ShellCheck: SC2312 – Consider invoking this command separately to avoid masking its return value (or use '|| true' to ignore).

# SC2312 – ShellCheck Wiki

[See this page on GitHub](https://github.com/koalaman/shellcheck/wiki/SC2312)

[Sitemap](index.html)

## Consider invoking this command separately to avoid masking its return value (or use '|| true' to ignore).

### Optional - `check-extra-masked-return`

This is an [optional](optional) rule, which means that it has a special "long name" and is not enabled by default. See the [optional](optional) page for more details. In short, you have to enable it with the long name instead of the "SC" code like you would with a normal rule:

#### `.shellcheckrc`

```
enable=check-extra-masked-return # SC2312
```

### Problematic code:

```
#cb2-1set -e
#cb2-2cd "$(get_chroot_dir)/etc"
#cb2-3tar xf "${config}"
```

### Correct code:

```
#cb3-1set -e
#cb3-2dir="$(get_chroot_dir)"
#cb3-3cd "${dir}/etc"
#cb3-4tar xf "${config}"
```

### Correct code: (with correction)

```
#cb4-1set -e
#cb4-2dir="$(get_chroot_dir)"
#cb4-3[[ -d "${dir}" ]] || exit 1
#cb4-4cd "${dir}/etc"
#cb4-5tar xf "${config}"
```

### Rationale:

In the problematic example, the exit code for `get_chroot_dir` is ignored because it is used in a command substitution in the argument of another command.

If the command shows `error: Can't determine chroot` and exits with failure without outputting a directory, then the command being run will be `cd "/etc"` and the script will proceed to overwrite the host system's configuration.

By assigning it to a variable first, the exit code of the command will propagate into the exit code of the assignment, so that it can be checked explicitly with `if` or implicitly with `set -e`.

### Exceptions:

If you don't care about the command's exit status, already handle it through a side channel like `<(cmd; echo $? > status)`, or (in the case of background processes and process substitution) wait on the result like `<(cmd) ; wait $!`, then you can either [ignore](ignore) the suggestion with a directive, or use `|| true` (or `|| :`) to suppress it.

#### Handling process substitution failures

Note that you can combine [file
descriptor duplication](https://www.gnu.org/software/bash/manual/html_node/Redirections.html#Duplicating-File-Descriptors) with `wait` to reference process substitution output (or input) while retaining the exit codes of those processes. For example:

```
#cb5-1generate_data() {
#cb5-2    declare i
#cb5-3    for (( i = 0 ; i < 5 ; ++i ))
#cb5-4    do
#cb5-5        date -d "$RANDOM hours"
#cb5-6    done
#cb5-7}
#cb5-8
#cb5-9consume_data() {
#cb5-10    declare line
#cb5-11    while IFS= read -r line
#cb5-12    do
#cb5-13        echo Consuming line: "$line"
#cb5-14    done
#cb5-15}
#cb5-16
#cb5-17declare \
#cb5-18    input_file_descriptor \
#cb5-19    process
#cb5-20
#cb5-21# The following statement
#cb5-22#
#cb5-23# - uses process substitution to allow us to read the output of `generate_data`
#cb5-24#   via a filename and
#cb5-25# - duplicates the file descriptor for that file so that it is not
#cb5-26#   immediately closed
#cb5-27#
#cb5-28# Note that process substitution uses either `pipe(2)` or named pipes (FIFOs)
#cb5-29# with `O_RDONLY` or `O_WRONLY`, and so the file descriptor that is duplicated
#cb5-30# via `[N]<&WORD` is only opened for reads
#cb5-31exec {input_file_descriptor}< <(
#cb5-32    generate_data
#cb5-33)
#cb5-34process=$!
#cb5-35
#cb5-36# Returns non-zero if `consume_data` does
#cb5-37consume_data <&"$input_file_descriptor"
#cb5-38
#cb5-39# Returns non-zero if `generate_data` does
#cb5-40wait "$process"
```

This can be particularly helpful with `readarray` for robust array handling

### Related resources:

[https://mywiki.wooledge.org/BashPitfalls#cmd1_.26.26_cmd2_.7C.7C_cmd3](https://mywiki.wooledge.org/BashPitfalls#cmd1_.26.26_cmd2_.7C.7C_cmd3)

- Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!

[ShellCheck](https://www.shellcheck.net) is a static analysis tool for shell scripts. This page is part of its documentation.

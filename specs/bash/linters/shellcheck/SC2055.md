ShellCheck: SC2055 – You probably wanted `&&` here, otherwise it's always true.

# SC2055 – ShellCheck Wiki

[See this page on GitHub](https://github.com/koalaman/shellcheck/wiki/SC2055)

[Sitemap](index.html)

## You probably wanted `&&` here, otherwise it's always true.

### Problematic code:

```
#cb1-1if [[ $1 != foo || $1 != bar ]]
#cb1-2then
#cb1-3  echo "$1 is not foo or bar"
#cb1-4fi
```

### Correct code:

```
#cb2-1if [[ $1 != foo && $1 != bar ]]
#cb2-2then
#cb2-3  echo "$1 is not foo or bar"
#cb2-4fi
```

### Rationale:

This is not a bash issue, but a simple, common logical mistake applicable to all languages.

`[[ $1 != foo || $1 != bar ]]` is always true (when `foo != bar`):

- If `$1 = foo` then `$1 != bar` is true, so the statement is true.
- If `$1 = bar` then `$1 != foo` is true, so the statement is true.
- If `$1 = cow` then `$1 != foo` is true, so the statement is true.

`[[ $1 != foo && $1 != bar ]]` matches when `$1` is neither `foo` nor `bar`:

- If `$1 = foo`, then `$1 != foo` is false, so the statement is false.
- If `$1 = bar`, then `$1 != bar` is false, so the statement is false.
- If `$1 = cow`, then both `$1 != foo` and `$1  != bar` is true, so the statement is true.

This statement is identical to `! [[ $1 = foo || $1 = bar ]]`, which also works correctly.

### Exceptions

Rare.

- If I want to check that $FOO, $BAR and $COW are all equal:

```
#cb3-1if [[ $FOO != $BAR || $FOO != $COW ]]
#cb3-2then
#cb3-3    echo "$FOO and $BAR and $COW are not all equal"
#cb3-4fi
```

[ShellCheck](https://www.shellcheck.net) is a static analysis tool for shell scripts. This page is part of its documentation.

ShellCheck: SC2031 – var was modified in a subshell. That change might be lost.

# SC2031 – ShellCheck Wiki

[See this page on GitHub](https://github.com/koalaman/shellcheck/wiki/SC2031)

[Sitemap](index.html)

# var was modified in a subshell. That change might be lost.

### Problematic code:

There are many ways of accidentally creating subshells, but a common one is piping to a loop:

```
#cb1-1n=0
#cb1-2printf "%s\n" {1..10} | while read i; do (( n+=i )); done
#cb1-3echo $n
```

### Correct code:

```
#cb2-1# Bash specific: process substitution. Also try shopts like lastpipe.
#cb2-2n=0
#cb2-3while read i; do (( n+=i )); done < <(printf "%s\n" {1..10})
#cb2-4echo $n
```

In `sh`, temporary files, FIFOs or file descriptors can be used instead. When the output of the command can be stored to a variable before entering the loop, here documents are a preferable alternative.

```
#cb3-1n=0
#cb3-2SUMMANDS="1
#cb3-32
#cb3-43
#cb3-54
#cb3-65
#cb3-76
#cb3-87
#cb3-98
#cb3-109
#cb3-1110
#cb3-12"
#cb3-13while read i; do n=$(( n + i )); done <<SUMMANDS_HEREDOC_INPUT
#cb3-14$SUMMANDS
#cb3-15SUMMANDS_HEREDOC_INPUT
#cb3-16echo $n
```

With Bash 4.2+ you can also use `shopt -s lastpipe` which will change the pipe behaviour to be similar to Ksh and Zsh (see Rationale below) [as
long as job control is not active](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html) (e.g. inside a script):

```
#cb4-1#!/usr/bin/env bash
#cb4-2shopt -s lastpipe
#cb4-3n=0
#cb4-4printf "%s\n" {1..10} | while read i; do (( n+=i )); done
#cb4-5echo $n
```

### Rationale:

Variables set in subshells are not available outside the subshell. This is a wide topic, and better described on the [Wooledge Bash
Wiki](http://mywiki.wooledge.org/BashFAQ/024).

Here are some constructs that cause subshells (shellcheck may not warn about all of them). In each case, you can replace `subshell1` by a command or function that sets a variable, e.g. simply `var=foo`, and the variable will appear to be unset after the command is run. Similarly, you can replace `regular` with `var=foo`, and it will be set afterwards:

Pipelines:

```
#cb5-1subshell1 | subshell2 | subshell3    # Dash, Ash, Bash (default)
#cb5-2subshell1 | subshell2 | regular      # Ksh, Zsh, Bash (with lastpipe=on and no job control)
```

Command substitution:

```
#cb6-1regular "$(subshell1)" "`subshell2`"
```

Process substitution:

```
#cb7-1regular <(subshell1) >(subshell2)
```

Some forms of grouping:

```
#cb8-1( subshell )
#cb8-2{ regular; }
```

Backgrounding:

```
#cb9-1subshell1 &
#cb9-2subshell2 &
```

Anything executed by external processes:

```
#cb10-1find . -exec subshell1 {} \;
#cb10-2find . -print0 | xargs -0 subshell2
#cb10-3sudo subshell3
#cb10-4su -c subshell4
```

This applies not only to setting variables, but also setting shell options and changing directories.

### Exceptions

You can ignore this error if you don't care that the changes aren't reflected, because work on the value branches and shouldn't be recombined.

### Related resources:

- [BashFaq: I set
variables in a loop that's in a pipeline. Why do they disappear after
the loop terminates?](https://mywiki.wooledge.org/BashFAQ/024)
- [Bash
Pitfalls: grep foo bar | while read -r; do ((count++)); done](https://mywiki.wooledge.org/BashPitfalls#pf8)
- [StackOverflow:
A variable modified inside a while loop is not remembered](https://stackoverflow.com/questions/16854280/a-variable-modified-inside-a-while-loop-is-not-remembered)

[ShellCheck](https://www.shellcheck.net) is a static analysis tool for shell scripts. This page is part of its documentation.

ShellCheck: SC2039 – In POSIX sh, *something* is undefined.

# SC2039 – ShellCheck Wiki

[See this page on GitHub](https://github.com/koalaman/shellcheck/wiki/SC2039)

[Sitemap](index.html)

## In POSIX sh, something is undefined.

Note: This warning has been retired in favor of individual SC3xxx warnings for each individual issue. Removed in [V0.7.2
- 2021-04-19](https://github.com/koalaman/shellcheck/commit/cfd68ee0c2ebfd0ab08a1d4bf628162b454dc207)

You have declared that your script works with `/bin/sh`, but you are using features that have undefined behavior according to the POSIX specification.

It may currently work for you, but it can or will fail on other OS, the same OS with different configurations, from different contexts (like initramfs/chroot), or in different versions of the same OS, including future updates to your current system.

Either declare that your script requires a specific shell like `#!/bin/bash` or `#!/bin/dash`, or rewrite the script in a portable way.

For help with rewrites, the Ubuntu wiki has [a list of portability
issues](https://wiki.ubuntu.com/DashAsBinSh) that broke people's `#!/bin/sh` scripts when Ubuntu switched from Bash to Dash. See also [Bashism](http://mywiki.wooledge.org/Bashism) on wooledge's wiki. ShellCheck may not warn about all these issues.

### `$'c-style-escapes'`

bash, ksh:

```
#cb1-1a=$' \t\n'
```

POSIX:

```
#cb2-1a="$(printf '%b_' ' \t\n')"; a="${a%_}" # protect trailing \n
```

Want some good news? See [http://austingroupbugs.net/view.php?id=249#c590](http://austingroupbugs.net/view.php?id=249#c590).

### Testing Equality

`==` operator is not supported in POSIX `sh`

Bash:

```
#cb3-1if [ "$a" == "$b" ]; then
#cb3-2    echo "equal"
#cb3-3fi
```

POSIX:

```
#cb4-1if [ "$a" = "$b" ]; then
#cb4-2    echo "equal"
#cb4-3fi
```

### `$"msgid"`

Bash:

```
#cb5-1echo $"foo $(bar) baz"
```

POSIX:

```
#cb6-1. gettext.sh # GNU Gettext sh library
#cb6-2# ...
#cb6-3barout=$(bar)
#cb6-4eval_gettext 'foo $barout baz' # See GNU Gettext doc for more info.
```

Or you can change them to normal double quotes so you go without `gettext`.

### `${var:1}` (substring expansion)

[https://wiki.ubuntu.com/DashAsBinSh#A.24.7Bfoo:3.5B:1.5D.7D](https://wiki.ubuntu.com/DashAsBinSh#A.24.7Bfoo:3.5B:1.5D.7D)

### Arithmetic `for` loops

Bash:

```
#cb7-1for ((init; test; next)); do foo; done
```

POSIX:

```
#cb8-1: $((init))
#cb8-2while [ $((test)) -ne 0 ]; do foo; : $((next)); done
```

### Arithmetic exponentiation

Bash:

```
#cb9-1printf "%s\n" "$(( 2**63 ))"
```

POSIX:

The POSIX standard does not allow for exponents. However, you can replicate them completely built-in using a POSIX compatible function. As an example, the `pow` function from [here](http://unix.stackexchange.com/a/7925).

```
#cb10-1pow() {
#cb10-2    set -- "$1" "$2" 1
#cb10-3    while [ "$2" -gt 0 ]; do
#cb10-4      set -- "$1" $(($2-1)) $(($1*$3))
#cb10-5    done
#cb10-6    # %d = signed decimal, %u = unsigned decimal
#cb10-7    # Either should overflow to 0
#cb10-8    printf "%d\n" "$3"
#cb10-9}
```

To compare:

```
#cb11-1$ echo "$(( 2**62 ))"
#cb11-24611686018427387904
#cb11-3$ pow 2 62
#cb11-44611686018427387904
```

Alternatively, if you don't mind using an external program, you can use `bc`. Be aware though: `bash` and other programs may abide by a certain maximum integer that `bc` does not (for `bash` that's: 64-bit signed long int, failing back to 32-bit signed long int).

Example:

```
#cb12-1# Note the overflow that gives a negative number
#cb12-2$ echo "$(( 2**63 ))"
#cb12-3-9223372036854775808
#cb12-4
#cb12-5# No such problem
#cb12-6$ echo 2^63 | bc
#cb12-79223372036854775808
#cb12-8
#cb12-9# 'bc' just keeps on going
#cb12-10$ echo 2^1280 | bc
#cb12-1120815864389328798163850480654728171077230524494533409610638224700807\
#cb12-1221611934672059602447888346464836968484322790856201558276713249664692\
#cb12-1398162798132113546415258482590187784406915463666993231671009459188410\
#cb12-1495379622423387354295096957733925002768876520583464697770622321657076\
#cb12-1583317005651120933244966378183760369413644440628104205339687097746591\
#cb12-166057756101739472373801429441421111406337458176
```

### standalone `((..))`

Bash:

```
#cb13-1((a=c+d))
#cb13-2((d)) && echo d is true.
```

POSIX:

```
#cb14-1: $((a=c+d)) # discard the output of the arith expn with `:` command
#cb14-2[ $((d)) -ne 0 ] && echo d is true. # manually check non-zero => true
```

### `select` loops

It takes extra care over terminal columns to make select loop look like bash's, which generates a list with multiple items on one line, or like `ls`.

It is, however, still possible to make a naive translation for `select foo in bar baz; do eat; done`:

```
#cb15-1while
#cb15-2  _i=0 _foo= foo=
#cb15-3  for _name in bar baz; do echo "$((_i+=1))) $_name"; done
#cb15-4  printf '$# '; read _foo
#cb15-5do
#cb15-6  case _foo in 1) foo=bar;; 2) foo=baz;; *) continue;; esac
#cb15-7  eat
#cb15-8done
```

### Here-strings

Bash, ksh:

```
#cb16-1read aaa bbb <<< $(grep foo bar)
```

POSIX:

```
#cb17-1read aaa bbb << EOF
#cb17-2$(grep foo bar)
#cb17-3EOF
```

### echo flags

See [https://unix.stackexchange.com/tags/echo/info](https://unix.stackexchange.com/tags/echo/info).

### `${var/pat/replacement}`

Bash:

```
#cb18-1echo "${TERM/%-256*}"
```

POSIX:

```
#cb19-1echo "$TERM" | sed -e 's/-256.*$//g'
#cb19-2# Special case for this since we are matching the end (the start [#] also works):
#cb19-3echo "${TERM%-256*}"
```

### `printf %q`

Bash:

```
#cb20-1printf '%q ' "$@"
```

POSIX:

```
#cb21-1# TODO: Interpret it back to printf escapes for hard-to-copy chars like \t?
#cb21-2# See also: http://git.savannah.gnu.org/cgit/libtool.git/tree/gl/build-aux/funclib.sh?id=c60e054#n1029
#cb21-3reuse_quote()(
#cb21-4  for i; do
#cb21-5    __i_quote=$(printf '%s\n' "$i" | sed -e "s/'/'\\\\''/g"; echo x)
#cb21-6    printf "'%s'" "${__i_quote%x}"
#cb21-7  done
#cb21-8)
#cb21-9reuse_quote "$@"
```

### `jobs` flags

The only acceptable flags under POSIX sh for `jobs` are `-l` and `-p` ([see
spec](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/jobs.html)). Common flags supported by other shells are `-s` and `-r`, to check for stopped/suspended jobs and running jobs. A portable alternative is using `grep` or `awk`:

```
#cb22-1"$(jobs | awk '/(S|s)(topped|uspended)/')" # instead of jobs -s
#cb22-2"$(jobs | awk '/(R|r)(unning)/')"          # instead of jobs -r
```

Although the state of stopped jobs is `Stopped` in Bash and dash, and it's the one specified by POSIX, `Suspended` is also a valid alternative (but Zsh happens to not respect the capitalization, that's why we try to match `suspended`). Similarly, the state of running jobs is `Running` according to POSIX. Bash and dash respect this, but Zsh uses `running`.

### Redirect both stdout and stderr

Change:

```
>& and &>
```

To:

```
command > file 2>&1 or command 2>&1 | othercommand
```

No Comments / Exceptions

### Prefixing signal names with `SIG`

Instead of e.g.:

```
#cb25-1trap my_handler SIGTERM
```

use:

```
#cb26-1trap my_handler TERM
#cb26-2# or (`trap -l` for a list of signal numbers; not every one is portable!)
#cb26-3trap my_handler 15
```

### disown

Bash:

```
#cb27-1<command>
#cb27-2disown %<command>
```

POSIX:

```
#cb28-1nohup <command>
```

Note that while `nohup` can be used to achieve the same result, their semantics is different. Also note that `nohup` will, by default, redirect input and output.

## Errors with changed codes

Some errors, currently having their own pages, were linked to this page in older ShellCheck versions.

- [SC3026: In POSIX sh, ^ in place of
! in glob bracket expressions is undefined.](SC3026)

## Exception

Depends on what your expected POSIX shell providers would use.

Some features have POSIX proposals:

- `local`: [https://www.austingroupbugs.net/bug_view_page.php?bug_id=767](https://www.austingroupbugs.net/bug_view_page.php?bug_id=767)
- `$'c-style-escape'`: see above

[ShellCheck](https://www.shellcheck.net) is a static analysis tool for shell scripts. This page is part of its documentation.

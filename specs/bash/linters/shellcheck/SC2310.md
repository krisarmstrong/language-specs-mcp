ShellCheck: SC2310 – This function is invoked in an 'if' condition so set -e will be disabled. Invoke separately if failures should cause the script to exit.

# SC2310 – ShellCheck Wiki

[See this page on GitHub](https://github.com/koalaman/shellcheck/wiki/SC2310)

[Sitemap](index.html)

## This function is invoked in an 'if' condition so set -e will be disabled. Invoke separately if failures should cause the script to exit.

### Optional - `check-set-e-suppressed`

This is an [optional](optional) rule, which means that it has a special "long name" and is not enabled by default. See the [optional](optional) page for more details. In short, you have to enable it with the long name instead of the "SC" code like you would with a normal rule:

#### `.shellcheckrc`

```
enable=check-set-e-suppressed # SC2310
```

### Problematic code:

```
#cb2-1#!/bin/sh
#cb2-2#shellcheck enable=check-set-e-suppressed
#cb2-3
#cb2-4set -e
#cb2-5
#cb2-6backup() {
#cb2-7  cp *.txt /backup
#cb2-8  rm *.txt            # Runs even if copy fails!
#cb2-9}
#cb2-10
#cb2-11if backup
#cb2-12then
#cb2-13    echo "Backup successful"
#cb2-14fi
```

### Correct code:

```
#cb3-1#!/bin/sh
#cb3-2#shellcheck enable=check-set-e-suppressed
#cb3-3
#cb3-4set -e
#cb3-5
#cb3-6backup() {
#cb3-7  cp *.txt /backup
#cb3-8  rm *.txt
#cb3-9}
#cb3-10
#cb3-11backup
#cb3-12echo "Backup successful"
```

### Rationale:

ShellCheck found a function used as a condition in a script where `set -e` is enabled. This means that the function will run without `set -e`, and will power through any errors.

This applies to `if`, `while`, and `until` statements, commands negated with `!`, as well as the left-hand side of `||` and `&&`. It does not matter how deeply the command is nested in such a structure.

In the problematic example, the intent was that an error like `cp: error writing '/backup/important.txt': No space left on device` would cause the script to abort. Instead, since the function is invoked in an `if` statement, the script will proceed to delete all the files even though it failed to back them up.

The fix is to call it outside of an `if` statement. There is no point in checking whether the command succeeded, since the script would abort if it didn't. You may also want to consider replacing `set -e` with explicit `|| exit` after every relevant command to avoid such surprises.

### Exceptions:

If you don't care that the function runs without `set -e`, you can disable this warning.

### Related resources:

- BashFaq #105: [Why
doesn't set -e (or set -o errexit, or trap ERR) do what I
expected?](https://mywiki.wooledge.org/BashFAQ/105)

[ShellCheck](https://www.shellcheck.net) is a static analysis tool for shell scripts. This page is part of its documentation.

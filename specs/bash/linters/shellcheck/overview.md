<h1>ShellCheck Wiki Sitemap</h1>
The wiki is maintained <a href="https://github.com/koalaman/shellcheck/wiki">on GitHub</a>. This page is primarily for the benefit of search engines.
<ul>
<li><a href='SC1000'>SC1000</a> &ndash; `$` is not used specially and should therefore be escaped.</li>
<li><a href='SC1001'>SC1001</a> &ndash; This `\o` will be a regular 'o' in this context.</li>
<li><a href='SC1003'>SC1003</a> &ndash; Want to escape a single quote? `echo 'This is how it'\''s done'`.</li>
<li><a href='SC1004'>SC1004</a> &ndash; This backslash+linefeed is literal. Break outside single quotes if you just want to break the line.</li>
<li><a href='SC1007'>SC1007</a> &ndash; Remove space after `=` if trying to assign a value (or for empty string, use `var=""` ... ).</li>
<li><a href='SC1008'>SC1008</a> &ndash; This shebang was unrecognized. ShellCheck only supports sh/bash/dash/ksh. Add a 'shell' directive to specify.</li>
<li><a href='SC1009'>SC1009</a> &ndash; The mentioned parser error was in ...</li>
<li><a href='SC1010'>SC1010</a> &ndash; Use semicolon or linefeed before `done` (or quote to make it literal).&#13;</li>
<li><a href='SC1011'>SC1011</a> &ndash; This apostrophe terminated the single quoted string!</li>
<li><a href='SC1012'>SC1012</a> &ndash; `\t` is just literal `t` here. For tab, use `"$(printf '\t')"` instead.</li>
<li><a href='SC1014'>SC1014</a> &ndash; Use `if cmd; then ..` to check exit code, or `if [ "$(cmd)" = .. ]` to check output.</li>
<li><a href='SC1015'>SC1015</a> &ndash; This is a Unicode double quote. Delete and retype it.</li>
<li><a href='SC1016'>SC1016</a> &ndash; This is a Unicode single quote. Delete and retype it.</li>
<li><a href='SC1017'>SC1017</a> &ndash; Literal carriage return. Run script through `tr -d '\r'` .</li>
<li><a href='SC1018'>SC1018</a> &ndash; This is a Unicode non-breaking space. Delete it and retype as space.</li>
<li><a href='SC1019'>SC1019</a> &ndash; Expected this to be an argument to the unary condition.</li>
<li><a href='SC1020'>SC1020</a> &ndash; You need a space before the `]` or `]]`</li>
<li><a href='SC1026'>SC1026</a> &ndash; If grouping expressions inside `[[..]]`, use `( .. )`.</li>
<li><a href='SC1027'>SC1027</a> &ndash; Expected another argument for this operator.</li>
<li><a href='SC1028'>SC1028</a> &ndash; In `[..]` you have to escape `\( \)` or preferably combine `[..]` expressions.</li>
<li><a href='SC1029'>SC1029</a> &ndash; In `[[..]]` you shouldn't escape `(` or `)`.</li>
<li><a href='SC1033'>SC1033</a> &ndash; Test expression was opened with double `[[` but closed with single `]`. Make sure they match.</li>
<li><a href='SC1034'>SC1034</a> &ndash; Test expression was opened with single `[` but closed with double `]]`. Make sure they match.</li>
<li><a href='SC1035'>SC1035</a> &ndash; You need a space here</li>
<li><a href='SC1036'>SC1036</a> &ndash; `(` is invalid here. Did you forget to escape it?</li>
<li><a href='SC1037'>SC1037</a> &ndash; Braces are required for positionals over 9, e.g. `${10}`.</li>
<li><a href='SC1038'>SC1038</a> &ndash; Shells are space sensitive. Use `&lt; &lt;(cmd)`, not `&lt;&lt;(cmd)`.</li>
<li><a href='SC1039'>SC1039</a> &ndash; Remove indentation before end token (or use `&lt;&lt;-` and indent with tabs).</li>
<li><a href='SC1040'>SC1040</a> &ndash; When using `&lt;&lt;-`, you can only indent with tabs.</li>
<li><a href='SC1041'>SC1041</a> &ndash; Found `eof` further down, but not on a separate line.</li>
<li><a href='SC1043'>SC1043</a> &ndash; Found EOF further down, but with wrong casing.</li>
<li><a href='SC1044'>SC1044</a> &ndash; Couldn't find end token `EOF` in the here document.</li>
<li><a href='SC1045'>SC1045</a> &ndash; It's not `foo &amp;; bar`, just `foo &amp; bar`.</li>
<li><a href='SC1046'>SC1046</a> &ndash; Couldn't find `fi` for this `if`.</li>
<li><a href='SC1047'>SC1047</a> &ndash; Expected `fi` matching previously mentioned `if`.</li>
<li><a href='SC1048'>SC1048</a> &ndash; Can't have empty then clauses (use `true` as a no-op).</li>
<li><a href='SC1049'>SC1049</a> &ndash; Did you forget the `then` for this `if`?</li>
<li><a href='SC1050'>SC1050</a> &ndash; Expected `then`.</li>
<li><a href='SC1051'>SC1051</a> &ndash; Semicolons directly after `then` are not allowed. Just remove it.</li>
<li><a href='SC1052'>SC1052</a> &ndash; Semicolons directly after `then` are not allowed. Just remove it.</li>
<li><a href='SC1053'>SC1053</a> &ndash; Semicolons directly after `else` are not allowed. Just remove it.</li>
<li><a href='SC1054'>SC1054</a> &ndash; You need a space after the `{`.</li>
<li><a href='SC1055'>SC1055</a> &ndash; You need at least one command here. Use `true;` as a no-op.</li>
<li><a href='SC1056'>SC1056</a> &ndash; Expected a `}`. If you have one, try a `;` or `\n` in front of it.</li>
<li><a href='SC1057'>SC1057</a> &ndash; Did you forget the `do` for this loop?</li>
<li><a href='SC1058'>SC1058</a> &ndash; Expected `do`.</li>
<li><a href='SC1059'>SC1059</a> &ndash; Semicolon is not allowed directly after `do`. You can just delete it.</li>
<li><a href='SC1060'>SC1060</a> &ndash; Can't have empty do clauses (use `true` as a no-op)</li>
<li><a href='SC1061'>SC1061</a> &ndash; Couldn't find `done` for this `do`.</li>
<li><a href='SC1062'>SC1062</a> &ndash; Expected `done` matching previously mentioned `do`.</li>
<li><a href='SC1063'>SC1063</a> &ndash; You need a line feed or semicolon before the `do`.</li>
<li><a href='SC1064'>SC1064</a> &ndash; Expected a `{` to open the function definition.</li>
<li><a href='SC1065'>SC1065</a> &ndash; Trying to declare parameters? Don't. Use `()` and refer to params as `$1`, `$2`, &#x2026;</li>
<li><a href='SC1066'>SC1066</a> &ndash; Don't use `$` on the left side of assignments.</li>
<li><a href='SC1067'>SC1067</a> &ndash; For indirection, use arrays, `declare "var$n=value"`, or (for sh) `read`/`eval`</li>
<li><a href='SC1068'>SC1068</a> &ndash; Don't put spaces around the `=` in assignments.</li>
<li><a href='SC1069'>SC1069</a> &ndash; You need a space before the `[`.</li>
<li><a href='SC1070'>SC1070</a> &ndash; Parsing stopped here. Mismatched keywords or invalid parentheses?</li>
<li><a href='SC1071'>SC1071</a> &ndash; ShellCheck only supports sh/bash/dash/ksh scripts. Sorry!</li>
<li><a href='SC1072'>SC1072</a> &ndash; Unexpected ..</li>
<li><a href='SC1073'>SC1073</a> &ndash; Couldn't parse this (thing). Fix to allow more checks.</li>
<li><a href='SC1074'>SC1074</a> &ndash; Did you forget the `;;` after the previous case item?</li>
<li><a href='SC1075'>SC1075</a> &ndash; Use `elif` instead of `else if`.</li>
<li><a href='SC1076'>SC1076</a> &ndash; Trying to do math? Use e.g. `[ $((i/2+7)) -ge 18 ]`.</li>
<li><a href='SC1077'>SC1077</a> &ndash; For command expansion, the tick should slant left (`` ` `` vs `&#xB4;`).</li>
<li><a href='SC1078'>SC1078</a> &ndash; Did you forget to close this double-quoted string?</li>
<li><a href='SC1079'>SC1079</a> &ndash; This is actually an end quote, but due to next char it looks suspect.</li>
<li><a href='SC1080'>SC1080</a> &ndash; You need `\` before line feeds to break lines in `[ ]`.</li>
<li><a href='SC1081'>SC1081</a> &ndash; Scripts are case-sensitive. Use `if`, not `If`.</li>
<li><a href='SC1082'>SC1082</a> &ndash; This file has a UTF-8 BOM. Remove it with: `LC_CTYPE=C sed '1s/^...//' &lt; yourscript`.</li>
<li><a href='SC1083'>SC1083</a> &ndash; This `{`/`}` is literal. Check if `;` is missing or quote the expression.</li>
<li><a href='SC1084'>SC1084</a> &ndash; Use `#!`, not `!#`, for the shebang.</li>
<li><a href='SC1085'>SC1085</a> &ndash; Did you forget to move the ;; after extending this case item?</li>
<li><a href='SC1086'>SC1086</a> &ndash; Don't use `$` on the iterator name in for loops.</li>
<li><a href='SC1087'>SC1087</a> &ndash; Use braces when expanding arrays, e.g. `${array[idx]}` (or `${var}[..` to quiet).</li>
<li><a href='SC1088'>SC1088</a> &ndash; Parsing stopped here. Invalid use of parentheses?</li>
<li><a href='SC1089'>SC1089</a> &ndash; Parsing stopped here. Is this keyword correctly matched up?</li>
<li><a href='SC1090'>SC1090</a> &ndash; Can't follow non-constant source. Use a directive to specify location</li>
<li><a href='SC1091'>SC1091</a> &ndash; Not following: (error message here)</li>
<li><a href='SC1092'>SC1092</a> &ndash; Stopping at 100 `source` frames :O</li>
<li><a href='SC1094'>SC1094</a> &ndash; Parsing of sourced file failed. Ignoring it.</li>
<li><a href='SC1095'>SC1095</a> &ndash; You need a space or linefeed between the function name and body.</li>
<li><a href='SC1097'>SC1097</a> &ndash; Unexpected `==`. For assignment, use `=`. For comparison, use `[`/`[[`.</li>
<li><a href='SC1098'>SC1098</a> &ndash; Quote/escape special characters when using `eval`, e.g. `eval "a=(b)"`.</li>
<li><a href='SC1099'>SC1099</a> &ndash; You need a space before the `#`.</li>
<li><a href='SC1100'>SC1100</a> &ndash; This is a Unicode dash. Delete and retype as ASCII minus.</li>
<li><a href='SC1101'>SC1101</a> &ndash; Delete trailing spaces after `\` to break line (or use quotes for literal space).</li>
<li><a href='SC1102'>SC1102</a> &ndash; Shells disambiguate `$((` differently or not at all. For `$(command substitution)`, add space after `$(` . For `$((arithmetics))`, fix parsing errors.</li>
<li><a href='SC1103'>SC1103</a> &ndash; This shell type is unknown. Use e.g. `sh` or `bash`.</li>
<li><a href='SC1104'>SC1104</a> &ndash; Use `#!`, not just `!`, for the shebang.</li>
<li><a href='SC1105'>SC1105</a> &ndash; Shells disambiguate `((` differently or not at all. If the first `(` should start a subshell, add a space after it.</li>
<li><a href='SC1106'>SC1106</a> &ndash; In arithmetic contexts, use `&lt;` instead of `-lt`</li>
<li><a href='SC1107'>SC1107</a> &ndash; This directive is unknown. It will be ignored.</li>
<li><a href='SC1108'>SC1108</a> &ndash; You need a space before and after the `=` .</li>
<li><a href='SC1109'>SC1109</a> &ndash; This is an unquoted HTML entity. Replace with corresponding character.</li>
<li><a href='SC1110'>SC1110</a> &ndash; This is a Unicode quote. Delete and retype it (or quote to make literal).</li>
<li><a href='SC1111'>SC1111</a> &ndash; This is a Unicode quote. Delete and retype it (or ignore/singlequote for literal).</li>
<li><a href='SC1112'>SC1112</a> &ndash; This is a Unicode quote. Delete and retype it (or ignore/doublequote for literal).</li>
<li><a href='SC1113'>SC1113</a> &ndash; Use `#!`, not just `#`, for the shebang.</li>
<li><a href='SC1114'>SC1114</a> &ndash; Remove leading spaces before the shebang.</li>
<li><a href='SC1115'>SC1115</a> &ndash; Remove spaces between `#` and `!` in the shebang.</li>
<li><a href='SC1116'>SC1116</a> &ndash; Missing `$` on a `$((..))` expression? (or use `( (` for arrays).</li>
<li><a href='SC1117'>SC1117</a> &ndash; Backslash is literal in `"\n"`. Prefer explicit escaping: `"\\n"`.</li>
<li><a href='SC1118'>SC1118</a> &ndash; Delete whitespace after the here-doc end token.</li>
<li><a href='SC1119'>SC1119</a> &ndash; Add a linefeed between end token and terminating `)`.</li>
<li><a href='SC1120'>SC1120</a> &ndash; No comments allowed after here-doc token. Comment the next line instead.</li>
<li><a href='SC1121'>SC1121</a> &ndash; Add `;`/`&amp;` terminators (and other syntax) on the line with the `&lt;&lt;`, not here.</li>
<li><a href='SC1122'>SC1122</a> &ndash; Nothing allowed after end token. To continue a command, put it on the line with the `&lt;&lt;`.</li>
<li><a href='SC1123'>SC1123</a> &ndash; ShellCheck directives are only valid in front of complete compound commands, like `if`, not e.g. individual `elif` branches.</li>
<li><a href='SC1124'>SC1124</a> &ndash; ShellCheck directives are only valid in front of complete commands like `case` statements, not individual case branches.</li>
<li><a href='SC1125'>SC1125</a> &ndash; Invalid `key=value` pair in directive</li>
<li><a href='SC1126'>SC1126</a> &ndash; Place shellcheck directives before commands, not after.</li>
<li><a href='SC1127'>SC1127</a> &ndash; Was this intended as a comment? Use `#` in sh.</li>
<li><a href='SC1128'>SC1128</a> &ndash; The shebang must be on the first line. Delete blanks and move comments.</li>
<li><a href='SC1129'>SC1129</a> &ndash; You need a space before the `!`.</li>
<li><a href='SC1130'>SC1130</a> &ndash; You need a space before the :.</li>
<li><a href='SC1131'>SC1131</a> &ndash; Use `elif` to start another branch.</li>
<li><a href='SC1132'>SC1132</a> &ndash; This `&amp;` terminates the command. Escape it or add space after `&amp;` to silence.</li>
<li><a href='SC1133'>SC1133</a> &ndash; Unexpected start of line. If breaking lines, `|`/`||`/`&amp;&amp;` should be at the end of the previous one.</li>
<li><a href='SC1134'>SC1134</a> &ndash; </li>
<li><a href='SC1135'>SC1135</a> &ndash; Prefer escape over ending quote to make `$` literal. Instead of `"It costs $"5`, use `"It costs \$5"`</li>
<li><a href='SC1136'>SC1136</a> &ndash; Unexpected characters after terminating `]`. Missing semicolon/linefeed?</li>
<li><a href='SC1137'>SC1137</a> &ndash; Missing second `(` to start arithmetic for ((;;)) loop</li>
<li><a href='SC1138'>SC1138</a> &ndash; Remove spaces between (( in arithmetic for loop.</li>
<li><a href='SC1139'>SC1139</a> &ndash; Use `||` instead of `-o` between test commands.</li>
<li><a href='SC1140'>SC1140</a> &ndash; Unexpected parameters after condition. Missing `&amp;&amp;`/`||`, or bad expression?</li>
<li><a href='SC1141'>SC1141</a> &ndash; Unexpected tokens after compound command. Bad redirection or missing `;`/`&amp;&amp;`/`||`/`|`?</li>
<li><a href='SC1142'>SC1142</a> &ndash; Use `done &lt; &lt;(cmd)` to redirect from process substitution (currently missing one `&lt;`).</li>
<li><a href='SC1143'>SC1143</a> &ndash; This backslash is part of a comment and does not continue the line.</li>
<li><a href='SC1144'>SC1144</a> &ndash; `external-sources` can only be enabled in .shellcheckrc, not in individual files.</li>
<li><a href='SC1145'>SC1145</a> &ndash; Unknown `external-sources` value. Expected `true`/`false`.</li>
<li><a href='SC2000'>SC2000</a> &ndash; See if you can use `${#variable}` instead</li>
<li><a href='SC2001'>SC2001</a> &ndash; See if you can use `${variable//search/replace}` instead.</li>
<li><a href='SC2002'>SC2002</a> &ndash; Useless cat. Consider `cmd &lt; file | ..` or `cmd file | ..` instead.</li>
<li><a href='SC2003'>SC2003</a> &ndash; expr is antiquated. Consider rewriting this using `$((..))`, `${}` or `[[  ]]`.</li>
<li><a href='SC2004'>SC2004</a> &ndash; `$`/`${}` is unnecessary on arithmetic variables.</li>
<li><a href='SC2005'>SC2005</a> &ndash; </li>
<li><a href='SC2006'>SC2006</a> &ndash; Use `$(...)` notation instead of legacy backticked `` `...` ``.</li>
<li><a href='SC2007'>SC2007</a> &ndash; Use `$((..))` instead of deprecated `$[..]`.</li>
<li><a href='SC2008'>SC2008</a> &ndash; `echo` doesn't read from stdin, are you sure you should be piping to it?</li>
<li><a href='SC2009'>SC2009</a> &ndash; Consider using `pgrep` instead of grepping `ps` output.</li>
<li><a href='SC2010'>SC2010</a> &ndash; Don't use `ls | grep`. Use a glob or a for loop with a condition to allow non-alphanumeric filenames.</li>
<li><a href='SC2011'>SC2011</a> &ndash; Use `find -print0` or `find -exec` to better handle non-alphanumeric filenames.</li>
<li><a href='SC2012'>SC2012</a> &ndash; Use `find` instead of `ls` to better handle non-alphanumeric filenames.</li>
<li><a href='SC2013'>SC2013</a> &ndash; To read lines rather than words, pipe/redirect to a `while read` loop.</li>
<li><a href='SC2014'>SC2014</a> &ndash; This will expand once before find runs, not per file found.</li>
<li><a href='SC2015'>SC2015</a> &ndash; Note that `A &amp;&amp; B || C` is not if-then-else. C may run when A is true.</li>
<li><a href='SC2016'>SC2016</a> &ndash; Expressions don't expand in single quotes, use double quotes for that.</li>
<li><a href='SC2017'>SC2017</a> &ndash; Increase precision by replacing `a/b*c` with `a*c/b`.</li>
<li><a href='SC2018'>SC2018</a> &ndash; Use `[:lower:]` to support accents and foreign alphabets.</li>
<li><a href='SC2019'>SC2019</a> &ndash; Use `[:upper:]` to support accents and foreign alphabets.</li>
<li><a href='SC2020'>SC2020</a> &ndash; `tr` replaces sets of chars, not words (mentioned due to duplicates).</li>
<li><a href='SC2021'>SC2021</a> &ndash; Don't use `[]` around ranges in `tr`, it replaces literal square brackets.</li>
<li><a href='SC2022'>SC2022</a> &ndash; Note that unlike globs, `o*` here matches `ooo` but not `oscar`.</li>
<li><a href='SC2023'>SC2023</a> &ndash; The shell may override `time` as seen in man time(1). Use `command time ..` for that one.</li>
<li><a href='SC2024'>SC2024</a> &ndash; `sudo` doesn't affect redirects. Use `..| sudo tee file`&#13;</li>
<li><a href='SC2025'>SC2025</a> &ndash; Make sure all escape sequences are enclosed in `\[..\]` to prevent line wrapping issues.</li>
<li><a href='SC2026'>SC2026</a> &ndash; This word is outside of quotes. Did you intend to `'nest '"'single quotes'"'` instead?</li>
<li><a href='SC2027'>SC2027</a> &ndash; The surrounding quotes actually unquote this. Remove or escape them.</li>
<li><a href='SC2028'>SC2028</a> &ndash; `echo` won't expand escape sequences. Consider `printf`.</li>
<li><a href='SC2029'>SC2029</a> &ndash; Note that, unescaped, this expands on the client side.</li>
<li><a href='SC2030'>SC2030</a> &ndash; Modification of var is local (to subshell caused by pipeline).</li>
<li><a href='SC2031'>SC2031</a> &ndash; var was modified in a subshell. That change might be lost.</li>
<li><a href='SC2032'>SC2032</a> &ndash; This function can't be invoked via su on line 42.</li>
<li><a href='SC2033'>SC2033</a> &ndash; Shell functions can't be passed to external commands. Use separate script or sh -c.</li>
<li><a href='SC2034'>SC2034</a> &ndash; foo appears unused. Verify it or export it.</li>
<li><a href='SC2035'>SC2035</a> &ndash; Use `./*glob*` or `-- *glob*` so names with dashes won't become options.</li>
<li><a href='SC2036'>SC2036</a> &ndash; If you wanted to assign the output of the pipeline, use `a=$(b | c)` .</li>
<li><a href='SC2037'>SC2037</a> &ndash; To assign the output of a command, use `var=$(cmd)` .</li>
<li><a href='SC2038'>SC2038</a> &ndash; Use `-print0`/`-0` or `find -exec +` to allow for non-alphanumeric filenames.</li>
<li><a href='SC2039'>SC2039</a> &ndash; In POSIX sh, *something* is undefined.</li>
<li><a href='SC2040'>SC2040</a> &ndash; `#!/bin/sh` was specified, so ____ is not supported, even when sh is actually bash.</li>
<li><a href='SC2041'>SC2041</a> &ndash; This is a literal string. To run as a command, use `$(..)` instead of `'..'` .</li>
<li><a href='SC2042'>SC2042</a> &ndash; Use spaces, not commas, to separate loop elements.</li>
<li><a href='SC2043'>SC2043</a> &ndash; This loop will only ever run once for a constant value. Did you perhaps mean to loop over `dir/*`, `$var` or `$(cmd)`?</li>
<li><a href='SC2044'>SC2044</a> &ndash; For loops over find output are fragile. Use `find -exec` or a `while read` loop.</li>
<li><a href='SC2045'>SC2045</a> &ndash; Iterating over ls output is fragile. Use globs.</li>
<li><a href='SC2046'>SC2046</a> &ndash; Quote this to prevent word splitting.</li>
<li><a href='SC2048'>SC2048</a> &ndash; Use `"$@"` (with quotes) to prevent whitespace problems.</li>
<li><a href='SC2049'>SC2049</a> &ndash; `=~` is for regex, but this looks like a glob. Use `=` instead.</li>
<li><a href='SC2050'>SC2050</a> &ndash; This expression is constant. Did you forget the `$` on a variable?</li>
<li><a href='SC2051'>SC2051</a> &ndash; Bash doesn't support variables in brace range expansions.&#13;</li>
<li><a href='SC2053'>SC2053</a> &ndash; Quote the rhs of `=` in `[[ ]]` to prevent glob matching.</li>
<li><a href='SC2054'>SC2054</a> &ndash; Use spaces, not commas, to separate array elements.</li>
<li><a href='SC2055'>SC2055</a> &ndash; You probably wanted `&amp;&amp;` here, otherwise it's always true.</li>
<li><a href='SC2056'>SC2056</a> &ndash; You probably wanted `&amp;&amp;` here</li>
<li><a href='SC2057'>SC2057</a> &ndash; Unknown binary operator.</li>
<li><a href='SC2058'>SC2058</a> &ndash; Unknown unary operator.</li>
<li><a href='SC2059'>SC2059</a> &ndash; Don't use variables in the `printf` format string. Use `printf "..%s.." "$foo"`.</li>
<li><a href='SC2060'>SC2060</a> &ndash; Quote parameters to `tr` to prevent glob expansion.</li>
<li><a href='SC2061'>SC2061</a> &ndash; Quote the parameter to `-name` so the shell won't interpret it.</li>
<li><a href='SC2062'>SC2062</a> &ndash; Quote the grep pattern so the shell won't interpret it.</li>
<li><a href='SC2063'>SC2063</a> &ndash; Grep uses regex, but this looks like a glob.</li>
<li><a href='SC2064'>SC2064</a> &ndash; Use single quotes, otherwise this expands now rather than when signalled.</li>
<li><a href='SC2065'>SC2065</a> &ndash; This is interpreted as a shell file redirection, not a comparison.</li>
<li><a href='SC2066'>SC2066</a> &ndash; Since you double-quoted this, it will not word split, and the loop will only run once.</li>
<li><a href='SC2067'>SC2067</a> &ndash; Missing `;` or `+` terminating `-exec`. You can't use `|`/`||`/`&amp;&amp;`, and `;` has to be a separate, quoted argument.</li>
<li><a href='SC2068'>SC2068</a> &ndash; Double quote array expansions to avoid re-splitting elements.</li>
<li><a href='SC2069'>SC2069</a> &ndash; To redirect stdout+stderr, `2&gt;&amp;1` must be last (or use `{ cmd &gt; file; } 2&gt;&amp;1` to clarify).</li>
<li><a href='SC2070'>SC2070</a> &ndash; `-n` doesn't work with unquoted arguments. Quote or use `[[ ]]`.</li>
<li><a href='SC2071'>SC2071</a> &ndash; `&gt;` is for string comparisons. Use `-gt` instead.</li>
<li><a href='SC2072'>SC2072</a> &ndash; Decimals are not supported. Either use integers only, or use `bc` or `awk` to compare.</li>
<li><a href='SC2073'>SC2073</a> &ndash; Escape `\&lt;` to prevent it redirecting (or switch to `[[ .. ]]`).</li>
<li><a href='SC2074'>SC2074</a> &ndash; Can't use `=~` in `[ ]`. Use `[[..]]` instead.</li>
<li><a href='SC2075'>SC2075</a> &ndash; Escaping `\&lt;` is required in `[..]`, but invalid in `[[..]]`</li>
<li><a href='SC2076'>SC2076</a> &ndash; Don't quote rhs of `=~`, it'll match literally rather than as a regex.</li>
<li><a href='SC2077'>SC2077</a> &ndash; You need spaces around the comparison operator.</li>
<li><a href='SC2078'>SC2078</a> &ndash; This expression is constant. Did you forget a `$` somewhere?</li>
<li><a href='SC2079'>SC2079</a> &ndash; `(( ))` doesn't support decimals. Use `bc` or `awk`.</li>
<li><a href='SC2080'>SC2080</a> &ndash; Numbers with leading 0 are considered octal.</li>
<li><a href='SC2081'>SC2081</a> &ndash; `[ .. ]` can't match globs. Use `[[ .. ]]` or grep.</li>
<li><a href='SC2082'>SC2082</a> &ndash; To expand via indirection, use `name="foo$n"; echo "${!name}"`.</li>
<li><a href='SC2083'>SC2083</a> &ndash; Don't add spaces after the slash in `./file`.</li>
<li><a href='SC2084'>SC2084</a> &ndash; Remove `$` or use `_=$((expr))` to avoid executing output.</li>
<li><a href='SC2086'>SC2086</a> &ndash; Double quote to prevent globbing and word splitting.</li>
<li><a href='SC2087'>SC2087</a> &ndash; Quote `EOF` to make here document expansions happen on the server side rather than on the client.</li>
<li><a href='SC2088'>SC2088</a> &ndash; Tilde does not expand in quotes. Use `$HOME`.</li>
<li><a href='SC2089'>SC2089</a> &ndash; Quotes/backslashes will be treated literally. Use an array.</li>
<li><a href='SC2090'>SC2090</a> &ndash; Quotes/backslashes in this variable will not be respected.</li>
<li><a href='SC2091'>SC2091</a> &ndash; Remove surrounding `$()` to avoid executing output (or use `eval` if intentional).</li>
<li><a href='SC2092'>SC2092</a> &ndash; Remove backticks to avoid executing output.</li>
<li><a href='SC2093'>SC2093</a> &ndash; Remove `exec ` if script should continue after this command.</li>
<li><a href='SC2094'>SC2094</a> &ndash; Make sure not to read and write the same file in the same pipeline.</li>
<li><a href='SC2095'>SC2095</a> &ndash; Use `ssh -n` to prevent ssh from swallowing stdin.</li>
<li><a href='SC2096'>SC2096</a> &ndash; On most OS, shebangs can only specify a single parameter.</li>
<li><a href='SC2097'>SC2097</a> &ndash; This assignment is only seen by the forked process.</li>
<li><a href='SC2098'>SC2098</a> &ndash; This expansion will not see the mentioned assignment.</li>
<li><a href='SC2099'>SC2099</a> &ndash; Use `$((..))` for arithmetics, e.g. `i=$((i + 2))`</li>
<li><a href='SC2100'>SC2100</a> &ndash; Use `$((..))` for arithmetics, e.g. `i=$((i + 2))`</li>
<li><a href='SC2101'>SC2101</a> &ndash; Named class needs outer `[]`, e.g. `[[:digit:]]`.</li>
<li><a href='SC2102'>SC2102</a> &ndash; Ranges can only match single chars (mentioned due to duplicates).</li>
<li><a href='SC2103'>SC2103</a> &ndash; Use a `( subshell )` to avoid having to `cd` back.</li>
<li><a href='SC2104'>SC2104</a> &ndash; In functions, use `return` instead of `break`.</li>
<li><a href='SC2105'>SC2105</a> &ndash; `break` is only valid in loops</li>
<li><a href='SC2106'>SC2106</a> &ndash; This only exits the subshell caused by the pipeline.</li>
<li><a href='SC2107'>SC2107</a> &ndash; Instead of `[ a &amp;&amp; b ]`, use `[ a ] &amp;&amp; [ b ]`.</li>
<li><a href='SC2108'>SC2108</a> &ndash; In `[[..]]`, use `&amp;&amp;` instead of `-a`.</li>
<li><a href='SC2109'>SC2109</a> &ndash; Instead of `[ a || b ]`, use `[ a ] || [ b ]`.</li>
<li><a href='SC2110'>SC2110</a> &ndash; In `[[..]]`, use `||` instead of `-o`.</li>
<li><a href='SC2111'>SC2111</a> &ndash; ksh does not allow `function` keyword and `()` at the same time.</li>
<li><a href='SC2112'>SC2112</a> &ndash; `function` keyword is non-standard. Delete it.</li>
<li><a href='SC2113'>SC2113</a> &ndash; `function` keyword is non-standard. Use `foo()` instead of `function foo`.</li>
<li><a href='SC2114'>SC2114</a> &ndash; Warning: deletes a system directory.</li>
<li><a href='SC2115'>SC2115</a> &ndash; Use `"${var:?}"` to ensure this never expands to `/*` .</li>
<li><a href='SC2116'>SC2116</a> &ndash; Useless echo? Instead of `cmd $(echo foo)`, just use `cmd foo`.</li>
<li><a href='SC2117'>SC2117</a> &ndash; To run commands as another user, use `su -c` or `sudo`.</li>
<li><a href='SC2118'>SC2118</a> &ndash; Ksh does not support `|&amp;`. Use `2&gt;&amp;1 |`</li>
<li><a href='SC2119'>SC2119</a> &ndash; Use `foo "$@"` if function's `$1` should mean script's `$1`.</li>
<li><a href='SC2120'>SC2120</a> &ndash; foo references arguments, but none are ever passed.</li>
<li><a href='SC2121'>SC2121</a> &ndash; To assign a variable, use just `var=value`, not `set ..`.</li>
<li><a href='SC2122'>SC2122</a> &ndash; `&gt;=` is not a valid operator. Use `! a &lt; b` instead.</li>
<li><a href='SC2123'>SC2123</a> &ndash; `PATH` is the shell search path. Use another name.</li>
<li><a href='SC2124'>SC2124</a> &ndash; Assigning an array to a string! Assign as array, or use `*` instead of `@` to concatenate.</li>
<li><a href='SC2125'>SC2125</a> &ndash; Brace expansions and globs are literal in assignments. Quote it or use an array.</li>
<li><a href='SC2126'>SC2126</a> &ndash; Consider using `grep -c` instead of `grep | wc`</li>
<li><a href='SC2127'>SC2127</a> &ndash; To use `${ ..; }`, specify `#!/usr/bin/env ksh`.</li>
<li><a href='SC2128'>SC2128</a> &ndash; Expanding an array without an index only gives the element in the index 0.</li>
<li><a href='SC2129'>SC2129</a> &ndash; Consider using `{ cmd1; cmd2; } &gt;&gt; file` instead of individual redirects.</li>
<li><a href='SC2130'>SC2130</a> &ndash; `-eq` is for integer comparisons. Use `=` instead.</li>
<li><a href='SC2139'>SC2139</a> &ndash; This expands when defined, not when used. Consider escaping.</li>
<li><a href='SC2140'>SC2140</a> &ndash; Word is of the form `"A"B"C"` (B indicated). Did you mean `"ABC"` or `"A\"B\"C"`?</li>
<li><a href='SC2141'>SC2141</a> &ndash; Did you mean `IFS=$'\t'` ?</li>
<li><a href='SC2142'>SC2142</a> &ndash; Aliases can't use positional parameters. Use a function.</li>
<li><a href='SC2143'>SC2143</a> &ndash; Use `grep -q` instead of comparing output with `[ -n .. ]`.</li>
<li><a href='SC2144'>SC2144</a> &ndash; `-e` doesn't work with globs. Use a `for` loop.</li>
<li><a href='SC2145'>SC2145</a> &ndash; Argument mixes string and array. Use `*` or separate argument.</li>
<li><a href='SC2146'>SC2146</a> &ndash; This action ignores everything before the `-o`. Use `\( \)` to group.</li>
<li><a href='SC2147'>SC2147</a> &ndash; Literal tilde in PATH works poorly across programs.</li>
<li><a href='SC2148'>SC2148</a> &ndash; Tips depend on target shell and yours is unknown. Add a shebang.</li>
<li><a href='SC2149'>SC2149</a> &ndash; Remove `$`/`${}` for numeric index, or escape it for string.</li>
<li><a href='SC2150'>SC2150</a> &ndash; `-exec` does not automatically invoke a shell. Use `-exec sh -c ..` for that.</li>
<li><a href='SC2151'>SC2151</a> &ndash; Only one integer 0-255 can be returned. Use stdout for other data.</li>
<li><a href='SC2152'>SC2152</a> &ndash; Can only return 0-255. Other data should be written to stdout.</li>
<li><a href='SC2153'>SC2153</a> &ndash; Possible Misspelling: MYVARIABLE may not be assigned. Did you mean MY_VARIABLE?</li>
<li><a href='SC2154'>SC2154</a> &ndash; var is referenced but not assigned.</li>
<li><a href='SC2155'>SC2155</a> &ndash; Declare and assign separately to avoid masking return values.</li>
<li><a href='SC2156'>SC2156</a> &ndash; Injecting filenames is fragile and insecure. Use parameters.</li>
<li><a href='SC2157'>SC2157</a> &ndash; Argument to implicit `-n` is always true due to literal strings.</li>
<li><a href='SC2158'>SC2158</a> &ndash; `[ false ]` is true. Remove the brackets</li>
<li><a href='SC2159'>SC2159</a> &ndash; `[ 0 ]` is true. Use `false` instead.</li>
<li><a href='SC2160'>SC2160</a> &ndash; Instead of `[ true ]`, just use `true`.</li>
<li><a href='SC2161'>SC2161</a> &ndash; Instead of `[ 1 ]`, use `true`.</li>
<li><a href='SC2162'>SC2162</a> &ndash; `read` without `-r` will mangle backslashes.</li>
<li><a href='SC2163'>SC2163</a> &ndash; This does not export `FOO`. Remove `$`/`${}` for that, or use `${var?}` to quiet.</li>
<li><a href='SC2164'>SC2164</a> &ndash; Use `cd ... || exit` in case `cd` fails.</li>
<li><a href='SC2165'>SC2165</a> &ndash; This nested loop overrides the index variable of its parent.</li>
<li><a href='SC2166'>SC2166</a> &ndash; Prefer `[ p ] &amp;&amp; [ q ]` as `[ p -a q ]` is not well-defined.</li>
<li><a href='SC2167'>SC2167</a> &ndash; This parent loop has its index variable overridden.</li>
<li><a href='SC2168'>SC2168</a> &ndash; `local` is only valid in functions.</li>
<li><a href='SC2169'>SC2169</a> &ndash; In dash, *something* is not supported.</li>
<li><a href='SC2170'>SC2170</a> &ndash; Invalid number for `-eq`. Use `=` to compare as string (or use `$var` to expand as a variable).</li>
<li><a href='SC2171'>SC2171</a> &ndash; Found trailing `]` outside test. Add missing `[` or quote if intentional.</li>
<li><a href='SC2172'>SC2172</a> &ndash; Trapping signals by number is not well-defined. Prefer signal names.</li>
<li><a href='SC2173'>SC2173</a> &ndash; SIGKILL/SIGSTOP can not be trapped.</li>
<li><a href='SC2174'>SC2174</a> &ndash; When used with `-p`, `-m` only applies to the deepest directory.</li>
<li><a href='SC2175'>SC2175</a> &ndash; Quote this invalid brace expansion since it should be passed literally to eval</li>
<li><a href='SC2176'>SC2176</a> &ndash; `time` is undefined for pipelines. time single stage or `bash -c` instead.</li>
<li><a href='SC2177'>SC2177</a> &ndash; `time` is undefined for compound commands, use `time sh -c` instead.</li>
<li><a href='SC2178'>SC2178</a> &ndash; Variable was used as an array but is now assigned a string.</li>
<li><a href='SC2179'>SC2179</a> &ndash; Use `array+=("item")` to append items to an array.</li>
<li><a href='SC2180'>SC2180</a> &ndash; Bash does not support multidimensional arrays. Use 1D or associative arrays.</li>
<li><a href='SC2181'>SC2181</a> &ndash; Check exit code directly with e.g. `if mycmd;`, not indirectly with `$?`.</li>
<li><a href='SC2182'>SC2182</a> &ndash; This printf format string has no variables. Other arguments are ignored.</li>
<li><a href='SC2183'>SC2183</a> &ndash; This format string has 2 variables, but is passed 1 argument.</li>
<li><a href='SC2184'>SC2184</a> &ndash; Quote arguments to unset so they're not glob expanded.</li>
<li><a href='SC2185'>SC2185</a> &ndash; Some finds don't have a default path. Specify `.` explicitly.</li>
<li><a href='SC2186'>SC2186</a> &ndash; tempfile is deprecated. Use mktemp instead.</li>
<li><a href='SC2187'>SC2187</a> &ndash; Ash scripts will be checked as Dash. Add `# shellcheck shell=dash` to silence.</li>
<li><a href='SC2188'>SC2188</a> &ndash; This redirection doesn't have a command. Move to its command (or use `true` as no-op).</li>
<li><a href='SC2189'>SC2189</a> &ndash; You can't have `|` between this redirection and the command it should apply to.</li>
<li><a href='SC2190'>SC2190</a> &ndash; Elements in associative arrays need index, e.g. `array=( [index]=value )` .</li>
<li><a href='SC2191'>SC2191</a> &ndash; The `=` here is literal. To assign by index, use `( [index]=value )` with no spaces. To keep as literal, quote it.</li>
<li><a href='SC2192'>SC2192</a> &ndash; This array element has no value. Remove spaces after `=` or use `""` for empty string.</li>
<li><a href='SC2193'>SC2193</a> &ndash; The arguments to this comparison can never be equal. Make sure your syntax is correct.</li>
<li><a href='SC2194'>SC2194</a> &ndash; This word is constant. Did you forget the `$` on a variable?</li>
<li><a href='SC2195'>SC2195</a> &ndash; This pattern will never match the case statement's word. Double check them.</li>
<li><a href='SC2196'>SC2196</a> &ndash; `egrep` is non-standard and deprecated. Use `grep -E` instead.</li>
<li><a href='SC2197'>SC2197</a> &ndash; `fgrep` is non-standard and deprecated. Use `grep -F` instead.</li>
<li><a href='SC2198'>SC2198</a> &ndash; Arrays don't work as operands in `[ ]`. Use a loop (or concatenate with `*` instead of `@`).</li>
<li><a href='SC2199'>SC2199</a> &ndash; Arrays implicitly concatenate in `[[ ]]`. Use a loop (or explicit `*` instead of `@`).</li>
<li><a href='SC2200'>SC2200</a> &ndash; Brace expansions don't work as operands in `[ ]`. Use a loop.</li>
<li><a href='SC2201'>SC2201</a> &ndash; Brace expansion doesn't happen in `[[ ]]`. Use a loop.</li>
<li><a href='SC2202'>SC2202</a> &ndash; Globs don't work as operands in `[ ]`. Use a loop.</li>
<li><a href='SC2203'>SC2203</a> &ndash; Globs are ignored in `[[ ]]` except right of `=`/`!=`. Use a loop.</li>
<li><a href='SC2204'>SC2204</a> &ndash; `(..)` is a subshell. Did you mean `[ .. ]`, a test expression?</li>
<li><a href='SC2205'>SC2205</a> &ndash; `(..)` is a subshell. Did you mean `[ .. ]`, a test expression?</li>
<li><a href='SC2206'>SC2206</a> &ndash; Quote to prevent word splitting/globbing, or split robustly with mapfile or `read -a`.</li>
<li><a href='SC2207'>SC2207</a> &ndash; Prefer `mapfile` or `read -a` to split command output (or quote to avoid splitting).</li>
<li><a href='SC2208'>SC2208</a> &ndash; Use `[[ ]]` or quote arguments to `-v` to avoid glob expansion.</li>
<li><a href='SC2209'>SC2209</a> &ndash; Use `var=$(command)` to assign output (or quote to assign string).</li>
<li><a href='SC2210'>SC2210</a> &ndash; This is a file redirection. Was it supposed to be a comparison or fd operation?</li>
<li><a href='SC2211'>SC2211</a> &ndash; This is a glob used as a command name. Was it supposed to be in `${..}`, array, or is it missing quoting?</li>
<li><a href='SC2212'>SC2212</a> &ndash; Use `false` instead of empty `[`/`[[` conditionals.</li>
<li><a href='SC2213'>SC2213</a> &ndash; getopts specified `-n`, but it's not handled by this `case`.</li>
<li><a href='SC2214'>SC2214</a> &ndash; This case is not specified by getopts.</li>
<li><a href='SC2215'>SC2215</a> &ndash; This flag is used as a command name. Bad line break or missing `[ .. ]`?</li>
<li><a href='SC2216'>SC2216</a> &ndash; Piping to `rm`, a command that doesn't read stdin. Wrong command or missing `xargs`?</li>
<li><a href='SC2217'>SC2217</a> &ndash; Redirecting to `echo`, a command that doesn't read stdin. Bad quoting or missing `xargs`?</li>
<li><a href='SC2218'>SC2218</a> &ndash; This function is only defined later. Move the definition up.</li>
<li><a href='SC2219'>SC2219</a> &ndash; Instead of `let expr`, prefer `(( expr ))` .</li>
<li><a href='SC2220'>SC2220</a> &ndash; Invalid flags are not handled. Add a `*)` case.</li>
<li><a href='SC2221'>SC2221</a> &ndash; This pattern always overrides a later one.</li>
<li><a href='SC2222'>SC2222</a> &ndash; This pattern never matches because of a previous pattern.</li>
<li><a href='SC2223'>SC2223</a> &ndash; This default assignment may cause DoS due to globbing. Quote it.</li>
<li><a href='SC2224'>SC2224</a> &ndash; This `mv` has no destination. Check the arguments.</li>
<li><a href='SC2225'>SC2225</a> &ndash; This `cp` has no destination. Check the arguments.</li>
<li><a href='SC2226'>SC2226</a> &ndash; This `ln` has no destination. Check the arguments, or specify `.` explicitly.</li>
<li><a href='SC2227'>SC2227</a> &ndash; Redirection applies to the find command itself. Rewrite to work per action (or move to end).</li>
<li><a href='SC2229'>SC2229</a> &ndash; This does not read `foo`. Remove `$`/`${}` for that, or use `${var?}` to quiet.</li>
<li><a href='SC2230'>SC2230</a> &ndash; `which` is non-standard. Use builtin `command -v` instead.</li>
<li><a href='SC2231'>SC2231</a> &ndash; Quote expansions in this `for` loop glob to prevent word splitting, e.g. `"${dir}"/*.txt`.</li>
<li><a href='SC2232'>SC2232</a> &ndash; Can't use `sudo` with builtins like `cd`. Did you want `sudo sh -c ..` instead?</li>
<li><a href='SC2233'>SC2233</a> &ndash; Remove superfluous `(..)` around condition to avoid subshell overhead.</li>
<li><a href='SC2234'>SC2234</a> &ndash; Remove superfluous `(..)` around test command to avoid subshell overhead.</li>
<li><a href='SC2235'>SC2235</a> &ndash; Use `{ ..; }` instead of `(..)` to avoid subshell overhead.</li>
<li><a href='SC2236'>SC2236</a> &ndash; Use `-n` instead of `! -z`.</li>
<li><a href='SC2237'>SC2237</a> &ndash; Use `[ -n .. ]` instead of `! [ -z .. ]`.</li>
<li><a href='SC2238'>SC2238</a> &ndash; Redirecting to/from command name instead of file. Did you want pipes/xargs (or quote to ignore)?</li>
<li><a href='SC2239'>SC2239</a> &ndash; Ensure the shebang uses the absolute path to the interpreter.</li>
<li><a href='SC2240'>SC2240</a> &ndash; The dot command does not support arguments in sh/dash. Set them as variables.</li>
<li><a href='SC2241'>SC2241</a> &ndash; The exit status can only be one integer 0-255. Use stdout for other data.</li>
<li><a href='SC2242'>SC2242</a> &ndash; Can only exit with status 0-255. Other data should be written to stdout/stderr.</li>
<li><a href='SC2243'>SC2243</a> &ndash; Prefer explicit `-n` to check for output (or run command without `[`/`[[` to check for success)</li>
<li><a href='SC2244'>SC2244</a> &ndash; Prefer explicit `-n` to check non-empty string (or use `=`/`-ne` to check boolean/integer).</li>
<li><a href='SC2245'>SC2245</a> &ndash; -d only applies to the first expansion of this glob. Use a loop to check any/all.</li>
<li><a href='SC2246'>SC2246</a> &ndash; This shebang specifies a directory. Ensure the interpreter is a file.</li>
<li><a href='SC2247'>SC2247</a> &ndash; Flip leading `$` and `"` if this should be a quoted substitution.</li>
<li><a href='SC2248'>SC2248</a> &ndash; Prefer double quoting even when variables don't contain special characters.</li>
<li><a href='SC2249'>SC2249</a> &ndash; Consider adding a default `*)` case, even if it just exits with error.</li>
<li><a href='SC2250'>SC2250</a> &ndash; Prefer putting braces around variable references even when not strictly required.</li>
<li><a href='SC2251'>SC2251</a> &ndash; This `!` is not on a condition and skips errexit. Add `|| exit 1` or make sure `$?` is checked.</li>
<li><a href='SC2252'>SC2252</a> &ndash; You probably wanted `&amp;&amp;` here, otherwise it's always true.</li>
<li><a href='SC2253'>SC2253</a> &ndash; Use `-R` to recurse, or explicitly `a-r` to remove read permissions.</li>
<li><a href='SC2254'>SC2254</a> &ndash; Quote expansions in case patterns to match literally rather than as a glob.</li>
<li><a href='SC2255'>SC2255</a> &ndash; `[ ]` does not apply arithmetic evaluation. Evaluate with `$((..))` for numbers, or use string comparator for strings.</li>
<li><a href='SC2256'>SC2256</a> &ndash; This translated string is the name of a variable. Flip leading `$` and `"` if this should be a quoted substitution.</li>
<li><a href='SC2257'>SC2257</a> &ndash; Arithmetic modifications in command redirections may be discarded. Do them separately.</li>
<li><a href='SC2258'>SC2258</a> &ndash; The trailing comma is part of the value, not a separator. Delete or quote it.</li>
<li><a href='SC2259'>SC2259</a> &ndash; This redirection overrides piped input. To use both, merge or pass filenames.</li>
<li><a href='SC2260'>SC2260</a> &ndash; This redirection overrides the output pipe. Use `tee` to output to both.</li>
<li><a href='SC2261'>SC2261</a> &ndash; Multiple redirections compete for stdout. Use `cat`, `tee`, or pass filenames instead.</li>
<li><a href='SC2262'>SC2262</a> &ndash; This alias can't be defined and used in the same parsing unit. Use a function instead.</li>
<li><a href='SC2263'>SC2263</a> &ndash; Since they're in the same parsing unit, this command will not refer to the previously mentioned alias.</li>
<li><a href='SC2264'>SC2264</a> &ndash; This function unconditionally re-invokes itself. Missing `command`?</li>
<li><a href='SC2265'>SC2265</a> &ndash; Use `&amp;&amp;` for logical AND. Single `&amp;` will background and return true.</li>
<li><a href='SC2266'>SC2266</a> &ndash; Use `||` for logical OR. Single `|` will pipe.</li>
<li><a href='SC2267'>SC2267</a> &ndash; GNU `xargs -i` is deprecated in favor of `-I{}`</li>
<li><a href='SC2268'>SC2268</a> &ndash; Avoid x-prefix in comparisons as it no longer serves a purpose.</li>
<li><a href='SC2269'>SC2269</a> &ndash; This variable is assigned to itself, so the assignment does nothing.</li>
<li><a href='SC2270'>SC2270</a> &ndash; To assign positional parameters, use `set -- first second ..` (or use `[ ]` to compare).</li>
<li><a href='SC2271'>SC2271</a> &ndash; For indirection, use arrays, `declare "var$n=value"`, or (for sh) read/eval</li>
<li><a href='SC2272'>SC2272</a> &ndash; Command name contains `==`. For comparison, use `[ "$var" = value ]`.</li>
<li><a href='SC2273'>SC2273</a> &ndash; Sequence of `===`s found. Merge conflict or intended as a commented border?</li>
<li><a href='SC2274'>SC2274</a> &ndash; Command name starts with `===`. Intended as a commented border?</li>
<li><a href='SC2275'>SC2275</a> &ndash; Command name starts with `=`. Bad line break?</li>
<li><a href='SC2276'>SC2276</a> &ndash; This is interpreted as a command name containing `=`. Bad assignment or comparison?</li>
<li><a href='SC2277'>SC2277</a> &ndash; Use `BASH_ARGV0` to assign to `$0` in bash (or use `[ ]` to compare).</li>
<li><a href='SC2278'>SC2278</a> &ndash; `$0` can't be assigned in Ksh (but it does reflect the current function).</li>
<li><a href='SC2279'>SC2279</a> &ndash; `$0` can't be assigned in Dash. This becomes a command name.</li>
<li><a href='SC2280'>SC2280</a> &ndash; `$0` can't be assigned this way, and there is no portable alternative.</li>
<li><a href='SC2281'>SC2281</a> &ndash; Don't use `$`/`${}` on the left side of assignments.</li>
<li><a href='SC2282'>SC2282</a> &ndash; Variable names can't start with numbers, so this is interpreted as a command.</li>
<li><a href='SC2283'>SC2283</a> &ndash; Use `[ ]` to compare values, or remove spaces around `=` to assign (or quote `'='` if literal).</li>
<li><a href='SC2284'>SC2284</a> &ndash; Use `[ x = y ]` to compare values (or quote `'=='` if literal).</li>
<li><a href='SC2285'>SC2285</a> &ndash; Remove spaces around `+=` to assign (or quote `'+='` if literal).</li>
<li><a href='SC2286'>SC2286</a> &ndash; This empty string is interpreted as a command name. Double check syntax (or use 'true' as a no-op).</li>
<li><a href='SC2287'>SC2287</a> &ndash; This is interpreted as a command name ending with '/'. Double check syntax.</li>
<li><a href='SC2288'>SC2288</a> &ndash; This is interpreted as a command name ending with apostrophe. Double check syntax.</li>
<li><a href='SC2289'>SC2289</a> &ndash; This is interpreted as a command name containing a linefeed. Double check syntax.</li>
<li><a href='SC2290'>SC2290</a> &ndash; Remove spaces around = to assign.</li>
<li><a href='SC2291'>SC2291</a> &ndash; Quote repeated spaces to avoid them collapsing into one.</li>
<li><a href='SC2292'>SC2292</a> &ndash; Prefer `[[ ]]` over `[ ]` for tests in Bash/Ksh.</li>
<li><a href='SC2293'>SC2293</a> &ndash; When eval'ing @Q-quoted words, use * rather than @ as the index.</li>
<li><a href='SC2294'>SC2294</a> &ndash; eval negates the benefit of arrays. Drop eval to preserve whitespace/symbols (or eval as string).</li>
<li><a href='SC2295'>SC2295</a> &ndash; Expansions inside `${..}` need to be quoted separately, otherwise they will match as a pattern.</li>
<li><a href='SC2296'>SC2296</a> &ndash; Parameter expansions can't start with `{`. Double check syntax.</li>
<li><a href='SC2297'>SC2297</a> &ndash; Double quotes must be outside `${}`: `${"invalid"}` vs `"${valid}"`.</li>
<li><a href='SC2298'>SC2298</a> &ndash; `${$x}` is invalid. For expansion, use ${x}. For indirection, use arrays, ${!x} or (for sh) eval.</li>
<li><a href='SC2299'>SC2299</a> &ndash; Parameter expansions can't be nested. Use temporary variables.</li>
<li><a href='SC2300'>SC2300</a> &ndash; Parameter expansion can't be applied to command substitutions. Use temporary variables.</li>
<li><a href='SC2301'>SC2301</a> &ndash; Parameter expansion starts with unexpected quotes. Double check syntax.</li>
<li><a href='SC2302'>SC2302</a> &ndash; This loops over values. To loop over keys, use `"${!array[@]}"`.</li>
<li><a href='SC2303'>SC2303</a> &ndash; `i` is an array value, not a key. Use directly or loop over keys instead.</li>
<li><a href='SC2304'>SC2304</a> &ndash; `*` must be escaped to multiply: `\*`. Modern `$((x * y))` avoids this issue.</li>
<li><a href='SC2305'>SC2305</a> &ndash; Quote regex argument to expr to avoid it expanding as a glob.</li>
<li><a href='SC2306'>SC2306</a> &ndash; Escape glob characters in arguments to expr to avoid pathname expansion.</li>
<li><a href='SC2307'>SC2307</a> &ndash; 'expr' expects 3+ arguments but sees 1. Make sure each operator/operand is a separate argument, and escape &lt;&gt;&amp;|.</li>
<li><a href='SC2308'>SC2308</a> &ndash; `expr length` has unspecified results. Prefer `${#var}`.</li>
<li><a href='SC2309'>SC2309</a> &ndash; -eq treats this as a variable. Use = to compare as string (or expand explicitly with $var)</li>
<li><a href='SC2310'>SC2310</a> &ndash; This function is invoked in an 'if' condition so set -e will be disabled. Invoke separately if failures should cause the script to exit.</li>
<li><a href='SC2311'>SC2311</a> &ndash; Bash implicitly disabled set -e for this function invocation because it's inside a command substitution. Add set -e; before it or enable inherit_errexit.</li>
<li><a href='SC2312'>SC2312</a> &ndash; Consider invoking this command separately to avoid masking its return value (or use '|| true' to ignore).</li>
<li><a href='SC2313'>SC2313</a> &ndash; Quote array indices to avoid them expanding as globs.</li>
<li><a href='SC2314'>SC2314</a> &ndash; In bats, `!` does not cause a test failure.</li>
<li><a href='SC2315'>SC2315</a> &ndash; In bats, `!` does not cause a test failure. Fold the `!` into the conditional!</li>
<li><a href='SC2316'>SC2316</a> &ndash; This applies local to the variable named readonly, which is probably not what you want. Use a separate command or the appropriate `declare` options instead.</li>
<li><a href='SC2317'>SC2317</a> &ndash; Command appears to be unreachable. Check usage (or ignore if invoked indirectly).</li>
<li><a href='SC2318'>SC2318</a> &ndash; This assignment is used again in this `declare`, but won't have taken effect. Use two `declare`s.</li>
<li><a href='SC2319'>SC2319</a> &ndash; This `$?` refers to a condition, not a command. Assign to a variable to avoid it being overwritten.</li>
<li><a href='SC2320'>SC2320</a> &ndash; This `$?` refers to echo/printf, not a previous command. Assign to variable to avoid it being overwritten.</li>
<li><a href='SC2321'>SC2321</a> &ndash; Array indices are already arithmetic contexts. Prefer removing the `$((` and `))`.</li>
<li><a href='SC2322'>SC2322</a> &ndash; In arithmetic contexts, `((x))` is the same as `(x)`. Prefer only one layer of parentheses.</li>
<li><a href='SC2323'>SC2323</a> &ndash; `a[(x)]` is the same as `a[x]`. Prefer not wrapping in additional parentheses.</li>
<li><a href='SC2324'>SC2324</a> &ndash; var+=1 will append, not increment. Use (( var += 1 )), declare -i var, or quote number to silence.</li>
<li><a href='SC2325'>SC2325</a> &ndash; Multiple ! in front of pipelines are a bash/ksh extension. Use only 0 or 1.</li>
<li><a href='SC2326'>SC2326</a> &ndash; ! is not allowed in the middle of pipelines. Use command group as in `cmd | { ! cmd; }` if necessary.</li>
<li><a href='SC2327'>SC2327</a> &ndash; This command substitution will be empty because the command's output gets redirected away.</li>
<li><a href='SC2328'>SC2328</a> &ndash; This redirection takes output away from the command substitution.</li>
<li><a href='SC2329'>SC2329</a> &ndash; This function is never invoked. Check usage (or ignored if invoked indirectly).</li>
<li><a href='SC2330'>SC2330</a> &ndash; BusyBox `[[ .. ]]` does not support glob matching. Use a case statement.</li>
<li><a href='SC2331'>SC2331</a> &ndash; For file existence, prefer standard -e over legacy -a.</li>
<li><a href='SC2332'>SC2332</a> &ndash; [ ! -o opt ] is always true because -o becomes logical OR. Use [[ ]] or ! [ -o opt ].</li>
<li><a href='SC2333'>SC2333</a> &ndash; You probably wanted || here, otherwise it's always false.</li>
<li><a href='SC2334'>SC2334</a> &ndash; You probably wanted || here, otherwise it's always false.</li>
<li><a href='SC2335'>SC2335</a> &ndash; Use `[ "$var" -ne 1 ]` instead of `[ ! "$var" -eq 1 ]`</li>
<li><a href='SC3001'>SC3001</a> &ndash; In POSIX sh, process substitution is undefined.</li>
<li><a href='SC3002'>SC3002</a> &ndash; In POSIX sh, extglob is undefined.</li>
<li><a href='SC3003'>SC3003</a> &ndash; In POSIX sh, `$'..'` is undefined.</li>
<li><a href='SC3004'>SC3004</a> &ndash; In POSIX sh, $".." is undefined</li>
<li><a href='SC3005'>SC3005</a> &ndash; In POSIX sh, arithmetic for loops are undefined.</li>
<li><a href='SC3006'>SC3006</a> &ndash; In POSIX sh, standalone `((..))` is undefined.</li>
<li><a href='SC3007'>SC3007</a> &ndash; In POSIX sh, `$[..]` in place of `$((..))` is undefined.</li>
<li><a href='SC3008'>SC3008</a> &ndash; In POSIX sh, select loops are undefined.</li>
<li><a href='SC3009'>SC3009</a> &ndash; In POSIX `sh`, brace expansion is undefined.</li>
<li><a href='SC3010'>SC3010</a> &ndash; In POSIX sh, `[[ ]]` is undefined.</li>
<li><a href='SC3011'>SC3011</a> &ndash; In POSIX sh, here-strings are undefined.</li>
<li><a href='SC3012'>SC3012</a> &ndash; In POSIX sh, lexicographical `\&lt;` is undefined.</li>
<li><a href='SC3013'>SC3013</a> &ndash; In POSIX sh, `-nt` is undefined.</li>
<li><a href='SC3014'>SC3014</a> &ndash; In POSIX sh, `==` in place of `=` is undefined.</li>
<li><a href='SC3015'>SC3015</a> &ndash; In POSIX sh, `=~` regex matching is undefined.</li>
<li><a href='SC3016'>SC3016</a> &ndash; In POSIX sh, unary `-v` (in place of `[ -n "${var+x}" ]`) is undefined.</li>
<li><a href='SC3017'>SC3017</a> &ndash; In POSIX sh, unary `-a` in place of `-e` is undefined.</li>
<li><a href='SC3018'>SC3018</a> &ndash; In POSIX sh, `++` is undefined.</li>
<li><a href='SC3019'>SC3019</a> &ndash; In POSIX sh, exponentials are undefined.</li>
<li><a href='SC3020'>SC3020</a> &ndash; In POSIX sh, `&amp;&gt;` is undefined.</li>
<li><a href='SC3021'>SC3021</a> &ndash; In POSIX sh, `&gt;&amp; filename` (as opposed to `&gt;&amp; fd`) is undefined.</li>
<li><a href='SC3022'>SC3022</a> &ndash; In POSIX sh, named file descriptors is undefined.</li>
<li><a href='SC3023'>SC3023</a> &ndash; In POSIX sh, FDs outside 0-9 are undefined.</li>
<li><a href='SC3024'>SC3024</a> &ndash; In POSIX sh, `+=` is undefined.</li>
<li><a href='SC3025'>SC3025</a> &ndash; In POSIX sh, `/dev/{tcp,udp}` is undefined.</li>
<li><a href='SC3026'>SC3026</a> &ndash; In POSIX sh, `^` in place of `!` in glob bracket expressions is undefined.</li>
<li><a href='SC3028'>SC3028</a> &ndash; In POSIX sh, VARIABLE is undefined.</li>
<li><a href='SC3029'>SC3029</a> &ndash; In POSIX sh, `|&amp;` in place of `2&gt;&amp;1 |` is undefined.</li>
<li><a href='SC3030'>SC3030</a> &ndash; In POSIX sh, arrays are undefined.</li>
<li><a href='SC3031'>SC3031</a> &ndash; In POSIX sh, redirecting from/to globs is undefined.</li>
<li><a href='SC3032'>SC3032</a> &ndash; In POSIX sh, coproc is undefined.</li>
<li><a href='SC3033'>SC3033</a> &ndash; In POSIX sh, naming functions outside [a-zA-Z_][a-zA-Z0-9_]* is undefined.</li>
<li><a href='SC3034'>SC3034</a> &ndash; In POSIX sh, `$(&lt;file)` is undefined.</li>
<li><a href='SC3035'>SC3035</a> &ndash; In POSIX sh, `` `&lt;file` `` is undefined.</li>
<li><a href='SC3036'>SC3036</a> &ndash; In Dash, echo flags besides -n are not supported.</li>
<li><a href='SC3037'>SC3037</a> &ndash; In POSIX sh, echo flags are undefined.</li>
<li><a href='SC3038'>SC3038</a> &ndash; In POSIX sh, exec flags are undefined.</li>
<li><a href='SC3039'>SC3039</a> &ndash; In POSIX sh, `let` is undefined.</li>
<li><a href='SC3040'>SC3040</a> &ndash; In POSIX sh, set option *[name]* is undefined.</li>
<li><a href='SC3041'>SC3041</a> &ndash; In POSIX sh, set flag `-E` is undefined</li>
<li><a href='SC3042'>SC3042</a> &ndash; In POSIX sh, set flag `--default` is undefined</li>
<li><a href='SC3043'>SC3043</a> &ndash; In POSIX sh, `local` is undefined.</li>
<li><a href='SC3044'>SC3044</a> &ndash; In POSIX sh, `declare` is undefined.</li>
<li><a href='SC3045'>SC3045</a> &ndash; In POSIX sh, some-command-with-flag is undefined.</li>
<li><a href='SC3046'>SC3046</a> &ndash; In POSIX sh, `source` in place of `.` is undefined.</li>
<li><a href='SC3047'>SC3047</a> &ndash; In POSIX sh, trapping ERR is undefined.</li>
<li><a href='SC3048'>SC3048</a> &ndash; In POSIX sh, prefixing signal names with 'SIG' is undefined.</li>
<li><a href='SC3049'>SC3049</a> &ndash; In POSIX sh, using lower/mixed case for signal names is undefined.</li>
<li><a href='SC3050'>SC3050</a> &ndash; In POSIX sh, `printf %q` is undefined.</li>
<li><a href='SC3051'>SC3051</a> &ndash; In POSIX sh, `source` in place of `.` is undefined</li>
<li><a href='SC3052'>SC3052</a> &ndash; In POSIX sh, arithmetic base conversion is undefined</li>
<li><a href='SC3053'>SC3053</a> &ndash; In POSIX sh, indirect expansion is undefined.</li>
<li><a href='SC3054'>SC3054</a> &ndash; In POSIX sh, array references are undefined.</li>
<li><a href='SC3055'>SC3055</a> &ndash; In POSIX sh, array key expansion is undefined.</li>
<li><a href='SC3056'>SC3056</a> &ndash; In POSIX sh, name matching prefixes are undefined.</li>
<li><a href='SC3057'>SC3057</a> &ndash; In POSIX sh, string indexing is undefined.</li>
<li><a href='SC3059'>SC3059</a> &ndash; In POSIX sh, case modification is undefined.</li>
<li><a href='SC3060'>SC3060</a> &ndash; In POSIX sh, string replacement is undefined.</li>
<li><a href='SC3061'>SC3061</a> &ndash; In POSIX sh, `read` without a variable is undefined.</li>
<li><a href='SC3062'>SC3062</a> &ndash; In POSIX sh, unary -o to check options is undefined.</li>
<li><a href='SC3063'>SC3063</a> &ndash; In POSIX sh, test -R and namerefs in general are undefined.</li>
<li><a href='SC3064'>SC3064</a> &ndash; In POSIX sh, test -N is undefined.</li>
<li><a href='SC3065'>SC3065</a> &ndash; In POSIX sh, test -k is undefined.</li>
<li><a href='SC3066'>SC3066</a> &ndash; In POSIX sh, test -G is undefined.</li>
<li><a href='SC3067'>SC3067</a> &ndash; In POSIX sh, test -O is undefined.</li>
</ul>

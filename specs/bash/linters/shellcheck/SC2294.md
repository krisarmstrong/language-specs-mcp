ShellCheck: SC2294 – eval negates the benefit of arrays. Drop eval to preserve whitespace/symbols (or eval as string).

# SC2294 – ShellCheck Wiki

[See this page on GitHub](https://github.com/koalaman/shellcheck/wiki/SC2294)

[Sitemap](index.html)

## eval negates the benefit of arrays. Drop eval to preserve whitespace/symbols (or eval as string).

### Problematic code:

```
#cb1-1check() {
#cb1-2  eval "$@" || exit
#cb1-3}
```

### Correct code:

```
#cb2-1check() {
#cb2-2  "$@" || exit
#cb2-3}
```

### Rationale:

ShellCheck found `eval` used on an array (or equivalently, `"$@"`). This is problematic because it effectively throws away all boundary information and rebuilds it from shell words.

Let's say you invoke `check sed -i '$d' "my file.txt"`:

`eval "$@"` will:

1. Join the elements on spaces: `sed -i $d my file.txt`
2. Split the string on shell word boundaries: `sed`, `-i`, `$d`, `my``file.txt`
3. Perform shell expansions (assuming `$d` is unset): `sed`, `-i`, `my`, `file.txt`
4. Execute the first element as the command and the rest as its arguments, as if running `sed -i 'my' 'file.txt'`

`"$@"` will

1. Execute the first element as the command and the rest as its arguments, as if running `sed -i '$d' 'my file.txt'`

Note that while `"$@"` is essentially always better than `eval "$@"`, it's easy to unintentionally introduce a dependency on bad behavior through the shell debugging anti-strategy of "adding quotes until it works":

```
#cb3-1# Works with problematic example because of double-escaping, fails with correct example
#cb3-2check ls -l "'My File.txt'" 
#cb3-3
#cb3-4# Works with correct example the way it was always intended:
#cb3-5check ls -l "My File.txt" 
```

The correct example is still better, but the function invocation has to be tweaked as well.

### Exceptions:

If each of the array elements is a carefully escaped shell command or word, use `*` instead of `@` to explicitly join the elements on spaces which is what would happen anyways:

```
#cb4-1on_exit=(
#cb4-2  'rm /tmp/myfile; '
#cb4-3  'echo "Finished on $(date)" > log.txt; '
#cb4-4)
#cb4-5
#cb4-6# Equivalent to `eval "${on_exit[@]}"`, but more explicit
#cb4-7eval "${on_exit[*]}"
#cb4-8
#cb4-9# Even better in this case, as it does not require
#cb4-10# semicolons and commands don't interfere:
#cb4-11for cmd in "${on_exit[@]}"
#cb4-12do
#cb4-13  eval "$cmd"
#cb4-14done
```

If you require `eval` for another part of the command, explicitly transform the array into a series of escaped shell words. This ensures that the array elements will `eval` back to themselves:

```
#cb5-1# Assumed to be outside of our control, 
#cb5-2# otherwise we would output this in an array as well:
#cb5-3COMMAND='dialog --menu "Choose file:" 15 40 4'
#cb5-4
#cb5-5# Our array:
#cb5-6array=(
#cb5-7  1 "My File.txt"
#cb5-8  2 "My Other File.txt"
#cb5-9)
#cb5-10eval "$COMMAND ${array[*]@Q}"                     # Bash 4+
#cb5-11eval "$COMMAND $(printf "%q " "${array[@]}")"     # Bash 1+
```

### Related resources:

- Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!

[ShellCheck](https://www.shellcheck.net) is a static analysis tool for shell scripts. This page is part of its documentation.

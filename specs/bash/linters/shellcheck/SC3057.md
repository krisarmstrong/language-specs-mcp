ShellCheck: SC3057 – In POSIX sh, string indexing is undefined.

# SC3057 – ShellCheck Wiki

[See this page on GitHub](https://github.com/koalaman/shellcheck/wiki/SC3057)

[Sitemap](index.html)

## In POSIX sh, string indexing is undefined.

(or "In dash, ... is not supported." when using `dash`)

### Problematic code:

```
#cb1-1#!/bin/sh
#cb1-2echo "Your initial is ${USER:0:1}"
```

### Correct code:

Either switch to a shell that does support string indexing via parameter expansion, like `bash` or `ksh`, or rewrite with `cut`:

```
#cb2-1#!/bin/sh
#cb2-2echo "Your initial is $(printf '%s' "$USER" | cut -c 1)"
```

To find the last argument passed to a shell script without using bash’s `${@:$#}`- or `${@: -1}`-style string indexing, use the following, which even “[works
in the unix v7 bourne shell from 1979](https://stackoverflow.com/q/1853946#comment104235724_1853993)”:

```
#cb3-1#!/bin/sh
#cb3-2for argument in "$@"; do
#cb3-3  : # `:`, also called as `true`, is a no-op here
#cb3-4done
#cb3-5printf '%s\n' "${argument-}"
```

#### Use `parameter expansion` instead

An alternative could be to use parameter expansion instead of string indexing. Either [through a
delimiting character](#through-a-delimiting-character), [through matching
undesired parts of a text](#through-matching-undesired-parts-of-the-text), or [through a "simple" pattern of
length size](#through-a-simple-pattern).

##### Through a delimiting character

For instance, to use texts prefixed with a number, an option is to use a colon as a delimiter and use that in a parameter expansion that removes a pattern form either beginning or ending of variable value.

```
#cb4-1#!/usr/bin/env sh
#cb4-2exitForReasonY='6:Stopping because of 8x Y.'
#cb4-3printf "The ''reason y'' has number '%s' and its message is: '%s'." "${exitForReasonY#*:}" "${exitForReasonY%%:*}"
```

Or, in a function:

```
#cb5-1#!/usr/bin/env sh
#cb5-2exitForReasonX='44:Stopping %s because of X.'
#cb5-3reasonableExit ()
#cb5-4{
#cb5-5  state="${1:-}"
#cb5-6  state="${state:?is required}"
#cb5-7  ${1+shift}
#cb5-8  set -- "${state#*:}" ${1+"${@?}"}
#cb5-9  >&2 printf "${@?}"
#cb5-10  exit "${state%%:*}"
#cb5-11}
#cb5-12reasonableExit "${exitForReasonX?}" 'something'
```

##### Through matching undesired parts of the text

Another way could be to remove what is unwanted by selecting that.

```
#cb6-1#!/usr/bin/env sh
#cb6-2exitForReasonY='6Stopping because of 8x Y.'
#cb6-3yNumber="${exitForReasonY%%[![:digit:]]*}"
#cb6-4yText="${exitForReasonY#${exitForReasonY%%[![:digit:]]*}}"
#cb6-5# or : yText="${exitForReasonY#${yNumber?}"
#cb6-6printf "The ''reason y'' has number '%s' and its message is: '%s'.\n" "${yNumber?}" "${yText?}"
```

Or, in a function:

```
#cb7-1#!/usr/bin/env sh
#cb7-2exitForReasonX='44Stopping %s because of X.'
#cb7-3reasonableExit ()
#cb7-4{
#cb7-5  text="${1:-}"
#cb7-6  text="${text:?is required}"
#cb7-7  ${1+shift}
#cb7-8  state="${text%%[![:digit:]]*}"
#cb7-9  set -- "${text#"${state?}"}" ${1+"${@?}"}
#cb7-10  >&2 printf "${@?}"
#cb7-11  exit "${state?}"
#cb7-12}
#cb7-13reasonableExit "${exitForReasonX?}" 'something'
```

##### Through a "simple" pattern

Remove the smallest prefix from a text where prefix matches a pattern that matches any character as many times as the sum of start and length. Remove the smallest _suffix that matches that previous text from the original text. Remove the smallest prefix that matches any character as many times as the start index.

This could also be the other way around, selecting an offset from the end of a text.

```
#cb8-1#!/usr/bin/env sh
#cb8-2
#cb8-3part="zyxwvutsrqponmlkjihgfedcba"
#cb8-4#echo "${part:5:3}"
#cb8-5part="${part%${part#????????}}"
#cb8-6part="${part#?????}"
#cb8-7printf '%s\n' "${part?}"
```

Code "walkthrough"

```
#cb9-1#!/usr/bin/env sh
#cb9-2
#cb9-3part="zyxwvutsrqponmlkjihgfedcba"
#cb9-4#echo "${part:5:3}"
#cb9-5
#cb9-6part="${part%${part#????????}}"
#cb9-7## Removed smallest prefix from text where prefix matches pattern ????????
#cb9-8## in this case : "rqponmlkjihgfedcba"
#cb9-9## "${part%${part#????????}}" = "${part%"rqponmlkjihgfedcba"}" = "zyxwvuts"
#cb9-10## Removed smallest suffix from part of text where suffix matches pattern ${part#????????} (i.e. "rqponmlkjihgfedcba")
#cb9-11
#cb9-12part="${part#?????}"
#cb9-13## Removed smallest prefix from text where prefix matches ????? (i.e. "zyxwv")
#cb9-14
#cb9-15printf '%s\n' "${part?}"
```

### Rationale:

String indexing is a bash and ksh extension, and does not work in `dash` or POSIX `sh`.

### Exceptions:

If you only intend to target shells that supports this feature, you can change the shebang to a shell that guarantees support, or [ignore](ignore) this warning.

You can use `# shellcheck disable=SC3000-SC4000` to ignore all such compatibility warnings.

### Related resources:

- Help by adding links to BashFAQ, StackOverflow, man pages, POSIX, etc!

[ShellCheck](https://www.shellcheck.net) is a static analysis tool for shell scripts. This page is part of its documentation.

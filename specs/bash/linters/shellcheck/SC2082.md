ShellCheck: SC2082 – To expand via indirection, use `name="foo$n"; echo "${!name}"`.

# SC2082 – ShellCheck Wiki

[See this page on GitHub](https://github.com/koalaman/shellcheck/wiki/SC2082)

[Sitemap](index.html)

## To expand via indirection, use `name="foo$n"; echo "${!name}"`.

### Problematic code:

```
#cb1-1var_1="hello world"
#cb1-2n=1
#cb1-3echo "${var_$n}"
```

### Correct code:

Bash/ksh:

```
#cb2-1# Use arrays instead of dynamic names
#cb2-2declare -a var
#cb2-3var[1]="hello world"
#cb2-4n=1
#cb2-5echo "${var[n]}"
```

or

```
#cb3-1# Expand variable names dynamically
#cb3-2var_1="hello world"
#cb3-3n=1
#cb3-4name="var_$n"
#cb3-5echo "${!name}"
```

POSIX sh:

```
#cb4-1# Expand dynamically with eval
#cb4-2var_1="hello world"
#cb4-3n=1
#cb4-4eval "tmp=\$var_$n"
#cb4-5echo "${tmp}"
```

### Rationale:

You can expand a variable `var_1` with `${var_1}`, but you can not generate the string `var_1` with an embedded expansion, like `${var_$n}`.

Instead, if at all possible, you should use an array. Bash and ksh support both numerical and associative arrays, and an example is shown above.

If you can't use arrays, you can indirectly reference variables by creating a temporary variable with its name, e.g. `myvar="var_$n"` and then expanding it indirectly with `${!myvar}`. This will give the contents of the variable `var_1`.

If using POSIX sh, where neither arrays nor `${!var}` is available, `eval` can be used. You must be careful in sanitizing the data used to construct the variable name to avoid arbitrary code execution.

### Exceptions:

None

### Related resources:

- [BashFaq: How can I
use variable variables (indirect variables, pointers, references) or
associative arrays?](https://mywiki.wooledge.org/BashFAQ/006)
- [StackOverflow:
Dynamic variable names in Bash](https://stackoverflow.com/questions/16553089/dynamic-variable-names-in-bash)

[ShellCheck](https://www.shellcheck.net) is a static analysis tool for shell scripts. This page is part of its documentation.

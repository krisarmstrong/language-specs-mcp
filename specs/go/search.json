{"language": "go", "generatedAt": "2026-01-05T15:15:55.931114+00:00", "entries": [{"path": "effective-go.md", "category": "spec", "name": "effective-go", "content": "# Effective Go\n\nSee: https://go.dev/doc/effective_go\n"}, {"path": "patterns/proverbs.md", "category": "patterns", "name": "patterns/proverbs", "content": "# Go Proverbs\n\nBy Rob Pike\n\n- Don't communicate by sharing memory, share memory by communicating.\n- Concurrency is not parallelism.\n- Channels orchestrate; mutexes serialize.\n- The bigger the interface, the weaker the abstraction.\n- Make the zero value useful.\n- interface{} says nothing.\n- Gofmt's style is no one's favorite, yet gofmt is everyone's favorite.\n- A little copying is better than a little dependency.\n- Syscall must always be guarded with build tags.\n- Cgo must always be guarded with build tags.\n- Cgo is not Go.\n- With the unsafe package there are no guarantees.\n- Clear is better than clever.\n- Reflection is never clear.\n- Errors are values.\n- Don't just check errors, handle them gracefully.\n- Design the architecture, name the components, document the details.\n- Documentation is for users.\n- Don't panic.\n"}, {"path": "patterns/error-handling.md", "category": "patterns", "name": "patterns/error-handling", "content": "# Go Error Handling Patterns\n\n## Basic Pattern\n\n```go\nresult, err := doSomething()\nif err != nil {\n    return fmt.Errorf(\"doing something: %w\", err)\n}\n```\n\n## NEVER ignore errors\n\n```go\n// BAD - fails errcheck\nresult, _ := doSomething()\n\n// GOOD\nresult, err := doSomething()\nif err != nil {\n    return err\n}\n```\n\n## Error wrapping (Go 1.13+)\n\n```go\n// Wrap with context\nif err != nil {\n    return fmt.Errorf(\"failed to process %s: %w\", name, err)\n}\n\n// Check wrapped errors\nif errors.Is(err, os.ErrNotExist) {\n    // handle not found\n}\n\n// Type assert wrapped errors\nvar pathErr *os.PathError\nif errors.As(err, &pathErr) {\n    // handle path error\n}\n```\n\n## Sentinel errors\n\n```go\n// Define at package level\nvar ErrNotFound = errors.New(\"not found\")\n\n// Use errors.Is to check\nif errors.Is(err, ErrNotFound) {\n    // handle\n}\n```\n\n## Custom error types\n\n```go\ntype ValidationError struct {\n    Field string\n    Msg   string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"%s: %s\", e.Field, e.Msg)\n}\n```\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# Go Formatters\n\n## gofmt\n\nSee: https://pkg.go.dev/cmd/gofmt\n\n## goimports\n\nSee: https://pkg.go.dev/golang.org/x/tools/cmd/goimports\n\n## gofumpt\n\nSee: https://github.com/mvdan/gofumpt\n\n## golines\n\nSee: https://github.com/segmentio/golines\n"}, {"path": "formatters/goimports.md", "category": "formatters", "name": "formatters/goimports", "content": "# goimports Options\n\nSee: https://pkg.go.dev/golang.org/x/tools/cmd/goimports\n"}, {"path": "formatters/gofmt.md", "category": "formatters", "name": "formatters/gofmt", "content": "# gofmt Options\n\nSee: https://pkg.go.dev/cmd/gofmt\n"}, {"path": "formatters/gofumpt.md", "category": "formatters", "name": "formatters/gofumpt", "content": "# gofumpt Options\nVersion: unknown\n\nSource: https://github.com/mvdan/gofumpt\n\n\nSee: https://github.com/mvdan/gofumpt\n"}, {"path": "formatters/golines.md", "category": "formatters", "name": "formatters/golines", "content": "# golines Options\nVersion: unknown\n\nSource: https://github.com/segmentio/golines\n\n\nSee: https://github.com/segmentio/golines\n"}, {"path": "stdlib/debug-elf.md", "category": "stdlib", "name": "stdlib/debug-elf", "content": "package elf // import \"debug/elf\"\n\nPackage elf implements access to ELF object files.\n\n# Security\n\nThis package is not designed to be hardened against adversarial inputs,\nand is outside the scope of https://go.dev/security/policy. In particular,\nonly basic validation is done when parsing object files. As such, care should\nbe taken when parsing untrusted inputs, as parsing malformed files may consume\nsignificant resources, or cause panics.\n\nCONSTANTS\n\nconst (\n\tEI_CLASS      = 4  /* Class of machine. */\n\tEI_DATA       = 5  /* Data format. */\n\tEI_VERSION    = 6  /* ELF format version. */\n\tEI_OSABI      = 7  /* Operating system / ABI identification */\n\tEI_ABIVERSION = 8  /* ABI version */\n\tEI_PAD        = 9  /* Start of padding (per SVR4 ABI). */\n\tEI_NIDENT     = 16 /* Size of e_ident array. */\n)\n    Indexes into the Header.Ident array.\n\nconst ARM_MAGIC_TRAMP_NUMBER = 0x5c000003\n    Magic number for the elf trampoline, chosen wisely to be an immediate value.\n\nconst ELFMAG = \"\\177ELF\"\n    Initial magic number for ELF files.\n\nconst Sym32Size = 16\nconst Sym64Size = 24\n\nVARIABLES\n\nvar ErrNoSymbols = errors.New(\"no symbol section\")\n    ErrNoSymbols is returned by File.Symbols and File.DynamicSymbols if there is\n    no such section in the File.\n\n\nFUNCTIONS\n\nfunc NewFile(r io.ReaderAt) (*File, error)\n    NewFile creates a new File for accessing an ELF binary in an underlying\n    reader. The ELF binary is expected to start at position 0 in the ReaderAt.\n\nfunc Open(name string) (*File, error)\n    Open opens the named file using os.Open and prepares it for use as an ELF\n    binary.\n\nfunc R_INFO(sym, typ uint32) uint64\nfunc R_INFO32(sym, typ uint32) uint32\nfunc R_SYM32(info uint32) uint32\nfunc R_SYM64(info uint64) uint32\nfunc R_TYPE32(info uint32) uint32\nfunc R_TYPE64(info uint64) uint32\nfunc ST_INFO(bind SymBind, typ SymType) uint8\n\nTYPES\n\ntype Chdr32 struct {\n\tType      uint32\n\tSize      uint32\n\tAddralign uint32\n}\n    ELF32 Compression header.\n\ntype Chdr64 struct {\n\tType uint32\n\n\tSize      uint64\n\tAddralign uint64\n\t// Has unexported fields.\n}\n    ELF64 Compression header.\n\ntype Class byte\n    Class is found in Header.Ident[EI_CLASS] and Header.Class.\n\nconst (\n\tELFCLASSNONE Class = 0 /* Unknown class. */\n\tELFCLASS32   Class = 1 /* 32-bit architecture. */\n\tELFCLASS64   Class = 2 /* 64-bit architecture. */\n)\nfunc (i Class) GoString() string\n\nfunc (i Class) String() string\n\ntype CompressionType int\n    Section compression type.\n\nconst (\n\tCOMPRESS_ZLIB   CompressionType = 1          /* ZLIB compression. */\n\tCOMPRESS_ZSTD   CompressionType = 2          /* ZSTD compression. */\n\tCOMPRESS_LOOS   CompressionType = 0x60000000 /* First OS-specific. */\n\tCOMPRESS_HIOS   CompressionType = 0x6fffffff /* Last OS-specific. */\n\tCOMPRESS_LOPROC CompressionType = 0x70000000 /* First processor-specific type. */\n\tCOMPRESS_HIPROC CompressionType = 0x7fffffff /* Last processor-specific type. */\n)\nfunc (i CompressionType) GoString() string\n\nfunc (i CompressionType) String() string\n\ntype Data byte\n    Data is found in Header.Ident[EI_DATA] and Header.Data.\n\nconst (\n\tELFDATANONE Data = 0 /* Unknown data format. */\n\tELFDATA2LSB Data = 1 /* 2's complement little-endian. */\n\tELFDATA2MSB Data = 2 /* 2's complement big-endian. */\n)\nfunc (i Data) GoString() string\n\nfunc (i Data) String() string\n\ntype Dyn32 struct {\n\tTag int32  /* Entry type. */\n\tVal uint32 /* Integer/Address value. */\n}\n    ELF32 Dynamic structure. The \".dynamic\" section contains an array of them.\n\ntype Dyn64 struct {\n\tTag int64  /* Entry type. */\n\tVal uint64 /* Integer/address value */\n}\n    ELF64 Dynamic structure. The \".dynamic\" section contains an array of them.\n\ntype DynFlag int\n    DT_FLAGS values.\n\nconst (\n\tDF_ORIGIN DynFlag = 0x0001 /* Indicates that the object being loaded may\n\t   make reference to the\n\t   $ORIGIN substitution string */\n\tDF_SYMBOLIC DynFlag = 0x0002 /* Indicates \"symbolic\" linking. */\n\tDF_TEXTREL  DynFlag = 0x0004 /* Indicates there may be relocations in non-writable segments. */\n\tDF_BIND_NOW DynFlag = 0x0008 /* Indicates that the dynamic linker should\n\t   process all relocations for the object\n\t   containing this entry before transferring\n\t   control to the program. */\n\tDF_STATIC_TLS DynFlag = 0x0010 /* Indicates that the shared object or\n\t   executable contains code using a static\n\t   thread-local storage scheme. */\n)\nfunc (i DynFlag) GoString() string\n\nfunc (i DynFlag) String() string\n\ntype DynFlag1 uint32\n    DT_FLAGS_1 values.\n\nconst (\n\t// Indicates that all relocations for this object must be processed before\n\t// returning control to the program.\n\tDF_1_NOW DynFlag1 = 0x00000001\n\t// Unused.\n\tDF_1_GLOBAL DynFlag1 = 0x00000002\n\t// Indicates that the object is a member of a group.\n\tDF_1_GROUP DynFlag1 = 0x00000004\n\t// Indicates that the object cannot be deleted from a process.\n\tDF_1_NODELETE DynFlag1 = 0x00000008\n\t// Meaningful only for filters. Indicates that all associated filtees be\n\t// processed immediately.\n\tDF_1_LOADFLTR DynFlag1 = 0x00000010\n\t// Indicates that this object's initialization section be run before any other\n\t// objects loaded.\n\tDF_1_INITFIRST DynFlag1 = 0x00000020\n\t// Indicates that the object cannot be added to a running process with dlopen.\n\tDF_1_NOOPEN DynFlag1 = 0x00000040\n\t// Indicates the object requires $ORIGIN processing.\n\tDF_1_ORIGIN DynFlag1 = 0x00000080\n\t// Indicates that the object should use direct binding information.\n\tDF_1_DIRECT DynFlag1 = 0x00000100\n\t// Unused.\n\tDF_1_TRANS DynFlag1 = 0x00000200\n\t// Indicates that the objects symbol table is to interpose before all symbols\n\t// except the primary load object, which is typically the executable.\n\tDF_1_INTERPOSE DynFlag1 = 0x00000400\n\t// Indicates that the search for dependencies of this object ignores any\n\t// default library search paths.\n\tDF_1_NODEFLIB DynFlag1 = 0x00000800\n\t// Indicates that this object is not dumped by dldump. Candidates are objects\n\t// with no relocations that might get included when generating alternative\n\t// objects using.\n\tDF_1_NODUMP DynFlag1 = 0x00001000\n\t// Identifies this object as a configuration alternative object generated by\n\t// crle. Triggers the runtime linker to search for a configuration file $ORIGIN/ld.config.app-name.\n\tDF_1_CONFALT DynFlag1 = 0x00002000\n\t// Meaningful only for filtees. Terminates a filters search for any\n\t// further filtees.\n\tDF_1_ENDFILTEE DynFlag1 = 0x00004000\n\t// Indicates that this object has displacement relocations applied.\n\tDF_1_DISPRELDNE DynFlag1 = 0x00008000\n\t// Indicates that this object has displacement relocations pending.\n\tDF_1_DISPRELPND DynFlag1 = 0x00010000\n\t// Indicates that this object contains symbols that cannot be directly\n\t// bound to.\n\tDF_1_NODIRECT DynFlag1 = 0x00020000\n\t// Reserved for internal use by the kernel runtime-linker.\n\tDF_1_IGNMULDEF DynFlag1 = 0x00040000\n\t// Reserved for internal use by the kernel runtime-linker.\n\tDF_1_NOKSYMS DynFlag1 = 0x00080000\n\t// Reserved for internal use by the kernel runtime-linker.\n\tDF_1_NOHDR DynFlag1 = 0x00100000\n\t// Indicates that this object has been edited or has been modified since the\n\t// objects original construction by the link-editor.\n\tDF_1_EDITED DynFlag1 = 0x00200000\n\t// Reserved for internal use by the kernel runtime-linker.\n\tDF_1_NORELOC DynFlag1 = 0x00400000\n\t// Indicates that the object contains individual symbols that should interpose\n\t// before all symbols except the primary load object, which is typically the\n\t// executable.\n\tDF_1_SYMINTPOSE DynFlag1 = 0x00800000\n\t// Indicates that the executable requires global auditing.\n\tDF_1_GLOBAUDIT DynFlag1 = 0x01000000\n\t// Indicates that the object defines, or makes reference to singleton symbols.\n\tDF_1_SINGLETON DynFlag1 = 0x02000000\n\t// Indicates that the object is a stub.\n\tDF_1_STUB DynFlag1 = 0x04000000\n\t// Indicates that the object is a position-independent executable.\n\tDF_1_PIE DynFlag1 = 0x08000000\n\t// Indicates that the object is a kernel module.\n\tDF_1_KMOD DynFlag1 = 0x10000000\n\t// Indicates that the object is a weak standard filter.\n\tDF_1_WEAKFILTER DynFlag1 = 0x20000000\n\t// Unused.\n\tDF_1_NOCOMMON DynFlag1 = 0x40000000\n)\nfunc (i DynFlag1) GoString() string\n\nfunc (i DynFlag1) String() string\n\ntype DynTag int\n    Dyn.Tag\n\nconst (\n\tDT_NULL         DynTag = 0  /* Terminating entry. */\n\tDT_NEEDED       DynTag = 1  /* String table offset of a needed shared library. */\n\tDT_PLTRELSZ     DynTag = 2  /* Total size in bytes of PLT relocations. */\n\tDT_PLTGOT       DynTag = 3  /* Processor-dependent address. */\n\tDT_HASH         DynTag = 4  /* Address of symbol hash table. */\n\tDT_STRTAB       DynTag = 5  /* Address of string table. */\n\tDT_SYMTAB       DynTag = 6  /* Address of symbol table. */\n\tDT_RELA         DynTag = 7  /* Address of ElfNN_Rela relocations. */\n\tDT_RELASZ       DynTag = 8  /* Total size of ElfNN_Rela relocations. */\n\tDT_RELAENT      DynTag = 9  /* Size of each ElfNN_Rela relocation entry. */\n\tDT_STRSZ        DynTag = 10 /* Size of string table. */\n\tDT_SYMENT       DynTag = 11 /* Size of each symbol table entry. */\n\tDT_INIT         DynTag = 12 /* Address of initialization function. */\n\tDT_FINI         DynTag = 13 /* Address of finalization function. */\n\tDT_SONAME       DynTag = 14 /* String table offset of shared object name. */\n\tDT_RPATH        DynTag = 15 /* String table offset of library path. [sup] */\n\tDT_SYMBOLIC     DynTag = 16 /* Indicates \"symbolic\" linking. [sup] */\n\tDT_REL          DynTag = 17 /* Address of ElfNN_Rel relocations. */\n\tDT_RELSZ        DynTag = 18 /* Total size of ElfNN_Rel relocations. */\n\tDT_RELENT       DynTag = 19 /* Size of each ElfNN_Rel relocation. */\n\tDT_PLTREL       DynTag = 20 /* Type of relocation used for PLT. */\n\tDT_DEBUG        DynTag = 21 /* Reserved (not used). */\n\tDT_TEXTREL      DynTag = 22 /* Indicates there may be relocations in non-writable segments. [sup] */\n\tDT_JMPREL       DynTag = 23 /* Address of PLT relocations. */\n\tDT_BIND_NOW     DynTag = 24 /* [sup] */\n\tDT_INIT_ARRAY   DynTag = 25 /* Address of the array of pointers to initialization functions */\n\tDT_FINI_ARRAY   DynTag = 26 /* Address of the array of pointers to termination functions */\n\tDT_INIT_ARRAYSZ DynTag = 27 /* Size in bytes of the array of initialization functions. */\n\tDT_FINI_ARRAYSZ DynTag = 28 /* Size in bytes of the array of termination functions. */\n\tDT_RUNPATH      DynTag = 29 /* String table offset of a null-terminated library search path string. */\n\tDT_FLAGS        DynTag = 30 /* Object specific flag values. */\n\tDT_ENCODING     DynTag = 32 /* Values greater than or equal to DT_ENCODING\n\t   and less than DT_LOOS follow the rules for\n\t   the interpretation of the d_un union\n\t   as follows: even == 'd_ptr', even == 'd_val'\n\t   or none */\n\tDT_PREINIT_ARRAY   DynTag = 32 /* Address of the array of pointers to pre-initialization functions. */\n\tDT_PREINIT_ARRAYSZ DynTag = 33 /* Size in bytes of the array of pre-initialization functions. */\n\tDT_SYMTAB_SHNDX    DynTag = 34 /* Address of SHT_SYMTAB_SHNDX section. */\n\n\tDT_LOOS DynTag = 0x6000000d /* First OS-specific */\n\tDT_HIOS DynTag = 0x6ffff000 /* Last OS-specific */\n\n\tDT_VALRNGLO       DynTag = 0x6ffffd00\n\tDT_GNU_PRELINKED  DynTag = 0x6ffffdf5\n\tDT_GNU_CONFLICTSZ DynTag = 0x6ffffdf6\n\tDT_GNU_LIBLISTSZ  DynTag = 0x6ffffdf7\n\tDT_CHECKSUM       DynTag = 0x6ffffdf8\n\tDT_PLTPADSZ       DynTag = 0x6ffffdf9\n\tDT_MOVEENT        DynTag = 0x6ffffdfa\n\tDT_MOVESZ         DynTag = 0x6ffffdfb\n\tDT_FEATURE        DynTag = 0x6ffffdfc\n\tDT_POSFLAG_1      DynTag = 0x6ffffdfd\n\tDT_SYMINSZ        DynTag = 0x6ffffdfe\n\tDT_SYMINENT       DynTag = 0x6ffffdff\n\tDT_VALRNGHI       DynTag = 0x6ffffdff\n\n\tDT_ADDRRNGLO    DynTag = 0x6ffffe00\n\tDT_GNU_HASH     DynTag = 0x6ffffef5\n\tDT_TLSDESC_PLT  DynTag = 0x6ffffef6\n\tDT_TLSDESC_GOT  DynTag = 0x6ffffef7\n\tDT_GNU_CONFLICT DynTag = 0x6ffffef8\n\tDT_GNU_LIBLIST  DynTag = 0x6ffffef9\n\tDT_CONFIG       DynTag = 0x6ffffefa\n\tDT_DEPAUDIT     DynTag = 0x6ffffefb\n\tDT_AUDIT        DynTag = 0x6ffffefc\n\tDT_PLTPAD       DynTag = 0x6ffffefd\n\tDT_MOVETAB      DynTag = 0x6ffffefe\n\tDT_SYMINFO      DynTag = 0x6ffffeff\n\tDT_ADDRRNGHI    DynTag = 0x6ffffeff\n\n\tDT_VERSYM     DynTag = 0x6ffffff0\n\tDT_RELACOUNT  DynTag = 0x6ffffff9\n\tDT_RELCOUNT   DynTag = 0x6ffffffa\n\tDT_FLAGS_1    DynTag = 0x6ffffffb\n\tDT_VERDEF     DynTag = 0x6ffffffc\n\tDT_VERDEFNUM  DynTag = 0x6ffffffd\n\tDT_VERNEED    DynTag = 0x6ffffffe\n\tDT_VERNEEDNUM DynTag = 0x6fffffff\n\n\tDT_LOPROC DynTag = 0x70000000 /* First processor-specific type. */\n\n\tDT_MIPS_RLD_VERSION           DynTag = 0x70000001\n\tDT_MIPS_TIME_STAMP            DynTag = 0x70000002\n\tDT_MIPS_ICHECKSUM             DynTag = 0x70000003\n\tDT_MIPS_IVERSION              DynTag = 0x70000004\n\tDT_MIPS_FLAGS                 DynTag = 0x70000005\n\tDT_MIPS_BASE_ADDRESS          DynTag = 0x70000006\n\tDT_MIPS_MSYM                  DynTag = 0x70000007\n\tDT_MIPS_CONFLICT              DynTag = 0x70000008\n\tDT_MIPS_LIBLIST               DynTag = 0x70000009\n\tDT_MIPS_LOCAL_GOTNO           DynTag = 0x7000000a\n\tDT_MIPS_CONFLICTNO            DynTag = 0x7000000b\n\tDT_MIPS_LIBLISTNO             DynTag = 0x70000010\n\tDT_MIPS_SYMTABNO              DynTag = 0x70000011\n\tDT_MIPS_UNREFEXTNO            DynTag = 0x70000012\n\tDT_MIPS_GOTSYM                DynTag = 0x70000013\n\tDT_MIPS_HIPAGENO              DynTag = 0x70000014\n\tDT_MIPS_RLD_MAP               DynTag = 0x70000016\n\tDT_MIPS_DELTA_CLASS           DynTag = 0x70000017\n\tDT_MIPS_DELTA_CLASS_NO        DynTag = 0x70000018\n\tDT_MIPS_DELTA_INSTANCE        DynTag = 0x70000019\n\tDT_MIPS_DELTA_INSTANCE_NO     DynTag = 0x7000001a\n\tDT_MIPS_DELTA_RELOC           DynTag = 0x7000001b\n\tDT_MIPS_DELTA_RELOC_NO        DynTag = 0x7000001c\n\tDT_MIPS_DELTA_SYM             DynTag = 0x7000001d\n\tDT_MIPS_DELTA_SYM_NO          DynTag = 0x7000001e\n\tDT_MIPS_DELTA_CLASSSYM        DynTag = 0x70000020\n\tDT_MIPS_DELTA_CLASSSYM_NO     DynTag = 0x70000021\n\tDT_MIPS_CXX_FLAGS             DynTag = 0x70000022\n\tDT_MIPS_PIXIE_INIT            DynTag = 0x70000023\n\tDT_MIPS_SYMBOL_LIB            DynTag = 0x70000024\n\tDT_MIPS_LOCALPAGE_GOTIDX      DynTag = 0x70000025\n\tDT_MIPS_LOCAL_GOTIDX          DynTag = 0x70000026\n\tDT_MIPS_HIDDEN_GOTIDX         DynTag = 0x70000027\n\tDT_MIPS_PROTECTED_GOTIDX      DynTag = 0x70000028\n\tDT_MIPS_OPTIONS               DynTag = 0x70000029\n\tDT_MIPS_INTERFACE             DynTag = 0x7000002a\n\tDT_MIPS_DYNSTR_ALIGN          DynTag = 0x7000002b\n\tDT_MIPS_INTERFACE_SIZE        DynTag = 0x7000002c\n\tDT_MIPS_RLD_TEXT_RESOLVE_ADDR DynTag = 0x7000002d\n\tDT_MIPS_PERF_SUFFIX           DynTag = 0x7000002e\n\tDT_MIPS_COMPACT_SIZE          DynTag = 0x7000002f\n\tDT_MIPS_GP_VALUE              DynTag = 0x70000030\n\tDT_MIPS_AUX_DYNAMIC           DynTag = 0x70000031\n\tDT_MIPS_PLTGOT                DynTag = 0x70000032\n\tDT_MIPS_RWPLT                 DynTag = 0x70000034\n\tDT_MIPS_RLD_MAP_REL           DynTag = 0x70000035\n\n\tDT_PPC_GOT DynTag = 0x70000000\n\tDT_PPC_OPT DynTag = 0x70000001\n\n\tDT_PPC64_GLINK DynTag = 0x70000000\n\tDT_PPC64_OPD   DynTag = 0x70000001\n\tDT_PPC64_OPDSZ DynTag = 0x70000002\n\tDT_PPC64_OPT   DynTag = 0x70000003\n\n\tDT_SPARC_REGISTER DynTag = 0x70000001\n\n\tDT_AUXILIARY DynTag = 0x7ffffffd\n\tDT_USED      DynTag = 0x7ffffffe\n\tDT_FILTER    DynTag = 0x7fffffff\n\n\tDT_HIPROC DynTag = 0x7fffffff /* Last processor-specific type. */\n)\nfunc (i DynTag) GoString() string\n\nfunc (i DynTag) String() string\n\ntype DynamicVersion struct {\n\tName  string // Name of version defined by this index.\n\tIndex uint16 // Version index.\n\tFlags DynamicVersionFlag\n\tDeps  []string // Names of versions that this version depends upon.\n}\n    DynamicVersion is a version defined by a dynamic object. This describes\n    entries in the ELF SHT_GNU_verdef section. We assume that the vd_version\n    field is 1. Note that the name of the version appears here; it is not in the\n    first Deps entry as it is in the ELF file.\n\ntype DynamicVersionDep struct {\n\tFlags DynamicVersionFlag\n\tIndex uint16 // Version index.\n\tDep   string // Name of required version.\n}\n    DynamicVersionDep is a version needed from some shared library.\n\ntype DynamicVersionFlag uint16\n    Dynamic version flags.\n\nconst (\n\tVER_FLG_BASE DynamicVersionFlag = 0x1 /* Version definition of the file. */\n\tVER_FLG_WEAK DynamicVersionFlag = 0x2 /* Weak version identifier. */\n\tVER_FLG_INFO DynamicVersionFlag = 0x4 /* Reference exists for informational purposes. */\n)\ntype DynamicVersionNeed struct {\n\tName  string              // Shared library name.\n\tNeeds []DynamicVersionDep // Dependencies.\n}\n    DynamicVersionNeed describes a shared library needed by a dynamic object,\n    with a list of the versions needed from that shared library. This describes\n    entries in the ELF SHT_GNU_verneed section. We assume that the vn_version\n    field is 1.\n\ntype File struct {\n\tFileHeader\n\tSections []*Section\n\tProgs    []*Prog\n\n\t// Has unexported fields.\n}\n    A File represents an open ELF file.\n\nfunc (f *File) Close() error\n    Close closes the File. If the File was created using NewFile directly\n    instead of Open, Close has no effect.\n\nfunc (f *File) DWARF() (*dwarf.Data, error)\n\nfunc (f *File) DynString(tag DynTag) ([]string, error)\n    DynString returns the strings listed for the given tag in the file's dynamic\n    section.\n\n    The tag must be one that takes string values: DT_NEEDED, DT_SONAME,\n    DT_RPATH, or DT_RUNPATH.\n\nfunc (f *File) DynValue(tag DynTag) ([]uint64, error)\n    DynValue returns the values listed for the given tag in the file's dynamic\n    section.\n\nfunc (f *File) DynamicSymbols() ([]Symbol, error)\n    DynamicSymbols returns the dynamic symbol table for f. The symbols will be\n    listed in the order they appear in f.\n\n    If f has a symbol version table, the returned File.Symbols will have\n    initialized Version and Library fields.\n\n    For compatibility with File.Symbols, File.DynamicSymbols omits the null\n    symbol at index 0. After retrieving the symbols as symtab, an externally\n    supplied index x corresponds to symtab[x-1], not symtab[x].\n\nfunc (f *File) DynamicVersionNeeds() ([]DynamicVersionNeed, error)\n    DynamicVersionNeeds returns version dependencies for a dynamic object.\n\nfunc (f *File) DynamicVersions() ([]DynamicVersion, error)\n    DynamicVersions returns version information for a dynamic object.\n\nfunc (f *File) ImportedLibraries() ([]string, error)\n    ImportedLibraries returns the names of all libraries referred to by the\n    binary f that are expected to be linked with the binary at dynamic link\n    time.\n\nfunc (f *File) ImportedSymbols() ([]ImportedSymbol, error)\n    ImportedSymbols returns the names of all symbols referred to by the binary\n    f that are expected to be satisfied by other libraries at dynamic load time.\n    It does not return weak symbols.\n\nfunc (f *File) Section(name string) *Section\n    Section returns a section with the given name, or nil if no such section\n    exists.\n\nfunc (f *File) SectionByType(typ SectionType) *Section\n    SectionByType returns the first section in f with the given type, or nil if\n    there is no such section.\n\nfunc (f *File) Symbols() ([]Symbol, error)\n    Symbols returns the symbol table for f. The symbols will be listed in the\n    order they appear in f.\n\n    For compatibility with Go 1.0, Symbols omits the null symbol at index 0.\n    After retrieving the symbols as symtab, an externally supplied index x\n    corresponds to symtab[x-1], not symtab[x].\n\ntype FileHeader struct {\n\tClass      Class\n\tData       Data\n\tVersion    Version\n\tOSABI      OSABI\n\tABIVersion uint8\n\tByteOrder  binary.ByteOrder\n\tType       Type\n\tMachine    Machine\n\tEntry      uint64\n}\n    A FileHeader represents an ELF file header.\n\ntype FormatError struct {\n\t// Has unexported fields.\n}\n\nfunc (e *FormatError) Error() string\n\ntype Header32 struct {\n\tIdent     [EI_NIDENT]byte /* File identification. */\n\tType      uint16          /* File type. */\n\tMachine   uint16          /* Machine architecture. */\n\tVersion   uint32          /* ELF format version. */\n\tEntry     uint32          /* Entry point. */\n\tPhoff     uint32          /* Program header file offset. */\n\tShoff     uint32          /* Section header file offset. */\n\tFlags     uint32          /* Architecture-specific flags. */\n\tEhsize    uint16          /* Size of ELF header in bytes. */\n\tPhentsize uint16          /* Size of program header entry. */\n\tPhnum     uint16          /* Number of program header entries. */\n\tShentsize uint16          /* Size of section header entry. */\n\tShnum     uint16          /* Number of section header entries. */\n\tShstrndx  uint16          /* Section name strings section. */\n}\n    ELF32 File header.\n\ntype Header64 struct {\n\tIdent     [EI_NIDENT]byte /* File identification. */\n\tType      uint16          /* File type. */\n\tMachine   uint16          /* Machine architecture. */\n\tVersion   uint32          /* ELF format version. */\n\tEntry     uint64          /* Entry point. */\n\tPhoff     uint64          /* Program header file offset. */\n\tShoff     uint64          /* Section header file offset. */\n\tFlags     uint32          /* Architecture-specific flags. */\n\tEhsize    uint16          /* Size of ELF header in bytes. */\n\tPhentsize uint16          /* Size of program header entry. */\n\tPhnum     uint16          /* Number of program header entries. */\n\tShentsize uint16          /* Size of section header entry. */\n\tShnum     uint16          /* Number of section header entries. */\n\tShstrndx  uint16          /* Section name strings section. */\n}\n    ELF64 file header.\n\ntype ImportedSymbol struct {\n\tName    string\n\tVersion string\n\tLibrary string\n}\n\ntype Machine uint16\n    Machine is found in Header.Machine.\n\nconst (\n\tEM_NONE          Machine = 0   /* Unknown machine. */\n\tEM_M32           Machine = 1   /* AT&T WE32100. */\n\tEM_SPARC         Machine = 2   /* Sun SPARC. */\n\tEM_386           Machine = 3   /* Intel i386. */\n\tEM_68K           Machine = 4   /* Motorola 68000. */\n\tEM_88K           Machine = 5   /* Motorola 88000. */\n\tEM_860           Machine = 7   /* Intel i860. */\n\tEM_MIPS          Machine = 8   /* MIPS R3000 Big-Endian only. */\n\tEM_S370          Machine = 9   /* IBM System/370. */\n\tEM_MIPS_RS3_LE   Machine = 10  /* MIPS R3000 Little-Endian. */\n\tEM_PARISC        Machine = 15  /* HP PA-RISC. */\n\tEM_VPP500        Machine = 17  /* Fujitsu VPP500. */\n\tEM_SPARC32PLUS   Machine = 18  /* SPARC v8plus. */\n\tEM_960           Machine = 19  /* Intel 80960. */\n\tEM_PPC           Machine = 20  /* PowerPC 32-bit. */\n\tEM_PPC64         Machine = 21  /* PowerPC 64-bit. */\n\tEM_S390          Machine = 22  /* IBM System/390. */\n\tEM_V800          Machine = 36  /* NEC V800. */\n\tEM_FR20          Machine = 37  /* Fujitsu FR20. */\n\tEM_RH32          Machine = 38  /* TRW RH-32. */\n\tEM_RCE           Machine = 39  /* Motorola RCE. */\n\tEM_ARM           Machine = 40  /* ARM. */\n\tEM_SH            Machine = 42  /* Hitachi SH. */\n\tEM_SPARCV9       Machine = 43  /* SPARC v9 64-bit. */\n\tEM_TRICORE       Machine = 44  /* Siemens TriCore embedded processor. */\n\tEM_ARC           Machine = 45  /* Argonaut RISC Core. */\n\tEM_H8_300        Machine = 46  /* Hitachi H8/300. */\n\tEM_H8_300H       Machine = 47  /* Hitachi H8/300H. */\n\tEM_H8S           Machine = 48  /* Hitachi H8S. */\n\tEM_H8_500        Machine = 49  /* Hitachi H8/500. */\n\tEM_IA_64         Machine = 50  /* Intel IA-64 Processor. */\n\tEM_MIPS_X        Machine = 51  /* Stanford MIPS-X. */\n\tEM_COLDFIRE      Machine = 52  /* Motorola ColdFire. */\n\tEM_68HC12        Machine = 53  /* Motorola M68HC12. */\n\tEM_MMA           Machine = 54  /* Fujitsu MMA. */\n\tEM_PCP           Machine = 55  /* Siemens PCP. */\n\tEM_NCPU          Machine = 56  /* Sony nCPU. */\n\tEM_NDR1          Machine = 57  /* Denso NDR1 microprocessor. */\n\tEM_STARCORE      Machine = 58  /* Motorola Star*Core processor. */\n\tEM_ME16          Machine = 59  /* Toyota ME16 processor. */\n\tEM_ST100         Machine = 60  /* STMicroelectronics ST100 processor. */\n\tEM_TINYJ         Machine = 61  /* Advanced Logic Corp. TinyJ processor. */\n\tEM_X86_64        Machine = 62  /* Advanced Micro Devices x86-64 */\n\tEM_PDSP          Machine = 63  /* Sony DSP Processor */\n\tEM_PDP10         Machine = 64  /* Digital Equipment Corp. PDP-10 */\n\tEM_PDP11         Machine = 65  /* Digital Equipment Corp. PDP-11 */\n\tEM_FX66          Machine = 66  /* Siemens FX66 microcontroller */\n\tEM_ST9PLUS       Machine = 67  /* STMicroelectronics ST9+ 8/16 bit microcontroller */\n\tEM_ST7           Machine = 68  /* STMicroelectronics ST7 8-bit microcontroller */\n\tEM_68HC16        Machine = 69  /* Motorola MC68HC16 Microcontroller */\n\tEM_68HC11        Machine = 70  /* Motorola MC68HC11 Microcontroller */\n\tEM_68HC08        Machine = 71  /* Motorola MC68HC08 Microcontroller */\n\tEM_68HC05        Machine = 72  /* Motorola MC68HC05 Microcontroller */\n\tEM_SVX           Machine = 73  /* Silicon Graphics SVx */\n\tEM_ST19          Machine = 74  /* STMicroelectronics ST19 8-bit microcontroller */\n\tEM_VAX           Machine = 75  /* Digital VAX */\n\tEM_CRIS          Machine = 76  /* Axis Communications 32-bit embedded processor */\n\tEM_JAVELIN       Machine = 77  /* Infineon Technologies 32-bit embedded processor */\n\tEM_FIREPATH      Machine = 78  /* Element 14 64-bit DSP Processor */\n\tEM_ZSP           Machine = 79  /* LSI Logic 16-bit DSP Processor */\n\tEM_MMIX          Machine = 80  /* Donald Knuth's educational 64-bit processor */\n\tEM_HUANY         Machine = 81  /* Harvard University machine-independent object files */\n\tEM_PRISM         Machine = 82  /* SiTera Prism */\n\tEM_AVR           Machine = 83  /* Atmel AVR 8-bit microcontroller */\n\tEM_FR30          Machine = 84  /* Fujitsu FR30 */\n\tEM_D10V          Machine = 85  /* Mitsubishi D10V */\n\tEM_D30V          Machine = 86  /* Mitsubishi D30V */\n\tEM_V850          Machine = 87  /* NEC v850 */\n\tEM_M32R          Machine = 88  /* Mitsubishi M32R */\n\tEM_MN10300       Machine = 89  /* Matsushita MN10300 */\n\tEM_MN10200       Machine = 90  /* Matsushita MN10200 */\n\tEM_PJ            Machine = 91  /* picoJava */\n\tEM_OPENRISC      Machine = 92  /* OpenRISC 32-bit embedded processor */\n\tEM_ARC_COMPACT   Machine = 93  /* ARC International ARCompact processor (old spelling/synonym: EM_ARC_A5) */\n\tEM_XTENSA        Machine = 94  /* Tensilica Xtensa Architecture */\n\tEM_VIDEOCORE     Machine = 95  /* Alphamosaic VideoCore processor */\n\tEM_TMM_GPP       Machine = 96  /* Thompson Multimedia General Purpose Processor */\n\tEM_NS32K         Machine = 97  /* National Semiconductor 32000 series */\n\tEM_TPC           Machine = 98  /* Tenor Network TPC processor */\n\tEM_SNP1K         Machine = 99  /* Trebia SNP 1000 processor */\n\tEM_ST200         Machine = 100 /* STMicroelectronics (www.st.com) ST200 microcontroller */\n\tEM_IP2K          Machine = 101 /* Ubicom IP2xxx microcontroller family */\n\tEM_MAX           Machine = 102 /* MAX Processor */\n\tEM_CR            Machine = 103 /* National Semiconductor CompactRISC microprocessor */\n\tEM_F2MC16        Machine = 104 /* Fujitsu F2MC16 */\n\tEM_MSP430        Machine = 105 /* Texas Instruments embedded microcontroller msp430 */\n\tEM_BLACKFIN      Machine = 106 /* Analog Devices Blackfin (DSP) processor */\n\tEM_SE_C33        Machine = 107 /* S1C33 Family of Seiko Epson processors */\n\tEM_SEP           Machine = 108 /* Sharp embedded microprocessor */\n\tEM_ARCA          Machine = 109 /* Arca RISC Microprocessor */\n\tEM_UNICORE       Machine = 110 /* Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University */\n\tEM_EXCESS        Machine = 111 /* eXcess: 16/32/64-bit configurable embedded CPU */\n\tEM_DXP           Machine = 112 /* Icera Semiconductor Inc. Deep Execution Processor */\n\tEM_ALTERA_NIOS2  Machine = 113 /* Altera Nios II soft-core processor */\n\tEM_CRX           Machine = 114 /* National Semiconductor CompactRISC CRX microprocessor */\n\tEM_XGATE         Machine = 115 /* Motorola XGATE embedded processor */\n\tEM_C166          Machine = 116 /* Infineon C16x/XC16x processor */\n\tEM_M16C          Machine = 117 /* Renesas M16C series microprocessors */\n\tEM_DSPIC30F      Machine = 118 /* Microchip Technology dsPIC30F Digital Signal Controller */\n\tEM_CE            Machine = 119 /* Freescale Communication Engine RISC core */\n\tEM_M32C          Machine = 120 /* Renesas M32C series microprocessors */\n\tEM_TSK3000       Machine = 131 /* Altium TSK3000 core */\n\tEM_RS08          Machine = 132 /* Freescale RS08 embedded processor */\n\tEM_SHARC         Machine = 133 /* Analog Devices SHARC family of 32-bit DSP processors */\n\tEM_ECOG2         Machine = 134 /* Cyan Technology eCOG2 microprocessor */\n\tEM_SCORE7        Machine = 135 /* Sunplus S+core7 RISC processor */\n\tEM_DSP24         Machine = 136 /* New Japan Radio (NJR) 24-bit DSP Processor */\n\tEM_VIDEOCORE3    Machine = 137 /* Broadcom VideoCore III processor */\n\tEM_LATTICEMICO32 Machine = 138 /* RISC processor for Lattice FPGA architecture */\n\tEM_SE_C17        Machine = 139 /* Seiko Epson C17 family */\n\tEM_TI_C6000      Machine = 140 /* The Texas Instruments TMS320C6000 DSP family */\n\tEM_TI_C2000      Machine = 141 /* The Texas Instruments TMS320C2000 DSP family */\n\tEM_TI_C5500      Machine = 142 /* The Texas Instruments TMS320C55x DSP family */\n\tEM_TI_ARP32      Machine = 143 /* Texas Instruments Application Specific RISC Processor, 32bit fetch */\n\tEM_TI_PRU        Machine = 144 /* Texas Instruments Programmable Realtime Unit */\n\tEM_MMDSP_PLUS    Machine = 160 /* STMicroelectronics 64bit VLIW Data Signal Processor */\n\tEM_CYPRESS_M8C   Machine = 161 /* Cypress M8C microprocessor */\n\tEM_R32C          Machine = 162 /* Renesas R32C series microprocessors */\n\tEM_TRIMEDIA      Machine = 163 /* NXP Semiconductors TriMedia architecture family */\n\tEM_QDSP6         Machine = 164 /* QUALCOMM DSP6 Processor */\n\tEM_8051          Machine = 165 /* Intel 8051 and variants */\n\tEM_STXP7X        Machine = 166 /* STMicroelectronics STxP7x family of configurable and extensible RISC processors */\n\tEM_NDS32         Machine = 167 /* Andes Technology compact code size embedded RISC processor family */\n\tEM_ECOG1         Machine = 168 /* Cyan Technology eCOG1X family */\n\tEM_ECOG1X        Machine = 168 /* Cyan Technology eCOG1X family */\n\tEM_MAXQ30        Machine = 169 /* Dallas Semiconductor MAXQ30 Core Micro-controllers */\n\tEM_XIMO16        Machine = 170 /* New Japan Radio (NJR) 16-bit DSP Processor */\n\tEM_MANIK         Machine = 171 /* M2000 Reconfigurable RISC Microprocessor */\n\tEM_CRAYNV2       Machine = 172 /* Cray Inc. NV2 vector architecture */\n\tEM_RX            Machine = 173 /* Renesas RX family */\n\tEM_METAG         Machine = 174 /* Imagination Technologies META processor architecture */\n\tEM_MCST_ELBRUS   Machine = 175 /* MCST Elbrus general purpose hardware architecture */\n\tEM_ECOG16        Machine = 176 /* Cyan Technology eCOG16 family */\n\tEM_CR16          Machine = 177 /* National Semiconductor CompactRISC CR16 16-bit microprocessor */\n\tEM_ETPU          Machine = 178 /* Freescale Extended Time Processing Unit */\n\tEM_SLE9X         Machine = 179 /* Infineon Technologies SLE9X core */\n\tEM_L10M          Machine = 180 /* Intel L10M */\n\tEM_K10M          Machine = 181 /* Intel K10M */\n\tEM_AARCH64       Machine = 183 /* ARM 64-bit Architecture (AArch64) */\n\tEM_AVR32         Machine = 185 /* Atmel Corporation 32-bit microprocessor family */\n\tEM_STM8          Machine = 186 /* STMicroeletronics STM8 8-bit microcontroller */\n\tEM_TILE64        Machine = 187 /* Tilera TILE64 multicore architecture family */\n\tEM_TILEPRO       Machine = 188 /* Tilera TILEPro multicore architecture family */\n\tEM_MICROBLAZE    Machine = 189 /* Xilinx MicroBlaze 32-bit RISC soft processor core */\n\tEM_CUDA          Machine = 190 /* NVIDIA CUDA architecture */\n\tEM_TILEGX        Machine = 191 /* Tilera TILE-Gx multicore architecture family */\n\tEM_CLOUDSHIELD   Machine = 192 /* CloudShield architecture family */\n\tEM_COREA_1ST     Machine = 193 /* KIPO-KAIST Core-A 1st generation processor family */\n\tEM_COREA_2ND     Machine = 194 /* KIPO-KAIST Core-A 2nd generation processor family */\n\tEM_ARC_COMPACT2  Machine = 195 /* Synopsys ARCompact V2 */\n\tEM_OPEN8         Machine = 196 /* Open8 8-bit RISC soft processor core */\n\tEM_RL78          Machine = 197 /* Renesas RL78 family */\n\tEM_VIDEOCORE5    Machine = 198 /* Broadcom VideoCore V processor */\n\tEM_78KOR         Machine = 199 /* Renesas 78KOR family */\n\tEM_56800EX       Machine = 200 /* Freescale 56800EX Digital Signal Controller (DSC) */\n\tEM_BA1           Machine = 201 /* Beyond BA1 CPU architecture */\n\tEM_BA2           Machine = 202 /* Beyond BA2 CPU architecture */\n\tEM_XCORE         Machine = 203 /* XMOS xCORE processor family */\n\tEM_MCHP_PIC      Machine = 204 /* Microchip 8-bit PIC(r) family */\n\tEM_INTEL205      Machine = 205 /* Reserved by Intel */\n\tEM_INTEL206      Machine = 206 /* Reserved by Intel */\n\tEM_INTEL207      Machine = 207 /* Reserved by Intel */\n\tEM_INTEL208      Machine = 208 /* Reserved by Intel */\n\tEM_INTEL209      Machine = 209 /* Reserved by Intel */\n\tEM_KM32          Machine = 210 /* KM211 KM32 32-bit processor */\n\tEM_KMX32         Machine = 211 /* KM211 KMX32 32-bit processor */\n\tEM_KMX16         Machine = 212 /* KM211 KMX16 16-bit processor */\n\tEM_KMX8          Machine = 213 /* KM211 KMX8 8-bit processor */\n\tEM_KVARC         Machine = 214 /* KM211 KVARC processor */\n\tEM_CDP           Machine = 215 /* Paneve CDP architecture family */\n\tEM_COGE          Machine = 216 /* Cognitive Smart Memory Processor */\n\tEM_COOL          Machine = 217 /* Bluechip Systems CoolEngine */\n\tEM_NORC          Machine = 218 /* Nanoradio Optimized RISC */\n\tEM_CSR_KALIMBA   Machine = 219 /* CSR Kalimba architecture family */\n\tEM_Z80           Machine = 220 /* Zilog Z80 */\n\tEM_VISIUM        Machine = 221 /* Controls and Data Services VISIUMcore processor */\n\tEM_FT32          Machine = 222 /* FTDI Chip FT32 high performance 32-bit RISC architecture */\n\tEM_MOXIE         Machine = 223 /* Moxie processor family */\n\tEM_AMDGPU        Machine = 224 /* AMD GPU architecture */\n\tEM_RISCV         Machine = 243 /* RISC-V */\n\tEM_LANAI         Machine = 244 /* Lanai 32-bit processor */\n\tEM_BPF           Machine = 247 /* Linux BPF \u2013 in-kernel virtual machine */\n\tEM_LOONGARCH     Machine = 258 /* LoongArch */\n\n\t/* Non-standard or deprecated. */\n\tEM_486         Machine = 6      /* Intel i486. */\n\tEM_MIPS_RS4_BE Machine = 10     /* MIPS R4000 Big-Endian */\n\tEM_ALPHA_STD   Machine = 41     /* Digital Alpha (standard value). */\n\tEM_ALPHA       Machine = 0x9026 /* Alpha (written in the absence of an ABI) */\n)\nfunc (i Machine) GoString() string\n\nfunc (i Machine) String() string\n\ntype NType int\n    NType values; used in core files.\n\nconst (\n\tNT_PRSTATUS NType = 1 /* Process status. */\n\tNT_FPREGSET NType = 2 /* Floating point registers. */\n\tNT_PRPSINFO NType = 3 /* Process state info. */\n)\nfunc (i NType) GoString() string\n\nfunc (i NType) String() string\n\ntype OSABI byte\n    OSABI is found in Header.Ident[EI_OSABI] and Header.OSABI.\n\nconst (\n\tELFOSABI_NONE       OSABI = 0   /* UNIX System V ABI */\n\tELFOSABI_HPUX       OSABI = 1   /* HP-UX operating system */\n\tELFOSABI_NETBSD     OSABI = 2   /* NetBSD */\n\tELFOSABI_LINUX      OSABI = 3   /* Linux */\n\tELFOSABI_HURD       OSABI = 4   /* Hurd */\n\tELFOSABI_86OPEN     OSABI = 5   /* 86Open common IA32 ABI */\n\tELFOSABI_SOLARIS    OSABI = 6   /* Solaris */\n\tELFOSABI_AIX        OSABI = 7   /* AIX */\n\tELFOSABI_IRIX       OSABI = 8   /* IRIX */\n\tELFOSABI_FREEBSD    OSABI = 9   /* FreeBSD */\n\tELFOSABI_TRU64      OSABI = 10  /* TRU64 UNIX */\n\tELFOSABI_MODESTO    OSABI = 11  /* Novell Modesto */\n\tELFOSABI_OPENBSD    OSABI = 12  /* OpenBSD */\n\tELFOSABI_OPENVMS    OSABI = 13  /* Open VMS */\n\tELFOSABI_NSK        OSABI = 14  /* HP Non-Stop Kernel */\n\tELFOSABI_AROS       OSABI = 15  /* Amiga Research OS */\n\tELFOSABI_FENIXOS    OSABI = 16  /* The FenixOS highly scalable multi-core OS */\n\tELFOSABI_CLOUDABI   OSABI = 17  /* Nuxi CloudABI */\n\tELFOSABI_ARM        OSABI = 97  /* ARM */\n\tELFOSABI_STANDALONE OSABI = 255 /* Standalone (embedded) application */\n)\nfunc (i OSABI) GoString() string\n\nfunc (i OSABI) String() string\n\ntype Prog struct {\n\tProgHeader\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\t// Has unexported fields.\n}\n    A Prog represents a single ELF program header in an ELF binary.\n\nfunc (p *Prog) Open() io.ReadSeeker\n    Open returns a new ReadSeeker reading the ELF program body.\n\ntype Prog32 struct {\n\tType   uint32 /* Entry type. */\n\tOff    uint32 /* File offset of contents. */\n\tVaddr  uint32 /* Virtual address in memory image. */\n\tPaddr  uint32 /* Physical address (not used). */\n\tFilesz uint32 /* Size of contents in file. */\n\tMemsz  uint32 /* Size of contents in memory. */\n\tFlags  uint32 /* Access permission flags. */\n\tAlign  uint32 /* Alignment in memory and file. */\n}\n    ELF32 Program header.\n\ntype Prog64 struct {\n\tType   uint32 /* Entry type. */\n\tFlags  uint32 /* Access permission flags. */\n\tOff    uint64 /* File offset of contents. */\n\tVaddr  uint64 /* Virtual address in memory image. */\n\tPaddr  uint64 /* Physical address (not used). */\n\tFilesz uint64 /* Size of contents in file. */\n\tMemsz  uint64 /* Size of contents in memory. */\n\tAlign  uint64 /* Alignment in memory and file. */\n}\n    ELF64 Program header.\n\ntype ProgFlag uint32\n    Prog.Flag\n\nconst (\n\tPF_X        ProgFlag = 0x1        /* Executable. */\n\tPF_W        ProgFlag = 0x2        /* Writable. */\n\tPF_R        ProgFlag = 0x4        /* Readable. */\n\tPF_MASKOS   ProgFlag = 0x0ff00000 /* Operating system-specific. */\n\tPF_MASKPROC ProgFlag = 0xf0000000 /* Processor-specific. */\n)\nfunc (i ProgFlag) GoString() string\n\nfunc (i ProgFlag) String() string\n\ntype ProgHeader struct {\n\tType   ProgType\n\tFlags  ProgFlag\n\tOff    uint64\n\tVaddr  uint64\n\tPaddr  uint64\n\tFilesz uint64\n\tMemsz  uint64\n\tAlign  uint64\n}\n    A ProgHeader represents a single ELF program header.\n\ntype ProgType int\n    Prog.Type\n\nconst (\n\tPT_NULL    ProgType = 0 /* Unused entry. */\n\tPT_LOAD    ProgType = 1 /* Loadable segment. */\n\tPT_DYNAMIC ProgType = 2 /* Dynamic linking information segment. */\n\tPT_INTERP  ProgType = 3 /* Pathname of interpreter. */\n\tPT_NOTE    ProgType = 4 /* Auxiliary information. */\n\tPT_SHLIB   ProgType = 5 /* Reserved (not used). */\n\tPT_PHDR    ProgType = 6 /* Location of program header itself. */\n\tPT_TLS     ProgType = 7 /* Thread local storage segment */\n\n\tPT_LOOS ProgType = 0x60000000 /* First OS-specific. */\n\n\tPT_GNU_EH_FRAME ProgType = 0x6474e550 /* Frame unwind information */\n\tPT_GNU_STACK    ProgType = 0x6474e551 /* Stack flags */\n\tPT_GNU_RELRO    ProgType = 0x6474e552 /* Read only after relocs */\n\tPT_GNU_PROPERTY ProgType = 0x6474e553 /* GNU property */\n\tPT_GNU_MBIND_LO ProgType = 0x6474e555 /* Mbind segments start */\n\tPT_GNU_MBIND_HI ProgType = 0x6474f554 /* Mbind segments finish */\n\n\tPT_PAX_FLAGS ProgType = 0x65041580 /* PAX flags */\n\n\tPT_OPENBSD_RANDOMIZE ProgType = 0x65a3dbe6 /* Random data */\n\tPT_OPENBSD_WXNEEDED  ProgType = 0x65a3dbe7 /* W^X violations */\n\tPT_OPENBSD_NOBTCFI   ProgType = 0x65a3dbe8 /* No branch target CFI */\n\tPT_OPENBSD_BOOTDATA  ProgType = 0x65a41be6 /* Boot arguments */\n\n\tPT_SUNW_EH_FRAME ProgType = 0x6474e550 /* Frame unwind information */\n\tPT_SUNWSTACK     ProgType = 0x6ffffffb /* Stack segment */\n\n\tPT_HIOS ProgType = 0x6fffffff /* Last OS-specific. */\n\n\tPT_LOPROC ProgType = 0x70000000 /* First processor-specific type. */\n\n\tPT_ARM_ARCHEXT ProgType = 0x70000000 /* Architecture compatibility */\n\tPT_ARM_EXIDX   ProgType = 0x70000001 /* Exception unwind tables */\n\n\tPT_AARCH64_ARCHEXT ProgType = 0x70000000 /* Architecture compatibility */\n\tPT_AARCH64_UNWIND  ProgType = 0x70000001 /* Exception unwind tables */\n\n\tPT_MIPS_REGINFO  ProgType = 0x70000000 /* Register usage */\n\tPT_MIPS_RTPROC   ProgType = 0x70000001 /* Runtime procedures */\n\tPT_MIPS_OPTIONS  ProgType = 0x70000002 /* Options */\n\tPT_MIPS_ABIFLAGS ProgType = 0x70000003 /* ABI flags */\n\n\tPT_RISCV_ATTRIBUTES ProgType = 0x70000003 /* RISC-V ELF attribute section. */\n\n\tPT_S390_PGSTE ProgType = 0x70000000 /* 4k page table size */\n\n\tPT_HIPROC ProgType = 0x7fffffff /* Last processor-specific type. */\n)\nfunc (i ProgType) GoString() string\n\nfunc (i ProgType) String() string\n\ntype R_386 int\n    Relocation types for 386.\n\nconst (\n\tR_386_NONE          R_386 = 0  /* No relocation. */\n\tR_386_32            R_386 = 1  /* Add symbol value. */\n\tR_386_PC32          R_386 = 2  /* Add PC-relative symbol value. */\n\tR_386_GOT32         R_386 = 3  /* Add PC-relative GOT offset. */\n\tR_386_PLT32         R_386 = 4  /* Add PC-relative PLT offset. */\n\tR_386_COPY          R_386 = 5  /* Copy data from shared object. */\n\tR_386_GLOB_DAT      R_386 = 6  /* Set GOT entry to data address. */\n\tR_386_JMP_SLOT      R_386 = 7  /* Set GOT entry to code address. */\n\tR_386_RELATIVE      R_386 = 8  /* Add load address of shared object. */\n\tR_386_GOTOFF        R_386 = 9  /* Add GOT-relative symbol address. */\n\tR_386_GOTPC         R_386 = 10 /* Add PC-relative GOT table address. */\n\tR_386_32PLT         R_386 = 11\n\tR_386_TLS_TPOFF     R_386 = 14 /* Negative offset in static TLS block */\n\tR_386_TLS_IE        R_386 = 15 /* Absolute address of GOT for -ve static TLS */\n\tR_386_TLS_GOTIE     R_386 = 16 /* GOT entry for negative static TLS block */\n\tR_386_TLS_LE        R_386 = 17 /* Negative offset relative to static TLS */\n\tR_386_TLS_GD        R_386 = 18 /* 32 bit offset to GOT (index,off) pair */\n\tR_386_TLS_LDM       R_386 = 19 /* 32 bit offset to GOT (index,zero) pair */\n\tR_386_16            R_386 = 20\n\tR_386_PC16          R_386 = 21\n\tR_386_8             R_386 = 22\n\tR_386_PC8           R_386 = 23\n\tR_386_TLS_GD_32     R_386 = 24 /* 32 bit offset to GOT (index,off) pair */\n\tR_386_TLS_GD_PUSH   R_386 = 25 /* pushl instruction for Sun ABI GD sequence */\n\tR_386_TLS_GD_CALL   R_386 = 26 /* call instruction for Sun ABI GD sequence */\n\tR_386_TLS_GD_POP    R_386 = 27 /* popl instruction for Sun ABI GD sequence */\n\tR_386_TLS_LDM_32    R_386 = 28 /* 32 bit offset to GOT (index,zero) pair */\n\tR_386_TLS_LDM_PUSH  R_386 = 29 /* pushl instruction for Sun ABI LD sequence */\n\tR_386_TLS_LDM_CALL  R_386 = 30 /* call instruction for Sun ABI LD sequence */\n\tR_386_TLS_LDM_POP   R_386 = 31 /* popl instruction for Sun ABI LD sequence */\n\tR_386_TLS_LDO_32    R_386 = 32 /* 32 bit offset from start of TLS block */\n\tR_386_TLS_IE_32     R_386 = 33 /* 32 bit offset to GOT static TLS offset entry */\n\tR_386_TLS_LE_32     R_386 = 34 /* 32 bit offset within static TLS block */\n\tR_386_TLS_DTPMOD32  R_386 = 35 /* GOT entry containing TLS index */\n\tR_386_TLS_DTPOFF32  R_386 = 36 /* GOT entry containing TLS offset */\n\tR_386_TLS_TPOFF32   R_386 = 37 /* GOT entry of -ve static TLS offset */\n\tR_386_SIZE32        R_386 = 38\n\tR_386_TLS_GOTDESC   R_386 = 39\n\tR_386_TLS_DESC_CALL R_386 = 40\n\tR_386_TLS_DESC      R_386 = 41\n\tR_386_IRELATIVE     R_386 = 42\n\tR_386_GOT32X        R_386 = 43\n)\nfunc (i R_386) GoString() string\n\nfunc (i R_386) String() string\n\ntype R_390 int\n    Relocation types for s390x processors.\n\nconst (\n\tR_390_NONE        R_390 = 0\n\tR_390_8           R_390 = 1\n\tR_390_12          R_390 = 2\n\tR_390_16          R_390 = 3\n\tR_390_32          R_390 = 4\n\tR_390_PC32        R_390 = 5\n\tR_390_GOT12       R_390 = 6\n\tR_390_GOT32       R_390 = 7\n\tR_390_PLT32       R_390 = 8\n\tR_390_COPY        R_390 = 9\n\tR_390_GLOB_DAT    R_390 = 10\n\tR_390_JMP_SLOT    R_390 = 11\n\tR_390_RELATIVE    R_390 = 12\n\tR_390_GOTOFF      R_390 = 13\n\tR_390_GOTPC       R_390 = 14\n\tR_390_GOT16       R_390 = 15\n\tR_390_PC16        R_390 = 16\n\tR_390_PC16DBL     R_390 = 17\n\tR_390_PLT16DBL    R_390 = 18\n\tR_390_PC32DBL     R_390 = 19\n\tR_390_PLT32DBL    R_390 = 20\n\tR_390_GOTPCDBL    R_390 = 21\n\tR_390_64          R_390 = 22\n\tR_390_PC64        R_390 = 23\n\tR_390_GOT64       R_390 = 24\n\tR_390_PLT64       R_390 = 25\n\tR_390_GOTENT      R_390 = 26\n\tR_390_GOTOFF16    R_390 = 27\n\tR_390_GOTOFF64    R_390 = 28\n\tR_390_GOTPLT12    R_390 = 29\n\tR_390_GOTPLT16    R_390 = 30\n\tR_390_GOTPLT32    R_390 = 31\n\tR_390_GOTPLT64    R_390 = 32\n\tR_390_GOTPLTENT   R_390 = 33\n\tR_390_GOTPLTOFF16 R_390 = 34\n\tR_390_GOTPLTOFF32 R_390 = 35\n\tR_390_GOTPLTOFF64 R_390 = 36\n\tR_390_TLS_LOAD    R_390 = 37\n\tR_390_TLS_GDCALL  R_390 = 38\n\tR_390_TLS_LDCALL  R_390 = 39\n\tR_390_TLS_GD32    R_390 = 40\n\tR_390_TLS_GD64    R_390 = 41\n\tR_390_TLS_GOTIE12 R_390 = 42\n\tR_390_TLS_GOTIE32 R_390 = 43\n\tR_390_TLS_GOTIE64 R_390 = 44\n\tR_390_TLS_LDM32   R_390 = 45\n\tR_390_TLS_LDM64   R_390 = 46\n\tR_390_TLS_IE32    R_390 = 47\n\tR_390_TLS_IE64    R_390 = 48\n\tR_390_TLS_IEENT   R_390 = 49\n\tR_390_TLS_LE32    R_390 = 50\n\tR_390_TLS_LE64    R_390 = 51\n\tR_390_TLS_LDO32   R_390 = 52\n\tR_390_TLS_LDO64   R_390 = 53\n\tR_390_TLS_DTPMOD  R_390 = 54\n\tR_390_TLS_DTPOFF  R_390 = 55\n\tR_390_TLS_TPOFF   R_390 = 56\n\tR_390_20          R_390 = 57\n\tR_390_GOT20       R_390 = 58\n\tR_390_GOTPLT20    R_390 = 59\n\tR_390_TLS_GOTIE20 R_390 = 60\n)\nfunc (i R_390) GoString() string\n\nfunc (i R_390) String() string\n\ntype R_AARCH64 int\n    Relocation types for AArch64 (aka arm64)\n\nconst (\n\tR_AARCH64_NONE                            R_AARCH64 = 0\n\tR_AARCH64_P32_ABS32                       R_AARCH64 = 1\n\tR_AARCH64_P32_ABS16                       R_AARCH64 = 2\n\tR_AARCH64_P32_PREL32                      R_AARCH64 = 3\n\tR_AARCH64_P32_PREL16                      R_AARCH64 = 4\n\tR_AARCH64_P32_MOVW_UABS_G0                R_AARCH64 = 5\n\tR_AARCH64_P32_MOVW_UABS_G0_NC             R_AARCH64 = 6\n\tR_AARCH64_P32_MOVW_UABS_G1                R_AARCH64 = 7\n\tR_AARCH64_P32_MOVW_SABS_G0                R_AARCH64 = 8\n\tR_AARCH64_P32_LD_PREL_LO19                R_AARCH64 = 9\n\tR_AARCH64_P32_ADR_PREL_LO21               R_AARCH64 = 10\n\tR_AARCH64_P32_ADR_PREL_PG_HI21            R_AARCH64 = 11\n\tR_AARCH64_P32_ADD_ABS_LO12_NC             R_AARCH64 = 12\n\tR_AARCH64_P32_LDST8_ABS_LO12_NC           R_AARCH64 = 13\n\tR_AARCH64_P32_LDST16_ABS_LO12_NC          R_AARCH64 = 14\n\tR_AARCH64_P32_LDST32_ABS_LO12_NC          R_AARCH64 = 15\n\tR_AARCH64_P32_LDST64_ABS_LO12_NC          R_AARCH64 = 16\n\tR_AARCH64_P32_LDST128_ABS_LO12_NC         R_AARCH64 = 17\n\tR_AARCH64_P32_TSTBR14                     R_AARCH64 = 18\n\tR_AARCH64_P32_CONDBR19                    R_AARCH64 = 19\n\tR_AARCH64_P32_JUMP26                      R_AARCH64 = 20\n\tR_AARCH64_P32_CALL26                      R_AARCH64 = 21\n\tR_AARCH64_P32_GOT_LD_PREL19               R_AARCH64 = 25\n\tR_AARCH64_P32_ADR_GOT_PAGE                R_AARCH64 = 26\n\tR_AARCH64_P32_LD32_GOT_LO12_NC            R_AARCH64 = 27\n\tR_AARCH64_P32_TLSGD_ADR_PAGE21            R_AARCH64 = 81\n\tR_AARCH64_P32_TLSGD_ADD_LO12_NC           R_AARCH64 = 82\n\tR_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21   R_AARCH64 = 103\n\tR_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC R_AARCH64 = 104\n\tR_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19    R_AARCH64 = 105\n\tR_AARCH64_P32_TLSLE_MOVW_TPREL_G1         R_AARCH64 = 106\n\tR_AARCH64_P32_TLSLE_MOVW_TPREL_G0         R_AARCH64 = 107\n\tR_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC      R_AARCH64 = 108\n\tR_AARCH64_P32_TLSLE_ADD_TPREL_HI12        R_AARCH64 = 109\n\tR_AARCH64_P32_TLSLE_ADD_TPREL_LO12        R_AARCH64 = 110\n\tR_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC     R_AARCH64 = 111\n\tR_AARCH64_P32_TLSDESC_LD_PREL19           R_AARCH64 = 122\n\tR_AARCH64_P32_TLSDESC_ADR_PREL21          R_AARCH64 = 123\n\tR_AARCH64_P32_TLSDESC_ADR_PAGE21          R_AARCH64 = 124\n\tR_AARCH64_P32_TLSDESC_LD32_LO12_NC        R_AARCH64 = 125\n\tR_AARCH64_P32_TLSDESC_ADD_LO12_NC         R_AARCH64 = 126\n\tR_AARCH64_P32_TLSDESC_CALL                R_AARCH64 = 127\n\tR_AARCH64_P32_COPY                        R_AARCH64 = 180\n\tR_AARCH64_P32_GLOB_DAT                    R_AARCH64 = 181\n\tR_AARCH64_P32_JUMP_SLOT                   R_AARCH64 = 182\n\tR_AARCH64_P32_RELATIVE                    R_AARCH64 = 183\n\tR_AARCH64_P32_TLS_DTPMOD                  R_AARCH64 = 184\n\tR_AARCH64_P32_TLS_DTPREL                  R_AARCH64 = 185\n\tR_AARCH64_P32_TLS_TPREL                   R_AARCH64 = 186\n\tR_AARCH64_P32_TLSDESC                     R_AARCH64 = 187\n\tR_AARCH64_P32_IRELATIVE                   R_AARCH64 = 188\n\tR_AARCH64_NULL                            R_AARCH64 = 256\n\tR_AARCH64_ABS64                           R_AARCH64 = 257\n\tR_AARCH64_ABS32                           R_AARCH64 = 258\n\tR_AARCH64_ABS16                           R_AARCH64 = 259\n\tR_AARCH64_PREL64                          R_AARCH64 = 260\n\tR_AARCH64_PREL32                          R_AARCH64 = 261\n\tR_AARCH64_PREL16                          R_AARCH64 = 262\n\tR_AARCH64_MOVW_UABS_G0                    R_AARCH64 = 263\n\tR_AARCH64_MOVW_UABS_G0_NC                 R_AARCH64 = 264\n\tR_AARCH64_MOVW_UABS_G1                    R_AARCH64 = 265\n\tR_AARCH64_MOVW_UABS_G1_NC                 R_AARCH64 = 266\n\tR_AARCH64_MOVW_UABS_G2                    R_AARCH64 = 267\n\tR_AARCH64_MOVW_UABS_G2_NC                 R_AARCH64 = 268\n\tR_AARCH64_MOVW_UABS_G3                    R_AARCH64 = 269\n\tR_AARCH64_MOVW_SABS_G0                    R_AARCH64 = 270\n\tR_AARCH64_MOVW_SABS_G1                    R_AARCH64 = 271\n\tR_AARCH64_MOVW_SABS_G2                    R_AARCH64 = 272\n\tR_AARCH64_LD_PREL_LO19                    R_AARCH64 = 273\n\tR_AARCH64_ADR_PREL_LO21                   R_AARCH64 = 274\n\tR_AARCH64_ADR_PREL_PG_HI21                R_AARCH64 = 275\n\tR_AARCH64_ADR_PREL_PG_HI21_NC             R_AARCH64 = 276\n\tR_AARCH64_ADD_ABS_LO12_NC                 R_AARCH64 = 277\n\tR_AARCH64_LDST8_ABS_LO12_NC               R_AARCH64 = 278\n\tR_AARCH64_TSTBR14                         R_AARCH64 = 279\n\tR_AARCH64_CONDBR19                        R_AARCH64 = 280\n\tR_AARCH64_JUMP26                          R_AARCH64 = 282\n\tR_AARCH64_CALL26                          R_AARCH64 = 283\n\tR_AARCH64_LDST16_ABS_LO12_NC              R_AARCH64 = 284\n\tR_AARCH64_LDST32_ABS_LO12_NC              R_AARCH64 = 285\n\tR_AARCH64_LDST64_ABS_LO12_NC              R_AARCH64 = 286\n\tR_AARCH64_LDST128_ABS_LO12_NC             R_AARCH64 = 299\n\tR_AARCH64_GOT_LD_PREL19                   R_AARCH64 = 309\n\tR_AARCH64_LD64_GOTOFF_LO15                R_AARCH64 = 310\n\tR_AARCH64_ADR_GOT_PAGE                    R_AARCH64 = 311\n\tR_AARCH64_LD64_GOT_LO12_NC                R_AARCH64 = 312\n\tR_AARCH64_LD64_GOTPAGE_LO15               R_AARCH64 = 313\n\tR_AARCH64_TLSGD_ADR_PREL21                R_AARCH64 = 512\n\tR_AARCH64_TLSGD_ADR_PAGE21                R_AARCH64 = 513\n\tR_AARCH64_TLSGD_ADD_LO12_NC               R_AARCH64 = 514\n\tR_AARCH64_TLSGD_MOVW_G1                   R_AARCH64 = 515\n\tR_AARCH64_TLSGD_MOVW_G0_NC                R_AARCH64 = 516\n\tR_AARCH64_TLSLD_ADR_PREL21                R_AARCH64 = 517\n\tR_AARCH64_TLSLD_ADR_PAGE21                R_AARCH64 = 518\n\tR_AARCH64_TLSIE_MOVW_GOTTPREL_G1          R_AARCH64 = 539\n\tR_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC       R_AARCH64 = 540\n\tR_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21       R_AARCH64 = 541\n\tR_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC     R_AARCH64 = 542\n\tR_AARCH64_TLSIE_LD_GOTTPREL_PREL19        R_AARCH64 = 543\n\tR_AARCH64_TLSLE_MOVW_TPREL_G2             R_AARCH64 = 544\n\tR_AARCH64_TLSLE_MOVW_TPREL_G1             R_AARCH64 = 545\n\tR_AARCH64_TLSLE_MOVW_TPREL_G1_NC          R_AARCH64 = 546\n\tR_AARCH64_TLSLE_MOVW_TPREL_G0             R_AARCH64 = 547\n\tR_AARCH64_TLSLE_MOVW_TPREL_G0_NC          R_AARCH64 = 548\n\tR_AARCH64_TLSLE_ADD_TPREL_HI12            R_AARCH64 = 549\n\tR_AARCH64_TLSLE_ADD_TPREL_LO12            R_AARCH64 = 550\n\tR_AARCH64_TLSLE_ADD_TPREL_LO12_NC         R_AARCH64 = 551\n\tR_AARCH64_TLSDESC_LD_PREL19               R_AARCH64 = 560\n\tR_AARCH64_TLSDESC_ADR_PREL21              R_AARCH64 = 561\n\tR_AARCH64_TLSDESC_ADR_PAGE21              R_AARCH64 = 562\n\tR_AARCH64_TLSDESC_LD64_LO12_NC            R_AARCH64 = 563\n\tR_AARCH64_TLSDESC_ADD_LO12_NC             R_AARCH64 = 564\n\tR_AARCH64_TLSDESC_OFF_G1                  R_AARCH64 = 565\n\tR_AARCH64_TLSDESC_OFF_G0_NC               R_AARCH64 = 566\n\tR_AARCH64_TLSDESC_LDR                     R_AARCH64 = 567\n\tR_AARCH64_TLSDESC_ADD                     R_AARCH64 = 568\n\tR_AARCH64_TLSDESC_CALL                    R_AARCH64 = 569\n\tR_AARCH64_TLSLE_LDST128_TPREL_LO12        R_AARCH64 = 570\n\tR_AARCH64_TLSLE_LDST128_TPREL_LO12_NC     R_AARCH64 = 571\n\tR_AARCH64_TLSLD_LDST128_DTPREL_LO12       R_AARCH64 = 572\n\tR_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC    R_AARCH64 = 573\n\tR_AARCH64_COPY                            R_AARCH64 = 1024\n\tR_AARCH64_GLOB_DAT                        R_AARCH64 = 1025\n\tR_AARCH64_JUMP_SLOT                       R_AARCH64 = 1026\n\tR_AARCH64_RELATIVE                        R_AARCH64 = 1027\n\tR_AARCH64_TLS_DTPMOD64                    R_AARCH64 = 1028\n\tR_AARCH64_TLS_DTPREL64                    R_AARCH64 = 1029\n\tR_AARCH64_TLS_TPREL64                     R_AARCH64 = 1030\n\tR_AARCH64_TLSDESC                         R_AARCH64 = 1031\n\tR_AARCH64_IRELATIVE                       R_AARCH64 = 1032\n)\nfunc (i R_AARCH64) GoString() string\n\nfunc (i R_AARCH64) String() string\n\ntype R_ALPHA int\n    Relocation types for Alpha.\n\nconst (\n\tR_ALPHA_NONE           R_ALPHA = 0  /* No reloc */\n\tR_ALPHA_REFLONG        R_ALPHA = 1  /* Direct 32 bit */\n\tR_ALPHA_REFQUAD        R_ALPHA = 2  /* Direct 64 bit */\n\tR_ALPHA_GPREL32        R_ALPHA = 3  /* GP relative 32 bit */\n\tR_ALPHA_LITERAL        R_ALPHA = 4  /* GP relative 16 bit w/optimization */\n\tR_ALPHA_LITUSE         R_ALPHA = 5  /* Optimization hint for LITERAL */\n\tR_ALPHA_GPDISP         R_ALPHA = 6  /* Add displacement to GP */\n\tR_ALPHA_BRADDR         R_ALPHA = 7  /* PC+4 relative 23 bit shifted */\n\tR_ALPHA_HINT           R_ALPHA = 8  /* PC+4 relative 16 bit shifted */\n\tR_ALPHA_SREL16         R_ALPHA = 9  /* PC relative 16 bit */\n\tR_ALPHA_SREL32         R_ALPHA = 10 /* PC relative 32 bit */\n\tR_ALPHA_SREL64         R_ALPHA = 11 /* PC relative 64 bit */\n\tR_ALPHA_OP_PUSH        R_ALPHA = 12 /* OP stack push */\n\tR_ALPHA_OP_STORE       R_ALPHA = 13 /* OP stack pop and store */\n\tR_ALPHA_OP_PSUB        R_ALPHA = 14 /* OP stack subtract */\n\tR_ALPHA_OP_PRSHIFT     R_ALPHA = 15 /* OP stack right shift */\n\tR_ALPHA_GPVALUE        R_ALPHA = 16\n\tR_ALPHA_GPRELHIGH      R_ALPHA = 17\n\tR_ALPHA_GPRELLOW       R_ALPHA = 18\n\tR_ALPHA_IMMED_GP_16    R_ALPHA = 19\n\tR_ALPHA_IMMED_GP_HI32  R_ALPHA = 20\n\tR_ALPHA_IMMED_SCN_HI32 R_ALPHA = 21\n\tR_ALPHA_IMMED_BR_HI32  R_ALPHA = 22\n\tR_ALPHA_IMMED_LO32     R_ALPHA = 23\n\tR_ALPHA_COPY           R_ALPHA = 24 /* Copy symbol at runtime */\n\tR_ALPHA_GLOB_DAT       R_ALPHA = 25 /* Create GOT entry */\n\tR_ALPHA_JMP_SLOT       R_ALPHA = 26 /* Create PLT entry */\n\tR_ALPHA_RELATIVE       R_ALPHA = 27 /* Adjust by program base */\n)\nfunc (i R_ALPHA) GoString() string\n\nfunc (i R_ALPHA) String() string\n\ntype R_ARM int\n    Relocation types for ARM.\n\nconst (\n\tR_ARM_NONE               R_ARM = 0 /* No relocation. */\n\tR_ARM_PC24               R_ARM = 1\n\tR_ARM_ABS32              R_ARM = 2\n\tR_ARM_REL32              R_ARM = 3\n\tR_ARM_PC13               R_ARM = 4\n\tR_ARM_ABS16              R_ARM = 5\n\tR_ARM_ABS12              R_ARM = 6\n\tR_ARM_THM_ABS5           R_ARM = 7\n\tR_ARM_ABS8               R_ARM = 8\n\tR_ARM_SBREL32            R_ARM = 9\n\tR_ARM_THM_PC22           R_ARM = 10\n\tR_ARM_THM_PC8            R_ARM = 11\n\tR_ARM_AMP_VCALL9         R_ARM = 12\n\tR_ARM_SWI24              R_ARM = 13\n\tR_ARM_THM_SWI8           R_ARM = 14\n\tR_ARM_XPC25              R_ARM = 15\n\tR_ARM_THM_XPC22          R_ARM = 16\n\tR_ARM_TLS_DTPMOD32       R_ARM = 17\n\tR_ARM_TLS_DTPOFF32       R_ARM = 18\n\tR_ARM_TLS_TPOFF32        R_ARM = 19\n\tR_ARM_COPY               R_ARM = 20 /* Copy data from shared object. */\n\tR_ARM_GLOB_DAT           R_ARM = 21 /* Set GOT entry to data address. */\n\tR_ARM_JUMP_SLOT          R_ARM = 22 /* Set GOT entry to code address. */\n\tR_ARM_RELATIVE           R_ARM = 23 /* Add load address of shared object. */\n\tR_ARM_GOTOFF             R_ARM = 24 /* Add GOT-relative symbol address. */\n\tR_ARM_GOTPC              R_ARM = 25 /* Add PC-relative GOT table address. */\n\tR_ARM_GOT32              R_ARM = 26 /* Add PC-relative GOT offset. */\n\tR_ARM_PLT32              R_ARM = 27 /* Add PC-relative PLT offset. */\n\tR_ARM_CALL               R_ARM = 28\n\tR_ARM_JUMP24             R_ARM = 29\n\tR_ARM_THM_JUMP24         R_ARM = 30\n\tR_ARM_BASE_ABS           R_ARM = 31\n\tR_ARM_ALU_PCREL_7_0      R_ARM = 32\n\tR_ARM_ALU_PCREL_15_8     R_ARM = 33\n\tR_ARM_ALU_PCREL_23_15    R_ARM = 34\n\tR_ARM_LDR_SBREL_11_10_NC R_ARM = 35\n\tR_ARM_ALU_SBREL_19_12_NC R_ARM = 36\n\tR_ARM_ALU_SBREL_27_20_CK R_ARM = 37\n\tR_ARM_TARGET1            R_ARM = 38\n\tR_ARM_SBREL31            R_ARM = 39\n\tR_ARM_V4BX               R_ARM = 40\n\tR_ARM_TARGET2            R_ARM = 41\n\tR_ARM_PREL31             R_ARM = 42\n\tR_ARM_MOVW_ABS_NC        R_ARM = 43\n\tR_ARM_MOVT_ABS           R_ARM = 44\n\tR_ARM_MOVW_PREL_NC       R_ARM = 45\n\tR_ARM_MOVT_PREL          R_ARM = 46\n\tR_ARM_THM_MOVW_ABS_NC    R_ARM = 47\n\tR_ARM_THM_MOVT_ABS       R_ARM = 48\n\tR_ARM_THM_MOVW_PREL_NC   R_ARM = 49\n\tR_ARM_THM_MOVT_PREL      R_ARM = 50\n\tR_ARM_THM_JUMP19         R_ARM = 51\n\tR_ARM_THM_JUMP6          R_ARM = 52\n\tR_ARM_THM_ALU_PREL_11_0  R_ARM = 53\n\tR_ARM_THM_PC12           R_ARM = 54\n\tR_ARM_ABS32_NOI          R_ARM = 55\n\tR_ARM_REL32_NOI          R_ARM = 56\n\tR_ARM_ALU_PC_G0_NC       R_ARM = 57\n\tR_ARM_ALU_PC_G0          R_ARM = 58\n\tR_ARM_ALU_PC_G1_NC       R_ARM = 59\n\tR_ARM_ALU_PC_G1          R_ARM = 60\n\tR_ARM_ALU_PC_G2          R_ARM = 61\n\tR_ARM_LDR_PC_G1          R_ARM = 62\n\tR_ARM_LDR_PC_G2          R_ARM = 63\n\tR_ARM_LDRS_PC_G0         R_ARM = 64\n\tR_ARM_LDRS_PC_G1         R_ARM = 65\n\tR_ARM_LDRS_PC_G2         R_ARM = 66\n\tR_ARM_LDC_PC_G0          R_ARM = 67\n\tR_ARM_LDC_PC_G1          R_ARM = 68\n\tR_ARM_LDC_PC_G2          R_ARM = 69\n\tR_ARM_ALU_SB_G0_NC       R_ARM = 70\n\tR_ARM_ALU_SB_G0          R_ARM = 71\n\tR_ARM_ALU_SB_G1_NC       R_ARM = 72\n\tR_ARM_ALU_SB_G1          R_ARM = 73\n\tR_ARM_ALU_SB_G2          R_ARM = 74\n\tR_ARM_LDR_SB_G0          R_ARM = 75\n\tR_ARM_LDR_SB_G1          R_ARM = 76\n\tR_ARM_LDR_SB_G2          R_ARM = 77\n\tR_ARM_LDRS_SB_G0         R_ARM = 78\n\tR_ARM_LDRS_SB_G1         R_ARM = 79\n\tR_ARM_LDRS_SB_G2         R_ARM = 80\n\tR_ARM_LDC_SB_G0          R_ARM = 81\n\tR_ARM_LDC_SB_G1          R_ARM = 82\n\tR_ARM_LDC_SB_G2          R_ARM = 83\n\tR_ARM_MOVW_BREL_NC       R_ARM = 84\n\tR_ARM_MOVT_BREL          R_ARM = 85\n\tR_ARM_MOVW_BREL          R_ARM = 86\n\tR_ARM_THM_MOVW_BREL_NC   R_ARM = 87\n\tR_ARM_THM_MOVT_BREL      R_ARM = 88\n\tR_ARM_THM_MOVW_BREL      R_ARM = 89\n\tR_ARM_TLS_GOTDESC        R_ARM = 90\n\tR_ARM_TLS_CALL           R_ARM = 91\n\tR_ARM_TLS_DESCSEQ        R_ARM = 92\n\tR_ARM_THM_TLS_CALL       R_ARM = 93\n\tR_ARM_PLT32_ABS          R_ARM = 94\n\tR_ARM_GOT_ABS            R_ARM = 95\n\tR_ARM_GOT_PREL           R_ARM = 96\n\tR_ARM_GOT_BREL12         R_ARM = 97\n\tR_ARM_GOTOFF12           R_ARM = 98\n\tR_ARM_GOTRELAX           R_ARM = 99\n\tR_ARM_GNU_VTENTRY        R_ARM = 100\n\tR_ARM_GNU_VTINHERIT      R_ARM = 101\n\tR_ARM_THM_JUMP11         R_ARM = 102\n\tR_ARM_THM_JUMP8          R_ARM = 103\n\tR_ARM_TLS_GD32           R_ARM = 104\n\tR_ARM_TLS_LDM32          R_ARM = 105\n\tR_ARM_TLS_LDO32          R_ARM = 106\n\tR_ARM_TLS_IE32           R_ARM = 107\n\tR_ARM_TLS_LE32           R_ARM = 108\n\tR_ARM_TLS_LDO12          R_ARM = 109\n\tR_ARM_TLS_LE12           R_ARM = 110\n\tR_ARM_TLS_IE12GP         R_ARM = 111\n\tR_ARM_PRIVATE_0          R_ARM = 112\n\tR_ARM_PRIVATE_1          R_ARM = 113\n\tR_ARM_PRIVATE_2          R_ARM = 114\n\tR_ARM_PRIVATE_3          R_ARM = 115\n\tR_ARM_PRIVATE_4          R_ARM = 116\n\tR_ARM_PRIVATE_5          R_ARM = 117\n\tR_ARM_PRIVATE_6          R_ARM = 118\n\tR_ARM_PRIVATE_7          R_ARM = 119\n\tR_ARM_PRIVATE_8          R_ARM = 120\n\tR_ARM_PRIVATE_9          R_ARM = 121\n\tR_ARM_PRIVATE_10         R_ARM = 122\n\tR_ARM_PRIVATE_11         R_ARM = 123\n\tR_ARM_PRIVATE_12         R_ARM = 124\n\tR_ARM_PRIVATE_13         R_ARM = 125\n\tR_ARM_PRIVATE_14         R_ARM = 126\n\tR_ARM_PRIVATE_15         R_ARM = 127\n\tR_ARM_ME_TOO             R_ARM = 128\n\tR_ARM_THM_TLS_DESCSEQ16  R_ARM = 129\n\tR_ARM_THM_TLS_DESCSEQ32  R_ARM = 130\n\tR_ARM_THM_GOT_BREL12     R_ARM = 131\n\tR_ARM_THM_ALU_ABS_G0_NC  R_ARM = 132\n\tR_ARM_THM_ALU_ABS_G1_NC  R_ARM = 133\n\tR_ARM_THM_ALU_ABS_G2_NC  R_ARM = 134\n\tR_ARM_THM_ALU_ABS_G3     R_ARM = 135\n\tR_ARM_IRELATIVE          R_ARM = 160\n\tR_ARM_RXPC25             R_ARM = 249\n\tR_ARM_RSBREL32           R_ARM = 250\n\tR_ARM_THM_RPC22          R_ARM = 251\n\tR_ARM_RREL32             R_ARM = 252\n\tR_ARM_RABS32             R_ARM = 253\n\tR_ARM_RPC24              R_ARM = 254\n\tR_ARM_RBASE              R_ARM = 255\n)\nfunc (i R_ARM) GoString() string\n\nfunc (i R_ARM) String() string\n\ntype R_LARCH int\n    Relocation types for LoongArch.\n\nconst (\n\tR_LARCH_NONE                       R_LARCH = 0\n\tR_LARCH_32                         R_LARCH = 1\n\tR_LARCH_64                         R_LARCH = 2\n\tR_LARCH_RELATIVE                   R_LARCH = 3\n\tR_LARCH_COPY                       R_LARCH = 4\n\tR_LARCH_JUMP_SLOT                  R_LARCH = 5\n\tR_LARCH_TLS_DTPMOD32               R_LARCH = 6\n\tR_LARCH_TLS_DTPMOD64               R_LARCH = 7\n\tR_LARCH_TLS_DTPREL32               R_LARCH = 8\n\tR_LARCH_TLS_DTPREL64               R_LARCH = 9\n\tR_LARCH_TLS_TPREL32                R_LARCH = 10\n\tR_LARCH_TLS_TPREL64                R_LARCH = 11\n\tR_LARCH_IRELATIVE                  R_LARCH = 12\n\tR_LARCH_MARK_LA                    R_LARCH = 20\n\tR_LARCH_MARK_PCREL                 R_LARCH = 21\n\tR_LARCH_SOP_PUSH_PCREL             R_LARCH = 22\n\tR_LARCH_SOP_PUSH_ABSOLUTE          R_LARCH = 23\n\tR_LARCH_SOP_PUSH_DUP               R_LARCH = 24\n\tR_LARCH_SOP_PUSH_GPREL             R_LARCH = 25\n\tR_LARCH_SOP_PUSH_TLS_TPREL         R_LARCH = 26\n\tR_LARCH_SOP_PUSH_TLS_GOT           R_LARCH = 27\n\tR_LARCH_SOP_PUSH_TLS_GD            R_LARCH = 28\n\tR_LARCH_SOP_PUSH_PLT_PCREL         R_LARCH = 29\n\tR_LARCH_SOP_ASSERT                 R_LARCH = 30\n\tR_LARCH_SOP_NOT                    R_LARCH = 31\n\tR_LARCH_SOP_SUB                    R_LARCH = 32\n\tR_LARCH_SOP_SL                     R_LARCH = 33\n\tR_LARCH_SOP_SR                     R_LARCH = 34\n\tR_LARCH_SOP_ADD                    R_LARCH = 35\n\tR_LARCH_SOP_AND                    R_LARCH = 36\n\tR_LARCH_SOP_IF_ELSE                R_LARCH = 37\n\tR_LARCH_SOP_POP_32_S_10_5          R_LARCH = 38\n\tR_LARCH_SOP_POP_32_U_10_12         R_LARCH = 39\n\tR_LARCH_SOP_POP_32_S_10_12         R_LARCH = 40\n\tR_LARCH_SOP_POP_32_S_10_16         R_LARCH = 41\n\tR_LARCH_SOP_POP_32_S_10_16_S2      R_LARCH = 42\n\tR_LARCH_SOP_POP_32_S_5_20          R_LARCH = 43\n\tR_LARCH_SOP_POP_32_S_0_5_10_16_S2  R_LARCH = 44\n\tR_LARCH_SOP_POP_32_S_0_10_10_16_S2 R_LARCH = 45\n\tR_LARCH_SOP_POP_32_U               R_LARCH = 46\n\tR_LARCH_ADD8                       R_LARCH = 47\n\tR_LARCH_ADD16                      R_LARCH = 48\n\tR_LARCH_ADD24                      R_LARCH = 49\n\tR_LARCH_ADD32                      R_LARCH = 50\n\tR_LARCH_ADD64                      R_LARCH = 51\n\tR_LARCH_SUB8                       R_LARCH = 52\n\tR_LARCH_SUB16                      R_LARCH = 53\n\tR_LARCH_SUB24                      R_LARCH = 54\n\tR_LARCH_SUB32                      R_LARCH = 55\n\tR_LARCH_SUB64                      R_LARCH = 56\n\tR_LARCH_GNU_VTINHERIT              R_LARCH = 57\n\tR_LARCH_GNU_VTENTRY                R_LARCH = 58\n\tR_LARCH_B16                        R_LARCH = 64\n\tR_LARCH_B21                        R_LARCH = 65\n\tR_LARCH_B26                        R_LARCH = 66\n\tR_LARCH_ABS_HI20                   R_LARCH = 67\n\tR_LARCH_ABS_LO12                   R_LARCH = 68\n\tR_LARCH_ABS64_LO20                 R_LARCH = 69\n\tR_LARCH_ABS64_HI12                 R_LARCH = 70\n\tR_LARCH_PCALA_HI20                 R_LARCH = 71\n\tR_LARCH_PCALA_LO12                 R_LARCH = 72\n\tR_LARCH_PCALA64_LO20               R_LARCH = 73\n\tR_LARCH_PCALA64_HI12               R_LARCH = 74\n\tR_LARCH_GOT_PC_HI20                R_LARCH = 75\n\tR_LARCH_GOT_PC_LO12                R_LARCH = 76\n\tR_LARCH_GOT64_PC_LO20              R_LARCH = 77\n\tR_LARCH_GOT64_PC_HI12              R_LARCH = 78\n\tR_LARCH_GOT_HI20                   R_LARCH = 79\n\tR_LARCH_GOT_LO12                   R_LARCH = 80\n\tR_LARCH_GOT64_LO20                 R_LARCH = 81\n\tR_LARCH_GOT64_HI12                 R_LARCH = 82\n\tR_LARCH_TLS_LE_HI20                R_LARCH = 83\n\tR_LARCH_TLS_LE_LO12                R_LARCH = 84\n\tR_LARCH_TLS_LE64_LO20              R_LARCH = 85\n\tR_LARCH_TLS_LE64_HI12              R_LARCH = 86\n\tR_LARCH_TLS_IE_PC_HI20             R_LARCH = 87\n\tR_LARCH_TLS_IE_PC_LO12             R_LARCH = 88\n\tR_LARCH_TLS_IE64_PC_LO20           R_LARCH = 89\n\tR_LARCH_TLS_IE64_PC_HI12           R_LARCH = 90\n\tR_LARCH_TLS_IE_HI20                R_LARCH = 91\n\tR_LARCH_TLS_IE_LO12                R_LARCH = 92\n\tR_LARCH_TLS_IE64_LO20              R_LARCH = 93\n\tR_LARCH_TLS_IE64_HI12              R_LARCH = 94\n\tR_LARCH_TLS_LD_PC_HI20             R_LARCH = 95\n\tR_LARCH_TLS_LD_HI20                R_LARCH = 96\n\tR_LARCH_TLS_GD_PC_HI20             R_LARCH = 97\n\tR_LARCH_TLS_GD_HI20                R_LARCH = 98\n\tR_LARCH_32_PCREL                   R_LARCH = 99\n\tR_LARCH_RELAX                      R_LARCH = 100\n\tR_LARCH_DELETE                     R_LARCH = 101\n\tR_LARCH_ALIGN                      R_LARCH = 102\n\tR_LARCH_PCREL20_S2                 R_LARCH = 103\n\tR_LARCH_CFA                        R_LARCH = 104\n\tR_LARCH_ADD6                       R_LARCH = 105\n\tR_LARCH_SUB6                       R_LARCH = 106\n\tR_LARCH_ADD_ULEB128                R_LARCH = 107\n\tR_LARCH_SUB_ULEB128                R_LARCH = 108\n\tR_LARCH_64_PCREL                   R_LARCH = 109\n)\nfunc (i R_LARCH) GoString() string\n\nfunc (i R_LARCH) String() string\n\ntype R_MIPS int\n    Relocation types for MIPS.\n\nconst (\n\tR_MIPS_NONE          R_MIPS = 0\n\tR_MIPS_16            R_MIPS = 1\n\tR_MIPS_32            R_MIPS = 2\n\tR_MIPS_REL32         R_MIPS = 3\n\tR_MIPS_26            R_MIPS = 4\n\tR_MIPS_HI16          R_MIPS = 5  /* high 16 bits of symbol value */\n\tR_MIPS_LO16          R_MIPS = 6  /* low 16 bits of symbol value */\n\tR_MIPS_GPREL16       R_MIPS = 7  /* GP-relative reference  */\n\tR_MIPS_LITERAL       R_MIPS = 8  /* Reference to literal section  */\n\tR_MIPS_GOT16         R_MIPS = 9  /* Reference to global offset table */\n\tR_MIPS_PC16          R_MIPS = 10 /* 16 bit PC relative reference */\n\tR_MIPS_CALL16        R_MIPS = 11 /* 16 bit call through glbl offset tbl */\n\tR_MIPS_GPREL32       R_MIPS = 12\n\tR_MIPS_SHIFT5        R_MIPS = 16\n\tR_MIPS_SHIFT6        R_MIPS = 17\n\tR_MIPS_64            R_MIPS = 18\n\tR_MIPS_GOT_DISP      R_MIPS = 19\n\tR_MIPS_GOT_PAGE      R_MIPS = 20\n\tR_MIPS_GOT_OFST      R_MIPS = 21\n\tR_MIPS_GOT_HI16      R_MIPS = 22\n\tR_MIPS_GOT_LO16      R_MIPS = 23\n\tR_MIPS_SUB           R_MIPS = 24\n\tR_MIPS_INSERT_A      R_MIPS = 25\n\tR_MIPS_INSERT_B      R_MIPS = 26\n\tR_MIPS_DELETE        R_MIPS = 27\n\tR_MIPS_HIGHER        R_MIPS = 28\n\tR_MIPS_HIGHEST       R_MIPS = 29\n\tR_MIPS_CALL_HI16     R_MIPS = 30\n\tR_MIPS_CALL_LO16     R_MIPS = 31\n\tR_MIPS_SCN_DISP      R_MIPS = 32\n\tR_MIPS_REL16         R_MIPS = 33\n\tR_MIPS_ADD_IMMEDIATE R_MIPS = 34\n\tR_MIPS_PJUMP         R_MIPS = 35\n\tR_MIPS_RELGOT        R_MIPS = 36\n\tR_MIPS_JALR          R_MIPS = 37\n\n\tR_MIPS_TLS_DTPMOD32    R_MIPS = 38 /* Module number 32 bit */\n\tR_MIPS_TLS_DTPREL32    R_MIPS = 39 /* Module-relative offset 32 bit */\n\tR_MIPS_TLS_DTPMOD64    R_MIPS = 40 /* Module number 64 bit */\n\tR_MIPS_TLS_DTPREL64    R_MIPS = 41 /* Module-relative offset 64 bit */\n\tR_MIPS_TLS_GD          R_MIPS = 42 /* 16 bit GOT offset for GD */\n\tR_MIPS_TLS_LDM         R_MIPS = 43 /* 16 bit GOT offset for LDM */\n\tR_MIPS_TLS_DTPREL_HI16 R_MIPS = 44 /* Module-relative offset, high 16 bits */\n\tR_MIPS_TLS_DTPREL_LO16 R_MIPS = 45 /* Module-relative offset, low 16 bits */\n\tR_MIPS_TLS_GOTTPREL    R_MIPS = 46 /* 16 bit GOT offset for IE */\n\tR_MIPS_TLS_TPREL32     R_MIPS = 47 /* TP-relative offset, 32 bit */\n\tR_MIPS_TLS_TPREL64     R_MIPS = 48 /* TP-relative offset, 64 bit */\n\tR_MIPS_TLS_TPREL_HI16  R_MIPS = 49 /* TP-relative offset, high 16 bits */\n\tR_MIPS_TLS_TPREL_LO16  R_MIPS = 50 /* TP-relative offset, low 16 bits */\n\n\tR_MIPS_PC32 R_MIPS = 248 /* 32 bit PC relative reference */\n)\nfunc (i R_MIPS) GoString() string\n\nfunc (i R_MIPS) String() string\n\ntype R_PPC int\n    Relocation types for PowerPC.\n\n    Values that are shared by both R_PPC and R_PPC64 are prefixed with\n    R_POWERPC_ in the ELF standard. For the R_PPC type, the relevant shared\n    relocations have been renamed with the prefix R_PPC_. The original name\n    follows the value in a comment.\n\nconst (\n\tR_PPC_NONE            R_PPC = 0  // R_POWERPC_NONE\n\tR_PPC_ADDR32          R_PPC = 1  // R_POWERPC_ADDR32\n\tR_PPC_ADDR24          R_PPC = 2  // R_POWERPC_ADDR24\n\tR_PPC_ADDR16          R_PPC = 3  // R_POWERPC_ADDR16\n\tR_PPC_ADDR16_LO       R_PPC = 4  // R_POWERPC_ADDR16_LO\n\tR_PPC_ADDR16_HI       R_PPC = 5  // R_POWERPC_ADDR16_HI\n\tR_PPC_ADDR16_HA       R_PPC = 6  // R_POWERPC_ADDR16_HA\n\tR_PPC_ADDR14          R_PPC = 7  // R_POWERPC_ADDR14\n\tR_PPC_ADDR14_BRTAKEN  R_PPC = 8  // R_POWERPC_ADDR14_BRTAKEN\n\tR_PPC_ADDR14_BRNTAKEN R_PPC = 9  // R_POWERPC_ADDR14_BRNTAKEN\n\tR_PPC_REL24           R_PPC = 10 // R_POWERPC_REL24\n\tR_PPC_REL14           R_PPC = 11 // R_POWERPC_REL14\n\tR_PPC_REL14_BRTAKEN   R_PPC = 12 // R_POWERPC_REL14_BRTAKEN\n\tR_PPC_REL14_BRNTAKEN  R_PPC = 13 // R_POWERPC_REL14_BRNTAKEN\n\tR_PPC_GOT16           R_PPC = 14 // R_POWERPC_GOT16\n\tR_PPC_GOT16_LO        R_PPC = 15 // R_POWERPC_GOT16_LO\n\tR_PPC_GOT16_HI        R_PPC = 16 // R_POWERPC_GOT16_HI\n\tR_PPC_GOT16_HA        R_PPC = 17 // R_POWERPC_GOT16_HA\n\tR_PPC_PLTREL24        R_PPC = 18\n\tR_PPC_COPY            R_PPC = 19 // R_POWERPC_COPY\n\tR_PPC_GLOB_DAT        R_PPC = 20 // R_POWERPC_GLOB_DAT\n\tR_PPC_JMP_SLOT        R_PPC = 21 // R_POWERPC_JMP_SLOT\n\tR_PPC_RELATIVE        R_PPC = 22 // R_POWERPC_RELATIVE\n\tR_PPC_LOCAL24PC       R_PPC = 23\n\tR_PPC_UADDR32         R_PPC = 24 // R_POWERPC_UADDR32\n\tR_PPC_UADDR16         R_PPC = 25 // R_POWERPC_UADDR16\n\tR_PPC_REL32           R_PPC = 26 // R_POWERPC_REL32\n\tR_PPC_PLT32           R_PPC = 27 // R_POWERPC_PLT32\n\tR_PPC_PLTREL32        R_PPC = 28 // R_POWERPC_PLTREL32\n\tR_PPC_PLT16_LO        R_PPC = 29 // R_POWERPC_PLT16_LO\n\tR_PPC_PLT16_HI        R_PPC = 30 // R_POWERPC_PLT16_HI\n\tR_PPC_PLT16_HA        R_PPC = 31 // R_POWERPC_PLT16_HA\n\tR_PPC_SDAREL16        R_PPC = 32\n\tR_PPC_SECTOFF         R_PPC = 33 // R_POWERPC_SECTOFF\n\tR_PPC_SECTOFF_LO      R_PPC = 34 // R_POWERPC_SECTOFF_LO\n\tR_PPC_SECTOFF_HI      R_PPC = 35 // R_POWERPC_SECTOFF_HI\n\tR_PPC_SECTOFF_HA      R_PPC = 36 // R_POWERPC_SECTOFF_HA\n\tR_PPC_TLS             R_PPC = 67 // R_POWERPC_TLS\n\tR_PPC_DTPMOD32        R_PPC = 68 // R_POWERPC_DTPMOD32\n\tR_PPC_TPREL16         R_PPC = 69 // R_POWERPC_TPREL16\n\tR_PPC_TPREL16_LO      R_PPC = 70 // R_POWERPC_TPREL16_LO\n\tR_PPC_TPREL16_HI      R_PPC = 71 // R_POWERPC_TPREL16_HI\n\tR_PPC_TPREL16_HA      R_PPC = 72 // R_POWERPC_TPREL16_HA\n\tR_PPC_TPREL32         R_PPC = 73 // R_POWERPC_TPREL32\n\tR_PPC_DTPREL16        R_PPC = 74 // R_POWERPC_DTPREL16\n\tR_PPC_DTPREL16_LO     R_PPC = 75 // R_POWERPC_DTPREL16_LO\n\tR_PPC_DTPREL16_HI     R_PPC = 76 // R_POWERPC_DTPREL16_HI\n\tR_PPC_DTPREL16_HA     R_PPC = 77 // R_POWERPC_DTPREL16_HA\n\tR_PPC_DTPREL32        R_PPC = 78 // R_POWERPC_DTPREL32\n\tR_PPC_GOT_TLSGD16     R_PPC = 79 // R_POWERPC_GOT_TLSGD16\n\tR_PPC_GOT_TLSGD16_LO  R_PPC = 80 // R_POWERPC_GOT_TLSGD16_LO\n\tR_PPC_GOT_TLSGD16_HI  R_PPC = 81 // R_POWERPC_GOT_TLSGD16_HI\n\tR_PPC_GOT_TLSGD16_HA  R_PPC = 82 // R_POWERPC_GOT_TLSGD16_HA\n\tR_PPC_GOT_TLSLD16     R_PPC = 83 // R_POWERPC_GOT_TLSLD16\n\tR_PPC_GOT_TLSLD16_LO  R_PPC = 84 // R_POWERPC_GOT_TLSLD16_LO\n\tR_PPC_GOT_TLSLD16_HI  R_PPC = 85 // R_POWERPC_GOT_TLSLD16_HI\n\tR_PPC_GOT_TLSLD16_HA  R_PPC = 86 // R_POWERPC_GOT_TLSLD16_HA\n\tR_PPC_GOT_TPREL16     R_PPC = 87 // R_POWERPC_GOT_TPREL16\n\tR_PPC_GOT_TPREL16_LO  R_PPC = 88 // R_POWERPC_GOT_TPREL16_LO\n\tR_PPC_GOT_TPREL16_HI  R_PPC = 89 // R_POWERPC_GOT_TPREL16_HI\n\tR_PPC_GOT_TPREL16_HA  R_PPC = 90 // R_POWERPC_GOT_TPREL16_HA\n\tR_PPC_EMB_NADDR32     R_PPC = 101\n\tR_PPC_EMB_NADDR16     R_PPC = 102\n\tR_PPC_EMB_NADDR16_LO  R_PPC = 103\n\tR_PPC_EMB_NADDR16_HI  R_PPC = 104\n\tR_PPC_EMB_NADDR16_HA  R_PPC = 105\n\tR_PPC_EMB_SDAI16      R_PPC = 106\n\tR_PPC_EMB_SDA2I16     R_PPC = 107\n\tR_PPC_EMB_SDA2REL     R_PPC = 108\n\tR_PPC_EMB_SDA21       R_PPC = 109\n\tR_PPC_EMB_MRKREF      R_PPC = 110\n\tR_PPC_EMB_RELSEC16    R_PPC = 111\n\tR_PPC_EMB_RELST_LO    R_PPC = 112\n\tR_PPC_EMB_RELST_HI    R_PPC = 113\n\tR_PPC_EMB_RELST_HA    R_PPC = 114\n\tR_PPC_EMB_BIT_FLD     R_PPC = 115\n\tR_PPC_EMB_RELSDA      R_PPC = 116\n)\nfunc (i R_PPC) GoString() string\n\nfunc (i R_PPC) String() string\n\ntype R_PPC64 int\n    Relocation types for 64-bit PowerPC or Power Architecture processors.\n\n    Values that are shared by both R_PPC and R_PPC64 are prefixed with\n    R_POWERPC_ in the ELF standard. For the R_PPC64 type, the relevant shared\n    relocations have been renamed with the prefix R_PPC64_. The original name\n    follows the value in a comment.\n\nconst (\n\tR_PPC64_NONE               R_PPC64 = 0  // R_POWERPC_NONE\n\tR_PPC64_ADDR32             R_PPC64 = 1  // R_POWERPC_ADDR32\n\tR_PPC64_ADDR24             R_PPC64 = 2  // R_POWERPC_ADDR24\n\tR_PPC64_ADDR16             R_PPC64 = 3  // R_POWERPC_ADDR16\n\tR_PPC64_ADDR16_LO          R_PPC64 = 4  // R_POWERPC_ADDR16_LO\n\tR_PPC64_ADDR16_HI          R_PPC64 = 5  // R_POWERPC_ADDR16_HI\n\tR_PPC64_ADDR16_HA          R_PPC64 = 6  // R_POWERPC_ADDR16_HA\n\tR_PPC64_ADDR14             R_PPC64 = 7  // R_POWERPC_ADDR14\n\tR_PPC64_ADDR14_BRTAKEN     R_PPC64 = 8  // R_POWERPC_ADDR14_BRTAKEN\n\tR_PPC64_ADDR14_BRNTAKEN    R_PPC64 = 9  // R_POWERPC_ADDR14_BRNTAKEN\n\tR_PPC64_REL24              R_PPC64 = 10 // R_POWERPC_REL24\n\tR_PPC64_REL14              R_PPC64 = 11 // R_POWERPC_REL14\n\tR_PPC64_REL14_BRTAKEN      R_PPC64 = 12 // R_POWERPC_REL14_BRTAKEN\n\tR_PPC64_REL14_BRNTAKEN     R_PPC64 = 13 // R_POWERPC_REL14_BRNTAKEN\n\tR_PPC64_GOT16              R_PPC64 = 14 // R_POWERPC_GOT16\n\tR_PPC64_GOT16_LO           R_PPC64 = 15 // R_POWERPC_GOT16_LO\n\tR_PPC64_GOT16_HI           R_PPC64 = 16 // R_POWERPC_GOT16_HI\n\tR_PPC64_GOT16_HA           R_PPC64 = 17 // R_POWERPC_GOT16_HA\n\tR_PPC64_COPY               R_PPC64 = 19 // R_POWERPC_COPY\n\tR_PPC64_GLOB_DAT           R_PPC64 = 20 // R_POWERPC_GLOB_DAT\n\tR_PPC64_JMP_SLOT           R_PPC64 = 21 // R_POWERPC_JMP_SLOT\n\tR_PPC64_RELATIVE           R_PPC64 = 22 // R_POWERPC_RELATIVE\n\tR_PPC64_UADDR32            R_PPC64 = 24 // R_POWERPC_UADDR32\n\tR_PPC64_UADDR16            R_PPC64 = 25 // R_POWERPC_UADDR16\n\tR_PPC64_REL32              R_PPC64 = 26 // R_POWERPC_REL32\n\tR_PPC64_PLT32              R_PPC64 = 27 // R_POWERPC_PLT32\n\tR_PPC64_PLTREL32           R_PPC64 = 28 // R_POWERPC_PLTREL32\n\tR_PPC64_PLT16_LO           R_PPC64 = 29 // R_POWERPC_PLT16_LO\n\tR_PPC64_PLT16_HI           R_PPC64 = 30 // R_POWERPC_PLT16_HI\n\tR_PPC64_PLT16_HA           R_PPC64 = 31 // R_POWERPC_PLT16_HA\n\tR_PPC64_SECTOFF            R_PPC64 = 33 // R_POWERPC_SECTOFF\n\tR_PPC64_SECTOFF_LO         R_PPC64 = 34 // R_POWERPC_SECTOFF_LO\n\tR_PPC64_SECTOFF_HI         R_PPC64 = 35 // R_POWERPC_SECTOFF_HI\n\tR_PPC64_SECTOFF_HA         R_PPC64 = 36 // R_POWERPC_SECTOFF_HA\n\tR_PPC64_REL30              R_PPC64 = 37 // R_POWERPC_ADDR30\n\tR_PPC64_ADDR64             R_PPC64 = 38\n\tR_PPC64_ADDR16_HIGHER      R_PPC64 = 39\n\tR_PPC64_ADDR16_HIGHERA     R_PPC64 = 40\n\tR_PPC64_ADDR16_HIGHEST     R_PPC64 = 41\n\tR_PPC64_ADDR16_HIGHESTA    R_PPC64 = 42\n\tR_PPC64_UADDR64            R_PPC64 = 43\n\tR_PPC64_REL64              R_PPC64 = 44\n\tR_PPC64_PLT64              R_PPC64 = 45\n\tR_PPC64_PLTREL64           R_PPC64 = 46\n\tR_PPC64_TOC16              R_PPC64 = 47\n\tR_PPC64_TOC16_LO           R_PPC64 = 48\n\tR_PPC64_TOC16_HI           R_PPC64 = 49\n\tR_PPC64_TOC16_HA           R_PPC64 = 50\n\tR_PPC64_TOC                R_PPC64 = 51\n\tR_PPC64_PLTGOT16           R_PPC64 = 52\n\tR_PPC64_PLTGOT16_LO        R_PPC64 = 53\n\tR_PPC64_PLTGOT16_HI        R_PPC64 = 54\n\tR_PPC64_PLTGOT16_HA        R_PPC64 = 55\n\tR_PPC64_ADDR16_DS          R_PPC64 = 56\n\tR_PPC64_ADDR16_LO_DS       R_PPC64 = 57\n\tR_PPC64_GOT16_DS           R_PPC64 = 58\n\tR_PPC64_GOT16_LO_DS        R_PPC64 = 59\n\tR_PPC64_PLT16_LO_DS        R_PPC64 = 60\n\tR_PPC64_SECTOFF_DS         R_PPC64 = 61\n\tR_PPC64_SECTOFF_LO_DS      R_PPC64 = 62\n\tR_PPC64_TOC16_DS           R_PPC64 = 63\n\tR_PPC64_TOC16_LO_DS        R_PPC64 = 64\n\tR_PPC64_PLTGOT16_DS        R_PPC64 = 65\n\tR_PPC64_PLTGOT_LO_DS       R_PPC64 = 66\n\tR_PPC64_TLS                R_PPC64 = 67 // R_POWERPC_TLS\n\tR_PPC64_DTPMOD64           R_PPC64 = 68 // R_POWERPC_DTPMOD64\n\tR_PPC64_TPREL16            R_PPC64 = 69 // R_POWERPC_TPREL16\n\tR_PPC64_TPREL16_LO         R_PPC64 = 70 // R_POWERPC_TPREL16_LO\n\tR_PPC64_TPREL16_HI         R_PPC64 = 71 // R_POWERPC_TPREL16_HI\n\tR_PPC64_TPREL16_HA         R_PPC64 = 72 // R_POWERPC_TPREL16_HA\n\tR_PPC64_TPREL64            R_PPC64 = 73 // R_POWERPC_TPREL64\n\tR_PPC64_DTPREL16           R_PPC64 = 74 // R_POWERPC_DTPREL16\n\tR_PPC64_DTPREL16_LO        R_PPC64 = 75 // R_POWERPC_DTPREL16_LO\n\tR_PPC64_DTPREL16_HI        R_PPC64 = 76 // R_POWERPC_DTPREL16_HI\n\tR_PPC64_DTPREL16_HA        R_PPC64 = 77 // R_POWERPC_DTPREL16_HA\n\tR_PPC64_DTPREL64           R_PPC64 = 78 // R_POWERPC_DTPREL64\n\tR_PPC64_GOT_TLSGD16        R_PPC64 = 79 // R_POWERPC_GOT_TLSGD16\n\tR_PPC64_GOT_TLSGD16_LO     R_PPC64 = 80 // R_POWERPC_GOT_TLSGD16_LO\n\tR_PPC64_GOT_TLSGD16_HI     R_PPC64 = 81 // R_POWERPC_GOT_TLSGD16_HI\n\tR_PPC64_GOT_TLSGD16_HA     R_PPC64 = 82 // R_POWERPC_GOT_TLSGD16_HA\n\tR_PPC64_GOT_TLSLD16        R_PPC64 = 83 // R_POWERPC_GOT_TLSLD16\n\tR_PPC64_GOT_TLSLD16_LO     R_PPC64 = 84 // R_POWERPC_GOT_TLSLD16_LO\n\tR_PPC64_GOT_TLSLD16_HI     R_PPC64 = 85 // R_POWERPC_GOT_TLSLD16_HI\n\tR_PPC64_GOT_TLSLD16_HA     R_PPC64 = 86 // R_POWERPC_GOT_TLSLD16_HA\n\tR_PPC64_GOT_TPREL16_DS     R_PPC64 = 87 // R_POWERPC_GOT_TPREL16_DS\n\tR_PPC64_GOT_TPREL16_LO_DS  R_PPC64 = 88 // R_POWERPC_GOT_TPREL16_LO_DS\n\tR_PPC64_GOT_TPREL16_HI     R_PPC64 = 89 // R_POWERPC_GOT_TPREL16_HI\n\tR_PPC64_GOT_TPREL16_HA     R_PPC64 = 90 // R_POWERPC_GOT_TPREL16_HA\n\tR_PPC64_GOT_DTPREL16_DS    R_PPC64 = 91 // R_POWERPC_GOT_DTPREL16_DS\n\tR_PPC64_GOT_DTPREL16_LO_DS R_PPC64 = 92 // R_POWERPC_GOT_DTPREL16_LO_DS\n\tR_PPC64_GOT_DTPREL16_HI    R_PPC64 = 93 // R_POWERPC_GOT_DTPREL16_HI\n\tR_PPC64_GOT_DTPREL16_HA    R_PPC64 = 94 // R_POWERPC_GOT_DTPREL16_HA\n\tR_PPC64_TPREL16_DS         R_PPC64 = 95\n\tR_PPC64_TPREL16_LO_DS      R_PPC64 = 96\n\tR_PPC64_TPREL16_HIGHER     R_PPC64 = 97\n\tR_PPC64_TPREL16_HIGHERA    R_PPC64 = 98\n\tR_PPC64_TPREL16_HIGHEST    R_PPC64 = 99\n\tR_PPC64_TPREL16_HIGHESTA   R_PPC64 = 100\n\tR_PPC64_DTPREL16_DS        R_PPC64 = 101\n\tR_PPC64_DTPREL16_LO_DS     R_PPC64 = 102\n\tR_PPC64_DTPREL16_HIGHER    R_PPC64 = 103\n\tR_PPC64_DTPREL16_HIGHERA   R_PPC64 = 104\n\tR_PPC64_DTPREL16_HIGHEST   R_PPC64 = 105\n\tR_PPC64_DTPREL16_HIGHESTA  R_PPC64 = 106\n\tR_PPC64_TLSGD              R_PPC64 = 107\n\tR_PPC64_TLSLD              R_PPC64 = 108\n\tR_PPC64_TOCSAVE            R_PPC64 = 109\n\tR_PPC64_ADDR16_HIGH        R_PPC64 = 110\n\tR_PPC64_ADDR16_HIGHA       R_PPC64 = 111\n\tR_PPC64_TPREL16_HIGH       R_PPC64 = 112\n\tR_PPC64_TPREL16_HIGHA      R_PPC64 = 113\n\tR_PPC64_DTPREL16_HIGH      R_PPC64 = 114\n\tR_PPC64_DTPREL16_HIGHA     R_PPC64 = 115\n\tR_PPC64_REL24_NOTOC        R_PPC64 = 116\n\tR_PPC64_ADDR64_LOCAL       R_PPC64 = 117\n\tR_PPC64_ENTRY              R_PPC64 = 118\n\tR_PPC64_PLTSEQ             R_PPC64 = 119\n\tR_PPC64_PLTCALL            R_PPC64 = 120\n\tR_PPC64_PLTSEQ_NOTOC       R_PPC64 = 121\n\tR_PPC64_PLTCALL_NOTOC      R_PPC64 = 122\n\tR_PPC64_PCREL_OPT          R_PPC64 = 123\n\tR_PPC64_REL24_P9NOTOC      R_PPC64 = 124\n\tR_PPC64_D34                R_PPC64 = 128\n\tR_PPC64_D34_LO             R_PPC64 = 129\n\tR_PPC64_D34_HI30           R_PPC64 = 130\n\tR_PPC64_D34_HA30           R_PPC64 = 131\n\tR_PPC64_PCREL34            R_PPC64 = 132\n\tR_PPC64_GOT_PCREL34        R_PPC64 = 133\n\tR_PPC64_PLT_PCREL34        R_PPC64 = 134\n\tR_PPC64_PLT_PCREL34_NOTOC  R_PPC64 = 135\n\tR_PPC64_ADDR16_HIGHER34    R_PPC64 = 136\n\tR_PPC64_ADDR16_HIGHERA34   R_PPC64 = 137\n\tR_PPC64_ADDR16_HIGHEST34   R_PPC64 = 138\n\tR_PPC64_ADDR16_HIGHESTA34  R_PPC64 = 139\n\tR_PPC64_REL16_HIGHER34     R_PPC64 = 140\n\tR_PPC64_REL16_HIGHERA34    R_PPC64 = 141\n\tR_PPC64_REL16_HIGHEST34    R_PPC64 = 142\n\tR_PPC64_REL16_HIGHESTA34   R_PPC64 = 143\n\tR_PPC64_D28                R_PPC64 = 144\n\tR_PPC64_PCREL28            R_PPC64 = 145\n\tR_PPC64_TPREL34            R_PPC64 = 146\n\tR_PPC64_DTPREL34           R_PPC64 = 147\n\tR_PPC64_GOT_TLSGD_PCREL34  R_PPC64 = 148\n\tR_PPC64_GOT_TLSLD_PCREL34  R_PPC64 = 149\n\tR_PPC64_GOT_TPREL_PCREL34  R_PPC64 = 150\n\tR_PPC64_GOT_DTPREL_PCREL34 R_PPC64 = 151\n\tR_PPC64_REL16_HIGH         R_PPC64 = 240\n\tR_PPC64_REL16_HIGHA        R_PPC64 = 241\n\tR_PPC64_REL16_HIGHER       R_PPC64 = 242\n\tR_PPC64_REL16_HIGHERA      R_PPC64 = 243\n\tR_PPC64_REL16_HIGHEST      R_PPC64 = 244\n\tR_PPC64_REL16_HIGHESTA     R_PPC64 = 245\n\tR_PPC64_REL16DX_HA         R_PPC64 = 246 // R_POWERPC_REL16DX_HA\n\tR_PPC64_JMP_IREL           R_PPC64 = 247\n\tR_PPC64_IRELATIVE          R_PPC64 = 248 // R_POWERPC_IRELATIVE\n\tR_PPC64_REL16              R_PPC64 = 249 // R_POWERPC_REL16\n\tR_PPC64_REL16_LO           R_PPC64 = 250 // R_POWERPC_REL16_LO\n\tR_PPC64_REL16_HI           R_PPC64 = 251 // R_POWERPC_REL16_HI\n\tR_PPC64_REL16_HA           R_PPC64 = 252 // R_POWERPC_REL16_HA\n\tR_PPC64_GNU_VTINHERIT      R_PPC64 = 253\n\tR_PPC64_GNU_VTENTRY        R_PPC64 = 254\n)\nfunc (i R_PPC64) GoString() string\n\nfunc (i R_PPC64) String() string\n\ntype R_RISCV int\n    Relocation types for RISC-V processors.\n\nconst (\n\tR_RISCV_NONE          R_RISCV = 0  /* No relocation. */\n\tR_RISCV_32            R_RISCV = 1  /* Add 32 bit zero extended symbol value */\n\tR_RISCV_64            R_RISCV = 2  /* Add 64 bit symbol value. */\n\tR_RISCV_RELATIVE      R_RISCV = 3  /* Add load address of shared object. */\n\tR_RISCV_COPY          R_RISCV = 4  /* Copy data from shared object. */\n\tR_RISCV_JUMP_SLOT     R_RISCV = 5  /* Set GOT entry to code address. */\n\tR_RISCV_TLS_DTPMOD32  R_RISCV = 6  /* 32 bit ID of module containing symbol */\n\tR_RISCV_TLS_DTPMOD64  R_RISCV = 7  /* ID of module containing symbol */\n\tR_RISCV_TLS_DTPREL32  R_RISCV = 8  /* 32 bit relative offset in TLS block */\n\tR_RISCV_TLS_DTPREL64  R_RISCV = 9  /* Relative offset in TLS block */\n\tR_RISCV_TLS_TPREL32   R_RISCV = 10 /* 32 bit relative offset in static TLS block */\n\tR_RISCV_TLS_TPREL64   R_RISCV = 11 /* Relative offset in static TLS block */\n\tR_RISCV_BRANCH        R_RISCV = 16 /* PC-relative branch */\n\tR_RISCV_JAL           R_RISCV = 17 /* PC-relative jump */\n\tR_RISCV_CALL          R_RISCV = 18 /* PC-relative call */\n\tR_RISCV_CALL_PLT      R_RISCV = 19 /* PC-relative call (PLT) */\n\tR_RISCV_GOT_HI20      R_RISCV = 20 /* PC-relative GOT reference */\n\tR_RISCV_TLS_GOT_HI20  R_RISCV = 21 /* PC-relative TLS IE GOT offset */\n\tR_RISCV_TLS_GD_HI20   R_RISCV = 22 /* PC-relative TLS GD reference */\n\tR_RISCV_PCREL_HI20    R_RISCV = 23 /* PC-relative reference */\n\tR_RISCV_PCREL_LO12_I  R_RISCV = 24 /* PC-relative reference */\n\tR_RISCV_PCREL_LO12_S  R_RISCV = 25 /* PC-relative reference */\n\tR_RISCV_HI20          R_RISCV = 26 /* Absolute address */\n\tR_RISCV_LO12_I        R_RISCV = 27 /* Absolute address */\n\tR_RISCV_LO12_S        R_RISCV = 28 /* Absolute address */\n\tR_RISCV_TPREL_HI20    R_RISCV = 29 /* TLS LE thread offset */\n\tR_RISCV_TPREL_LO12_I  R_RISCV = 30 /* TLS LE thread offset */\n\tR_RISCV_TPREL_LO12_S  R_RISCV = 31 /* TLS LE thread offset */\n\tR_RISCV_TPREL_ADD     R_RISCV = 32 /* TLS LE thread usage */\n\tR_RISCV_ADD8          R_RISCV = 33 /* 8-bit label addition */\n\tR_RISCV_ADD16         R_RISCV = 34 /* 16-bit label addition */\n\tR_RISCV_ADD32         R_RISCV = 35 /* 32-bit label addition */\n\tR_RISCV_ADD64         R_RISCV = 36 /* 64-bit label addition */\n\tR_RISCV_SUB8          R_RISCV = 37 /* 8-bit label subtraction */\n\tR_RISCV_SUB16         R_RISCV = 38 /* 16-bit label subtraction */\n\tR_RISCV_SUB32         R_RISCV = 39 /* 32-bit label subtraction */\n\tR_RISCV_SUB64         R_RISCV = 40 /* 64-bit label subtraction */\n\tR_RISCV_GNU_VTINHERIT R_RISCV = 41 /* GNU C++ vtable hierarchy */\n\tR_RISCV_GNU_VTENTRY   R_RISCV = 42 /* GNU C++ vtable member usage */\n\tR_RISCV_ALIGN         R_RISCV = 43 /* Alignment statement */\n\tR_RISCV_RVC_BRANCH    R_RISCV = 44 /* PC-relative branch offset */\n\tR_RISCV_RVC_JUMP      R_RISCV = 45 /* PC-relative jump offset */\n\tR_RISCV_RVC_LUI       R_RISCV = 46 /* Absolute address */\n\tR_RISCV_GPREL_I       R_RISCV = 47 /* GP-relative reference */\n\tR_RISCV_GPREL_S       R_RISCV = 48 /* GP-relative reference */\n\tR_RISCV_TPREL_I       R_RISCV = 49 /* TP-relative TLS LE load */\n\tR_RISCV_TPREL_S       R_RISCV = 50 /* TP-relative TLS LE store */\n\tR_RISCV_RELAX         R_RISCV = 51 /* Instruction pair can be relaxed */\n\tR_RISCV_SUB6          R_RISCV = 52 /* Local label subtraction */\n\tR_RISCV_SET6          R_RISCV = 53 /* Local label subtraction */\n\tR_RISCV_SET8          R_RISCV = 54 /* Local label subtraction */\n\tR_RISCV_SET16         R_RISCV = 55 /* Local label subtraction */\n\tR_RISCV_SET32         R_RISCV = 56 /* Local label subtraction */\n\tR_RISCV_32_PCREL      R_RISCV = 57 /* 32-bit PC relative */\n)\nfunc (i R_RISCV) GoString() string\n\nfunc (i R_RISCV) String() string\n\ntype R_SPARC int\n    Relocation types for SPARC.\n\nconst (\n\tR_SPARC_NONE     R_SPARC = 0\n\tR_SPARC_8        R_SPARC = 1\n\tR_SPARC_16       R_SPARC = 2\n\tR_SPARC_32       R_SPARC = 3\n\tR_SPARC_DISP8    R_SPARC = 4\n\tR_SPARC_DISP16   R_SPARC = 5\n\tR_SPARC_DISP32   R_SPARC = 6\n\tR_SPARC_WDISP30  R_SPARC = 7\n\tR_SPARC_WDISP22  R_SPARC = 8\n\tR_SPARC_HI22     R_SPARC = 9\n\tR_SPARC_22       R_SPARC = 10\n\tR_SPARC_13       R_SPARC = 11\n\tR_SPARC_LO10     R_SPARC = 12\n\tR_SPARC_GOT10    R_SPARC = 13\n\tR_SPARC_GOT13    R_SPARC = 14\n\tR_SPARC_GOT22    R_SPARC = 15\n\tR_SPARC_PC10     R_SPARC = 16\n\tR_SPARC_PC22     R_SPARC = 17\n\tR_SPARC_WPLT30   R_SPARC = 18\n\tR_SPARC_COPY     R_SPARC = 19\n\tR_SPARC_GLOB_DAT R_SPARC = 20\n\tR_SPARC_JMP_SLOT R_SPARC = 21\n\tR_SPARC_RELATIVE R_SPARC = 22\n\tR_SPARC_UA32     R_SPARC = 23\n\tR_SPARC_PLT32    R_SPARC = 24\n\tR_SPARC_HIPLT22  R_SPARC = 25\n\tR_SPARC_LOPLT10  R_SPARC = 26\n\tR_SPARC_PCPLT32  R_SPARC = 27\n\tR_SPARC_PCPLT22  R_SPARC = 28\n\tR_SPARC_PCPLT10  R_SPARC = 29\n\tR_SPARC_10       R_SPARC = 30\n\tR_SPARC_11       R_SPARC = 31\n\tR_SPARC_64       R_SPARC = 32\n\tR_SPARC_OLO10    R_SPARC = 33\n\tR_SPARC_HH22     R_SPARC = 34\n\tR_SPARC_HM10     R_SPARC = 35\n\tR_SPARC_LM22     R_SPARC = 36\n\tR_SPARC_PC_HH22  R_SPARC = 37\n\tR_SPARC_PC_HM10  R_SPARC = 38\n\tR_SPARC_PC_LM22  R_SPARC = 39\n\tR_SPARC_WDISP16  R_SPARC = 40\n\tR_SPARC_WDISP19  R_SPARC = 41\n\tR_SPARC_GLOB_JMP R_SPARC = 42\n\tR_SPARC_7        R_SPARC = 43\n\tR_SPARC_5        R_SPARC = 44\n\tR_SPARC_6        R_SPARC = 45\n\tR_SPARC_DISP64   R_SPARC = 46\n\tR_SPARC_PLT64    R_SPARC = 47\n\tR_SPARC_HIX22    R_SPARC = 48\n\tR_SPARC_LOX10    R_SPARC = 49\n\tR_SPARC_H44      R_SPARC = 50\n\tR_SPARC_M44      R_SPARC = 51\n\tR_SPARC_L44      R_SPARC = 52\n\tR_SPARC_REGISTER R_SPARC = 53\n\tR_SPARC_UA64     R_SPARC = 54\n\tR_SPARC_UA16     R_SPARC = 55\n)\nfunc (i R_SPARC) GoString() string\n\nfunc (i R_SPARC) String() string\n\ntype R_X86_64 int\n    Relocation types for x86-64.\n\nconst (\n\tR_X86_64_NONE            R_X86_64 = 0  /* No relocation. */\n\tR_X86_64_64              R_X86_64 = 1  /* Add 64 bit symbol value. */\n\tR_X86_64_PC32            R_X86_64 = 2  /* PC-relative 32 bit signed sym value. */\n\tR_X86_64_GOT32           R_X86_64 = 3  /* PC-relative 32 bit GOT offset. */\n\tR_X86_64_PLT32           R_X86_64 = 4  /* PC-relative 32 bit PLT offset. */\n\tR_X86_64_COPY            R_X86_64 = 5  /* Copy data from shared object. */\n\tR_X86_64_GLOB_DAT        R_X86_64 = 6  /* Set GOT entry to data address. */\n\tR_X86_64_JMP_SLOT        R_X86_64 = 7  /* Set GOT entry to code address. */\n\tR_X86_64_RELATIVE        R_X86_64 = 8  /* Add load address of shared object. */\n\tR_X86_64_GOTPCREL        R_X86_64 = 9  /* Add 32 bit signed pcrel offset to GOT. */\n\tR_X86_64_32              R_X86_64 = 10 /* Add 32 bit zero extended symbol value */\n\tR_X86_64_32S             R_X86_64 = 11 /* Add 32 bit sign extended symbol value */\n\tR_X86_64_16              R_X86_64 = 12 /* Add 16 bit zero extended symbol value */\n\tR_X86_64_PC16            R_X86_64 = 13 /* Add 16 bit signed extended pc relative symbol value */\n\tR_X86_64_8               R_X86_64 = 14 /* Add 8 bit zero extended symbol value */\n\tR_X86_64_PC8             R_X86_64 = 15 /* Add 8 bit signed extended pc relative symbol value */\n\tR_X86_64_DTPMOD64        R_X86_64 = 16 /* ID of module containing symbol */\n\tR_X86_64_DTPOFF64        R_X86_64 = 17 /* Offset in TLS block */\n\tR_X86_64_TPOFF64         R_X86_64 = 18 /* Offset in static TLS block */\n\tR_X86_64_TLSGD           R_X86_64 = 19 /* PC relative offset to GD GOT entry */\n\tR_X86_64_TLSLD           R_X86_64 = 20 /* PC relative offset to LD GOT entry */\n\tR_X86_64_DTPOFF32        R_X86_64 = 21 /* Offset in TLS block */\n\tR_X86_64_GOTTPOFF        R_X86_64 = 22 /* PC relative offset to IE GOT entry */\n\tR_X86_64_TPOFF32         R_X86_64 = 23 /* Offset in static TLS block */\n\tR_X86_64_PC64            R_X86_64 = 24 /* PC relative 64-bit sign extended symbol value. */\n\tR_X86_64_GOTOFF64        R_X86_64 = 25\n\tR_X86_64_GOTPC32         R_X86_64 = 26\n\tR_X86_64_GOT64           R_X86_64 = 27\n\tR_X86_64_GOTPCREL64      R_X86_64 = 28\n\tR_X86_64_GOTPC64         R_X86_64 = 29\n\tR_X86_64_GOTPLT64        R_X86_64 = 30\n\tR_X86_64_PLTOFF64        R_X86_64 = 31\n\tR_X86_64_SIZE32          R_X86_64 = 32\n\tR_X86_64_SIZE64          R_X86_64 = 33\n\tR_X86_64_GOTPC32_TLSDESC R_X86_64 = 34\n\tR_X86_64_TLSDESC_CALL    R_X86_64 = 35\n\tR_X86_64_TLSDESC         R_X86_64 = 36\n\tR_X86_64_IRELATIVE       R_X86_64 = 37\n\tR_X86_64_RELATIVE64      R_X86_64 = 38\n\tR_X86_64_PC32_BND        R_X86_64 = 39\n\tR_X86_64_PLT32_BND       R_X86_64 = 40\n\tR_X86_64_GOTPCRELX       R_X86_64 = 41\n\tR_X86_64_REX_GOTPCRELX   R_X86_64 = 42\n)\nfunc (i R_X86_64) GoString() string\n\nfunc (i R_X86_64) String() string\n\ntype Rel32 struct {\n\tOff  uint32 /* Location to be relocated. */\n\tInfo uint32 /* Relocation type and symbol index. */\n}\n    ELF32 Relocations that don't need an addend field.\n\ntype Rel64 struct {\n\tOff  uint64 /* Location to be relocated. */\n\tInfo uint64 /* Relocation type and symbol index. */\n}\n    ELF64 relocations that don't need an addend field.\n\ntype Rela32 struct {\n\tOff    uint32 /* Location to be relocated. */\n\tInfo   uint32 /* Relocation type and symbol index. */\n\tAddend int32  /* Addend. */\n}\n    ELF32 Relocations that need an addend field.\n\ntype Rela64 struct {\n\tOff    uint64 /* Location to be relocated. */\n\tInfo   uint64 /* Relocation type and symbol index. */\n\tAddend int64  /* Addend. */\n}\n    ELF64 relocations that need an addend field.\n\ntype Section struct {\n\tSectionHeader\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\t//\n\t// ReaderAt may be nil if the section is not easily available\n\t// in a random-access form. For example, a compressed section\n\t// may have a nil ReaderAt.\n\tio.ReaderAt\n\n\t// Has unexported fields.\n}\n    A Section represents a single section in an ELF file.\n\nfunc (s *Section) Data() ([]byte, error)\n    Data reads and returns the contents of the ELF section. Even if the section\n    is stored compressed in the ELF file, Data returns uncompressed data.\n\n    For an SHT_NOBITS section, Data always returns a non-nil error.\n\nfunc (s *Section) Open() io.ReadSeeker\n    Open returns a new ReadSeeker reading the ELF section. Even if the section\n    is stored compressed in the ELF file, the ReadSeeker reads uncompressed\n    data.\n\n    For an SHT_NOBITS section, all calls to the opened reader will return a\n    non-nil error.\n\ntype Section32 struct {\n\tName      uint32 /* Section name (index into the section header string table). */\n\tType      uint32 /* Section type. */\n\tFlags     uint32 /* Section flags. */\n\tAddr      uint32 /* Address in memory image. */\n\tOff       uint32 /* Offset in file. */\n\tSize      uint32 /* Size in bytes. */\n\tLink      uint32 /* Index of a related section. */\n\tInfo      uint32 /* Depends on section type. */\n\tAddralign uint32 /* Alignment in bytes. */\n\tEntsize   uint32 /* Size of each entry in section. */\n}\n    ELF32 Section header.\n\ntype Section64 struct {\n\tName      uint32 /* Section name (index into the section header string table). */\n\tType      uint32 /* Section type. */\n\tFlags     uint64 /* Section flags. */\n\tAddr      uint64 /* Address in memory image. */\n\tOff       uint64 /* Offset in file. */\n\tSize      uint64 /* Size in bytes. */\n\tLink      uint32 /* Index of a related section. */\n\tInfo      uint32 /* Depends on section type. */\n\tAddralign uint64 /* Alignment in bytes. */\n\tEntsize   uint64 /* Size of each entry in section. */\n}\n    ELF64 Section header.\n\ntype SectionFlag uint32\n    Section flags.\n\nconst (\n\tSHF_WRITE            SectionFlag = 0x1        /* Section contains writable data. */\n\tSHF_ALLOC            SectionFlag = 0x2        /* Section occupies memory. */\n\tSHF_EXECINSTR        SectionFlag = 0x4        /* Section contains instructions. */\n\tSHF_MERGE            SectionFlag = 0x10       /* Section may be merged. */\n\tSHF_STRINGS          SectionFlag = 0x20       /* Section contains strings. */\n\tSHF_INFO_LINK        SectionFlag = 0x40       /* sh_info holds section index. */\n\tSHF_LINK_ORDER       SectionFlag = 0x80       /* Special ordering requirements. */\n\tSHF_OS_NONCONFORMING SectionFlag = 0x100      /* OS-specific processing required. */\n\tSHF_GROUP            SectionFlag = 0x200      /* Member of section group. */\n\tSHF_TLS              SectionFlag = 0x400      /* Section contains TLS data. */\n\tSHF_COMPRESSED       SectionFlag = 0x800      /* Section is compressed. */\n\tSHF_MASKOS           SectionFlag = 0x0ff00000 /* OS-specific semantics. */\n\tSHF_MASKPROC         SectionFlag = 0xf0000000 /* Processor-specific semantics. */\n)\nfunc (i SectionFlag) GoString() string\n\nfunc (i SectionFlag) String() string\n\ntype SectionHeader struct {\n\tName      string\n\tType      SectionType\n\tFlags     SectionFlag\n\tAddr      uint64\n\tOffset    uint64\n\tSize      uint64\n\tLink      uint32\n\tInfo      uint32\n\tAddralign uint64\n\tEntsize   uint64\n\n\t// FileSize is the size of this section in the file in bytes.\n\t// If a section is compressed, FileSize is the size of the\n\t// compressed data, while Size (above) is the size of the\n\t// uncompressed data.\n\tFileSize uint64\n}\n    A SectionHeader represents a single ELF section header.\n\ntype SectionIndex int\n    Special section indices.\n\nconst (\n\tSHN_UNDEF     SectionIndex = 0      /* Undefined, missing, irrelevant. */\n\tSHN_LORESERVE SectionIndex = 0xff00 /* First of reserved range. */\n\tSHN_LOPROC    SectionIndex = 0xff00 /* First processor-specific. */\n\tSHN_HIPROC    SectionIndex = 0xff1f /* Last processor-specific. */\n\tSHN_LOOS      SectionIndex = 0xff20 /* First operating system-specific. */\n\tSHN_HIOS      SectionIndex = 0xff3f /* Last operating system-specific. */\n\tSHN_ABS       SectionIndex = 0xfff1 /* Absolute values. */\n\tSHN_COMMON    SectionIndex = 0xfff2 /* Common data. */\n\tSHN_XINDEX    SectionIndex = 0xffff /* Escape; index stored elsewhere. */\n\tSHN_HIRESERVE SectionIndex = 0xffff /* Last of reserved range. */\n)\nfunc (i SectionIndex) GoString() string\n\nfunc (i SectionIndex) String() string\n\ntype SectionType uint32\n    Section type.\n\nconst (\n\tSHT_NULL             SectionType = 0          /* inactive */\n\tSHT_PROGBITS         SectionType = 1          /* program defined information */\n\tSHT_SYMTAB           SectionType = 2          /* symbol table section */\n\tSHT_STRTAB           SectionType = 3          /* string table section */\n\tSHT_RELA             SectionType = 4          /* relocation section with addends */\n\tSHT_HASH             SectionType = 5          /* symbol hash table section */\n\tSHT_DYNAMIC          SectionType = 6          /* dynamic section */\n\tSHT_NOTE             SectionType = 7          /* note section */\n\tSHT_NOBITS           SectionType = 8          /* no space section */\n\tSHT_REL              SectionType = 9          /* relocation section - no addends */\n\tSHT_SHLIB            SectionType = 10         /* reserved - purpose unknown */\n\tSHT_DYNSYM           SectionType = 11         /* dynamic symbol table section */\n\tSHT_INIT_ARRAY       SectionType = 14         /* Initialization function pointers. */\n\tSHT_FINI_ARRAY       SectionType = 15         /* Termination function pointers. */\n\tSHT_PREINIT_ARRAY    SectionType = 16         /* Pre-initialization function ptrs. */\n\tSHT_GROUP            SectionType = 17         /* Section group. */\n\tSHT_SYMTAB_SHNDX     SectionType = 18         /* Section indexes (see SHN_XINDEX). */\n\tSHT_LOOS             SectionType = 0x60000000 /* First of OS specific semantics */\n\tSHT_GNU_ATTRIBUTES   SectionType = 0x6ffffff5 /* GNU object attributes */\n\tSHT_GNU_HASH         SectionType = 0x6ffffff6 /* GNU hash table */\n\tSHT_GNU_LIBLIST      SectionType = 0x6ffffff7 /* GNU prelink library list */\n\tSHT_GNU_VERDEF       SectionType = 0x6ffffffd /* GNU version definition section */\n\tSHT_GNU_VERNEED      SectionType = 0x6ffffffe /* GNU version needs section */\n\tSHT_GNU_VERSYM       SectionType = 0x6fffffff /* GNU version symbol table */\n\tSHT_HIOS             SectionType = 0x6fffffff /* Last of OS specific semantics */\n\tSHT_LOPROC           SectionType = 0x70000000 /* reserved range for processor */\n\tSHT_RISCV_ATTRIBUTES SectionType = 0x70000003 /* RISCV object attributes */\n\tSHT_MIPS_ABIFLAGS    SectionType = 0x7000002a /* .MIPS.abiflags */\n\tSHT_HIPROC           SectionType = 0x7fffffff /* specific section header types */\n\tSHT_LOUSER           SectionType = 0x80000000 /* reserved range for application */\n\tSHT_HIUSER           SectionType = 0xffffffff /* specific indexes */\n)\nfunc (i SectionType) GoString() string\n\nfunc (i SectionType) String() string\n\ntype Sym32 struct {\n\tName  uint32\n\tValue uint32\n\tSize  uint32\n\tInfo  uint8\n\tOther uint8\n\tShndx uint16\n}\n    ELF32 Symbol.\n\ntype Sym64 struct {\n\tName  uint32 /* String table index of name. */\n\tInfo  uint8  /* Type and binding information. */\n\tOther uint8  /* Reserved (not used). */\n\tShndx uint16 /* Section index of symbol. */\n\tValue uint64 /* Symbol value. */\n\tSize  uint64 /* Size of associated object. */\n}\n    ELF64 symbol table entries.\n\ntype SymBind int\n    Symbol Binding - ELFNN_ST_BIND - st_info\n\nconst (\n\tSTB_LOCAL  SymBind = 0  /* Local symbol */\n\tSTB_GLOBAL SymBind = 1  /* Global symbol */\n\tSTB_WEAK   SymBind = 2  /* like global - lower precedence */\n\tSTB_LOOS   SymBind = 10 /* Reserved range for operating system */\n\tSTB_HIOS   SymBind = 12 /*   specific semantics. */\n\tSTB_LOPROC SymBind = 13 /* reserved range for processor */\n\tSTB_HIPROC SymBind = 15 /*   specific semantics. */\n)\nfunc ST_BIND(info uint8) SymBind\n\nfunc (i SymBind) GoString() string\n\nfunc (i SymBind) String() string\n\ntype SymType int\n    Symbol type - ELFNN_ST_TYPE - st_info\n\nconst (\n\tSTT_NOTYPE  SymType = 0  /* Unspecified type. */\n\tSTT_OBJECT  SymType = 1  /* Data object. */\n\tSTT_FUNC    SymType = 2  /* Function. */\n\tSTT_SECTION SymType = 3  /* Section. */\n\tSTT_FILE    SymType = 4  /* Source file. */\n\tSTT_COMMON  SymType = 5  /* Uninitialized common block. */\n\tSTT_TLS     SymType = 6  /* TLS object. */\n\tSTT_LOOS    SymType = 10 /* Reserved range for operating system */\n\tSTT_HIOS    SymType = 12 /*   specific semantics. */\n\tSTT_LOPROC  SymType = 13 /* reserved range for processor */\n\tSTT_HIPROC  SymType = 15 /*   specific semantics. */\n\n\t/* Non-standard symbol types. */\n\tSTT_RELC      SymType = 8  /* Complex relocation expression. */\n\tSTT_SRELC     SymType = 9  /* Signed complex relocation expression. */\n\tSTT_GNU_IFUNC SymType = 10 /* Indirect code object. */\n)\nfunc ST_TYPE(info uint8) SymType\n\nfunc (i SymType) GoString() string\n\nfunc (i SymType) String() string\n\ntype SymVis int\n    Symbol visibility - ELFNN_ST_VISIBILITY - st_other\n\nconst (\n\tSTV_DEFAULT   SymVis = 0x0 /* Default visibility (see binding). */\n\tSTV_INTERNAL  SymVis = 0x1 /* Special meaning in relocatable objects. */\n\tSTV_HIDDEN    SymVis = 0x2 /* Not visible. */\n\tSTV_PROTECTED SymVis = 0x3 /* Visible but not preemptible. */\n)\nfunc ST_VISIBILITY(other uint8) SymVis\n\nfunc (i SymVis) GoString() string\n\nfunc (i SymVis) String() string\n\ntype Symbol struct {\n\tName        string\n\tInfo, Other byte\n\n\t// HasVersion reports whether the symbol has any version information.\n\t// This will only be true for the dynamic symbol table.\n\tHasVersion bool\n\t// VersionIndex is the symbol's version index.\n\t// Use the methods of the [VersionIndex] type to access it.\n\t// This field is only meaningful if HasVersion is true.\n\tVersionIndex VersionIndex\n\n\tSection     SectionIndex\n\tValue, Size uint64\n\n\t// These fields are present only for the dynamic symbol table.\n\tVersion string\n\tLibrary string\n}\n    A Symbol represents an entry in an ELF symbol table section.\n\ntype Type uint16\n    Type is found in Header.Type.\n\nconst (\n\tET_NONE   Type = 0      /* Unknown type. */\n\tET_REL    Type = 1      /* Relocatable. */\n\tET_EXEC   Type = 2      /* Executable. */\n\tET_DYN    Type = 3      /* Shared object. */\n\tET_CORE   Type = 4      /* Core file. */\n\tET_LOOS   Type = 0xfe00 /* First operating system specific. */\n\tET_HIOS   Type = 0xfeff /* Last operating system-specific. */\n\tET_LOPROC Type = 0xff00 /* First processor-specific. */\n\tET_HIPROC Type = 0xffff /* Last processor-specific. */\n)\nfunc (i Type) GoString() string\n\nfunc (i Type) String() string\n\ntype Version byte\n    Version is found in Header.Ident[EI_VERSION] and Header.Version.\n\nconst (\n\tEV_NONE    Version = 0\n\tEV_CURRENT Version = 1\n)\nfunc (i Version) GoString() string\n\nfunc (i Version) String() string\n\ntype VersionIndex uint16\n    VersionIndex is the type of a Symbol version index.\n\nfunc (vi VersionIndex) Index() uint16\n    Index returns the version index. If this is the value 0, it means that the\n    symbol is local, and is not visible externally. If this is the value 1,\n    it means that the symbol is in the base version, and has no specific\n    version; it may or may not match a [DynamicVersion.Index] in the slice\n    returned by File.DynamicVersions. Other values will match either\n    [DynamicVersion.Index] in the slice returned by File.DynamicVersions,\n    or [DynamicVersionDep.Index] in the Needs field of the elements of the slice\n    returned by File.DynamicVersionNeeds. In general, a defined symbol will have\n    an index referring to DynamicVersions, and an undefined symbol will have an\n    index referring to some version in DynamicVersionNeeds.\n\nfunc (vi VersionIndex) IsHidden() bool\n    IsHidden reports whether the symbol is hidden within the version. This means\n    that the symbol can only be seen by specifying the exact version.\n\n"}, {"path": "stdlib/image-gif.md", "category": "stdlib", "name": "stdlib/image-gif", "content": "package gif // import \"image/gif\"\n\nPackage gif implements a GIF image decoder and encoder.\n\nThe GIF specification is at https://www.w3.org/Graphics/GIF/spec-gif89a.txt.\n\nCONSTANTS\n\nconst (\n\tDisposalNone       = 0x01\n\tDisposalBackground = 0x02\n\tDisposalPrevious   = 0x03\n)\n    Disposal Methods.\n\n\nFUNCTIONS\n\nfunc Decode(r io.Reader) (image.Image, error)\n    Decode reads a GIF image from r and returns the first embedded image as an\n    image.Image.\n\nfunc DecodeConfig(r io.Reader) (image.Config, error)\n    DecodeConfig returns the global color model and dimensions of a GIF image\n    without decoding the entire image.\n\nfunc Encode(w io.Writer, m image.Image, o *Options) error\n    Encode writes the Image m to w in GIF format.\n\nfunc EncodeAll(w io.Writer, g *GIF) error\n    EncodeAll writes the images in g to w in GIF format with the given loop\n    count and delay between frames.\n\n\nTYPES\n\ntype GIF struct {\n\tImage []*image.Paletted // The successive images.\n\tDelay []int             // The successive delay times, one per frame, in 100ths of a second.\n\t// LoopCount controls the number of times an animation will be\n\t// restarted during display.\n\t// A LoopCount of 0 means to loop forever.\n\t// A LoopCount of -1 means to show each frame only once.\n\t// Otherwise, the animation is looped LoopCount+1 times.\n\tLoopCount int\n\t// Disposal is the successive disposal methods, one per frame. For\n\t// backwards compatibility, a nil Disposal is valid to pass to EncodeAll,\n\t// and implies that each frame's disposal method is 0 (no disposal\n\t// specified).\n\tDisposal []byte\n\t// Config is the global color table (palette), width and height. A nil or\n\t// empty-color.Palette Config.ColorModel means that each frame has its own\n\t// color table and there is no global color table. Each frame's bounds must\n\t// be within the rectangle defined by the two points (0, 0) and\n\t// (Config.Width, Config.Height).\n\t//\n\t// For backwards compatibility, a zero-valued Config is valid to pass to\n\t// EncodeAll, and implies that the overall GIF's width and height equals\n\t// the first frame's bounds' Rectangle.Max point.\n\tConfig image.Config\n\t// BackgroundIndex is the background index in the global color table, for\n\t// use with the DisposalBackground disposal method.\n\tBackgroundIndex byte\n}\n    GIF represents the possibly multiple images stored in a GIF file.\n\nfunc DecodeAll(r io.Reader) (*GIF, error)\n    DecodeAll reads a GIF image from r and returns the sequential frames and\n    timing information.\n\ntype Options struct {\n\t// NumColors is the maximum number of colors used in the image.\n\t// It ranges from 1 to 256.\n\tNumColors int\n\n\t// Quantizer is used to produce a palette with size NumColors.\n\t// palette.Plan9 is used in place of a nil Quantizer.\n\tQuantizer draw.Quantizer\n\n\t// Drawer is used to convert the source image to the desired palette.\n\t// draw.FloydSteinberg is used in place of a nil Drawer.\n\tDrawer draw.Drawer\n}\n    Options are the encoding parameters.\n\n"}, {"path": "stdlib/go-version.md", "category": "stdlib", "name": "stdlib/go-version", "content": "package version // import \"go/version\"\n\nPackage version provides operations on Go versions in Go toolchain name syntax:\nstrings like \"go1.20\", \"go1.21.0\", \"go1.22rc2\", and \"go1.23.4-bigcorp\".\n\n[Go versions]: https://go.dev/doc/toolchain#version\n[Go toolchain name syntax]: https://go.dev/doc/toolchain#name\n\nFUNCTIONS\n\nfunc Compare(x, y string) int\n    Compare returns -1, 0, or +1 depending on whether x < y, x == y, or x > y,\n    interpreted as Go versions. The versions x and y must begin with a \"go\"\n    prefix: \"go1.21\" not \"1.21\". Invalid versions, including the empty string,\n    compare less than valid versions and equal to each other. The language\n    version \"go1.21\" compares less than the release candidate and eventual\n    releases \"go1.21rc1\" and \"go1.21.0\".\n\nfunc IsValid(x string) bool\n    IsValid reports whether the version x is valid.\n\nfunc Lang(x string) string\n    Lang returns the Go language version for version x. If x is not a valid\n    version, Lang returns the empty string. For example:\n\n        Lang(\"go1.21rc2\") = \"go1.21\"\n        Lang(\"go1.21.2\") = \"go1.21\"\n        Lang(\"go1.21\") = \"go1.21\"\n        Lang(\"go1\") = \"go1\"\n        Lang(\"bad\") = \"\"\n        Lang(\"1.21\") = \"\"\n\n"}, {"path": "stdlib/net-http-pprof.md", "category": "stdlib", "name": "stdlib/net-http-pprof", "content": "package pprof // import \"net/http/pprof\"\n\nPackage pprof serves via its HTTP server runtime profiling data in the format\nexpected by the pprof visualization tool.\n\nThe package is typically only imported for the side effect of registering its\nHTTP handlers. The handled paths all begin with /debug/pprof/. As of Go 1.22,\nall the paths must be requested with GET.\n\nTo use pprof, link this package into your program:\n\n    import _ \"net/http/pprof\"\n\nIf your application is not already running an http server, you need to start\none. Add \"net/http\" and \"log\" to your imports and the following code to your\nmain function:\n\n    go func() {\n    \tlog.Println(http.ListenAndServe(\"localhost:6060\", nil))\n    }()\n\nBy default, all the profiles listed in runtime/pprof.Profile are available\n(via Handler), in addition to the Cmdline, Profile, Symbol, and Trace profiles\ndefined in this package. If you are not using DefaultServeMux, you will have to\nregister handlers with the mux you are using.\n\n# Parameters\n\nParameters can be passed via GET query params:\n\n  - debug=N (all profiles): response format: N = 0: binary (default), N > 0:\n    plaintext\n  - gc=N (heap profile): N > 0: run a garbage collection cycle before profiling\n  - seconds=N (allocs, block, goroutine, heap, mutex, threadcreate profiles):\n    return a delta profile\n  - seconds=N (cpu (profile), trace profiles): profile for the given duration\n\n# Usage examples\n\nUse the pprof tool to look at the heap profile:\n\n    go tool pprof http://localhost:6060/debug/pprof/heap\n\nOr to look at a 30-second CPU profile:\n\n    go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30\n\nOr to look at the goroutine blocking profile, after calling\nruntime.SetBlockProfileRate in your program:\n\n    go tool pprof http://localhost:6060/debug/pprof/block\n\nOr to look at the holders of contended mutexes, after calling\nruntime.SetMutexProfileFraction in your program:\n\n    go tool pprof http://localhost:6060/debug/pprof/mutex\n\nThe package also exports a handler that serves execution trace data for the \"go\ntool trace\" command. To collect a 5-second execution trace:\n\n    curl -o trace.out http://localhost:6060/debug/pprof/trace?seconds=5\n    go tool trace trace.out\n\nTo view all available profiles, open http://localhost:6060/debug/pprof/ in your\nbrowser.\n\nFor a study of the facility in action, visit\nhttps://blog.golang.org/2011/06/profiling-go-programs.html.\n\nFUNCTIONS\n\nfunc Cmdline(w http.ResponseWriter, r *http.Request)\n    Cmdline responds with the running program's command line, with arguments\n    separated by NUL bytes. The package initialization registers it as\n    /debug/pprof/cmdline.\n\nfunc Handler(name string) http.Handler\n    Handler returns an HTTP handler that serves the named profile. Available\n    profiles can be found in runtime/pprof.Profile.\n\nfunc Index(w http.ResponseWriter, r *http.Request)\n    Index responds with the pprof-formatted profile named by the request.\n    For example, \"/debug/pprof/heap\" serves the \"heap\" profile. Index responds\n    to a request for \"/debug/pprof/\" with an HTML page listing the available\n    profiles.\n\nfunc Profile(w http.ResponseWriter, r *http.Request)\n    Profile responds with the pprof-formatted cpu profile. Profiling lasts\n    for duration specified in seconds GET parameter, or for 30 seconds if not\n    specified. The package initialization registers it as /debug/pprof/profile.\n\nfunc Symbol(w http.ResponseWriter, r *http.Request)\n    Symbol looks up the program counters listed in the request, responding\n    with a table mapping program counters to function names. The package\n    initialization registers it as /debug/pprof/symbol.\n\nfunc Trace(w http.ResponseWriter, r *http.Request)\n    Trace responds with the execution trace in binary form. Tracing lasts\n    for duration specified in seconds GET parameter, or for 1 second if not\n    specified. The package initialization registers it as /debug/pprof/trace.\n\n"}, {"path": "stdlib/cmp.md", "category": "stdlib", "name": "stdlib/cmp", "content": "package cmp // import \"cmp\"\n\nPackage cmp provides types and functions related to comparing ordered values.\n\nFUNCTIONS\n\nfunc Compare[T Ordered](x, y T) int\n    Compare returns\n\n        -1 if x is less than y,\n         0 if x equals y,\n        +1 if x is greater than y.\n\n    For floating-point types, a NaN is considered less than any non-NaN,\n    a NaN is considered equal to a NaN, and -0.0 is equal to 0.0.\n\nfunc Less[T Ordered](x, y T) bool\n    Less reports whether x is less than y. For floating-point types, a NaN is\n    considered less than any non-NaN, and -0.0 is not less than (is equal to)\n    0.0.\n\nfunc Or[T comparable](vals ...T) T\n    Or returns the first of its arguments that is not equal to the zero value.\n    If no argument is non-zero, it returns the zero value.\n\n\nTYPES\n\ntype Ordered interface {\n\t~int | ~int8 | ~int16 | ~int32 | ~int64 |\n\t\t~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |\n\t\t~float32 | ~float64 |\n\t\t~string\n}\n    Ordered is a constraint that permits any ordered type: any type that\n    supports the operators < <= >= >. If future releases of Go add new ordered\n    types, this constraint will be modified to include them.\n\n    Note that floating-point types may contain NaN (\"not-a-number\") values. An\n    operator such as == or < will always report false when comparing a NaN value\n    with any other value, NaN or not. See the Compare function for a consistent\n    way to compare NaN values.\n\n"}, {"path": "stdlib/crypto-internal-boring.md", "category": "stdlib", "name": "stdlib/crypto-internal-boring", "content": "package boring // import \"crypto/internal/boring\"\n\nPackage boring provides access to BoringCrypto implementation functions.\nCheck the constant Enabled to find out whether BoringCrypto is available.\nIf BoringCrypto is not available, the functions in this package all panic.\n\nCONSTANTS\n\nconst Enabled = available\n    Enabled reports whether BoringCrypto is available. When enabled is false,\n    all functions in this package panic.\n\n    BoringCrypto is only available on linux/amd64 and linux/arm64 systems.\n\nconst RandReader = randReader(0)\n\nFUNCTIONS\n\nfunc DecryptRSANoPadding(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error)\nfunc DecryptRSAOAEP(h, mgfHash hash.Hash, priv *PrivateKeyRSA, ciphertext, label []byte) ([]byte, error)\nfunc DecryptRSAPKCS1(priv *PrivateKeyRSA, ciphertext []byte) ([]byte, error)\nfunc ECDH(*PrivateKeyECDH, *PublicKeyECDH) ([]byte, error)\nfunc EncryptRSANoPadding(pub *PublicKeyRSA, msg []byte) ([]byte, error)\nfunc EncryptRSAOAEP(h, mgfHash hash.Hash, pub *PublicKeyRSA, msg, label []byte) ([]byte, error)\nfunc EncryptRSAPKCS1(pub *PublicKeyRSA, msg []byte) ([]byte, error)\nfunc NewAESCipher(key []byte) (cipher.Block, error)\nfunc NewGCMTLS(cipher.Block) (cipher.AEAD, error)\nfunc NewGCMTLS13(cipher.Block) (cipher.AEAD, error)\nfunc NewHMAC(h func() hash.Hash, key []byte) hash.Hash\nfunc NewSHA1() hash.Hash\nfunc NewSHA224() hash.Hash\nfunc NewSHA256() hash.Hash\nfunc NewSHA384() hash.Hash\nfunc NewSHA512() hash.Hash\nfunc SHA1([]byte) [20]byte\nfunc SHA224([]byte) [28]byte\nfunc SHA256([]byte) [32]byte\nfunc SHA384([]byte) [48]byte\nfunc SHA512([]byte) [64]byte\nfunc SignMarshalECDSA(priv *PrivateKeyECDSA, hash []byte) ([]byte, error)\nfunc SignRSAPKCS1v15(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte) ([]byte, error)\nfunc SignRSAPSS(priv *PrivateKeyRSA, h crypto.Hash, hashed []byte, saltLen int) ([]byte, error)\nfunc Unreachable()\n    Unreachable marks code that should be unreachable when BoringCrypto is in\n    use. It is a no-op without BoringCrypto.\n\nfunc UnreachableExceptTests()\n    UnreachableExceptTests marks code that should be unreachable when\n    BoringCrypto is in use. It is a no-op without BoringCrypto.\n\nfunc VerifyECDSA(pub *PublicKeyECDSA, hash []byte, sig []byte) bool\nfunc VerifyRSAPKCS1v15(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte) error\nfunc VerifyRSAPSS(pub *PublicKeyRSA, h crypto.Hash, hashed, sig []byte, saltLen int) error\n\nTYPES\n\ntype BigInt []uint\n    A BigInt is the raw words from a BigInt. This definition allows us to\n    avoid importing math/big. Conversion between BigInt and *big.Int is in\n    crypto/internal/boring/bbig.\n\nfunc GenerateKeyECDSA(curve string) (X, Y, D BigInt, err error)\n\nfunc GenerateKeyRSA(bits int) (N, E, D, P, Q, Dp, Dq, Qinv BigInt, err error)\n\ntype PrivateKeyECDH struct{}\n\nfunc GenerateKeyECDH(string) (*PrivateKeyECDH, []byte, error)\n\nfunc NewPrivateKeyECDH(string, []byte) (*PrivateKeyECDH, error)\n\nfunc (*PrivateKeyECDH) PublicKey() (*PublicKeyECDH, error)\n\ntype PrivateKeyECDSA struct {\n\t// Has unexported fields.\n}\n\nfunc NewPrivateKeyECDSA(curve string, X, Y, D BigInt) (*PrivateKeyECDSA, error)\n\ntype PrivateKeyRSA struct {\n\t// Has unexported fields.\n}\n\nfunc NewPrivateKeyRSA(N, E, D, P, Q, Dp, Dq, Qinv BigInt) (*PrivateKeyRSA, error)\n\ntype PublicKeyECDH struct{}\n\nfunc NewPublicKeyECDH(string, []byte) (*PublicKeyECDH, error)\n\nfunc (*PublicKeyECDH) Bytes() []byte\n\ntype PublicKeyECDSA struct {\n\t// Has unexported fields.\n}\n\nfunc NewPublicKeyECDSA(curve string, X, Y BigInt) (*PublicKeyECDSA, error)\n\ntype PublicKeyRSA struct {\n\t// Has unexported fields.\n}\n\nfunc NewPublicKeyRSA(N, E BigInt) (*PublicKeyRSA, error)\n\n"}, {"path": "stdlib/crypto-dsa.md", "category": "stdlib", "name": "stdlib/crypto-dsa", "content": "package dsa // import \"crypto/dsa\"\n\nPackage dsa implements the Digital Signature Algorithm, as defined in FIPS\n186-3.\n\nThe DSA operations in this package are not implemented using constant-time\nalgorithms.\n\nDeprecated: DSA is a legacy algorithm, and modern alternatives such as Ed25519\n(implemented by package crypto/ed25519) should be used instead. Keys with\n1024-bit moduli (L1024N160 parameters) are cryptographically weak, while bigger\nkeys are not widely supported. Note that FIPS 186-5 no longer approves DSA for\nsignature generation.\n\nVARIABLES\n\nvar ErrInvalidPublicKey = errors.New(\"crypto/dsa: invalid public key\")\n    ErrInvalidPublicKey results when a public key is not usable by this code.\n    FIPS is quite strict about the format of DSA keys, but other code may be\n    less so. Thus, when using keys which may have been generated by other code,\n    this error must be handled.\n\n\nFUNCTIONS\n\nfunc GenerateKey(priv *PrivateKey, rand io.Reader) error\n    GenerateKey generates a public&private key pair. The Parameters of the\n    PrivateKey must already be valid (see GenerateParameters).\n\nfunc GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes) error\n    GenerateParameters puts a random, valid set of DSA parameters into params.\n    This function can take many seconds, even on fast machines.\n\nfunc Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)\n    Sign signs an arbitrary length hash (which should be the result of hashing\n    a larger message) using the private key, priv. It returns the signature as a\n    pair of integers. The security of the private key depends on the entropy of\n    rand.\n\n    Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated\n    to the byte-length of the subgroup. This function does not perform that\n    truncation itself.\n\n    Be aware that calling Sign with an attacker-controlled PrivateKey may\n    require an arbitrary amount of CPU.\n\nfunc Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool\n    Verify verifies the signature in r, s of hash using the public key, pub.\n    It reports whether the signature is valid.\n\n    Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated\n    to the byte-length of the subgroup. This function does not perform that\n    truncation itself.\n\n\nTYPES\n\ntype ParameterSizes int\n    ParameterSizes is an enumeration of the acceptable bit lengths of the primes\n    in a set of DSA parameters. See FIPS 186-3, section 4.2.\n\nconst (\n\tL1024N160 ParameterSizes = iota\n\tL2048N224\n\tL2048N256\n\tL3072N256\n)\ntype Parameters struct {\n\tP, Q, G *big.Int\n}\n    Parameters represents the domain parameters for a key. These parameters can\n    be shared across many keys. The bit length of Q must be a multiple of 8.\n\ntype PrivateKey struct {\n\tPublicKey\n\tX *big.Int\n}\n    PrivateKey represents a DSA private key.\n\ntype PublicKey struct {\n\tParameters\n\tY *big.Int\n}\n    PublicKey represents a DSA public key.\n\n"}, {"path": "stdlib/vendor-golang.org-x-net-dns-dnsmessage.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-net-dns-dnsmessage", "content": ""}, {"path": "stdlib/internal-race.md", "category": "stdlib", "name": "stdlib/internal-race", "content": "package race // import \"internal/race\"\n\nPackage race contains helper functions for manually instrumenting code for the\nrace detector.\n\nThe runtime package intentionally exports these functions only in the race\nbuild; this package exports them unconditionally but without the \"race\" build\ntag they are no-ops.\n\nCONSTANTS\n\nconst Enabled = false\n\nFUNCTIONS\n\nfunc Acquire(addr unsafe.Pointer)\nfunc Disable()\nfunc Enable()\nfunc Errors() int\nfunc Read(addr unsafe.Pointer)\nfunc ReadObjectPC(t *abi.Type, addr unsafe.Pointer, callerpc, pc uintptr)\nfunc ReadPC(addr unsafe.Pointer, callerpc, pc uintptr)\nfunc ReadRange(addr unsafe.Pointer, len int)\nfunc Release(addr unsafe.Pointer)\nfunc ReleaseMerge(addr unsafe.Pointer)\nfunc Write(addr unsafe.Pointer)\nfunc WriteObjectPC(t *abi.Type, addr unsafe.Pointer, callerpc, pc uintptr)\nfunc WritePC(addr unsafe.Pointer, callerpc, pc uintptr)\nfunc WriteRange(addr unsafe.Pointer, len int)\n"}, {"path": "stdlib/reflect-internal-example1.md", "category": "stdlib", "name": "stdlib/reflect-internal-example1", "content": "package example1 // import \"reflect/internal/example1\"\n\n\nTYPES\n\ntype MyStruct struct {\n\tMyStructs []MyStruct\n\tMyStruct  *MyStruct\n}\n\n"}, {"path": "stdlib/vendor-golang.org-x-crypto-chacha20.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-crypto-chacha20", "content": ""}, {"path": "stdlib/unicode-utf8.md", "category": "stdlib", "name": "stdlib/unicode-utf8", "content": "package utf8 // import \"unicode/utf8\"\n\nPackage utf8 implements functions and constants to support text encoded\nin UTF-8. It includes functions to translate between runes and UTF-8 byte\nsequences. See https://en.wikipedia.org/wiki/UTF-8\n\nCONSTANTS\n\nconst (\n\tRuneError = '\\uFFFD'     // the \"error\" Rune or \"Unicode replacement character\"\n\tRuneSelf  = 0x80         // characters below RuneSelf are represented as themselves in a single byte.\n\tMaxRune   = '\\U0010FFFF' // Maximum valid Unicode code point.\n\tUTFMax    = 4            // maximum number of bytes of a UTF-8 encoded Unicode character.\n)\n    Numbers fundamental to the encoding.\n\n\nFUNCTIONS\n\nfunc AppendRune(p []byte, r rune) []byte\n    AppendRune appends the UTF-8 encoding of r to the end of p and returns the\n    extended buffer. If the rune is out of range, it appends the encoding of\n    RuneError.\n\nfunc DecodeLastRune(p []byte) (r rune, size int)\n    DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune\n    and its width in bytes. If p is empty it returns (RuneError, 0). Otherwise,\n    if the encoding is invalid, it returns (RuneError, 1). Both are impossible\n    results for correct, non-empty UTF-8.\n\n    An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out\n    of range, or is not the shortest possible UTF-8 encoding for the value.\n    No other validation is performed.\n\nfunc DecodeLastRuneInString(s string) (r rune, size int)\n    DecodeLastRuneInString is like DecodeLastRune but its input is a string.\n    If s is empty it returns (RuneError, 0). Otherwise, if the encoding is\n    invalid, it returns (RuneError, 1). Both are impossible results for correct,\n    non-empty UTF-8.\n\n    An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out\n    of range, or is not the shortest possible UTF-8 encoding for the value.\n    No other validation is performed.\n\nfunc DecodeRune(p []byte) (r rune, size int)\n    DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and\n    its width in bytes. If p is empty it returns (RuneError, 0). Otherwise,\n    if the encoding is invalid, it returns (RuneError, 1). Both are impossible\n    results for correct, non-empty UTF-8.\n\n    An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out\n    of range, or is not the shortest possible UTF-8 encoding for the value.\n    No other validation is performed.\n\nfunc DecodeRuneInString(s string) (r rune, size int)\n    DecodeRuneInString is like DecodeRune but its input is a string. If s is\n    empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,\n    it returns (RuneError, 1). Both are impossible results for correct,\n    non-empty UTF-8.\n\n    An encoding is invalid if it is incorrect UTF-8, encodes a rune that is out\n    of range, or is not the shortest possible UTF-8 encoding for the value.\n    No other validation is performed.\n\nfunc EncodeRune(p []byte, r rune) int\n    EncodeRune writes into p (which must be large enough) the UTF-8 encoding of\n    the rune. If the rune is out of range, it writes the encoding of RuneError.\n    It returns the number of bytes written.\n\nfunc FullRune(p []byte) bool\n    FullRune reports whether the bytes in p begin with a full UTF-8 encoding of\n    a rune. An invalid encoding is considered a full Rune since it will convert\n    as a width-1 error rune.\n\nfunc FullRuneInString(s string) bool\n    FullRuneInString is like FullRune but its input is a string.\n\nfunc RuneCount(p []byte) int\n    RuneCount returns the number of runes in p. Erroneous and short encodings\n    are treated as single runes of width 1 byte.\n\nfunc RuneCountInString(s string) (n int)\n    RuneCountInString is like RuneCount but its input is a string.\n\nfunc RuneLen(r rune) int\n    RuneLen returns the number of bytes in the UTF-8 encoding of the rune.\n    It returns -1 if the rune is not a valid value to encode in UTF-8.\n\nfunc RuneStart(b byte) bool\n    RuneStart reports whether the byte could be the first byte of an encoded,\n    possibly invalid rune. Second and subsequent bytes always have the top two\n    bits set to 10.\n\nfunc Valid(p []byte) bool\n    Valid reports whether p consists entirely of valid UTF-8-encoded runes.\n\nfunc ValidRune(r rune) bool\n    ValidRune reports whether r can be legally encoded as UTF-8. Code points\n    that are out of range or a surrogate half are illegal.\n\nfunc ValidString(s string) bool\n    ValidString reports whether s consists entirely of valid UTF-8-encoded\n    runes.\n\n"}, {"path": "stdlib/internal-copyright.md", "category": "stdlib", "name": "stdlib/internal-copyright", "content": ""}, {"path": "stdlib/testing-fstest.md", "category": "stdlib", "name": "stdlib/testing-fstest", "content": "package fstest // import \"testing/fstest\"\n\nPackage fstest implements support for testing implementations and users of file\nsystems.\n\nFUNCTIONS\n\nfunc TestFS(fsys fs.FS, expected ...string) error\n    TestFS tests a file system implementation. It walks the entire tree of\n    files in fsys, opening and checking that each file behaves correctly.\n    Symbolic links are not followed, but their Lstat values are checked if the\n    file system implements fs.ReadLinkFS. It also checks that the file system\n    contains at least the expected files. As a special case, if no expected\n    files are listed, fsys must be empty. Otherwise, fsys must contain at least\n    the listed files; it can also contain others. The contents of fsys must not\n    change concurrently with TestFS.\n\n    If TestFS finds any misbehaviors, it returns either the first error or a\n    list of errors. Use errors.Is or errors.As to inspect.\n\n    Typical usage inside a test is:\n\n        if err := fstest.TestFS(myFS, \"file/that/should/be/present\"); err != nil {\n        \tt.Fatal(err)\n        }\n\n\nTYPES\n\ntype MapFS map[string]*MapFile\n    A MapFS is a simple in-memory file system for use in tests, represented as\n    a map from path names (arguments to Open) to information about the files,\n    directories, or symbolic links they represent.\n\n    The map need not include parent directories for files contained in the map;\n    those will be synthesized if needed. But a directory can still be included\n    by setting the [MapFile.Mode]'s fs.ModeDir bit; this may be necessary for\n    detailed control over the directory's fs.FileInfo or to create an empty\n    directory.\n\n    File system operations read directly from the map, so that the file system\n    can be changed by editing the map as needed. An implication is that file\n    system operations must not run concurrently with changes to the map, which\n    would be a race. Another implication is that opening or reading a directory\n    requires iterating over the entire map, so a MapFS should typically be used\n    with not more than a few hundred entries or directory reads.\n\nfunc (fsys MapFS) Glob(pattern string) ([]string, error)\n\nfunc (fsys MapFS) Lstat(name string) (fs.FileInfo, error)\n    Lstat returns a FileInfo describing the named file. If the file is a\n    symbolic link, the returned FileInfo describes the symbolic link. Lstat\n    makes no attempt to follow the link.\n\nfunc (fsys MapFS) Open(name string) (fs.File, error)\n    Open opens the named file after following any symbolic links.\n\nfunc (fsys MapFS) ReadDir(name string) ([]fs.DirEntry, error)\n\nfunc (fsys MapFS) ReadFile(name string) ([]byte, error)\n\nfunc (fsys MapFS) ReadLink(name string) (string, error)\n    ReadLink returns the destination of the named symbolic link.\n\nfunc (fsys MapFS) Stat(name string) (fs.FileInfo, error)\n\nfunc (fsys MapFS) Sub(dir string) (fs.FS, error)\n\ntype MapFile struct {\n\tData    []byte      // file content or symlink destination\n\tMode    fs.FileMode // fs.FileInfo.Mode\n\tModTime time.Time   // fs.FileInfo.ModTime\n\tSys     any         // fs.FileInfo.Sys\n}\n    A MapFile describes a single file in a MapFS.\n\n"}, {"path": "stdlib/internal-coverage-cformat.md", "category": "stdlib", "name": "stdlib/internal-coverage-cformat", "content": "package cformat // import \"internal/coverage/cformat\"\n\n\nTYPES\n\ntype Formatter struct {\n\t// Has unexported fields.\n}\n\nfunc NewFormatter(cm coverage.CounterMode) *Formatter\n\nfunc (fm *Formatter) AddUnit(file string, fname string, isfnlit bool, unit coverage.CoverableUnit, count uint32)\n    AddUnit passes info on a single coverable unit (file, funcname, literal\n    flag, range of lines, and counter value) to the formatter. Counter values\n    will be accumulated where appropriate.\n\nfunc (fm *Formatter) EmitFuncs(w io.Writer) error\n    EmitFuncs writes out a function-level summary to the writer 'w'. A note on\n    handling function literals: although we collect coverage data for unnamed\n    literals, it probably does not make sense to include them in the function\n    summary since there isn't any good way to name them (this is also consistent\n    with the legacy cmd/cover implementation). We do want to include their\n    counts in the overall summary however.\n\nfunc (fm *Formatter) EmitPercent(w io.Writer, pkgs []string, inpkgs string, noteEmpty bool, aggregate bool) error\n    EmitPercent writes out a \"percentage covered\" string to the writer 'w',\n    selecting the set of packages in 'pkgs' and suffixing the printed string\n    with 'inpkgs'.\n\nfunc (fm *Formatter) EmitTextual(pkgs []string, w io.Writer) error\n    EmitTextual writes the accumulated coverage data for 'pkgs' in the\n    legacy cmd/cover text format to the writer 'w'; if pkgs is empty,\n    text output is emitted for all packages recorded. We sort the data items\n    by importpath, source file, and line number before emitting (this sorting\n    is not explicitly mandated by the format, but seems like a good idea for\n    repeatable/deterministic dumps).\n\nfunc (fm *Formatter) SetPackage(importpath string)\n    SetPackage tells the formatter that we're about to visit the coverage data\n    for the package with the specified import path. Note that it's OK to call\n    SetPackage more than once with the same import path; counter data values\n    will be accumulated.\n\n"}, {"path": "stdlib/log-internal.md", "category": "stdlib", "name": "stdlib/log-internal", "content": "package internal // import \"log/internal\"\n\nPackage internal contains definitions used by both log and log/slog.\n\nVARIABLES\n\nvar DefaultOutput func(pc uintptr, data []byte) error\n    DefaultOutput holds a function which calls the default log.Logger's output\n    function. It allows slog.defaultHandler to call into an unexported function\n    of the log package.\n\n"}, {"path": "stdlib/bufio.md", "category": "stdlib", "name": "stdlib/bufio", "content": "package bufio // import \"bufio\"\n\nPackage bufio implements buffered I/O. It wraps an io.Reader or io.Writer\nobject, creating another object (Reader or Writer) that also implements the\ninterface but provides buffering and some help for textual I/O.\n\nCONSTANTS\n\nconst (\n\t// MaxScanTokenSize is the maximum size used to buffer a token\n\t// unless the user provides an explicit buffer with [Scanner.Buffer].\n\t// The actual maximum token size may be smaller as the buffer\n\t// may need to include, for instance, a newline.\n\tMaxScanTokenSize = 64 * 1024\n)\n\nVARIABLES\n\nvar (\n\tErrInvalidUnreadByte = errors.New(\"bufio: invalid use of UnreadByte\")\n\tErrInvalidUnreadRune = errors.New(\"bufio: invalid use of UnreadRune\")\n\tErrBufferFull        = errors.New(\"bufio: buffer full\")\n\tErrNegativeCount     = errors.New(\"bufio: negative count\")\n)\nvar (\n\tErrTooLong         = errors.New(\"bufio.Scanner: token too long\")\n\tErrNegativeAdvance = errors.New(\"bufio.Scanner: SplitFunc returns negative advance count\")\n\tErrAdvanceTooFar   = errors.New(\"bufio.Scanner: SplitFunc returns advance count beyond input\")\n\tErrBadReadCount    = errors.New(\"bufio.Scanner: Read returned impossible count\")\n)\n    Errors returned by Scanner.\n\nvar ErrFinalToken = errors.New(\"final token\")\n    ErrFinalToken is a special sentinel error value. It is intended to be\n    returned by a Split function to indicate that the scanning should stop\n    with no error. If the token being delivered with this error is not nil,\n    the token is the last token.\n\n    The value is useful to stop processing early or when it is necessary to\n    deliver a final empty token (which is different from a nil token). One could\n    achieve the same behavior with a custom error value but providing one here\n    is tidier. See the emptyFinalToken example for a use of this value.\n\n\nFUNCTIONS\n\nfunc ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)\n    ScanBytes is a split function for a Scanner that returns each byte as a\n    token.\n\nfunc ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)\n    ScanLines is a split function for a Scanner that returns each line of text,\n    stripped of any trailing end-of-line marker. The returned line may be empty.\n    The end-of-line marker is one optional carriage return followed by one\n    mandatory newline. In regular expression notation, it is `\\r?\\n`. The last\n    non-empty line of input will be returned even if it has no newline.\n\nfunc ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)\n    ScanRunes is a split function for a Scanner that returns each UTF-8-encoded\n    rune as a token. The sequence of runes returned is equivalent to that\n    from a range loop over the input as a string, which means that erroneous\n    UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\". Because of the Scan\n    interface, this makes it impossible for the client to distinguish correctly\n    encoded replacement runes from encoding errors.\n\nfunc ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)\n    ScanWords is a split function for a Scanner that returns each\n    space-separated word of text, with surrounding spaces deleted. It will never\n    return an empty string. The definition of space is set by unicode.IsSpace.\n\n\nTYPES\n\ntype ReadWriter struct {\n\t*Reader\n\t*Writer\n}\n    ReadWriter stores pointers to a Reader and a Writer. It implements\n    io.ReadWriter.\n\nfunc NewReadWriter(r *Reader, w *Writer) *ReadWriter\n    NewReadWriter allocates a new ReadWriter that dispatches to r and w.\n\ntype Reader struct {\n\t// Has unexported fields.\n}\n    Reader implements buffering for an io.Reader object. A new Reader is created\n    by calling NewReader or NewReaderSize; alternatively the zero value of a\n    Reader may be used after calling [Reset] on it.\n\nfunc NewReader(rd io.Reader) *Reader\n    NewReader returns a new Reader whose buffer has the default size.\n\nfunc NewReaderSize(rd io.Reader, size int) *Reader\n    NewReaderSize returns a new Reader whose buffer has at least the specified\n    size. If the argument io.Reader is already a Reader with large enough size,\n    it returns the underlying Reader.\n\nfunc (b *Reader) Buffered() int\n    Buffered returns the number of bytes that can be read from the current\n    buffer.\n\nfunc (b *Reader) Discard(n int) (discarded int, err error)\n    Discard skips the next n bytes, returning the number of bytes discarded.\n\n    If Discard skips fewer than n bytes, it also returns an error. If 0 <= n\n    <= b.Buffered(), Discard is guaranteed to succeed without reading from the\n    underlying io.Reader.\n\nfunc (b *Reader) Peek(n int) ([]byte, error)\n    Peek returns the next n bytes without advancing the reader. The bytes stop\n    being valid at the next read call. If necessary, Peek will read more bytes\n    into the buffer in order to make n bytes available. If Peek returns fewer\n    than n bytes, it also returns an error explaining why the read is short.\n    The error is ErrBufferFull if n is larger than b's buffer size.\n\n    Calling Peek prevents a Reader.UnreadByte or Reader.UnreadRune call from\n    succeeding until the next read operation.\n\nfunc (b *Reader) Read(p []byte) (n int, err error)\n    Read reads data into p. It returns the number of bytes read into p.\n    The bytes are taken from at most one Read on the underlying Reader, hence n\n    may be less than len(p). To read exactly len(p) bytes, use io.ReadFull(b,\n    p). If the underlying Reader can return a non-zero count with io.EOF,\n    then this Read method can do so as well; see the io.Reader docs.\n\nfunc (b *Reader) ReadByte() (byte, error)\n    ReadByte reads and returns a single byte. If no byte is available, returns\n    an error.\n\nfunc (b *Reader) ReadBytes(delim byte) ([]byte, error)\n    ReadBytes reads until the first occurrence of delim in the input,\n    returning a slice containing the data up to and including the delimiter.\n    If ReadBytes encounters an error before finding a delimiter, it returns the\n    data read before the error and the error itself (often io.EOF). ReadBytes\n    returns err != nil if and only if the returned data does not end in delim.\n    For simple uses, a Scanner may be more convenient.\n\nfunc (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)\n    ReadLine is a low-level line-reading primitive. Most callers should use\n    Reader.ReadBytes('\\n') or Reader.ReadString('\\n') instead or use a Scanner.\n\n    ReadLine tries to return a single line, not including the end-of-line bytes.\n    If the line was too long for the buffer then isPrefix is set and the\n    beginning of the line is returned. The rest of the line will be returned\n    from future calls. isPrefix will be false when returning the last fragment\n    of the line. The returned buffer is only valid until the next call to\n    ReadLine. ReadLine either returns a non-nil line or it returns an error,\n    never both.\n\n    The text returned from ReadLine does not include the line end (\"\\r\\n\" or\n    \"\\n\"). No indication or error is given if the input ends without a final\n    line end. Calling Reader.UnreadByte after ReadLine will always unread the\n    last byte read (possibly a character belonging to the line end) even if that\n    byte is not part of the line returned by ReadLine.\n\nfunc (b *Reader) ReadRune() (r rune, size int, err error)\n    ReadRune reads a single UTF-8 encoded Unicode character and returns the rune\n    and its size in bytes. If the encoded rune is invalid, it consumes one byte\n    and returns unicode.ReplacementChar (U+FFFD) with a size of 1.\n\nfunc (b *Reader) ReadSlice(delim byte) (line []byte, err error)\n    ReadSlice reads until the first occurrence of delim in the input, returning\n    a slice pointing at the bytes in the buffer. The bytes stop being valid at\n    the next read. If ReadSlice encounters an error before finding a delimiter,\n    it returns all the data in the buffer and the error itself (often io.EOF).\n    ReadSlice fails with error ErrBufferFull if the buffer fills without a\n    delim. Because the data returned from ReadSlice will be overwritten by the\n    next I/O operation, most clients should use Reader.ReadBytes or ReadString\n    instead. ReadSlice returns err != nil if and only if line does not end in\n    delim.\n\nfunc (b *Reader) ReadString(delim byte) (string, error)\n    ReadString reads until the first occurrence of delim in the input,\n    returning a string containing the data up to and including the delimiter.\n    If ReadString encounters an error before finding a delimiter, it returns the\n    data read before the error and the error itself (often io.EOF). ReadString\n    returns err != nil if and only if the returned data does not end in delim.\n    For simple uses, a Scanner may be more convenient.\n\nfunc (b *Reader) Reset(r io.Reader)\n    Reset discards any buffered data, resets all state, and switches the\n    buffered reader to read from r. Calling Reset on the zero value of Reader\n    initializes the internal buffer to the default size. Calling b.Reset(b)\n    (that is, resetting a Reader to itself) does nothing.\n\nfunc (b *Reader) Size() int\n    Size returns the size of the underlying buffer in bytes.\n\nfunc (b *Reader) UnreadByte() error\n    UnreadByte unreads the last byte. Only the most recently read byte can be\n    unread.\n\n    UnreadByte returns an error if the most recent method called on the\n    Reader was not a read operation. Notably, Reader.Peek, Reader.Discard,\n    and Reader.WriteTo are not considered read operations.\n\nfunc (b *Reader) UnreadRune() error\n    UnreadRune unreads the last rune. If the most recent method called on the\n    Reader was not a Reader.ReadRune, Reader.UnreadRune returns an error.\n    (In this regard it is stricter than Reader.UnreadByte, which will unread the\n    last byte from any read operation.)\n\nfunc (b *Reader) WriteTo(w io.Writer) (n int64, err error)\n    WriteTo implements io.WriterTo. This may make multiple calls to the\n    Reader.Read method of the underlying Reader. If the underlying reader\n    supports the Reader.WriteTo method, this calls the underlying Reader.WriteTo\n    without buffering.\n\ntype Scanner struct {\n\t// Has unexported fields.\n}\n    Scanner provides a convenient interface for reading data such as a file\n    of newline-delimited lines of text. Successive calls to the Scanner.Scan\n    method will step through the 'tokens' of a file, skipping the bytes between\n    the tokens. The specification of a token is defined by a split function\n    of type SplitFunc; the default split function breaks the input into lines\n    with line termination stripped. Scanner.Split functions are defined in\n    this package for scanning a file into lines, bytes, UTF-8-encoded runes,\n    and space-delimited words. The client may instead provide a custom split\n    function.\n\n    Scanning stops unrecoverably at EOF, the first I/O error, or a token too\n    large to fit in the Scanner.Buffer. When a scan stops, the reader may\n    have advanced arbitrarily far past the last token. Programs that need more\n    control over error handling or large tokens, or must run sequential scans on\n    a reader, should use bufio.Reader instead.\n\nfunc NewScanner(r io.Reader) *Scanner\n    NewScanner returns a new Scanner to read from r. The split function defaults\n    to ScanLines.\n\nfunc (s *Scanner) Buffer(buf []byte, max int)\n    Buffer controls memory allocation by the Scanner. It sets the initial buffer\n    to use when scanning and the maximum size of buffer that may be allocated\n    during scanning. The contents of the buffer are ignored.\n\n    The maximum token size must be less than the larger of max and cap(buf).\n    If max <= cap(buf), Scanner.Scan will use this buffer only and do no\n    allocation.\n\n    By default, Scanner.Scan uses an internal buffer and sets the maximum token\n    size to MaxScanTokenSize.\n\n    Buffer panics if it is called after scanning has started.\n\nfunc (s *Scanner) Bytes() []byte\n    Bytes returns the most recent token generated by a call to Scanner.Scan. The\n    underlying array may point to data that will be overwritten by a subsequent\n    call to Scan. It does no allocation.\n\nfunc (s *Scanner) Err() error\n    Err returns the first non-EOF error that was encountered by the Scanner.\n\nfunc (s *Scanner) Scan() bool\n    Scan advances the Scanner to the next token, which will then be available\n    through the Scanner.Bytes or Scanner.Text method. It returns false when\n    there are no more tokens, either by reaching the end of the input or\n    an error. After Scan returns false, the Scanner.Err method will return\n    any error that occurred during scanning, except that if it was io.EOF,\n    Scanner.Err will return nil. Scan panics if the split function returns too\n    many empty tokens without advancing the input. This is a common error mode\n    for scanners.\n\nfunc (s *Scanner) Split(split SplitFunc)\n    Split sets the split function for the Scanner. The default split function is\n    ScanLines.\n\n    Split panics if it is called after scanning has started.\n\nfunc (s *Scanner) Text() string\n    Text returns the most recent token generated by a call to Scanner.Scan as a\n    newly allocated string holding its bytes.\n\ntype SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)\n    SplitFunc is the signature of the split function used to tokenize the input.\n    The arguments are an initial substring of the remaining unprocessed data and\n    a flag, atEOF, that reports whether the Reader has no more data to give.\n    The return values are the number of bytes to advance the input and the next\n    token to return to the user, if any, plus an error, if any.\n\n    Scanning stops if the function returns an error, in which case some of the\n    input may be discarded. If that error is ErrFinalToken, scanning stops with\n    no error. A non-nil token delivered with ErrFinalToken will be the last\n    token, and a nil token with ErrFinalToken immediately stops the scanning.\n\n    Otherwise, the Scanner advances the input. If the token is not nil,\n    the Scanner returns it to the user. If the token is nil, the Scanner reads\n    more data and continues scanning; if there is no more data--if atEOF was\n    true--the Scanner returns. If the data does not yet hold a complete token,\n    for instance if it has no newline while scanning lines, a SplitFunc can\n    return (0, nil, nil) to signal the Scanner to read more data into the slice\n    and try again with a longer slice starting at the same point in the input.\n\n    The function is never called with an empty data slice unless atEOF is true.\n    If atEOF is true, however, data may be non-empty and, as always, holds\n    unprocessed text.\n\ntype Writer struct {\n\t// Has unexported fields.\n}\n    Writer implements buffering for an io.Writer object. If an error occurs\n    writing to a Writer, no more data will be accepted and all subsequent\n    writes, and Writer.Flush, will return the error. After all data has been\n    written, the client should call the Writer.Flush method to guarantee all\n    data has been forwarded to the underlying io.Writer.\n\nfunc NewWriter(w io.Writer) *Writer\n    NewWriter returns a new Writer whose buffer has the default size.\n    If the argument io.Writer is already a Writer with large enough buffer size,\n    it returns the underlying Writer.\n\nfunc NewWriterSize(w io.Writer, size int) *Writer\n    NewWriterSize returns a new Writer whose buffer has at least the specified\n    size. If the argument io.Writer is already a Writer with large enough size,\n    it returns the underlying Writer.\n\nfunc (b *Writer) Available() int\n    Available returns how many bytes are unused in the buffer.\n\nfunc (b *Writer) AvailableBuffer() []byte\n    AvailableBuffer returns an empty buffer with b.Available() capacity. This\n    buffer is intended to be appended to and passed to an immediately succeeding\n    Writer.Write call. The buffer is only valid until the next write operation\n    on b.\n\nfunc (b *Writer) Buffered() int\n    Buffered returns the number of bytes that have been written into the current\n    buffer.\n\nfunc (b *Writer) Flush() error\n    Flush writes any buffered data to the underlying io.Writer.\n\nfunc (b *Writer) ReadFrom(r io.Reader) (n int64, err error)\n    ReadFrom implements io.ReaderFrom. If the underlying writer supports the\n    ReadFrom method, this calls the underlying ReadFrom. If there is buffered\n    data and an underlying ReadFrom, this fills the buffer and writes it before\n    calling ReadFrom.\n\nfunc (b *Writer) Reset(w io.Writer)\n    Reset discards any unflushed buffered data, clears any error, and resets\n    b to write its output to w. Calling Reset on the zero value of Writer\n    initializes the internal buffer to the default size. Calling w.Reset(w)\n    (that is, resetting a Writer to itself) does nothing.\n\nfunc (b *Writer) Size() int\n    Size returns the size of the underlying buffer in bytes.\n\nfunc (b *Writer) Write(p []byte) (nn int, err error)\n    Write writes the contents of p into the buffer. It returns the number of\n    bytes written. If nn < len(p), it also returns an error explaining why the\n    write is short.\n\nfunc (b *Writer) WriteByte(c byte) error\n    WriteByte writes a single byte.\n\nfunc (b *Writer) WriteRune(r rune) (size int, err error)\n    WriteRune writes a single Unicode code point, returning the number of bytes\n    written and any error.\n\nfunc (b *Writer) WriteString(s string) (int, error)\n    WriteString writes a string. It returns the number of bytes written. If the\n    count is less than len(s), it also returns an error explaining why the write\n    is short.\n\n"}, {"path": "stdlib/internal-trace.md", "category": "stdlib", "name": "stdlib/internal-trace", "content": "package trace // import \"internal/trace\"\n\n\nCONSTANTS\n\nconst (\n\t// NoTask indicates the lack of a task.\n\tNoTask = TaskID(^uint64(0))\n\n\t// BackgroundTask is the global task that events are attached to if there was\n\t// no other task in the context at the point the event was emitted.\n\tBackgroundTask = TaskID(0)\n)\nconst NoGoroutine = GoID(-1)\n    NoGoroutine indicates that the relevant events don't correspond to any\n    goroutine in particular.\n\nconst NoProc = ProcID(-1)\n    NoProc indicates that the relevant events don't correspond to any P in\n    particular.\n\nconst NoThread = ThreadID(-1)\n    NoThread indicates that the relevant events don't correspond to any thread\n    in particular.\n\n\nVARIABLES\n\nvar NoStack = Stack{}\n    NoStack is a sentinel value that can be compared against any Stack value,\n    indicating a lack of a stack trace.\n\n\nFUNCTIONS\n\nfunc IsSystemGoroutine(entryFn string) bool\nfunc MutatorUtilizationV2(events []Event, flags UtilFlags) [][]MutatorUtil\n    MutatorUtilizationV2 returns a set of mutator utilization functions for the\n    given v2 trace, passed as an io.Reader. Each function will always end with 0\n    utilization. The bounds of each function are implicit in the first and last\n    event; outside of these bounds each function is undefined.\n\n    If the UtilPerProc flag is not given, this always returns a single\n    utilization function. Otherwise, it returns one function per P.\n\nfunc RelatedGoroutinesV2(events []Event, goid GoID) map[GoID]struct{}\n    RelatedGoroutinesV2 finds a set of goroutines related to goroutine goid for\n    v2 traces. The association is based on whether they have synchronized with\n    each other in the Go scheduler (one has unblocked another).\n\n\nTYPES\n\ntype ClockSnapshot struct {\n\t// Trace is a snapshot of the trace clock.\n\tTrace Time\n\n\t// Wall is a snapshot of the system's wall clock.\n\tWall time.Time\n\n\t// Mono is a snapshot of the system's monotonic clock.\n\tMono uint64\n}\n    ClockSnapshot represents a near-simultaneous clock reading of several\n    different system clocks. The snapshot can be used as a reference to convert\n    timestamps to different clocks, which is helpful for correlating timestamps\n    with data captured by other tools.\n\ntype Event struct {\n\t// Has unexported fields.\n}\n    Event represents a single event in the trace.\n\nfunc (e Event) Experimental() ExperimentalEvent\n    Experimental returns a view of the raw event for an experimental event.\n\n    Panics if Kind != EventExperimental.\n\nfunc (e Event) Goroutine() GoID\n    Goroutine returns the ID of the goroutine that was executing when this event\n    happened. It describes part of the execution context for this event.\n\n    Note that for goroutine state transitions this always refers to the state\n    before the transition. For example, if a goroutine is just starting\n    to run on this thread and/or proc, then this will return NoGoroutine.\n    In this case, the goroutine starting to run will be can be found at\n    Event.StateTransition().Resource.\n\nfunc (e Event) Kind() EventKind\n    Kind returns the kind of event that this is.\n\nfunc (e Event) Label() Label\n    Label returns details about a Label event.\n\n    Panics if Kind != EventLabel.\n\nfunc (e Event) Log() Log\n    Log returns details about a Log event.\n\n    Panics if Kind != EventLog.\n\nfunc (e Event) Metric() Metric\n    Metric returns details about a Metric event.\n\n    Panics if Kind != EventMetric.\n\nfunc (e Event) Proc() ProcID\n    Proc returns the ID of the proc this event event pertains to.\n\n    Note that for proc state transitions this always refers to the state before\n    the transition. For example, if a proc is just starting to run on this\n    thread, then this will return NoProc.\n\nfunc (e Event) Range() Range\n    Range returns details about an EventRangeBegin, EventRangeActive,\n    or EventRangeEnd event.\n\n    Panics if Kind != EventRangeBegin, Kind != EventRangeActive, and Kind !=\n    EventRangeEnd.\n\nfunc (e Event) RangeAttributes() []RangeAttribute\n    RangeAttributes returns attributes for a completed range.\n\n    Panics if Kind != EventRangeEnd.\n\nfunc (e Event) Region() Region\n    Region returns details about a RegionBegin or RegionEnd event.\n\n    Panics if Kind != EventRegionBegin and Kind != EventRegionEnd.\n\nfunc (e Event) Stack() Stack\n    Stack returns a handle to a stack associated with the event.\n\n    This represents a stack trace at the current moment in time for the current\n    execution context.\n\nfunc (e Event) StateTransition() StateTransition\n    StateTransition returns details about a StateTransition event.\n\n    Panics if Kind != EventStateTransition.\n\nfunc (e Event) String() string\n    String returns the event as a human-readable string.\n\n    The format of the string is intended for debugging and is subject to change.\n\nfunc (e Event) Sync() Sync\n    Sync returns details that are relevant for the following events, up to but\n    excluding the next EventSync event.\n\nfunc (e Event) Task() Task\n    Task returns details about a TaskBegin or TaskEnd event.\n\n    Panics if Kind != EventTaskBegin and Kind != EventTaskEnd.\n\nfunc (e Event) Thread() ThreadID\n    Thread returns the ID of the thread this event pertains to.\n\n    Note that for thread state transitions this always refers to the state\n    before the transition. For example, if a thread is just starting to run,\n    then this will return NoThread.\n\n    Note: tracking thread state is not currently supported, so this will always\n    return a valid thread ID. However thread state transitions may be tracked in\n    the future, and callers must be robust to this possibility.\n\nfunc (e Event) Time() Time\n    Time returns the timestamp of the event.\n\ntype EventKind uint16\n    EventKind indicates the kind of event this is.\n\n    Use this information to obtain a more specific event that allows access to\n    more detailed information.\n\nconst (\n\tEventBad EventKind = iota\n\n\t// EventKindSync is an event that indicates a global synchronization\n\t// point in the trace. At the point of a sync event, the\n\t// trace reader can be certain that all resources (e.g. threads,\n\t// goroutines) that have existed until that point have been enumerated.\n\tEventSync\n\n\t// EventMetric is an event that represents the value of a metric at\n\t// a particular point in time.\n\tEventMetric\n\n\t// EventLabel attaches a label to a resource.\n\tEventLabel\n\n\t// EventStackSample represents an execution sample, indicating what a\n\t// thread/proc/goroutine was doing at a particular point in time via\n\t// its backtrace.\n\t//\n\t// Note: Samples should be considered a close approximation of\n\t// what a thread/proc/goroutine was executing at a given point in time.\n\t// These events may slightly contradict the situation StateTransitions\n\t// describe, so they should only be treated as a best-effort annotation.\n\tEventStackSample\n\n\t// EventRangeBegin and EventRangeEnd are a pair of generic events representing\n\t// a special range of time. Ranges are named and scoped to some resource\n\t// (identified via ResourceKind). A range that has begun but has not ended\n\t// is considered active.\n\t//\n\t// EvRangeBegin and EvRangeEnd will share the same name, and an End will always\n\t// follow a Begin on the same instance of the resource. The associated\n\t// resource ID can be obtained from the Event. ResourceNone indicates the\n\t// range is globally scoped. That is, any goroutine/proc/thread can start or\n\t// stop, but only one such range may be active at any given time.\n\t//\n\t// EventRangeActive is like EventRangeBegin, but indicates that the range was\n\t// already active. In this case, the resource referenced may not be in the current\n\t// context.\n\tEventRangeBegin\n\tEventRangeActive\n\tEventRangeEnd\n\n\t// EvTaskBegin and EvTaskEnd are a pair of events representing a runtime/trace.Task.\n\tEventTaskBegin\n\tEventTaskEnd\n\n\t// EventRegionBegin and EventRegionEnd are a pair of events represent a runtime/trace.Region.\n\tEventRegionBegin\n\tEventRegionEnd\n\n\t// EventLog represents a runtime/trace.Log call.\n\tEventLog\n\n\t// EventStateTransition represents a state change for some resource.\n\tEventStateTransition\n\n\t// EventExperimental is an experimental event that is unvalidated and exposed in a raw form.\n\t// Users are expected to understand the format and perform their own validation. These events\n\t// may always be safely ignored.\n\tEventExperimental\n)\nfunc (e EventKind) String() string\n    String returns a string form of the EventKind.\n\ntype ExperimentalBatch struct {\n\t// Thread is the ID of the thread that produced a packet of data.\n\tThread ThreadID\n\n\t// Data is a packet of unparsed data all produced by one thread.\n\tData []byte\n}\n    ExperimentalBatch represents a packet of unparsed data along with metadata\n    about that packet.\n\ntype ExperimentalEvent struct {\n\t// Name is the name of the event.\n\tName string\n\n\t// Experiment is the name of the experiment this event is a part of.\n\tExperiment string\n\n\t// Args lists the names of the event's arguments in order.\n\tArgs []string\n\n\t// Has unexported fields.\n}\n    ExperimentalEvent presents a raw view of an experimental event's arguments\n    and their names.\n\nfunc (e ExperimentalEvent) ArgValue(i int) Value\n    ArgValue returns a typed Value for the i'th argument in the experimental\n    event.\n\ntype GoID int64\n    GoID is the runtime-internal G structure's goid field. This is unique for\n    each goroutine.\n\ntype GoState uint8\n    GoState represents the state of a goroutine.\n\n    New GoStates may be added in the future. Users of this type must be robust\n    to that possibility.\n\nconst (\n\tGoUndetermined GoState = iota // No information is known about the goroutine.\n\tGoNotExist                    // Goroutine does not exist.\n\tGoRunnable                    // Goroutine is runnable but not running.\n\tGoRunning                     // Goroutine is running.\n\tGoWaiting                     // Goroutine is waiting on something to happen.\n\tGoSyscall                     // Goroutine is in a system call.\n)\nfunc (s GoState) Executing() bool\n    Executing returns true if the state indicates that the goroutine is\n    executing and bound to its thread.\n\nfunc (s GoState) String() string\n    String returns a human-readable representation of a GoState.\n\n    The format of the returned string is for debugging purposes and is subject\n    to change.\n\ntype GoroutineExecStats struct {\n\t// These stats are all non-overlapping.\n\tExecTime          time.Duration\n\tSchedWaitTime     time.Duration\n\tBlockTimeByReason map[string]time.Duration\n\tSyscallTime       time.Duration\n\tSyscallBlockTime  time.Duration\n\n\t// TotalTime is the duration of the goroutine's presence in the trace.\n\t// Necessarily overlaps with other stats.\n\tTotalTime time.Duration\n\n\t// Total time the goroutine spent in certain ranges; may overlap\n\t// with other stats.\n\tRangeTime map[string]time.Duration\n}\n    GoroutineExecStats contains statistics about a goroutine's execution during\n    a period of time.\n\nfunc (s GoroutineExecStats) NonOverlappingStats() map[string]time.Duration\n\nfunc (s GoroutineExecStats) UnknownTime() time.Duration\n    UnknownTime returns whatever isn't accounted for in TotalTime.\n\ntype GoroutineSummary struct {\n\tID           GoID\n\tName         string // A non-unique human-friendly identifier for the goroutine.\n\tPC           uint64 // The first PC we saw for the entry function of the goroutine\n\tCreationTime Time   // Timestamp of the first appearance in the trace.\n\tStartTime    Time   // Timestamp of the first time it started running. 0 if the goroutine never ran.\n\tEndTime      Time   // Timestamp of when the goroutine exited. 0 if the goroutine never exited.\n\n\t// List of regions in the goroutine, sorted based on the start time.\n\tRegions []*UserRegionSummary\n\n\t// Statistics of execution time during the goroutine execution.\n\tGoroutineExecStats\n\n\t// Has unexported fields.\n}\n    GoroutineSummary contains statistics and execution details of a single\n    goroutine. (For v2 traces.)\n\ntype Label struct {\n\t// Label is the label applied to some resource.\n\tLabel string\n\n\t// Resource is the resource to which this label should be applied.\n\tResource ResourceID\n}\n    Label provides details about a Label event.\n\ntype Log struct {\n\t// Task is the ID of the task this region is associated with.\n\tTask TaskID\n\n\t// Category is the category that was passed to runtime/trace.Log or runtime/trace.Logf.\n\tCategory string\n\n\t// Message is the message that was passed to runtime/trace.Log or runtime/trace.Logf.\n\tMessage string\n}\n    Log provides details about a Log event.\n\ntype MMUCurve struct {\n\t// Has unexported fields.\n}\n    An MMUCurve is the minimum mutator utilization curve across multiple window\n    sizes.\n\nfunc NewMMUCurve(utils [][]MutatorUtil) *MMUCurve\n    NewMMUCurve returns an MMU curve for the given mutator utilization function.\n\nfunc (c *MMUCurve) Examples(window time.Duration, n int) (worst []UtilWindow)\n    Examples returns n specific examples of the lowest mutator utilization for\n    the given window size. The returned windows will be disjoint (otherwise\n    there would be a huge number of mostly-overlapping windows at the single\n    lowest point). There are no guarantees on which set of disjoint windows this\n    returns.\n\nfunc (c *MMUCurve) MMU(window time.Duration) (mmu float64)\n    MMU returns the minimum mutator utilization for the given time window.\n    This is the minimum utilization for all windows of this duration across the\n    execution. The returned value is in the range [0, 1].\n\nfunc (c *MMUCurve) MUD(window time.Duration, quantiles []float64) []float64\n    MUD returns mutator utilization distribution quantiles for the given window\n    size.\n\n    The mutator utilization distribution is the distribution of mean mutator\n    utilization across all windows of the given window size in the trace.\n\n    The minimum mutator utilization is the minimum (0th percentile) of this\n    distribution. (However, if only the minimum is desired, it's more efficient\n    to use the MMU method.)\n\ntype Metric struct {\n\t// Name is the name of the sampled metric.\n\t//\n\t// Names follow the same convention as metric names in the\n\t// runtime/metrics package, meaning they include the unit.\n\t// Names that match with the runtime/metrics package represent\n\t// the same quantity. Note that this corresponds to the\n\t// runtime/metrics package for the Go version this trace was\n\t// collected for.\n\tName string\n\n\t// Value is the sampled value of the metric.\n\t//\n\t// The Value's Kind is tied to the name of the metric, and so is\n\t// guaranteed to be the same for metric samples for the same metric.\n\tValue Value\n}\n    Metric provides details about a Metric event.\n\ntype MutatorUtil struct {\n\tTime int64\n\t// Util is the mean mutator utilization starting at Time. This\n\t// is in the range [0, 1].\n\tUtil float64\n}\n    MutatorUtil is a change in mutator utilization at a particular time. Mutator\n    utilization functions are represented as a time-ordered []MutatorUtil.\n\ntype ProcID int64\n    ProcID is the runtime-internal G structure's id field. This is unique for\n    each P.\n\ntype ProcState uint8\n    ProcState represents the state of a proc.\n\n    New ProcStates may be added in the future. Users of this type must be robust\n    to that possibility.\n\nconst (\n\tProcUndetermined ProcState = iota // No information is known about the proc.\n\tProcNotExist                      // Proc does not exist.\n\tProcRunning                       // Proc is running.\n\tProcIdle                          // Proc is idle.\n)\nfunc (s ProcState) Executing() bool\n    Executing returns true if the state indicates that the proc is executing and\n    bound to its thread.\n\nfunc (s ProcState) String() string\n    String returns a human-readable representation of a ProcState.\n\n    The format of the returned string is for debugging purposes and is subject\n    to change.\n\ntype Range struct {\n\t// Name is a human-readable name for the range.\n\t//\n\t// This name can be used to identify the end of the range for the resource\n\t// its scoped to, because only one of each type of range may be active on\n\t// a particular resource. The relevant resource should be obtained from the\n\t// Event that produced these details. The corresponding RangeEnd will have\n\t// an identical name.\n\tName string\n\n\t// Scope is the resource that the range is scoped to.\n\t//\n\t// For example, a ResourceGoroutine scope means that the same goroutine\n\t// must have a start and end for the range, and that goroutine can only\n\t// have one range of a particular name active at any given time. The\n\t// ID that this range is scoped to may be obtained via Event.Goroutine.\n\t//\n\t// The ResourceNone scope means that the range is globally scoped. As a\n\t// result, any goroutine/proc/thread may start or end the range, and only\n\t// one such named range may be active globally at any given time.\n\t//\n\t// For RangeBegin and RangeEnd events, this will always reference some\n\t// resource ID in the current execution context. For RangeActive events,\n\t// this may reference a resource not in the current context. Prefer Scope\n\t// over the current execution context.\n\tScope ResourceID\n}\n    Range provides details about a Range event.\n\ntype RangeAttribute struct {\n\t// Name is the human-readable name for the range.\n\tName string\n\n\t// Value is the value of the attribute.\n\tValue Value\n}\n    RangeAttributes provides attributes about a completed Range.\n\ntype Reader struct {\n\t// Has unexported fields.\n}\n    Reader reads a byte stream, validates it, and produces trace events.\n\n    Provided the trace is non-empty the Reader always produces a Sync event as\n    the first event, and a Sync event as the last event. (There may also be any\n    number of Sync events in the middle, too.)\n\nfunc NewReader(r io.Reader) (*Reader, error)\n    NewReader creates a new trace reader.\n\nfunc (r *Reader) ReadEvent() (e Event, err error)\n    ReadEvent reads a single event from the stream.\n\n    If the stream has been exhausted, it returns an invalid event and io.EOF.\n\ntype Region struct {\n\t// Task is the ID of the task this region is associated with.\n\tTask TaskID\n\n\t// Type is the regionType that was passed to runtime/trace.StartRegion or runtime/trace.WithRegion.\n\tType string\n}\n    Region provides details about a Region event.\n\ntype ResourceID struct {\n\t// Kind is the kind of resource this ID is for.\n\tKind ResourceKind\n\t// Has unexported fields.\n}\n    ResourceID represents a generic resource ID.\n\nfunc MakeResourceID[T interface{ GoID | ProcID | ThreadID }](id T) ResourceID\n    MakeResourceID creates a general resource ID from a specific resource's ID.\n\nfunc (r ResourceID) Goroutine() GoID\n    Goroutine obtains a GoID from the resource ID.\n\n    r.Kind must be ResourceGoroutine or this function will panic.\n\nfunc (r ResourceID) Proc() ProcID\n    Proc obtains a ProcID from the resource ID.\n\n    r.Kind must be ResourceProc or this function will panic.\n\nfunc (r ResourceID) String() string\n    String returns a human-readable string representation of the ResourceID.\n\n    This representation is subject to change and is intended primarily for\n    debugging.\n\nfunc (r ResourceID) Thread() ThreadID\n    Thread obtains a ThreadID from the resource ID.\n\n    r.Kind must be ResourceThread or this function will panic.\n\ntype ResourceKind uint8\n    ResourceKind indicates a kind of resource that has a state machine.\n\n    New ResourceKinds may be added in the future. Users of this type must be\n    robust to that possibility.\n\nconst (\n\tResourceNone      ResourceKind = iota // No resource.\n\tResourceGoroutine                     // Goroutine.\n\tResourceProc                          // Proc.\n\tResourceThread                        // Thread.\n)\nfunc (r ResourceKind) String() string\n    String returns a human-readable representation of a ResourceKind.\n\n    The format of the returned string is for debugging purposes and is subject\n    to change.\n\ntype Stack struct {\n\t// Has unexported fields.\n}\n    Stack represents a stack. It's really a handle to a stack and it's trivially\n    comparable.\n\n    If two Stacks are equal then their Frames are guaranteed to be identical.\n    If they are not equal, however, their Frames may still be equal.\n\nfunc (s Stack) Frames() iter.Seq[StackFrame]\n    Frames is an iterator over the frames in a Stack.\n\ntype StackFrame struct {\n\t// PC is the program counter of the function call if this\n\t// is not a leaf frame. If it's a leaf frame, it's the point\n\t// at which the stack trace was taken.\n\tPC uint64\n\n\t// Func is the name of the function this frame maps to.\n\tFunc string\n\n\t// File is the file which contains the source code of Func.\n\tFile string\n\n\t// Line is the line number within File which maps to PC.\n\tLine uint64\n}\n    StackFrame represents a single frame of a stack.\n\ntype StateTransition struct {\n\t// Resource is the resource this state transition is for.\n\tResource ResourceID\n\n\t// Reason is a human-readable reason for the state transition.\n\tReason string\n\n\t// Stack is the stack trace of the resource making the state transition.\n\t//\n\t// This is distinct from the result (Event).Stack because it pertains to\n\t// the transitioning resource, not any of the ones executing the event\n\t// this StateTransition came from.\n\t//\n\t// An example of this difference is the NotExist -> Runnable transition for\n\t// goroutines, which indicates goroutine creation. In this particular case,\n\t// a Stack here would refer to the starting stack of the new goroutine, and\n\t// an (Event).Stack would refer to the stack trace of whoever created the\n\t// goroutine.\n\tStack Stack\n\n\t// Has unexported fields.\n}\n    StateTransition provides details about a StateTransition event.\n\nfunc (d StateTransition) Goroutine() (from, to GoState)\n    Goroutine returns the state transition for a goroutine.\n\n    Transitions to and from states that are Executing are special in that they\n    change the future execution context. In other words, future events on the\n    same thread will feature the same goroutine until it stops running.\n\n    Panics if d.Resource.Kind is not ResourceGoroutine.\n\nfunc (d StateTransition) Proc() (from, to ProcState)\n    Proc returns the state transition for a proc.\n\n    Transitions to and from states that are Executing are special in that they\n    change the future execution context. In other words, future events on the\n    same thread will feature the same goroutine until it stops running.\n\n    Panics if d.Resource.Kind is not ResourceProc.\n\ntype Summarizer struct {\n\t// Has unexported fields.\n}\n    Summarizer constructs per-goroutine time statistics for v2 traces.\n\nfunc NewSummarizer() *Summarizer\n    NewSummarizer creates a new struct to build goroutine stats from a trace.\n\nfunc (s *Summarizer) Event(ev *Event)\n    Event feeds a single event into the stats summarizer.\n\nfunc (s *Summarizer) Finalize() *Summary\n    Finalize indicates to the summarizer that we're done processing the trace.\n    It cleans up any remaining state and returns the full summary.\n\ntype Summary struct {\n\tGoroutines map[GoID]*GoroutineSummary\n\tTasks      map[TaskID]*UserTaskSummary\n}\n    Summary is the analysis result produced by the summarizer.\n\ntype Sync struct {\n\t// N indicates that this is the Nth sync event in the trace.\n\tN int\n\n\t// ClockSnapshot is a snapshot of different clocks taken in close in time\n\t// that can be used to correlate trace events with data captured by other\n\t// tools. May be nil for older trace versions.\n\tClockSnapshot *ClockSnapshot\n\n\t// ExperimentalBatches contain all the unparsed batches of data for a given experiment.\n\tExperimentalBatches map[string][]ExperimentalBatch\n}\n    Sync contains details potentially relevant to all the following events,\n    up to but excluding the next EventSync event.\n\ntype Task struct {\n\t// ID is a unique identifier for the task.\n\t//\n\t// This can be used to associate the beginning of a task with its end.\n\tID TaskID\n\n\t// ParentID is the ID of the parent task.\n\tParent TaskID\n\n\t// Type is the taskType that was passed to runtime/trace.NewTask.\n\t//\n\t// May be \"\" if a task's TaskBegin event isn't present in the trace.\n\tType string\n}\n    Task provides details about a Task event.\n\ntype TaskID uint64\n    TaskID is the internal ID of a task used to disambiguate tasks (even if they\n    are of the same type).\n\ntype ThreadID int64\n    ThreadID is the runtime-internal M structure's ID. This is unique for each\n    OS thread.\n\ntype Time int64\n    Time is a timestamp in nanoseconds.\n\n    It corresponds to the monotonic clock on the platform that the trace was\n    taken, and so is possible to correlate with timestamps for other traces\n    taken on the same machine using the same clock (i.e. no reboots in between).\n\n    The actual absolute value of the timestamp is only meaningful in relation to\n    other timestamps from the same clock.\n\n    BUG: Timestamps coming from traces on Windows platforms are only comparable\n    with timestamps from the same trace. Timestamps across traces cannot be\n    compared, because the system clock is not used as of Go 1.22.\n\n    BUG: Traces produced by Go versions 1.21 and earlier cannot be compared with\n    timestamps from other traces taken on the same machine. This is because the\n    system clock was not used at all to collect those timestamps.\n\nfunc (t Time) Sub(t0 Time) time.Duration\n    Sub subtracts t0 from t, returning the duration in nanoseconds.\n\ntype UserRegionSummary struct {\n\tTaskID TaskID\n\tName   string\n\n\t// Region start event. Normally EventRegionBegin event or nil,\n\t// but can be a state transition event from NotExist or Undetermined\n\t// if the region is a synthetic region representing task inheritance\n\t// from the parent goroutine.\n\tStart *Event\n\n\t// Region end event. Normally EventRegionEnd event or nil,\n\t// but can be a state transition event to NotExist if the goroutine\n\t// terminated without explicitly ending the region.\n\tEnd *Event\n\n\tGoroutineExecStats\n}\n    UserRegionSummary represents a region and goroutine execution stats while\n    the region was active. (For v2 traces.)\n\ntype UserTaskSummary struct {\n\tID       TaskID\n\tName     string\n\tParent   *UserTaskSummary // nil if the parent is unknown.\n\tChildren []*UserTaskSummary\n\n\t// Task begin event. An EventTaskBegin event or nil.\n\tStart *Event\n\n\t// End end event. Normally EventTaskEnd event or nil.\n\tEnd *Event\n\n\t// Logs is a list of EventLog events associated with the task.\n\tLogs []*Event\n\n\t// List of regions in the task, sorted based on the start time.\n\tRegions []*UserRegionSummary\n\n\t// Goroutines is the set of goroutines associated with this task.\n\tGoroutines map[GoID]*GoroutineSummary\n}\n    UserTaskSummary represents a task in the trace.\n\nfunc (s *UserTaskSummary) Complete() bool\n    Complete returns true if we have complete information about the task from\n    the trace: both a start and an end.\n\nfunc (s *UserTaskSummary) Descendents() []*UserTaskSummary\n    Descendents returns a slice consisting of itself (always the first task\n    returned), and the transitive closure of all of its children.\n\ntype UtilFlags int\n    UtilFlags controls the behavior of MutatorUtilization.\n\nconst (\n\t// UtilSTW means utilization should account for STW events.\n\t// This includes non-GC STW events, which are typically user-requested.\n\tUtilSTW UtilFlags = 1 << iota\n\t// UtilBackground means utilization should account for\n\t// background mark workers.\n\tUtilBackground\n\t// UtilAssist means utilization should account for mark\n\t// assists.\n\tUtilAssist\n\t// UtilSweep means utilization should account for sweeping.\n\tUtilSweep\n\n\t// UtilPerProc means each P should be given a separate\n\t// utilization function. Otherwise, there is a single function\n\t// and each P is given a fraction of the utilization.\n\tUtilPerProc\n)\ntype UtilWindow struct {\n\tTime int64\n\t// MutatorUtil is the mean mutator utilization in this window.\n\tMutatorUtil float64\n}\n    UtilWindow is a specific window at Time.\n\ntype Value struct {\n\t// Has unexported fields.\n}\n    Value is a dynamically-typed value obtained from a trace.\n\nfunc (v Value) Kind() ValueKind\n    Kind returns the ValueKind of the value.\n\n    It represents the underlying structure of the value.\n\n    New ValueKinds may be added in the future. Users of this type must be robust\n    to that possibility.\n\nfunc (v Value) String() string\n    String returns the string value for a ValueString, and otherwise a string\n    representation of the value for other kinds of values.\n\nfunc (v Value) Uint64() uint64\n    Uint64 returns the uint64 value for a ValueUint64.\n\n    Panics if this Value's Kind is not ValueUint64.\n\ntype ValueKind uint8\n    ValueKind is the type of a dynamically-typed value from a trace.\n\nconst (\n\tValueBad ValueKind = iota\n\tValueUint64\n\tValueString\n)\n"}, {"path": "stdlib/os-user.md", "category": "stdlib", "name": "stdlib/os-user", "content": "package user // import \"os/user\"\n\nPackage user allows user account lookups by name or id.\n\nFor most Unix systems, this package has two internal implementations of\nresolving user and group ids to names, and listing supplementary group IDs.\nOne is written in pure Go and parses /etc/passwd and /etc/group. The other\nis cgo-based and relies on the standard C library (libc) routines such as\ngetpwuid_r, getgrnam_r, and getgrouplist.\n\nWhen cgo is available, and the required routines are implemented in\nlibc for a particular platform, cgo-based (libc-backed) code is used.\nThis can be overridden by using osusergo build tag, which enforces the pure Go\nimplementation.\n\nTYPES\n\ntype Group struct {\n\tGid  string // group ID\n\tName string // group name\n}\n    Group represents a grouping of users.\n\n    On POSIX systems Gid contains a decimal number representing the group ID.\n\nfunc LookupGroup(name string) (*Group, error)\n    LookupGroup looks up a group by name. If the group cannot be found,\n    the returned error is of type UnknownGroupError.\n\nfunc LookupGroupId(gid string) (*Group, error)\n    LookupGroupId looks up a group by groupid. If the group cannot be found,\n    the returned error is of type UnknownGroupIdError.\n\ntype UnknownGroupError string\n    UnknownGroupError is returned by LookupGroup when a group cannot be found.\n\nfunc (e UnknownGroupError) Error() string\n\ntype UnknownGroupIdError string\n    UnknownGroupIdError is returned by LookupGroupId when a group cannot be\n    found.\n\nfunc (e UnknownGroupIdError) Error() string\n\ntype UnknownUserError string\n    UnknownUserError is returned by Lookup when a user cannot be found.\n\nfunc (e UnknownUserError) Error() string\n\ntype UnknownUserIdError int\n    UnknownUserIdError is returned by LookupId when a user cannot be found.\n\nfunc (e UnknownUserIdError) Error() string\n\ntype User struct {\n\t// Uid is the user ID.\n\t// On POSIX systems, this is a decimal number representing the uid.\n\t// On Windows, this is a security identifier (SID) in a string format.\n\t// On Plan 9, this is the contents of /dev/user.\n\tUid string\n\t// Gid is the primary group ID.\n\t// On POSIX systems, this is a decimal number representing the gid.\n\t// On Windows, this is a SID in a string format.\n\t// On Plan 9, this is the contents of /dev/user.\n\tGid string\n\t// Username is the login name.\n\tUsername string\n\t// Name is the user's real or display name.\n\t// It might be blank.\n\t// On POSIX systems, this is the first (or only) entry in the GECOS field\n\t// list.\n\t// On Windows, this is the user's display name.\n\t// On Plan 9, this is the contents of /dev/user.\n\tName string\n\t// HomeDir is the path to the user's home directory (if they have one).\n\tHomeDir string\n}\n    User represents a user account.\n\nfunc Current() (*User, error)\n    Current returns the current user.\n\n    The first call will cache the current user information. Subsequent calls\n    will return the cached value and will not reflect changes to the current\n    user.\n\nfunc Lookup(username string) (*User, error)\n    Lookup looks up a user by username. If the user cannot be found, the\n    returned error is of type UnknownUserError.\n\nfunc LookupId(uid string) (*User, error)\n    LookupId looks up a user by userid. If the user cannot be found, the\n    returned error is of type UnknownUserIdError.\n\nfunc (u *User) GroupIds() ([]string, error)\n    GroupIds returns the list of group IDs that the user is a member of.\n\n"}, {"path": "stdlib/crypto-rc4.md", "category": "stdlib", "name": "stdlib/crypto-rc4", "content": "package rc4 // import \"crypto/rc4\"\n\nPackage rc4 implements RC4 encryption, as defined in Bruce Schneier's Applied\nCryptography.\n\nRC4 is cryptographically broken and should not be used for secure applications.\n\nTYPES\n\ntype Cipher struct {\n\t// Has unexported fields.\n}\n    A Cipher is an instance of RC4 using a particular key.\n\nfunc NewCipher(key []byte) (*Cipher, error)\n    NewCipher creates and returns a new Cipher. The key argument should be the\n    RC4 key, at least 1 byte and at most 256 bytes.\n\nfunc (c *Cipher) Reset()\n    Reset zeros the key data and makes the Cipher unusable.\n\n    Deprecated: Reset can't guarantee that the key will be entirely removed from\n    the process's memory.\n\nfunc (c *Cipher) XORKeyStream(dst, src []byte)\n    XORKeyStream sets dst to the result of XORing src with the key stream.\n    Dst and src must overlap entirely or not at all.\n\ntype KeySizeError int\n\nfunc (k KeySizeError) Error() string\n\n"}, {"path": "stdlib/internal-types-errors.md", "category": "stdlib", "name": "stdlib/internal-types-errors", "content": "package errors // import \"internal/types/errors\"\n\n\nTYPES\n\ntype Code int\n\nconst (\n\n\t// Test is reserved for errors that only apply while in self-test mode.\n\tTest Code\n\n\t// BlankPkgName occurs when a package name is the blank identifier \"_\".\n\t//\n\t// Per the spec:\n\t//  \"The PackageName must not be the blank identifier.\"\n\t//\n\t// Example:\n\t//  package _\n\tBlankPkgName\n\n\t// MismatchedPkgName occurs when a file's package name doesn't match the\n\t// package name already established by other files.\n\tMismatchedPkgName\n\n\t// InvalidPkgUse occurs when a package identifier is used outside of a\n\t// selector expression.\n\t//\n\t// Example:\n\t//  import \"fmt\"\n\t//\n\t//  var _ = fmt\n\tInvalidPkgUse\n\n\t// BadImportPath occurs when an import path is not valid.\n\tBadImportPath\n\n\t// BrokenImport occurs when importing a package fails.\n\t//\n\t// Example:\n\t//  import \"amissingpackage\"\n\tBrokenImport\n\n\t// ImportCRenamed occurs when the special import \"C\" is renamed. \"C\" is a\n\t// pseudo-package, and must not be renamed.\n\t//\n\t// Example:\n\t//  import _ \"C\"\n\tImportCRenamed\n\n\t// UnusedImport occurs when an import is unused.\n\t//\n\t// Example:\n\t//  import \"fmt\"\n\t//\n\t//  func main() {}\n\tUnusedImport\n\n\t// InvalidInitCycle occurs when an invalid cycle is detected within the\n\t// initialization graph.\n\t//\n\t// Example:\n\t//  var x int = f()\n\t//\n\t//  func f() int { return x }\n\tInvalidInitCycle\n\n\t// DuplicateDecl occurs when an identifier is declared multiple times.\n\t//\n\t// Example:\n\t//  var x = 1\n\t//  var x = 2\n\tDuplicateDecl\n\n\t// InvalidDeclCycle occurs when a declaration cycle is not valid.\n\t//\n\t// Example:\n\t//  type S struct {\n\t//  \tS\n\t//  }\n\t//\n\tInvalidDeclCycle\n\n\t// InvalidTypeCycle occurs when a cycle in type definitions results in a\n\t// type that is not well-defined.\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  type T [unsafe.Sizeof(T{})]int\n\tInvalidTypeCycle\n\n\t// InvalidConstInit occurs when a const declaration has a non-constant\n\t// initializer.\n\t//\n\t// Example:\n\t//  var x int\n\t//  const _ = x\n\tInvalidConstInit\n\n\t// InvalidConstVal occurs when a const value cannot be converted to its\n\t// target type.\n\t//\n\t// TODO(findleyr): this error code and example are not very clear. Consider\n\t// removing it.\n\t//\n\t// Example:\n\t//  const _ = 1 << \"hello\"\n\tInvalidConstVal\n\n\t// InvalidConstType occurs when the underlying type in a const declaration\n\t// is not a valid constant type.\n\t//\n\t// Example:\n\t//  const c *int = 4\n\tInvalidConstType\n\n\t// UntypedNilUse occurs when the predeclared (untyped) value nil is used to\n\t// initialize a variable declared without an explicit type.\n\t//\n\t// Example:\n\t//  var x = nil\n\tUntypedNilUse\n\n\t// WrongAssignCount occurs when the number of values on the right-hand side\n\t// of an assignment or initialization expression does not match the number\n\t// of variables on the left-hand side.\n\t//\n\t// Example:\n\t//  var x = 1, 2\n\tWrongAssignCount\n\n\t// UnassignableOperand occurs when the left-hand side of an assignment is\n\t// not assignable.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tconst c = 1\n\t//  \tc = 2\n\t//  }\n\tUnassignableOperand\n\n\t// NoNewVar occurs when a short variable declaration (':=') does not declare\n\t// new variables.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tx := 1\n\t//  \tx := 2\n\t//  }\n\tNoNewVar\n\n\t// MultiValAssignOp occurs when an assignment operation (+=, *=, etc) does\n\t// not have single-valued left-hand or right-hand side.\n\t//\n\t// Per the spec:\n\t//  \"In assignment operations, both the left- and right-hand expression lists\n\t//  must contain exactly one single-valued expression\"\n\t//\n\t// Example:\n\t//  func f() int {\n\t//  \tx, y := 1, 2\n\t//  \tx, y += 1\n\t//  \treturn x + y\n\t//  }\n\tMultiValAssignOp\n\n\t// InvalidIfaceAssign occurs when a value of type T is used as an\n\t// interface, but T does not implement a method of the expected interface.\n\t//\n\t// Example:\n\t//  type I interface {\n\t//  \tf()\n\t//  }\n\t//\n\t//  type T int\n\t//\n\t//  var x I = T(1)\n\tInvalidIfaceAssign\n\n\t// InvalidChanAssign occurs when a chan assignment is invalid.\n\t//\n\t// Per the spec, a value x is assignable to a channel type T if:\n\t//  \"x is a bidirectional channel value, T is a channel type, x's type V and\n\t//  T have identical element types, and at least one of V or T is not a\n\t//  defined type.\"\n\t//\n\t// Example:\n\t//  type T1 chan int\n\t//  type T2 chan int\n\t//\n\t//  var x T1\n\t//  // Invalid assignment because both types are named\n\t//  var _ T2 = x\n\tInvalidChanAssign\n\n\t// IncompatibleAssign occurs when the type of the right-hand side expression\n\t// in an assignment cannot be assigned to the type of the variable being\n\t// assigned.\n\t//\n\t// Example:\n\t//  var x []int\n\t//  var _ int = x\n\tIncompatibleAssign\n\n\t// UnaddressableFieldAssign occurs when trying to assign to a struct field\n\t// in a map value.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tm := make(map[string]struct{i int})\n\t//  \tm[\"foo\"].i = 42\n\t//  }\n\tUnaddressableFieldAssign\n\n\t// NotAType occurs when the identifier used as the underlying type in a type\n\t// declaration or the right-hand side of a type alias does not denote a type.\n\t//\n\t// Example:\n\t//  var S = 2\n\t//\n\t//  type T S\n\tNotAType\n\n\t// InvalidArrayLen occurs when an array length is not a constant value.\n\t//\n\t// Example:\n\t//  var n = 3\n\t//  var _ = [n]int{}\n\tInvalidArrayLen\n\n\t// BlankIfaceMethod occurs when a method name is '_'.\n\t//\n\t// Per the spec:\n\t//  \"The name of each explicitly specified method must be unique and not\n\t//  blank.\"\n\t//\n\t// Example:\n\t//  type T interface {\n\t//  \t_(int)\n\t//  }\n\tBlankIfaceMethod\n\n\t// IncomparableMapKey occurs when a map key type does not support the == and\n\t// != operators.\n\t//\n\t// Per the spec:\n\t//  \"The comparison operators == and != must be fully defined for operands of\n\t//  the key type; thus the key type must not be a function, map, or slice.\"\n\t//\n\t// Example:\n\t//  var x map[T]int\n\t//\n\t//  type T []int\n\tIncomparableMapKey\n\n\t// InvalidPtrEmbed occurs when an embedded field is of the pointer form *T,\n\t// and T itself is itself a pointer, an unsafe.Pointer, or an interface.\n\t//\n\t// Per the spec:\n\t//  \"An embedded field must be specified as a type name T or as a pointer to\n\t//  a non-interface type name *T, and T itself may not be a pointer type.\"\n\t//\n\t// Example:\n\t//  type T *int\n\t//\n\t//  type S struct {\n\t//  \t*T\n\t//  }\n\tInvalidPtrEmbed\n\n\t// BadRecv occurs when a method declaration does not have exactly one\n\t// receiver parameter.\n\t//\n\t// Example:\n\t//  func () _() {}\n\tBadRecv\n\n\t// InvalidRecv occurs when a receiver type expression is not of the form T\n\t// or *T, or T is a pointer type.\n\t//\n\t// Example:\n\t//  type T struct {}\n\t//\n\t//  func (**T) m() {}\n\tInvalidRecv\n\n\t// DuplicateFieldAndMethod occurs when an identifier appears as both a field\n\t// and method name.\n\t//\n\t// Example:\n\t//  type T struct {\n\t//  \tm int\n\t//  }\n\t//\n\t//  func (T) m() {}\n\tDuplicateFieldAndMethod\n\n\t// DuplicateMethod occurs when two methods on the same receiver type have\n\t// the same name.\n\t//\n\t// Example:\n\t//  type T struct {}\n\t//  func (T) m() {}\n\t//  func (T) m(i int) int { return i }\n\tDuplicateMethod\n\n\t// InvalidBlank occurs when a blank identifier is used as a value or type.\n\t//\n\t// Per the spec:\n\t//  \"The blank identifier may appear as an operand only on the left-hand side\n\t//  of an assignment.\"\n\t//\n\t// Example:\n\t//  var x = _\n\tInvalidBlank\n\n\t// InvalidIota occurs when the predeclared identifier iota is used outside\n\t// of a constant declaration.\n\t//\n\t// Example:\n\t//  var x = iota\n\tInvalidIota\n\n\t// MissingInitBody occurs when an init function is missing its body.\n\t//\n\t// Example:\n\t//  func init()\n\tMissingInitBody\n\n\t// InvalidInitSig occurs when an init function declares parameters or\n\t// results.\n\t//\n\t// Deprecated: no longer emitted by the type checker. _InvalidInitDecl is\n\t// used instead.\n\tInvalidInitSig\n\n\t// InvalidInitDecl occurs when init is declared as anything other than a\n\t// function.\n\t//\n\t// Example:\n\t//  var init = 1\n\t//\n\t// Example:\n\t//  func init() int { return 1 }\n\tInvalidInitDecl\n\n\t// InvalidMainDecl occurs when main is declared as anything other than a\n\t// function, in a main package.\n\tInvalidMainDecl\n\n\t// TooManyValues occurs when a function returns too many values for the\n\t// expression context in which it is used.\n\t//\n\t// Example:\n\t//  func ReturnTwo() (int, int) {\n\t//  \treturn 1, 2\n\t//  }\n\t//\n\t//  var x = ReturnTwo()\n\tTooManyValues\n\n\t// NotAnExpr occurs when a type expression is used where a value expression\n\t// is expected.\n\t//\n\t// Example:\n\t//  type T struct {}\n\t//\n\t//  func f() {\n\t//  \tT\n\t//  }\n\tNotAnExpr\n\n\t// TruncatedFloat occurs when a float constant is truncated to an integer\n\t// value.\n\t//\n\t// Example:\n\t//  var _ int = 98.6\n\tTruncatedFloat\n\n\t// NumericOverflow occurs when a numeric constant overflows its target type.\n\t//\n\t// Example:\n\t//  var x int8 = 1000\n\tNumericOverflow\n\n\t// UndefinedOp occurs when an operator is not defined for the type(s) used\n\t// in an operation.\n\t//\n\t// Example:\n\t//  var c = \"a\" - \"b\"\n\tUndefinedOp\n\n\t// MismatchedTypes occurs when operand types are incompatible in a binary\n\t// operation.\n\t//\n\t// Example:\n\t//  var a = \"hello\"\n\t//  var b = 1\n\t//  var c = a - b\n\tMismatchedTypes\n\n\t// DivByZero occurs when a division operation is provable at compile\n\t// time to be a division by zero.\n\t//\n\t// Example:\n\t//  const divisor = 0\n\t//  var x int = 1/divisor\n\tDivByZero\n\n\t// NonNumericIncDec occurs when an increment or decrement operator is\n\t// applied to a non-numeric value.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tvar c = \"c\"\n\t//  \tc++\n\t//  }\n\tNonNumericIncDec\n\n\t// UnaddressableOperand occurs when the & operator is applied to an\n\t// unaddressable expression.\n\t//\n\t// Example:\n\t//  var x = &1\n\tUnaddressableOperand\n\n\t// InvalidIndirection occurs when a non-pointer value is indirected via the\n\t// '*' operator.\n\t//\n\t// Example:\n\t//  var x int\n\t//  var y = *x\n\tInvalidIndirection\n\n\t// NonIndexableOperand occurs when an index operation is applied to a value\n\t// that cannot be indexed.\n\t//\n\t// Example:\n\t//  var x = 1\n\t//  var y = x[1]\n\tNonIndexableOperand\n\n\t// InvalidIndex occurs when an index argument is not of integer type,\n\t// negative, or out-of-bounds.\n\t//\n\t// Example:\n\t//  var s = [...]int{1,2,3}\n\t//  var x = s[5]\n\t//\n\t// Example:\n\t//  var s = []int{1,2,3}\n\t//  var _ = s[-1]\n\t//\n\t// Example:\n\t//  var s = []int{1,2,3}\n\t//  var i string\n\t//  var _ = s[i]\n\tInvalidIndex\n\n\t// SwappedSliceIndices occurs when constant indices in a slice expression\n\t// are decreasing in value.\n\t//\n\t// Example:\n\t//  var _ = []int{1,2,3}[2:1]\n\tSwappedSliceIndices\n\n\t// NonSliceableOperand occurs when a slice operation is applied to a value\n\t// whose type is not sliceable, or is unaddressable.\n\t//\n\t// Example:\n\t//  var x = [...]int{1, 2, 3}[:1]\n\t//\n\t// Example:\n\t//  var x = 1\n\t//  var y = 1[:1]\n\tNonSliceableOperand\n\n\t// InvalidSliceExpr occurs when a three-index slice expression (a[x:y:z]) is\n\t// applied to a string.\n\t//\n\t// Example:\n\t//  var s = \"hello\"\n\t//  var x = s[1:2:3]\n\tInvalidSliceExpr\n\n\t// InvalidShiftCount occurs when the right-hand side of a shift operation is\n\t// either non-integer, negative, or too large.\n\t//\n\t// Example:\n\t//  var (\n\t//  \tx string\n\t//  \ty int = 1 << x\n\t//  )\n\tInvalidShiftCount\n\n\t// InvalidShiftOperand occurs when the shifted operand is not an integer.\n\t//\n\t// Example:\n\t//  var s = \"hello\"\n\t//  var x = s << 2\n\tInvalidShiftOperand\n\n\t// InvalidReceive occurs when there is a channel receive from a value that\n\t// is either not a channel, or is a send-only channel.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tvar x = 1\n\t//  \t<-x\n\t//  }\n\tInvalidReceive\n\n\t// InvalidSend occurs when there is a channel send to a value that is not a\n\t// channel, or is a receive-only channel.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tvar x = 1\n\t//  \tx <- \"hello!\"\n\t//  }\n\tInvalidSend\n\n\t// DuplicateLitKey occurs when an index is duplicated in a slice, array, or\n\t// map literal.\n\t//\n\t// Example:\n\t//  var _ = []int{0:1, 0:2}\n\t//\n\t// Example:\n\t//  var _ = map[string]int{\"a\": 1, \"a\": 2}\n\tDuplicateLitKey\n\n\t// MissingLitKey occurs when a map literal is missing a key expression.\n\t//\n\t// Example:\n\t//  var _ = map[string]int{1}\n\tMissingLitKey\n\n\t// InvalidLitIndex occurs when the key in a key-value element of a slice or\n\t// array literal is not an integer constant.\n\t//\n\t// Example:\n\t//  var i = 0\n\t//  var x = []string{i: \"world\"}\n\tInvalidLitIndex\n\n\t// OversizeArrayLit occurs when an array literal exceeds its length.\n\t//\n\t// Example:\n\t//  var _ = [2]int{1,2,3}\n\tOversizeArrayLit\n\n\t// MixedStructLit occurs when a struct literal contains a mix of positional\n\t// and named elements.\n\t//\n\t// Example:\n\t//  var _ = struct{i, j int}{i: 1, 2}\n\tMixedStructLit\n\n\t// InvalidStructLit occurs when a positional struct literal has an incorrect\n\t// number of values.\n\t//\n\t// Example:\n\t//  var _ = struct{i, j int}{1,2,3}\n\tInvalidStructLit\n\n\t// MissingLitField occurs when a struct literal refers to a field that does\n\t// not exist on the struct type.\n\t//\n\t// Example:\n\t//  var _ = struct{i int}{j: 2}\n\tMissingLitField\n\n\t// DuplicateLitField occurs when a struct literal contains duplicated\n\t// fields.\n\t//\n\t// Example:\n\t//  var _ = struct{i int}{i: 1, i: 2}\n\tDuplicateLitField\n\n\t// UnexportedLitField occurs when a positional struct literal implicitly\n\t// assigns an unexported field of an imported type.\n\tUnexportedLitField\n\n\t// InvalidLitField occurs when a field name is not a valid identifier.\n\t//\n\t// Example:\n\t//  var _ = struct{i int}{1: 1}\n\tInvalidLitField\n\n\t// UntypedLit occurs when a composite literal omits a required type\n\t// identifier.\n\t//\n\t// Example:\n\t//  type outer struct{\n\t//  \tinner struct { i int }\n\t//  }\n\t//\n\t//  var _ = outer{inner: {1}}\n\tUntypedLit\n\n\t// InvalidLit occurs when a composite literal expression does not match its\n\t// type.\n\t//\n\t// Example:\n\t//  type P *struct{\n\t//  \tx int\n\t//  }\n\t//  var _ = P {}\n\tInvalidLit\n\n\t// AmbiguousSelector occurs when a selector is ambiguous.\n\t//\n\t// Example:\n\t//  type E1 struct { i int }\n\t//  type E2 struct { i int }\n\t//  type T struct { E1; E2 }\n\t//\n\t//  var x T\n\t//  var _ = x.i\n\tAmbiguousSelector\n\n\t// UndeclaredImportedName occurs when a package-qualified identifier is\n\t// undeclared by the imported package.\n\t//\n\t// Example:\n\t//  import \"go/types\"\n\t//\n\t//  var _ = types.NotAnActualIdentifier\n\tUndeclaredImportedName\n\n\t// UnexportedName occurs when a selector refers to an unexported identifier\n\t// of an imported package.\n\t//\n\t// Example:\n\t//  import \"reflect\"\n\t//\n\t//  type _ reflect.flag\n\tUnexportedName\n\n\t// UndeclaredName occurs when an identifier is not declared in the current\n\t// scope.\n\t//\n\t// Example:\n\t//  var x T\n\tUndeclaredName\n\n\t// MissingFieldOrMethod occurs when a selector references a field or method\n\t// that does not exist.\n\t//\n\t// Example:\n\t//  type T struct {}\n\t//\n\t//  var x = T{}.f\n\tMissingFieldOrMethod\n\n\t// BadDotDotDotSyntax occurs when a \"...\" occurs in a context where it is\n\t// not valid.\n\t//\n\t// Example:\n\t//  var _ = map[int][...]int{0: {}}\n\tBadDotDotDotSyntax\n\n\t// NonVariadicDotDotDot occurs when a \"...\" is used on the final argument to\n\t// a non-variadic function.\n\t//\n\t// Example:\n\t//  func printArgs(s []string) {\n\t//  \tfor _, a := range s {\n\t//  \t\tprintln(a)\n\t//  \t}\n\t//  }\n\t//\n\t//  func f() {\n\t//  \ts := []string{\"a\", \"b\", \"c\"}\n\t//  \tprintArgs(s...)\n\t//  }\n\tNonVariadicDotDotDot\n\n\t// InvalidDotDotDot occurs when a \"...\" is used in a non-variadic built-in\n\t// function.\n\t//\n\t// Example:\n\t//  var s = []int{1, 2, 3}\n\t//  var l = len(s...)\n\tInvalidDotDotDot\n\n\t// UncalledBuiltin occurs when a built-in function is used as a\n\t// function-valued expression, instead of being called.\n\t//\n\t// Per the spec:\n\t//  \"The built-in functions do not have standard Go types, so they can only\n\t//  appear in call expressions; they cannot be used as function values.\"\n\t//\n\t// Example:\n\t//  var _ = copy\n\tUncalledBuiltin\n\n\t// InvalidAppend occurs when append is called with a first argument that is\n\t// not a slice.\n\t//\n\t// Example:\n\t//  var _ = append(1, 2)\n\tInvalidAppend\n\n\t// InvalidCap occurs when an argument to the cap built-in function is not of\n\t// supported type.\n\t//\n\t// See https://golang.org/ref/spec#Length_and_capacity for information on\n\t// which underlying types are supported as arguments to cap and len.\n\t//\n\t// Example:\n\t//  var s = 2\n\t//  var x = cap(s)\n\tInvalidCap\n\n\t// InvalidClose occurs when close(...) is called with an argument that is\n\t// not of channel type, or that is a receive-only channel.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tvar x int\n\t//  \tclose(x)\n\t//  }\n\tInvalidClose\n\n\t// InvalidCopy occurs when the arguments are not of slice type or do not\n\t// have compatible type.\n\t//\n\t// See https://golang.org/ref/spec#Appending_and_copying_slices for more\n\t// information on the type requirements for the copy built-in.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tvar x []int\n\t//  \ty := []int64{1,2,3}\n\t//  \tcopy(x, y)\n\t//  }\n\tInvalidCopy\n\n\t// InvalidComplex occurs when the complex built-in function is called with\n\t// arguments with incompatible types.\n\t//\n\t// Example:\n\t//  var _ = complex(float32(1), float64(2))\n\tInvalidComplex\n\n\t// InvalidDelete occurs when the delete built-in function is called with a\n\t// first argument that is not a map.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tm := \"hello\"\n\t//  \tdelete(m, \"e\")\n\t//  }\n\tInvalidDelete\n\n\t// InvalidImag occurs when the imag built-in function is called with an\n\t// argument that does not have complex type.\n\t//\n\t// Example:\n\t//  var _ = imag(int(1))\n\tInvalidImag\n\n\t// InvalidLen occurs when an argument to the len built-in function is not of\n\t// supported type.\n\t//\n\t// See https://golang.org/ref/spec#Length_and_capacity for information on\n\t// which underlying types are supported as arguments to cap and len.\n\t//\n\t// Example:\n\t//  var s = 2\n\t//  var x = len(s)\n\tInvalidLen\n\n\t// SwappedMakeArgs occurs when make is called with three arguments, and its\n\t// length argument is larger than its capacity argument.\n\t//\n\t// Example:\n\t//  var x = make([]int, 3, 2)\n\tSwappedMakeArgs\n\n\t// InvalidMake occurs when make is called with an unsupported type argument.\n\t//\n\t// See https://golang.org/ref/spec#Making_slices_maps_and_channels for\n\t// information on the types that may be created using make.\n\t//\n\t// Example:\n\t//  var x = make(int)\n\tInvalidMake\n\n\t// InvalidReal occurs when the real built-in function is called with an\n\t// argument that does not have complex type.\n\t//\n\t// Example:\n\t//  var _ = real(int(1))\n\tInvalidReal\n\n\t// InvalidAssert occurs when a type assertion is applied to a\n\t// value that is not of interface type.\n\t//\n\t// Example:\n\t//  var x = 1\n\t//  var _ = x.(float64)\n\tInvalidAssert\n\n\t// ImpossibleAssert occurs for a type assertion x.(T) when the value x of\n\t// interface cannot have dynamic type T, due to a missing or mismatching\n\t// method on T.\n\t//\n\t// Example:\n\t//  type T int\n\t//\n\t//  func (t *T) m() int { return int(*t) }\n\t//\n\t//  type I interface { m() int }\n\t//\n\t//  var x I\n\t//  var _ = x.(T)\n\tImpossibleAssert\n\n\t// InvalidConversion occurs when the argument type cannot be converted to the\n\t// target.\n\t//\n\t// See https://golang.org/ref/spec#Conversions for the rules of\n\t// convertibility.\n\t//\n\t// Example:\n\t//  var x float64\n\t//  var _ = string(x)\n\tInvalidConversion\n\n\t// InvalidUntypedConversion occurs when there is no valid implicit\n\t// conversion from an untyped value satisfying the type constraints of the\n\t// context in which it is used.\n\t//\n\t// Example:\n\t//  var _ = 1 + []int{}\n\tInvalidUntypedConversion\n\n\t// BadOffsetofSyntax occurs when unsafe.Offsetof is called with an argument\n\t// that is not a selector expression.\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  var x int\n\t//  var _ = unsafe.Offsetof(x)\n\tBadOffsetofSyntax\n\n\t// InvalidOffsetof occurs when unsafe.Offsetof is called with a method\n\t// selector, rather than a field selector, or when the field is embedded via\n\t// a pointer.\n\t//\n\t// Per the spec:\n\t//\n\t//  \"If f is an embedded field, it must be reachable without pointer\n\t//  indirections through fields of the struct. \"\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  type T struct { f int }\n\t//  type S struct { *T }\n\t//  var s S\n\t//  var _ = unsafe.Offsetof(s.f)\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  type S struct{}\n\t//\n\t//  func (S) m() {}\n\t//\n\t//  var s S\n\t//  var _ = unsafe.Offsetof(s.m)\n\tInvalidOffsetof\n\n\t// UnusedExpr occurs when a side-effect free expression is used as a\n\t// statement. Such a statement has no effect.\n\t//\n\t// Example:\n\t//  func f(i int) {\n\t//  \ti*i\n\t//  }\n\tUnusedExpr\n\n\t// UnusedVar occurs when a variable is declared but unused.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tx := 1\n\t//  }\n\tUnusedVar\n\n\t// MissingReturn occurs when a function with results is missing a return\n\t// statement.\n\t//\n\t// Example:\n\t//  func f() int {}\n\tMissingReturn\n\n\t// WrongResultCount occurs when a return statement returns an incorrect\n\t// number of values.\n\t//\n\t// Example:\n\t//  func ReturnOne() int {\n\t//  \treturn 1, 2\n\t//  }\n\tWrongResultCount\n\n\t// OutOfScopeResult occurs when the name of a value implicitly returned by\n\t// an empty return statement is shadowed in a nested scope.\n\t//\n\t// Example:\n\t//  func factor(n int) (i int) {\n\t//  \tfor i := 2; i < n; i++ {\n\t//  \t\tif n%i == 0 {\n\t//  \t\t\treturn\n\t//  \t\t}\n\t//  \t}\n\t//  \treturn 0\n\t//  }\n\tOutOfScopeResult\n\n\t// InvalidCond occurs when an if condition is not a boolean expression.\n\t//\n\t// Example:\n\t//  func checkReturn(i int) {\n\t//  \tif i {\n\t//  \t\tpanic(\"non-zero return\")\n\t//  \t}\n\t//  }\n\tInvalidCond\n\n\t// InvalidPostDecl occurs when there is a declaration in a for-loop post\n\t// statement.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tfor i := 0; i < 10; j := 0 {}\n\t//  }\n\tInvalidPostDecl\n\n\t// InvalidIterVar occurs when two iteration variables are used while ranging\n\t// over a channel.\n\t//\n\t// Example:\n\t//  func f(c chan int) {\n\t//  \tfor k, v := range c {\n\t//  \t\tprintln(k, v)\n\t//  \t}\n\t//  }\n\tInvalidIterVar\n\n\t// InvalidRangeExpr occurs when the type of a range expression is not\n\t// a valid type for use with a range loop.\n\t//\n\t// Example:\n\t//  func f(f float64) {\n\t//  \tfor j := range f {\n\t//  \t\tprintln(j)\n\t//  \t}\n\t//  }\n\tInvalidRangeExpr\n\n\t// MisplacedBreak occurs when a break statement is not within a for, switch,\n\t// or select statement of the innermost function definition.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tbreak\n\t//  }\n\tMisplacedBreak\n\n\t// MisplacedContinue occurs when a continue statement is not within a for\n\t// loop of the innermost function definition.\n\t//\n\t// Example:\n\t//  func sumeven(n int) int {\n\t//  \tproceed := func() {\n\t//  \t\tcontinue\n\t//  \t}\n\t//  \tsum := 0\n\t//  \tfor i := 1; i <= n; i++ {\n\t//  \t\tif i % 2 != 0 {\n\t//  \t\t\tproceed()\n\t//  \t\t}\n\t//  \t\tsum += i\n\t//  \t}\n\t//  \treturn sum\n\t//  }\n\tMisplacedContinue\n\n\t// MisplacedFallthrough occurs when a fallthrough statement is not within an\n\t// expression switch.\n\t//\n\t// Example:\n\t//  func typename(i interface{}) string {\n\t//  \tswitch i.(type) {\n\t//  \tcase int64:\n\t//  \t\tfallthrough\n\t//  \tcase int:\n\t//  \t\treturn \"int\"\n\t//  \t}\n\t//  \treturn \"unsupported\"\n\t//  }\n\tMisplacedFallthrough\n\n\t// DuplicateCase occurs when a type or expression switch has duplicate\n\t// cases.\n\t//\n\t// Example:\n\t//  func printInt(i int) {\n\t//  \tswitch i {\n\t//  \tcase 1:\n\t//  \t\tprintln(\"one\")\n\t//  \tcase 1:\n\t//  \t\tprintln(\"One\")\n\t//  \t}\n\t//  }\n\tDuplicateCase\n\n\t// DuplicateDefault occurs when a type or expression switch has multiple\n\t// default clauses.\n\t//\n\t// Example:\n\t//  func printInt(i int) {\n\t//  \tswitch i {\n\t//  \tcase 1:\n\t//  \t\tprintln(\"one\")\n\t//  \tdefault:\n\t//  \t\tprintln(\"One\")\n\t//  \tdefault:\n\t//  \t\tprintln(\"1\")\n\t//  \t}\n\t//  }\n\tDuplicateDefault\n\n\t// BadTypeKeyword occurs when a .(type) expression is used anywhere other\n\t// than a type switch.\n\t//\n\t// Example:\n\t//  type I interface {\n\t//  \tm()\n\t//  }\n\t//  var t I\n\t//  var _ = t.(type)\n\tBadTypeKeyword\n\n\t// InvalidTypeSwitch occurs when .(type) is used on an expression that is\n\t// not of interface type.\n\t//\n\t// Example:\n\t//  func f(i int) {\n\t//  \tswitch x := i.(type) {}\n\t//  }\n\tInvalidTypeSwitch\n\n\t// InvalidExprSwitch occurs when a switch expression is not comparable.\n\t//\n\t// Example:\n\t//  func _() {\n\t//  \tvar a struct{ _ func() }\n\t//  \tswitch a /* ERROR cannot switch on a */ {\n\t//  \t}\n\t//  }\n\tInvalidExprSwitch\n\n\t// InvalidSelectCase occurs when a select case is not a channel send or\n\t// receive.\n\t//\n\t// Example:\n\t//  func checkChan(c <-chan int) bool {\n\t//  \tselect {\n\t//  \tcase c:\n\t//  \t\treturn true\n\t//  \tdefault:\n\t//  \t\treturn false\n\t//  \t}\n\t//  }\n\tInvalidSelectCase\n\n\t// UndeclaredLabel occurs when an undeclared label is jumped to.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  \tgoto L\n\t//  }\n\tUndeclaredLabel\n\n\t// DuplicateLabel occurs when a label is declared more than once.\n\t//\n\t// Example:\n\t//  func f() int {\n\t//  L:\n\t//  L:\n\t//  \treturn 1\n\t//  }\n\tDuplicateLabel\n\n\t// MisplacedLabel occurs when a break or continue label is not on a for,\n\t// switch, or select statement.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  L:\n\t//  \ta := []int{1,2,3}\n\t//  \tfor _, e := range a {\n\t//  \t\tif e > 10 {\n\t//  \t\t\tbreak L\n\t//  \t\t}\n\t//  \t\tprintln(a)\n\t//  \t}\n\t//  }\n\tMisplacedLabel\n\n\t// UnusedLabel occurs when a label is declared and not used.\n\t//\n\t// Example:\n\t//  func f() {\n\t//  L:\n\t//  }\n\tUnusedLabel\n\n\t// JumpOverDecl occurs when a label jumps over a variable declaration.\n\t//\n\t// Example:\n\t//  func f() int {\n\t//  \tgoto L\n\t//  \tx := 2\n\t//  L:\n\t//  \tx++\n\t//  \treturn x\n\t//  }\n\tJumpOverDecl\n\n\t// JumpIntoBlock occurs when a forward jump goes to a label inside a nested\n\t// block.\n\t//\n\t// Example:\n\t//  func f(x int) {\n\t//  \tgoto L\n\t//  \tif x > 0 {\n\t//  \tL:\n\t//  \t\tprint(\"inside block\")\n\t//  \t}\n\t// }\n\tJumpIntoBlock\n\n\t// InvalidMethodExpr occurs when a pointer method is called but the argument\n\t// is not addressable.\n\t//\n\t// Example:\n\t//  type T struct {}\n\t//\n\t//  func (*T) m() int { return 1 }\n\t//\n\t//  var _ = T.m(T{})\n\tInvalidMethodExpr\n\n\t// WrongArgCount occurs when too few or too many arguments are passed by a\n\t// function call.\n\t//\n\t// Example:\n\t//  func f(i int) {}\n\t//  var x = f()\n\tWrongArgCount\n\n\t// InvalidCall occurs when an expression is called that is not of function\n\t// type.\n\t//\n\t// Example:\n\t//  var x = \"x\"\n\t//  var y = x()\n\tInvalidCall\n\n\t// UnusedResults occurs when a restricted expression-only built-in function\n\t// is suspended via go or defer. Such a suspension discards the results of\n\t// these side-effect free built-in functions, and therefore is ineffectual.\n\t//\n\t// Example:\n\t//  func f(a []int) int {\n\t//  \tdefer len(a)\n\t//  \treturn i\n\t//  }\n\tUnusedResults\n\n\t// InvalidDefer occurs when a deferred expression is not a function call,\n\t// for example if the expression is a type conversion.\n\t//\n\t// Example:\n\t//  func f(i int) int {\n\t//  \tdefer int32(i)\n\t//  \treturn i\n\t//  }\n\tInvalidDefer\n\n\t// InvalidGo occurs when a go expression is not a function call, for example\n\t// if the expression is a type conversion.\n\t//\n\t// Example:\n\t//  func f(i int) int {\n\t//  \tgo int32(i)\n\t//  \treturn i\n\t//  }\n\tInvalidGo\n\n\t// BadDecl occurs when a declaration has invalid syntax.\n\tBadDecl\n\n\t// RepeatedDecl occurs when an identifier occurs more than once on the left\n\t// hand side of a short variable declaration.\n\t//\n\t// Example:\n\t//  func _() {\n\t//  \tx, y, y := 1, 2, 3\n\t//  }\n\tRepeatedDecl\n\n\t// InvalidUnsafeAdd occurs when unsafe.Add is called with a\n\t// length argument that is not of integer type.\n\t// It also occurs if it is used in a package compiled for a\n\t// language version before go1.17.\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  var p unsafe.Pointer\n\t//  var _ = unsafe.Add(p, float64(1))\n\tInvalidUnsafeAdd\n\n\t// InvalidUnsafeSlice occurs when unsafe.Slice is called with a\n\t// pointer argument that is not of pointer type or a length argument\n\t// that is not of integer type, negative, or out of bounds.\n\t// It also occurs if it is used in a package compiled for a language\n\t// version before go1.17.\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  var x int\n\t//  var _ = unsafe.Slice(x, 1)\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  var x int\n\t//  var _ = unsafe.Slice(&x, float64(1))\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  var x int\n\t//  var _ = unsafe.Slice(&x, -1)\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  var x int\n\t//  var _ = unsafe.Slice(&x, uint64(1) << 63)\n\tInvalidUnsafeSlice\n\n\t// UnsupportedFeature occurs when a language feature is used that is not\n\t// supported at this Go version.\n\tUnsupportedFeature\n\n\t// NotAGenericType occurs when a non-generic type is used where a generic\n\t// type is expected: in type or function instantiation.\n\t//\n\t// Example:\n\t//  type T int\n\t//\n\t//  var _ T[int]\n\tNotAGenericType\n\n\t// WrongTypeArgCount occurs when a type or function is instantiated with an\n\t// incorrect number of type arguments, including when a generic type or\n\t// function is used without instantiation.\n\t//\n\t// Errors involving failed type inference are assigned other error codes.\n\t//\n\t// Example:\n\t//  type T[p any] int\n\t//\n\t//  var _ T[int, string]\n\t//\n\t// Example:\n\t//  func f[T any]() {}\n\t//\n\t//  var x = f\n\tWrongTypeArgCount\n\n\t// CannotInferTypeArgs occurs when type or function type argument inference\n\t// fails to infer all type arguments.\n\t//\n\t// Example:\n\t//  func f[T any]() {}\n\t//\n\t//  func _() {\n\t//  \tf()\n\t//  }\n\tCannotInferTypeArgs\n\n\t// InvalidTypeArg occurs when a type argument does not satisfy its\n\t// corresponding type parameter constraints.\n\t//\n\t// Example:\n\t//  type T[P ~int] struct{}\n\t//\n\t//  var _ T[string]\n\tInvalidTypeArg // arguments? InferenceFailed\n\n\t// InvalidInstanceCycle occurs when an invalid cycle is detected\n\t// within the instantiation graph.\n\t//\n\t// Example:\n\t//  func f[T any]() { f[*T]() }\n\tInvalidInstanceCycle\n\n\t// InvalidUnion occurs when an embedded union or approximation element is\n\t// not valid.\n\t//\n\t// Example:\n\t//  type _ interface {\n\t//   \t~int | interface{ m() }\n\t//  }\n\tInvalidUnion\n\n\t// MisplacedConstraintIface occurs when a constraint-type interface is used\n\t// outside of constraint position.\n\t//\n\t// Example:\n\t//   type I interface { ~int }\n\t//\n\t//   var _ I\n\tMisplacedConstraintIface\n\n\t// InvalidMethodTypeParams occurs when methods have type parameters.\n\t//\n\t// It cannot be encountered with an AST parsed using go/parser.\n\tInvalidMethodTypeParams\n\n\t// MisplacedTypeParam occurs when a type parameter is used in a place where\n\t// it is not permitted.\n\t//\n\t// Example:\n\t//  type T[P any] P\n\t//\n\t// Example:\n\t//  type T[P any] struct{ *P }\n\tMisplacedTypeParam\n\n\t// InvalidUnsafeSliceData occurs when unsafe.SliceData is called with\n\t// an argument that is not of slice type. It also occurs if it is used\n\t// in a package compiled for a language version before go1.20.\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  var x int\n\t//  var _ = unsafe.SliceData(x)\n\tInvalidUnsafeSliceData\n\n\t// InvalidUnsafeString occurs when unsafe.String is called with\n\t// a length argument that is not of integer type, negative, or\n\t// out of bounds. It also occurs if it is used in a package\n\t// compiled for a language version before go1.20.\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  var b [10]byte\n\t//  var _ = unsafe.String(&b[0], -1)\n\tInvalidUnsafeString\n\n\t// InvalidClear occurs when clear is called with an argument\n\t// that is not of map or slice type.\n\t//\n\t// Example:\n\t//  func _(x int) {\n\t//  \tclear(x)\n\t//  }\n\tInvalidClear\n\n\t// TypeTooLarge occurs if unsafe.Sizeof or unsafe.Offsetof is\n\t// called with an expression whose type is too large.\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  type E [1 << 31 - 1]int\n\t//  var a [1 << 31]E\n\t//  var _ = unsafe.Sizeof(a)\n\t//\n\t// Example:\n\t//  import \"unsafe\"\n\t//\n\t//  type E [1 << 31 - 1]int\n\t//  var s struct {\n\t//  \t_ [1 << 31]E\n\t//  \tx int\n\t//  }\n\t// var _ = unsafe.Offsetof(s.x)\n\tTypeTooLarge\n\n\t// InvalidMinMaxOperand occurs if min or max is called\n\t// with an operand that cannot be ordered because it\n\t// does not support the < operator.\n\t//\n\t// Example:\n\t//  const _ = min(true)\n\t//\n\t// Example:\n\t//  var s, t []byte\n\t//  var _ = max(s, t)\n\tInvalidMinMaxOperand\n\n\t// TooNew indicates that, through build tags or a go.mod file,\n\t// a source file requires a version of Go that is newer than\n\t// the logic of the type checker. As a consequence, the type\n\t// checker may produce spurious errors or fail to report real\n\t// errors. The solution is to rebuild the application with a\n\t// newer Go release.\n\tTooNew\n)\nconst (\n\t// InvalidSyntaxTree occurs if an invalid syntax tree is provided\n\t// to the type checker. It should never happen.\n\tInvalidSyntaxTree Code = -1\n)\nfunc (i Code) String() string\n\n"}, {"path": "stdlib/vendor-golang.org-x-crypto-chacha20poly1305.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-crypto-chacha20poly1305", "content": ""}, {"path": "stdlib/internal-profilerecord.md", "category": "stdlib", "name": "stdlib/internal-profilerecord", "content": "package profilerecord // import \"internal/profilerecord\"\n\nPackage profilerecord holds internal types used to represent profiling records\nwith deep stack traces.\n\nTODO: Consider moving this to internal/runtime, see golang.org/issue/65355.\n\nTYPES\n\ntype BlockProfileRecord struct {\n\tCount  int64\n\tCycles int64\n\tStack  []uintptr\n}\n\ntype MemProfileRecord struct {\n\tAllocBytes, FreeBytes     int64\n\tAllocObjects, FreeObjects int64\n\tStack                     []uintptr\n}\n\nfunc (r *MemProfileRecord) InUseBytes() int64\n\nfunc (r *MemProfileRecord) InUseObjects() int64\n\ntype StackRecord struct {\n\tStack []uintptr\n}\n\n"}, {"path": "stdlib/log-slog-internal.md", "category": "stdlib", "name": "stdlib/log-slog-internal", "content": "package internal // import \"log/slog/internal\"\n\n\nVARIABLES\n\nvar IgnorePC = false\n    If IgnorePC is true, do not invoke runtime.Callers to get the pc. This is\n    solely for benchmarking the slowdown from runtime.Callers.\n\n"}, {"path": "stdlib/vendor-golang.org-x-net-http2-hpack.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-net-http2-hpack", "content": ""}, {"path": "stdlib/crypto-internal-fips140-sha256.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-sha256", "content": "package sha256 // import \"crypto/internal/fips140/sha256\"\n\nPackage sha256 implements the SHA-224 and SHA-256 hash algorithms as defined in\nFIPS 180-4.\n\nTYPES\n\ntype Digest struct {\n\t// Has unexported fields.\n}\n    Digest is a SHA-224 or SHA-256 hash.Hash implementation.\n\nfunc New() *Digest\n    New returns a new Digest computing the SHA-256 hash.\n\nfunc New224() *Digest\n    New224 returns a new Digest computing the SHA-224 hash.\n\nfunc (d *Digest) AppendBinary(b []byte) ([]byte, error)\n\nfunc (d *Digest) BlockSize() int\n\nfunc (d *Digest) Clone() (hash.Cloner, error)\n\nfunc (d *Digest) MarshalBinary() ([]byte, error)\n\nfunc (d *Digest) Reset()\n\nfunc (d *Digest) Size() int\n\nfunc (d *Digest) Sum(in []byte) []byte\n\nfunc (d *Digest) UnmarshalBinary(b []byte) error\n\nfunc (d *Digest) Write(p []byte) (nn int, err error)\n\n"}, {"path": "stdlib/internal-trace-testtrace.md", "category": "stdlib", "name": "stdlib/internal-trace-testtrace", "content": "package testtrace // import \"internal/trace/testtrace\"\n\n\nTYPES\n\ntype Expectation struct {\n\t// Has unexported fields.\n}\n    Expectation represents the expected result of some operation.\n\nfunc ExpectSuccess() *Expectation\n    ExpectSuccess returns an Expectation that trivially expects success.\n\nfunc ParseExpectation(data []byte) (*Expectation, error)\n    ParseExpectation parses the serialized form of an Expectation.\n\nfunc ParseFile(testPath string) (io.Reader, version.Version, *Expectation, error)\n    ParseFile parses a test file generated by the testgen package.\n\nfunc (e *Expectation) Check(err error) error\n    Check validates whether err conforms to the expectation. Returns an error if\n    it does not conform.\n\n    Conformance means that if failure is true, then err must be non-nil.\n    If err is non-nil, then it must match errorMatcher.\n\ntype Validator struct {\n\tGoVersion version.Version\n\n\t// Has unexported fields.\n}\n    Validator is a type used for validating a stream of trace.Events.\n\nfunc NewValidator() *Validator\n    NewValidator creates a new Validator.\n\nfunc (v *Validator) Event(ev trace.Event) error\n    Event validates ev as the next event in a stream of trace.Events.\n\n    Returns an error if validation fails.\n\nfunc (v *Validator) SkipClockSnapshotChecks()\n    SkipClockSnapshotChecks causes the validator to skip checks on the clock\n    snapshots.\n\n    Some platforms like Windows, with a small enough trace period, are unable\n    to produce monotonically increasing timestamps due to very coarse clock\n    granularity.\n\n"}, {"path": "stdlib/crypto-internal-fips140-drbg.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-drbg", "content": "package drbg // import \"crypto/internal/fips140/drbg\"\n\nPackage drbg provides cryptographically secure random bytes usable by FIPS code.\nIn FIPS mode it uses an SP 800-90A Rev. 1 Deterministic Random Bit Generator\n(DRBG). Otherwise, it uses the operating system's random number generator.\n\nCONSTANTS\n\nconst (\n\tSeedSize = keySize + aes.BlockSize\n)\n\nFUNCTIONS\n\nfunc Read(b []byte)\n    Read fills b with cryptographically secure random bytes. In FIPS mode,\n    it uses an SP 800-90A Rev. 1 Deterministic Random Bit Generator (DRBG).\n    Otherwise, it uses the operating system's random number generator.\n\nfunc ReadWithReader(r io.Reader, b []byte) error\n    ReadWithReader uses Reader to fill b with cryptographically secure random\n    bytes. It is intended for use in APIs that expose a rand io.Reader.\n\n    If Reader is not the default Reader from crypto/rand, randutil.MaybeReadByte\n    and fips140.RecordNonApproved are called.\n\nfunc ReadWithReaderDeterministic(r io.Reader, b []byte) error\n    ReadWithReaderDeterministic is like ReadWithReader, but it doesn't call\n    randutil.MaybeReadByte on non-default Readers.\n\n\nTYPES\n\ntype Counter struct {\n\t// Has unexported fields.\n}\n    Counter is an SP 800-90A Rev. 1 CTR_DRBG instantiated with AES-256.\n\n    Per Table 3, it has a security strength of 256 bits, a seed size of 384\n    bits, a counter length of 128 bits, a reseed interval of 2^48 requests,\n    and a maximum request size of 2^19 bits (2^16 bytes, 64 KiB).\n\n    We support a narrow range of parameters that fit the needs of our RNG:\n    AES-256, no derivation function, no personalization string, no prediction\n    resistance, and 384-bit additional input.\n\n    WARNING: this type provides tightly scoped support for the DRBG\n    functionality we need for FIPS 140-3 _only_. This type _should not_ be used\n    outside of the FIPS 140-3 module for any other use.\n\n    In particular, as documented, Counter does not support the derivation\n    function, or personalization strings which are necessary for safely using\n    this DRBG for generic purposes without leaking sensitive values.\n\nfunc NewCounter(entropy *[SeedSize]byte) *Counter\n\nfunc (c *Counter) Generate(out []byte, additionalInput *[SeedSize]byte) (reseedRequired bool)\n    Generate produces at most maxRequestSize bytes of random data in out.\n\nfunc (c *Counter) Reseed(entropy, additionalInput *[SeedSize]byte)\n\ntype DefaultReader interface {\n\t// Has unexported methods.\n}\n    DefaultReader is a sentinel type, embedded in the default\n    crypto/rand.Reader, used to recognize it when passed to APIs that accept a\n    rand io.Reader.\n\n"}, {"path": "stdlib/internal-coverage-slicereader.md", "category": "stdlib", "name": "stdlib/internal-coverage-slicereader", "content": "package slicereader // import \"internal/coverage/slicereader\"\n\n\nTYPES\n\ntype Reader struct {\n\t// Has unexported fields.\n}\n\nfunc NewReader(b []byte, readonly bool) *Reader\n\nfunc (r *Reader) Offset() int64\n\nfunc (r *Reader) Read(b []byte) (int, error)\n\nfunc (r *Reader) ReadString(len int64) string\n\nfunc (r *Reader) ReadULEB128() (value uint64)\n\nfunc (r *Reader) ReadUint32() uint32\n\nfunc (r *Reader) ReadUint64() uint64\n\nfunc (r *Reader) ReadUint8() uint8\n\nfunc (r *Reader) Seek(offset int64, whence int) (ret int64, err error)\n\n"}, {"path": "stdlib/internal-trace-internal-tracev1.md", "category": "stdlib", "name": "stdlib/internal-trace-internal-tracev1", "content": "package tracev1 // import \"internal/trace/internal/tracev1\"\n\nPackage tracev1 implements a parser for Go execution traces from versions\n1.11\u20131.21.\n\nThe package started as a copy of Go 1.19's internal/trace, but has been\noptimized to be faster while using less memory and fewer allocations. It has\nbeen further modified for the specific purpose of converting traces to the new\n1.22+ format.\n\nCONSTANTS\n\nconst (\n\t// Special P identifiers:\n\tFakeP    = 1000000 + iota\n\tTimerP   // contains timer unblocks\n\tNetpollP // contains network unblocks\n\tSyscallP // contains returns from syscalls\n\tGCP      // contains GC state\n\tProfileP // contains recording of CPU profile samples\n)\n\nVARIABLES\n\nvar ErrTimeOrder = errors.New(\"time stamps out of order\")\n    ErrTimeOrder is returned by Parse when the trace contains time stamps that\n    do not respect actual event ordering.\n\nvar EventDescriptions = [256]struct {\n\tName       string\n\tminVersion version.Version\n\tStack      bool\n\tArgs       []string\n\tSArgs      []string // string arguments\n}{\n\tEvNone:              {\"None\", 5, false, []string{}, nil},\n\tEvBatch:             {\"Batch\", 5, false, []string{\"p\", \"ticks\"}, nil},\n\tEvFrequency:         {\"Frequency\", 5, false, []string{\"freq\"}, nil},\n\tEvStack:             {\"Stack\", 5, false, []string{\"id\", \"siz\"}, nil},\n\tEvGomaxprocs:        {\"Gomaxprocs\", 5, true, []string{\"procs\"}, nil},\n\tEvProcStart:         {\"ProcStart\", 5, false, []string{\"thread\"}, nil},\n\tEvProcStop:          {\"ProcStop\", 5, false, []string{}, nil},\n\tEvGCStart:           {\"GCStart\", 5, true, []string{\"seq\"}, nil},\n\tEvGCDone:            {\"GCDone\", 5, false, []string{}, nil},\n\tEvSTWStart:          {\"GCSTWStart\", 5, false, []string{\"kindid\"}, []string{\"kind\"}},\n\tEvSTWDone:           {\"GCSTWDone\", 5, false, []string{}, nil},\n\tEvGCSweepStart:      {\"GCSweepStart\", 5, true, []string{}, nil},\n\tEvGCSweepDone:       {\"GCSweepDone\", 5, false, []string{\"swept\", \"reclaimed\"}, nil},\n\tEvGoCreate:          {\"GoCreate\", 5, true, []string{\"g\", \"stack\"}, nil},\n\tEvGoStart:           {\"GoStart\", 5, false, []string{\"g\", \"seq\"}, nil},\n\tEvGoEnd:             {\"GoEnd\", 5, false, []string{}, nil},\n\tEvGoStop:            {\"GoStop\", 5, true, []string{}, nil},\n\tEvGoSched:           {\"GoSched\", 5, true, []string{}, nil},\n\tEvGoPreempt:         {\"GoPreempt\", 5, true, []string{}, nil},\n\tEvGoSleep:           {\"GoSleep\", 5, true, []string{}, nil},\n\tEvGoBlock:           {\"GoBlock\", 5, true, []string{}, nil},\n\tEvGoUnblock:         {\"GoUnblock\", 5, true, []string{\"g\", \"seq\"}, nil},\n\tEvGoBlockSend:       {\"GoBlockSend\", 5, true, []string{}, nil},\n\tEvGoBlockRecv:       {\"GoBlockRecv\", 5, true, []string{}, nil},\n\tEvGoBlockSelect:     {\"GoBlockSelect\", 5, true, []string{}, nil},\n\tEvGoBlockSync:       {\"GoBlockSync\", 5, true, []string{}, nil},\n\tEvGoBlockCond:       {\"GoBlockCond\", 5, true, []string{}, nil},\n\tEvGoBlockNet:        {\"GoBlockNet\", 5, true, []string{}, nil},\n\tEvGoSysCall:         {\"GoSysCall\", 5, true, []string{}, nil},\n\tEvGoSysExit:         {\"GoSysExit\", 5, false, []string{\"g\", \"seq\", \"ts\"}, nil},\n\tEvGoSysBlock:        {\"GoSysBlock\", 5, false, []string{}, nil},\n\tEvGoWaiting:         {\"GoWaiting\", 5, false, []string{\"g\"}, nil},\n\tEvGoInSyscall:       {\"GoInSyscall\", 5, false, []string{\"g\"}, nil},\n\tEvHeapAlloc:         {\"HeapAlloc\", 5, false, []string{\"mem\"}, nil},\n\tEvHeapGoal:          {\"HeapGoal\", 5, false, []string{\"mem\"}, nil},\n\tEvTimerGoroutine:    {\"TimerGoroutine\", 5, false, []string{\"g\"}, nil},\n\tEvFutileWakeup:      {\"FutileWakeup\", 5, false, []string{}, nil},\n\tEvString:            {\"String\", 7, false, []string{}, nil},\n\tEvGoStartLocal:      {\"GoStartLocal\", 7, false, []string{\"g\"}, nil},\n\tEvGoUnblockLocal:    {\"GoUnblockLocal\", 7, true, []string{\"g\"}, nil},\n\tEvGoSysExitLocal:    {\"GoSysExitLocal\", 7, false, []string{\"g\", \"ts\"}, nil},\n\tEvGoStartLabel:      {\"GoStartLabel\", 8, false, []string{\"g\", \"seq\", \"labelid\"}, []string{\"label\"}},\n\tEvGoBlockGC:         {\"GoBlockGC\", 8, true, []string{}, nil},\n\tEvGCMarkAssistStart: {\"GCMarkAssistStart\", 9, true, []string{}, nil},\n\tEvGCMarkAssistDone:  {\"GCMarkAssistDone\", 9, false, []string{}, nil},\n\tEvUserTaskCreate:    {\"UserTaskCreate\", 11, true, []string{\"taskid\", \"pid\", \"typeid\"}, []string{\"name\"}},\n\tEvUserTaskEnd:       {\"UserTaskEnd\", 11, true, []string{\"taskid\"}, nil},\n\tEvUserRegion:        {\"UserRegion\", 11, true, []string{\"taskid\", \"mode\", \"typeid\"}, []string{\"name\"}},\n\tEvUserLog:           {\"UserLog\", 11, true, []string{\"id\", \"keyid\"}, []string{\"category\", \"message\"}},\n\tEvCPUSample:         {\"CPUSample\", 19, true, []string{\"ts\", \"p\", \"g\"}, nil},\n}\n\nTYPES\n\ntype Event struct {\n\tTs    Timestamp // timestamp in nanoseconds\n\tG     uint64    // G on which the event happened\n\tArgs  [4]uint64 // event-type-specific arguments\n\tStkID uint32    // unique stack ID\n\tP     int32     // P on which the event happened (can be a real P or one of TimerP, NetpollP, SyscallP)\n\tType  EventType // one of Ev*\n}\n    Event describes one event in the trace.\n\nfunc (ev *Event) String() string\n\ntype EventType uint8\n\nconst (\n\tEvNone              EventType = 0  // unused\n\tEvBatch             EventType = 1  // start of per-P batch of events [pid, timestamp]\n\tEvFrequency         EventType = 2  // contains tracer timer frequency [frequency (ticks per second)]\n\tEvStack             EventType = 3  // stack [stack id, number of PCs, array of {PC, func string ID, file string ID, line}]\n\tEvGomaxprocs        EventType = 4  // current value of GOMAXPROCS [timestamp, GOMAXPROCS, stack id]\n\tEvProcStart         EventType = 5  // start of P [timestamp, thread id]\n\tEvProcStop          EventType = 6  // stop of P [timestamp]\n\tEvGCStart           EventType = 7  // GC start [timestamp, seq, stack id]\n\tEvGCDone            EventType = 8  // GC done [timestamp]\n\tEvSTWStart          EventType = 9  // GC mark termination start [timestamp, kind]\n\tEvSTWDone           EventType = 10 // GC mark termination done [timestamp]\n\tEvGCSweepStart      EventType = 11 // GC sweep start [timestamp, stack id]\n\tEvGCSweepDone       EventType = 12 // GC sweep done [timestamp, swept, reclaimed]\n\tEvGoCreate          EventType = 13 // goroutine creation [timestamp, new goroutine id, new stack id, stack id]\n\tEvGoStart           EventType = 14 // goroutine starts running [timestamp, goroutine id, seq]\n\tEvGoEnd             EventType = 15 // goroutine ends [timestamp]\n\tEvGoStop            EventType = 16 // goroutine stops (like in select{}) [timestamp, stack]\n\tEvGoSched           EventType = 17 // goroutine calls Gosched [timestamp, stack]\n\tEvGoPreempt         EventType = 18 // goroutine is preempted [timestamp, stack]\n\tEvGoSleep           EventType = 19 // goroutine calls Sleep [timestamp, stack]\n\tEvGoBlock           EventType = 20 // goroutine blocks [timestamp, stack]\n\tEvGoUnblock         EventType = 21 // goroutine is unblocked [timestamp, goroutine id, seq, stack]\n\tEvGoBlockSend       EventType = 22 // goroutine blocks on chan send [timestamp, stack]\n\tEvGoBlockRecv       EventType = 23 // goroutine blocks on chan recv [timestamp, stack]\n\tEvGoBlockSelect     EventType = 24 // goroutine blocks on select [timestamp, stack]\n\tEvGoBlockSync       EventType = 25 // goroutine blocks on Mutex/RWMutex [timestamp, stack]\n\tEvGoBlockCond       EventType = 26 // goroutine blocks on Cond [timestamp, stack]\n\tEvGoBlockNet        EventType = 27 // goroutine blocks on network [timestamp, stack]\n\tEvGoSysCall         EventType = 28 // syscall enter [timestamp, stack]\n\tEvGoSysExit         EventType = 29 // syscall exit [timestamp, goroutine id, seq, real timestamp]\n\tEvGoSysBlock        EventType = 30 // syscall blocks [timestamp]\n\tEvGoWaiting         EventType = 31 // denotes that goroutine is blocked when tracing starts [timestamp, goroutine id]\n\tEvGoInSyscall       EventType = 32 // denotes that goroutine is in syscall when tracing starts [timestamp, goroutine id]\n\tEvHeapAlloc         EventType = 33 // gcController.heapLive change [timestamp, heap live bytes]\n\tEvHeapGoal          EventType = 34 // gcController.heapGoal change [timestamp, heap goal bytes]\n\tEvTimerGoroutine    EventType = 35 // denotes timer goroutine [timer goroutine id]\n\tEvFutileWakeup      EventType = 36 // denotes that the previous wakeup of this goroutine was futile [timestamp]\n\tEvString            EventType = 37 // string dictionary entry [ID, length, string]\n\tEvGoStartLocal      EventType = 38 // goroutine starts running on the same P as the last event [timestamp, goroutine id]\n\tEvGoUnblockLocal    EventType = 39 // goroutine is unblocked on the same P as the last event [timestamp, goroutine id, stack]\n\tEvGoSysExitLocal    EventType = 40 // syscall exit on the same P as the last event [timestamp, goroutine id, real timestamp]\n\tEvGoStartLabel      EventType = 41 // goroutine starts running with label [timestamp, goroutine id, seq, label string id]\n\tEvGoBlockGC         EventType = 42 // goroutine blocks on GC assist [timestamp, stack]\n\tEvGCMarkAssistStart EventType = 43 // GC mark assist start [timestamp, stack]\n\tEvGCMarkAssistDone  EventType = 44 // GC mark assist done [timestamp]\n\tEvUserTaskCreate    EventType = 45 // trace.NewTask [timestamp, internal task id, internal parent id, stack, name string]\n\tEvUserTaskEnd       EventType = 46 // end of task [timestamp, internal task id, stack]\n\tEvUserRegion        EventType = 47 // trace.WithRegion [timestamp, internal task id, mode(0:start, 1:end), name string]\n\tEvUserLog           EventType = 48 // trace.Log [timestamp, internal id, key string id, stack, value string]\n\tEvCPUSample         EventType = 49 // CPU profiling sample [timestamp, stack, real timestamp, real P id (-1 when absent), goroutine id]\n\tEvCount             EventType = 50\n)\n    Event types in the trace. Verbatim copy from src/runtime/trace.go with the\n    \"trace\" prefix removed.\n\ntype Events struct {\n\t// Has unexported fields.\n}\n\nfunc (l *Events) All() func(yield func(ev *Event) bool)\n\nfunc (l *Events) Len() int\n\nfunc (l *Events) Less(i, j int) bool\n\nfunc (l *Events) Peek() (*Event, bool)\n\nfunc (l *Events) Pop() (*Event, bool)\n\nfunc (l *Events) Ptr(i int) *Event\n\nfunc (l *Events) Swap(i, j int)\n\ntype Frame struct {\n\tPC uint64\n\t// string ID of the function name\n\tFn uint64\n\t// string ID of the file name\n\tFile uint64\n\tLine int\n}\n    Frame is a frame in stack traces.\n\ntype STWReason int\n\nconst (\n\tSTWUnknown                 STWReason = 0\n\tSTWGCMarkTermination       STWReason = 1\n\tSTWGCSweepTermination      STWReason = 2\n\tSTWWriteHeapDump           STWReason = 3\n\tSTWGoroutineProfile        STWReason = 4\n\tSTWGoroutineProfileCleanup STWReason = 5\n\tSTWAllGoroutinesStackTrace STWReason = 6\n\tSTWReadMemStats            STWReason = 7\n\tSTWAllThreadsSyscall       STWReason = 8\n\tSTWGOMAXPROCS              STWReason = 9\n\tSTWStartTrace              STWReason = 10\n\tSTWStopTrace               STWReason = 11\n\tSTWCountPagesInUse         STWReason = 12\n\tSTWReadMetricsSlow         STWReason = 13\n\tSTWReadMemStatsSlow        STWReason = 14\n\tSTWPageCachePagesLeaked    STWReason = 15\n\tSTWResetDebugLog           STWReason = 16\n\n\tNumSTWReasons = 17\n)\ntype Timestamp int64\n    Timestamp represents a count of nanoseconds since the beginning of the\n    trace. They can only be meaningfully compared with other timestamps from the\n    same trace.\n\ntype Trace struct {\n\tVersion version.Version\n\n\t// Events is the sorted list of Events in the trace.\n\tEvents Events\n\t// Stacks is the stack traces (stored as slices of PCs), keyed by stack IDs\n\t// from the trace.\n\tStacks        map[uint32][]uint64\n\tPCs           map[uint64]Frame\n\tStrings       map[uint64]string\n\tInlineStrings []string\n}\n    Trace is the result of Parse.\n\nfunc Parse(r io.Reader, vers version.Version) (Trace, error)\n    Parse parses Go execution traces from versions 1.11\u20131.21. The provided\n    reader will be read to completion and the entire trace will be materialized\n    in memory. That is, this function does not allow incremental parsing.\n\n    The reader has to be positioned just after the trace header and vers\n    needs to be the version of the trace. This can be achieved by using\n    version.ReadHeader.\n\nfunc (tr *Trace) STWReason(kindID uint64) STWReason\n\n"}, {"path": "stdlib/mime-multipart.md", "category": "stdlib", "name": "stdlib/mime-multipart", "content": "package multipart // import \"mime/multipart\"\n\nPackage multipart implements MIME multipart parsing, as defined in RFC 2046.\n\nThe implementation is sufficient for HTTP (RFC 2388) and the multipart bodies\ngenerated by popular browsers.\n\n# Limits\n\nTo protect against malicious inputs, this package sets limits on the size of the\nMIME data it processes.\n\nReader.NextPart and Reader.NextRawPart limit the number of headers in\na part to 10000 and Reader.ReadForm limits the total number of headers\nin all FileHeaders to 10000. These limits may be adjusted with the\nGODEBUG=multipartmaxheaders=<values> setting.\n\nReader.ReadForm further limits the number of parts in a form to 1000. This limit\nmay be adjusted with the GODEBUG=multipartmaxparts=<value> setting.\n\nVARIABLES\n\nvar ErrMessageTooLarge = errors.New(\"multipart: message too large\")\n    ErrMessageTooLarge is returned by ReadForm if the message form data is too\n    large to be processed.\n\n\nFUNCTIONS\n\nfunc FileContentDisposition(fieldname, filename string) string\n    FileContentDisposition returns the value of a Content-Disposition header\n    with the provided field name and file name.\n\n\nTYPES\n\ntype File interface {\n\tio.Reader\n\tio.ReaderAt\n\tio.Seeker\n\tio.Closer\n}\n    File is an interface to access the file part of a multipart message.\n    Its contents may be either stored in memory or on disk. If stored on disk,\n    the File's underlying concrete type will be an *os.File.\n\ntype FileHeader struct {\n\tFilename string\n\tHeader   textproto.MIMEHeader\n\tSize     int64\n\n\t// Has unexported fields.\n}\n    A FileHeader describes a file part of a multipart request.\n\nfunc (fh *FileHeader) Open() (File, error)\n    Open opens and returns the FileHeader's associated File.\n\ntype Form struct {\n\tValue map[string][]string\n\tFile  map[string][]*FileHeader\n}\n    Form is a parsed multipart form. Its File parts are stored either in memory\n    or on disk, and are accessible via the *FileHeader's Open method. Its Value\n    parts are stored as strings. Both are keyed by field name.\n\nfunc (f *Form) RemoveAll() error\n    RemoveAll removes any temporary files associated with a Form.\n\ntype Part struct {\n\t// The headers of the body, if any, with the keys canonicalized\n\t// in the same fashion that the Go http.Request headers are.\n\t// For example, \"foo-bar\" changes case to \"Foo-Bar\"\n\tHeader textproto.MIMEHeader\n\n\t// Has unexported fields.\n}\n    A Part represents a single part in a multipart body.\n\nfunc (p *Part) Close() error\n\nfunc (p *Part) FileName() string\n    FileName returns the filename parameter of the Part's Content-Disposition\n    header. If not empty, the filename is passed through filepath.Base (which is\n    platform dependent) before being returned.\n\nfunc (p *Part) FormName() string\n    FormName returns the name parameter if p has a Content-Disposition of type\n    \"form-data\". Otherwise it returns the empty string.\n\nfunc (p *Part) Read(d []byte) (n int, err error)\n    Read reads the body of a part, after its headers and before the next part\n    (if any) begins.\n\ntype Reader struct {\n\t// Has unexported fields.\n}\n    Reader is an iterator over parts in a MIME multipart body. Reader's\n    underlying parser consumes its input as needed. Seeking isn't supported.\n\nfunc NewReader(r io.Reader, boundary string) *Reader\n    NewReader creates a new multipart Reader reading from r using the given MIME\n    boundary.\n\n    The boundary is usually obtained from the \"boundary\" parameter of the\n    message's \"Content-Type\" header. Use mime.ParseMediaType to parse such\n    headers.\n\nfunc (r *Reader) NextPart() (*Part, error)\n    NextPart returns the next part in the multipart or an error. When there are\n    no more parts, the error io.EOF is returned.\n\n    As a special case, if the \"Content-Transfer-Encoding\" header has a value\n    of \"quoted-printable\", that header is instead hidden and the body is\n    transparently decoded during Read calls.\n\nfunc (r *Reader) NextRawPart() (*Part, error)\n    NextRawPart returns the next part in the multipart or an error. When there\n    are no more parts, the error io.EOF is returned.\n\n    Unlike Reader.NextPart, it does not have special handling for\n    \"Content-Transfer-Encoding: quoted-printable\".\n\nfunc (r *Reader) ReadForm(maxMemory int64) (*Form, error)\n    ReadForm parses an entire multipart message whose parts have a\n    Content-Disposition of \"form-data\". It stores up to maxMemory bytes +\n    10MB (reserved for non-file parts) in memory. File parts which can't be\n    stored in memory will be stored on disk in temporary files. It returns\n    ErrMessageTooLarge if all non-file parts can't be stored in memory.\n\ntype Writer struct {\n\t// Has unexported fields.\n}\n    A Writer generates multipart messages.\n\nfunc NewWriter(w io.Writer) *Writer\n    NewWriter returns a new multipart Writer with a random boundary, writing to\n    w.\n\nfunc (w *Writer) Boundary() string\n    Boundary returns the Writer's boundary.\n\nfunc (w *Writer) Close() error\n    Close finishes the multipart message and writes the trailing boundary end\n    line to the output.\n\nfunc (w *Writer) CreateFormField(fieldname string) (io.Writer, error)\n    CreateFormField calls Writer.CreatePart with a header using the given field\n    name.\n\nfunc (w *Writer) CreateFormFile(fieldname, filename string) (io.Writer, error)\n    CreateFormFile is a convenience wrapper around Writer.CreatePart. It creates\n    a new form-data header with the provided field name and file name.\n\nfunc (w *Writer) CreatePart(header textproto.MIMEHeader) (io.Writer, error)\n    CreatePart creates a new multipart section with the provided header.\n    The body of the part should be written to the returned Writer. After calling\n    CreatePart, any previous part may no longer be written to.\n\nfunc (w *Writer) FormDataContentType() string\n    FormDataContentType returns the Content-Type for an HTTP multipart/form-data\n    with this Writer's Boundary.\n\nfunc (w *Writer) SetBoundary(boundary string) error\n    SetBoundary overrides the Writer's default randomly-generated boundary\n    separator with an explicit value.\n\n    SetBoundary must be called before any parts are created, may only contain\n    certain ASCII characters, and must be non-empty and at most 70 bytes long.\n\nfunc (w *Writer) WriteField(fieldname, value string) error\n    WriteField calls Writer.CreateFormField and then writes the given value.\n\n"}, {"path": "stdlib/internal-coverage-rtcov.md", "category": "stdlib", "name": "stdlib/internal-coverage-rtcov", "content": "package rtcov // import \"internal/coverage/rtcov\"\n\n\nVARIABLES\n\nvar Meta struct {\n\t// List contains the list of currently registered meta-data\n\t// blobs for the running program.\n\tList []CovMetaBlob\n\n\t// PkgMap records mappings from hard-coded package IDs to\n\t// slots in the List above.\n\tPkgMap map[int]int\n\n\t// Set to true if we discover a package mapping glitch.\n\thardCodedListNeedsUpdating bool\n}\n    Meta is the top-level container for bits of state related to code coverage\n    meta-data in the runtime.\n\n\nFUNCTIONS\n\nfunc AddMeta(p unsafe.Pointer, dlen uint32, hash [16]byte, pkgpath string, pkgid int, cmode uint8, cgran uint8) uint32\n    AddMeta is invoked during package \"init\" functions by the compiler when\n    compiling for coverage instrumentation; here 'p' is a meta-data blob of\n    length 'dlen' for the package in question, 'hash' is a compiler-computed\n    md5.sum for the blob, 'pkpath' is the package path, 'pkid' is the hard-coded\n    ID that the compiler is using for the package (or -1 if the compiler doesn't\n    think a hard-coded ID is needed), and 'cmode'/'cgran' are the coverage\n    counter mode and granularity requested by the user. Return value is the ID\n    for the package for use by the package code itself, or 0 for impossible\n    errors.\n\n\nTYPES\n\ntype CovCounterBlob struct {\n\tCounters *uint32\n\tLen      uint64\n}\n    CovCounterBlob is a container for encapsulating a counter section (BSS\n    variable) for an instrumented Go module. Here \"counters\" points to the\n    counter payload and \"len\" is the number of uint32 entries in the section.\n\ntype CovMetaBlob struct {\n\tP                  *byte\n\tLen                uint32\n\tHash               [16]byte\n\tPkgPath            string\n\tPkgID              int\n\tCounterMode        uint8 // coverage.CounterMode\n\tCounterGranularity uint8 // coverage.CounterGranularity\n}\n    CovMetaBlob is a container for holding the meta-data symbol (an RODATA\n    variable) for an instrumented Go package. Here \"p\" points to the symbol\n    itself, \"len\" is the length of the sym in bytes, and \"hash\" is an md5sum\n    for the sym computed by the compiler. When the init function for a\n    coverage-instrumented package executes, it will make a call into the runtime\n    which will create a covMetaBlob object for the package and chain it onto a\n    global list.\n\n"}, {"path": "stdlib/runtime-debug.md", "category": "stdlib", "name": "stdlib/runtime-debug", "content": "package debug // import \"runtime/debug\"\n\nPackage debug contains facilities for programs to debug themselves while they\nare running.\n\nFUNCTIONS\n\nfunc FreeOSMemory()\n    FreeOSMemory forces a garbage collection followed by an attempt to return\n    as much memory to the operating system as possible. (Even if this is not\n    called, the runtime gradually returns memory to the operating system in a\n    background task.)\n\nfunc PrintStack()\n    PrintStack prints to standard error the stack trace returned by\n    runtime.Stack.\n\nfunc ReadGCStats(stats *GCStats)\n    ReadGCStats reads statistics about garbage collection into stats.\n    The number of entries in the pause history is system-dependent; stats.Pause\n    slice will be reused if large enough, reallocated otherwise. ReadGCStats may\n    use the full capacity of the stats.Pause slice. If stats.PauseQuantiles is\n    non-empty, ReadGCStats fills it with quantiles summarizing the distribution\n    of pause time. For example, if len(stats.PauseQuantiles) is 5, it will be\n    filled with the minimum, 25%, 50%, 75%, and maximum pause times.\n\nfunc SetCrashOutput(f *os.File, opts CrashOptions) error\n    SetCrashOutput configures a single additional file where unhandled panics\n    and other fatal errors are printed, in addition to standard error. There is\n    only one additional file: calling SetCrashOutput again overrides any earlier\n    call. SetCrashOutput duplicates f's file descriptor, so the caller may\n    safely close f as soon as SetCrashOutput returns. To disable this additional\n    crash output, call SetCrashOutput(nil). If called concurrently with a crash,\n    some in-progress output may be written to the old file even after an\n    overriding SetCrashOutput returns.\n\nfunc SetGCPercent(percent int) int\n    SetGCPercent sets the garbage collection target percentage: a collection is\n    triggered when the ratio of freshly allocated data to live data remaining\n    after the previous collection reaches this percentage. SetGCPercent\n    returns the previous setting. The initial setting is the value of the\n    GOGC environment variable at startup, or 100 if the variable is not set.\n    This setting may be effectively reduced in order to maintain a memory limit.\n    A negative percentage effectively disables garbage collection, unless the\n    memory limit is reached. See SetMemoryLimit for more details.\n\nfunc SetMaxStack(bytes int) int\n    SetMaxStack sets the maximum amount of memory that can be used by a single\n    goroutine stack. If any goroutine exceeds this limit while growing its\n    stack, the program crashes. SetMaxStack returns the previous setting.\n    The initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.\n    There may be a system-imposed maximum stack limit regardless of the value\n    provided to SetMaxStack.\n\n    SetMaxStack is useful mainly for limiting the damage done by goroutines that\n    enter an infinite recursion. It only limits future stack growth.\n\nfunc SetMaxThreads(threads int) int\n    SetMaxThreads sets the maximum number of operating system threads that the\n    Go program can use. If it attempts to use more than this many, the program\n    crashes. SetMaxThreads returns the previous setting. The initial setting is\n    10,000 threads.\n\n    The limit controls the number of operating system threads, not the number of\n    goroutines. A Go program creates a new thread only when a goroutine is ready\n    to run but all the existing threads are blocked in system calls, cgo calls,\n    or are locked to other goroutines due to use of runtime.LockOSThread.\n\n    SetMaxThreads is useful mainly for limiting the damage done by programs that\n    create an unbounded number of threads. The idea is to take down the program\n    before it takes down the operating system.\n\nfunc SetMemoryLimit(limit int64) int64\n    SetMemoryLimit provides the runtime with a soft memory limit.\n\n    The runtime undertakes several processes to try to respect this memory\n    limit, including adjustments to the frequency of garbage collections and\n    returning memory to the underlying system more aggressively. This limit will\n    be respected even if GOGC=off (or, if SetGCPercent(-1) is executed).\n\n    The input limit is provided as bytes, and includes all memory mapped,\n    managed, and not released by the Go runtime. Notably, it does not account\n    for space used by the Go binary and memory external to Go, such as memory\n    managed by the underlying system on behalf of the process, or memory managed\n    by non-Go code inside the same process. Examples of excluded memory sources\n    include: OS kernel memory held on behalf of the process, memory allocated by\n    C code, and memory mapped by syscall.Mmap (because it is not managed by the\n    Go runtime).\n\n    More specifically, the following expression accurately reflects the value\n    the runtime attempts to maintain as the limit:\n\n        runtime.MemStats.Sys - runtime.MemStats.HeapReleased\n\n    or in terms of the runtime/metrics package:\n\n        /memory/classes/total:bytes - /memory/classes/heap/released:bytes\n\n    A zero limit or a limit that's lower than the amount of memory used by the\n    Go runtime may cause the garbage collector to run nearly continuously.\n    However, the application may still make progress.\n\n    The memory limit is always respected by the Go runtime, so to effectively\n    disable this behavior, set the limit very high. math.MaxInt64 is the\n    canonical value for disabling the limit, but values much greater than the\n    available memory on the underlying system work just as well.\n\n    See https://go.dev/doc/gc-guide for a detailed guide explaining the soft\n    memory limit in more detail, as well as a variety of common use-cases and\n    scenarios.\n\n    The initial setting is math.MaxInt64 unless the GOMEMLIMIT environment\n    variable is set, in which case it provides the initial setting. GOMEMLIMIT\n    is a numeric value in bytes with an optional unit suffix. The supported\n    suffixes include B, KiB, MiB, GiB, and TiB. These suffixes represent\n    quantities of bytes as defined by the IEC 80000-13 standard. That is,\n    they are based on powers of two: KiB means 2^10 bytes, MiB means 2^20 bytes,\n    and so on.\n\n    SetMemoryLimit returns the previously set memory limit. A negative input\n    does not adjust the limit, and allows for retrieval of the currently set\n    memory limit.\n\nfunc SetPanicOnFault(enabled bool) bool\n    SetPanicOnFault controls the runtime's behavior when a program faults at\n    an unexpected (non-nil) address. Such faults are typically caused by bugs\n    such as runtime memory corruption, so the default response is to crash the\n    program. Programs working with memory-mapped files or unsafe manipulation\n    of memory may cause faults at non-nil addresses in less dramatic situations;\n    SetPanicOnFault allows such programs to request that the runtime trigger\n    only a panic, not a crash. The runtime.Error that the runtime panics with\n    may have an additional method:\n\n        Addr() uintptr\n\n    If that method exists, it returns the memory address which triggered the\n    fault. The results of Addr are best-effort and the veracity of the result\n    may depend on the platform. SetPanicOnFault applies only to the current\n    goroutine. It returns the previous setting.\n\nfunc SetTraceback(level string)\n    SetTraceback sets the amount of detail printed by the runtime in the\n    traceback it prints before exiting due to an unrecovered panic or an\n    internal runtime error. The level argument takes the same values as the\n    GOTRACEBACK environment variable. For example, SetTraceback(\"all\") ensure\n    that the program prints all goroutines when it crashes. See the package\n    runtime documentation for details. If SetTraceback is called with a level\n    lower than that of the environment variable, the call is ignored.\n\nfunc Stack() []byte\n    Stack returns a formatted stack trace of the goroutine that calls it. It\n    calls runtime.Stack with a large enough buffer to capture the entire trace.\n\nfunc WriteHeapDump(fd uintptr)\n    WriteHeapDump writes a description of the heap and the objects in it to the\n    given file descriptor.\n\n    WriteHeapDump suspends the execution of all goroutines until the heap dump\n    is completely written. Thus, the file descriptor must not be connected\n    to a pipe or socket whose other end is in the same Go process; instead,\n    use a temporary file or network socket.\n\n    The heap dump format is defined at https://golang.org/s/go15heapdump.\n\n\nTYPES\n\ntype BuildInfo struct {\n\t// GoVersion is the version of the Go toolchain that built the binary\n\t// (for example, \"go1.19.2\").\n\tGoVersion string `json:\",omitempty\"`\n\n\t// Path is the package path of the main package for the binary\n\t// (for example, \"golang.org/x/tools/cmd/stringer\").\n\tPath string `json:\",omitempty\"`\n\n\t// Main describes the module that contains the main package for the binary.\n\tMain Module `json:\"\"`\n\n\t// Deps describes all the dependency modules, both direct and indirect,\n\t// that contributed packages to the build of this binary.\n\tDeps []*Module `json:\",omitempty\"`\n\n\t// Settings describes the build settings used to build the binary.\n\tSettings []BuildSetting `json:\",omitempty\"`\n}\n    BuildInfo represents the build information read from a Go binary.\n\nfunc ParseBuildInfo(data string) (bi *BuildInfo, err error)\n    ParseBuildInfo parses the string returned by *BuildInfo.String, restoring\n    the original BuildInfo, except that the GoVersion field is not set. Programs\n    should normally not call this function, but instead call ReadBuildInfo,\n    debug/buildinfo.ReadFile, or debug/buildinfo.Read.\n\nfunc ReadBuildInfo() (info *BuildInfo, ok bool)\n    ReadBuildInfo returns the build information embedded in the running binary.\n    The information is available only in binaries built with module support.\n\nfunc (bi *BuildInfo) String() string\n    String returns a string representation of a BuildInfo.\n\ntype BuildSetting struct {\n\t// Key and Value describe the build setting.\n\t// Key must not contain an equals sign, space, tab, or newline.\n\tKey string `json:\",omitempty\"`\n\t// Value must not contain newlines ('\\n').\n\tValue string `json:\",omitempty\"`\n}\n    A BuildSetting is a key-value pair describing one setting that influenced a\n    build.\n\n    Defined keys include:\n\n      - -buildmode: the buildmode flag used (typically \"exe\")\n      - -compiler: the compiler toolchain flag used (typically \"gc\")\n      - CGO_ENABLED: the effective CGO_ENABLED environment variable\n      - CGO_CFLAGS: the effective CGO_CFLAGS environment variable\n      - CGO_CPPFLAGS: the effective CGO_CPPFLAGS environment variable\n      - CGO_CXXFLAGS: the effective CGO_CXXFLAGS environment variable\n      - CGO_LDFLAGS: the effective CGO_LDFLAGS environment variable\n      - DefaultGODEBUG: the effective GODEBUG settings\n      - GOARCH: the architecture target\n      - GOAMD64/GOARM/GO386/etc: the architecture feature level for GOARCH\n      - GOOS: the operating system target\n      - GOFIPS140: the frozen FIPS 140-3 module version, if any\n      - vcs: the version control system for the source tree where the build ran\n      - vcs.revision: the revision identifier for the current commit or checkout\n      - vcs.time: the modification time associated with vcs.revision, in RFC3339\n        format\n      - vcs.modified: true or false indicating whether the source tree had local\n        modifications\n\ntype CrashOptions struct {\n}\n    CrashOptions provides options that control the formatting of the fatal crash\n    message.\n\ntype GCStats struct {\n\tLastGC         time.Time       // time of last collection\n\tNumGC          int64           // number of garbage collections\n\tPauseTotal     time.Duration   // total pause for all collections\n\tPause          []time.Duration // pause history, most recent first\n\tPauseEnd       []time.Time     // pause end times history, most recent first\n\tPauseQuantiles []time.Duration\n}\n    GCStats collect information about recent garbage collections.\n\ntype Module struct {\n\tPath    string  `json:\",omitempty\"` // module path\n\tVersion string  `json:\",omitempty\"` // module version\n\tSum     string  `json:\",omitempty\"` // checksum\n\tReplace *Module `json:\",omitempty\"` // replaced by this module\n}\n    A Module describes a single module included in a build.\n\n"}, {"path": "stdlib/internal-coverage-decodemeta.md", "category": "stdlib", "name": "stdlib/internal-coverage-decodemeta", "content": "package decodemeta // import \"internal/coverage/decodemeta\"\n\n\nTYPES\n\ntype CoverageMetaDataDecoder struct {\n\t// Has unexported fields.\n}\n\nfunc NewCoverageMetaDataDecoder(b []byte, readonly bool) (*CoverageMetaDataDecoder, error)\n\nfunc (d *CoverageMetaDataDecoder) ModulePath() string\n\nfunc (d *CoverageMetaDataDecoder) NumFuncs() uint32\n\nfunc (d *CoverageMetaDataDecoder) PackageName() string\n\nfunc (d *CoverageMetaDataDecoder) PackagePath() string\n\nfunc (d *CoverageMetaDataDecoder) ReadFunc(fidx uint32, f *coverage.FuncDesc) error\n    ReadFunc reads the coverage meta-data for the function with index 'findex',\n    filling it into the FuncDesc pointed to by 'f'.\n\ntype CoverageMetaFileReader struct {\n\t// Has unexported fields.\n}\n    CoverageMetaFileReader provides state and methods for reading a meta-data\n    file from a code coverage run.\n\nfunc NewCoverageMetaFileReader(f *os.File, fileView []byte) (*CoverageMetaFileReader, error)\n    NewCoverageMetaFileReader returns a new helper object for reading the\n    coverage meta-data output file 'f'. The param 'fileView' is a read-only\n    slice containing the contents of 'f' obtained by mmap'ing the file\n    read-only; 'fileView' may be nil, in which case the helper will read the\n    contents of the file using regular file Read operations.\n\nfunc (r *CoverageMetaFileReader) CounterGranularity() coverage.CounterGranularity\n    CounterGranularity returns the counter granularity (single counter per\n    function, or counter per block) selected when building for coverage for the\n    program that produce this meta-data file.\n\nfunc (r *CoverageMetaFileReader) CounterMode() coverage.CounterMode\n    CounterMode returns the counter mode (set, count, atomic) used when building\n    for coverage for the program that produce this meta-data file.\n\nfunc (r *CoverageMetaFileReader) FileHash() [16]byte\n    FileHash returns the hash computed for all of the package meta-data blobs.\n    Coverage counter data files refer to this hash, and the hash will be encoded\n    into the meta-data file name.\n\nfunc (r *CoverageMetaFileReader) GetPackageDecoder(pkIdx uint32, payloadbuf []byte) (*CoverageMetaDataDecoder, []byte, error)\n    GetPackageDecoder requests a decoder object for the package within the\n    meta-data file whose index is 'pkIdx'. If the CoverageMetaFileReader was\n    set up with a read-only file view, a pointer into that file view will be\n    returned, otherwise the buffer 'payloadbuf' will be written to (or if it is\n    not of sufficient size, a new buffer will be allocated). Return value is the\n    decoder, a byte slice with the encoded meta-data, and an error.\n\nfunc (r *CoverageMetaFileReader) GetPackagePayload(pkIdx uint32, payloadbuf []byte) ([]byte, error)\n    GetPackagePayload returns the raw (encoded) meta-data payload for\n    the package with index 'pkIdx'. As with GetPackageDecoder, if the\n    CoverageMetaFileReader was set up with a read-only file view, a pointer\n    into that file view will be returned, otherwise the buffer 'payloadbuf'\n    will be written to (or if it is not of sufficient size, a new buffer will\n    be allocated). Return value is the decoder, a byte slice with the encoded\n    meta-data, and an error.\n\nfunc (r *CoverageMetaFileReader) NumPackages() uint64\n    NumPackages returns the number of packages for which this file contains\n    meta-data.\n\n"}, {"path": "stdlib/plugin.md", "category": "stdlib", "name": "stdlib/plugin", "content": "package plugin // import \"plugin\"\n\nPackage plugin implements loading and symbol resolution of Go plugins.\n\nA plugin is a Go main package with exported functions and variables that has\nbeen built with:\n\n    go build -buildmode=plugin\n\nWhen a plugin is first opened, the init functions of all packages not already\npart of the program are called. The main function is not run. A plugin is only\ninitialized once, and cannot be closed.\n\n# Warnings\n\nThe ability to dynamically load parts of an application during execution,\nperhaps based on user-defined configuration, may be a useful building block\nin some designs. In particular, because applications and dynamically loaded\nfunctions can share data structures directly, plugins may enable very\nhigh-performance integration of separate parts.\n\nHowever, the plugin mechanism has many significant drawbacks that should be\nconsidered carefully during the design. For example:\n\n  - Plugins are currently supported only on Linux, FreeBSD, and macOS, making\n    them unsuitable for applications intended to be portable.\n\n  - Plugins are poorly supported by the Go race detector. Even simple race\n    conditions may not be automatically detected. See https://go.dev/issue/24245\n    for more information.\n\n  - Applications that use plugins may require careful configuration to ensure\n    that the various parts of the program be made available in the correct\n    location in the file system (or container image). By contrast, deploying an\n    application consisting of a single static executable is straightforward.\n\n  - Reasoning about program initialization is more difficult when some packages\n    may not be initialized until long after the application has started running.\n\n  - Bugs in applications that load plugins could be exploited by an attacker to\n    load dangerous or untrusted libraries.\n\n  - Runtime crashes are likely to occur unless all parts of the program (the\n    application and all its plugins) are compiled using exactly the same version\n    of the toolchain, the same build tags, and the same values of certain flags\n    and environment variables.\n\n  - Similar crashing problems are likely to arise unless all common dependencies\n    of the application and its plugins are built from exactly the same source\n    code.\n\n  - Together, these restrictions mean that, in practice, the application and\n    its plugins must all be built together by a single person or component of\n    a system. In that case, it may be simpler for that person or component to\n    generate Go source files that blank-import the desired set of plugins and\n    then compile a static executable in the usual way.\n\nFor these reasons, many users decide that traditional interprocess communication\n(IPC) mechanisms such as sockets, pipes, remote procedure call (RPC), shared\nmemory mappings, or file system operations may be more suitable despite the\nperformance overheads.\n\nTYPES\n\ntype Plugin struct {\n\t// Has unexported fields.\n}\n    Plugin is a loaded Go plugin.\n\nfunc Open(path string) (*Plugin, error)\n    Open opens a Go plugin. If a path has already been opened, then the existing\n    *Plugin is returned. It is safe for concurrent use by multiple goroutines.\n\nfunc (p *Plugin) Lookup(symName string) (Symbol, error)\n    Lookup searches for a symbol named symName in plugin p. A symbol is any\n    exported variable or function. It reports an error if the symbol is not\n    found. It is safe for concurrent use by multiple goroutines.\n\ntype Symbol any\n    A Symbol is a pointer to a variable or function.\n\n    For example, a plugin defined as\n\n        package main\n\n        import \"fmt\"\n\n        var V int\n\n        func F() { fmt.Printf(\"Hello, number %d\\n\", V) }\n\n    may be loaded with the Open function and then the exported package symbols V\n    and F can be accessed\n\n        p, err := plugin.Open(\"plugin_name.so\")\n        if err != nil {\n        \tpanic(err)\n        }\n        v, err := p.Lookup(\"V\")\n        if err != nil {\n        \tpanic(err)\n        }\n        f, err := p.Lookup(\"F\")\n        if err != nil {\n        \tpanic(err)\n        }\n        *v.(*int) = 7\n        f.(func())() // prints \"Hello, number 7\"\n\n"}, {"path": "stdlib/crypto-sha512.md", "category": "stdlib", "name": "stdlib/crypto-sha512", "content": "package sha512 // import \"crypto/sha512\"\n\nPackage sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256\nhash algorithms as defined in FIPS 180-4.\n\nAll the hash.Hash implementations returned by this package also implement\nencoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal\nthe internal state of the hash.\n\nCONSTANTS\n\nconst (\n\t// Size is the size, in bytes, of a SHA-512 checksum.\n\tSize = 64\n\n\t// Size224 is the size, in bytes, of a SHA-512/224 checksum.\n\tSize224 = 28\n\n\t// Size256 is the size, in bytes, of a SHA-512/256 checksum.\n\tSize256 = 32\n\n\t// Size384 is the size, in bytes, of a SHA-384 checksum.\n\tSize384 = 48\n\n\t// BlockSize is the block size, in bytes, of the SHA-512/224,\n\t// SHA-512/256, SHA-384 and SHA-512 hash functions.\n\tBlockSize = 128\n)\n\nFUNCTIONS\n\nfunc New() hash.Hash\n    New returns a new hash.Hash computing the SHA-512 checksum. The Hash\n    also implements encoding.BinaryMarshaler, encoding.BinaryAppender and\n    encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of\n    the hash.\n\nfunc New384() hash.Hash\n    New384 returns a new hash.Hash computing the SHA-384 checksum. The Hash\n    also implements encoding.BinaryMarshaler, encoding.BinaryAppender and\n    encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of\n    the hash.\n\nfunc New512_224() hash.Hash\n    New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.\n    The Hash also implements encoding.BinaryMarshaler, encoding.BinaryAppender\n    and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state\n    of the hash.\n\nfunc New512_256() hash.Hash\n    New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.\n    The Hash also implements encoding.BinaryMarshaler, encoding.BinaryAppender\n    and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state\n    of the hash.\n\nfunc Sum384(data []byte) [Size384]byte\n    Sum384 returns the SHA384 checksum of the data.\n\nfunc Sum512(data []byte) [Size]byte\n    Sum512 returns the SHA512 checksum of the data.\n\nfunc Sum512_224(data []byte) [Size224]byte\n    Sum512_224 returns the Sum512/224 checksum of the data.\n\nfunc Sum512_256(data []byte) [Size256]byte\n    Sum512_256 returns the Sum512/256 checksum of the data.\n\n"}, {"path": "stdlib/crypto-internal-fips140-ssh.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-ssh", "content": "package ssh // import \"crypto/internal/fips140/ssh\"\n\nPackage ssh implements the SSH KDF as specified in RFC 4253, Section 7.2 and\nallowed by SP 800-135 Revision 1.\n\nFUNCTIONS\n\nfunc Keys[Hash hash.Hash](hash func() Hash, d Direction,\n\tK, H, sessionID []byte,\n\tivKeyLen, keyLen, macKeyLen int,\n) (ivKey, key, macKey []byte)\n\nTYPES\n\ntype Direction struct {\n\t// Has unexported fields.\n}\n\nvar ServerKeys, ClientKeys Direction\n"}, {"path": "stdlib/net-http-httputil.md", "category": "stdlib", "name": "stdlib/net-http-httputil", "content": "package httputil // import \"net/http/httputil\"\n\nPackage httputil provides HTTP utility functions, complementing the more common\nones in the net/http package.\n\nVARIABLES\n\nvar (\n\t// Deprecated: No longer used.\n\tErrPersistEOF = &http.ProtocolError{ErrorString: \"persistent connection closed\"}\n\n\t// Deprecated: No longer used.\n\tErrClosed = &http.ProtocolError{ErrorString: \"connection closed by user\"}\n\n\t// Deprecated: No longer used.\n\tErrPipeline = &http.ProtocolError{ErrorString: \"pipeline error\"}\n)\nvar ErrLineTooLong = internal.ErrLineTooLong\n    ErrLineTooLong is returned when reading malformed chunked data with lines\n    that are too long.\n\n\nFUNCTIONS\n\nfunc DumpRequest(req *http.Request, body bool) ([]byte, error)\n    DumpRequest returns the given request in its HTTP/1.x wire representation.\n    It should only be used by servers to debug client requests. The returned\n    representation is an approximation only; some details of the initial request\n    are lost while parsing it into an http.Request. In particular, the order and\n    case of header field names are lost. The order of values in multi-valued\n    headers is kept intact. HTTP/2 requests are dumped in HTTP/1.x form,\n    not in their original binary representations.\n\n    If body is true, DumpRequest also returns the body. To do so, it consumes\n    req.Body and then replaces it with a new io.ReadCloser that yields the same\n    bytes. If DumpRequest returns an error, the state of req is undefined.\n\n    The documentation for http.Request.Write details which fields of req are\n    included in the dump.\n\nfunc DumpRequestOut(req *http.Request, body bool) ([]byte, error)\n    DumpRequestOut is like DumpRequest but for outgoing client requests.\n    It includes any headers that the standard http.Transport adds, such as\n    User-Agent.\n\nfunc DumpResponse(resp *http.Response, body bool) ([]byte, error)\n    DumpResponse is like DumpRequest but dumps a response.\n\nfunc NewChunkedReader(r io.Reader) io.Reader\n    NewChunkedReader returns a new chunkedReader that translates the data read\n    from r out of HTTP \"chunked\" format before returning it. The chunkedReader\n    returns io.EOF when the final 0-length chunk is read.\n\n    NewChunkedReader is not needed by normal applications. The http package\n    automatically decodes chunking when reading response bodies.\n\nfunc NewChunkedWriter(w io.Writer) io.WriteCloser\n    NewChunkedWriter returns a new chunkedWriter that translates writes into\n    HTTP \"chunked\" format before writing them to w. Closing the returned\n    chunkedWriter sends the final 0-length chunk that marks the end of the\n    stream but does not send the final CRLF that appears after trailers;\n    trailers and the last CRLF must be written separately.\n\n    NewChunkedWriter is not needed by normal applications. The http package\n    adds chunking automatically if handlers don't set a Content-Length header.\n    Using NewChunkedWriter inside a handler would result in double chunking or\n    chunking with a Content-Length length, both of which are wrong.\n\n\nTYPES\n\ntype BufferPool interface {\n\tGet() []byte\n\tPut([]byte)\n}\n    A BufferPool is an interface for getting and returning temporary byte slices\n    for use by io.CopyBuffer.\n\ntype ClientConn struct {\n\t// Has unexported fields.\n}\n    ClientConn is an artifact of Go's early HTTP implementation. It is\n    low-level, old, and unused by Go's current HTTP stack. We should have\n    deleted it before Go 1.\n\n    Deprecated: Use Client or Transport in package net/http instead.\n\nfunc NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn\n    NewClientConn is an artifact of Go's early HTTP implementation. It is\n    low-level, old, and unused by Go's current HTTP stack. We should have\n    deleted it before Go 1.\n\n    Deprecated: Use the Client or Transport in package net/http instead.\n\nfunc NewProxyClientConn(c net.Conn, r *bufio.Reader) *ClientConn\n    NewProxyClientConn is an artifact of Go's early HTTP implementation.\n    It is low-level, old, and unused by Go's current HTTP stack. We should have\n    deleted it before Go 1.\n\n    Deprecated: Use the Client or Transport in package net/http instead.\n\nfunc (cc *ClientConn) Close() error\n    Close calls ClientConn.Hijack and then also closes the underlying\n    connection.\n\nfunc (cc *ClientConn) Do(req *http.Request) (*http.Response, error)\n    Do is convenience method that writes a request and reads a response.\n\nfunc (cc *ClientConn) Hijack() (c net.Conn, r *bufio.Reader)\n    Hijack detaches the ClientConn and returns the underlying connection\n    as well as the read-side bufio which may have some left over data.\n    Hijack may be called before the user or Read have signaled the end of the\n    keep-alive logic. The user should not call Hijack while ClientConn.Read or\n    ClientConn.Write is in progress.\n\nfunc (cc *ClientConn) Pending() int\n    Pending returns the number of unanswered requests that have been sent on the\n    connection.\n\nfunc (cc *ClientConn) Read(req *http.Request) (resp *http.Response, err error)\n    Read reads the next response from the wire. A valid response might be\n    returned together with an ErrPersistEOF, which means that the remote\n    requested that this be the last request serviced. Read can be called\n    concurrently with ClientConn.Write, but not with another Read.\n\nfunc (cc *ClientConn) Write(req *http.Request) error\n    Write writes a request. An ErrPersistEOF error is returned if the connection\n    has been closed in an HTTP keep-alive sense. If req.Close equals true,\n    the keep-alive connection is logically closed after this request and the\n    opposing server is informed. An ErrUnexpectedEOF indicates the remote closed\n    the underlying TCP connection, which is usually considered as graceful\n    close.\n\ntype ProxyRequest struct {\n\t// In is the request received by the proxy.\n\t// The Rewrite function must not modify In.\n\tIn *http.Request\n\n\t// Out is the request which will be sent by the proxy.\n\t// The Rewrite function may modify or replace this request.\n\t// Hop-by-hop headers are removed from this request\n\t// before Rewrite is called.\n\tOut *http.Request\n}\n    A ProxyRequest contains a request to be rewritten by a ReverseProxy.\n\nfunc (r *ProxyRequest) SetURL(target *url.URL)\n    SetURL routes the outbound request to the scheme, host, and base path\n    provided in target. If the target's path is \"/base\" and the incoming\n    request was for \"/dir\", the target request will be for \"/base/dir\". To route\n    requests without joining the incoming path, set r.Out.URL directly.\n\n    SetURL rewrites the outbound Host header to match the target's host.\n    To preserve the inbound request's Host header (the default behavior of\n    NewSingleHostReverseProxy):\n\n        rewriteFunc := func(r *httputil.ProxyRequest) {\n        \tr.SetURL(url)\n        \tr.Out.Host = r.In.Host\n        }\n\nfunc (r *ProxyRequest) SetXForwarded()\n    SetXForwarded sets the X-Forwarded-For, X-Forwarded-Host, and\n    X-Forwarded-Proto headers of the outbound request.\n\n      - The X-Forwarded-For header is set to the client IP address.\n      - The X-Forwarded-Host header is set to the host name requested by the\n        client.\n      - The X-Forwarded-Proto header is set to \"http\" or \"https\", depending on\n        whether the inbound request was made on a TLS-enabled connection.\n\n    If the outbound request contains an existing X-Forwarded-For header,\n    SetXForwarded appends the client IP address to it. To append to the inbound\n    request's X-Forwarded-For header (the default behavior of ReverseProxy when\n    using a Director function), copy the header from the inbound request before\n    calling SetXForwarded:\n\n        rewriteFunc := func(r *httputil.ProxyRequest) {\n        \tr.Out.Header[\"X-Forwarded-For\"] = r.In.Header[\"X-Forwarded-For\"]\n        \tr.SetXForwarded()\n        }\n\ntype ReverseProxy struct {\n\t// Rewrite must be a function which modifies\n\t// the request into a new request to be sent\n\t// using Transport. Its response is then copied\n\t// back to the original client unmodified.\n\t// Rewrite must not access the provided ProxyRequest\n\t// or its contents after returning.\n\t//\n\t// The Forwarded, X-Forwarded, X-Forwarded-Host,\n\t// and X-Forwarded-Proto headers are removed from the\n\t// outbound request before Rewrite is called. See also\n\t// the ProxyRequest.SetXForwarded method.\n\t//\n\t// Unparsable query parameters are removed from the\n\t// outbound request before Rewrite is called.\n\t// The Rewrite function may copy the inbound URL's\n\t// RawQuery to the outbound URL to preserve the original\n\t// parameter string. Note that this can lead to security\n\t// issues if the proxy's interpretation of query parameters\n\t// does not match that of the downstream server.\n\t//\n\t// At most one of Rewrite or Director may be set.\n\tRewrite func(*ProxyRequest)\n\n\t// Director is a function which modifies\n\t// the request into a new request to be sent\n\t// using Transport. Its response is then copied\n\t// back to the original client unmodified.\n\t// Director must not access the provided Request\n\t// after returning.\n\t//\n\t// By default, the X-Forwarded-For header is set to the\n\t// value of the client IP address. If an X-Forwarded-For\n\t// header already exists, the client IP is appended to the\n\t// existing values. As a special case, if the header\n\t// exists in the Request.Header map but has a nil value\n\t// (such as when set by the Director func), the X-Forwarded-For\n\t// header is not modified.\n\t//\n\t// To prevent IP spoofing, be sure to delete any pre-existing\n\t// X-Forwarded-For header coming from the client or\n\t// an untrusted proxy.\n\t//\n\t// Hop-by-hop headers are removed from the request after\n\t// Director returns, which can remove headers added by\n\t// Director. Use a Rewrite function instead to ensure\n\t// modifications to the request are preserved.\n\t//\n\t// Unparsable query parameters are removed from the outbound\n\t// request if Request.Form is set after Director returns.\n\t//\n\t// At most one of Rewrite or Director may be set.\n\tDirector func(*http.Request)\n\n\t// The transport used to perform proxy requests.\n\t// If nil, http.DefaultTransport is used.\n\tTransport http.RoundTripper\n\n\t// FlushInterval specifies the flush interval\n\t// to flush to the client while copying the\n\t// response body.\n\t// If zero, no periodic flushing is done.\n\t// A negative value means to flush immediately\n\t// after each write to the client.\n\t// The FlushInterval is ignored when ReverseProxy\n\t// recognizes a response as a streaming response, or\n\t// if its ContentLength is -1; for such responses, writes\n\t// are flushed to the client immediately.\n\tFlushInterval time.Duration\n\n\t// ErrorLog specifies an optional logger for errors\n\t// that occur when attempting to proxy the request.\n\t// If nil, logging is done via the log package's standard logger.\n\tErrorLog *log.Logger\n\n\t// BufferPool optionally specifies a buffer pool to\n\t// get byte slices for use by io.CopyBuffer when\n\t// copying HTTP response bodies.\n\tBufferPool BufferPool\n\n\t// ModifyResponse is an optional function that modifies the\n\t// Response from the backend. It is called if the backend\n\t// returns a response at all, with any HTTP status code.\n\t// If the backend is unreachable, the optional ErrorHandler is\n\t// called without any call to ModifyResponse.\n\t//\n\t// Hop-by-hop headers are removed from the response before\n\t// calling ModifyResponse. ModifyResponse may need to remove\n\t// additional headers to fit its deployment model, such as Alt-Svc.\n\t//\n\t// If ModifyResponse returns an error, ErrorHandler is called\n\t// with its error value. If ErrorHandler is nil, its default\n\t// implementation is used.\n\tModifyResponse func(*http.Response) error\n\n\t// ErrorHandler is an optional function that handles errors\n\t// reaching the backend or errors from ModifyResponse.\n\t//\n\t// If nil, the default is to log the provided error and return\n\t// a 502 Status Bad Gateway response.\n\tErrorHandler func(http.ResponseWriter, *http.Request, error)\n}\n    ReverseProxy is an HTTP Handler that takes an incoming request and sends it\n    to another server, proxying the response back to the client.\n\n    1xx responses are forwarded to the client if the underlying transport\n    supports ClientTrace.Got1xxResponse.\n\n    Hop-by-hop headers (see RFC 9110, section 7.6.1), including Connection,\n    Proxy-Connection, Keep-Alive, Proxy-Authenticate, Proxy-Authorization, TE,\n    Trailer, Transfer-Encoding, and Upgrade, are removed from client requests\n    and backend responses. The Rewrite function may be used to add hop-by-hop\n    headers to the request, and the ModifyResponse function may be used to\n    remove them from the response.\n\nfunc NewSingleHostReverseProxy(target *url.URL) *ReverseProxy\n    NewSingleHostReverseProxy returns a new ReverseProxy that routes URLs to\n    the scheme, host, and base path provided in target. If the target's path is\n    \"/base\" and the incoming request was for \"/dir\", the target request will be\n    for /base/dir.\n\n    NewSingleHostReverseProxy does not rewrite the Host header.\n\n    To customize the ReverseProxy behavior beyond what NewSingleHostReverseProxy\n    provides, use ReverseProxy directly with a Rewrite function. The\n    ProxyRequest SetURL method may be used to route the outbound request. (Note\n    that SetURL, unlike NewSingleHostReverseProxy, rewrites the Host header of\n    the outbound request by default.)\n\n        proxy := &ReverseProxy{\n        \tRewrite: func(r *ProxyRequest) {\n        \t\tr.SetURL(target)\n        \t\tr.Out.Host = r.In.Host // if desired\n        \t},\n        }\n\nfunc (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request)\n\ntype ServerConn struct {\n\t// Has unexported fields.\n}\n    ServerConn is an artifact of Go's early HTTP implementation. It is\n    low-level, old, and unused by Go's current HTTP stack. We should have\n    deleted it before Go 1.\n\n    Deprecated: Use the Server in package net/http instead.\n\nfunc NewServerConn(c net.Conn, r *bufio.Reader) *ServerConn\n    NewServerConn is an artifact of Go's early HTTP implementation. It is\n    low-level, old, and unused by Go's current HTTP stack. We should have\n    deleted it before Go 1.\n\n    Deprecated: Use the Server in package net/http instead.\n\nfunc (sc *ServerConn) Close() error\n    Close calls ServerConn.Hijack and then also closes the underlying\n    connection.\n\nfunc (sc *ServerConn) Hijack() (net.Conn, *bufio.Reader)\n    Hijack detaches the ServerConn and returns the underlying connection as\n    well as the read-side bufio which may have some left over data. Hijack\n    may be called before Read has signaled the end of the keep-alive logic.\n    The user should not call Hijack while ServerConn.Read or ServerConn.Write is\n    in progress.\n\nfunc (sc *ServerConn) Pending() int\n    Pending returns the number of unanswered requests that have been received on\n    the connection.\n\nfunc (sc *ServerConn) Read() (*http.Request, error)\n    Read returns the next request on the wire. An ErrPersistEOF is returned if\n    it is gracefully determined that there are no more requests (e.g. after the\n    first request on an HTTP/1.0 connection, or after a Connection:close on a\n    HTTP/1.1 connection).\n\nfunc (sc *ServerConn) Write(req *http.Request, resp *http.Response) error\n    Write writes resp in response to req. To close the connection gracefully,\n    set the Response.Close field to true. Write should be considered operational\n    until it returns an error, regardless of any errors returned on the\n    ServerConn.Read side.\n\n"}, {"path": "stdlib/testing-synctest.md", "category": "stdlib", "name": "stdlib/testing-synctest", "content": "package synctest // import \"testing/synctest\"\n\nPackage synctest provides support for testing concurrent code.\n\nThe Test function runs a function in an isolated \"bubble\". Any goroutines\nstarted within the bubble are also part of the bubble.\n\n# Time\n\nWithin a bubble, the time package uses a fake clock. Each bubble has its own\nclock. The initial time is midnight UTC 2000-01-01.\n\nTime in a bubble only advances when every goroutine in the bubble is durably\nblocked. See below for the exact definition of \"durably blocked\".\n\nFor example, this test runs immediately rather than taking two seconds:\n\n    func TestTime(t *testing.T) {\n    \tsynctest.Test(t, func(t *testing.T) {\n    \t\tstart := time.Now() // always midnight UTC 2000-01-01\n    \t\tgo func() {\n    \t\t\ttime.Sleep(1 * time.Second)\n    \t\t\tt.Log(time.Since(start)) // always logs \"1s\"\n    \t\t}()\n    \t\ttime.Sleep(2 * time.Second) // the goroutine above will run before this Sleep returns\n    \t\tt.Log(time.Since(start))    // always logs \"2s\"\n    \t})\n    }\n\nTime stops advancing when the root goroutine of the bubble exits.\n\n# Blocking\n\nA goroutine in a bubble is \"durably blocked\" when it is blocked and can only\nbe unblocked by another goroutine in the same bubble. A goroutine which can be\nunblocked by an event from outside its bubble is not durably blocked.\n\nThe Wait function blocks until all other goroutines in the bubble are durably\nblocked.\n\nFor example:\n\n    func TestWait(t *testing.T) {\n    \tsynctest.Test(t, func(t *testing.T) {\n    \t\tdone := false\n    \t\tgo func() {\n    \t\t\tdone = true\n    \t\t}()\n    \t\t// Wait will block until the goroutine above has finished.\n    \t\tsynctest.Wait()\n    \t\tt.Log(done) // always logs \"true\"\n    \t})\n    }\n\nWhen every goroutine in a bubble is durably blocked:\n\n  - Wait returns, if it has been called.\n  - Otherwise, time advances to the next time that will unblock at least one\n    goroutine, if there is such a time and the root goroutine of the bubble has\n    not exited.\n  - Otherwise, there is a deadlock and Test panics.\n\nThe following operations durably block a goroutine:\n\n  - a blocking send or receive on a channel created within the bubble\n  - a blocking select statement where every case is a channel created within the\n    bubble\n  - sync.Cond.Wait\n  - sync.WaitGroup.Wait, when sync.WaitGroup.Add was called within the bubble\n  - time.Sleep\n\nOperations not in the above list are not durably blocking. In particular,\nthe following operations may block a goroutine, but are not durably blocking\nbecause the goroutine can be unblocked by an event occurring outside its bubble:\n\n  - locking a sync.Mutex or sync.RWMutex\n  - blocking on I/O, such as reading from a network socket\n  - system calls\n\n# Isolation\n\nA channel, time.Timer, or time.Ticker created within a bubble is associated with\nit. Operating on a bubbled channel, timer, or ticker from outside the bubble\npanics.\n\nA sync.WaitGroup becomes associated with a bubble on the first call to Add or\nGo. Once a WaitGroup is associated with a bubble, calling Add or Go from outside\nthat bubble is a fatal error. (As a technical limitation, a WaitGroup defined\nas a package variable, such as \"var wg sync.WaitGroup\", cannot be associated\nwith a bubble and operations on it may not be durably blocking. This limitation\ndoes not apply to a *WaitGroup stored in a package variable, such as \"var wg =\nnew(sync.WaitGroup)\".)\n\nsync.Cond.Wait is durably blocking. Waking a goroutine in a bubble blocked on\nCond.Wait from outside the bubble is a fatal error.\n\nCleanup functions and finalizers registered with runtime.AddCleanup and\nruntime.SetFinalizer run outside of any bubble.\n\n# Example: Context.AfterFunc\n\nThis example demonstrates testing the context.AfterFunc function.\n\nAfterFunc registers a function to execute in a new goroutine after a context is\ncanceled.\n\nThe test verifies that the function is not run before the context is canceled,\nand is run after the context is canceled.\n\n    func TestContextAfterFunc(t *testing.T) {\n    \tsynctest.Test(t, func(t *testing.T) {\n    \t\t// Create a context.Context which can be canceled.\n    \t\tctx, cancel := context.WithCancel(t.Context())\n\n    \t\t// context.AfterFunc registers a function to be called\n    \t\t// when a context is canceled.\n    \t\tafterFuncCalled := false\n    \t\tcontext.AfterFunc(ctx, func() {\n    \t\t\tafterFuncCalled = true\n    \t\t})\n\n    \t\t// The context has not been canceled, so the AfterFunc is not called.\n    \t\tsynctest.Wait()\n    \t\tif afterFuncCalled {\n    \t\t\tt.Fatalf(\"before context is canceled: AfterFunc called\")\n    \t\t}\n\n    \t\t// Cancel the context and wait for the AfterFunc to finish executing.\n    \t\t// Verify that the AfterFunc ran.\n    \t\tcancel()\n    \t\tsynctest.Wait()\n    \t\tif !afterFuncCalled {\n    \t\t\tt.Fatalf(\"before context is canceled: AfterFunc not called\")\n    \t\t}\n    \t})\n    }\n\n# Example: Context.WithTimeout\n\nThis example demonstrates testing the context.WithTimeout function.\n\nWithTimeout creates a context which is canceled after a timeout.\n\nThe test verifies that the context is not canceled before the timeout expires,\nand is canceled after the timeout expires.\n\n    func TestContextWithTimeout(t *testing.T) {\n    \tsynctest.Test(t, func(t *testing.T) {\n    \t\t// Create a context.Context which is canceled after a timeout.\n    \t\tconst timeout = 5 * time.Second\n    \t\tctx, cancel := context.WithTimeout(t.Context(), timeout)\n    \t\tdefer cancel()\n\n    \t\t// Wait just less than the timeout.\n    \t\ttime.Sleep(timeout - time.Nanosecond)\n    \t\tsynctest.Wait()\n    \t\tif err := ctx.Err(); err != nil {\n    \t\t\tt.Fatalf(\"before timeout: ctx.Err() = %v, want nil\\n\", err)\n    \t\t}\n\n    \t\t// Wait the rest of the way until the timeout.\n    \t\ttime.Sleep(time.Nanosecond)\n    \t\tsynctest.Wait()\n    \t\tif err := ctx.Err(); err != context.DeadlineExceeded {\n    \t\t\tt.Fatalf(\"after timeout: ctx.Err() = %v, want DeadlineExceeded\\n\", err)\n    \t\t}\n    \t})\n    }\n\n# Example: HTTP 100 Continue\n\nThis example demonstrates testing [http.Transport]'s 100 Continue handling.\n\nAn HTTP client sending a request can include an \"Expect: 100-continue\" header\nto tell the server that the client has additional data to send. The server may\nthen respond with an 100 Continue information response to request the data,\nor some other status to tell the client the data is not needed. For example,\na client uploading a large file might use this feature to confirm that the\nserver is willing to accept the file before sending it.\n\nThis test confirms that when sending an \"Expect: 100-continue\" header the\nHTTP client does not send a request's content before the server requests it,\nand that it does send the content after receiving a 100 Continue response.\n\n    func TestHTTPTransport100Continue(t *testing.T) {\n    \tsynctest.Test(t, func(*testing.T) {\n    \t\t// Create an in-process fake network connection.\n    \t\t// We cannot use a loopback network connection for this test,\n    \t\t// because goroutines blocked on network I/O prevent a synctest\n    \t\t// bubble from becoming idle.\n    \t\tsrvConn, cliConn := net.Pipe()\n    \t\tdefer cliConn.Close()\n    \t\tdefer srvConn.Close()\n\n    \t\ttr := &http.Transport{\n    \t\t\t// Use the fake network connection created above.\n    \t\t\tDialContext: func(ctx context.Context, network, address string) (net.Conn, error) {\n    \t\t\t\treturn cliConn, nil\n    \t\t\t},\n    \t\t\t// Enable \"Expect: 100-continue\" handling.\n    \t\t\tExpectContinueTimeout: 5 * time.Second,\n    \t\t}\n\n    \t\t// Send a request with the \"Expect: 100-continue\" header set.\n    \t\t// Send it in a new goroutine, since it won't complete until the end of the test.\n    \t\tbody := \"request body\"\n    \t\tgo func() {\n    \t\t\treq, _ := http.NewRequest(\"PUT\", \"http://test.tld/\", strings.NewReader(body))\n    \t\t\treq.Header.Set(\"Expect\", \"100-continue\")\n    \t\t\tresp, err := tr.RoundTrip(req)\n    \t\t\tif err != nil {\n    \t\t\t\tt.Errorf(\"RoundTrip: unexpected error %v\\n\", err)\n    \t\t\t} else {\n    \t\t\t\tresp.Body.Close()\n    \t\t\t}\n    \t\t}()\n\n    \t\t// Read the request headers sent by the client.\n    \t\treq, err := http.ReadRequest(bufio.NewReader(srvConn))\n    \t\tif err != nil {\n    \t\t\tt.Fatalf(\"ReadRequest: %v\\n\", err)\n    \t\t}\n\n    \t\t// Start a new goroutine copying the body sent by the client into a buffer.\n    \t\t// Wait for all goroutines in the bubble to block and verify that we haven't\n    \t\t// read anything from the client yet.\n    \t\tvar gotBody bytes.Buffer\n    \t\tgo io.Copy(&gotBody, req.Body)\n    \t\tsynctest.Wait()\n    \t\tif got, want := gotBody.String(), \"\"; got != want {\n    \t\t\tt.Fatalf(\"before sending 100 Continue, read body: %q, want %q\\n\", got, want)\n    \t\t}\n\n    \t\t// Write a \"100 Continue\" response to the client and verify that\n    \t\t// it sends the request body.\n    \t\tsrvConn.Write([]byte(\"HTTP/1.1 100 Continue\\r\\n\\r\\n\"))\n    \t\tsynctest.Wait()\n    \t\tif got, want := gotBody.String(), body; got != want {\n    \t\t\tt.Fatalf(\"after sending 100 Continue, read body: %q, want %q\\n\", got, want)\n    \t\t}\n\n    \t\t// Finish up by sending the \"200 OK\" response to conclude the request.\n    \t\tsrvConn.Write([]byte(\"HTTP/1.1 200 OK\\r\\n\\r\\n\"))\n\n    \t\t// We started several goroutines during the test.\n    \t\t// The synctest.Test call will wait for all of them to exit before returning.\n    \t})\n    }\n\nFUNCTIONS\n\nfunc Test(t *testing.T, f func(*testing.T))\n    Test executes f in a new bubble.\n\n    Test waits for all goroutines in the bubble to exit before returning.\n    If the goroutines in the bubble become deadlocked, the test fails.\n\n    Test must not be called from within a bubble.\n\n    The *testing.T provided to f has the following properties:\n\n      - T.Cleanup functions run inside the bubble, immediately before Test\n        returns.\n      - T.Context returns a context.Context with a Done channel associated with\n        the bubble.\n      - T.Run, T.Parallel, and T.Deadline must not be called.\n\nfunc Wait()\n    Wait blocks until every goroutine within the current bubble, other than the\n    current goroutine, is durably blocked.\n\n    Wait must not be called from outside a bubble. Wait must not be called\n    concurrently by multiple goroutines in the same bubble.\n\n"}, {"path": "stdlib/crypto-internal-fips140deps-cpu.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140deps-cpu", "content": "package cpu // import \"crypto/internal/fips140deps/cpu\"\n\n\nCONSTANTS\n\nconst (\n\tBigEndian = goarch.BigEndian\n\tAMD64     = goarch.IsAmd64 == 1\n\tARM64     = goarch.IsArm64 == 1\n\tPPC64     = goarch.IsPpc64 == 1\n\tPPC64le   = goarch.IsPpc64le == 1\n)\n\nVARIABLES\n\nvar (\n\tARM64HasAES    = cpu.ARM64.HasAES\n\tARM64HasPMULL  = cpu.ARM64.HasPMULL\n\tARM64HasSHA2   = cpu.ARM64.HasSHA2\n\tARM64HasSHA512 = cpu.ARM64.HasSHA512\n\tARM64HasSHA3   = cpu.ARM64.HasSHA3\n\n\tLOONG64HasLSX  = cpu.Loong64.HasLSX\n\tLOONG64HasLASX = cpu.Loong64.HasLASX\n\n\tS390XHasAES    = cpu.S390X.HasAES\n\tS390XHasAESCBC = cpu.S390X.HasAESCBC\n\tS390XHasAESCTR = cpu.S390X.HasAESCTR\n\tS390XHasAESGCM = cpu.S390X.HasAESGCM\n\tS390XHasECDSA  = cpu.S390X.HasECDSA\n\tS390XHasGHASH  = cpu.S390X.HasGHASH\n\tS390XHasSHA256 = cpu.S390X.HasSHA256\n\tS390XHasSHA3   = cpu.S390X.HasSHA3\n\tS390XHasSHA512 = cpu.S390X.HasSHA512\n\n\tX86HasAES       = cpu.X86.HasAES\n\tX86HasADX       = cpu.X86.HasADX\n\tX86HasAVX       = cpu.X86.HasAVX\n\tX86HasAVX2      = cpu.X86.HasAVX2\n\tX86HasBMI2      = cpu.X86.HasBMI2\n\tX86HasPCLMULQDQ = cpu.X86.HasPCLMULQDQ\n\tX86HasSHA       = cpu.X86.HasSHA\n\tX86HasSSE41     = cpu.X86.HasSSE41\n\tX86HasSSSE3     = cpu.X86.HasSSSE3\n)\n"}, {"path": "stdlib/internal-bytealg.md", "category": "stdlib", "name": "stdlib/internal-bytealg", "content": "package bytealg // import \"internal/bytealg\"\n\n\nCONSTANTS\n\nconst MaxBruteForce = 16\n    Empirical data shows that using Index can get better performance when len(s)\n    <= 16.\n\nconst PrimeRK = 16777619\n    PrimeRK is the prime base used in Rabin-Karp algorithm.\n\n\nVARIABLES\n\nvar MaxLen int\n    MaxLen is the maximum length of the string to be searched for (argument b)\n    in Index. If MaxLen is not 0, make sure MaxLen >= 4.\n\n\nFUNCTIONS\n\nfunc Compare(a, b []byte) int\nfunc CompareString(a, b string) int\nfunc Count(b []byte, c byte) int\nfunc CountString(s string, c byte) int\nfunc Cutover(n int) int\n    Cutover reports the number of failures of IndexByte we should tolerate\n    before switching over to Index. n is the number of bytes processed so far.\n    See the bytes.Index implementation for details.\n\nfunc Equal(a, b []byte) bool\n    Equal reports whether a and b are the same length and contain the same\n    bytes. A nil argument is equivalent to an empty slice.\n\n    Equal is equivalent to bytes.Equal. It is provided here for convenience,\n    because some packages cannot depend on bytes.\n\nfunc HashStr[T string | []byte](sep T) (uint32, uint32)\n    HashStr returns the hash and the appropriate multiplicative factor for use\n    in Rabin-Karp algorithm.\n\nfunc HashStrRev[T string | []byte](sep T) (uint32, uint32)\n    HashStrRev returns the hash of the reverse of sep and the appropriate\n    multiplicative factor for use in Rabin-Karp algorithm.\n\nfunc Index(a, b []byte) int\n    Index returns the index of the first instance of b in a, or -1 if b is not\n    present in a. Requires 2 <= len(b) <= MaxLen.\n\nfunc IndexByte(b []byte, c byte) int\nfunc IndexByteString(s string, c byte) int\nfunc IndexRabinKarp[T string | []byte](s, sep T) int\n    IndexRabinKarp uses the Rabin-Karp search algorithm to return the index of\n    the first occurrence of sep in s, or -1 if not present.\n\nfunc IndexString(a, b string) int\n    IndexString returns the index of the first instance of b in a, or -1 if b is\n    not present in a. Requires 2 <= len(b) <= MaxLen.\n\nfunc LastIndexByte(s []byte, c byte) int\nfunc LastIndexByteString(s string, c byte) int\nfunc LastIndexRabinKarp[T string | []byte](s, sep T) int\n    LastIndexRabinKarp uses the Rabin-Karp search algorithm to return the last\n    index of the occurrence of sep in s, or -1 if not present.\n\nfunc MakeNoZero(n int) []byte\n    MakeNoZero makes a slice of length n and capacity of at least n Bytes\n    without zeroing the bytes (including the bytes between len and cap).\n    It is the caller's responsibility to ensure uninitialized bytes do not leak\n    to the end user.\n\n"}, {"path": "stdlib/runtime-race.md", "category": "stdlib", "name": "stdlib/runtime-race", "content": "package race // import \"runtime/race\"\n\nPackage race implements data race detection logic. No public\ninterface is provided. For details about the race detector see\nhttps://golang.org/doc/articles/race_detector.html\n"}, {"path": "stdlib/syscall.md", "category": "stdlib", "name": "stdlib/syscall", "content": "package syscall // import \"syscall\"\n\nPackage syscall contains an interface to the low-level operating system\nprimitives. The details vary depending on the underlying system, and by default,\ngodoc will display the syscall documentation for the current system. If you\nwant godoc to display syscall documentation for another system, set $GOOS and\n$GOARCH to the desired system. For example, if you want to view documentation\nfor freebsd/arm on linux/amd64, set $GOOS to freebsd and $GOARCH to arm.\nThe primary use of syscall is inside other packages that provide a more portable\ninterface to the system, such as \"os\", \"time\" and \"net\". Use those packages\nrather than this one if you can. For details of the functions and data types\nin this package consult the manuals for the appropriate operating system.\nThese calls return err == nil to indicate success; otherwise err is an operating\nsystem error describing the failure. On most systems, that error has type Errno.\n\nNOTE: Most of the functions, types, and constants defined in this package are\nalso available in the golang.org/x/sys package. That package has more system\ncall support than this one, and most new code should prefer that package where\npossible. See https://golang.org/s/go1.4-syscall for more information.\n\nCONSTANTS\n\nconst (\n\tAF_APPLETALK                      = 0x10\n\tAF_CCITT                          = 0xa\n\tAF_CHAOS                          = 0x5\n\tAF_CNT                            = 0x15\n\tAF_COIP                           = 0x14\n\tAF_DATAKIT                        = 0x9\n\tAF_DECnet                         = 0xc\n\tAF_DLI                            = 0xd\n\tAF_E164                           = 0x1c\n\tAF_ECMA                           = 0x8\n\tAF_HYLINK                         = 0xf\n\tAF_IEEE80211                      = 0x25\n\tAF_IMPLINK                        = 0x3\n\tAF_INET                           = 0x2\n\tAF_INET6                          = 0x1e\n\tAF_IPX                            = 0x17\n\tAF_ISDN                           = 0x1c\n\tAF_ISO                            = 0x7\n\tAF_LAT                            = 0xe\n\tAF_LINK                           = 0x12\n\tAF_LOCAL                          = 0x1\n\tAF_MAX                            = 0x28\n\tAF_NATM                           = 0x1f\n\tAF_NDRV                           = 0x1b\n\tAF_NETBIOS                        = 0x21\n\tAF_NS                             = 0x6\n\tAF_OSI                            = 0x7\n\tAF_PPP                            = 0x22\n\tAF_PUP                            = 0x4\n\tAF_RESERVED_36                    = 0x24\n\tAF_ROUTE                          = 0x11\n\tAF_SIP                            = 0x18\n\tAF_SNA                            = 0xb\n\tAF_SYSTEM                         = 0x20\n\tAF_UNIX                           = 0x1\n\tAF_UNSPEC                         = 0x0\n\tAF_UTUN                           = 0x26\n\tB0                                = 0x0\n\tB110                              = 0x6e\n\tB115200                           = 0x1c200\n\tB1200                             = 0x4b0\n\tB134                              = 0x86\n\tB14400                            = 0x3840\n\tB150                              = 0x96\n\tB1800                             = 0x708\n\tB19200                            = 0x4b00\n\tB200                              = 0xc8\n\tB230400                           = 0x38400\n\tB2400                             = 0x960\n\tB28800                            = 0x7080\n\tB300                              = 0x12c\n\tB38400                            = 0x9600\n\tB4800                             = 0x12c0\n\tB50                               = 0x32\n\tB57600                            = 0xe100\n\tB600                              = 0x258\n\tB7200                             = 0x1c20\n\tB75                               = 0x4b\n\tB76800                            = 0x12c00\n\tB9600                             = 0x2580\n\tBIOCFLUSH                         = 0x20004268\n\tBIOCGBLEN                         = 0x40044266\n\tBIOCGDLT                          = 0x4004426a\n\tBIOCGDLTLIST                      = 0xc00c4279\n\tBIOCGETIF                         = 0x4020426b\n\tBIOCGHDRCMPLT                     = 0x40044274\n\tBIOCGRSIG                         = 0x40044272\n\tBIOCGRTIMEOUT                     = 0x4010426e\n\tBIOCGSEESENT                      = 0x40044276\n\tBIOCGSTATS                        = 0x4008426f\n\tBIOCIMMEDIATE                     = 0x80044270\n\tBIOCPROMISC                       = 0x20004269\n\tBIOCSBLEN                         = 0xc0044266\n\tBIOCSDLT                          = 0x80044278\n\tBIOCSETF                          = 0x80104267\n\tBIOCSETIF                         = 0x8020426c\n\tBIOCSHDRCMPLT                     = 0x80044275\n\tBIOCSRSIG                         = 0x80044273\n\tBIOCSRTIMEOUT                     = 0x8010426d\n\tBIOCSSEESENT                      = 0x80044277\n\tBIOCVERSION                       = 0x40044271\n\tBPF_A                             = 0x10\n\tBPF_ABS                           = 0x20\n\tBPF_ADD                           = 0x0\n\tBPF_ALIGNMENT                     = 0x4\n\tBPF_ALU                           = 0x4\n\tBPF_AND                           = 0x50\n\tBPF_B                             = 0x10\n\tBPF_DIV                           = 0x30\n\tBPF_H                             = 0x8\n\tBPF_IMM                           = 0x0\n\tBPF_IND                           = 0x40\n\tBPF_JA                            = 0x0\n\tBPF_JEQ                           = 0x10\n\tBPF_JGE                           = 0x30\n\tBPF_JGT                           = 0x20\n\tBPF_JMP                           = 0x5\n\tBPF_JSET                          = 0x40\n\tBPF_K                             = 0x0\n\tBPF_LD                            = 0x0\n\tBPF_LDX                           = 0x1\n\tBPF_LEN                           = 0x80\n\tBPF_LSH                           = 0x60\n\tBPF_MAJOR_VERSION                 = 0x1\n\tBPF_MAXBUFSIZE                    = 0x80000\n\tBPF_MAXINSNS                      = 0x200\n\tBPF_MEM                           = 0x60\n\tBPF_MEMWORDS                      = 0x10\n\tBPF_MINBUFSIZE                    = 0x20\n\tBPF_MINOR_VERSION                 = 0x1\n\tBPF_MISC                          = 0x7\n\tBPF_MSH                           = 0xa0\n\tBPF_MUL                           = 0x20\n\tBPF_NEG                           = 0x80\n\tBPF_OR                            = 0x40\n\tBPF_RELEASE                       = 0x30bb6\n\tBPF_RET                           = 0x6\n\tBPF_RSH                           = 0x70\n\tBPF_ST                            = 0x2\n\tBPF_STX                           = 0x3\n\tBPF_SUB                           = 0x10\n\tBPF_TAX                           = 0x0\n\tBPF_TXA                           = 0x80\n\tBPF_W                             = 0x0\n\tBPF_X                             = 0x8\n\tBRKINT                            = 0x2\n\tCFLUSH                            = 0xf\n\tCLOCAL                            = 0x8000\n\tCREAD                             = 0x800\n\tCS5                               = 0x0\n\tCS6                               = 0x100\n\tCS7                               = 0x200\n\tCS8                               = 0x300\n\tCSIZE                             = 0x300\n\tCSTART                            = 0x11\n\tCSTATUS                           = 0x14\n\tCSTOP                             = 0x13\n\tCSTOPB                            = 0x400\n\tCSUSP                             = 0x1a\n\tCTL_MAXNAME                       = 0xc\n\tCTL_NET                           = 0x4\n\tDLT_APPLE_IP_OVER_IEEE1394        = 0x8a\n\tDLT_ARCNET                        = 0x7\n\tDLT_ATM_CLIP                      = 0x13\n\tDLT_ATM_RFC1483                   = 0xb\n\tDLT_AX25                          = 0x3\n\tDLT_CHAOS                         = 0x5\n\tDLT_CHDLC                         = 0x68\n\tDLT_C_HDLC                        = 0x68\n\tDLT_EN10MB                        = 0x1\n\tDLT_EN3MB                         = 0x2\n\tDLT_FDDI                          = 0xa\n\tDLT_IEEE802                       = 0x6\n\tDLT_IEEE802_11                    = 0x69\n\tDLT_IEEE802_11_RADIO              = 0x7f\n\tDLT_IEEE802_11_RADIO_AVS          = 0xa3\n\tDLT_LINUX_SLL                     = 0x71\n\tDLT_LOOP                          = 0x6c\n\tDLT_NULL                          = 0x0\n\tDLT_PFLOG                         = 0x75\n\tDLT_PFSYNC                        = 0x12\n\tDLT_PPP                           = 0x9\n\tDLT_PPP_BSDOS                     = 0x10\n\tDLT_PPP_SERIAL                    = 0x32\n\tDLT_PRONET                        = 0x4\n\tDLT_RAW                           = 0xc\n\tDLT_SLIP                          = 0x8\n\tDLT_SLIP_BSDOS                    = 0xf\n\tDT_BLK                            = 0x6\n\tDT_CHR                            = 0x2\n\tDT_DIR                            = 0x4\n\tDT_FIFO                           = 0x1\n\tDT_LNK                            = 0xa\n\tDT_REG                            = 0x8\n\tDT_SOCK                           = 0xc\n\tDT_UNKNOWN                        = 0x0\n\tDT_WHT                            = 0xe\n\tECHO                              = 0x8\n\tECHOCTL                           = 0x40\n\tECHOE                             = 0x2\n\tECHOK                             = 0x4\n\tECHOKE                            = 0x1\n\tECHONL                            = 0x10\n\tECHOPRT                           = 0x20\n\tEVFILT_AIO                        = -0x3\n\tEVFILT_FS                         = -0x9\n\tEVFILT_MACHPORT                   = -0x8\n\tEVFILT_PROC                       = -0x5\n\tEVFILT_READ                       = -0x1\n\tEVFILT_SIGNAL                     = -0x6\n\tEVFILT_SYSCOUNT                   = 0xe\n\tEVFILT_THREADMARKER               = 0xe\n\tEVFILT_TIMER                      = -0x7\n\tEVFILT_USER                       = -0xa\n\tEVFILT_VM                         = -0xc\n\tEVFILT_VNODE                      = -0x4\n\tEVFILT_WRITE                      = -0x2\n\tEV_ADD                            = 0x1\n\tEV_CLEAR                          = 0x20\n\tEV_DELETE                         = 0x2\n\tEV_DISABLE                        = 0x8\n\tEV_DISPATCH                       = 0x80\n\tEV_ENABLE                         = 0x4\n\tEV_EOF                            = 0x8000\n\tEV_ERROR                          = 0x4000\n\tEV_FLAG0                          = 0x1000\n\tEV_FLAG1                          = 0x2000\n\tEV_ONESHOT                        = 0x10\n\tEV_OOBAND                         = 0x2000\n\tEV_POLL                           = 0x1000\n\tEV_RECEIPT                        = 0x40\n\tEV_SYSFLAGS                       = 0xf000\n\tEXTA                              = 0x4b00\n\tEXTB                              = 0x9600\n\tEXTPROC                           = 0x800\n\tFD_CLOEXEC                        = 0x1\n\tFD_SETSIZE                        = 0x400\n\tFLUSHO                            = 0x800000\n\tF_ADDFILESIGS                     = 0x3d\n\tF_ADDSIGS                         = 0x3b\n\tF_ALLOCATEALL                     = 0x4\n\tF_ALLOCATECONTIG                  = 0x2\n\tF_CHKCLEAN                        = 0x29\n\tF_DUPFD                           = 0x0\n\tF_DUPFD_CLOEXEC                   = 0x43\n\tF_FINDSIGS                        = 0x4e\n\tF_FLUSH_DATA                      = 0x28\n\tF_FREEZE_FS                       = 0x35\n\tF_FULLFSYNC                       = 0x33\n\tF_GETCODEDIR                      = 0x48\n\tF_GETFD                           = 0x1\n\tF_GETFL                           = 0x3\n\tF_GETLK                           = 0x7\n\tF_GETLKPID                        = 0x42\n\tF_GETNOSIGPIPE                    = 0x4a\n\tF_GETOWN                          = 0x5\n\tF_GETPATH                         = 0x32\n\tF_GETPATH_MTMINFO                 = 0x47\n\tF_GETPROTECTIONCLASS              = 0x3f\n\tF_GETPROTECTIONLEVEL              = 0x4d\n\tF_GLOBAL_NOCACHE                  = 0x37\n\tF_LOG2PHYS                        = 0x31\n\tF_LOG2PHYS_EXT                    = 0x41\n\tF_NOCACHE                         = 0x30\n\tF_NODIRECT                        = 0x3e\n\tF_OK                              = 0x0\n\tF_PATHPKG_CHECK                   = 0x34\n\tF_PEOFPOSMODE                     = 0x3\n\tF_PREALLOCATE                     = 0x2a\n\tF_RDADVISE                        = 0x2c\n\tF_RDAHEAD                         = 0x2d\n\tF_RDLCK                           = 0x1\n\tF_SETBACKINGSTORE                 = 0x46\n\tF_SETFD                           = 0x2\n\tF_SETFL                           = 0x4\n\tF_SETLK                           = 0x8\n\tF_SETLKW                          = 0x9\n\tF_SETLKWTIMEOUT                   = 0xa\n\tF_SETNOSIGPIPE                    = 0x49\n\tF_SETOWN                          = 0x6\n\tF_SETPROTECTIONCLASS              = 0x40\n\tF_SETSIZE                         = 0x2b\n\tF_SINGLE_WRITER                   = 0x4c\n\tF_THAW_FS                         = 0x36\n\tF_TRANSCODEKEY                    = 0x4b\n\tF_UNLCK                           = 0x2\n\tF_VOLPOSMODE                      = 0x4\n\tF_WRLCK                           = 0x3\n\tHUPCL                             = 0x4000\n\tICANON                            = 0x100\n\tICMP6_FILTER                      = 0x12\n\tICRNL                             = 0x100\n\tIEXTEN                            = 0x400\n\tIFF_ALLMULTI                      = 0x200\n\tIFF_ALTPHYS                       = 0x4000\n\tIFF_BROADCAST                     = 0x2\n\tIFF_DEBUG                         = 0x4\n\tIFF_LINK0                         = 0x1000\n\tIFF_LINK1                         = 0x2000\n\tIFF_LINK2                         = 0x4000\n\tIFF_LOOPBACK                      = 0x8\n\tIFF_MULTICAST                     = 0x8000\n\tIFF_NOARP                         = 0x80\n\tIFF_NOTRAILERS                    = 0x20\n\tIFF_OACTIVE                       = 0x400\n\tIFF_POINTOPOINT                   = 0x10\n\tIFF_PROMISC                       = 0x100\n\tIFF_RUNNING                       = 0x40\n\tIFF_SIMPLEX                       = 0x800\n\tIFF_UP                            = 0x1\n\tIFNAMSIZ                          = 0x10\n\tIFT_1822                          = 0x2\n\tIFT_AAL5                          = 0x31\n\tIFT_ARCNET                        = 0x23\n\tIFT_ARCNETPLUS                    = 0x24\n\tIFT_ATM                           = 0x25\n\tIFT_BRIDGE                        = 0xd1\n\tIFT_CARP                          = 0xf8\n\tIFT_CELLULAR                      = 0xff\n\tIFT_CEPT                          = 0x13\n\tIFT_DS3                           = 0x1e\n\tIFT_ENC                           = 0xf4\n\tIFT_EON                           = 0x19\n\tIFT_ETHER                         = 0x6\n\tIFT_FAITH                         = 0x38\n\tIFT_FDDI                          = 0xf\n\tIFT_FRELAY                        = 0x20\n\tIFT_FRELAYDCE                     = 0x2c\n\tIFT_GIF                           = 0x37\n\tIFT_HDH1822                       = 0x3\n\tIFT_HIPPI                         = 0x2f\n\tIFT_HSSI                          = 0x2e\n\tIFT_HY                            = 0xe\n\tIFT_IEEE1394                      = 0x90\n\tIFT_IEEE8023ADLAG                 = 0x88\n\tIFT_ISDNBASIC                     = 0x14\n\tIFT_ISDNPRIMARY                   = 0x15\n\tIFT_ISO88022LLC                   = 0x29\n\tIFT_ISO88023                      = 0x7\n\tIFT_ISO88024                      = 0x8\n\tIFT_ISO88025                      = 0x9\n\tIFT_ISO88026                      = 0xa\n\tIFT_L2VLAN                        = 0x87\n\tIFT_LAPB                          = 0x10\n\tIFT_LOCALTALK                     = 0x2a\n\tIFT_LOOP                          = 0x18\n\tIFT_MIOX25                        = 0x26\n\tIFT_MODEM                         = 0x30\n\tIFT_NSIP                          = 0x1b\n\tIFT_OTHER                         = 0x1\n\tIFT_P10                           = 0xc\n\tIFT_P80                           = 0xd\n\tIFT_PARA                          = 0x22\n\tIFT_PDP                           = 0xff\n\tIFT_PFLOG                         = 0xf5\n\tIFT_PFSYNC                        = 0xf6\n\tIFT_PPP                           = 0x17\n\tIFT_PROPMUX                       = 0x36\n\tIFT_PROPVIRTUAL                   = 0x35\n\tIFT_PTPSERIAL                     = 0x16\n\tIFT_RS232                         = 0x21\n\tIFT_SDLC                          = 0x11\n\tIFT_SIP                           = 0x1f\n\tIFT_SLIP                          = 0x1c\n\tIFT_SMDSDXI                       = 0x2b\n\tIFT_SMDSICIP                      = 0x34\n\tIFT_SONET                         = 0x27\n\tIFT_SONETPATH                     = 0x32\n\tIFT_SONETVT                       = 0x33\n\tIFT_STARLAN                       = 0xb\n\tIFT_STF                           = 0x39\n\tIFT_T1                            = 0x12\n\tIFT_ULTRA                         = 0x1d\n\tIFT_V35                           = 0x2d\n\tIFT_X25                           = 0x5\n\tIFT_X25DDN                        = 0x4\n\tIFT_X25PLE                        = 0x28\n\tIFT_XETHER                        = 0x1a\n\tIGNBRK                            = 0x1\n\tIGNCR                             = 0x80\n\tIGNPAR                            = 0x4\n\tIMAXBEL                           = 0x2000\n\tINLCR                             = 0x40\n\tINPCK                             = 0x10\n\tIN_CLASSA_HOST                    = 0xffffff\n\tIN_CLASSA_MAX                     = 0x80\n\tIN_CLASSA_NET                     = 0xff000000\n\tIN_CLASSA_NSHIFT                  = 0x18\n\tIN_CLASSB_HOST                    = 0xffff\n\tIN_CLASSB_MAX                     = 0x10000\n\tIN_CLASSB_NET                     = 0xffff0000\n\tIN_CLASSB_NSHIFT                  = 0x10\n\tIN_CLASSC_HOST                    = 0xff\n\tIN_CLASSC_NET                     = 0xffffff00\n\tIN_CLASSC_NSHIFT                  = 0x8\n\tIN_CLASSD_HOST                    = 0xfffffff\n\tIN_CLASSD_NET                     = 0xf0000000\n\tIN_CLASSD_NSHIFT                  = 0x1c\n\tIN_LINKLOCALNETNUM                = 0xa9fe0000\n\tIN_LOOPBACKNET                    = 0x7f\n\tIPPROTO_3PC                       = 0x22\n\tIPPROTO_ADFS                      = 0x44\n\tIPPROTO_AH                        = 0x33\n\tIPPROTO_AHIP                      = 0x3d\n\tIPPROTO_APES                      = 0x63\n\tIPPROTO_ARGUS                     = 0xd\n\tIPPROTO_AX25                      = 0x5d\n\tIPPROTO_BHA                       = 0x31\n\tIPPROTO_BLT                       = 0x1e\n\tIPPROTO_BRSATMON                  = 0x4c\n\tIPPROTO_CFTP                      = 0x3e\n\tIPPROTO_CHAOS                     = 0x10\n\tIPPROTO_CMTP                      = 0x26\n\tIPPROTO_CPHB                      = 0x49\n\tIPPROTO_CPNX                      = 0x48\n\tIPPROTO_DDP                       = 0x25\n\tIPPROTO_DGP                       = 0x56\n\tIPPROTO_DIVERT                    = 0xfe\n\tIPPROTO_DONE                      = 0x101\n\tIPPROTO_DSTOPTS                   = 0x3c\n\tIPPROTO_EGP                       = 0x8\n\tIPPROTO_EMCON                     = 0xe\n\tIPPROTO_ENCAP                     = 0x62\n\tIPPROTO_EON                       = 0x50\n\tIPPROTO_ESP                       = 0x32\n\tIPPROTO_ETHERIP                   = 0x61\n\tIPPROTO_FRAGMENT                  = 0x2c\n\tIPPROTO_GGP                       = 0x3\n\tIPPROTO_GMTP                      = 0x64\n\tIPPROTO_GRE                       = 0x2f\n\tIPPROTO_HELLO                     = 0x3f\n\tIPPROTO_HMP                       = 0x14\n\tIPPROTO_HOPOPTS                   = 0x0\n\tIPPROTO_ICMP                      = 0x1\n\tIPPROTO_ICMPV6                    = 0x3a\n\tIPPROTO_IDP                       = 0x16\n\tIPPROTO_IDPR                      = 0x23\n\tIPPROTO_IDRP                      = 0x2d\n\tIPPROTO_IGMP                      = 0x2\n\tIPPROTO_IGP                       = 0x55\n\tIPPROTO_IGRP                      = 0x58\n\tIPPROTO_IL                        = 0x28\n\tIPPROTO_INLSP                     = 0x34\n\tIPPROTO_INP                       = 0x20\n\tIPPROTO_IP                        = 0x0\n\tIPPROTO_IPCOMP                    = 0x6c\n\tIPPROTO_IPCV                      = 0x47\n\tIPPROTO_IPEIP                     = 0x5e\n\tIPPROTO_IPIP                      = 0x4\n\tIPPROTO_IPPC                      = 0x43\n\tIPPROTO_IPV4                      = 0x4\n\tIPPROTO_IPV6                      = 0x29\n\tIPPROTO_IRTP                      = 0x1c\n\tIPPROTO_KRYPTOLAN                 = 0x41\n\tIPPROTO_LARP                      = 0x5b\n\tIPPROTO_LEAF1                     = 0x19\n\tIPPROTO_LEAF2                     = 0x1a\n\tIPPROTO_MAX                       = 0x100\n\tIPPROTO_MAXID                     = 0x34\n\tIPPROTO_MEAS                      = 0x13\n\tIPPROTO_MHRP                      = 0x30\n\tIPPROTO_MICP                      = 0x5f\n\tIPPROTO_MTP                       = 0x5c\n\tIPPROTO_MUX                       = 0x12\n\tIPPROTO_ND                        = 0x4d\n\tIPPROTO_NHRP                      = 0x36\n\tIPPROTO_NONE                      = 0x3b\n\tIPPROTO_NSP                       = 0x1f\n\tIPPROTO_NVPII                     = 0xb\n\tIPPROTO_OSPFIGP                   = 0x59\n\tIPPROTO_PGM                       = 0x71\n\tIPPROTO_PIGP                      = 0x9\n\tIPPROTO_PIM                       = 0x67\n\tIPPROTO_PRM                       = 0x15\n\tIPPROTO_PUP                       = 0xc\n\tIPPROTO_PVP                       = 0x4b\n\tIPPROTO_RAW                       = 0xff\n\tIPPROTO_RCCMON                    = 0xa\n\tIPPROTO_RDP                       = 0x1b\n\tIPPROTO_ROUTING                   = 0x2b\n\tIPPROTO_RSVP                      = 0x2e\n\tIPPROTO_RVD                       = 0x42\n\tIPPROTO_SATEXPAK                  = 0x40\n\tIPPROTO_SATMON                    = 0x45\n\tIPPROTO_SCCSP                     = 0x60\n\tIPPROTO_SCTP                      = 0x84\n\tIPPROTO_SDRP                      = 0x2a\n\tIPPROTO_SEP                       = 0x21\n\tIPPROTO_SRPC                      = 0x5a\n\tIPPROTO_ST                        = 0x7\n\tIPPROTO_SVMTP                     = 0x52\n\tIPPROTO_SWIPE                     = 0x35\n\tIPPROTO_TCF                       = 0x57\n\tIPPROTO_TCP                       = 0x6\n\tIPPROTO_TP                        = 0x1d\n\tIPPROTO_TPXX                      = 0x27\n\tIPPROTO_TRUNK1                    = 0x17\n\tIPPROTO_TRUNK2                    = 0x18\n\tIPPROTO_TTP                       = 0x54\n\tIPPROTO_UDP                       = 0x11\n\tIPPROTO_VINES                     = 0x53\n\tIPPROTO_VISA                      = 0x46\n\tIPPROTO_VMTP                      = 0x51\n\tIPPROTO_WBEXPAK                   = 0x4f\n\tIPPROTO_WBMON                     = 0x4e\n\tIPPROTO_WSN                       = 0x4a\n\tIPPROTO_XNET                      = 0xf\n\tIPPROTO_XTP                       = 0x24\n\tIPV6_2292DSTOPTS                  = 0x17\n\tIPV6_2292HOPLIMIT                 = 0x14\n\tIPV6_2292HOPOPTS                  = 0x16\n\tIPV6_2292NEXTHOP                  = 0x15\n\tIPV6_2292PKTINFO                  = 0x13\n\tIPV6_2292PKTOPTIONS               = 0x19\n\tIPV6_2292RTHDR                    = 0x18\n\tIPV6_BINDV6ONLY                   = 0x1b\n\tIPV6_BOUND_IF                     = 0x7d\n\tIPV6_CHECKSUM                     = 0x1a\n\tIPV6_DEFAULT_MULTICAST_HOPS       = 0x1\n\tIPV6_DEFAULT_MULTICAST_LOOP       = 0x1\n\tIPV6_DEFHLIM                      = 0x40\n\tIPV6_FAITH                        = 0x1d\n\tIPV6_FLOWINFO_MASK                = 0xffffff0f\n\tIPV6_FLOWLABEL_MASK               = 0xffff0f00\n\tIPV6_FRAGTTL                      = 0x78\n\tIPV6_FW_ADD                       = 0x1e\n\tIPV6_FW_DEL                       = 0x1f\n\tIPV6_FW_FLUSH                     = 0x20\n\tIPV6_FW_GET                       = 0x22\n\tIPV6_FW_ZERO                      = 0x21\n\tIPV6_HLIMDEC                      = 0x1\n\tIPV6_IPSEC_POLICY                 = 0x1c\n\tIPV6_JOIN_GROUP                   = 0xc\n\tIPV6_LEAVE_GROUP                  = 0xd\n\tIPV6_MAXHLIM                      = 0xff\n\tIPV6_MAXOPTHDR                    = 0x800\n\tIPV6_MAXPACKET                    = 0xffff\n\tIPV6_MAX_GROUP_SRC_FILTER         = 0x200\n\tIPV6_MAX_MEMBERSHIPS              = 0xfff\n\tIPV6_MAX_SOCK_SRC_FILTER          = 0x80\n\tIPV6_MIN_MEMBERSHIPS              = 0x1f\n\tIPV6_MMTU                         = 0x500\n\tIPV6_MULTICAST_HOPS               = 0xa\n\tIPV6_MULTICAST_IF                 = 0x9\n\tIPV6_MULTICAST_LOOP               = 0xb\n\tIPV6_PORTRANGE                    = 0xe\n\tIPV6_PORTRANGE_DEFAULT            = 0x0\n\tIPV6_PORTRANGE_HIGH               = 0x1\n\tIPV6_PORTRANGE_LOW                = 0x2\n\tIPV6_RECVTCLASS                   = 0x23\n\tIPV6_RTHDR_LOOSE                  = 0x0\n\tIPV6_RTHDR_STRICT                 = 0x1\n\tIPV6_RTHDR_TYPE_0                 = 0x0\n\tIPV6_SOCKOPT_RESERVED1            = 0x3\n\tIPV6_TCLASS                       = 0x24\n\tIPV6_UNICAST_HOPS                 = 0x4\n\tIPV6_V6ONLY                       = 0x1b\n\tIPV6_VERSION                      = 0x60\n\tIPV6_VERSION_MASK                 = 0xf0\n\tIP_ADD_MEMBERSHIP                 = 0xc\n\tIP_ADD_SOURCE_MEMBERSHIP          = 0x46\n\tIP_BLOCK_SOURCE                   = 0x48\n\tIP_BOUND_IF                       = 0x19\n\tIP_DEFAULT_MULTICAST_LOOP         = 0x1\n\tIP_DEFAULT_MULTICAST_TTL          = 0x1\n\tIP_DF                             = 0x4000\n\tIP_DROP_MEMBERSHIP                = 0xd\n\tIP_DROP_SOURCE_MEMBERSHIP         = 0x47\n\tIP_DUMMYNET_CONFIGURE             = 0x3c\n\tIP_DUMMYNET_DEL                   = 0x3d\n\tIP_DUMMYNET_FLUSH                 = 0x3e\n\tIP_DUMMYNET_GET                   = 0x40\n\tIP_FAITH                          = 0x16\n\tIP_FW_ADD                         = 0x28\n\tIP_FW_DEL                         = 0x29\n\tIP_FW_FLUSH                       = 0x2a\n\tIP_FW_GET                         = 0x2c\n\tIP_FW_RESETLOG                    = 0x2d\n\tIP_FW_ZERO                        = 0x2b\n\tIP_HDRINCL                        = 0x2\n\tIP_IPSEC_POLICY                   = 0x15\n\tIP_MAXPACKET                      = 0xffff\n\tIP_MAX_GROUP_SRC_FILTER           = 0x200\n\tIP_MAX_MEMBERSHIPS                = 0xfff\n\tIP_MAX_SOCK_MUTE_FILTER           = 0x80\n\tIP_MAX_SOCK_SRC_FILTER            = 0x80\n\tIP_MF                             = 0x2000\n\tIP_MIN_MEMBERSHIPS                = 0x1f\n\tIP_MSFILTER                       = 0x4a\n\tIP_MSS                            = 0x240\n\tIP_MULTICAST_IF                   = 0x9\n\tIP_MULTICAST_IFINDEX              = 0x42\n\tIP_MULTICAST_LOOP                 = 0xb\n\tIP_MULTICAST_TTL                  = 0xa\n\tIP_MULTICAST_VIF                  = 0xe\n\tIP_NAT__XXX                       = 0x37\n\tIP_OFFMASK                        = 0x1fff\n\tIP_OLD_FW_ADD                     = 0x32\n\tIP_OLD_FW_DEL                     = 0x33\n\tIP_OLD_FW_FLUSH                   = 0x34\n\tIP_OLD_FW_GET                     = 0x36\n\tIP_OLD_FW_RESETLOG                = 0x38\n\tIP_OLD_FW_ZERO                    = 0x35\n\tIP_OPTIONS                        = 0x1\n\tIP_PKTINFO                        = 0x1a\n\tIP_PORTRANGE                      = 0x13\n\tIP_PORTRANGE_DEFAULT              = 0x0\n\tIP_PORTRANGE_HIGH                 = 0x1\n\tIP_PORTRANGE_LOW                  = 0x2\n\tIP_RECVDSTADDR                    = 0x7\n\tIP_RECVIF                         = 0x14\n\tIP_RECVOPTS                       = 0x5\n\tIP_RECVPKTINFO                    = 0x1a\n\tIP_RECVRETOPTS                    = 0x6\n\tIP_RECVTTL                        = 0x18\n\tIP_RETOPTS                        = 0x8\n\tIP_RF                             = 0x8000\n\tIP_RSVP_OFF                       = 0x10\n\tIP_RSVP_ON                        = 0xf\n\tIP_RSVP_VIF_OFF                   = 0x12\n\tIP_RSVP_VIF_ON                    = 0x11\n\tIP_STRIPHDR                       = 0x17\n\tIP_TOS                            = 0x3\n\tIP_TRAFFIC_MGT_BACKGROUND         = 0x41\n\tIP_TTL                            = 0x4\n\tIP_UNBLOCK_SOURCE                 = 0x49\n\tISIG                              = 0x80\n\tISTRIP                            = 0x20\n\tIUTF8                             = 0x4000\n\tIXANY                             = 0x800\n\tIXOFF                             = 0x400\n\tIXON                              = 0x200\n\tLOCK_EX                           = 0x2\n\tLOCK_NB                           = 0x4\n\tLOCK_SH                           = 0x1\n\tLOCK_UN                           = 0x8\n\tMADV_CAN_REUSE                    = 0x9\n\tMADV_DONTNEED                     = 0x4\n\tMADV_FREE                         = 0x5\n\tMADV_FREE_REUSABLE                = 0x7\n\tMADV_FREE_REUSE                   = 0x8\n\tMADV_NORMAL                       = 0x0\n\tMADV_RANDOM                       = 0x1\n\tMADV_SEQUENTIAL                   = 0x2\n\tMADV_WILLNEED                     = 0x3\n\tMADV_ZERO_WIRED_PAGES             = 0x6\n\tMAP_ANON                          = 0x1000\n\tMAP_COPY                          = 0x2\n\tMAP_FILE                          = 0x0\n\tMAP_FIXED                         = 0x10\n\tMAP_HASSEMAPHORE                  = 0x200\n\tMAP_JIT                           = 0x800\n\tMAP_NOCACHE                       = 0x400\n\tMAP_NOEXTEND                      = 0x100\n\tMAP_NORESERVE                     = 0x40\n\tMAP_PRIVATE                       = 0x2\n\tMAP_RENAME                        = 0x20\n\tMAP_RESERVED0080                  = 0x80\n\tMAP_SHARED                        = 0x1\n\tMCL_CURRENT                       = 0x1\n\tMCL_FUTURE                        = 0x2\n\tMSG_CTRUNC                        = 0x20\n\tMSG_DONTROUTE                     = 0x4\n\tMSG_DONTWAIT                      = 0x80\n\tMSG_EOF                           = 0x100\n\tMSG_EOR                           = 0x8\n\tMSG_FLUSH                         = 0x400\n\tMSG_HAVEMORE                      = 0x2000\n\tMSG_HOLD                          = 0x800\n\tMSG_NEEDSA                        = 0x10000\n\tMSG_OOB                           = 0x1\n\tMSG_PEEK                          = 0x2\n\tMSG_RCVMORE                       = 0x4000\n\tMSG_SEND                          = 0x1000\n\tMSG_TRUNC                         = 0x10\n\tMSG_WAITALL                       = 0x40\n\tMSG_WAITSTREAM                    = 0x200\n\tMS_ASYNC                          = 0x1\n\tMS_DEACTIVATE                     = 0x8\n\tMS_INVALIDATE                     = 0x2\n\tMS_KILLPAGES                      = 0x4\n\tMS_SYNC                           = 0x10\n\tNAME_MAX                          = 0xff\n\tNET_RT_DUMP                       = 0x1\n\tNET_RT_DUMP2                      = 0x7\n\tNET_RT_FLAGS                      = 0x2\n\tNET_RT_IFLIST                     = 0x3\n\tNET_RT_IFLIST2                    = 0x6\n\tNET_RT_MAXID                      = 0xa\n\tNET_RT_STAT                       = 0x4\n\tNET_RT_TRASH                      = 0x5\n\tNOFLSH                            = 0x80000000\n\tNOTE_ABSOLUTE                     = 0x8\n\tNOTE_ATTRIB                       = 0x8\n\tNOTE_BACKGROUND                   = 0x40\n\tNOTE_CHILD                        = 0x4\n\tNOTE_CRITICAL                     = 0x20\n\tNOTE_DELETE                       = 0x1\n\tNOTE_EXEC                         = 0x20000000\n\tNOTE_EXIT                         = 0x80000000\n\tNOTE_EXITSTATUS                   = 0x4000000\n\tNOTE_EXIT_CSERROR                 = 0x40000\n\tNOTE_EXIT_DECRYPTFAIL             = 0x10000\n\tNOTE_EXIT_DETAIL                  = 0x2000000\n\tNOTE_EXIT_DETAIL_MASK             = 0x70000\n\tNOTE_EXIT_MEMORY                  = 0x20000\n\tNOTE_EXIT_REPARENTED              = 0x80000\n\tNOTE_EXTEND                       = 0x4\n\tNOTE_FFAND                        = 0x40000000\n\tNOTE_FFCOPY                       = 0xc0000000\n\tNOTE_FFCTRLMASK                   = 0xc0000000\n\tNOTE_FFLAGSMASK                   = 0xffffff\n\tNOTE_FFNOP                        = 0x0\n\tNOTE_FFOR                         = 0x80000000\n\tNOTE_FORK                         = 0x40000000\n\tNOTE_LEEWAY                       = 0x10\n\tNOTE_LINK                         = 0x10\n\tNOTE_LOWAT                        = 0x1\n\tNOTE_NONE                         = 0x80\n\tNOTE_NSECONDS                     = 0x4\n\tNOTE_PCTRLMASK                    = -0x100000\n\tNOTE_PDATAMASK                    = 0xfffff\n\tNOTE_REAP                         = 0x10000000\n\tNOTE_RENAME                       = 0x20\n\tNOTE_REVOKE                       = 0x40\n\tNOTE_SECONDS                      = 0x1\n\tNOTE_SIGNAL                       = 0x8000000\n\tNOTE_TRACK                        = 0x1\n\tNOTE_TRACKERR                     = 0x2\n\tNOTE_TRIGGER                      = 0x1000000\n\tNOTE_USECONDS                     = 0x2\n\tNOTE_VM_ERROR                     = 0x10000000\n\tNOTE_VM_PRESSURE                  = 0x80000000\n\tNOTE_VM_PRESSURE_SUDDEN_TERMINATE = 0x20000000\n\tNOTE_VM_PRESSURE_TERMINATE        = 0x40000000\n\tNOTE_WRITE                        = 0x2\n\tOCRNL                             = 0x10\n\tOFDEL                             = 0x20000\n\tOFILL                             = 0x80\n\tONLCR                             = 0x2\n\tONLRET                            = 0x40\n\tONOCR                             = 0x20\n\tONOEOT                            = 0x8\n\tOPOST                             = 0x1\n\tO_ACCMODE                         = 0x3\n\tO_ALERT                           = 0x20000000\n\tO_APPEND                          = 0x8\n\tO_ASYNC                           = 0x40\n\tO_CLOEXEC                         = 0x1000000\n\tO_CREAT                           = 0x200\n\tO_DIRECTORY                       = 0x100000\n\tO_DP_GETRAWENCRYPTED              = 0x1\n\tO_DSYNC                           = 0x400000\n\tO_EVTONLY                         = 0x8000\n\tO_EXCL                            = 0x800\n\tO_EXLOCK                          = 0x20\n\tO_FSYNC                           = 0x80\n\tO_NDELAY                          = 0x4\n\tO_NOCTTY                          = 0x20000\n\tO_NOFOLLOW                        = 0x100\n\tO_NONBLOCK                        = 0x4\n\tO_POPUP                           = 0x80000000\n\tO_RDONLY                          = 0x0\n\tO_RDWR                            = 0x2\n\tO_SHLOCK                          = 0x10\n\tO_SYMLINK                         = 0x200000\n\tO_SYNC                            = 0x80\n\tO_TRUNC                           = 0x400\n\tO_WRONLY                          = 0x1\n\tPARENB                            = 0x1000\n\tPARMRK                            = 0x8\n\tPARODD                            = 0x2000\n\tPENDIN                            = 0x20000000\n\tPRIO_PGRP                         = 0x1\n\tPRIO_PROCESS                      = 0x0\n\tPRIO_USER                         = 0x2\n\tPROT_EXEC                         = 0x4\n\tPROT_NONE                         = 0x0\n\tPROT_READ                         = 0x1\n\tPROT_WRITE                        = 0x2\n\tPT_ATTACH                         = 0xa\n\tPT_ATTACHEXC                      = 0xe\n\tPT_CONTINUE                       = 0x7\n\tPT_DENY_ATTACH                    = 0x1f\n\tPT_DETACH                         = 0xb\n\tPT_FIRSTMACH                      = 0x20\n\tPT_FORCEQUOTA                     = 0x1e\n\tPT_KILL                           = 0x8\n\tPT_READ_D                         = 0x2\n\tPT_READ_I                         = 0x1\n\tPT_READ_U                         = 0x3\n\tPT_SIGEXC                         = 0xc\n\tPT_STEP                           = 0x9\n\tPT_THUPDATE                       = 0xd\n\tPT_TRACE_ME                       = 0x0\n\tPT_WRITE_D                        = 0x5\n\tPT_WRITE_I                        = 0x4\n\tPT_WRITE_U                        = 0x6\n\tRLIMIT_AS                         = 0x5\n\tRLIMIT_CORE                       = 0x4\n\tRLIMIT_CPU                        = 0x0\n\tRLIMIT_CPU_USAGE_MONITOR          = 0x2\n\tRLIMIT_DATA                       = 0x2\n\tRLIMIT_FSIZE                      = 0x1\n\tRLIMIT_NOFILE                     = 0x8\n\tRLIMIT_STACK                      = 0x3\n\tRLIM_INFINITY                     = 0x7fffffffffffffff\n\tRTAX_AUTHOR                       = 0x6\n\tRTAX_BRD                          = 0x7\n\tRTAX_DST                          = 0x0\n\tRTAX_GATEWAY                      = 0x1\n\tRTAX_GENMASK                      = 0x3\n\tRTAX_IFA                          = 0x5\n\tRTAX_IFP                          = 0x4\n\tRTAX_MAX                          = 0x8\n\tRTAX_NETMASK                      = 0x2\n\tRTA_AUTHOR                        = 0x40\n\tRTA_BRD                           = 0x80\n\tRTA_DST                           = 0x1\n\tRTA_GATEWAY                       = 0x2\n\tRTA_GENMASK                       = 0x8\n\tRTA_IFA                           = 0x20\n\tRTA_IFP                           = 0x10\n\tRTA_NETMASK                       = 0x4\n\tRTF_BLACKHOLE                     = 0x1000\n\tRTF_BROADCAST                     = 0x400000\n\tRTF_CLONING                       = 0x100\n\tRTF_CONDEMNED                     = 0x2000000\n\tRTF_DELCLONE                      = 0x80\n\tRTF_DONE                          = 0x40\n\tRTF_DYNAMIC                       = 0x10\n\tRTF_GATEWAY                       = 0x2\n\tRTF_HOST                          = 0x4\n\tRTF_IFREF                         = 0x4000000\n\tRTF_IFSCOPE                       = 0x1000000\n\tRTF_LLINFO                        = 0x400\n\tRTF_LOCAL                         = 0x200000\n\tRTF_MODIFIED                      = 0x20\n\tRTF_MULTICAST                     = 0x800000\n\tRTF_PINNED                        = 0x100000\n\tRTF_PRCLONING                     = 0x10000\n\tRTF_PROTO1                        = 0x8000\n\tRTF_PROTO2                        = 0x4000\n\tRTF_PROTO3                        = 0x40000\n\tRTF_PROXY                         = 0x8000000\n\tRTF_REJECT                        = 0x8\n\tRTF_ROUTER                        = 0x10000000\n\tRTF_STATIC                        = 0x800\n\tRTF_UP                            = 0x1\n\tRTF_WASCLONED                     = 0x20000\n\tRTF_XRESOLVE                      = 0x200\n\tRTM_ADD                           = 0x1\n\tRTM_CHANGE                        = 0x3\n\tRTM_DELADDR                       = 0xd\n\tRTM_DELETE                        = 0x2\n\tRTM_DELMADDR                      = 0x10\n\tRTM_GET                           = 0x4\n\tRTM_GET2                          = 0x14\n\tRTM_IFINFO                        = 0xe\n\tRTM_IFINFO2                       = 0x12\n\tRTM_LOCK                          = 0x8\n\tRTM_LOSING                        = 0x5\n\tRTM_MISS                          = 0x7\n\tRTM_NEWADDR                       = 0xc\n\tRTM_NEWMADDR                      = 0xf\n\tRTM_NEWMADDR2                     = 0x13\n\tRTM_OLDADD                        = 0x9\n\tRTM_OLDDEL                        = 0xa\n\tRTM_REDIRECT                      = 0x6\n\tRTM_RESOLVE                       = 0xb\n\tRTM_RTTUNIT                       = 0xf4240\n\tRTM_VERSION                       = 0x5\n\tRTV_EXPIRE                        = 0x4\n\tRTV_HOPCOUNT                      = 0x2\n\tRTV_MTU                           = 0x1\n\tRTV_RPIPE                         = 0x8\n\tRTV_RTT                           = 0x40\n\tRTV_RTTVAR                        = 0x80\n\tRTV_SPIPE                         = 0x10\n\tRTV_SSTHRESH                      = 0x20\n\tRUSAGE_CHILDREN                   = -0x1\n\tRUSAGE_SELF                       = 0x0\n\tSCM_CREDS                         = 0x3\n\tSCM_RIGHTS                        = 0x1\n\tSCM_TIMESTAMP                     = 0x2\n\tSCM_TIMESTAMP_MONOTONIC           = 0x4\n\tSHUT_RD                           = 0x0\n\tSHUT_RDWR                         = 0x2\n\tSHUT_WR                           = 0x1\n\tSIOCADDMULTI                      = 0x80206931\n\tSIOCAIFADDR                       = 0x8040691a\n\tSIOCARPIPLL                       = 0xc0206928\n\tSIOCATMARK                        = 0x40047307\n\tSIOCAUTOADDR                      = 0xc0206926\n\tSIOCAUTONETMASK                   = 0x80206927\n\tSIOCDELMULTI                      = 0x80206932\n\tSIOCDIFADDR                       = 0x80206919\n\tSIOCDIFPHYADDR                    = 0x80206941\n\tSIOCGDRVSPEC                      = 0xc028697b\n\tSIOCGETVLAN                       = 0xc020697f\n\tSIOCGHIWAT                        = 0x40047301\n\tSIOCGIFADDR                       = 0xc0206921\n\tSIOCGIFALTMTU                     = 0xc0206948\n\tSIOCGIFASYNCMAP                   = 0xc020697c\n\tSIOCGIFBOND                       = 0xc0206947\n\tSIOCGIFBRDADDR                    = 0xc0206923\n\tSIOCGIFCAP                        = 0xc020695b\n\tSIOCGIFCONF                       = 0xc00c6924\n\tSIOCGIFDEVMTU                     = 0xc0206944\n\tSIOCGIFDSTADDR                    = 0xc0206922\n\tSIOCGIFFLAGS                      = 0xc0206911\n\tSIOCGIFGENERIC                    = 0xc020693a\n\tSIOCGIFKPI                        = 0xc0206987\n\tSIOCGIFMAC                        = 0xc0206982\n\tSIOCGIFMEDIA                      = 0xc02c6938\n\tSIOCGIFMETRIC                     = 0xc0206917\n\tSIOCGIFMTU                        = 0xc0206933\n\tSIOCGIFNETMASK                    = 0xc0206925\n\tSIOCGIFPDSTADDR                   = 0xc0206940\n\tSIOCGIFPHYS                       = 0xc0206935\n\tSIOCGIFPSRCADDR                   = 0xc020693f\n\tSIOCGIFSTATUS                     = 0xc331693d\n\tSIOCGIFVLAN                       = 0xc020697f\n\tSIOCGIFWAKEFLAGS                  = 0xc0206988\n\tSIOCGLOWAT                        = 0x40047303\n\tSIOCGPGRP                         = 0x40047309\n\tSIOCIFCREATE                      = 0xc0206978\n\tSIOCIFCREATE2                     = 0xc020697a\n\tSIOCIFDESTROY                     = 0x80206979\n\tSIOCIFGCLONERS                    = 0xc0106981\n\tSIOCRSLVMULTI                     = 0xc010693b\n\tSIOCSDRVSPEC                      = 0x8028697b\n\tSIOCSETVLAN                       = 0x8020697e\n\tSIOCSHIWAT                        = 0x80047300\n\tSIOCSIFADDR                       = 0x8020690c\n\tSIOCSIFALTMTU                     = 0x80206945\n\tSIOCSIFASYNCMAP                   = 0x8020697d\n\tSIOCSIFBOND                       = 0x80206946\n\tSIOCSIFBRDADDR                    = 0x80206913\n\tSIOCSIFCAP                        = 0x8020695a\n\tSIOCSIFDSTADDR                    = 0x8020690e\n\tSIOCSIFFLAGS                      = 0x80206910\n\tSIOCSIFGENERIC                    = 0x80206939\n\tSIOCSIFKPI                        = 0x80206986\n\tSIOCSIFLLADDR                     = 0x8020693c\n\tSIOCSIFMAC                        = 0x80206983\n\tSIOCSIFMEDIA                      = 0xc0206937\n\tSIOCSIFMETRIC                     = 0x80206918\n\tSIOCSIFMTU                        = 0x80206934\n\tSIOCSIFNETMASK                    = 0x80206916\n\tSIOCSIFPHYADDR                    = 0x8040693e\n\tSIOCSIFPHYS                       = 0x80206936\n\tSIOCSIFVLAN                       = 0x8020697e\n\tSIOCSLOWAT                        = 0x80047302\n\tSIOCSPGRP                         = 0x80047308\n\tSOCK_DGRAM                        = 0x2\n\tSOCK_MAXADDRLEN                   = 0xff\n\tSOCK_RAW                          = 0x3\n\tSOCK_RDM                          = 0x4\n\tSOCK_SEQPACKET                    = 0x5\n\tSOCK_STREAM                       = 0x1\n\tSOL_SOCKET                        = 0xffff\n\tSOMAXCONN                         = 0x80\n\tSO_ACCEPTCONN                     = 0x2\n\tSO_BROADCAST                      = 0x20\n\tSO_DEBUG                          = 0x1\n\tSO_DONTROUTE                      = 0x10\n\tSO_DONTTRUNC                      = 0x2000\n\tSO_ERROR                          = 0x1007\n\tSO_KEEPALIVE                      = 0x8\n\tSO_LABEL                          = 0x1010\n\tSO_LINGER                         = 0x80\n\tSO_LINGER_SEC                     = 0x1080\n\tSO_NKE                            = 0x1021\n\tSO_NOADDRERR                      = 0x1023\n\tSO_NOSIGPIPE                      = 0x1022\n\tSO_NOTIFYCONFLICT                 = 0x1026\n\tSO_NP_EXTENSIONS                  = 0x1083\n\tSO_NREAD                          = 0x1020\n\tSO_NUMRCVPKT                      = 0x1112\n\tSO_NWRITE                         = 0x1024\n\tSO_OOBINLINE                      = 0x100\n\tSO_PEERLABEL                      = 0x1011\n\tSO_RANDOMPORT                     = 0x1082\n\tSO_RCVBUF                         = 0x1002\n\tSO_RCVLOWAT                       = 0x1004\n\tSO_RCVTIMEO                       = 0x1006\n\tSO_REUSEADDR                      = 0x4\n\tSO_REUSEPORT                      = 0x200\n\tSO_REUSESHAREUID                  = 0x1025\n\tSO_SNDBUF                         = 0x1001\n\tSO_SNDLOWAT                       = 0x1003\n\tSO_SNDTIMEO                       = 0x1005\n\tSO_TIMESTAMP                      = 0x400\n\tSO_TIMESTAMP_MONOTONIC            = 0x800\n\tSO_TYPE                           = 0x1008\n\tSO_UPCALLCLOSEWAIT                = 0x1027\n\tSO_USELOOPBACK                    = 0x40\n\tSO_WANTMORE                       = 0x4000\n\tSO_WANTOOBFLAG                    = 0x8000\n\tS_IEXEC                           = 0x40\n\tS_IFBLK                           = 0x6000\n\tS_IFCHR                           = 0x2000\n\tS_IFDIR                           = 0x4000\n\tS_IFIFO                           = 0x1000\n\tS_IFLNK                           = 0xa000\n\tS_IFMT                            = 0xf000\n\tS_IFREG                           = 0x8000\n\tS_IFSOCK                          = 0xc000\n\tS_IFWHT                           = 0xe000\n\tS_IREAD                           = 0x100\n\tS_IRGRP                           = 0x20\n\tS_IROTH                           = 0x4\n\tS_IRUSR                           = 0x100\n\tS_IRWXG                           = 0x38\n\tS_IRWXO                           = 0x7\n\tS_IRWXU                           = 0x1c0\n\tS_ISGID                           = 0x400\n\tS_ISTXT                           = 0x200\n\tS_ISUID                           = 0x800\n\tS_ISVTX                           = 0x200\n\tS_IWGRP                           = 0x10\n\tS_IWOTH                           = 0x2\n\tS_IWRITE                          = 0x80\n\tS_IWUSR                           = 0x80\n\tS_IXGRP                           = 0x8\n\tS_IXOTH                           = 0x1\n\tS_IXUSR                           = 0x40\n\tTCIFLUSH                          = 0x1\n\tTCIOFLUSH                         = 0x3\n\tTCOFLUSH                          = 0x2\n\tTCP_CONNECTIONTIMEOUT             = 0x20\n\tTCP_ENABLE_ECN                    = 0x104\n\tTCP_KEEPALIVE                     = 0x10\n\tTCP_KEEPCNT                       = 0x102\n\tTCP_KEEPINTVL                     = 0x101\n\tTCP_MAXHLEN                       = 0x3c\n\tTCP_MAXOLEN                       = 0x28\n\tTCP_MAXSEG                        = 0x2\n\tTCP_MAXWIN                        = 0xffff\n\tTCP_MAX_SACK                      = 0x4\n\tTCP_MAX_WINSHIFT                  = 0xe\n\tTCP_MINMSS                        = 0xd8\n\tTCP_MSS                           = 0x200\n\tTCP_NODELAY                       = 0x1\n\tTCP_NOOPT                         = 0x8\n\tTCP_NOPUSH                        = 0x4\n\tTCP_NOTSENT_LOWAT                 = 0x201\n\tTCP_RXT_CONNDROPTIME              = 0x80\n\tTCP_RXT_FINDROP                   = 0x100\n\tTCP_SENDMOREACKS                  = 0x103\n\tTCSAFLUSH                         = 0x2\n\tTIOCCBRK                          = 0x2000747a\n\tTIOCCDTR                          = 0x20007478\n\tTIOCCONS                          = 0x80047462\n\tTIOCDCDTIMESTAMP                  = 0x40107458\n\tTIOCDRAIN                         = 0x2000745e\n\tTIOCDSIMICROCODE                  = 0x20007455\n\tTIOCEXCL                          = 0x2000740d\n\tTIOCEXT                           = 0x80047460\n\tTIOCFLUSH                         = 0x80047410\n\tTIOCGDRAINWAIT                    = 0x40047456\n\tTIOCGETA                          = 0x40487413\n\tTIOCGETD                          = 0x4004741a\n\tTIOCGPGRP                         = 0x40047477\n\tTIOCGWINSZ                        = 0x40087468\n\tTIOCIXOFF                         = 0x20007480\n\tTIOCIXON                          = 0x20007481\n\tTIOCMBIC                          = 0x8004746b\n\tTIOCMBIS                          = 0x8004746c\n\tTIOCMGDTRWAIT                     = 0x4004745a\n\tTIOCMGET                          = 0x4004746a\n\tTIOCMODG                          = 0x40047403\n\tTIOCMODS                          = 0x80047404\n\tTIOCMSDTRWAIT                     = 0x8004745b\n\tTIOCMSET                          = 0x8004746d\n\tTIOCM_CAR                         = 0x40\n\tTIOCM_CD                          = 0x40\n\tTIOCM_CTS                         = 0x20\n\tTIOCM_DSR                         = 0x100\n\tTIOCM_DTR                         = 0x2\n\tTIOCM_LE                          = 0x1\n\tTIOCM_RI                          = 0x80\n\tTIOCM_RNG                         = 0x80\n\tTIOCM_RTS                         = 0x4\n\tTIOCM_SR                          = 0x10\n\tTIOCM_ST                          = 0x8\n\tTIOCNOTTY                         = 0x20007471\n\tTIOCNXCL                          = 0x2000740e\n\tTIOCOUTQ                          = 0x40047473\n\tTIOCPKT                           = 0x80047470\n\tTIOCPKT_DATA                      = 0x0\n\tTIOCPKT_DOSTOP                    = 0x20\n\tTIOCPKT_FLUSHREAD                 = 0x1\n\tTIOCPKT_FLUSHWRITE                = 0x2\n\tTIOCPKT_IOCTL                     = 0x40\n\tTIOCPKT_NOSTOP                    = 0x10\n\tTIOCPKT_START                     = 0x8\n\tTIOCPKT_STOP                      = 0x4\n\tTIOCPTYGNAME                      = 0x40807453\n\tTIOCPTYGRANT                      = 0x20007454\n\tTIOCPTYUNLK                       = 0x20007452\n\tTIOCREMOTE                        = 0x80047469\n\tTIOCSBRK                          = 0x2000747b\n\tTIOCSCONS                         = 0x20007463\n\tTIOCSCTTY                         = 0x20007461\n\tTIOCSDRAINWAIT                    = 0x80047457\n\tTIOCSDTR                          = 0x20007479\n\tTIOCSETA                          = 0x80487414\n\tTIOCSETAF                         = 0x80487416\n\tTIOCSETAW                         = 0x80487415\n\tTIOCSETD                          = 0x8004741b\n\tTIOCSIG                           = 0x2000745f\n\tTIOCSPGRP                         = 0x80047476\n\tTIOCSTART                         = 0x2000746e\n\tTIOCSTAT                          = 0x20007465\n\tTIOCSTI                           = 0x80017472\n\tTIOCSTOP                          = 0x2000746f\n\tTIOCSWINSZ                        = 0x80087467\n\tTIOCTIMESTAMP                     = 0x40107459\n\tTIOCUCNTL                         = 0x80047466\n\tTOSTOP                            = 0x400000\n\tVDISCARD                          = 0xf\n\tVDSUSP                            = 0xb\n\tVEOF                              = 0x0\n\tVEOL                              = 0x1\n\tVEOL2                             = 0x2\n\tVERASE                            = 0x3\n\tVINTR                             = 0x8\n\tVKILL                             = 0x5\n\tVLNEXT                            = 0xe\n\tVMIN                              = 0x10\n\tVQUIT                             = 0x9\n\tVREPRINT                          = 0x6\n\tVSTART                            = 0xc\n\tVSTATUS                           = 0x12\n\tVSTOP                             = 0xd\n\tVSUSP                             = 0xa\n\tVT0                               = 0x0\n\tVT1                               = 0x10000\n\tVTDLY                             = 0x10000\n\tVTIME                             = 0x11\n\tVWERASE                           = 0x4\n\tWCONTINUED                        = 0x10\n\tWCOREFLAG                         = 0x80\n\tWEXITED                           = 0x4\n\tWNOHANG                           = 0x1\n\tWNOWAIT                           = 0x20\n\tWORDSIZE                          = 0x40\n\tWSTOPPED                          = 0x8\n\tWUNTRACED                         = 0x2\n)\nconst (\n\tE2BIG           = Errno(0x7)\n\tEACCES          = Errno(0xd)\n\tEADDRINUSE      = Errno(0x30)\n\tEADDRNOTAVAIL   = Errno(0x31)\n\tEAFNOSUPPORT    = Errno(0x2f)\n\tEAGAIN          = Errno(0x23)\n\tEALREADY        = Errno(0x25)\n\tEAUTH           = Errno(0x50)\n\tEBADARCH        = Errno(0x56)\n\tEBADEXEC        = Errno(0x55)\n\tEBADF           = Errno(0x9)\n\tEBADMACHO       = Errno(0x58)\n\tEBADMSG         = Errno(0x5e)\n\tEBADRPC         = Errno(0x48)\n\tEBUSY           = Errno(0x10)\n\tECANCELED       = Errno(0x59)\n\tECHILD          = Errno(0xa)\n\tECONNABORTED    = Errno(0x35)\n\tECONNREFUSED    = Errno(0x3d)\n\tECONNRESET      = Errno(0x36)\n\tEDEADLK         = Errno(0xb)\n\tEDESTADDRREQ    = Errno(0x27)\n\tEDEVERR         = Errno(0x53)\n\tEDOM            = Errno(0x21)\n\tEDQUOT          = Errno(0x45)\n\tEEXIST          = Errno(0x11)\n\tEFAULT          = Errno(0xe)\n\tEFBIG           = Errno(0x1b)\n\tEFTYPE          = Errno(0x4f)\n\tEHOSTDOWN       = Errno(0x40)\n\tEHOSTUNREACH    = Errno(0x41)\n\tEIDRM           = Errno(0x5a)\n\tEILSEQ          = Errno(0x5c)\n\tEINPROGRESS     = Errno(0x24)\n\tEINTR           = Errno(0x4)\n\tEINVAL          = Errno(0x16)\n\tEIO             = Errno(0x5)\n\tEISCONN         = Errno(0x38)\n\tEISDIR          = Errno(0x15)\n\tELAST           = Errno(0x6a)\n\tELOOP           = Errno(0x3e)\n\tEMFILE          = Errno(0x18)\n\tEMLINK          = Errno(0x1f)\n\tEMSGSIZE        = Errno(0x28)\n\tEMULTIHOP       = Errno(0x5f)\n\tENAMETOOLONG    = Errno(0x3f)\n\tENEEDAUTH       = Errno(0x51)\n\tENETDOWN        = Errno(0x32)\n\tENETRESET       = Errno(0x34)\n\tENETUNREACH     = Errno(0x33)\n\tENFILE          = Errno(0x17)\n\tENOATTR         = Errno(0x5d)\n\tENOBUFS         = Errno(0x37)\n\tENODATA         = Errno(0x60)\n\tENODEV          = Errno(0x13)\n\tENOENT          = Errno(0x2)\n\tENOEXEC         = Errno(0x8)\n\tENOLCK          = Errno(0x4d)\n\tENOLINK         = Errno(0x61)\n\tENOMEM          = Errno(0xc)\n\tENOMSG          = Errno(0x5b)\n\tENOPOLICY       = Errno(0x67)\n\tENOPROTOOPT     = Errno(0x2a)\n\tENOSPC          = Errno(0x1c)\n\tENOSR           = Errno(0x62)\n\tENOSTR          = Errno(0x63)\n\tENOSYS          = Errno(0x4e)\n\tENOTBLK         = Errno(0xf)\n\tENOTCONN        = Errno(0x39)\n\tENOTDIR         = Errno(0x14)\n\tENOTEMPTY       = Errno(0x42)\n\tENOTRECOVERABLE = Errno(0x68)\n\tENOTSOCK        = Errno(0x26)\n\tENOTSUP         = Errno(0x2d)\n\tENOTTY          = Errno(0x19)\n\tENXIO           = Errno(0x6)\n\tEOPNOTSUPP      = Errno(0x66)\n\tEOVERFLOW       = Errno(0x54)\n\tEOWNERDEAD      = Errno(0x69)\n\tEPERM           = Errno(0x1)\n\tEPFNOSUPPORT    = Errno(0x2e)\n\tEPIPE           = Errno(0x20)\n\tEPROCLIM        = Errno(0x43)\n\tEPROCUNAVAIL    = Errno(0x4c)\n\tEPROGMISMATCH   = Errno(0x4b)\n\tEPROGUNAVAIL    = Errno(0x4a)\n\tEPROTO          = Errno(0x64)\n\tEPROTONOSUPPORT = Errno(0x2b)\n\tEPROTOTYPE      = Errno(0x29)\n\tEPWROFF         = Errno(0x52)\n\tEQFULL          = Errno(0x6a)\n\tERANGE          = Errno(0x22)\n\tEREMOTE         = Errno(0x47)\n\tEROFS           = Errno(0x1e)\n\tERPCMISMATCH    = Errno(0x49)\n\tESHLIBVERS      = Errno(0x57)\n\tESHUTDOWN       = Errno(0x3a)\n\tESOCKTNOSUPPORT = Errno(0x2c)\n\tESPIPE          = Errno(0x1d)\n\tESRCH           = Errno(0x3)\n\tESTALE          = Errno(0x46)\n\tETIME           = Errno(0x65)\n\tETIMEDOUT       = Errno(0x3c)\n\tETOOMANYREFS    = Errno(0x3b)\n\tETXTBSY         = Errno(0x1a)\n\tEUSERS          = Errno(0x44)\n\tEWOULDBLOCK     = Errno(0x23)\n\tEXDEV           = Errno(0x12)\n)\n    Errors\n\nconst (\n\tSIGABRT   = Signal(0x6)\n\tSIGALRM   = Signal(0xe)\n\tSIGBUS    = Signal(0xa)\n\tSIGCHLD   = Signal(0x14)\n\tSIGCONT   = Signal(0x13)\n\tSIGEMT    = Signal(0x7)\n\tSIGFPE    = Signal(0x8)\n\tSIGHUP    = Signal(0x1)\n\tSIGILL    = Signal(0x4)\n\tSIGINFO   = Signal(0x1d)\n\tSIGINT    = Signal(0x2)\n\tSIGIO     = Signal(0x17)\n\tSIGIOT    = Signal(0x6)\n\tSIGKILL   = Signal(0x9)\n\tSIGPIPE   = Signal(0xd)\n\tSIGPROF   = Signal(0x1b)\n\tSIGQUIT   = Signal(0x3)\n\tSIGSEGV   = Signal(0xb)\n\tSIGSTOP   = Signal(0x11)\n\tSIGSYS    = Signal(0xc)\n\tSIGTERM   = Signal(0xf)\n\tSIGTRAP   = Signal(0x5)\n\tSIGTSTP   = Signal(0x12)\n\tSIGTTIN   = Signal(0x15)\n\tSIGTTOU   = Signal(0x16)\n\tSIGURG    = Signal(0x10)\n\tSIGUSR1   = Signal(0x1e)\n\tSIGUSR2   = Signal(0x1f)\n\tSIGVTALRM = Signal(0x1a)\n\tSIGWINCH  = Signal(0x1c)\n\tSIGXCPU   = Signal(0x18)\n\tSIGXFSZ   = Signal(0x19)\n)\n    Signals\n\nconst (\n\tSYS_SYSCALL                        = 0\n\tSYS_EXIT                           = 1\n\tSYS_FORK                           = 2\n\tSYS_READ                           = 3\n\tSYS_WRITE                          = 4\n\tSYS_OPEN                           = 5\n\tSYS_CLOSE                          = 6\n\tSYS_WAIT4                          = 7\n\tSYS_LINK                           = 9\n\tSYS_UNLINK                         = 10\n\tSYS_CHDIR                          = 12\n\tSYS_FCHDIR                         = 13\n\tSYS_MKNOD                          = 14\n\tSYS_CHMOD                          = 15\n\tSYS_CHOWN                          = 16\n\tSYS_GETFSSTAT                      = 18\n\tSYS_GETPID                         = 20\n\tSYS_SETUID                         = 23\n\tSYS_GETUID                         = 24\n\tSYS_GETEUID                        = 25\n\tSYS_PTRACE                         = 26\n\tSYS_RECVMSG                        = 27\n\tSYS_SENDMSG                        = 28\n\tSYS_RECVFROM                       = 29\n\tSYS_ACCEPT                         = 30\n\tSYS_GETPEERNAME                    = 31\n\tSYS_GETSOCKNAME                    = 32\n\tSYS_ACCESS                         = 33\n\tSYS_CHFLAGS                        = 34\n\tSYS_FCHFLAGS                       = 35\n\tSYS_SYNC                           = 36\n\tSYS_KILL                           = 37\n\tSYS_GETPPID                        = 39\n\tSYS_DUP                            = 41\n\tSYS_PIPE                           = 42\n\tSYS_GETEGID                        = 43\n\tSYS_SIGACTION                      = 46\n\tSYS_GETGID                         = 47\n\tSYS_SIGPROCMASK                    = 48\n\tSYS_GETLOGIN                       = 49\n\tSYS_SETLOGIN                       = 50\n\tSYS_ACCT                           = 51\n\tSYS_SIGPENDING                     = 52\n\tSYS_SIGALTSTACK                    = 53\n\tSYS_IOCTL                          = 54\n\tSYS_REBOOT                         = 55\n\tSYS_REVOKE                         = 56\n\tSYS_SYMLINK                        = 57\n\tSYS_READLINK                       = 58\n\tSYS_EXECVE                         = 59\n\tSYS_UMASK                          = 60\n\tSYS_CHROOT                         = 61\n\tSYS_MSYNC                          = 65\n\tSYS_VFORK                          = 66\n\tSYS_MUNMAP                         = 73\n\tSYS_MPROTECT                       = 74\n\tSYS_MADVISE                        = 75\n\tSYS_MINCORE                        = 78\n\tSYS_GETGROUPS                      = 79\n\tSYS_SETGROUPS                      = 80\n\tSYS_GETPGRP                        = 81\n\tSYS_SETPGID                        = 82\n\tSYS_SETITIMER                      = 83\n\tSYS_SWAPON                         = 85\n\tSYS_GETITIMER                      = 86\n\tSYS_GETDTABLESIZE                  = 89\n\tSYS_DUP2                           = 90\n\tSYS_FCNTL                          = 92\n\tSYS_SELECT                         = 93\n\tSYS_FSYNC                          = 95\n\tSYS_SETPRIORITY                    = 96\n\tSYS_SOCKET                         = 97\n\tSYS_CONNECT                        = 98\n\tSYS_GETPRIORITY                    = 100\n\tSYS_BIND                           = 104\n\tSYS_SETSOCKOPT                     = 105\n\tSYS_LISTEN                         = 106\n\tSYS_SIGSUSPEND                     = 111\n\tSYS_GETTIMEOFDAY                   = 116\n\tSYS_GETRUSAGE                      = 117\n\tSYS_GETSOCKOPT                     = 118\n\tSYS_READV                          = 120\n\tSYS_WRITEV                         = 121\n\tSYS_SETTIMEOFDAY                   = 122\n\tSYS_FCHOWN                         = 123\n\tSYS_FCHMOD                         = 124\n\tSYS_SETREUID                       = 126\n\tSYS_SETREGID                       = 127\n\tSYS_RENAME                         = 128\n\tSYS_FLOCK                          = 131\n\tSYS_MKFIFO                         = 132\n\tSYS_SENDTO                         = 133\n\tSYS_SHUTDOWN                       = 134\n\tSYS_SOCKETPAIR                     = 135\n\tSYS_MKDIR                          = 136\n\tSYS_RMDIR                          = 137\n\tSYS_UTIMES                         = 138\n\tSYS_FUTIMES                        = 139\n\tSYS_ADJTIME                        = 140\n\tSYS_GETHOSTUUID                    = 142\n\tSYS_SETSID                         = 147\n\tSYS_GETPGID                        = 151\n\tSYS_SETPRIVEXEC                    = 152\n\tSYS_PREAD                          = 153\n\tSYS_PWRITE                         = 154\n\tSYS_NFSSVC                         = 155\n\tSYS_STATFS                         = 157\n\tSYS_FSTATFS                        = 158\n\tSYS_UNMOUNT                        = 159\n\tSYS_GETFH                          = 161\n\tSYS_QUOTACTL                       = 165\n\tSYS_MOUNT                          = 167\n\tSYS_CSOPS                          = 169\n\tSYS_CSOPS_AUDITTOKEN               = 170\n\tSYS_WAITID                         = 173\n\tSYS_KDEBUG_TRACE                   = 180\n\tSYS_SETGID                         = 181\n\tSYS_SETEGID                        = 182\n\tSYS_SETEUID                        = 183\n\tSYS_SIGRETURN                      = 184\n\tSYS_CHUD                           = 185\n\tSYS_FDATASYNC                      = 187\n\tSYS_STAT                           = 188\n\tSYS_FSTAT                          = 189\n\tSYS_LSTAT                          = 190\n\tSYS_PATHCONF                       = 191\n\tSYS_FPATHCONF                      = 192\n\tSYS_GETRLIMIT                      = 194\n\tSYS_SETRLIMIT                      = 195\n\tSYS_GETDIRENTRIES                  = 196\n\tSYS_MMAP                           = 197\n\tSYS_LSEEK                          = 199\n\tSYS_TRUNCATE                       = 200\n\tSYS_FTRUNCATE                      = 201\n\tSYS___SYSCTL                       = 202\n\tSYS_MLOCK                          = 203\n\tSYS_MUNLOCK                        = 204\n\tSYS_UNDELETE                       = 205\n\tSYS_ATSOCKET                       = 206\n\tSYS_ATGETMSG                       = 207\n\tSYS_ATPUTMSG                       = 208\n\tSYS_ATPSNDREQ                      = 209\n\tSYS_ATPSNDRSP                      = 210\n\tSYS_ATPGETREQ                      = 211\n\tSYS_ATPGETRSP                      = 212\n\tSYS_OPEN_DPROTECTED_NP             = 216\n\tSYS_GETATTRLIST                    = 220\n\tSYS_SETATTRLIST                    = 221\n\tSYS_GETDIRENTRIESATTR              = 222\n\tSYS_EXCHANGEDATA                   = 223\n\tSYS_SEARCHFS                       = 225\n\tSYS_DELETE                         = 226\n\tSYS_COPYFILE                       = 227\n\tSYS_FGETATTRLIST                   = 228\n\tSYS_FSETATTRLIST                   = 229\n\tSYS_POLL                           = 230\n\tSYS_WATCHEVENT                     = 231\n\tSYS_WAITEVENT                      = 232\n\tSYS_MODWATCH                       = 233\n\tSYS_GETXATTR                       = 234\n\tSYS_FGETXATTR                      = 235\n\tSYS_SETXATTR                       = 236\n\tSYS_FSETXATTR                      = 237\n\tSYS_REMOVEXATTR                    = 238\n\tSYS_FREMOVEXATTR                   = 239\n\tSYS_LISTXATTR                      = 240\n\tSYS_FLISTXATTR                     = 241\n\tSYS_FSCTL                          = 242\n\tSYS_INITGROUPS                     = 243\n\tSYS_POSIX_SPAWN                    = 244\n\tSYS_FFSCTL                         = 245\n\tSYS_NFSCLNT                        = 247\n\tSYS_FHOPEN                         = 248\n\tSYS_MINHERIT                       = 250\n\tSYS_SEMSYS                         = 251\n\tSYS_MSGSYS                         = 252\n\tSYS_SHMSYS                         = 253\n\tSYS_SEMCTL                         = 254\n\tSYS_SEMGET                         = 255\n\tSYS_SEMOP                          = 256\n\tSYS_MSGCTL                         = 258\n\tSYS_MSGGET                         = 259\n\tSYS_MSGSND                         = 260\n\tSYS_MSGRCV                         = 261\n\tSYS_SHMAT                          = 262\n\tSYS_SHMCTL                         = 263\n\tSYS_SHMDT                          = 264\n\tSYS_SHMGET                         = 265\n\tSYS_SHM_OPEN                       = 266\n\tSYS_SHM_UNLINK                     = 267\n\tSYS_SEM_OPEN                       = 268\n\tSYS_SEM_CLOSE                      = 269\n\tSYS_SEM_UNLINK                     = 270\n\tSYS_SEM_WAIT                       = 271\n\tSYS_SEM_TRYWAIT                    = 272\n\tSYS_SEM_POST                       = 273\n\tSYS_SEM_GETVALUE                   = 274\n\tSYS_SEM_INIT                       = 275\n\tSYS_SEM_DESTROY                    = 276\n\tSYS_OPEN_EXTENDED                  = 277\n\tSYS_UMASK_EXTENDED                 = 278\n\tSYS_STAT_EXTENDED                  = 279\n\tSYS_LSTAT_EXTENDED                 = 280\n\tSYS_FSTAT_EXTENDED                 = 281\n\tSYS_CHMOD_EXTENDED                 = 282\n\tSYS_FCHMOD_EXTENDED                = 283\n\tSYS_ACCESS_EXTENDED                = 284\n\tSYS_SETTID                         = 285\n\tSYS_GETTID                         = 286\n\tSYS_SETSGROUPS                     = 287\n\tSYS_GETSGROUPS                     = 288\n\tSYS_SETWGROUPS                     = 289\n\tSYS_GETWGROUPS                     = 290\n\tSYS_MKFIFO_EXTENDED                = 291\n\tSYS_MKDIR_EXTENDED                 = 292\n\tSYS_IDENTITYSVC                    = 293\n\tSYS_SHARED_REGION_CHECK_NP         = 294\n\tSYS_VM_PRESSURE_MONITOR            = 296\n\tSYS_PSYNCH_RW_LONGRDLOCK           = 297\n\tSYS_PSYNCH_RW_YIELDWRLOCK          = 298\n\tSYS_PSYNCH_RW_DOWNGRADE            = 299\n\tSYS_PSYNCH_RW_UPGRADE              = 300\n\tSYS_PSYNCH_MUTEXWAIT               = 301\n\tSYS_PSYNCH_MUTEXDROP               = 302\n\tSYS_PSYNCH_CVBROAD                 = 303\n\tSYS_PSYNCH_CVSIGNAL                = 304\n\tSYS_PSYNCH_CVWAIT                  = 305\n\tSYS_PSYNCH_RW_RDLOCK               = 306\n\tSYS_PSYNCH_RW_WRLOCK               = 307\n\tSYS_PSYNCH_RW_UNLOCK               = 308\n\tSYS_PSYNCH_RW_UNLOCK2              = 309\n\tSYS_GETSID                         = 310\n\tSYS_SETTID_WITH_PID                = 311\n\tSYS_PSYNCH_CVCLRPREPOST            = 312\n\tSYS_AIO_FSYNC                      = 313\n\tSYS_AIO_RETURN                     = 314\n\tSYS_AIO_SUSPEND                    = 315\n\tSYS_AIO_CANCEL                     = 316\n\tSYS_AIO_ERROR                      = 317\n\tSYS_AIO_READ                       = 318\n\tSYS_AIO_WRITE                      = 319\n\tSYS_LIO_LISTIO                     = 320\n\tSYS_IOPOLICYSYS                    = 322\n\tSYS_PROCESS_POLICY                 = 323\n\tSYS_MLOCKALL                       = 324\n\tSYS_MUNLOCKALL                     = 325\n\tSYS_ISSETUGID                      = 327\n\tSYS___PTHREAD_KILL                 = 328\n\tSYS___PTHREAD_SIGMASK              = 329\n\tSYS___SIGWAIT                      = 330\n\tSYS___DISABLE_THREADSIGNAL         = 331\n\tSYS___PTHREAD_MARKCANCEL           = 332\n\tSYS___PTHREAD_CANCELED             = 333\n\tSYS___SEMWAIT_SIGNAL               = 334\n\tSYS_PROC_INFO                      = 336\n\tSYS_SENDFILE                       = 337\n\tSYS_STAT64                         = 338\n\tSYS_FSTAT64                        = 339\n\tSYS_LSTAT64                        = 340\n\tSYS_STAT64_EXTENDED                = 341\n\tSYS_LSTAT64_EXTENDED               = 342\n\tSYS_FSTAT64_EXTENDED               = 343\n\tSYS_GETDIRENTRIES64                = 344\n\tSYS_STATFS64                       = 345\n\tSYS_FSTATFS64                      = 346\n\tSYS_GETFSSTAT64                    = 347\n\tSYS___PTHREAD_CHDIR                = 348\n\tSYS___PTHREAD_FCHDIR               = 349\n\tSYS_AUDIT                          = 350\n\tSYS_AUDITON                        = 351\n\tSYS_GETAUID                        = 353\n\tSYS_SETAUID                        = 354\n\tSYS_GETAUDIT_ADDR                  = 357\n\tSYS_SETAUDIT_ADDR                  = 358\n\tSYS_AUDITCTL                       = 359\n\tSYS_BSDTHREAD_CREATE               = 360\n\tSYS_BSDTHREAD_TERMINATE            = 361\n\tSYS_KQUEUE                         = 362\n\tSYS_KEVENT                         = 363\n\tSYS_LCHOWN                         = 364\n\tSYS_STACK_SNAPSHOT                 = 365\n\tSYS_BSDTHREAD_REGISTER             = 366\n\tSYS_WORKQ_OPEN                     = 367\n\tSYS_WORKQ_KERNRETURN               = 368\n\tSYS_KEVENT64                       = 369\n\tSYS___OLD_SEMWAIT_SIGNAL           = 370\n\tSYS___OLD_SEMWAIT_SIGNAL_NOCANCEL  = 371\n\tSYS_THREAD_SELFID                  = 372\n\tSYS_LEDGER                         = 373\n\tSYS___MAC_EXECVE                   = 380\n\tSYS___MAC_SYSCALL                  = 381\n\tSYS___MAC_GET_FILE                 = 382\n\tSYS___MAC_SET_FILE                 = 383\n\tSYS___MAC_GET_LINK                 = 384\n\tSYS___MAC_SET_LINK                 = 385\n\tSYS___MAC_GET_PROC                 = 386\n\tSYS___MAC_SET_PROC                 = 387\n\tSYS___MAC_GET_FD                   = 388\n\tSYS___MAC_SET_FD                   = 389\n\tSYS___MAC_GET_PID                  = 390\n\tSYS___MAC_GET_LCID                 = 391\n\tSYS___MAC_GET_LCTX                 = 392\n\tSYS___MAC_SET_LCTX                 = 393\n\tSYS_SETLCID                        = 394\n\tSYS_GETLCID                        = 395\n\tSYS_READ_NOCANCEL                  = 396\n\tSYS_WRITE_NOCANCEL                 = 397\n\tSYS_OPEN_NOCANCEL                  = 398\n\tSYS_CLOSE_NOCANCEL                 = 399\n\tSYS_WAIT4_NOCANCEL                 = 400\n\tSYS_RECVMSG_NOCANCEL               = 401\n\tSYS_SENDMSG_NOCANCEL               = 402\n\tSYS_RECVFROM_NOCANCEL              = 403\n\tSYS_ACCEPT_NOCANCEL                = 404\n\tSYS_MSYNC_NOCANCEL                 = 405\n\tSYS_FCNTL_NOCANCEL                 = 406\n\tSYS_SELECT_NOCANCEL                = 407\n\tSYS_FSYNC_NOCANCEL                 = 408\n\tSYS_CONNECT_NOCANCEL               = 409\n\tSYS_SIGSUSPEND_NOCANCEL            = 410\n\tSYS_READV_NOCANCEL                 = 411\n\tSYS_WRITEV_NOCANCEL                = 412\n\tSYS_SENDTO_NOCANCEL                = 413\n\tSYS_PREAD_NOCANCEL                 = 414\n\tSYS_PWRITE_NOCANCEL                = 415\n\tSYS_WAITID_NOCANCEL                = 416\n\tSYS_POLL_NOCANCEL                  = 417\n\tSYS_MSGSND_NOCANCEL                = 418\n\tSYS_MSGRCV_NOCANCEL                = 419\n\tSYS_SEM_WAIT_NOCANCEL              = 420\n\tSYS_AIO_SUSPEND_NOCANCEL           = 421\n\tSYS___SIGWAIT_NOCANCEL             = 422\n\tSYS___SEMWAIT_SIGNAL_NOCANCEL      = 423\n\tSYS___MAC_MOUNT                    = 424\n\tSYS___MAC_GET_MOUNT                = 425\n\tSYS___MAC_GETFSSTAT                = 426\n\tSYS_FSGETPATH                      = 427\n\tSYS_AUDIT_SESSION_SELF             = 428\n\tSYS_AUDIT_SESSION_JOIN             = 429\n\tSYS_FILEPORT_MAKEPORT              = 430\n\tSYS_FILEPORT_MAKEFD                = 431\n\tSYS_AUDIT_SESSION_PORT             = 432\n\tSYS_PID_SUSPEND                    = 433\n\tSYS_PID_RESUME                     = 434\n\tSYS_PID_HIBERNATE                  = 435\n\tSYS_PID_SHUTDOWN_SOCKETS           = 436\n\tSYS_SHARED_REGION_MAP_AND_SLIDE_NP = 438\n\tSYS_KAS_INFO                       = 439\n\tSYS_MAXSYSCALL                     = 440\n)\nconst (\n\tSizeofSockaddrInet4    = 0x10\n\tSizeofSockaddrInet6    = 0x1c\n\tSizeofSockaddrAny      = 0x6c\n\tSizeofSockaddrUnix     = 0x6a\n\tSizeofSockaddrDatalink = 0x14\n\tSizeofLinger           = 0x8\n\tSizeofIPMreq           = 0x8\n\tSizeofIPv6Mreq         = 0x14\n\tSizeofMsghdr           = 0x30\n\tSizeofCmsghdr          = 0xc\n\tSizeofInet4Pktinfo     = 0xc\n\tSizeofInet6Pktinfo     = 0x14\n\tSizeofIPv6MTUInfo      = 0x20\n\tSizeofICMPv6Filter     = 0x20\n)\nconst (\n\tPTRACE_TRACEME = 0x0\n\tPTRACE_CONT    = 0x7\n\tPTRACE_KILL    = 0x8\n)\nconst (\n\tSizeofIfMsghdr    = 0x70\n\tSizeofIfData      = 0x60\n\tSizeofIfaMsghdr   = 0x14\n\tSizeofIfmaMsghdr  = 0x10\n\tSizeofIfmaMsghdr2 = 0x14\n\tSizeofRtMsghdr    = 0x5c\n\tSizeofRtMetrics   = 0x38\n)\nconst (\n\tSizeofBpfVersion = 0x4\n\tSizeofBpfStat    = 0x8\n\tSizeofBpfProgram = 0x10\n\tSizeofBpfInsn    = 0x8\n\tSizeofBpfHdr     = 0x14\n)\nconst ImplementsGetwd = true\n\nVARIABLES\n\nvar (\n\tStdin  = 0\n\tStdout = 1\n\tStderr = 2\n)\nvar ForkLock sync.RWMutex\n    ForkLock is used to synchronize creation of new file descriptors with fork.\n\n    We want the child in a fork/exec sequence to inherit only the file\n    descriptors we intend. To do that, we mark all file descriptors\n    close-on-exec and then, in the child, explicitly unmark the ones we want the\n    exec'ed program to keep. Unix doesn't make this easy: there is, in general,\n    no way to allocate a new file descriptor close-on-exec. Instead you have to\n    allocate the descriptor and then mark it close-on-exec. If a fork happens\n    between those two events, the child's exec will inherit an unwanted file\n    descriptor.\n\n    This lock solves that race: the create new fd/mark close-on-exec operation\n    is done holding ForkLock for reading, and the fork itself is done\n    holding ForkLock for writing. At least, that's the idea. There are some\n    complications.\n\n    Some system calls that create new file descriptors can block for arbitrarily\n    long times: open on a hung NFS server or named pipe, accept on a socket,\n    and so on. We can't reasonably grab the lock across those operations.\n\n    It is worse to inherit some file descriptors than others. If a non-malicious\n    child accidentally inherits an open ordinary file, that's not a big deal.\n    On the other hand, if a long-lived child accidentally inherits the write end\n    of a pipe, then the reader of that pipe will not see EOF until that child\n    exits, potentially causing the parent program to hang. This is a common\n    problem in threaded C programs that use popen.\n\n    Luckily, the file descriptors that are most important not to inherit\n    are not the ones that can take an arbitrarily long time to create: pipe\n    returns instantly, and the net package uses non-blocking I/O to accept on a\n    listening socket. The rules for which file descriptor-creating operations\n    use the ForkLock are as follows:\n\n      - Pipe. Use pipe2 if available. Otherwise, does not block, so use\n        ForkLock.\n      - Socket. Use SOCK_CLOEXEC if available. Otherwise, does not block,\n        so use ForkLock.\n      - Open. Use O_CLOEXEC if available. Otherwise, may block, so live with the\n        race.\n      - Dup. Use F_DUPFD_CLOEXEC or dup3 if available. Otherwise, does not\n        block, so use ForkLock.\n\nvar SocketDisableIPv6 bool\n    For testing: clients can set this flag to force creation of IPv6 sockets to\n    return EAFNOSUPPORT.\n\n\nFUNCTIONS\n\nfunc Accept(fd int) (nfd int, sa Sockaddr, err error)\nfunc Access(path string, mode uint32) (err error)\nfunc Adjtime(delta *Timeval, olddelta *Timeval) (err error)\nfunc Bind(fd int, sa Sockaddr) (err error)\nfunc BpfBuflen(fd int) (int, error)\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc BpfDatalink(fd int) (int, error)\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc BpfHeadercmpl(fd int) (int, error)\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc BpfInterface(fd int, name string) (string, error)\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc BpfStats(fd int) (*BpfStat, error)\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc BpfTimeout(fd int) (*Timeval, error)\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc BytePtrFromString(s string) (*byte, error)\n    BytePtrFromString returns a pointer to a NUL-terminated array of bytes\n    containing the text of s. If s contains a NUL byte at any location,\n    it returns (nil, EINVAL).\n\nfunc ByteSliceFromString(s string) ([]byte, error)\n    ByteSliceFromString returns a NUL-terminated slice of bytes containing\n    the text of s. If s contains a NUL byte at any location, it returns (nil,\n    EINVAL).\n\nfunc Chdir(path string) (err error)\nfunc CheckBpfVersion(fd int) error\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc Chflags(path string, flags int) (err error)\nfunc Chmod(path string, mode uint32) (err error)\nfunc Chown(path string, uid int, gid int) (err error)\nfunc Chroot(path string) (err error)\nfunc Clearenv()\nfunc Close(fd int) (err error)\nfunc CloseOnExec(fd int)\nfunc CmsgLen(datalen int) int\n    CmsgLen returns the value to store in the Len field of the Cmsghdr\n    structure, taking into account any necessary alignment.\n\nfunc CmsgSpace(datalen int) int\n    CmsgSpace returns the number of bytes an ancillary element with payload of\n    the passed data length occupies.\n\nfunc Connect(fd int, sa Sockaddr) (err error)\nfunc Dup(fd int) (nfd int, err error)\nfunc Dup2(from int, to int) (err error)\nfunc Environ() []string\nfunc Exchangedata(path1 string, path2 string, options int) (err error)\nfunc Exec(argv0 string, argv []string, envv []string) (err error)\n    Exec invokes the execve(2) system call.\n\nfunc Exit(code int)\nfunc Fchdir(fd int) (err error)\nfunc Fchflags(fd int, flags int) (err error)\nfunc Fchmod(fd int, mode uint32) (err error)\nfunc Fchown(fd int, uid int, gid int) (err error)\nfunc FcntlFlock(fd uintptr, cmd int, lk *Flock_t) error\n    FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW\n    command.\n\nfunc Flock(fd int, how int) (err error)\nfunc FlushBpf(fd int) error\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc ForkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)\n    Combination of fork and exec, careful to be thread safe.\n\nfunc Fpathconf(fd int, name int) (val int, err error)\nfunc Fstat(fd int, stat *Stat_t) (err error)\nfunc Fstatfs(fd int, stat *Statfs_t) (err error)\nfunc Fsync(fd int) (err error)\nfunc Ftruncate(fd int, length int64) (err error)\nfunc Futimes(fd int, tv []Timeval) (err error)\nfunc Getdirentries(fd int, buf []byte, basep *uintptr) (n int, err error)\nfunc Getdtablesize() (size int)\nfunc Getegid() (egid int)\nfunc Getenv(key string) (value string, found bool)\nfunc Geteuid() (uid int)\nfunc Getfsstat(buf []Statfs_t, flags int) (n int, err error)\nfunc Getgid() (gid int)\nfunc Getgroups() (gids []int, err error)\nfunc Getpagesize() int\nfunc Getpeername(fd int) (sa Sockaddr, err error)\nfunc Getpgid(pid int) (pgid int, err error)\nfunc Getpgrp() (pgrp int)\nfunc Getpid() (pid int)\nfunc Getppid() (ppid int)\nfunc Getpriority(which int, who int) (prio int, err error)\nfunc Getrlimit(which int, lim *Rlimit) (err error)\nfunc Getrusage(who int, rusage *Rusage) (err error)\nfunc Getsid(pid int) (sid int, err error)\nfunc Getsockname(fd int) (sa Sockaddr, err error)\nfunc GetsockoptByte(fd, level, opt int) (value byte, err error)\nfunc GetsockoptICMPv6Filter(fd, level, opt int) (*ICMPv6Filter, error)\nfunc GetsockoptIPMreq(fd, level, opt int) (*IPMreq, error)\nfunc GetsockoptIPv6MTUInfo(fd, level, opt int) (*IPv6MTUInfo, error)\nfunc GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error)\nfunc GetsockoptInet4Addr(fd, level, opt int) (value [4]byte, err error)\nfunc GetsockoptInt(fd, level, opt int) (value int, err error)\nfunc Gettimeofday(tp *Timeval) (err error)\nfunc Getuid() (uid int)\nfunc Getwd() (string, error)\nfunc Issetugid() (tainted bool)\nfunc Kevent(kq int, changes, events []Kevent_t, timeout *Timespec) (n int, err error)\nfunc Kill(pid int, signum Signal) (err error)\nfunc Kqueue() (fd int, err error)\nfunc Lchown(path string, uid int, gid int) (err error)\nfunc Link(path string, link string) (err error)\nfunc Listen(s int, backlog int) (err error)\nfunc Lstat(path string, stat *Stat_t) (err error)\nfunc Mkdir(path string, mode uint32) (err error)\nfunc Mkfifo(path string, mode uint32) (err error)\nfunc Mknod(path string, mode uint32, dev int) (err error)\nfunc Mlock(b []byte) (err error)\nfunc Mlockall(flags int) (err error)\nfunc Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error)\nfunc Mprotect(b []byte, prot int) (err error)\nfunc Munlock(b []byte) (err error)\nfunc Munlockall() (err error)\nfunc Munmap(b []byte) (err error)\nfunc Open(path string, mode int, perm uint32) (fd int, err error)\nfunc ParseDirent(buf []byte, max int, names []string) (consumed int, count int, newnames []string)\n    ParseDirent parses up to max directory entries in buf, appending the names\n    to names. It returns the number of bytes consumed from buf, the number of\n    entries added to names, and the new names slice.\n\nfunc ParseRoutingMessage(b []byte) (msgs []RoutingMessage, err error)\n    ParseRoutingMessage parses b as routing messages and returns the slice\n    containing the RoutingMessage interfaces.\n\n    Deprecated: Use golang.org/x/net/route instead.\n\nfunc ParseRoutingSockaddr(msg RoutingMessage) ([]Sockaddr, error)\n    ParseRoutingSockaddr parses msg's payload as raw sockaddrs and returns the\n    slice containing the Sockaddr interfaces.\n\n    Deprecated: Use golang.org/x/net/route instead.\n\nfunc ParseSocketControlMessage(b []byte) ([]SocketControlMessage, error)\n    ParseSocketControlMessage parses b as an array of socket control messages.\n\nfunc ParseUnixRights(m *SocketControlMessage) ([]int, error)\n    ParseUnixRights decodes a socket control message that contains an integer\n    array of open file descriptors from another process.\n\nfunc Pathconf(path string, name int) (val int, err error)\nfunc Pipe(p []int) (err error)\nfunc Pread(fd int, p []byte, offset int64) (n int, err error)\nfunc PtraceAttach(pid int) (err error)\nfunc PtraceDetach(pid int) (err error)\nfunc Pwrite(fd int, p []byte, offset int64) (n int, err error)\nfunc RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\nfunc RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\nfunc Read(fd int, p []byte) (n int, err error)\nfunc ReadDirent(fd int, buf []byte) (n int, err error)\nfunc Readlink(path string, buf []byte) (n int, err error)\nfunc Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, err error)\nfunc Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error)\nfunc Rename(from string, to string) (err error)\nfunc Revoke(path string) (err error)\nfunc Rmdir(path string) (err error)\nfunc RouteRIB(facility, param int) ([]byte, error)\n    RouteRIB returns routing information base, as known as RIB, which consists\n    of network facility information, states and parameters.\n\n    Deprecated: Use golang.org/x/net/route instead.\n\nfunc Seek(fd int, offset int64, whence int) (newoffset int64, err error)\nfunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)\nfunc Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)\nfunc Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (err error)\nfunc SendmsgN(fd int, p, oob []byte, to Sockaddr, flags int) (n int, err error)\nfunc Sendto(fd int, p []byte, flags int, to Sockaddr) (err error)\nfunc SetBpf(fd int, i []BpfInsn) error\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc SetBpfBuflen(fd, l int) (int, error)\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc SetBpfDatalink(fd, t int) (int, error)\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc SetBpfHeadercmpl(fd, f int) error\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc SetBpfImmediate(fd, m int) error\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc SetBpfInterface(fd int, name string) error\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc SetBpfPromisc(fd, m int) error\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc SetBpfTimeout(fd int, tv *Timeval) error\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc SetKevent(k *Kevent_t, fd, mode, flags int)\nfunc SetNonblock(fd int, nonblocking bool) (err error)\nfunc Setegid(egid int) (err error)\nfunc Setenv(key, value string) error\nfunc Seteuid(euid int) (err error)\nfunc Setgid(gid int) (err error)\nfunc Setgroups(gids []int) (err error)\nfunc Setlogin(name string) (err error)\nfunc Setpgid(pid int, pgid int) (err error)\nfunc Setpriority(which int, who int, prio int) (err error)\nfunc Setprivexec(flag int) (err error)\nfunc Setregid(rgid int, egid int) (err error)\nfunc Setreuid(ruid int, euid int) (err error)\nfunc Setrlimit(resource int, rlim *Rlimit) error\nfunc Setsid() (pid int, err error)\nfunc SetsockoptByte(fd, level, opt int, value byte) (err error)\nfunc SetsockoptICMPv6Filter(fd, level, opt int, filter *ICMPv6Filter) error\nfunc SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (err error)\nfunc SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (err error)\nfunc SetsockoptInet4Addr(fd, level, opt int, value [4]byte) (err error)\nfunc SetsockoptInt(fd, level, opt int, value int) (err error)\nfunc SetsockoptLinger(fd, level, opt int, l *Linger) (err error)\nfunc SetsockoptString(fd, level, opt int, s string) (err error)\nfunc SetsockoptTimeval(fd, level, opt int, tv *Timeval) (err error)\nfunc Settimeofday(tp *Timeval) (err error)\nfunc Setuid(uid int) (err error)\nfunc Shutdown(s int, how int) (err error)\nfunc SlicePtrFromStrings(ss []string) ([]*byte, error)\n    SlicePtrFromStrings converts a slice of strings to a slice of pointers to\n    NUL-terminated byte arrays. If any string contains a NUL byte, it returns\n    (nil, EINVAL).\n\nfunc Socket(domain, typ, proto int) (fd int, err error)\nfunc Socketpair(domain, typ, proto int) (fd [2]int, err error)\nfunc StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error)\n    StartProcess wraps ForkExec for package os.\n\nfunc Stat(path string, stat *Stat_t) (err error)\nfunc Statfs(path string, stat *Statfs_t) (err error)\nfunc StringBytePtr(s string) *byte\n    StringBytePtr returns a pointer to a NUL-terminated array of bytes. If s\n    contains a NUL byte this function panics instead of returning an error.\n\n    Deprecated: Use BytePtrFromString instead.\n\nfunc StringByteSlice(s string) []byte\n    StringByteSlice converts a string to a NUL-terminated []byte, If s contains\n    a NUL byte this function panics instead of returning an error.\n\n    Deprecated: Use ByteSliceFromString instead.\n\nfunc StringSlicePtr(ss []string) []*byte\n    StringSlicePtr converts a slice of strings to a slice of pointers to\n    NUL-terminated byte arrays. If any string contains a NUL byte this function\n    panics instead of returning an error.\n\n    Deprecated: Use SlicePtrFromStrings instead.\n\nfunc Symlink(path string, link string) (err error)\nfunc Sync() (err error)\nfunc Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)\nfunc Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)\nfunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err Errno)\nfunc Sysctl(name string) (value string, err error)\nfunc SysctlUint32(name string) (value uint32, err error)\nfunc TimespecToNsec(ts Timespec) int64\n    TimespecToNsec returns the time stored in ts as nanoseconds.\n\nfunc TimevalToNsec(tv Timeval) int64\n    TimevalToNsec returns the time stored in tv as nanoseconds.\n\nfunc Truncate(path string, length int64) (err error)\nfunc Umask(newmask int) (oldmask int)\nfunc Undelete(path string) (err error)\nfunc UnixRights(fds ...int) []byte\n    UnixRights encodes a set of open file descriptors into a socket control\n    message for sending to another process.\n\nfunc Unlink(path string) (err error)\nfunc Unmount(path string, flags int) (err error)\nfunc Unsetenv(key string) error\nfunc Utimes(path string, tv []Timeval) (err error)\nfunc UtimesNano(path string, ts []Timespec) error\nfunc Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error)\nfunc Write(fd int, p []byte) (n int, err error)\n\nTYPES\n\ntype BpfHdr struct {\n\tTstamp    Timeval32\n\tCaplen    uint32\n\tDatalen   uint32\n\tHdrlen    uint16\n\tPad_cgo_0 [2]byte\n}\n\ntype BpfInsn struct {\n\tCode uint16\n\tJt   uint8\n\tJf   uint8\n\tK    uint32\n}\n\nfunc BpfJump(code, k, jt, jf int) *BpfInsn\n    Deprecated: Use golang.org/x/net/bpf instead.\n\nfunc BpfStmt(code, k int) *BpfInsn\n    Deprecated: Use golang.org/x/net/bpf instead.\n\ntype BpfProgram struct {\n\tLen       uint32\n\tPad_cgo_0 [4]byte\n\tInsns     *BpfInsn\n}\n\ntype BpfStat struct {\n\tRecv uint32\n\tDrop uint32\n}\n\ntype BpfVersion struct {\n\tMajor uint16\n\tMinor uint16\n}\n\ntype Cmsghdr struct {\n\tLen   uint32\n\tLevel int32\n\tType  int32\n}\n\nfunc (cmsg *Cmsghdr) SetLen(length int)\n\ntype Conn interface {\n\t// SyscallConn returns a raw network connection.\n\tSyscallConn() (RawConn, error)\n}\n    Conn is implemented by some types in the net and os packages to provide\n    access to the underlying file descriptor or handle.\n\ntype Credential struct {\n\tUid         uint32   // User ID.\n\tGid         uint32   // Group ID.\n\tGroups      []uint32 // Supplementary group IDs.\n\tNoSetGroups bool     // If true, don't set supplementary groups\n}\n    Credential holds user and group identities to be assumed by a child process\n    started by StartProcess.\n\ntype Dirent struct {\n\tIno       uint64\n\tSeekoff   uint64\n\tReclen    uint16\n\tNamlen    uint16\n\tType      uint8\n\tName      [1024]int8\n\tPad_cgo_0 [3]byte\n}\n\ntype Errno uintptr\n    An Errno is an unsigned number describing an error condition. It implements\n    the error interface. The zero Errno is by convention a non-error, so code to\n    convert from Errno to error should use:\n\n        err = nil\n        if errno != 0 {\n        \terr = errno\n        }\n\n    Errno values can be tested against error values using errors.Is. For\n    example:\n\n        _, _, err := syscall.Syscall(...)\n        if errors.Is(err, fs.ErrNotExist) ...\n\nfunc (e Errno) Error() string\n\nfunc (e Errno) Is(target error) bool\n\nfunc (e Errno) Temporary() bool\n\nfunc (e Errno) Timeout() bool\n\ntype Fbootstraptransfer_t struct {\n\tOffset int64\n\tLength uint64\n\tBuffer *byte\n}\n\ntype FdSet struct {\n\tBits [32]int32\n}\n\ntype Flock_t struct {\n\tStart  int64\n\tLen    int64\n\tPid    int32\n\tType   int16\n\tWhence int16\n}\n\ntype Fsid struct {\n\tVal [2]int32\n}\n\ntype Fstore_t struct {\n\tFlags      uint32\n\tPosmode    int32\n\tOffset     int64\n\tLength     int64\n\tBytesalloc int64\n}\n\ntype ICMPv6Filter struct {\n\tFilt [8]uint32\n}\n\ntype IPMreq struct {\n\tMultiaddr [4]byte /* in_addr */\n\tInterface [4]byte /* in_addr */\n}\n\ntype IPv6MTUInfo struct {\n\tAddr RawSockaddrInet6\n\tMtu  uint32\n}\n\ntype IPv6Mreq struct {\n\tMultiaddr [16]byte /* in6_addr */\n\tInterface uint32\n}\n\ntype IfData struct {\n\tType       uint8\n\tTypelen    uint8\n\tPhysical   uint8\n\tAddrlen    uint8\n\tHdrlen     uint8\n\tRecvquota  uint8\n\tXmitquota  uint8\n\tUnused1    uint8\n\tMtu        uint32\n\tMetric     uint32\n\tBaudrate   uint32\n\tIpackets   uint32\n\tIerrors    uint32\n\tOpackets   uint32\n\tOerrors    uint32\n\tCollisions uint32\n\tIbytes     uint32\n\tObytes     uint32\n\tImcasts    uint32\n\tOmcasts    uint32\n\tIqdrops    uint32\n\tNoproto    uint32\n\tRecvtiming uint32\n\tXmittiming uint32\n\tLastchange Timeval32\n\tUnused2    uint32\n\tHwassist   uint32\n\tReserved1  uint32\n\tReserved2  uint32\n}\n\ntype IfMsghdr struct {\n\tMsglen    uint16\n\tVersion   uint8\n\tType      uint8\n\tAddrs     int32\n\tFlags     int32\n\tIndex     uint16\n\tPad_cgo_0 [2]byte\n\tData      IfData\n}\n\ntype IfaMsghdr struct {\n\tMsglen    uint16\n\tVersion   uint8\n\tType      uint8\n\tAddrs     int32\n\tFlags     int32\n\tIndex     uint16\n\tPad_cgo_0 [2]byte\n\tMetric    int32\n}\n\ntype IfmaMsghdr struct {\n\tMsglen    uint16\n\tVersion   uint8\n\tType      uint8\n\tAddrs     int32\n\tFlags     int32\n\tIndex     uint16\n\tPad_cgo_0 [2]byte\n}\n\ntype IfmaMsghdr2 struct {\n\tMsglen    uint16\n\tVersion   uint8\n\tType      uint8\n\tAddrs     int32\n\tFlags     int32\n\tIndex     uint16\n\tPad_cgo_0 [2]byte\n\tRefcount  int32\n}\n\ntype Inet4Pktinfo struct {\n\tIfindex  uint32\n\tSpec_dst [4]byte /* in_addr */\n\tAddr     [4]byte /* in_addr */\n}\n\ntype Inet6Pktinfo struct {\n\tAddr    [16]byte /* in6_addr */\n\tIfindex uint32\n}\n\ntype InterfaceAddrMessage struct {\n\tHeader IfaMsghdr\n\tData   []byte\n}\n    InterfaceAddrMessage represents a routing message containing network\n    interface address entries.\n\n    Deprecated: Use golang.org/x/net/route instead.\n\ntype InterfaceMessage struct {\n\tHeader IfMsghdr\n\tData   []byte\n}\n    InterfaceMessage represents a routing message containing network interface\n    entries.\n\n    Deprecated: Use golang.org/x/net/route instead.\n\ntype InterfaceMulticastAddrMessage struct {\n\tHeader IfmaMsghdr2\n\tData   []byte\n}\n    InterfaceMulticastAddrMessage represents a routing message containing\n    network interface address entries.\n\n    Deprecated: Use golang.org/x/net/route instead.\n\ntype Iovec struct {\n\tBase *byte\n\tLen  uint64\n}\n\nfunc (iov *Iovec) SetLen(length int)\n\ntype Kevent_t struct {\n\tIdent  uint64\n\tFilter int16\n\tFlags  uint16\n\tFflags uint32\n\tData   int64\n\tUdata  *byte\n}\n\ntype Linger struct {\n\tOnoff  int32\n\tLinger int32\n}\n\ntype Log2phys_t struct {\n\tFlags       uint32\n\tContigbytes int64\n\tDevoffset   int64\n}\n\ntype Msghdr struct {\n\tName       *byte\n\tNamelen    uint32\n\tPad_cgo_0  [4]byte\n\tIov        *Iovec\n\tIovlen     int32\n\tPad_cgo_1  [4]byte\n\tControl    *byte\n\tControllen uint32\n\tFlags      int32\n}\n\nfunc (msghdr *Msghdr) SetControllen(length int)\n\ntype ProcAttr struct {\n\tDir   string    // Current working directory.\n\tEnv   []string  // Environment.\n\tFiles []uintptr // File descriptors.\n\tSys   *SysProcAttr\n}\n    ProcAttr holds attributes that will be applied to a new process started by\n    StartProcess.\n\ntype Radvisory_t struct {\n\tOffset    int64\n\tCount     int32\n\tPad_cgo_0 [4]byte\n}\n\ntype RawConn interface {\n\t// Control invokes f on the underlying connection's file\n\t// descriptor or handle.\n\t// The file descriptor fd is guaranteed to remain valid while\n\t// f executes but not after f returns.\n\tControl(f func(fd uintptr)) error\n\n\t// Read invokes f on the underlying connection's file\n\t// descriptor or handle; f is expected to try to read from the\n\t// file descriptor.\n\t// If f returns true, Read returns. Otherwise Read blocks\n\t// waiting for the connection to be ready for reading and\n\t// tries again repeatedly.\n\t// The file descriptor is guaranteed to remain valid while f\n\t// executes but not after f returns.\n\tRead(f func(fd uintptr) (done bool)) error\n\n\t// Write is like Read but for writing.\n\tWrite(f func(fd uintptr) (done bool)) error\n}\n    A RawConn is a raw network connection.\n\ntype RawSockaddr struct {\n\tLen    uint8\n\tFamily uint8\n\tData   [14]int8\n}\n\ntype RawSockaddrAny struct {\n\tAddr RawSockaddr\n\tPad  [92]int8\n}\n\ntype RawSockaddrDatalink struct {\n\tLen    uint8\n\tFamily uint8\n\tIndex  uint16\n\tType   uint8\n\tNlen   uint8\n\tAlen   uint8\n\tSlen   uint8\n\tData   [12]int8\n}\n\ntype RawSockaddrInet4 struct {\n\tLen    uint8\n\tFamily uint8\n\tPort   uint16\n\tAddr   [4]byte /* in_addr */\n\tZero   [8]int8\n}\n\ntype RawSockaddrInet6 struct {\n\tLen      uint8\n\tFamily   uint8\n\tPort     uint16\n\tFlowinfo uint32\n\tAddr     [16]byte /* in6_addr */\n\tScope_id uint32\n}\n\ntype RawSockaddrUnix struct {\n\tLen    uint8\n\tFamily uint8\n\tPath   [104]int8\n}\n\ntype Rlimit struct {\n\tCur uint64\n\tMax uint64\n}\n\ntype RouteMessage struct {\n\tHeader RtMsghdr\n\tData   []byte\n}\n    RouteMessage represents a routing message containing routing entries.\n\n    Deprecated: Use golang.org/x/net/route instead.\n\ntype RoutingMessage interface {\n\t// Has unexported methods.\n}\n    RoutingMessage represents a routing message.\n\n    Deprecated: Use golang.org/x/net/route instead.\n\ntype RtMetrics struct {\n\tLocks    uint32\n\tMtu      uint32\n\tHopcount uint32\n\tExpire   int32\n\tRecvpipe uint32\n\tSendpipe uint32\n\tSsthresh uint32\n\tRtt      uint32\n\tRttvar   uint32\n\tPksent   uint32\n\tFiller   [4]uint32\n}\n\ntype RtMsghdr struct {\n\tMsglen    uint16\n\tVersion   uint8\n\tType      uint8\n\tIndex     uint16\n\tPad_cgo_0 [2]byte\n\tFlags     int32\n\tAddrs     int32\n\tPid       int32\n\tSeq       int32\n\tErrno     int32\n\tUse       int32\n\tInits     uint32\n\tRmx       RtMetrics\n}\n\ntype Rusage struct {\n\tUtime    Timeval\n\tStime    Timeval\n\tMaxrss   int64\n\tIxrss    int64\n\tIdrss    int64\n\tIsrss    int64\n\tMinflt   int64\n\tMajflt   int64\n\tNswap    int64\n\tInblock  int64\n\tOublock  int64\n\tMsgsnd   int64\n\tMsgrcv   int64\n\tNsignals int64\n\tNvcsw    int64\n\tNivcsw   int64\n}\n\ntype Signal int\n    A Signal is a number describing a process signal. It implements the\n    os.Signal interface.\n\nfunc (s Signal) Signal()\n\nfunc (s Signal) String() string\n\ntype Sockaddr interface {\n\t// Has unexported methods.\n}\n\ntype SockaddrDatalink struct {\n\tLen    uint8\n\tFamily uint8\n\tIndex  uint16\n\tType   uint8\n\tNlen   uint8\n\tAlen   uint8\n\tSlen   uint8\n\tData   [12]int8\n\t// Has unexported fields.\n}\n\ntype SockaddrInet4 struct {\n\tPort int\n\tAddr [4]byte\n\t// Has unexported fields.\n}\n\ntype SockaddrInet6 struct {\n\tPort   int\n\tZoneId uint32\n\tAddr   [16]byte\n\t// Has unexported fields.\n}\n\ntype SockaddrUnix struct {\n\tName string\n\t// Has unexported fields.\n}\n\ntype SocketControlMessage struct {\n\tHeader Cmsghdr\n\tData   []byte\n}\n    SocketControlMessage represents a socket control message.\n\ntype Stat_t struct {\n\tDev           int32\n\tMode          uint16\n\tNlink         uint16\n\tIno           uint64\n\tUid           uint32\n\tGid           uint32\n\tRdev          int32\n\tPad_cgo_0     [4]byte\n\tAtimespec     Timespec\n\tMtimespec     Timespec\n\tCtimespec     Timespec\n\tBirthtimespec Timespec\n\tSize          int64\n\tBlocks        int64\n\tBlksize       int32\n\tFlags         uint32\n\tGen           uint32\n\tLspare        int32\n\tQspare        [2]int64\n}\n\ntype Statfs_t struct {\n\tBsize       uint32\n\tIosize      int32\n\tBlocks      uint64\n\tBfree       uint64\n\tBavail      uint64\n\tFiles       uint64\n\tFfree       uint64\n\tFsid        Fsid\n\tOwner       uint32\n\tType        uint32\n\tFlags       uint32\n\tFssubtype   uint32\n\tFstypename  [16]int8\n\tMntonname   [1024]int8\n\tMntfromname [1024]int8\n\tReserved    [8]uint32\n}\n\ntype SysProcAttr struct {\n\tChroot     string      // Chroot.\n\tCredential *Credential // Credential.\n\tPtrace     bool        // Enable tracing.\n\tSetsid     bool        // Create session.\n\t// Setpgid sets the process group ID of the child to Pgid,\n\t// or, if Pgid == 0, to the new child's process ID.\n\tSetpgid bool\n\t// Setctty sets the controlling terminal of the child to\n\t// file descriptor Ctty. Ctty must be a descriptor number\n\t// in the child process: an index into ProcAttr.Files.\n\t// This is only meaningful if Setsid is true.\n\tSetctty bool\n\tNoctty  bool // Detach fd 0 from controlling terminal\n\tCtty    int  // Controlling TTY fd\n\t// Foreground places the child process group in the foreground.\n\t// This implies Setpgid. The Ctty field must be set to\n\t// the descriptor of the controlling TTY.\n\t// Unlike Setctty, in this case Ctty must be a descriptor\n\t// number in the parent process.\n\tForeground bool\n\tPgid       int // Child's process group ID if Setpgid.\n}\n\ntype Termios struct {\n\tIflag     uint64\n\tOflag     uint64\n\tCflag     uint64\n\tLflag     uint64\n\tCc        [20]uint8\n\tPad_cgo_0 [4]byte\n\tIspeed    uint64\n\tOspeed    uint64\n}\n\ntype Timespec struct {\n\tSec  int64\n\tNsec int64\n}\n\nfunc NsecToTimespec(nsec int64) Timespec\n    NsecToTimespec converts a number of nanoseconds into a Timespec.\n\nfunc (ts *Timespec) Nano() int64\n    Nano returns the time stored in ts as nanoseconds.\n\nfunc (ts *Timespec) Unix() (sec int64, nsec int64)\n    Unix returns the time stored in ts as seconds plus nanoseconds.\n\ntype Timeval struct {\n\tSec       int64\n\tUsec      int32\n\tPad_cgo_0 [4]byte\n}\n\nfunc NsecToTimeval(nsec int64) Timeval\n    NsecToTimeval converts a number of nanoseconds into a Timeval.\n\nfunc (tv *Timeval) Nano() int64\n    Nano returns the time stored in tv as nanoseconds.\n\nfunc (tv *Timeval) Unix() (sec int64, nsec int64)\n    Unix returns the time stored in tv as seconds plus nanoseconds.\n\ntype Timeval32 struct {\n\tSec  int32\n\tUsec int32\n}\n\ntype WaitStatus uint32\n\nfunc (w WaitStatus) Continued() bool\n\nfunc (w WaitStatus) CoreDump() bool\n\nfunc (w WaitStatus) ExitStatus() int\n\nfunc (w WaitStatus) Exited() bool\n\nfunc (w WaitStatus) Signal() Signal\n\nfunc (w WaitStatus) Signaled() bool\n\nfunc (w WaitStatus) StopSignal() Signal\n\nfunc (w WaitStatus) Stopped() bool\n\nfunc (w WaitStatus) TrapCause() int\n\n"}, {"path": "stdlib/internal-testhash.md", "category": "stdlib", "name": "stdlib/internal-testhash", "content": "package testhash // import \"internal/testhash\"\n\n\nFUNCTIONS\n\nfunc TestHash(t *testing.T, mh MakeHash)\n    TestHash performs a set of tests on hash.Hash implementations, checking the\n    documented requirements of Write, Sum, Reset, Size, and BlockSize.\n\nfunc TestHashWithoutClone(t *testing.T, mh MakeHash)\n\nTYPES\n\ntype MakeHash func() hash.Hash\n\n"}, {"path": "stdlib/log-slog-internal-benchmarks.md", "category": "stdlib", "name": "stdlib/log-slog-internal-benchmarks", "content": "package benchmarks // import \"log/slog/internal/benchmarks\"\n\nPackage benchmarks contains benchmarks for slog.\n\nThese benchmarks are loosely based on github.com/uber-go/zap/benchmarks.\nThey have the following desirable properties:\n\n  - They test a complete log event, from the user's call to its return.\n\n  - The benchmarked code is run concurrently in multiple goroutines, to better\n    simulate a real server (the most common environment for structured logs).\n\n  - Some handlers are optimistic versions of real handlers, doing real-world\n    tasks as fast as possible (and sometimes faster, in that an implementation\n    may not be concurrency-safe). This gives us an upper bound on handler\n    performance, so we can evaluate the (handler-independent) core activity of\n    the package in an end-to-end context without concern that a slow handler\n    implementation is skewing the results.\n\n  - We also test the built-in handlers, for comparison.\n"}, {"path": "stdlib/internal-coverage-slicewriter.md", "category": "stdlib", "name": "stdlib/internal-coverage-slicewriter", "content": "package slicewriter // import \"internal/coverage/slicewriter\"\n\n\nTYPES\n\ntype WriteSeeker struct {\n\t// Has unexported fields.\n}\n    WriteSeeker is a helper object that implements the io.WriteSeeker interface.\n    Clients can create a WriteSeeker, make a series of Write calls to add data\n    to it (and possibly Seek calls to update previously written portions),\n    then finally invoke BytesWritten() to get a pointer to the constructed byte\n    slice.\n\nfunc (sws *WriteSeeker) BytesWritten() []byte\n    BytesWritten returns the underlying byte slice for the WriteSeeker,\n    containing the data written to it via Write/Seek calls.\n\nfunc (sws *WriteSeeker) Read(p []byte) (n int, err error)\n\nfunc (sws *WriteSeeker) Seek(offset int64, whence int) (int64, error)\n    Seek repositions the read/write position of the WriteSeeker within its\n    internally maintained slice. Note that it is not possible to expand the size\n    of the slice using SEEK_SET; trying to seek outside the slice will result in\n    an error.\n\nfunc (sws *WriteSeeker) Write(p []byte) (n int, err error)\n\n"}, {"path": "stdlib/encoding-pem.md", "category": "stdlib", "name": "stdlib/encoding-pem", "content": "package pem // import \"encoding/pem\"\n\nPackage pem implements the PEM data encoding, which originated in Privacy\nEnhanced Mail. The most common use of PEM encoding today is in TLS keys and\ncertificates. See RFC 1421.\n\nFUNCTIONS\n\nfunc Encode(out io.Writer, b *Block) error\n    Encode writes the PEM encoding of b to out.\n\nfunc EncodeToMemory(b *Block) []byte\n    EncodeToMemory returns the PEM encoding of b.\n\n    If b has invalid headers and cannot be encoded, EncodeToMemory returns nil.\n    If it is important to report details about this error case, use Encode\n    instead.\n\n\nTYPES\n\ntype Block struct {\n\tType    string            // The type, taken from the preamble (i.e. \"RSA PRIVATE KEY\").\n\tHeaders map[string]string // Optional headers.\n\tBytes   []byte            // The decoded bytes of the contents. Typically a DER encoded ASN.1 structure.\n}\n    A Block represents a PEM encoded structure.\n\n    The encoded form is:\n\n        -----BEGIN Type-----\n        Headers\n        base64-encoded Bytes\n        -----END Type-----\n\n    where [Block.Headers] is a possibly empty sequence of Key: Value lines.\n\nfunc Decode(data []byte) (p *Block, rest []byte)\n    Decode will find the next PEM formatted block (certificate, private key etc)\n    in the input. It returns that block and the remainder of the input. If no\n    PEM data is found, p is nil and the whole of the input is returned in rest.\n    Blocks must start at the beginning of a line and end at the end of a line.\n\n"}, {"path": "stdlib/structs.md", "category": "stdlib", "name": "stdlib/structs", "content": "package structs // import \"structs\"\n\nPackage structs defines marker types that can be used as struct fields to modify\nthe properties of a struct.\n\nBy convention, a marker type should be used as the type of a field named \"_\",\nplaced at the beginning of a struct type definition.\n\nTYPES\n\ntype HostLayout struct {\n\t// Has unexported fields.\n}\n    HostLayout marks a struct as using host memory layout. A struct with a\n    field of type HostLayout will be laid out in memory according to host\n    expectations, generally following the host's C ABI.\n\n    HostLayout does not affect layout within any other struct-typed fields of\n    the containing struct, nor does it affect layout of structs containing the\n    struct marked as host layout.\n\n    By convention, HostLayout should be used as the type of a field named \"_\",\n    placed at the beginning of the struct type definition.\n\n"}, {"path": "stdlib/crypto-sha1.md", "category": "stdlib", "name": "stdlib/crypto-sha1", "content": "package sha1 // import \"crypto/sha1\"\n\nPackage sha1 implements the SHA-1 hash algorithm as defined in RFC 3174.\n\nSHA-1 is cryptographically broken and should not be used for secure\napplications.\n\nCONSTANTS\n\nconst BlockSize = 64\n    The blocksize of SHA-1 in bytes.\n\nconst Size = 20\n    The size of a SHA-1 checksum in bytes.\n\n\nFUNCTIONS\n\nfunc New() hash.Hash\n    New returns a new hash.Hash computing the SHA1 checksum. The Hash\n    also implements encoding.BinaryMarshaler, encoding.BinaryAppender and\n    encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of\n    the hash.\n\nfunc Sum(data []byte) [Size]byte\n    Sum returns the SHA-1 checksum of the data.\n\n"}, {"path": "stdlib/crypto-internal-fips140-bigmod.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-bigmod", "content": "package bigmod // import \"crypto/internal/fips140/bigmod\"\n\n\nTYPES\n\ntype Modulus struct {\n\t// Has unexported fields.\n}\n    Modulus is used for modular arithmetic, precomputing relevant constants.\n\n    A Modulus can leak the exact number of bits needed to store its value and is\n    stored without padding. Its actual value is still kept secret.\n\nfunc NewModulus(b []byte) (*Modulus, error)\n    NewModulus creates a new Modulus from a slice of big-endian bytes. The\n    modulus must be greater than one.\n\n    The number of significant bits and whether the modulus is even is leaked\n    through timing side-channels.\n\nfunc NewModulusProduct(a, b []byte) (*Modulus, error)\n    NewModulusProduct creates a new Modulus from the product of two numbers\n    represented as big-endian byte slices. The result must be greater than one.\n\nfunc (m *Modulus) BitLen() int\n    BitLen returns the size of m in bits.\n\nfunc (m *Modulus) Nat() *Nat\n    Nat returns m as a Nat.\n\nfunc (m *Modulus) Size() int\n    Size returns the size of m in bytes.\n\ntype Nat struct {\n\t// Has unexported fields.\n}\n    Nat represents an arbitrary natural number\n\n    Each Nat has an announced length, which is the number of limbs it has\n    stored. Operations on this number are allowed to leak this length, but will\n    not leak any information about the values contained in those limbs.\n\nfunc NewNat() *Nat\n    NewNat returns a new nat with a size of zero, just like new(Nat), but with\n    the preallocated capacity to hold a number of up to preallocTarget bits.\n    NewNat inlines, so the allocation can live on the stack.\n\nfunc (x *Nat) Add(y *Nat, m *Modulus) *Nat\n    Add computes x = x + y mod m.\n\n    The length of both operands must be the same as the modulus. Both operands\n    must already be reduced modulo m.\n\nfunc (x *Nat) BitLenVarTime() int\n    BitLenVarTime returns the actual size of x in bits.\n\n    The actual size of x (but nothing more) leaks through timing side-channels.\n    Note that this is ordinarily secret, as opposed to the announced size of x.\n\nfunc (x *Nat) Bits() []uint\n    Bits returns x as a little-endian slice of uint. The length of the\n    slice matches the announced length of x. The result and x share the same\n    underlying array.\n\nfunc (x *Nat) Bytes(m *Modulus) []byte\n    Bytes returns x as a zero-extended big-endian byte slice. The size of the\n    slice will match the size of m.\n\n    x must have the same size as m and it must be less than or equal to m.\n\nfunc (x *Nat) DivShortVarTime(y uint) uint\n    DivShortVarTime calculates x = x / y and returns the remainder.\n\n    It panics if y is zero.\n\nfunc (x *Nat) Equal(y *Nat) choice\n    Equal returns 1 if x == y, and 0 otherwise.\n\n    Both operands must have the same announced length.\n\nfunc (out *Nat) Exp(x *Nat, e []byte, m *Modulus) *Nat\n    Exp calculates out = x^e mod m.\n\n    The exponent e is represented in big-endian order. The output will be\n    resized to the size of m and overwritten. x must already be reduced modulo\n    m.\n\n    m must be odd, or Exp will panic.\n\nfunc (out *Nat) ExpShortVarTime(x *Nat, e uint, m *Modulus) *Nat\n    ExpShortVarTime calculates out = x^e mod m.\n\n    The output will be resized to the size of m and overwritten. x must already\n    be reduced modulo m. This leaks the exponent through timing side-channels.\n\n    m must be odd, or ExpShortVarTime will panic.\n\nfunc (x *Nat) ExpandFor(m *Modulus) *Nat\n    ExpandFor ensures x has the right size to work with operations modulo m.\n\n    The announced size of x must be smaller than or equal to that of m.\n\nfunc (x *Nat) GCDVarTime(a, b *Nat) (*Nat, error)\n    GCDVarTime calculates x = GCD(a, b) where at least one of a or b is odd,\n    and both are non-zero. If GCDVarTime returns an error, x is not modified.\n\n    The output will be resized to the size of the larger of a and b.\n\nfunc (x *Nat) InverseVarTime(a *Nat, m *Modulus) (*Nat, bool)\n    InverseVarTime calculates x = a\u207b\u00b9 mod m and returns (x, true) if a is\n    invertible. Otherwise, InverseVarTime returns (x, false) and x is not\n    modified.\n\n    a must be reduced modulo m, but doesn't need to have the same size.\n    The output will be resized to the size of m and overwritten.\n\nfunc (x *Nat) IsMinusOne(m *Modulus) choice\n    IsMinusOne returns 1 if x == -1 mod m, and 0 otherwise.\n\n    The length of x must be the same as the modulus. x must already be reduced\n    modulo m.\n\nfunc (x *Nat) IsOdd() choice\n    IsOdd returns 1 if x is odd, and 0 otherwise.\n\nfunc (x *Nat) IsOne() choice\n    IsOne returns 1 if x == 1, and 0 otherwise.\n\nfunc (x *Nat) IsZero() choice\n    IsZero returns 1 if x == 0, and 0 otherwise.\n\nfunc (out *Nat) Mod(x *Nat, m *Modulus) *Nat\n    Mod calculates out = x mod m.\n\n    This works regardless how large the value of x is.\n\n    The output will be resized to the size of m and overwritten.\n\nfunc (x *Nat) Mul(y *Nat, m *Modulus) *Nat\n    Mul calculates x = x * y mod m.\n\n    The length of both operands must be the same as the modulus. Both operands\n    must already be reduced modulo m.\n\nfunc (x *Nat) SetBytes(b []byte, m *Modulus) (*Nat, error)\n    SetBytes assigns x = b, where b is a slice of big-endian bytes. SetBytes\n    returns an error if b >= m.\n\n    The output will be resized to the size of m and overwritten.\n\nfunc (x *Nat) SetOverflowingBytes(b []byte, m *Modulus) (*Nat, error)\n    SetOverflowingBytes assigns x = b, where b is a slice of big-endian bytes.\n    SetOverflowingBytes returns an error if b has a longer bit length than m,\n    but reduces overflowing values up to 2^\u2308log2(m)\u2309 - 1.\n\n    The output will be resized to the size of m and overwritten.\n\nfunc (x *Nat) SetUint(y uint) *Nat\n    SetUint assigns x = y.\n\n    The output will be resized to a single limb and overwritten.\n\nfunc (x *Nat) ShiftRightVarTime(n uint) *Nat\n    ShiftRightVarTime sets x = x >> n.\n\n    The announced length of x is unchanged.\n\nfunc (x *Nat) Sub(y *Nat, m *Modulus) *Nat\n    Sub computes x = x - y mod m.\n\n    The length of both operands must be the same as the modulus. Both operands\n    must already be reduced modulo m.\n\nfunc (x *Nat) SubOne(m *Modulus) *Nat\n    SubOne computes x = x - 1 mod m.\n\n    The length of x must be the same as the modulus.\n\nfunc (x *Nat) TrailingZeroBitsVarTime() uint\n    TrailingZeroBitsVarTime returns the number of trailing zero bits in x.\n\n"}, {"path": "stdlib/crypto-internal-randutil.md", "category": "stdlib", "name": "stdlib/crypto-internal-randutil", "content": "package randutil // import \"crypto/internal/randutil\"\n\nPackage randutil contains internal randomness utilities for various crypto\npackages.\n\nFUNCTIONS\n\nfunc MaybeReadByte(r io.Reader)\n    MaybeReadByte reads a single byte from r with 50% probability. This is\n    used to ensure that callers do not depend on non-guaranteed behaviour, e.g.\n    assuming that rsa.GenerateKey is deterministic w.r.t. a given random stream.\n\n    This does not affect tests that pass a stream of fixed bytes as the random\n    source (e.g. a zeroReader).\n\n"}, {"path": "stdlib/net-http-fcgi.md", "category": "stdlib", "name": "stdlib/net-http-fcgi", "content": "package fcgi // import \"net/http/fcgi\"\n\nPackage fcgi implements the FastCGI protocol.\n\nSee https://fast-cgi.github.io/ for an unofficial mirror of the original\ndocumentation.\n\nCurrently only the responder role is supported.\n\nVARIABLES\n\nvar ErrConnClosed = errors.New(\"fcgi: connection to web server closed\")\n    ErrConnClosed is returned by Read when a handler attempts to read the body\n    of a request after the connection to the web server has been closed.\n\nvar ErrRequestAborted = errors.New(\"fcgi: request aborted by web server\")\n    ErrRequestAborted is returned by Read when a handler attempts to read the\n    body of a request that has been aborted by the web server.\n\n\nFUNCTIONS\n\nfunc ProcessEnv(r *http.Request) map[string]string\n    ProcessEnv returns FastCGI environment variables associated with the request\n    r for which no effort was made to be included in the request itself - the\n    data is hidden in the request's context. As an example, if REMOTE_USER\n    is set for a request, it will not be found anywhere in r, but it will be\n    included in ProcessEnv's response (via r's context).\n\nfunc Serve(l net.Listener, handler http.Handler) error\n    Serve accepts incoming FastCGI connections on the listener l, creating a\n    new goroutine for each. The goroutine reads requests and then calls handler\n    to reply to them. If l is nil, Serve accepts connections from os.Stdin.\n    If handler is nil, http.DefaultServeMux is used.\n\n"}, {"path": "stdlib/go-importer.md", "category": "stdlib", "name": "stdlib/go-importer", "content": "package importer // import \"go/importer\"\n\nPackage importer provides access to export data importers.\n\nThese functions, which are mostly deprecated, date from before the introduction\nof modules in release Go 1.11. They should no longer be relied on except for use\nin test cases using small programs that depend only on the standard library.\nFor reliable module-aware loading of type information, use the packages.Load\nfunction from golang.org/x/tools/go/packages.\n\nFUNCTIONS\n\nfunc Default() types.Importer\n    Default returns an Importer for the compiler that built the running binary.\n    If available, the result implements types.ImporterFrom.\n\n    Default may be convenient for use in the simplest of cases, but most clients\n    should instead use ForCompiler, which accepts a token.FileSet from the\n    caller; without it, all position information derived from the Importer will\n    be incorrect and misleading. See also the package documentation.\n\nfunc For(compiler string, lookup Lookup) types.Importer\n    For calls ForCompiler with a new FileSet.\n\n    Deprecated: Use ForCompiler, which populates a FileSet with the positions of\n    objects created by the importer.\n\nfunc ForCompiler(fset *token.FileSet, compiler string, lookup Lookup) types.Importer\n    ForCompiler returns an Importer for importing from installed packages for\n    the compilers \"gc\" and \"gccgo\", or for importing directly from the source\n    if the compiler argument is \"source\". In this latter case, importing may\n    fail under circumstances where the exported API is not entirely defined in\n    pure Go source code (if the package API depends on cgo-defined entities,\n    the type checker won't have access to those).\n\n    The lookup function is called each time the resulting importer needs to\n    resolve an import path. In this mode the importer can only be invoked with\n    canonical import paths (not relative or absolute ones); it is assumed that\n    the translation to canonical import paths is being done by the client of the\n    importer.\n\n    A lookup function must be provided for correct module-aware operation.\n    Deprecated: If lookup is nil, for backwards-compatibility, the importer will\n    attempt to resolve imports in the $GOPATH workspace.\n\n\nTYPES\n\ntype Lookup func(path string) (io.ReadCloser, error)\n    A Lookup function returns a reader to access package data for a given import\n    path, or an error if no matching package is found.\n\n"}, {"path": "stdlib/vendor-golang.org-x-text-unicode-bidi.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-text-unicode-bidi", "content": ""}, {"path": "stdlib/internal-runtime-wasitest.md", "category": "stdlib", "name": "stdlib/internal-runtime-wasitest", "content": ""}, {"path": "stdlib/go-internal-gcimporter.md", "category": "stdlib", "name": "stdlib/go-internal-gcimporter", "content": "package gcimporter // import \"go/internal/gcimporter\"\n\nPackage gcimporter implements Import for gc-generated object files.\n\nFUNCTIONS\n\nfunc Import(fset *token.FileSet, packages map[string]*types.Package, path, srcDir string, lookup func(path string) (io.ReadCloser, error)) (pkg *types.Package, err error)\n    Import imports a gc-generated package given its import path and srcDir,\n    adds the corresponding package object to the packages map, and returns the\n    object. The packages map must contain all packages already imported.\n\n"}, {"path": "stdlib/hash.md", "category": "stdlib", "name": "stdlib/hash", "content": "package hash // import \"hash\"\n\nPackage hash provides interfaces for hash functions.\n\nTYPES\n\ntype Cloner interface {\n\tHash\n\tClone() (Cloner, error)\n}\n    A Cloner is a hash function whose state can be cloned, returning a value\n    with equivalent and independent state.\n\n    All Hash implementations in the standard library implement this interface,\n    unless GOFIPS140=v1.0.0 is set.\n\n    If a hash can only determine at runtime if it can be cloned (e.g.\n    if it wraps another hash), Clone may return an error wrapping\n    errors.ErrUnsupported. Otherwise, Clone must always return a nil error.\n\ntype Hash interface {\n\t// Write (via the embedded io.Writer interface) adds more data to the running hash.\n\t// It never returns an error.\n\tio.Writer\n\n\t// Sum appends the current hash to b and returns the resulting slice.\n\t// It does not change the underlying hash state.\n\tSum(b []byte) []byte\n\n\t// Reset resets the Hash to its initial state.\n\tReset()\n\n\t// Size returns the number of bytes Sum will return.\n\tSize() int\n\n\t// BlockSize returns the hash's underlying block size.\n\t// The Write method must be able to accept any amount\n\t// of data, but it may operate more efficiently if all writes\n\t// are a multiple of the block size.\n\tBlockSize() int\n}\n    Hash is the common interface implemented by all hash functions.\n\n    Hash implementations in the standard library (e.g. hash/crc32\n    and crypto/sha256) implement the encoding.BinaryMarshaler,\n    encoding.BinaryAppender, encoding.BinaryUnmarshaler and Cloner interfaces.\n    Marshaling a hash implementation allows its internal state to be saved and\n    used for additional processing later, without having to re-write the data\n    previously written to the hash. The hash state may contain portions of the\n    input in its original form, which users are expected to handle for any\n    possible security implications.\n\n    Compatibility: Any future changes to hash or crypto packages will endeavor\n    to maintain compatibility with state encoded using previous versions.\n    That is, any released versions of the packages should be able to decode\n    data written with any previously released version, subject to issues such\n    as security fixes. See the Go compatibility document for background:\n    https://golang.org/doc/go1compat\n\ntype Hash32 interface {\n\tHash\n\tSum32() uint32\n}\n    Hash32 is the common interface implemented by all 32-bit hash functions.\n\ntype Hash64 interface {\n\tHash\n\tSum64() uint64\n}\n    Hash64 is the common interface implemented by all 64-bit hash functions.\n\ntype XOF interface {\n\t// Write absorbs more data into the XOF's state. It panics if called\n\t// after Read.\n\tio.Writer\n\n\t// Read reads more output from the XOF. It may return io.EOF if there\n\t// is a limit to the XOF output length.\n\tio.Reader\n\n\t// Reset resets the XOF to its initial state.\n\tReset()\n\n\t// BlockSize returns the XOF's underlying block size.\n\t// The Write method must be able to accept any amount\n\t// of data, but it may operate more efficiently if all writes\n\t// are a multiple of the block size.\n\tBlockSize() int\n}\n    XOF (extendable output function) is a hash function with arbitrary or\n    unlimited output length.\n\n"}, {"path": "stdlib/crypto-internal-fips140hash.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140hash", "content": "package fips140hash // import \"crypto/internal/fips140hash\"\n\n\nFUNCTIONS\n\nfunc Unwrap(h hash.Hash) hash.Hash\n    Unwrap returns h, or a crypto/internal/fips140 inner implementation of h.\n\n    The return value can be type asserted to one\n    of crypto/internal/fips140/sha256.Digest,\n    crypto/internal/fips140/sha512.Digest, or\n    crypto/internal/fips140/sha3.Digest if it is a FIPS 140-3 approved hash.\n\nfunc UnwrapNew[Hash hash.Hash](newHash func() Hash) func() hash.Hash\n    UnwrapNew returns a function that calls newHash and applies Unwrap to the\n    return value.\n\n"}, {"path": "stdlib/internal-obscuretestdata.md", "category": "stdlib", "name": "stdlib/internal-obscuretestdata", "content": "package obscuretestdata // import \"internal/obscuretestdata\"\n\nPackage obscuretestdata contains functionality used by tests to more easily work\nwith testdata that must be obscured primarily due to golang.org/issue/34986.\n\nFUNCTIONS\n\nfunc DecodeToTempFile(name string) (path string, err error)\n    DecodeToTempFile decodes the named file to a temporary location.\n    If successful, it returns the path of the decoded file. The caller is\n    responsible for ensuring that the temporary file is removed.\n\nfunc ReadFile(name string) ([]byte, error)\n    ReadFile reads the named file and returns its decoded contents.\n\nfunc Rot13(data []byte) []byte\n    Rot13 returns the rot13 encoding or decoding of its input.\n\n"}, {"path": "stdlib/net-http-httptest.md", "category": "stdlib", "name": "stdlib/net-http-httptest", "content": "package httptest // import \"net/http/httptest\"\n\nPackage httptest provides utilities for HTTP testing.\n\nCONSTANTS\n\nconst DefaultRemoteAddr = \"1.2.3.4\"\n    DefaultRemoteAddr is the default remote address to return in RemoteAddr if\n    an explicit DefaultRemoteAddr isn't set on ResponseRecorder.\n\n\nFUNCTIONS\n\nfunc NewRequest(method, target string, body io.Reader) *http.Request\n    NewRequest wraps NewRequestWithContext using context.Background.\n\nfunc NewRequestWithContext(ctx context.Context, method, target string, body io.Reader) *http.Request\n    NewRequestWithContext returns a new incoming server Request, suitable for\n    passing to an http.Handler for testing.\n\n    The target is the RFC 7230 \"request-target\": it may be either a path or an\n    absolute URL. If target is an absolute URL, the host name from the URL is\n    used. Otherwise, \"example.com\" is used.\n\n    The TLS field is set to a non-nil dummy value if target has scheme \"https\".\n\n    The Request.Proto is always HTTP/1.1.\n\n    An empty method means \"GET\".\n\n    The provided body may be nil. If the body is of type bytes.Reader,\n    strings.Reader, bytes.Buffer, or the value http.NoBody, the\n    Request.ContentLength is set.\n\n    NewRequest panics on error for ease of use in testing, where a panic is\n    acceptable.\n\n    To generate a client HTTP request instead of a server request, see the\n    NewRequest function in the net/http package.\n\n\nTYPES\n\ntype ResponseRecorder struct {\n\t// Code is the HTTP response code set by WriteHeader.\n\t//\n\t// Note that if a Handler never calls WriteHeader or Write,\n\t// this might end up being 0, rather than the implicit\n\t// http.StatusOK. To get the implicit value, use the Result\n\t// method.\n\tCode int\n\n\t// HeaderMap contains the headers explicitly set by the Handler.\n\t// It is an internal detail.\n\t//\n\t// Deprecated: HeaderMap exists for historical compatibility\n\t// and should not be used. To access the headers returned by a handler,\n\t// use the Response.Header map as returned by the Result method.\n\tHeaderMap http.Header\n\n\t// Body is the buffer to which the Handler's Write calls are sent.\n\t// If nil, the Writes are silently discarded.\n\tBody *bytes.Buffer\n\n\t// Flushed is whether the Handler called Flush.\n\tFlushed bool\n\n\t// Has unexported fields.\n}\n    ResponseRecorder is an implementation of http.ResponseWriter that records\n    its mutations for later inspection in tests.\n\nfunc NewRecorder() *ResponseRecorder\n    NewRecorder returns an initialized ResponseRecorder.\n\nfunc (rw *ResponseRecorder) Flush()\n    Flush implements http.Flusher. To test whether Flush was called, see\n    rw.Flushed.\n\nfunc (rw *ResponseRecorder) Header() http.Header\n    Header implements http.ResponseWriter. It returns the response headers\n    to mutate within a handler. To test the headers that were written after\n    a handler completes, use the ResponseRecorder.Result method and see the\n    returned Response value's Header.\n\nfunc (rw *ResponseRecorder) Result() *http.Response\n    Result returns the response generated by the handler.\n\n    The returned Response will have at least its StatusCode, Header, Body, and\n    optionally Trailer populated. More fields may be populated in the future,\n    so callers should not DeepEqual the result in tests.\n\n    The Response.Header is a snapshot of the headers at the time of the first\n    write call, or at the time of this call, if the handler never did a write.\n\n    The Response.Body is guaranteed to be non-nil and Body.Read call is\n    guaranteed to not return any error other than io.EOF.\n\n    Result must only be called after the handler has finished running.\n\nfunc (rw *ResponseRecorder) Write(buf []byte) (int, error)\n    Write implements http.ResponseWriter. The data in buf is written to rw.Body,\n    if not nil.\n\nfunc (rw *ResponseRecorder) WriteHeader(code int)\n    WriteHeader implements http.ResponseWriter.\n\nfunc (rw *ResponseRecorder) WriteString(str string) (int, error)\n    WriteString implements io.StringWriter. The data in str is written to\n    rw.Body, if not nil.\n\ntype Server struct {\n\tURL      string // base URL of form http://ipaddr:port with no trailing slash\n\tListener net.Listener\n\n\t// EnableHTTP2 controls whether HTTP/2 is enabled\n\t// on the server. It must be set between calling\n\t// NewUnstartedServer and calling Server.StartTLS.\n\tEnableHTTP2 bool\n\n\t// TLS is the optional TLS configuration, populated with a new config\n\t// after TLS is started. If set on an unstarted server before StartTLS\n\t// is called, existing fields are copied into the new config.\n\tTLS *tls.Config\n\n\t// Config may be changed after calling NewUnstartedServer and\n\t// before Start or StartTLS.\n\tConfig *http.Server\n\n\t// Has unexported fields.\n}\n    A Server is an HTTP server listening on a system-chosen port on the local\n    loopback interface, for use in end-to-end HTTP tests.\n\nfunc NewServer(handler http.Handler) *Server\n    NewServer starts and returns a new Server. The caller should call Close when\n    finished, to shut it down.\n\nfunc NewTLSServer(handler http.Handler) *Server\n    NewTLSServer starts and returns a new Server using TLS. The caller should\n    call Close when finished, to shut it down.\n\nfunc NewUnstartedServer(handler http.Handler) *Server\n    NewUnstartedServer returns a new Server but doesn't start it.\n\n    After changing its configuration, the caller should call Start or StartTLS.\n\n    The caller should call Close when finished, to shut it down.\n\nfunc (s *Server) Certificate() *x509.Certificate\n    Certificate returns the certificate used by the server, or nil if the server\n    doesn't use TLS.\n\nfunc (s *Server) Client() *http.Client\n    Client returns an HTTP client configured for making requests to the server.\n    It is configured to trust the server's TLS test certificate and will close\n    its idle connections on Server.Close. Use Server.URL as the base URL to send\n    requests to the server.\n\nfunc (s *Server) Close()\n    Close shuts down the server and blocks until all outstanding requests on\n    this server have completed.\n\nfunc (s *Server) CloseClientConnections()\n    CloseClientConnections closes any open HTTP connections to the test Server.\n\nfunc (s *Server) Start()\n    Start starts a server from NewUnstartedServer.\n\nfunc (s *Server) StartTLS()\n    StartTLS starts TLS on a server from NewUnstartedServer.\n\n"}, {"path": "stdlib/crypto-tls.md", "category": "stdlib", "name": "stdlib/crypto-tls", "content": "package tls // import \"crypto/tls\"\n\nPackage tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3,\nas specified in RFC 8446.\n\n# FIPS 140-3 mode\n\nWhen the program is in FIPS 140-3 mode, this package behaves as if only\nSP 800-140C and SP 800-140D approved protocol versions, cipher suites,\nsignature algorithms, certificate public key types and sizes, and key exchange\nand derivation algorithms were implemented. Others are silently ignored and not\nnegotiated, or rejected. This set may depend on the algorithms supported by\nthe FIPS 140-3 Go Cryptographic Module selected with GOFIPS140, and may change\nacross Go versions.\n\n[FIPS 140-3 mode]: https://go.dev/doc/security/fips140\n\nCONSTANTS\n\nconst (\n\t// TLS 1.0 - 1.2 cipher suites.\n\tTLS_RSA_WITH_RC4_128_SHA                      uint16 = 0x0005\n\tTLS_RSA_WITH_3DES_EDE_CBC_SHA                 uint16 = 0x000a\n\tTLS_RSA_WITH_AES_128_CBC_SHA                  uint16 = 0x002f\n\tTLS_RSA_WITH_AES_256_CBC_SHA                  uint16 = 0x0035\n\tTLS_RSA_WITH_AES_128_CBC_SHA256               uint16 = 0x003c\n\tTLS_RSA_WITH_AES_128_GCM_SHA256               uint16 = 0x009c\n\tTLS_RSA_WITH_AES_256_GCM_SHA384               uint16 = 0x009d\n\tTLS_ECDHE_ECDSA_WITH_RC4_128_SHA              uint16 = 0xc007\n\tTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA          uint16 = 0xc009\n\tTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA          uint16 = 0xc00a\n\tTLS_ECDHE_RSA_WITH_RC4_128_SHA                uint16 = 0xc011\n\tTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA           uint16 = 0xc012\n\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA            uint16 = 0xc013\n\tTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA            uint16 = 0xc014\n\tTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256       uint16 = 0xc023\n\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256         uint16 = 0xc027\n\tTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256         uint16 = 0xc02f\n\tTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256       uint16 = 0xc02b\n\tTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384         uint16 = 0xc030\n\tTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384       uint16 = 0xc02c\n\tTLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256   uint16 = 0xcca8\n\tTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xcca9\n\n\t// TLS 1.3 cipher suites.\n\tTLS_AES_128_GCM_SHA256       uint16 = 0x1301\n\tTLS_AES_256_GCM_SHA384       uint16 = 0x1302\n\tTLS_CHACHA20_POLY1305_SHA256 uint16 = 0x1303\n\n\t// TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator\n\t// that the client is doing version fallback. See RFC 7507.\n\tTLS_FALLBACK_SCSV uint16 = 0x5600\n\n\t// Legacy names for the corresponding cipher suites with the correct _SHA256\n\t// suffix, retained for backward compatibility.\n\tTLS_ECDHE_RSA_WITH_CHACHA20_POLY1305   = TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n\tTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 = TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n)\n    A list of cipher suite IDs that are, or have been, implemented by this\n    package.\n\n    See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n\nconst (\n\tVersionTLS10 = 0x0301\n\tVersionTLS11 = 0x0302\n\tVersionTLS12 = 0x0303\n\tVersionTLS13 = 0x0304\n\n\t// Deprecated: SSLv3 is cryptographically broken, and is no longer\n\t// supported by this package. See golang.org/issue/32716.\n\tVersionSSL30 = 0x0300\n)\nconst (\n\tQUICEncryptionLevelInitial = QUICEncryptionLevel(iota)\n\tQUICEncryptionLevelEarly\n\tQUICEncryptionLevelHandshake\n\tQUICEncryptionLevelApplication\n)\n\nFUNCTIONS\n\nfunc CipherSuiteName(id uint16) string\n    CipherSuiteName returns the standard name for the passed cipher suite\n    ID (e.g. \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\"), or a fallback\n    representation of the ID value if the cipher suite is not implemented by\n    this package.\n\nfunc Listen(network, laddr string, config *Config) (net.Listener, error)\n    Listen creates a TLS listener accepting connections on the given network\n    address using net.Listen. The configuration config must be non-nil and must\n    include at least one certificate or else set GetCertificate.\n\nfunc NewListener(inner net.Listener, config *Config) net.Listener\n    NewListener creates a Listener which accepts connections from an inner\n    Listener and wraps each connection with Server. The configuration config\n    must be non-nil and must include at least one certificate or else set\n    GetCertificate.\n\nfunc VersionName(version uint16) string\n    VersionName returns the name for the provided TLS version number (e.g.\n    \"TLS 1.3\"), or a fallback representation of the value if the version is not\n    implemented by this package.\n\n\nTYPES\n\ntype AlertError uint8\n    An AlertError is a TLS alert.\n\n    When using a QUIC transport, QUICConn methods will return an error which\n    wraps AlertError rather than sending a TLS alert.\n\nfunc (e AlertError) Error() string\n\ntype Certificate struct {\n\tCertificate [][]byte\n\t// PrivateKey contains the private key corresponding to the public key in\n\t// Leaf. This must implement crypto.Signer with an RSA, ECDSA or Ed25519 PublicKey.\n\t// For a server up to TLS 1.2, it can also implement crypto.Decrypter with\n\t// an RSA PublicKey.\n\tPrivateKey crypto.PrivateKey\n\t// SupportedSignatureAlgorithms is an optional list restricting what\n\t// signature algorithms the PrivateKey can be used for.\n\tSupportedSignatureAlgorithms []SignatureScheme\n\t// OCSPStaple contains an optional OCSP response which will be served\n\t// to clients that request it.\n\tOCSPStaple []byte\n\t// SignedCertificateTimestamps contains an optional list of Signed\n\t// Certificate Timestamps which will be served to clients that request it.\n\tSignedCertificateTimestamps [][]byte\n\t// Leaf is the parsed form of the leaf certificate, which may be initialized\n\t// using x509.ParseCertificate to reduce per-handshake processing. If nil,\n\t// the leaf certificate will be parsed as needed.\n\tLeaf *x509.Certificate\n}\n    A Certificate is a chain of one or more certificates, leaf first.\n\nfunc LoadX509KeyPair(certFile, keyFile string) (Certificate, error)\n    LoadX509KeyPair reads and parses a public/private key pair from a pair of\n    files. The files must contain PEM encoded data. The certificate file may\n    contain intermediate certificates following the leaf certificate to form a\n    certificate chain. On successful return, Certificate.Leaf will be populated.\n\n    Before Go 1.23 Certificate.Leaf was left nil, and the parsed certificate was\n    discarded. This behavior can be re-enabled by setting \"x509keypairleaf=0\" in\n    the GODEBUG environment variable.\n\nfunc X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)\n    X509KeyPair parses a public/private key pair from a pair of PEM encoded\n    data. On successful return, Certificate.Leaf will be populated.\n\n    Before Go 1.23 Certificate.Leaf was left nil, and the parsed certificate was\n    discarded. This behavior can be re-enabled by setting \"x509keypairleaf=0\" in\n    the GODEBUG environment variable.\n\ntype CertificateRequestInfo struct {\n\t// AcceptableCAs contains zero or more, DER-encoded, X.501\n\t// Distinguished Names. These are the names of root or intermediate CAs\n\t// that the server wishes the returned certificate to be signed by. An\n\t// empty slice indicates that the server has no preference.\n\tAcceptableCAs [][]byte\n\n\t// SignatureSchemes lists the signature schemes that the server is\n\t// willing to verify.\n\tSignatureSchemes []SignatureScheme\n\n\t// Version is the TLS version that was negotiated for this connection.\n\tVersion uint16\n\n\t// Has unexported fields.\n}\n    CertificateRequestInfo contains information from a server's\n    CertificateRequest message, which is used to demand a certificate and proof\n    of control from a client.\n\nfunc (c *CertificateRequestInfo) Context() context.Context\n    Context returns the context of the handshake that is in progress.\n    This context is a child of the context passed to HandshakeContext, if any,\n    and is canceled when the handshake concludes.\n\nfunc (cri *CertificateRequestInfo) SupportsCertificate(c *Certificate) error\n    SupportsCertificate returns nil if the provided certificate is supported by\n    the server that sent the CertificateRequest. Otherwise, it returns an error\n    describing the reason for the incompatibility.\n\ntype CertificateVerificationError struct {\n\t// UnverifiedCertificates and its contents should not be modified.\n\tUnverifiedCertificates []*x509.Certificate\n\tErr                    error\n}\n    CertificateVerificationError is returned when certificate verification fails\n    during the handshake.\n\nfunc (e *CertificateVerificationError) Error() string\n\nfunc (e *CertificateVerificationError) Unwrap() error\n\ntype CipherSuite struct {\n\tID   uint16\n\tName string\n\n\t// Supported versions is the list of TLS protocol versions that can\n\t// negotiate this cipher suite.\n\tSupportedVersions []uint16\n\n\t// Insecure is true if the cipher suite has known security issues\n\t// due to its primitives, design, or implementation.\n\tInsecure bool\n}\n    CipherSuite is a TLS cipher suite. Note that most functions in this package\n    accept and expose cipher suite IDs instead of this type.\n\nfunc CipherSuites() []*CipherSuite\n    CipherSuites returns a list of cipher suites currently implemented by\n    this package, excluding those with security issues, which are returned by\n    InsecureCipherSuites.\n\n    The list is sorted by ID. Note that the default cipher suites selected by\n    this package might depend on logic that can't be captured by a static list,\n    and might not match those returned by this function.\n\nfunc InsecureCipherSuites() []*CipherSuite\n    InsecureCipherSuites returns a list of cipher suites currently implemented\n    by this package and which have security issues.\n\n    Most applications should not use the cipher suites in this list, and should\n    only use those returned by CipherSuites.\n\ntype ClientAuthType int\n    ClientAuthType declares the policy the server will follow for TLS Client\n    Authentication.\n\nconst (\n\t// NoClientCert indicates that no client certificate should be requested\n\t// during the handshake, and if any certificates are sent they will not\n\t// be verified.\n\tNoClientCert ClientAuthType = iota\n\t// RequestClientCert indicates that a client certificate should be requested\n\t// during the handshake, but does not require that the client send any\n\t// certificates.\n\tRequestClientCert\n\t// RequireAnyClientCert indicates that a client certificate should be requested\n\t// during the handshake, and that at least one certificate is required to be\n\t// sent by the client, but that certificate is not required to be valid.\n\tRequireAnyClientCert\n\t// VerifyClientCertIfGiven indicates that a client certificate should be requested\n\t// during the handshake, but does not require that the client sends a\n\t// certificate. If the client does send a certificate it is required to be\n\t// valid.\n\tVerifyClientCertIfGiven\n\t// RequireAndVerifyClientCert indicates that a client certificate should be requested\n\t// during the handshake, and that at least one valid certificate is required\n\t// to be sent by the client.\n\tRequireAndVerifyClientCert\n)\nfunc (i ClientAuthType) String() string\n\ntype ClientHelloInfo struct {\n\t// CipherSuites lists the CipherSuites supported by the client (e.g.\n\t// TLS_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256).\n\tCipherSuites []uint16\n\n\t// ServerName indicates the name of the server requested by the client\n\t// in order to support virtual hosting. ServerName is only set if the\n\t// client is using SNI (see RFC 4366, Section 3.1).\n\tServerName string\n\n\t// SupportedCurves lists the key exchange mechanisms supported by the\n\t// client. It was renamed to \"supported groups\" in TLS 1.3, see RFC 8446,\n\t// Section 4.2.7 and [CurveID].\n\t//\n\t// SupportedCurves may be nil in TLS 1.2 and lower if the Supported Elliptic\n\t// Curves Extension is not being used (see RFC 4492, Section 5.1.1).\n\tSupportedCurves []CurveID\n\n\t// SupportedPoints lists the point formats supported by the client.\n\t// SupportedPoints is set only if the Supported Point Formats Extension\n\t// is being used (see RFC 4492, Section 5.1.2).\n\tSupportedPoints []uint8\n\n\t// SignatureSchemes lists the signature and hash schemes that the client\n\t// is willing to verify. SignatureSchemes is set only if the Signature\n\t// Algorithms Extension is being used (see RFC 5246, Section 7.4.1.4.1).\n\tSignatureSchemes []SignatureScheme\n\n\t// SupportedProtos lists the application protocols supported by the client.\n\t// SupportedProtos is set only if the Application-Layer Protocol\n\t// Negotiation Extension is being used (see RFC 7301, Section 3.1).\n\t//\n\t// Servers can select a protocol by setting Config.NextProtos in a\n\t// GetConfigForClient return value.\n\tSupportedProtos []string\n\n\t// SupportedVersions lists the TLS versions supported by the client.\n\t// For TLS versions less than 1.3, this is extrapolated from the max\n\t// version advertised by the client, so values other than the greatest\n\t// might be rejected if used.\n\tSupportedVersions []uint16\n\n\t// Extensions lists the IDs of the extensions presented by the client\n\t// in the ClientHello.\n\tExtensions []uint16\n\n\t// Conn is the underlying net.Conn for the connection. Do not read\n\t// from, or write to, this connection; that will cause the TLS\n\t// connection to fail.\n\tConn net.Conn\n\n\t// Has unexported fields.\n}\n    ClientHelloInfo contains information from a ClientHello message in order\n    to guide application logic in the GetCertificate and GetConfigForClient\n    callbacks.\n\nfunc (c *ClientHelloInfo) Context() context.Context\n    Context returns the context of the handshake that is in progress.\n    This context is a child of the context passed to HandshakeContext, if any,\n    and is canceled when the handshake concludes.\n\nfunc (chi *ClientHelloInfo) SupportsCertificate(c *Certificate) error\n    SupportsCertificate returns nil if the provided certificate is supported\n    by the client that sent the ClientHello. Otherwise, it returns an error\n    describing the reason for the incompatibility.\n\n    If this ClientHelloInfo was passed to a GetConfigForClient or GetCertificate\n    callback, this method will take into account the associated Config.\n    Note that if GetConfigForClient returns a different Config, the change can't\n    be accounted for by this method.\n\n    This function will call x509.ParseCertificate unless c.Leaf is set, which\n    can incur a significant performance cost.\n\ntype ClientSessionCache interface {\n\t// Get searches for a ClientSessionState associated with the given key.\n\t// On return, ok is true if one was found.\n\tGet(sessionKey string) (session *ClientSessionState, ok bool)\n\n\t// Put adds the ClientSessionState to the cache with the given key. It might\n\t// get called multiple times in a connection if a TLS 1.3 server provides\n\t// more than one session ticket. If called with a nil *ClientSessionState,\n\t// it should remove the cache entry.\n\tPut(sessionKey string, cs *ClientSessionState)\n}\n    ClientSessionCache is a cache of ClientSessionState objects that can be used\n    by a client to resume a TLS session with a given server. ClientSessionCache\n    implementations should expect to be called concurrently from different\n    goroutines. Up to TLS 1.2, only ticket-based resumption is supported,\n    not SessionID-based resumption. In TLS 1.3 they were merged into PSK modes,\n    which are supported via this interface.\n\nfunc NewLRUClientSessionCache(capacity int) ClientSessionCache\n    NewLRUClientSessionCache returns a ClientSessionCache with the given\n    capacity that uses an LRU strategy. If capacity is < 1, a default capacity\n    is used instead.\n\ntype ClientSessionState struct {\n\t// Has unexported fields.\n}\n    ClientSessionState contains the state needed by a client to resume a\n    previous TLS session.\n\nfunc NewResumptionState(ticket []byte, state *SessionState) (*ClientSessionState, error)\n    NewResumptionState returns a state value that can be returned by\n    [ClientSessionCache.Get] to resume a previous session.\n\n    state needs to be returned by ParseSessionState, and the ticket and session\n    state must have been returned by ClientSessionState.ResumptionState.\n\nfunc (cs *ClientSessionState) ResumptionState() (ticket []byte, state *SessionState, err error)\n    ResumptionState returns the session ticket sent by the server (also known as\n    the session's identity) and the state necessary to resume this session.\n\n    It can be called by [ClientSessionCache.Put] to serialize (with\n    SessionState.Bytes) and store the session.\n\ntype Config struct {\n\t// Rand provides the source of entropy for nonces and RSA blinding.\n\t// If Rand is nil, TLS uses the cryptographic random reader in package\n\t// crypto/rand.\n\t// The Reader must be safe for use by multiple goroutines.\n\tRand io.Reader\n\n\t// Time returns the current time as the number of seconds since the epoch.\n\t// If Time is nil, TLS uses time.Now.\n\tTime func() time.Time\n\n\t// Certificates contains one or more certificate chains to present to the\n\t// other side of the connection. The first certificate compatible with the\n\t// peer's requirements is selected automatically.\n\t//\n\t// Server configurations must set one of Certificates, GetCertificate or\n\t// GetConfigForClient. Clients doing client-authentication may set either\n\t// Certificates or GetClientCertificate.\n\t//\n\t// Note: if there are multiple Certificates, and they don't have the\n\t// optional field Leaf set, certificate selection will incur a significant\n\t// per-handshake performance cost.\n\tCertificates []Certificate\n\n\t// NameToCertificate maps from a certificate name to an element of\n\t// Certificates. Note that a certificate name can be of the form\n\t// '*.example.com' and so doesn't have to be a domain name as such.\n\t//\n\t// Deprecated: NameToCertificate only allows associating a single\n\t// certificate with a given name. Leave this field nil to let the library\n\t// select the first compatible chain from Certificates.\n\tNameToCertificate map[string]*Certificate\n\n\t// GetCertificate returns a Certificate based on the given\n\t// ClientHelloInfo. It will only be called if the client supplies SNI\n\t// information or if Certificates is empty.\n\t//\n\t// If GetCertificate is nil or returns nil, then the certificate is\n\t// retrieved from NameToCertificate. If NameToCertificate is nil, the\n\t// best element of Certificates will be used.\n\t//\n\t// Once a Certificate is returned it should not be modified.\n\tGetCertificate func(*ClientHelloInfo) (*Certificate, error)\n\n\t// GetClientCertificate, if not nil, is called when a server requests a\n\t// certificate from a client. If set, the contents of Certificates will\n\t// be ignored.\n\t//\n\t// If GetClientCertificate returns an error, the handshake will be\n\t// aborted and that error will be returned. Otherwise\n\t// GetClientCertificate must return a non-nil Certificate. If\n\t// Certificate.Certificate is empty then no certificate will be sent to\n\t// the server. If this is unacceptable to the server then it may abort\n\t// the handshake.\n\t//\n\t// GetClientCertificate may be called multiple times for the same\n\t// connection if renegotiation occurs or if TLS 1.3 is in use.\n\t//\n\t// Once a Certificate is returned it should not be modified.\n\tGetClientCertificate func(*CertificateRequestInfo) (*Certificate, error)\n\n\t// GetConfigForClient, if not nil, is called after a ClientHello is\n\t// received from a client. It may return a non-nil Config in order to\n\t// change the Config that will be used to handle this connection. If\n\t// the returned Config is nil, the original Config will be used. The\n\t// Config returned by this callback may not be subsequently modified.\n\t//\n\t// If GetConfigForClient is nil, the Config passed to Server() will be\n\t// used for all connections.\n\t//\n\t// If SessionTicketKey was explicitly set on the returned Config, or if\n\t// SetSessionTicketKeys was called on the returned Config, those keys will\n\t// be used. Otherwise, the original Config keys will be used (and possibly\n\t// rotated if they are automatically managed).\n\tGetConfigForClient func(*ClientHelloInfo) (*Config, error)\n\n\t// VerifyPeerCertificate, if not nil, is called after normal\n\t// certificate verification by either a TLS client or server. It\n\t// receives the raw ASN.1 certificates provided by the peer and also\n\t// any verified chains that normal processing found. If it returns a\n\t// non-nil error, the handshake is aborted and that error results.\n\t//\n\t// If normal verification fails then the handshake will abort before\n\t// considering this callback. If normal verification is disabled (on the\n\t// client when InsecureSkipVerify is set, or on a server when ClientAuth is\n\t// RequestClientCert or RequireAnyClientCert), then this callback will be\n\t// considered but the verifiedChains argument will always be nil. When\n\t// ClientAuth is NoClientCert, this callback is not called on the server.\n\t// rawCerts may be empty on the server if ClientAuth is RequestClientCert or\n\t// VerifyClientCertIfGiven.\n\t//\n\t// This callback is not invoked on resumed connections, as certificates are\n\t// not re-verified on resumption.\n\t//\n\t// verifiedChains and its contents should not be modified.\n\tVerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error\n\n\t// VerifyConnection, if not nil, is called after normal certificate\n\t// verification and after VerifyPeerCertificate by either a TLS client\n\t// or server. If it returns a non-nil error, the handshake is aborted\n\t// and that error results.\n\t//\n\t// If normal verification fails then the handshake will abort before\n\t// considering this callback. This callback will run for all connections,\n\t// including resumptions, regardless of InsecureSkipVerify or ClientAuth\n\t// settings.\n\tVerifyConnection func(ConnectionState) error\n\n\t// RootCAs defines the set of root certificate authorities\n\t// that clients use when verifying server certificates.\n\t// If RootCAs is nil, TLS uses the host's root CA set.\n\tRootCAs *x509.CertPool\n\n\t// NextProtos is a list of supported application level protocols, in\n\t// order of preference. If both peers support ALPN, the selected\n\t// protocol will be one from this list, and the connection will fail\n\t// if there is no mutually supported protocol. If NextProtos is empty\n\t// or the peer doesn't support ALPN, the connection will succeed and\n\t// ConnectionState.NegotiatedProtocol will be empty.\n\tNextProtos []string\n\n\t// ServerName is used to verify the hostname on the returned\n\t// certificates unless InsecureSkipVerify is given. It is also included\n\t// in the client's handshake to support virtual hosting unless it is\n\t// an IP address.\n\tServerName string\n\n\t// ClientAuth determines the server's policy for\n\t// TLS Client Authentication. The default is NoClientCert.\n\tClientAuth ClientAuthType\n\n\t// ClientCAs defines the set of root certificate authorities\n\t// that servers use if required to verify a client certificate\n\t// by the policy in ClientAuth.\n\tClientCAs *x509.CertPool\n\n\t// InsecureSkipVerify controls whether a client verifies the server's\n\t// certificate chain and host name. If InsecureSkipVerify is true, crypto/tls\n\t// accepts any certificate presented by the server and any host name in that\n\t// certificate. In this mode, TLS is susceptible to machine-in-the-middle\n\t// attacks unless custom verification is used. This should be used only for\n\t// testing or in combination with VerifyConnection or VerifyPeerCertificate.\n\tInsecureSkipVerify bool\n\n\t// CipherSuites is a list of enabled TLS 1.0\u20131.2 cipher suites. The order of\n\t// the list is ignored. Note that TLS 1.3 ciphersuites are not configurable.\n\t//\n\t// If CipherSuites is nil, a safe default list is used. The default cipher\n\t// suites might change over time. In Go 1.22 RSA key exchange based cipher\n\t// suites were removed from the default list, but can be re-added with the\n\t// GODEBUG setting tlsrsakex=1. In Go 1.23 3DES cipher suites were removed\n\t// from the default list, but can be re-added with the GODEBUG setting\n\t// tls3des=1.\n\tCipherSuites []uint16\n\n\t// PreferServerCipherSuites is a legacy field and has no effect.\n\t//\n\t// It used to control whether the server would follow the client's or the\n\t// server's preference. Servers now select the best mutually supported\n\t// cipher suite based on logic that takes into account inferred client\n\t// hardware, server hardware, and security.\n\t//\n\t// Deprecated: PreferServerCipherSuites is ignored.\n\tPreferServerCipherSuites bool\n\n\t// SessionTicketsDisabled may be set to true to disable session ticket and\n\t// PSK (resumption) support. Note that on clients, session ticket support is\n\t// also disabled if ClientSessionCache is nil.\n\tSessionTicketsDisabled bool\n\n\t// SessionTicketKey is used by TLS servers to provide session resumption.\n\t// See RFC 5077 and the PSK mode of RFC 8446. If zero, it will be filled\n\t// with random data before the first server handshake.\n\t//\n\t// Deprecated: if this field is left at zero, session ticket keys will be\n\t// automatically rotated every day and dropped after seven days. For\n\t// customizing the rotation schedule or synchronizing servers that are\n\t// terminating connections for the same host, use SetSessionTicketKeys.\n\tSessionTicketKey [32]byte\n\n\t// ClientSessionCache is a cache of ClientSessionState entries for TLS\n\t// session resumption. It is only used by clients.\n\tClientSessionCache ClientSessionCache\n\n\t// UnwrapSession is called on the server to turn a ticket/identity\n\t// previously produced by [WrapSession] into a usable session.\n\t//\n\t// UnwrapSession will usually either decrypt a session state in the ticket\n\t// (for example with [Config.EncryptTicket]), or use the ticket as a handle\n\t// to recover a previously stored state. It must use [ParseSessionState] to\n\t// deserialize the session state.\n\t//\n\t// If UnwrapSession returns an error, the connection is terminated. If it\n\t// returns (nil, nil), the session is ignored. crypto/tls may still choose\n\t// not to resume the returned session.\n\tUnwrapSession func(identity []byte, cs ConnectionState) (*SessionState, error)\n\n\t// WrapSession is called on the server to produce a session ticket/identity.\n\t//\n\t// WrapSession must serialize the session state with [SessionState.Bytes].\n\t// It may then encrypt the serialized state (for example with\n\t// [Config.DecryptTicket]) and use it as the ticket, or store the state and\n\t// return a handle for it.\n\t//\n\t// If WrapSession returns an error, the connection is terminated.\n\t//\n\t// Warning: the return value will be exposed on the wire and to clients in\n\t// plaintext. The application is in charge of encrypting and authenticating\n\t// it (and rotating keys) or returning high-entropy identifiers. Failing to\n\t// do so correctly can compromise current, previous, and future connections\n\t// depending on the protocol version.\n\tWrapSession func(ConnectionState, *SessionState) ([]byte, error)\n\n\t// MinVersion contains the minimum TLS version that is acceptable.\n\t//\n\t// By default, TLS 1.2 is currently used as the minimum. TLS 1.0 is the\n\t// minimum supported by this package.\n\t//\n\t// The server-side default can be reverted to TLS 1.0 by including the value\n\t// \"tls10server=1\" in the GODEBUG environment variable.\n\tMinVersion uint16\n\n\t// MaxVersion contains the maximum TLS version that is acceptable.\n\t//\n\t// By default, the maximum version supported by this package is used,\n\t// which is currently TLS 1.3.\n\tMaxVersion uint16\n\n\t// CurvePreferences contains a set of supported key exchange mechanisms.\n\t// The name refers to elliptic curves for legacy reasons, see [CurveID].\n\t// The order of the list is ignored, and key exchange mechanisms are chosen\n\t// from this list using an internal preference order. If empty, the default\n\t// will be used.\n\t//\n\t// From Go 1.24, the default includes the [X25519MLKEM768] hybrid\n\t// post-quantum key exchange. To disable it, set CurvePreferences explicitly\n\t// or use the GODEBUG=tlsmlkem=0 environment variable.\n\tCurvePreferences []CurveID\n\n\t// DynamicRecordSizingDisabled disables adaptive sizing of TLS records.\n\t// When true, the largest possible TLS record size is always used. When\n\t// false, the size of TLS records may be adjusted in an attempt to\n\t// improve latency.\n\tDynamicRecordSizingDisabled bool\n\n\t// Renegotiation controls what types of renegotiation are supported.\n\t// The default, none, is correct for the vast majority of applications.\n\tRenegotiation RenegotiationSupport\n\n\t// KeyLogWriter optionally specifies a destination for TLS master secrets\n\t// in NSS key log format that can be used to allow external programs\n\t// such as Wireshark to decrypt TLS connections.\n\t// See https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format.\n\t// Use of KeyLogWriter compromises security and should only be\n\t// used for debugging.\n\tKeyLogWriter io.Writer\n\n\t// EncryptedClientHelloConfigList is a serialized ECHConfigList. If\n\t// provided, clients will attempt to connect to servers using Encrypted\n\t// Client Hello (ECH) using one of the provided ECHConfigs.\n\t//\n\t// Servers do not use this field. In order to configure ECH for servers, see\n\t// the EncryptedClientHelloKeys field.\n\t//\n\t// If the list contains no valid ECH configs, the handshake will fail\n\t// and return an error.\n\t//\n\t// If EncryptedClientHelloConfigList is set, MinVersion, if set, must\n\t// be VersionTLS13.\n\t//\n\t// When EncryptedClientHelloConfigList is set, the handshake will only\n\t// succeed if ECH is successfully negotiated. If the server rejects ECH,\n\t// an ECHRejectionError error will be returned, which may contain a new\n\t// ECHConfigList that the server suggests using.\n\t//\n\t// How this field is parsed may change in future Go versions, if the\n\t// encoding described in the final Encrypted Client Hello RFC changes.\n\tEncryptedClientHelloConfigList []byte\n\n\t// EncryptedClientHelloRejectionVerify, if not nil, is called when ECH is\n\t// rejected by the remote server, in order to verify the ECH provider\n\t// certificate in the outer ClientHello. If it returns a non-nil error, the\n\t// handshake is aborted and that error results.\n\t//\n\t// On the server side this field is not used.\n\t//\n\t// Unlike VerifyPeerCertificate and VerifyConnection, normal certificate\n\t// verification will not be performed before calling\n\t// EncryptedClientHelloRejectionVerify.\n\t//\n\t// If EncryptedClientHelloRejectionVerify is nil and ECH is rejected, the\n\t// roots in RootCAs will be used to verify the ECH providers public\n\t// certificate. VerifyPeerCertificate and VerifyConnection are not called\n\t// when ECH is rejected, even if set, and InsecureSkipVerify is ignored.\n\tEncryptedClientHelloRejectionVerify func(ConnectionState) error\n\n\t// GetEncryptedClientHelloKeys, if not nil, is called when by a server when\n\t// a client attempts ECH.\n\t//\n\t// If GetEncryptedClientHelloKeys is not nil, [EncryptedClientHelloKeys] is\n\t// ignored.\n\t//\n\t// If GetEncryptedClientHelloKeys returns an error, the handshake will be\n\t// aborted and the error will be returned. Otherwise,\n\t// GetEncryptedClientHelloKeys must return a non-nil slice of\n\t// [EncryptedClientHelloKey] that represents the acceptable ECH keys.\n\t//\n\t// For further details, see [EncryptedClientHelloKeys].\n\tGetEncryptedClientHelloKeys func(*ClientHelloInfo) ([]EncryptedClientHelloKey, error)\n\n\t// EncryptedClientHelloKeys are the ECH keys to use when a client\n\t// attempts ECH.\n\t//\n\t// If EncryptedClientHelloKeys is set, MinVersion, if set, must be\n\t// VersionTLS13.\n\t//\n\t// If a client attempts ECH, but it is rejected by the server, the server\n\t// will send a list of configs to retry based on the set of\n\t// EncryptedClientHelloKeys which have the SendAsRetry field set.\n\t//\n\t// If GetEncryptedClientHelloKeys is non-nil, EncryptedClientHelloKeys is\n\t// ignored.\n\t//\n\t// On the client side, this field is ignored. In order to configure ECH for\n\t// clients, see the EncryptedClientHelloConfigList field.\n\tEncryptedClientHelloKeys []EncryptedClientHelloKey\n\n\t// Has unexported fields.\n}\n    A Config structure is used to configure a TLS client or server. After one\n    has been passed to a TLS function it must not be modified. A Config may be\n    reused; the tls package will also not modify it.\n\nfunc (c *Config) BuildNameToCertificate()\n    BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate\n    from the CommonName and SubjectAlternateName fields of each of the leaf\n    certificates.\n\n    Deprecated: NameToCertificate only allows associating a single certificate\n    with a given name. Leave that field nil to let the library select the first\n    compatible chain from Certificates.\n\nfunc (c *Config) Clone() *Config\n    Clone returns a shallow clone of c or nil if c is nil. It is safe to clone a\n    Config that is being used concurrently by a TLS client or server.\n\nfunc (c *Config) DecryptTicket(identity []byte, cs ConnectionState) (*SessionState, error)\n    DecryptTicket decrypts a ticket encrypted by Config.EncryptTicket. It can be\n    used as a [Config.UnwrapSession] implementation.\n\n    If the ticket can't be decrypted or parsed, DecryptTicket returns (nil,\n    nil).\n\nfunc (c *Config) EncryptTicket(cs ConnectionState, ss *SessionState) ([]byte, error)\n    EncryptTicket encrypts a ticket with the Config's configured (or\n    default) session ticket keys. It can be used as a [Config.WrapSession]\n    implementation.\n\nfunc (c *Config) SetSessionTicketKeys(keys [][32]byte)\n    SetSessionTicketKeys updates the session ticket keys for a server.\n\n    The first key will be used when creating new tickets, while all keys can\n    be used for decrypting tickets. It is safe to call this function while the\n    server is running in order to rotate the session ticket keys. The function\n    will panic if keys is empty.\n\n    Calling this function will turn off automatic session ticket key rotation.\n\n    If multiple servers are terminating connections for the same host they\n    should all have the same session ticket keys. If the session ticket keys\n    leaks, previously recorded and future TLS connections using those keys might\n    be compromised.\n\ntype Conn struct {\n\t// Has unexported fields.\n}\n    A Conn represents a secured connection. It implements the net.Conn\n    interface.\n\nfunc Client(conn net.Conn, config *Config) *Conn\n    Client returns a new TLS client side connection using conn as the underlying\n    transport. The config cannot be nil: users must set either ServerName or\n    InsecureSkipVerify in the config.\n\nfunc Dial(network, addr string, config *Config) (*Conn, error)\n    Dial connects to the given network address using net.Dial and then\n    initiates a TLS handshake, returning the resulting TLS connection.\n    Dial interprets a nil configuration as equivalent to the zero configuration;\n    see the documentation of Config for the defaults.\n\nfunc DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)\n    DialWithDialer connects to the given network address using dialer.Dial and\n    then initiates a TLS handshake, returning the resulting TLS connection.\n    Any timeout or deadline given in the dialer apply to connection and TLS\n    handshake as a whole.\n\n    DialWithDialer interprets a nil configuration as equivalent to the zero\n    configuration; see the documentation of Config for the defaults.\n\n    DialWithDialer uses context.Background internally; to specify the context,\n    use Dialer.DialContext with NetDialer set to the desired dialer.\n\nfunc Server(conn net.Conn, config *Config) *Conn\n    Server returns a new TLS server side connection using conn as the underlying\n    transport. The configuration config must be non-nil and must include at\n    least one certificate or else set GetCertificate.\n\nfunc (c *Conn) Close() error\n    Close closes the connection.\n\nfunc (c *Conn) CloseWrite() error\n    CloseWrite shuts down the writing side of the connection. It should only be\n    called once the handshake has completed and does not call CloseWrite on the\n    underlying connection. Most callers should just use Conn.Close.\n\nfunc (c *Conn) ConnectionState() ConnectionState\n    ConnectionState returns basic TLS details about the connection.\n\nfunc (c *Conn) Handshake() error\n    Handshake runs the client or server handshake protocol if it has not yet\n    been run.\n\n    Most uses of this package need not call Handshake explicitly: the first\n    Conn.Read or Conn.Write will call it automatically.\n\n    For control over canceling or setting a timeout on a handshake, use\n    Conn.HandshakeContext or the Dialer's DialContext method instead.\n\n    In order to avoid denial of service attacks, the maximum RSA key size\n    allowed in certificates sent by either the TLS server or client is limited\n    to 8192 bits. This limit can be overridden by setting tlsmaxrsasize in the\n    GODEBUG environment variable (e.g. GODEBUG=tlsmaxrsasize=4096).\n\nfunc (c *Conn) HandshakeContext(ctx context.Context) error\n    HandshakeContext runs the client or server handshake protocol if it has not\n    yet been run.\n\n    The provided Context must be non-nil. If the context is canceled before\n    the handshake is complete, the handshake is interrupted and an error is\n    returned. Once the handshake has completed, cancellation of the context will\n    not affect the connection.\n\n    Most uses of this package need not call HandshakeContext explicitly:\n    the first Conn.Read or Conn.Write will call it automatically.\n\nfunc (c *Conn) LocalAddr() net.Addr\n    LocalAddr returns the local network address.\n\nfunc (c *Conn) NetConn() net.Conn\n    NetConn returns the underlying connection that is wrapped by c. Note that\n    writing to or reading from this connection directly will corrupt the TLS\n    session.\n\nfunc (c *Conn) OCSPResponse() []byte\n    OCSPResponse returns the stapled OCSP response from the TLS server, if any.\n    (Only valid for client connections.)\n\nfunc (c *Conn) Read(b []byte) (int, error)\n    Read reads data from the connection.\n\n    As Read calls Conn.Handshake, in order to prevent indefinite blocking\n    a deadline must be set for both Read and Conn.Write before Read is\n    called when the handshake has not yet completed. See Conn.SetDeadline,\n    Conn.SetReadDeadline, and Conn.SetWriteDeadline.\n\nfunc (c *Conn) RemoteAddr() net.Addr\n    RemoteAddr returns the remote network address.\n\nfunc (c *Conn) SetDeadline(t time.Time) error\n    SetDeadline sets the read and write deadlines associated with the\n    connection. A zero value for t means Conn.Read and Conn.Write will not time\n    out. After a Write has timed out, the TLS state is corrupt and all future\n    writes will return the same error.\n\nfunc (c *Conn) SetReadDeadline(t time.Time) error\n    SetReadDeadline sets the read deadline on the underlying connection.\n    A zero value for t means Conn.Read will not time out.\n\nfunc (c *Conn) SetWriteDeadline(t time.Time) error\n    SetWriteDeadline sets the write deadline on the underlying connection.\n    A zero value for t means Conn.Write will not time out. After a Conn.Write\n    has timed out, the TLS state is corrupt and all future writes will return\n    the same error.\n\nfunc (c *Conn) VerifyHostname(host string) error\n    VerifyHostname checks that the peer certificate chain is valid for\n    connecting to host. If so, it returns nil; if not, it returns an error\n    describing the problem.\n\nfunc (c *Conn) Write(b []byte) (int, error)\n    Write writes data to the connection.\n\n    As Write calls Conn.Handshake, in order to prevent indefinite blocking\n    a deadline must be set for both Conn.Read and Write before Write is\n    called when the handshake has not yet completed. See Conn.SetDeadline,\n    Conn.SetReadDeadline, and Conn.SetWriteDeadline.\n\ntype ConnectionState struct {\n\t// Version is the TLS version used by the connection (e.g. VersionTLS12).\n\tVersion uint16\n\n\t// HandshakeComplete is true if the handshake has concluded.\n\tHandshakeComplete bool\n\n\t// DidResume is true if this connection was successfully resumed from a\n\t// previous session with a session ticket or similar mechanism.\n\tDidResume bool\n\n\t// CipherSuite is the cipher suite negotiated for the connection (e.g.\n\t// TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_AES_128_GCM_SHA256).\n\tCipherSuite uint16\n\n\t// CurveID is the key exchange mechanism used for the connection. The name\n\t// refers to elliptic curves for legacy reasons, see [CurveID]. If a legacy\n\t// RSA key exchange is used, this value is zero.\n\tCurveID CurveID\n\n\t// NegotiatedProtocol is the application protocol negotiated with ALPN.\n\tNegotiatedProtocol string\n\n\t// NegotiatedProtocolIsMutual used to indicate a mutual NPN negotiation.\n\t//\n\t// Deprecated: this value is always true.\n\tNegotiatedProtocolIsMutual bool\n\n\t// ServerName is the value of the Server Name Indication extension sent by\n\t// the client. It's available both on the server and on the client side.\n\tServerName string\n\n\t// PeerCertificates are the parsed certificates sent by the peer, in the\n\t// order in which they were sent. The first element is the leaf certificate\n\t// that the connection is verified against.\n\t//\n\t// On the client side, it can't be empty. On the server side, it can be\n\t// empty if Config.ClientAuth is not RequireAnyClientCert or\n\t// RequireAndVerifyClientCert.\n\t//\n\t// PeerCertificates and its contents should not be modified.\n\tPeerCertificates []*x509.Certificate\n\n\t// VerifiedChains is a list of one or more chains where the first element is\n\t// PeerCertificates[0] and the last element is from Config.RootCAs (on the\n\t// client side) or Config.ClientCAs (on the server side).\n\t//\n\t// On the client side, it's set if Config.InsecureSkipVerify is false. On\n\t// the server side, it's set if Config.ClientAuth is VerifyClientCertIfGiven\n\t// (and the peer provided a certificate) or RequireAndVerifyClientCert.\n\t//\n\t// VerifiedChains and its contents should not be modified.\n\tVerifiedChains [][]*x509.Certificate\n\n\t// SignedCertificateTimestamps is a list of SCTs provided by the peer\n\t// through the TLS handshake for the leaf certificate, if any.\n\tSignedCertificateTimestamps [][]byte\n\n\t// OCSPResponse is a stapled Online Certificate Status Protocol (OCSP)\n\t// response provided by the peer for the leaf certificate, if any.\n\tOCSPResponse []byte\n\n\t// TLSUnique contains the \"tls-unique\" channel binding value (see RFC 5929,\n\t// Section 3). This value will be nil for TLS 1.3 connections and for\n\t// resumed connections that don't support Extended Master Secret (RFC 7627).\n\tTLSUnique []byte\n\n\t// ECHAccepted indicates if Encrypted Client Hello was offered by the client\n\t// and accepted by the server. Currently, ECH is supported only on the\n\t// client side.\n\tECHAccepted bool\n\n\t// Has unexported fields.\n}\n    ConnectionState records basic TLS details about the connection.\n\nfunc (cs *ConnectionState) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error)\n    ExportKeyingMaterial returns length bytes of exported key material in a\n    new slice as defined in RFC 5705. If context is nil, it is not used as\n    part of the seed. If the connection was set to allow renegotiation via\n    Config.Renegotiation, or if the connections supports neither TLS 1.3 nor\n    Extended Master Secret, this function will return an error.\n\n    Exporting key material without Extended Master Secret or TLS 1.3 was\n    disabled in Go 1.22 due to security issues (see the Security Considerations\n    sections of RFC 5705 and RFC 7627), but can be re-enabled with the GODEBUG\n    setting tlsunsafeekm=1.\n\ntype CurveID uint16\n    CurveID is the type of a TLS identifier for a key exchange mechanism. See\n    https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8.\n\n    In TLS 1.2, this registry used to support only elliptic curves. In TLS 1.3,\n    it was extended to other groups and renamed NamedGroup. See RFC 8446,\n    Section 4.2.7. It was then also extended to other mechanisms, such as hybrid\n    post-quantum KEMs.\n\nconst (\n\tCurveP256      CurveID = 23\n\tCurveP384      CurveID = 24\n\tCurveP521      CurveID = 25\n\tX25519         CurveID = 29\n\tX25519MLKEM768 CurveID = 4588\n)\nfunc (i CurveID) String() string\n\ntype Dialer struct {\n\t// NetDialer is the optional dialer to use for the TLS connections'\n\t// underlying TCP connections.\n\t// A nil NetDialer is equivalent to the net.Dialer zero value.\n\tNetDialer *net.Dialer\n\n\t// Config is the TLS configuration to use for new connections.\n\t// A nil configuration is equivalent to the zero\n\t// configuration; see the documentation of Config for the\n\t// defaults.\n\tConfig *Config\n}\n    Dialer dials TLS connections given a configuration and a Dialer for the\n    underlying connection.\n\nfunc (d *Dialer) Dial(network, addr string) (net.Conn, error)\n    Dial connects to the given network address and initiates a TLS handshake,\n    returning the resulting TLS connection.\n\n    The returned Conn, if any, will always be of type *Conn.\n\n    Dial uses context.Background internally; to specify the context, use\n    Dialer.DialContext.\n\nfunc (d *Dialer) DialContext(ctx context.Context, network, addr string) (net.Conn, error)\n    DialContext connects to the given network address and initiates a TLS\n    handshake, returning the resulting TLS connection.\n\n    The provided Context must be non-nil. If the context expires before the\n    connection is complete, an error is returned. Once successfully connected,\n    any expiration of the context will not affect the connection.\n\n    The returned Conn, if any, will always be of type *Conn.\n\ntype ECHRejectionError struct {\n\tRetryConfigList []byte\n}\n    ECHRejectionError is the error type returned when ECH is rejected by a\n    remote server. If the server offered a ECHConfigList to use for retries,\n    the RetryConfigList field will contain this list.\n\n    The client may treat an ECHRejectionError with an empty set of RetryConfigs\n    as a secure signal from the server.\n\nfunc (e *ECHRejectionError) Error() string\n\ntype EncryptedClientHelloKey struct {\n\t// Config should be a marshalled ECHConfig associated with PrivateKey. This\n\t// must match the config provided to clients byte-for-byte. The config\n\t// should only specify the DHKEM(X25519, HKDF-SHA256) KEM ID (0x0020), the\n\t// HKDF-SHA256 KDF ID (0x0001), and a subset of the following AEAD IDs:\n\t// AES-128-GCM (0x0001), AES-256-GCM (0x0002), ChaCha20Poly1305 (0x0003).\n\tConfig []byte\n\t// PrivateKey should be a marshalled private key. Currently, we expect\n\t// this to be the output of [ecdh.PrivateKey.Bytes].\n\tPrivateKey []byte\n\t// SendAsRetry indicates if Config should be sent as part of the list of\n\t// retry configs when ECH is requested by the client but rejected by the\n\t// server.\n\tSendAsRetry bool\n}\n    EncryptedClientHelloKey holds a private key that is associated with a\n    specific ECH config known to a client.\n\ntype QUICConfig struct {\n\tTLSConfig *Config\n\n\t// EnableSessionEvents may be set to true to enable the\n\t// [QUICStoreSession] and [QUICResumeSession] events for client connections.\n\t// When this event is enabled, sessions are not automatically\n\t// stored in the client session cache.\n\t// The application should use [QUICConn.StoreSession] to store sessions.\n\tEnableSessionEvents bool\n}\n    A QUICConfig configures a QUICConn.\n\ntype QUICConn struct {\n\t// Has unexported fields.\n}\n    A QUICConn represents a connection which uses a QUIC implementation as the\n    underlying transport as described in RFC 9001.\n\n    Methods of QUICConn are not safe for concurrent use.\n\nfunc QUICClient(config *QUICConfig) *QUICConn\n    QUICClient returns a new TLS client side connection using QUICTransport as\n    the underlying transport. The config cannot be nil.\n\n    The config's MinVersion must be at least TLS 1.3.\n\nfunc QUICServer(config *QUICConfig) *QUICConn\n    QUICServer returns a new TLS server side connection using QUICTransport as\n    the underlying transport. The config cannot be nil.\n\n    The config's MinVersion must be at least TLS 1.3.\n\nfunc (q *QUICConn) Close() error\n    Close closes the connection and stops any in-progress handshake.\n\nfunc (q *QUICConn) ConnectionState() ConnectionState\n    ConnectionState returns basic TLS details about the connection.\n\nfunc (q *QUICConn) HandleData(level QUICEncryptionLevel, data []byte) error\n    HandleData handles handshake bytes received from the peer. It may produce\n    connection events, which may be read with QUICConn.NextEvent.\n\nfunc (q *QUICConn) NextEvent() QUICEvent\n    NextEvent returns the next event occurring on the connection. It returns an\n    event with a Kind of QUICNoEvent when no events are available.\n\nfunc (q *QUICConn) SendSessionTicket(opts QUICSessionTicketOptions) error\n    SendSessionTicket sends a session ticket to the client. It produces\n    connection events, which may be read with QUICConn.NextEvent. Currently,\n    it can only be called once.\n\nfunc (q *QUICConn) SetTransportParameters(params []byte)\n    SetTransportParameters sets the transport parameters to send to the peer.\n\n    Server connections may delay setting the transport parameters\n    until after receiving the client's transport parameters. See\n    QUICTransportParametersRequired.\n\nfunc (q *QUICConn) Start(ctx context.Context) error\n    Start starts the client or server handshake protocol. It may produce\n    connection events, which may be read with QUICConn.NextEvent.\n\n    Start must be called at most once.\n\nfunc (q *QUICConn) StoreSession(session *SessionState) error\n    StoreSession stores a session previously received in a QUICStoreSession\n    event in the ClientSessionCache. The application may process additional\n    events or modify the SessionState before storing the session.\n\ntype QUICEncryptionLevel int\n    QUICEncryptionLevel represents a QUIC encryption level used to transmit\n    handshake messages.\n\nfunc (l QUICEncryptionLevel) String() string\n\ntype QUICEvent struct {\n\tKind QUICEventKind\n\n\t// Set for QUICSetReadSecret, QUICSetWriteSecret, and QUICWriteData.\n\tLevel QUICEncryptionLevel\n\n\t// Set for QUICTransportParameters, QUICSetReadSecret, QUICSetWriteSecret, and QUICWriteData.\n\t// The contents are owned by crypto/tls, and are valid until the next NextEvent call.\n\tData []byte\n\n\t// Set for QUICSetReadSecret and QUICSetWriteSecret.\n\tSuite uint16\n\n\t// Set for QUICResumeSession and QUICStoreSession.\n\tSessionState *SessionState\n}\n    A QUICEvent is an event occurring on a QUIC connection.\n\n    The type of event is specified by the Kind field. The contents of the other\n    fields are kind-specific.\n\ntype QUICEventKind int\n    A QUICEventKind is a type of operation on a QUIC connection.\n\nconst (\n\t// QUICNoEvent indicates that there are no events available.\n\tQUICNoEvent QUICEventKind = iota\n\n\t// QUICSetReadSecret and QUICSetWriteSecret provide the read and write\n\t// secrets for a given encryption level.\n\t// QUICEvent.Level, QUICEvent.Data, and QUICEvent.Suite are set.\n\t//\n\t// Secrets for the Initial encryption level are derived from the initial\n\t// destination connection ID, and are not provided by the QUICConn.\n\tQUICSetReadSecret\n\tQUICSetWriteSecret\n\n\t// QUICWriteData provides data to send to the peer in CRYPTO frames.\n\t// QUICEvent.Data is set.\n\tQUICWriteData\n\n\t// QUICTransportParameters provides the peer's QUIC transport parameters.\n\t// QUICEvent.Data is set.\n\tQUICTransportParameters\n\n\t// QUICTransportParametersRequired indicates that the caller must provide\n\t// QUIC transport parameters to send to the peer. The caller should set\n\t// the transport parameters with QUICConn.SetTransportParameters and call\n\t// QUICConn.NextEvent again.\n\t//\n\t// If transport parameters are set before calling QUICConn.Start, the\n\t// connection will never generate a QUICTransportParametersRequired event.\n\tQUICTransportParametersRequired\n\n\t// QUICRejectedEarlyData indicates that the server rejected 0-RTT data even\n\t// if we offered it. It's returned before QUICEncryptionLevelApplication\n\t// keys are returned.\n\t// This event only occurs on client connections.\n\tQUICRejectedEarlyData\n\n\t// QUICHandshakeDone indicates that the TLS handshake has completed.\n\tQUICHandshakeDone\n\n\t// QUICResumeSession indicates that a client is attempting to resume a previous session.\n\t// [QUICEvent.SessionState] is set.\n\t//\n\t// For client connections, this event occurs when the session ticket is selected.\n\t// For server connections, this event occurs when receiving the client's session ticket.\n\t//\n\t// The application may set [QUICEvent.SessionState.EarlyData] to false before the\n\t// next call to [QUICConn.NextEvent] to decline 0-RTT even if the session supports it.\n\tQUICResumeSession\n\n\t// QUICStoreSession indicates that the server has provided state permitting\n\t// the client to resume the session.\n\t// [QUICEvent.SessionState] is set.\n\t// The application should use [QUICConn.StoreSession] session to store the [SessionState].\n\t// The application may modify the [SessionState] before storing it.\n\t// This event only occurs on client connections.\n\tQUICStoreSession\n)\ntype QUICSessionTicketOptions struct {\n\t// EarlyData specifies whether the ticket may be used for 0-RTT.\n\tEarlyData bool\n\tExtra     [][]byte\n}\n\ntype RecordHeaderError struct {\n\t// Msg contains a human readable string that describes the error.\n\tMsg string\n\t// RecordHeader contains the five bytes of TLS record header that\n\t// triggered the error.\n\tRecordHeader [5]byte\n\t// Conn provides the underlying net.Conn in the case that a client\n\t// sent an initial handshake that didn't look like TLS.\n\t// It is nil if there's already been a handshake or a TLS alert has\n\t// been written to the connection.\n\tConn net.Conn\n}\n    RecordHeaderError is returned when a TLS record header is invalid.\n\nfunc (e RecordHeaderError) Error() string\n\ntype RenegotiationSupport int\n    RenegotiationSupport enumerates the different levels of support for TLS\n    renegotiation. TLS renegotiation is the act of performing subsequent\n    handshakes on a connection after the first. This significantly complicates\n    the state machine and has been the source of numerous, subtle security\n    issues. Initiating a renegotiation is not supported, but support for\n    accepting renegotiation requests may be enabled.\n\n    Even when enabled, the server may not change its identity between handshakes\n    (i.e. the leaf certificate must be the same). Additionally, concurrent\n    handshake and application data flow is not permitted so renegotiation\n    can only be used with protocols that synchronise with the renegotiation,\n    such as HTTPS.\n\n    Renegotiation is not defined in TLS 1.3.\n\nconst (\n\t// RenegotiateNever disables renegotiation.\n\tRenegotiateNever RenegotiationSupport = iota\n\n\t// RenegotiateOnceAsClient allows a remote server to request\n\t// renegotiation once per connection.\n\tRenegotiateOnceAsClient\n\n\t// RenegotiateFreelyAsClient allows a remote server to repeatedly\n\t// request renegotiation.\n\tRenegotiateFreelyAsClient\n)\ntype SessionState struct {\n\n\t// Extra is ignored by crypto/tls, but is encoded by [SessionState.Bytes]\n\t// and parsed by [ParseSessionState].\n\t//\n\t// This allows [Config.UnwrapSession]/[Config.WrapSession] and\n\t// [ClientSessionCache] implementations to store and retrieve additional\n\t// data alongside this session.\n\t//\n\t// To allow different layers in a protocol stack to share this field,\n\t// applications must only append to it, not replace it, and must use entries\n\t// that can be recognized even if out of order (for example, by starting\n\t// with an id and version prefix).\n\tExtra [][]byte\n\n\t// EarlyData indicates whether the ticket can be used for 0-RTT in a QUIC\n\t// connection. The application may set this to false if it is true to\n\t// decline to offer 0-RTT even if supported.\n\tEarlyData bool\n\n\t// Has unexported fields.\n}\n    A SessionState is a resumable session.\n\nfunc ParseSessionState(data []byte) (*SessionState, error)\n    ParseSessionState parses a SessionState encoded by SessionState.Bytes.\n\nfunc (s *SessionState) Bytes() ([]byte, error)\n    Bytes encodes the session, including any private fields, so that it can be\n    parsed by ParseSessionState. The encoding contains secret values critical to\n    the security of future and possibly past sessions.\n\n    The specific encoding should be considered opaque and may change\n    incompatibly between Go versions.\n\ntype SignatureScheme uint16\n    SignatureScheme identifies a signature algorithm supported by TLS. See RFC\n    8446, Section 4.2.3.\n\nconst (\n\t// RSASSA-PKCS1-v1_5 algorithms.\n\tPKCS1WithSHA256 SignatureScheme = 0x0401\n\tPKCS1WithSHA384 SignatureScheme = 0x0501\n\tPKCS1WithSHA512 SignatureScheme = 0x0601\n\n\t// RSASSA-PSS algorithms with public key OID rsaEncryption.\n\tPSSWithSHA256 SignatureScheme = 0x0804\n\tPSSWithSHA384 SignatureScheme = 0x0805\n\tPSSWithSHA512 SignatureScheme = 0x0806\n\n\t// ECDSA algorithms. Only constrained to a specific curve in TLS 1.3.\n\tECDSAWithP256AndSHA256 SignatureScheme = 0x0403\n\tECDSAWithP384AndSHA384 SignatureScheme = 0x0503\n\tECDSAWithP521AndSHA512 SignatureScheme = 0x0603\n\n\t// EdDSA algorithms.\n\tEd25519 SignatureScheme = 0x0807\n\n\t// Legacy signature and hash algorithms for TLS 1.2.\n\tPKCS1WithSHA1 SignatureScheme = 0x0201\n\tECDSAWithSHA1 SignatureScheme = 0x0203\n)\nfunc (i SignatureScheme) String() string\n\n\nBUG: The crypto/tls package only implements some countermeasures\nagainst Lucky13 attacks on CBC-mode encryption, and only on SHA1\nvariants. See http://www.isg.rhul.ac.uk/tls/TLStiming.pdf and\nhttps://www.imperialviolet.org/2013/02/04/luckythirteen.html.\n\n"}, {"path": "stdlib/net-netip.md", "category": "stdlib", "name": "stdlib/net-netip", "content": "package netip // import \"net/netip\"\n\nPackage netip defines an IP address type that's a small value type. Building on\nthat Addr type, the package also defines AddrPort (an IP address and a port) and\nPrefix (an IP address and a bit length prefix).\n\nCompared to the net.IP type, Addr type takes less memory, is immutable, and is\ncomparable (supports == and being a map key).\n\nTYPES\n\ntype Addr struct {\n\t// Has unexported fields.\n}\n    Addr represents an IPv4 or IPv6 address (with or without a scoped addressing\n    zone), similar to net.IP or net.IPAddr.\n\n    Unlike net.IP or net.IPAddr, Addr is a comparable value type (it supports ==\n    and can be a map key) and is immutable.\n\n    The zero Addr is not a valid IP address. Addr{} is distinct from both\n    0.0.0.0 and ::.\n\nfunc AddrFrom16(addr [16]byte) Addr\n    AddrFrom16 returns the IPv6 address given by the bytes in addr. An\n    IPv4-mapped IPv6 address is left as an IPv6 address. (Use Unmap to convert\n    them if needed.)\n\nfunc AddrFrom4(addr [4]byte) Addr\n    AddrFrom4 returns the address of the IPv4 address given by the bytes in\n    addr.\n\nfunc AddrFromSlice(slice []byte) (ip Addr, ok bool)\n    AddrFromSlice parses the 4- or 16-byte byte slice as an IPv4 or IPv6\n    address. Note that a net.IP can be passed directly as the []byte argument.\n    If slice's length is not 4 or 16, AddrFromSlice returns Addr{}, false.\n\nfunc IPv4Unspecified() Addr\n    IPv4Unspecified returns the IPv4 unspecified address \"0.0.0.0\".\n\nfunc IPv6LinkLocalAllNodes() Addr\n    IPv6LinkLocalAllNodes returns the IPv6 link-local all nodes multicast\n    address ff02::1.\n\nfunc IPv6LinkLocalAllRouters() Addr\n    IPv6LinkLocalAllRouters returns the IPv6 link-local all routers multicast\n    address ff02::2.\n\nfunc IPv6Loopback() Addr\n    IPv6Loopback returns the IPv6 loopback address ::1.\n\nfunc IPv6Unspecified() Addr\n    IPv6Unspecified returns the IPv6 unspecified address \"::\".\n\nfunc MustParseAddr(s string) Addr\n    MustParseAddr calls ParseAddr(s) and panics on error. It is intended for use\n    in tests with hard-coded strings.\n\nfunc ParseAddr(s string) (Addr, error)\n    ParseAddr parses s as an IP address, returning the result. The string s can\n    be in dotted decimal (\"192.0.2.1\"), IPv6 (\"2001:db8::68\"), or IPv6 with a\n    scoped addressing zone (\"fe80::1cc0:3e8c:119f:c2e1%ens18\").\n\nfunc (ip Addr) AppendBinary(b []byte) ([]byte, error)\n    AppendBinary implements the encoding.BinaryAppender interface.\n\nfunc (ip Addr) AppendText(b []byte) ([]byte, error)\n    AppendText implements the encoding.TextAppender interface, It is the same as\n    Addr.AppendTo.\n\nfunc (ip Addr) AppendTo(b []byte) []byte\n    AppendTo appends a text encoding of ip, as generated by Addr.MarshalText,\n    to b and returns the extended buffer.\n\nfunc (ip Addr) As16() (a16 [16]byte)\n    As16 returns the IP address in its 16-byte representation. IPv4 addresses\n    are returned as IPv4-mapped IPv6 addresses. IPv6 addresses with zones are\n    returned without their zone (use the Addr.Zone method to get it). The ip\n    zero value returns all zeroes.\n\nfunc (ip Addr) As4() (a4 [4]byte)\n    As4 returns an IPv4 or IPv4-in-IPv6 address in its 4-byte representation.\n    If ip is the zero Addr or an IPv6 address, As4 panics. Note that 0.0.0.0 is\n    not the zero Addr.\n\nfunc (ip Addr) AsSlice() []byte\n    AsSlice returns an IPv4 or IPv6 address in its respective 4-byte or 16-byte\n    representation.\n\nfunc (ip Addr) BitLen() int\n    BitLen returns the number of bits in the IP address: 128 for IPv6, 32 for\n    IPv4, and 0 for the zero Addr.\n\n    Note that IPv4-mapped IPv6 addresses are considered IPv6 addresses and\n    therefore have bit length 128.\n\nfunc (ip Addr) Compare(ip2 Addr) int\n    Compare returns an integer comparing two IPs. The result will be 0 if ip ==\n    ip2, -1 if ip < ip2, and +1 if ip > ip2. The definition of \"less than\" is\n    the same as the Addr.Less method.\n\nfunc (ip Addr) Is4() bool\n    Is4 reports whether ip is an IPv4 address.\n\n    It returns false for IPv4-mapped IPv6 addresses. See Addr.Unmap.\n\nfunc (ip Addr) Is4In6() bool\n    Is4In6 reports whether ip is an \"IPv4-mapped IPv6 address\" as defined by RFC\n    4291. That is, it reports whether ip is in ::ffff:0:0/96.\n\nfunc (ip Addr) Is6() bool\n    Is6 reports whether ip is an IPv6 address, including IPv4-mapped IPv6\n    addresses.\n\nfunc (ip Addr) IsGlobalUnicast() bool\n    IsGlobalUnicast reports whether ip is a global unicast address.\n\n    It returns true for IPv6 addresses which fall outside of the current\n    IANA-allocated 2000::/3 global unicast space, with the exception of the\n    link-local address space. It also returns true even if ip is in the IPv4\n    private address space or IPv6 unique local address space. It returns false\n    for the zero Addr.\n\n    For reference, see RFC 1122, RFC 4291, and RFC 4632.\n\nfunc (ip Addr) IsInterfaceLocalMulticast() bool\n    IsInterfaceLocalMulticast reports whether ip is an IPv6 interface-local\n    multicast address.\n\nfunc (ip Addr) IsLinkLocalMulticast() bool\n    IsLinkLocalMulticast reports whether ip is a link-local multicast address.\n\nfunc (ip Addr) IsLinkLocalUnicast() bool\n    IsLinkLocalUnicast reports whether ip is a link-local unicast address.\n\nfunc (ip Addr) IsLoopback() bool\n    IsLoopback reports whether ip is a loopback address.\n\nfunc (ip Addr) IsMulticast() bool\n    IsMulticast reports whether ip is a multicast address.\n\nfunc (ip Addr) IsPrivate() bool\n    IsPrivate reports whether ip is a private address, according to RFC 1918\n    (IPv4 addresses) and RFC 4193 (IPv6 addresses). That is, it reports whether\n    ip is in 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, or fc00::/7. This is the\n    same as net.IP.IsPrivate.\n\nfunc (ip Addr) IsUnspecified() bool\n    IsUnspecified reports whether ip is an unspecified address, either the IPv4\n    address \"0.0.0.0\" or the IPv6 address \"::\".\n\n    Note that the zero Addr is not an unspecified address.\n\nfunc (ip Addr) IsValid() bool\n    IsValid reports whether the Addr is an initialized address (not the zero\n    Addr).\n\n    Note that \"0.0.0.0\" and \"::\" are both valid values.\n\nfunc (ip Addr) Less(ip2 Addr) bool\n    Less reports whether ip sorts before ip2. IP addresses sort first by length,\n    then their address. IPv6 addresses with zones sort just after the same\n    address without a zone.\n\nfunc (ip Addr) MarshalBinary() ([]byte, error)\n    MarshalBinary implements the encoding.BinaryMarshaler interface. It returns\n    a zero-length slice for the zero Addr, the 4-byte form for an IPv4 address,\n    and the 16-byte form with zone appended for an IPv6 address.\n\nfunc (ip Addr) MarshalText() ([]byte, error)\n    MarshalText implements the encoding.TextMarshaler interface, The encoding is\n    the same as returned by Addr.String, with one exception: If ip is the zero\n    Addr, the encoding is the empty string.\n\nfunc (ip Addr) Next() Addr\n    Next returns the address following ip. If there is none, it returns the zero\n    Addr.\n\nfunc (ip Addr) Prefix(b int) (Prefix, error)\n    Prefix keeps only the top b bits of IP, producing a Prefix of the specified\n    length. If ip is a zero Addr, Prefix always returns a zero Prefix and a nil\n    error. Otherwise, if bits is less than zero or greater than ip.BitLen(),\n    Prefix returns an error.\n\nfunc (ip Addr) Prev() Addr\n    Prev returns the IP before ip. If there is none, it returns the IP zero\n    value.\n\nfunc (ip Addr) String() string\n    String returns the string form of the IP address ip. It returns one of 5\n    forms:\n\n      - \"invalid IP\", if ip is the zero Addr\n      - IPv4 dotted decimal (\"192.0.2.1\")\n      - IPv6 (\"2001:db8::1\")\n      - \"::ffff:1.2.3.4\" (if Addr.Is4In6)\n      - IPv6 with zone (\"fe80:db8::1%eth0\")\n\n    Note that unlike package net's IP.String method, IPv4-mapped IPv6 addresses\n    format with a \"::ffff:\" prefix before the dotted quad.\n\nfunc (ip Addr) StringExpanded() string\n    StringExpanded is like Addr.String but IPv6 addresses are expanded with\n    leading zeroes and no \"::\" compression. For example, \"2001:db8::1\" becomes\n    \"2001:0db8:0000:0000:0000:0000:0000:0001\".\n\nfunc (ip Addr) Unmap() Addr\n    Unmap returns ip with any IPv4-mapped IPv6 address prefix removed.\n\n    That is, if ip is an IPv6 address wrapping an IPv4 address, it returns the\n    wrapped IPv4 address. Otherwise it returns ip unmodified.\n\nfunc (ip *Addr) UnmarshalBinary(b []byte) error\n    UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\n    It expects data in the form generated by MarshalBinary.\n\nfunc (ip *Addr) UnmarshalText(text []byte) error\n    UnmarshalText implements the encoding.TextUnmarshaler interface. The IP\n    address is expected in a form accepted by ParseAddr.\n\n    If text is empty, UnmarshalText sets *ip to the zero Addr and returns no\n    error.\n\nfunc (ip Addr) WithZone(zone string) Addr\n    WithZone returns an IP that's the same as ip but with the provided zone.\n    If zone is empty, the zone is removed. If ip is an IPv4 address, WithZone is\n    a no-op and returns ip unchanged.\n\nfunc (ip Addr) Zone() string\n    Zone returns ip's IPv6 scoped addressing zone, if any.\n\ntype AddrPort struct {\n\t// Has unexported fields.\n}\n    AddrPort is an IP and a port number.\n\nfunc AddrPortFrom(ip Addr, port uint16) AddrPort\n    AddrPortFrom returns an AddrPort with the provided IP and port. It does not\n    allocate.\n\nfunc MustParseAddrPort(s string) AddrPort\n    MustParseAddrPort calls ParseAddrPort(s) and panics on error. It is intended\n    for use in tests with hard-coded strings.\n\nfunc ParseAddrPort(s string) (AddrPort, error)\n    ParseAddrPort parses s as an AddrPort.\n\n    It doesn't do any name resolution: both the address and the port must be\n    numeric.\n\nfunc (p AddrPort) Addr() Addr\n    Addr returns p's IP address.\n\nfunc (p AddrPort) AppendBinary(b []byte) ([]byte, error)\n    AppendBinary implements the encoding.BinaryAppendler interface. It returns\n    Addr.AppendBinary with an additional two bytes appended containing the port\n    in little-endian.\n\nfunc (p AddrPort) AppendText(b []byte) ([]byte, error)\n    AppendText implements the encoding.TextAppender interface. The encoding is\n    the same as returned by AddrPort.AppendTo.\n\nfunc (p AddrPort) AppendTo(b []byte) []byte\n    AppendTo appends a text encoding of p, as generated by AddrPort.MarshalText,\n    to b and returns the extended buffer.\n\nfunc (p AddrPort) Compare(p2 AddrPort) int\n    Compare returns an integer comparing two AddrPorts. The result will be 0 if\n    p == p2, -1 if p < p2, and +1 if p > p2. AddrPorts sort first by IP address,\n    then port.\n\nfunc (p AddrPort) IsValid() bool\n    IsValid reports whether p.Addr() is valid. All ports are valid, including\n    zero.\n\nfunc (p AddrPort) MarshalBinary() ([]byte, error)\n    MarshalBinary implements the encoding.BinaryMarshaler interface. It returns\n    Addr.MarshalBinary with an additional two bytes appended containing the port\n    in little-endian.\n\nfunc (p AddrPort) MarshalText() ([]byte, error)\n    MarshalText implements the encoding.TextMarshaler interface. The encoding is\n    the same as returned by AddrPort.String, with one exception: if p.Addr() is\n    the zero Addr, the encoding is the empty string.\n\nfunc (p AddrPort) Port() uint16\n    Port returns p's port.\n\nfunc (p AddrPort) String() string\n\nfunc (p *AddrPort) UnmarshalBinary(b []byte) error\n    UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\n    It expects data in the form generated by AddrPort.MarshalBinary.\n\nfunc (p *AddrPort) UnmarshalText(text []byte) error\n    UnmarshalText implements the encoding.TextUnmarshaler interface. The\n    AddrPort is expected in a form generated by AddrPort.MarshalText or accepted\n    by ParseAddrPort.\n\ntype Prefix struct {\n\t// Has unexported fields.\n}\n    Prefix is an IP address prefix (CIDR) representing an IP network.\n\n    The first Prefix.Bits() of Addr() are specified. The remaining bits match\n    any address. The range of Bits() is [0,32] for IPv4 or [0,128] for IPv6.\n\nfunc MustParsePrefix(s string) Prefix\n    MustParsePrefix calls ParsePrefix(s) and panics on error. It is intended for\n    use in tests with hard-coded strings.\n\nfunc ParsePrefix(s string) (Prefix, error)\n    ParsePrefix parses s as an IP address prefix. The string can be in the form\n    \"192.168.1.0/24\" or \"2001:db8::/32\", the CIDR notation defined in RFC 4632\n    and RFC 4291. IPv6 zones are not permitted in prefixes, and an error will be\n    returned if a zone is present.\n\n    Note that masked address bits are not zeroed. Use Masked for that.\n\nfunc PrefixFrom(ip Addr, bits int) Prefix\n    PrefixFrom returns a Prefix with the provided IP address and bit prefix\n    length.\n\n    It does not allocate. Unlike Addr.Prefix, PrefixFrom does not mask off the\n    host bits of ip.\n\n    If bits is less than zero or greater than ip.BitLen, Prefix.Bits will return\n    an invalid value -1.\n\nfunc (p Prefix) Addr() Addr\n    Addr returns p's IP address.\n\nfunc (p Prefix) AppendBinary(b []byte) ([]byte, error)\n    AppendBinary implements the encoding.AppendMarshaler interface. It returns\n    Addr.AppendBinary with an additional byte appended containing the prefix\n    bits.\n\nfunc (p Prefix) AppendText(b []byte) ([]byte, error)\n    AppendText implements the encoding.TextAppender interface. It is the same as\n    Prefix.AppendTo.\n\nfunc (p Prefix) AppendTo(b []byte) []byte\n    AppendTo appends a text encoding of p, as generated by Prefix.MarshalText,\n    to b and returns the extended buffer.\n\nfunc (p Prefix) Bits() int\n    Bits returns p's prefix length.\n\n    It reports -1 if invalid.\n\nfunc (p Prefix) Contains(ip Addr) bool\n    Contains reports whether the network p includes ip.\n\n    An IPv4 address will not match an IPv6 prefix. An IPv4-mapped IPv6 address\n    will not match an IPv4 prefix. A zero-value IP will not match any prefix. If\n    ip has an IPv6 zone, Contains returns false, because Prefixes strip zones.\n\nfunc (p Prefix) IsSingleIP() bool\n    IsSingleIP reports whether p contains exactly one IP.\n\nfunc (p Prefix) IsValid() bool\n    IsValid reports whether p.Bits() has a valid range for p.Addr(). If p.Addr()\n    is the zero Addr, IsValid returns false. Note that if p is the zero Prefix,\n    then p.IsValid() == false.\n\nfunc (p Prefix) MarshalBinary() ([]byte, error)\n    MarshalBinary implements the encoding.BinaryMarshaler interface. It returns\n    Addr.MarshalBinary with an additional byte appended containing the prefix\n    bits.\n\nfunc (p Prefix) MarshalText() ([]byte, error)\n    MarshalText implements the encoding.TextMarshaler interface, The encoding is\n    the same as returned by Prefix.String, with one exception: If p is the zero\n    value, the encoding is the empty string.\n\nfunc (p Prefix) Masked() Prefix\n    Masked returns p in its canonical form, with all but the high p.Bits() bits\n    of p.Addr() masked off.\n\n    If p is zero or otherwise invalid, Masked returns the zero Prefix.\n\nfunc (p Prefix) Overlaps(o Prefix) bool\n    Overlaps reports whether p and o contain any IP addresses in common.\n\n    If p and o are of different address families or either have a zero IP,\n    it reports false. Like the Contains method, a prefix with an IPv4-mapped\n    IPv6 address is still treated as an IPv6 mask.\n\nfunc (p Prefix) String() string\n    String returns the CIDR notation of p: \"<ip>/<bits>\".\n\nfunc (p *Prefix) UnmarshalBinary(b []byte) error\n    UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\n    It expects data in the form generated by Prefix.MarshalBinary.\n\nfunc (p *Prefix) UnmarshalText(text []byte) error\n    UnmarshalText implements the encoding.TextUnmarshaler interface. The IP\n    address is expected in a form accepted by ParsePrefix or generated by\n    Prefix.MarshalText.\n\n"}, {"path": "stdlib/crypto-x509-pkix.md", "category": "stdlib", "name": "stdlib/crypto-x509-pkix", "content": "package pkix // import \"crypto/x509/pkix\"\n\nPackage pkix contains shared, low level structures used for ASN.1 parsing and\nserialization of X.509 certificates, CRL and OCSP.\n\nTYPES\n\ntype AlgorithmIdentifier struct {\n\tAlgorithm  asn1.ObjectIdentifier\n\tParameters asn1.RawValue `asn1:\"optional\"`\n}\n    AlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC\n    5280, section 4.1.1.2.\n\ntype AttributeTypeAndValue struct {\n\tType  asn1.ObjectIdentifier\n\tValue any\n}\n    AttributeTypeAndValue mirrors the ASN.1 structure of the same name in RFC\n    5280, Section 4.1.2.4.\n\ntype AttributeTypeAndValueSET struct {\n\tType  asn1.ObjectIdentifier\n\tValue [][]AttributeTypeAndValue `asn1:\"set\"`\n}\n    AttributeTypeAndValueSET represents a set of ASN.1 sequences of\n    AttributeTypeAndValue sequences from RFC 2986 (PKCS #10).\n\ntype CertificateList struct {\n\tTBSCertList        TBSCertificateList\n\tSignatureAlgorithm AlgorithmIdentifier\n\tSignatureValue     asn1.BitString\n}\n    CertificateList represents the ASN.1 structure of the same name.\n    See RFC 5280, section 5.1. Use Certificate.CheckCRLSignature to verify the\n    signature.\n\n    Deprecated: x509.RevocationList should be used instead.\n\nfunc (certList *CertificateList) HasExpired(now time.Time) bool\n    HasExpired reports whether certList should have been updated by now.\n\ntype Extension struct {\n\tId       asn1.ObjectIdentifier\n\tCritical bool `asn1:\"optional\"`\n\tValue    []byte\n}\n    Extension represents the ASN.1 structure of the same name. See RFC 5280,\n    section 4.2.\n\ntype Name struct {\n\tCountry, Organization, OrganizationalUnit []string\n\tLocality, Province                        []string\n\tStreetAddress, PostalCode                 []string\n\tSerialNumber, CommonName                  string\n\n\t// Names contains all parsed attributes. When parsing distinguished names,\n\t// this can be used to extract non-standard attributes that are not parsed\n\t// by this package. When marshaling to RDNSequences, the Names field is\n\t// ignored, see ExtraNames.\n\tNames []AttributeTypeAndValue\n\n\t// ExtraNames contains attributes to be copied, raw, into any marshaled\n\t// distinguished names. Values override any attributes with the same OID.\n\t// The ExtraNames field is not populated when parsing, see Names.\n\tExtraNames []AttributeTypeAndValue\n}\n    Name represents an X.509 distinguished name. This only includes the common\n    elements of a DN. Note that Name is only an approximation of the X.509\n    structure. If an accurate representation is needed, asn1.Unmarshal the raw\n    subject or issuer as an RDNSequence.\n\nfunc (n *Name) FillFromRDNSequence(rdns *RDNSequence)\n    FillFromRDNSequence populates n from the provided RDNSequence. Multi-entry\n    RDNs are flattened, all entries are added to the relevant n fields, and the\n    grouping is not preserved.\n\nfunc (n Name) String() string\n    String returns the string form of n, roughly following the RFC 2253\n    Distinguished Names syntax.\n\nfunc (n Name) ToRDNSequence() (ret RDNSequence)\n    ToRDNSequence converts n into a single RDNSequence. The following attributes\n    are encoded as multi-value RDNs:\n\n      - Country\n      - Organization\n      - OrganizationalUnit\n      - Locality\n      - Province\n      - StreetAddress\n      - PostalCode\n\n    Each ExtraNames entry is encoded as an individual RDN.\n\ntype RDNSequence []RelativeDistinguishedNameSET\n\nfunc (r RDNSequence) String() string\n    String returns a string representation of the sequence r, roughly following\n    the RFC 2253 Distinguished Names syntax.\n\ntype RelativeDistinguishedNameSET []AttributeTypeAndValue\n\ntype RevokedCertificate struct {\n\tSerialNumber   *big.Int\n\tRevocationTime time.Time\n\tExtensions     []Extension `asn1:\"optional\"`\n}\n    RevokedCertificate represents the ASN.1 structure of the same name. See RFC\n    5280, section 5.1.\n\ntype TBSCertificateList struct {\n\tRaw                 asn1.RawContent\n\tVersion             int `asn1:\"optional,default:0\"`\n\tSignature           AlgorithmIdentifier\n\tIssuer              RDNSequence\n\tThisUpdate          time.Time\n\tNextUpdate          time.Time            `asn1:\"optional\"`\n\tRevokedCertificates []RevokedCertificate `asn1:\"optional\"`\n\tExtensions          []Extension          `asn1:\"tag:0,optional,explicit\"`\n}\n    TBSCertificateList represents the ASN.1 structure of the same name. See RFC\n    5280, section 5.1.\n\n    Deprecated: x509.RevocationList should be used instead.\n\n"}, {"path": "stdlib/vendor-golang.org-x-sys-cpu.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-sys-cpu", "content": ""}, {"path": "stdlib/crypto-internal-fips140-ecdsa.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-ecdsa", "content": "package ecdsa // import \"crypto/internal/fips140/ecdsa\"\n\n\nFUNCTIONS\n\nfunc Verify[P Point[P]](c *Curve[P], pub *PublicKey, hash []byte, sig *Signature) error\n    Verify verifies the signature, sig, of hash (which should be the result of\n    hashing a larger message) using the public key, pub. If the hash is longer\n    than the bit-length of the private key's curve order, the hash will be\n    truncated to that length.\n\n    The inputs are not considered confidential, and may leak through timing side\n    channels, or if an attacker has control of part of the inputs.\n\nfunc TestingOnlyNewDRBG[H hash.Hash](hash func() H, entropy, nonce []byte, s []byte) *hmacDRBG\n    TestingOnlyNewDRBG creates an SP 800-90A Rev. 1 HMAC_DRBG with a plain\n    personalization string.\n\n    This should only be used for ACVP testing. hmacDRBG is not intended to be\n    used directly.\n\n\nTYPES\n\ntype Curve[P Point[P]] struct {\n\tN *bigmod.Modulus\n\t// Has unexported fields.\n}\n\nfunc P224() *Curve[*nistec.P224Point]\n\nfunc P256() *Curve[*nistec.P256Point]\n\nfunc P384() *Curve[*nistec.P384Point]\n\nfunc P521() *Curve[*nistec.P521Point]\n\ntype Point[P any] interface {\n\t*nistec.P224Point | *nistec.P256Point | *nistec.P384Point | *nistec.P521Point\n\tBytes() []byte\n\tBytesX() ([]byte, error)\n\tSetBytes([]byte) (P, error)\n\tScalarMult(P, []byte) (P, error)\n\tScalarBaseMult([]byte) (P, error)\n\tAdd(p1, p2 P) P\n}\n    Point is a generic constraint for the nistec Point types.\n\ntype PrivateKey struct {\n\t// Has unexported fields.\n}\n\nfunc GenerateKey[P Point[P]](c *Curve[P], rand io.Reader) (*PrivateKey, error)\n    GenerateKey generates a new ECDSA private key pair for the specified curve.\n\nfunc NewPrivateKey[P Point[P]](c *Curve[P], D, Q []byte) (*PrivateKey, error)\n\nfunc (priv *PrivateKey) Bytes() []byte\n\nfunc (priv *PrivateKey) PublicKey() *PublicKey\n\ntype PublicKey struct {\n\t// Has unexported fields.\n}\n\nfunc NewPublicKey[P Point[P]](c *Curve[P], Q []byte) (*PublicKey, error)\n\nfunc (pub *PublicKey) Bytes() []byte\n\ntype Signature struct {\n\tR, S []byte\n}\n    Signature is an ECDSA signature, where r and s are represented as big-endian\n    byte slices of the same length as the curve order.\n\nfunc Sign[P Point[P], H hash.Hash](c *Curve[P], h func() H, priv *PrivateKey, rand io.Reader, hash []byte) (*Signature, error)\n    Sign signs a hash (which shall be the result of hashing a larger message\n    with the hash function H) using the private key, priv. If the hash is longer\n    than the bit-length of the private key's curve order, the hash will be\n    truncated to that length.\n\nfunc SignDeterministic[P Point[P], H hash.Hash](c *Curve[P], h func() H, priv *PrivateKey, hash []byte) (*Signature, error)\n    SignDeterministic signs a hash (which shall be the result of hashing a\n    larger message with the hash function H) using the private key, priv.\n    If the hash is longer than the bit-length of the private key's curve order,\n    the hash will be truncated to that length. This applies Deterministic ECDSA\n    as specified in FIPS 186-5 and RFC 6979.\n\n"}, {"path": "stdlib/go-scanner.md", "category": "stdlib", "name": "stdlib/go-scanner", "content": "package scanner // import \"go/scanner\"\n\nPackage scanner implements a scanner for Go source text. It takes a []byte as\nsource which can then be tokenized through repeated calls to the Scan method.\n\nFUNCTIONS\n\nfunc PrintError(w io.Writer, err error)\n    PrintError is a utility function that prints a list of errors to w, one\n    error per line, if the err parameter is an ErrorList. Otherwise it prints\n    the err string.\n\n\nTYPES\n\ntype Error struct {\n\tPos token.Position\n\tMsg string\n}\n    In an ErrorList, an error is represented by an *Error. The position Pos,\n    if valid, points to the beginning of the offending token, and the error\n    condition is described by Msg.\n\nfunc (e Error) Error() string\n    Error implements the error interface.\n\ntype ErrorHandler func(pos token.Position, msg string)\n    An ErrorHandler may be provided to Scanner.Init. If a syntax error is\n    encountered and a handler was installed, the handler is called with a\n    position and an error message. The position points to the beginning of the\n    offending token.\n\ntype ErrorList []*Error\n    ErrorList is a list of *Errors. The zero value for an ErrorList is an empty\n    ErrorList ready to use.\n\nfunc (p *ErrorList) Add(pos token.Position, msg string)\n    Add adds an Error with given position and error message to an ErrorList.\n\nfunc (p ErrorList) Err() error\n    Err returns an error equivalent to this error list. If the list is empty,\n    Err returns nil.\n\nfunc (p ErrorList) Error() string\n    An ErrorList implements the error interface.\n\nfunc (p ErrorList) Len() int\n    ErrorList implements the sort Interface.\n\nfunc (p ErrorList) Less(i, j int) bool\n\nfunc (p *ErrorList) RemoveMultiples()\n    RemoveMultiples sorts an ErrorList and removes all but the first error per\n    line.\n\nfunc (p *ErrorList) Reset()\n    Reset resets an ErrorList to no errors.\n\nfunc (p ErrorList) Sort()\n    Sort sorts an ErrorList. *Error entries are sorted by position, other errors\n    are sorted by error message, and before any *Error entry.\n\nfunc (p ErrorList) Swap(i, j int)\n\ntype Mode uint\n    A mode value is a set of flags (or 0). They control scanner behavior.\n\nconst (\n\tScanComments Mode = 1 << iota // return comments as COMMENT tokens\n\n)\ntype Scanner struct {\n\n\t// public state - ok to modify\n\tErrorCount int // number of errors encountered\n\t// Has unexported fields.\n}\n    A Scanner holds the scanner's internal state while processing a given text.\n    It can be allocated as part of another data structure but must be\n    initialized via Scanner.Init before use.\n\nfunc (s *Scanner) Init(file *token.File, src []byte, err ErrorHandler, mode Mode)\n    Init prepares the scanner s to tokenize the text src by setting the scanner\n    at the beginning of src. The scanner uses the file set file for position\n    information and it adds line information for each line. It is ok to re-use\n    the same file when re-scanning the same file as line information which is\n    already present is ignored. Init causes a panic if the file size does not\n    match the src size.\n\n    Calls to Scanner.Scan will invoke the error handler err if they encounter\n    a syntax error and err is not nil. Also, for each error encountered,\n    the Scanner field ErrorCount is incremented by one. The mode parameter\n    determines how comments are handled.\n\n    Note that Init may call err if there is an error in the first character of\n    the file.\n\nfunc (s *Scanner) Scan() (pos token.Pos, tok token.Token, lit string)\n    Scan scans the next token and returns the token position, the token, and its\n    literal string if applicable. The source end is indicated by token.EOF.\n\n    If the returned token is a literal (token.IDENT, token.INT, token.FLOAT,\n    token.IMAG, token.CHAR, token.STRING) or token.COMMENT, the literal string\n    has the corresponding value.\n\n    If the returned token is a keyword, the literal string is the keyword.\n\n    If the returned token is token.SEMICOLON, the corresponding literal string\n    is \";\" if the semicolon was present in the source, and \"\\n\" if the semicolon\n    was inserted because of a newline or at EOF.\n\n    If the returned token is token.ILLEGAL, the literal string is the offending\n    character.\n\n    In all other cases, Scan returns an empty literal string.\n\n    For more tolerant parsing, Scan will return a valid token if possible\n    even if a syntax error was encountered. Thus, even if the resulting token\n    sequence contains no illegal tokens, a client may not assume that no error\n    occurred. Instead it must check the scanner's ErrorCount or the number of\n    calls of the error handler, if there was one installed.\n\n    Scan adds line information to the file added to the file set with Init.\n    Token positions are relative to that file and thus relative to the file set.\n\n"}, {"path": "stdlib/internal-singleflight.md", "category": "stdlib", "name": "stdlib/internal-singleflight", "content": "package singleflight // import \"internal/singleflight\"\n\nPackage singleflight provides a duplicate function call suppression mechanism.\n\nTYPES\n\ntype Group struct {\n\t// Has unexported fields.\n}\n    Group represents a class of work and forms a namespace in which units of\n    work can be executed with duplicate suppression.\n\nfunc (g *Group) Do(key string, fn func() (any, error)) (v any, err error, shared bool)\n    Do executes and returns the results of the given function, making sure that\n    only one execution is in-flight for a given key at a time. If a duplicate\n    comes in, the duplicate caller waits for the original to complete and\n    receives the same results. The return value shared indicates whether v was\n    given to multiple callers.\n\nfunc (g *Group) DoChan(key string, fn func() (any, error)) <-chan Result\n    DoChan is like Do but returns a channel that will receive the results when\n    they are ready.\n\nfunc (g *Group) ForgetUnshared(key string) bool\n    ForgetUnshared tells the singleflight to forget about a key if it is not\n    shared with any other goroutines. Future calls to Do for a forgotten key\n    will call the function rather than waiting for an earlier call to complete.\n    Returns whether the key was forgotten or unknown--that is, whether no other\n    goroutines are waiting for the result.\n\ntype Result struct {\n\tVal    any\n\tErr    error\n\tShared bool\n}\n    Result holds the results of Do, so they can be passed on a channel.\n\n"}, {"path": "stdlib/internal-abi.md", "category": "stdlib", "name": "stdlib/internal-abi", "content": "package abi // import \"internal/abi\"\n\n\nCONSTANTS\n\nconst (\n\n\t// R0 - R15.\n\tIntArgRegs = 16\n\n\t// F0 - F15.\n\tFloatArgRegs = 16\n\n\tEffectiveFloatRegSize = 8\n)\nconst (\n\t// Maximum number of key/elem pairs a bucket can hold.\n\tOldMapBucketCountBits = 3 // log2 of number of elements in a bucket.\n\tOldMapBucketCount     = 1 << OldMapBucketCountBits\n\n\t// Maximum key or elem size to keep inline (instead of mallocing per element).\n\t// Must fit in a uint8.\n\t// Note: fast map functions cannot handle big elems (bigger than MapMaxElemBytes).\n\tOldMapMaxKeyBytes  = 128\n\tOldMapMaxElemBytes = 128 // Must fit in a uint8.\n)\n    Map constants common to several packages\n    runtime/runtime-gdb.py:MapTypePrinter contains its own copy\n\nconst (\n\t// Number of bits in the group.slot count.\n\tSwissMapGroupSlotsBits = 3\n\n\t// Number of slots in a group.\n\tSwissMapGroupSlots = 1 << SwissMapGroupSlotsBits // 8\n\n\t// Maximum key or elem size to keep inline (instead of mallocing per element).\n\t// Must fit in a uint8.\n\tSwissMapMaxKeyBytes  = 128\n\tSwissMapMaxElemBytes = 128\n\n\t// Value of control word with all empty slots.\n\tSwissMapCtrlEmpty = bitsetLSB * uint64(ctrlEmpty)\n)\n    Map constants common to several packages\n    runtime/runtime-gdb.py:MapTypePrinter contains its own copy\n\nconst (\n\tSwissMapNeedKeyUpdate = 1 << iota\n\tSwissMapHashMightPanic\n\tSwissMapIndirectKey\n\tSwissMapIndirectElem\n)\n    Flag values\n\nconst (\n\tRF_DONE          = RF_State(iota) // body of loop has exited in a non-panic way\n\tRF_READY                          // body of loop has not exited yet, is not running  -- this is not a panic index\n\tRF_PANIC                          // body of loop is either currently running, or has panicked\n\tRF_EXHAUSTED                      // iterator function return, i.e., sequence is \"exhausted\"\n\tRF_MISSING_PANIC = 4              // body of loop panicked but iterator function defer-recovered it away\n)\n    These constants are shared between the compiler, which uses them for state\n    functions and panic indicators, and the runtime, which turns them into more\n    meaningful strings For best code generation, RF_DONE and RF_READY should be\n    0 and 1.\n\nconst (\n\t// StackNosplitBase is the base maximum number of bytes that a chain of\n\t// NOSPLIT functions can use.\n\t//\n\t// This value must be multiplied by the stack guard multiplier, so do not\n\t// use it directly. See runtime/stack.go:stackNosplit and\n\t// cmd/internal/objabi/stack.go:StackNosplit.\n\tStackNosplitBase = 800\n\n\t// After a stack split check the SP is allowed to be StackSmall bytes below\n\t// the stack guard.\n\t//\n\t// Functions that need frames <= StackSmall can perform the stack check\n\t// using a single comparison directly between the stack guard and the SP\n\t// because we ensure that StackSmall bytes of stack space are available\n\t// beyond the stack guard.\n\tStackSmall = 128\n\n\t// Functions that need frames <= StackBig can assume that neither\n\t// SP-framesize nor stackGuard-StackSmall will underflow, and thus use a\n\t// more efficient check. In order to ensure this, StackBig must be <= the\n\t// size of the unmapped space at zero.\n\tStackBig = 4096\n)\nconst (\n\tPCDATA_UnsafePoint   = 0\n\tPCDATA_StackMapIndex = 1\n\tPCDATA_InlTreeIndex  = 2\n\tPCDATA_ArgLiveIndex  = 3\n\n\tFUNCDATA_ArgsPointerMaps    = 0\n\tFUNCDATA_LocalsPointerMaps  = 1\n\tFUNCDATA_StackObjects       = 2\n\tFUNCDATA_InlTree            = 3\n\tFUNCDATA_OpenCodedDeferInfo = 4\n\tFUNCDATA_ArgInfo            = 5\n\tFUNCDATA_ArgLiveInfo        = 6\n\tFUNCDATA_WrapInfo           = 7\n)\n    IDs for PCDATA and FUNCDATA tables in Go binaries.\n\n    These must agree with ../../../runtime/funcdata.h.\n\nconst (\n\tUnsafePointSafe   = -1 // Safe for async preemption\n\tUnsafePointUnsafe = -2 // Unsafe for async preemption\n\n\t// UnsafePointRestart1(2) apply on a sequence of instructions, within\n\t// which if an async preemption happens, we should back off the PC\n\t// to the start of the sequence when resuming.\n\t// We need two so we can distinguish the start/end of the sequence\n\t// in case that two sequences are next to each other.\n\tUnsafePointRestart1 = -3\n\tUnsafePointRestart2 = -4\n\n\t// Like UnsafePointRestart1, but back to function entry if async preempted.\n\tUnsafePointRestartAtEntry = -5\n)\n    Special values for the PCDATA_UnsafePoint table.\n\nconst (\n\tTraceArgsLimit    = 10 // print no more than 10 args/components\n\tTraceArgsMaxDepth = 5  // no more than 5 layers of nesting\n\n\t// maxLen is a (conservative) upper bound of the byte stream length. For\n\t// each arg/component, it has no more than 2 bytes of data (size, offset),\n\t// and no more than one {, }, ... at each level (it cannot have both the\n\t// data and ... unless it is the last one, just be conservative). Plus 1\n\t// for _endSeq.\n\tTraceArgsMaxLen = (TraceArgsMaxDepth*3+2)*TraceArgsLimit + 1\n)\nconst (\n\tTraceArgsEndSeq         = 0xff\n\tTraceArgsStartAgg       = 0xfe\n\tTraceArgsEndAgg         = 0xfd\n\tTraceArgsDotdotdot      = 0xfc\n\tTraceArgsOffsetTooLarge = 0xfb\n\tTraceArgsSpecial        = 0xf0 // above this are operators, below this are ordinary offsets\n)\n    Populate the data. The data is a stream of bytes, which contains the offsets\n    and sizes of the non-aggregate arguments or non-aggregate fields/elements of\n    aggregate-typed arguments, along with special \"operators\". Specifically,\n      - for each non-aggregate arg/field/element, its offset from FP (1 byte)\n        and size (1 byte)\n      - special operators:\n      - 0xff - end of sequence\n      - 0xfe - print { (at the start of an aggregate-typed argument)\n      - 0xfd - print } (at the end of an aggregate-typed argument)\n      - 0xfc - print ... (more args/fields/elements)\n      - 0xfb - print _ (offset too large)\n\nconst ArgsSizeUnknown = -0x80000000\n    ArgsSizeUnknown is set in Func.argsize to mark all functions whose argument\n    size is unknown (C vararg functions, and assembly code without an explicit\n    specification). This value is generated by the compiler, assembler,\n    or linker.\n\nconst FuncTabBucketSize = 256 * MINFUNC // size of bucket in the pc->func lookup table\nconst MINFUNC = 16 // minimum size for a function\nconst MaxPtrmaskBytes = 2048\n    MaxPtrmaskBytes is the maximum length of a GC ptrmask bitmap, which holds\n    1-bit entries describing where pointers are in a given type. Above this\n    length, the GC information is recorded as a GC program, which can express\n    repetition compactly. In either form, the information is used by the runtime\n    to initialize the heap bitmap, and for large types (like 128 or more words),\n    they are roughly the same speed. GC programs are never much larger and often\n    more compact. (If large arrays are involved, they can be arbitrarily more\n    compact.)\n\n    The cutoff must be large enough that any allocation large enough to use a\n    GC program is large enough that it does not share heap bitmap bytes with\n    any other objects, allowing the GC program execution to assume an aligned\n    start and not use atomic operations. In the current runtime, this means all\n    malloc size classes larger than the cutoff must be multiples of four words.\n    On 32-bit systems that's 16 bytes, and all size classes >= 16 bytes are\n    16-byte aligned, so no real constraint. On 64-bit systems, that's 32 bytes,\n    and 32-byte alignment is guaranteed for size classes >= 256 bytes. On a\n    64-bit system, 256 bytes allocated is 32 pointers, the bits for which fit in\n    4 bytes. So MaxPtrmaskBytes must be >= 4.\n\n    We used to use 16 because the GC programs do have some constant overhead to\n    get started, and processing 128 pointers seems to be enough to amortize that\n    overhead well.\n\n    To make sure that the runtime's chansend can call typeBitsBulkBarrier,\n    we raised the limit to 2048, so that even 32-bit systems are guaranteed to\n    use bitmaps for objects up to 64 kB in size.\n\nconst ZeroValSize = 1024\n    ZeroValSize is the size in bytes of runtime.zeroVal.\n\n\nFUNCTIONS\n\nfunc CommonSize(ptrSize int) int\n    CommonSize returns sizeof(Type) for a compilation target with a given\n    ptrSize\n\nfunc Escape[T any](x T) T\n    Escape forces any pointers in x to escape to the heap.\n\nfunc EscapeNonString[T any](v T)\n    EscapeNonString forces v to be on the heap, if v contains a non-string\n    pointer.\n\n    This is used in hash/maphash.Comparable. We cannot hash pointers to local\n    variables on stack, as their addresses might change on stack growth.\n    Strings are okay as the hash depends on only the content, not the pointer.\n\n    This is essentially\n\n        if hasNonStringPointers(T) { Escape(v) }\n\n    Implemented as a compiler intrinsic.\n\nfunc EscapeToResultNonString[T any](v T) T\n    EscapeToResultNonString models a data flow edge from v to the result,\n    if v contains a non-string pointer. If v contains only string pointers,\n    it returns a copy of v, but is not modeled as a data flow edge from the\n    escape analysis's perspective.\n\n    This is used in unique.clone, to model the data flow edge on the value with\n    strings excluded, because strings are cloned (by content).\n\n    TODO: probably we should define this as a intrinsic and EscapeNonString\n    could just be \"heap = EscapeToResultNonString(v)\". This way we can model an\n    edge to the result but not necessarily heap.\n\nfunc FuncPCABI0(f interface{}) uintptr\n    FuncPCABI0 returns the entry PC of the function f, which must be a direct\n    reference of a function defined as ABI0. Otherwise it is a compile-time\n    error.\n\n    Implemented as a compile intrinsic.\n\nfunc FuncPCABIInternal(f interface{}) uintptr\n    FuncPCABIInternal returns the entry PC of the function f. If f is a direct\n    reference of a function, it must be defined as ABIInternal. Otherwise it is\n    a compile-time error. If f is not a direct reference of a defined function,\n    it assumes that f is a func value. Otherwise the behavior is undefined.\n\n    Implemented as a compile intrinsic.\n\nfunc ITabTypeOff(ptrSize int) int\n    ITabTypeOff returns the offset of ITab.Type for a compilation target with a\n    given ptrSize\n\nfunc NoEscape(p unsafe.Pointer) unsafe.Pointer\n    NoEscape hides the pointer p from escape analysis, preventing it from\n    escaping to the heap. It compiles down to nothing.\n\n    WARNING: This is very subtle to use correctly. The caller must ensure that\n    it's truly safe for p to not escape to the heap by maintaining runtime\n    pointer invariants (for example, that globals and the heap may not generally\n    point into a stack).\n\nfunc StructFieldSize(ptrSize int) int\n    StructFieldSize returns sizeof(StructField) for a compilation target with a\n    given ptrSize\n\nfunc TFlagOff(ptrSize int) int\n    TFlagOff returns the offset of Type.TFlag for a compilation target with a\n    given ptrSize\n\nfunc UncommonSize() uint64\n    UncommonSize returns sizeof(UncommonType). This currently does not depend on\n    ptrSize. This exported function is in an internal package, so it may change\n    to depend on ptrSize in the future.\n\nfunc UseInterfaceSwitchCache(arch goarch.ArchFamilyType) bool\n\nTYPES\n\ntype ArrayType struct {\n\tType\n\tElem  *Type // array element type\n\tSlice *Type // slice type\n\tLen   uintptr\n}\n    ArrayType represents a fixed array type.\n\ntype ChanDir int\n\nconst (\n\tRecvDir    ChanDir = 1 << iota         // <-chan\n\tSendDir                                // chan<-\n\tBothDir            = RecvDir | SendDir // chan\n\tInvalidDir ChanDir = 0\n)\ntype ChanType struct {\n\tType\n\tElem *Type\n\tDir  ChanDir\n}\n    ChanType represents a channel type\n\ntype EmptyInterface struct {\n\tType *Type\n\tData unsafe.Pointer\n}\n    EmptyInterface describes the layout of a \"interface{}\" or a \"any.\" These are\n    represented differently than non-empty interface, as the first word always\n    points to an abi.Type.\n\ntype FuncFlag uint8\n    A FuncFlag records bits about a function, passed to the runtime.\n\nconst (\n\t// FuncFlagTopFrame indicates a function that appears at the top of its stack.\n\t// The traceback routine stop at such a function and consider that a\n\t// successful, complete traversal of the stack.\n\t// Examples of TopFrame functions include goexit, which appears\n\t// at the top of a user goroutine stack, and mstart, which appears\n\t// at the top of a system goroutine stack.\n\tFuncFlagTopFrame FuncFlag = 1 << iota\n\n\t// FuncFlagSPWrite indicates a function that writes an arbitrary value to SP\n\t// (any write other than adding or subtracting a constant amount).\n\t// The traceback routines cannot encode such changes into the\n\t// pcsp tables, so the function traceback cannot safely unwind past\n\t// SPWrite functions. Stopping at an SPWrite function is considered\n\t// to be an incomplete unwinding of the stack. In certain contexts\n\t// (in particular garbage collector stack scans) that is a fatal error.\n\tFuncFlagSPWrite\n\n\t// FuncFlagAsm indicates that a function was implemented in assembly.\n\tFuncFlagAsm\n)\ntype FuncID uint8\n    A FuncID identifies particular functions that need to be treated specially\n    by the runtime. Note that in some situations involving plugins, there may be\n    multiple copies of a particular special runtime function.\n\nconst (\n\tFuncIDNormal FuncID = iota // not a special function\n\tFuncID_abort\n\tFuncID_asmcgocall\n\tFuncID_asyncPreempt\n\tFuncID_cgocallback\n\tFuncID_corostart\n\tFuncID_debugCallV2\n\tFuncID_gcBgMarkWorker\n\tFuncID_goexit\n\tFuncID_gogo\n\tFuncID_gopanic\n\tFuncID_handleAsyncEvent\n\tFuncID_mcall\n\tFuncID_morestack\n\tFuncID_mstart\n\tFuncID_panicwrap\n\tFuncID_rt0_go\n\tFuncID_runtime_main\n\tFuncID_runFinalizers\n\tFuncID_runCleanups\n\tFuncID_sigpanic\n\tFuncID_systemstack\n\tFuncID_systemstack_switch\n\tFuncIDWrapper // any autogenerated code (hash/eq algorithms, method wrappers, etc.)\n)\ntype FuncType struct {\n\tType\n\tInCount  uint16\n\tOutCount uint16 // top bit is set if last input parameter is ...\n}\n    FuncType represents a function type.\n\n    A *Type for each in and out parameter is stored in an array that directly\n    follows the funcType (and possibly its uncommonType). So a function type\n    with one method, one input, and one output is:\n\n        struct {\n        \tfuncType\n        \tuncommonType\n        \t[2]*rtype    // [0] is in, [1] is out\n        }\n\nfunc (t *FuncType) In(i int) *Type\n\nfunc (t *FuncType) InSlice() []*Type\n\nfunc (t *FuncType) IsVariadic() bool\n\nfunc (t *FuncType) NumIn() int\n\nfunc (t *FuncType) NumOut() int\n\nfunc (t *FuncType) Out(i int) *Type\n\nfunc (t *FuncType) OutSlice() []*Type\n\ntype ITab struct {\n\tInter *InterfaceType\n\tType  *Type\n\tHash  uint32     // copy of Type.Hash. Used for type switches.\n\tFun   [1]uintptr // variable sized. fun[0]==0 means Type does not implement Inter.\n}\n    The first word of every non-empty interface type contains an *ITab.\n    It records the underlying concrete type (Type), the interface type it is\n    implementing (Inter), and some ancillary information.\n\n    allocated in non-garbage-collected memory\n\ntype Imethod struct {\n\tName NameOff // name of method\n\tTyp  TypeOff // .(*FuncType) underneath\n}\n    Imethod represents a method on an interface type\n\ntype IntArgRegBitmap [(IntArgRegs + 7) / 8]uint8\n    IntArgRegBitmap is a bitmap large enough to hold one bit per integer\n    argument/return register.\n\nfunc (b *IntArgRegBitmap) Get(i int) bool\n    Get returns whether the i'th bit of the bitmap is set.\n\n    nosplit because it's called in extremely sensitive contexts, like on the\n    reflectcall return path.\n\nfunc (b *IntArgRegBitmap) Set(i int)\n    Set sets the i'th bit of the bitmap to 1.\n\ntype InterfaceSwitch struct {\n\tCache  *InterfaceSwitchCache\n\tNCases int\n\n\t// Array of NCases elements.\n\t// Each case must be a non-empty interface type.\n\tCases [1]*InterfaceType\n}\n\ntype InterfaceSwitchCache struct {\n\tMask    uintptr                      // mask for index. Must be a power of 2 minus 1\n\tEntries [1]InterfaceSwitchCacheEntry // Mask+1 entries total\n}\n\ntype InterfaceSwitchCacheEntry struct {\n\t// type of source value (a *Type)\n\tTyp uintptr\n\t// case # to dispatch to\n\tCase int\n\t// itab to use for resulting case variable (a *runtime.itab)\n\tItab uintptr\n}\n\ntype InterfaceType struct {\n\tType\n\tPkgPath Name      // import path\n\tMethods []Imethod // sorted by hash\n}\n\nfunc (t *InterfaceType) NumMethod() int\n    NumMethod returns the number of interface methods in the type's method set.\n\ntype Kind uint8\n    A Kind represents the specific kind of type that a Type represents. The zero\n    Kind is not a valid kind.\n\nconst (\n\tInvalid Kind = iota\n\tBool\n\tInt\n\tInt8\n\tInt16\n\tInt32\n\tInt64\n\tUint\n\tUint8\n\tUint16\n\tUint32\n\tUint64\n\tUintptr\n\tFloat32\n\tFloat64\n\tComplex64\n\tComplex128\n\tArray\n\tChan\n\tFunc\n\tInterface\n\tMap\n\tPointer\n\tSlice\n\tString\n\tStruct\n\tUnsafePointer\n)\nconst (\n\t// TODO (khr, drchase) why aren't these in TFlag?  Investigate, fix if possible.\n\tKindDirectIface Kind = 1 << 5\n\tKindMask        Kind = (1 << 5) - 1\n)\nfunc (k Kind) String() string\n    String returns the name of k.\n\ntype Method struct {\n\tName NameOff // name of method\n\tMtyp TypeOff // method type (without receiver)\n\tIfn  TextOff // fn used in interface call (one-word receiver)\n\tTfn  TextOff // fn used for normal method call\n}\n    Method on non-interface type\n\ntype Name struct {\n\tBytes *byte\n}\n\nfunc NewName(n, tag string, exported, embedded bool) Name\n\nfunc (n Name) Data(off int) *byte\n    Data does pointer arithmetic on n's Bytes, and that arithmetic is\n    asserted to be safe because the runtime made the call (other packages use\n    DataChecked)\n\nfunc (n Name) DataChecked(off int, whySafe string) *byte\n    DataChecked does pointer arithmetic on n's Bytes, and that arithmetic\n    is asserted to be safe for the reason in whySafe (which can appear in a\n    backtrace, etc.)\n\nfunc (n Name) HasTag() bool\n    HasTag returns true iff there is tag data following this name\n\nfunc (n Name) IsBlank() bool\n    IsBlank indicates whether n is \"_\".\n\nfunc (n Name) IsEmbedded() bool\n    IsEmbedded returns true iff n is embedded (an anonymous field).\n\nfunc (n Name) IsExported() bool\n    IsExported returns \"is n exported?\"\n\nfunc (n Name) Name() string\n    Name returns the tag string for n, or empty if there is none.\n\nfunc (n Name) ReadVarint(off int) (int, int)\n    ReadVarint parses a varint as encoded by encoding/binary. It returns the\n    number of encoded bytes and the encoded value.\n\nfunc (n Name) Tag() string\n    Tag returns the tag string for n, or empty if there is none.\n\ntype NameOff int32\n    NameOff is the offset to a name from moduledata.types. See resolveNameOff in\n    runtime.\n\ntype NonEmptyInterface struct {\n\tITab *ITab\n\tData unsafe.Pointer\n}\n    NonEmptyInterface describes the layout of an interface that contains any\n    methods.\n\ntype OldMapType struct {\n\tType\n\tKey    *Type\n\tElem   *Type\n\tBucket *Type // internal type representing a hash bucket\n\t// function for hashing keys (ptr to key, seed) -> hash\n\tHasher     func(unsafe.Pointer, uintptr) uintptr\n\tKeySize    uint8  // size of key slot\n\tValueSize  uint8  // size of elem slot\n\tBucketSize uint16 // size of bucket\n\tFlags      uint32\n}\n\nfunc (mt *OldMapType) HashMightPanic() bool\n\nfunc (mt *OldMapType) IndirectElem() bool\n\nfunc (mt *OldMapType) IndirectKey() bool\n    Note: flag values must match those used in the TMAP case in\n    ../cmd/compile/internal/reflectdata/reflect.go:writeType.\n\nfunc (mt *OldMapType) NeedKeyUpdate() bool\n\nfunc (mt *OldMapType) ReflexiveKey() bool\n\ntype PtrType struct {\n\tType\n\tElem *Type // pointer element (pointed at) type\n}\n\ntype RF_State int\n\ntype RegArgs struct {\n\t// Values in these slots should be precisely the bit-by-bit\n\t// representation of how they would appear in a register.\n\t//\n\t// This means that on big endian arches, integer values should\n\t// be in the top bits of the slot. Floats are usually just\n\t// directly represented, but some architectures treat narrow\n\t// width floating point values specially (e.g. they're promoted\n\t// first, or they need to be NaN-boxed).\n\tInts   [IntArgRegs]uintptr  // untyped integer registers\n\tFloats [FloatArgRegs]uint64 // untyped float registers\n\n\t// Ptrs is a space that duplicates Ints but with pointer type,\n\t// used to make pointers passed or returned  in registers\n\t// visible to the GC by making the type unsafe.Pointer.\n\tPtrs [IntArgRegs]unsafe.Pointer\n\n\t// ReturnIsPtr is a bitmap that indicates which registers\n\t// contain or will contain pointers on the return path from\n\t// a reflectcall. The i'th bit indicates whether the i'th\n\t// register contains or will contain a valid Go pointer.\n\tReturnIsPtr IntArgRegBitmap\n}\n    RegArgs is a struct that has space for each argument and return value\n    register on the current architecture.\n\n    Assembly code knows the layout of the first two fields of RegArgs.\n\n    RegArgs also contains additional space to hold pointers when it may not be\n    safe to keep them only in the integer register space otherwise.\n\nfunc (r *RegArgs) Dump()\n\nfunc (r *RegArgs) IntRegArgAddr(reg int, argSize uintptr) unsafe.Pointer\n    IntRegArgAddr returns a pointer inside of r.Ints[reg] that is appropriately\n    offset for an argument of size argSize.\n\n    argSize must be non-zero, fit in a register, and a power-of-two.\n\n    This method is a helper for dealing with the endianness of different CPU\n    architectures, since sub-word-sized arguments in big endian architectures\n    need to be \"aligned\" to the upper edge of the register to be interpreted by\n    the CPU correctly.\n\ntype SliceType struct {\n\tType\n\tElem *Type // slice element type\n}\n\ntype StructField struct {\n\tName   Name    // name is always non-empty\n\tTyp    *Type   // type of field\n\tOffset uintptr // byte offset of field\n}\n\nfunc (f *StructField) Embedded() bool\n\ntype StructType struct {\n\tType\n\tPkgPath Name\n\tFields  []StructField\n}\n\ntype SwissMapType struct {\n\tType\n\tKey   *Type\n\tElem  *Type\n\tGroup *Type // internal type representing a slot group\n\t// function for hashing keys (ptr to key, seed) -> hash\n\tHasher    func(unsafe.Pointer, uintptr) uintptr\n\tGroupSize uintptr // == Group.Size_\n\tSlotSize  uintptr // size of key/elem slot\n\tElemOff   uintptr // offset of elem in key/elem slot\n\tFlags     uint32\n}\n\nfunc (mt *SwissMapType) HashMightPanic() bool\n\nfunc (mt *SwissMapType) IndirectElem() bool\n\nfunc (mt *SwissMapType) IndirectKey() bool\n\nfunc (mt *SwissMapType) NeedKeyUpdate() bool\n\ntype TFlag uint8\n    TFlag is used by a Type to signal what extra type information is available\n    in the memory directly following the Type value.\n\nconst (\n\t// TFlagUncommon means that there is a data with a type, UncommonType,\n\t// just beyond the shared-per-type common data.  That is, the data\n\t// for struct types will store their UncommonType at one offset, the\n\t// data for interface types will store their UncommonType at a different\n\t// offset.  UncommonType is always accessed via a pointer that is computed\n\t// using trust-us-we-are-the-implementors pointer arithmetic.\n\t//\n\t// For example, if t.Kind() == Struct and t.tflag&TFlagUncommon != 0,\n\t// then t has UncommonType data and it can be accessed as:\n\t//\n\t//\ttype structTypeUncommon struct {\n\t//\t\tstructType\n\t//\t\tu UncommonType\n\t//\t}\n\t//\tu := &(*structTypeUncommon)(unsafe.Pointer(t)).u\n\tTFlagUncommon TFlag = 1 << 0\n\n\t// TFlagExtraStar means the name in the str field has an\n\t// extraneous '*' prefix. This is because for most types T in\n\t// a program, the type *T also exists and reusing the str data\n\t// saves binary size.\n\tTFlagExtraStar TFlag = 1 << 1\n\n\t// TFlagNamed means the type has a name.\n\tTFlagNamed TFlag = 1 << 2\n\n\t// TFlagRegularMemory means that equal and hash functions can treat\n\t// this type as a single region of t.size bytes.\n\tTFlagRegularMemory TFlag = 1 << 3\n\n\t// TFlagGCMaskOnDemand means that the GC pointer bitmask will be\n\t// computed on demand at runtime instead of being precomputed at\n\t// compile time. If this flag is set, the GCData field effectively\n\t// has type **byte instead of *byte. The runtime will store a\n\t// pointer to the GC pointer bitmask in *GCData.\n\tTFlagGCMaskOnDemand TFlag = 1 << 4\n)\ntype TextOff int32\n    TextOff is an offset from the top of a text section. See (rtype).textOff in\n    runtime.\n\ntype Type struct {\n\tSize_       uintptr\n\tPtrBytes    uintptr // number of (prefix) bytes in the type that can contain pointers\n\tHash        uint32  // hash of type; avoids computation in hash tables\n\tTFlag       TFlag   // extra type information flags\n\tAlign_      uint8   // alignment of variable with this type\n\tFieldAlign_ uint8   // alignment of struct field with this type\n\tKind_       Kind    // enumeration for C\n\t// function for comparing objects of this type\n\t// (ptr to object A, ptr to object B) -> ==?\n\tEqual func(unsafe.Pointer, unsafe.Pointer) bool\n\t// GCData stores the GC type data for the garbage collector.\n\t// Normally, GCData points to a bitmask that describes the\n\t// ptr/nonptr fields of the type. The bitmask will have at\n\t// least PtrBytes/ptrSize bits.\n\t// If the TFlagGCMaskOnDemand bit is set, GCData is instead a\n\t// **byte and the pointer to the bitmask is one dereference away.\n\t// The runtime will build the bitmask if needed.\n\t// (See runtime/type.go:getGCMask.)\n\t// Note: multiple types may have the same value of GCData,\n\t// including when TFlagGCMaskOnDemand is set. The types will, of course,\n\t// have the same pointer layout (but not necessarily the same size).\n\tGCData    *byte\n\tStr       NameOff // string form\n\tPtrToThis TypeOff // type for pointer to this type, may be zero\n}\n    Type is the runtime representation of a Go type.\n\n    Be careful about accessing this type at build time, as the version of this\n    type in the compiler/linker may not have the same layout as the version in\n    the target binary, due to pointer width differences and any experiments.\n    Use cmd/compile/internal/rttype or the functions in compiletype.go to access\n    this type instead. (TODO: this admonition applies to every type in this\n    package. Put it in some shared location?)\n\nfunc TypeFor[T any]() *Type\n    TypeFor returns the abi.Type for a type parameter.\n\nfunc TypeOf(a any) *Type\n    TypeOf returns the abi.Type of some value.\n\nfunc (t *Type) Align() int\n    Align returns the alignment of data with type t.\n\nfunc (t *Type) ArrayType() *ArrayType\n    ArrayType returns t cast to a *ArrayType, or nil if its tag does not match.\n\nfunc (t *Type) ChanDir() ChanDir\n    ChanDir returns the direction of t if t is a channel type, otherwise\n    InvalidDir (0).\n\nfunc (t *Type) Common() *Type\n\nfunc (t *Type) Elem() *Type\n    Elem returns the element type for t if t is an array, channel, map, pointer,\n    or slice, otherwise nil.\n\nfunc (t *Type) ExportedMethods() []Method\n\nfunc (t *Type) FieldAlign() int\n\nfunc (t *Type) FuncType() *FuncType\n    FuncType returns t cast to a *FuncType, or nil if its tag does not match.\n\nfunc (t *Type) GcSlice(begin, end uintptr) []byte\n\nfunc (t *Type) HasName() bool\n\nfunc (t *Type) IfaceIndir() bool\n    IfaceIndir reports whether t is stored indirectly in an interface value.\n\nfunc (t *Type) InterfaceType() *InterfaceType\n    InterfaceType returns t cast to a *InterfaceType, or nil if its tag does not\n    match.\n\nfunc (t *Type) IsDirectIface() bool\n    isDirectIface reports whether t is stored directly in an interface value.\n\nfunc (t *Type) Key() *Type\n\nfunc (t *Type) Kind() Kind\n\nfunc (t *Type) Len() int\n    Len returns the length of t if t is an array type, otherwise 0\n\nfunc (t *Type) MapType() *mapType\n    MapType returns t cast to a *OldMapType or *SwissMapType, or nil if its tag\n    does not match.\n\nfunc (t *Type) NumMethod() int\n\nfunc (t *Type) Pointers() bool\n    Pointers reports whether t contains pointers.\n\nfunc (t *Type) Size() uintptr\n    Size returns the size of data with type t.\n\nfunc (t *Type) StructType() *StructType\n    StructType returns t cast to a *StructType, or nil if its tag does not\n    match.\n\nfunc (t *Type) Uncommon() *UncommonType\n    Uncommon returns a pointer to T's \"uncommon\" data if there is any, otherwise\n    nil\n\ntype TypeAssert struct {\n\tCache   *TypeAssertCache\n\tInter   *InterfaceType\n\tCanFail bool\n}\n\ntype TypeAssertCache struct {\n\tMask    uintptr\n\tEntries [1]TypeAssertCacheEntry\n}\n\ntype TypeAssertCacheEntry struct {\n\t// type of source value (a *runtime._type)\n\tTyp uintptr\n\t// itab to use for result (a *runtime.itab)\n\t// nil if CanFail is set and conversion would fail.\n\tItab uintptr\n}\n\ntype TypeOff int32\n    TypeOff is the offset to a type from moduledata.types. See resolveTypeOff in\n    runtime.\n\ntype UncommonType struct {\n\tPkgPath NameOff // import path; empty for built-in types like int, string\n\tMcount  uint16  // number of methods\n\tXcount  uint16  // number of exported methods\n\tMoff    uint32  // offset from this uncommontype to [mcount]Method\n\t// Has unexported fields.\n}\n    UncommonType is present only for defined types or types with methods\n    (if T is a defined type, the uncommonTypes for T and *T have methods).\n    Using a pointer to this struct reduces the overall size required to describe\n    a non-defined type with no methods.\n\nfunc (t *UncommonType) ExportedMethods() []Method\n\nfunc (t *UncommonType) Methods() []Method\n\n"}, {"path": "stdlib/internal-coverage-decodecounter.md", "category": "stdlib", "name": "stdlib/internal-coverage-decodecounter", "content": "package decodecounter // import \"internal/coverage/decodecounter\"\n\n\nTYPES\n\ntype CounterDataReader struct {\n\t// Has unexported fields.\n}\n\nfunc NewCounterDataReader(fn string, rs io.ReadSeeker) (*CounterDataReader, error)\n\nfunc (cdr *CounterDataReader) BeginNextSegment() (bool, error)\n    BeginNextSegment sets up the reader to read the next segment, returning TRUE\n    if we do have another segment to read, or FALSE if we're done with all the\n    segments (also an error if something went wrong).\n\nfunc (cdr *CounterDataReader) Goarch() string\n    Goarch returns the GOARCH setting in effect for the \"-cover\" binary that\n    produced this counter data file. The GOARCH value may be empty in the case\n    where the counter data file was produced from a merge in which more than one\n    GOARCH value was present.\n\nfunc (cdr *CounterDataReader) Goos() string\n    Goos returns the GOOS setting in effect for the \"-cover\" binary that\n    produced this counter data file. The GOOS value may be empty in the case\n    where the counter data file was produced from a merge in which more than one\n    GOOS value was present.\n\nfunc (cdr *CounterDataReader) NextFunc(p *FuncPayload) (bool, error)\n    NextFunc reads data for the next function in this current segment into \"p\",\n    returning TRUE if the read was successful or FALSE if we've read all the\n    functions already (also an error if something went wrong with the read or we\n    hit a premature EOF).\n\nfunc (cdr *CounterDataReader) NumFunctionsInSegment() uint32\n    NumFunctionsInSegment returns the number of live functions in the currently\n    selected segment.\n\nfunc (cdr *CounterDataReader) NumSegments() uint32\n    NumSegments returns the number of execution segments in the file.\n\nfunc (cdr *CounterDataReader) OsArgs() []string\n    OsArgs returns the program arguments (saved from os.Args during the run of\n    the instrumented binary) read from the counter data file. Not all coverage\n    data files will have os.Args values; for example, if a data file is produced\n    by merging coverage data from two distinct runs, no os args will be\n    available (an empty list is returned).\n\ntype FuncPayload struct {\n\tPkgIdx   uint32\n\tFuncIdx  uint32\n\tCounters []uint32\n}\n    FuncPayload encapsulates the counter data payload for a single function as\n    read from a counter data file.\n\n"}, {"path": "stdlib/vendor-golang.org-x-text-secure-bidirule.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-text-secure-bidirule", "content": ""}, {"path": "stdlib/crypto-internal-fips140.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140", "content": "package fips140 // import \"crypto/internal/fips140\"\n\n\nVARIABLES\n\nvar Enabled bool\n\nFUNCTIONS\n\nfunc CAST(name string, f func() error)\n    CAST runs the named Cryptographic Algorithm Self-Test (if operated in FIPS\n    mode) and aborts the program (stopping the module input/output and entering\n    the \"error state\") if the self-test fails.\n\n    CASTs are mandatory self-checks that must be performed by FIPS 140-3 modules\n    before the algorithm is used. See Implementation Guidance 10.3.A.\n\n    The name must not contain commas, colons, hashes, or equal signs.\n\n    If a package p calls CAST from its init function, an import of p should also\n    be added to crypto/internal/fips140test. If a package p calls CAST on the\n    first use of the algorithm, an invocation of that algorithm should be added\n    to fipstest.TestConditionals.\n\nfunc Name() string\nfunc PCT(name string, f func() error)\n    PCT runs the named Pairwise Consistency Test (if operated in FIPS mode) and\n    aborts the program (stopping the module input/output and entering the \"error\n    state\") if the test fails.\n\n    PCTs are mandatory for every generated (but not imported) key pair,\n    including ephemeral keys (which effectively doubles the cost of key\n    establishment). See Implementation Guidance 10.3.A Additional Comment 1.\n\n    The name must not contain commas, colons, hashes, or equal signs.\n\n    If a package p calls PCT during key generation, an invocation of that\n    function should be added to fipstest.TestConditionals.\n\nfunc RecordApproved()\n    RecordApproved is an internal function that records the use of an approved\n    service. It does not override RecordNonApproved calls in the same span.\n\n    It should be called by exposed functions that perform a whole cryptographic\n    alrgorithm (e.g. by Sum, not by New, unless a cryptographic Instantiate\n    algorithm is performed) and should be called after any checks that may cause\n    the function to error out or panic.\n\nfunc RecordNonApproved()\n    RecordNonApproved is an internal function that records the use of a\n    non-approved service. It overrides any RecordApproved calls in the same\n    span.\n\nfunc ResetServiceIndicator()\n    ResetServiceIndicator clears the service indicator for the running\n    goroutine.\n\nfunc ServiceIndicator() bool\n    ServiceIndicator returns true if and only if all services invoked by this\n    goroutine since the last ResetServiceIndicator call are approved.\n\n    If ResetServiceIndicator was not called before by this goroutine, its return\n    value is undefined.\n\nfunc Supported() error\n    Supported returns an error if FIPS 140-3 mode can't be enabled.\n\nfunc Version() string\n    Version returns the formal version (such as \"v1.0.0\") if building against a\n    frozen module with GOFIPS140. Otherwise, it returns \"latest\".\n\n"}, {"path": "stdlib/vendor-golang.org-x-crypto-internal-alias.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-crypto-internal-alias", "content": ""}, {"path": "stdlib/unsafe.md", "category": "stdlib", "name": "stdlib/unsafe", "content": "package unsafe // import \"unsafe\"\n\nPackage unsafe contains operations that step around the type safety of Go\nprograms.\n\nPackages that import unsafe may be non-portable and are not protected by the Go\n1 compatibility guidelines.\n\nFUNCTIONS\n\nfunc Alignof(x ArbitraryType) uintptr\n    Alignof takes an expression x of any type and returns the required\n    alignment of a hypothetical variable v as if v was declared via var v = x.\n    It is the largest value m such that the address of v is always zero mod m.\n    It is the same as the value returned by reflect.TypeOf(x).Align().\n    As a special case, if a variable s is of struct type and f is a field\n    within that struct, then Alignof(s.f) will return the required alignment\n    of a field of that type within a struct. This case is the same as the value\n    returned by reflect.TypeOf(s.f).FieldAlign(). The return value of Alignof\n    is a Go constant if the type of the argument does not have variable size.\n    (See the description of Sizeof for a definition of variable sized types.)\n\nfunc Offsetof(x ArbitraryType) uintptr\n    Offsetof returns the offset within the struct of the field represented by x,\n    which must be of the form structValue.field. In other words, it returns the\n    number of bytes between the start of the struct and the start of the field.\n    The return value of Offsetof is a Go constant if the type of the argument x\n    does not have variable size. (See the description of Sizeof for a definition\n    of variable sized types.)\n\nfunc Sizeof(x ArbitraryType) uintptr\n    Sizeof takes an expression x of any type and returns the size in bytes of a\n    hypothetical variable v as if v was declared via var v = x. The size does\n    not include any memory possibly referenced by x. For instance, if x is a\n    slice, Sizeof returns the size of the slice descriptor, not the size of the\n    memory referenced by the slice; if x is an interface, Sizeof returns the\n    size of the interface value itself, not the size of the value stored in the\n    interface. For a struct, the size includes any padding introduced by field\n    alignment. The return value of Sizeof is a Go constant if the type of the\n    argument x does not have variable size. (A type has variable size if it is a\n    type parameter or if it is an array or struct type with elements of variable\n    size).\n\nfunc String(ptr *byte, len IntegerType) string\n    String returns a string value whose underlying bytes start at ptr and whose\n    length is len.\n\n    The len argument must be of integer type or an untyped constant. A constant\n    len argument must be non-negative and representable by a value of type int;\n    if it is an untyped constant it is given type int. At run time, if len is\n    negative, or if ptr is nil and len is not zero, a run-time panic occurs.\n\n    Since Go strings are immutable, the bytes passed to String must not be\n    modified as long as the returned string value exists.\n\nfunc StringData(str string) *byte\n    StringData returns a pointer to the underlying bytes of str. For an empty\n    string the return value is unspecified, and may be nil.\n\n    Since Go strings are immutable, the bytes returned by StringData must not be\n    modified.\n\n\nTYPES\n\ntype ArbitraryType int\n    ArbitraryType is here for the purposes of documentation only and is not\n    actually part of the unsafe package. It represents the type of an arbitrary\n    Go expression.\n\nfunc Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType\n    The function Slice returns a slice whose underlying array starts at ptr and\n    whose length and capacity are len. Slice(ptr, len) is equivalent to\n\n        (*[len]ArbitraryType)(unsafe.Pointer(ptr))[:]\n\n    except that, as a special case, if ptr is nil and len is zero, Slice returns\n    nil.\n\n    The len argument must be of integer type or an untyped constant. A constant\n    len argument must be non-negative and representable by a value of type int;\n    if it is an untyped constant it is given type int. At run time, if len is\n    negative, or if ptr is nil and len is not zero, a run-time panic occurs.\n\nfunc SliceData(slice []ArbitraryType) *ArbitraryType\n    SliceData returns a pointer to the underlying array of the argument slice.\n      - If cap(slice) > 0, SliceData returns &slice[:1][0].\n      - If slice == nil, SliceData returns nil.\n      - Otherwise, SliceData returns a non-nil pointer to an unspecified memory\n        address.\n\ntype IntegerType int\n    IntegerType is here for the purposes of documentation only and is not\n    actually part of the unsafe package. It represents any arbitrary integer\n    type.\n\ntype Pointer *ArbitraryType\n    Pointer represents a pointer to an arbitrary type. There are four special\n    operations available for type Pointer that are not available for other\n    types:\n      - A pointer value of any type can be converted to a Pointer.\n      - A Pointer can be converted to a pointer value of any type.\n      - A uintptr can be converted to a Pointer.\n      - A Pointer can be converted to a uintptr.\n\n    Pointer therefore allows a program to defeat the type system and read and\n    write arbitrary memory. It should be used with extreme care.\n\n    The following patterns involving Pointer are valid. Code not using these\n    patterns is likely to be invalid today or to become invalid in the future.\n    Even the valid patterns below come with important caveats.\n\n    Running \"go vet\" can help find uses of Pointer that do not conform to these\n    patterns, but silence from \"go vet\" is not a guarantee that the code is\n    valid.\n\n    (1) Conversion of a *T1 to Pointer to *T2.\n\n    Provided that T2 is no larger than T1 and that the two share an equivalent\n    memory layout, this conversion allows reinterpreting data of one type as\n    data of another type. An example is the implementation of math.Float64bits:\n\n        func Float64bits(f float64) uint64 {\n        \treturn *(*uint64)(unsafe.Pointer(&f))\n        }\n\n    (2) Conversion of a Pointer to a uintptr (but not back to Pointer).\n\n    Converting a Pointer to a uintptr produces the memory address of the value\n    pointed at, as an integer. The usual use for such a uintptr is to print it.\n\n    Conversion of a uintptr back to Pointer is not valid in general.\n\n    A uintptr is an integer, not a reference. Converting a Pointer to a uintptr\n    creates an integer value with no pointer semantics. Even if a uintptr holds\n    the address of some object, the garbage collector will not update that\n    uintptr's value if the object moves, nor will that uintptr keep the object\n    from being reclaimed.\n\n    The remaining patterns enumerate the only valid conversions from uintptr to\n    Pointer.\n\n    (3) Conversion of a Pointer to a uintptr and back, with arithmetic.\n\n    If p points into an allocated object, it can be advanced through the object\n    by conversion to uintptr, addition of an offset, and conversion back to\n    Pointer.\n\n        p = unsafe.Pointer(uintptr(p) + offset)\n\n    The most common use of this pattern is to access fields in a struct or\n    elements of an array:\n\n        // equivalent to f := unsafe.Pointer(&s.f)\n        f := unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.f))\n\n        // equivalent to e := unsafe.Pointer(&x[i])\n        e := unsafe.Pointer(uintptr(unsafe.Pointer(&x[0])) + i*unsafe.Sizeof(x[0]))\n\n    It is valid both to add and to subtract offsets from a pointer in this way.\n    It is also valid to use &^ to round pointers, usually for alignment. In all\n    cases, the result must continue to point into the original allocated object.\n\n    Unlike in C, it is not valid to advance a pointer just beyond the end of its\n    original allocation:\n\n        // INVALID: end points outside allocated space.\n        var s thing\n        end = unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + unsafe.Sizeof(s))\n\n        // INVALID: end points outside allocated space.\n        b := make([]byte, n)\n        end = unsafe.Pointer(uintptr(unsafe.Pointer(&b[0])) + uintptr(n))\n\n    Note that both conversions must appear in the same expression, with only the\n    intervening arithmetic between them:\n\n        // INVALID: uintptr cannot be stored in variable\n        // before conversion back to Pointer.\n        u := uintptr(p)\n        p = unsafe.Pointer(u + offset)\n\n    Note that the pointer must point into an allocated object, so it may not be\n    nil.\n\n        // INVALID: conversion of nil pointer\n        u := unsafe.Pointer(nil)\n        p := unsafe.Pointer(uintptr(u) + offset)\n\n    (4) Conversion of a Pointer to a uintptr when calling functions like\n    syscall.Syscall.\n\n    The Syscall functions in package syscall pass their uintptr arguments\n    directly to the operating system, which then may, depending on the details\n    of the call, reinterpret some of them as pointers. That is, the system call\n    implementation is implicitly converting certain arguments back from uintptr\n    to pointer.\n\n    If a pointer argument must be converted to uintptr for use as an argument,\n    that conversion must appear in the call expression itself:\n\n        syscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n))\n\n    The compiler handles a Pointer converted to a uintptr in the argument\n    list of a call to a function implemented in assembly by arranging that the\n    referenced allocated object, if any, is retained and not moved until the\n    call completes, even though from the types alone it would appear that the\n    object is no longer needed during the call.\n\n    For the compiler to recognize this pattern, the conversion must appear in\n    the argument list:\n\n        // INVALID: uintptr cannot be stored in variable\n        // before implicit conversion back to Pointer during system call.\n        u := uintptr(unsafe.Pointer(p))\n        syscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n))\n\n    (5) Conversion of the result of reflect.Value.Pointer or\n    reflect.Value.UnsafeAddr from uintptr to Pointer.\n\n    Package reflect's Value methods named Pointer and UnsafeAddr return type\n    uintptr instead of unsafe.Pointer to keep callers from changing the result\n    to an arbitrary type without first importing \"unsafe\". However, this means\n    that the result is fragile and must be converted to Pointer immediately\n    after making the call, in the same expression:\n\n        p := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))\n\n    As in the cases above, it is invalid to store the result before the\n    conversion:\n\n        // INVALID: uintptr cannot be stored in variable\n        // before conversion back to Pointer.\n        u := reflect.ValueOf(new(int)).Pointer()\n        p := (*int)(unsafe.Pointer(u))\n\n    (6) Conversion of a reflect.SliceHeader or reflect.StringHeader Data field\n    to or from Pointer.\n\n    As in the previous case, the reflect data structures SliceHeader and\n    StringHeader declare the field Data as a uintptr to keep callers from\n    changing the result to an arbitrary type without first importing \"unsafe\".\n    However, this means that SliceHeader and StringHeader are only valid when\n    interpreting the content of an actual slice or string value.\n\n        var s string\n        hdr := (*reflect.StringHeader)(unsafe.Pointer(&s)) // case 1\n        hdr.Data = uintptr(unsafe.Pointer(p))              // case 6 (this case)\n        hdr.Len = n\n\n    In this usage hdr.Data is really an alternate way to refer to the underlying\n    pointer in the string header, not a uintptr variable itself.\n\n    In general, reflect.SliceHeader and reflect.StringHeader should be used only\n    as *reflect.SliceHeader and *reflect.StringHeader pointing at actual slices\n    or strings, never as plain structs. A program should not declare or allocate\n    variables of these struct types.\n\n        // INVALID: a directly-declared header will not hold Data as a reference.\n        var hdr reflect.StringHeader\n        hdr.Data = uintptr(unsafe.Pointer(p))\n        hdr.Len = n\n        s := *(*string)(unsafe.Pointer(&hdr)) // p possibly already lost\n\nfunc Add(ptr Pointer, len IntegerType) Pointer\n    The function Add adds len to ptr and returns the updated pointer\n    Pointer(uintptr(ptr) + uintptr(len)). The len argument must be of integer\n    type or an untyped constant. A constant len argument must be representable\n    by a value of type int; if it is an untyped constant it is given type int.\n    The rules for valid uses of Pointer still apply.\n\n"}, {"path": "stdlib/go-internal-gccgoimporter.md", "category": "stdlib", "name": "stdlib/go-internal-gccgoimporter", "content": "package gccgoimporter // import \"go/internal/gccgoimporter\"\n\nPackage gccgoimporter implements Import for gccgo-generated object files.\n\nTYPES\n\ntype GccgoInstallation struct {\n\t// Version of gcc (e.g. 4.8.0).\n\tGccVersion string\n\n\t// Target triple (e.g. x86_64-unknown-linux-gnu).\n\tTargetTriple string\n\n\t// Built-in library paths used by this installation.\n\tLibPaths []string\n}\n    Information about a specific installation of gccgo.\n\nfunc (inst *GccgoInstallation) GetImporter(incpaths []string, initmap map[*types.Package]InitData) Importer\n    Return an importer that searches incpaths followed by the gcc installation's\n    built-in search paths and the current directory.\n\nfunc (inst *GccgoInstallation) InitFromDriver(gccgoPath string, args ...string) (err error)\n    Ask the driver at the given path for information for this GccgoInstallation.\n    The given arguments are passed directly to the call of the driver.\n\nfunc (inst *GccgoInstallation) SearchPaths() (paths []string)\n    Return the list of export search paths for this GccgoInstallation.\n\ntype Importer func(imports map[string]*types.Package, path, srcDir string, lookup func(string) (io.ReadCloser, error)) (*types.Package, error)\n    An Importer resolves import paths to Packages. The imports map records\n    packages already known, indexed by package path. An importer must determine\n    the canonical package path and check imports to see if it is already present\n    in the map. If so, the Importer can return the map entry. Otherwise, the\n    importer must load the package data for the given path into a new *Package,\n    record it in imports map, and return the package.\n\nfunc GetImporter(searchpaths []string, initmap map[*types.Package]InitData) Importer\n\ntype InitData struct {\n\t// Initialization priority of this package relative to other packages.\n\t// This is based on the maximum depth of the package's dependency graph;\n\t// it is guaranteed to be greater than that of its dependencies.\n\tPriority int\n\n\t// The list of packages which this package depends on to be initialized,\n\t// including itself if needed. This is the subset of the transitive closure of\n\t// the package's dependencies that need initialization.\n\tInits []PackageInit\n}\n    The gccgo-specific init data for a package.\n\ntype PackageInit struct {\n\tName     string // short package name\n\tInitFunc string // name of init function\n\tPriority int    // priority of init function, see InitData.Priority\n}\n    A PackageInit describes an imported package that needs initialization.\n\n"}, {"path": "stdlib/debug-plan9obj.md", "category": "stdlib", "name": "stdlib/debug-plan9obj", "content": "package plan9obj // import \"debug/plan9obj\"\n\nPackage plan9obj implements access to Plan 9 a.out object files.\n\n# Security\n\nThis package is not designed to be hardened against adversarial inputs,\nand is outside the scope of https://go.dev/security/policy. In particular,\nonly basic validation is done when parsing object files. As such, care should\nbe taken when parsing untrusted inputs, as parsing malformed files may consume\nsignificant resources, or cause panics.\n\nCONSTANTS\n\nconst (\n\tMagic64 = 0x8000 // 64-bit expanded header\n\n\tMagic386   = (4*11+0)*11 + 7\n\tMagicAMD64 = (4*26+0)*26 + 7 + Magic64\n\tMagicARM   = (4*20+0)*20 + 7\n)\n\nVARIABLES\n\nvar ErrNoSymbols = errors.New(\"no symbol section\")\n    ErrNoSymbols is returned by File.Symbols if there is no such section in the\n    File.\n\n\nTYPES\n\ntype File struct {\n\tFileHeader\n\tSections []*Section\n\t// Has unexported fields.\n}\n    A File represents an open Plan 9 a.out file.\n\nfunc NewFile(r io.ReaderAt) (*File, error)\n    NewFile creates a new File for accessing a Plan 9 binary in an underlying\n    reader. The Plan 9 binary is expected to start at position 0 in the\n    ReaderAt.\n\nfunc Open(name string) (*File, error)\n    Open opens the named file using os.Open and prepares it for use as a Plan 9\n    a.out binary.\n\nfunc (f *File) Close() error\n    Close closes the File. If the File was created using NewFile directly\n    instead of Open, Close has no effect.\n\nfunc (f *File) Section(name string) *Section\n    Section returns a section with the given name, or nil if no such section\n    exists.\n\nfunc (f *File) Symbols() ([]Sym, error)\n    Symbols returns the symbol table for f.\n\ntype FileHeader struct {\n\tMagic       uint32\n\tBss         uint32\n\tEntry       uint64\n\tPtrSize     int\n\tLoadAddress uint64\n\tHdrSize     uint64\n}\n    A FileHeader represents a Plan 9 a.out file header.\n\ntype Section struct {\n\tSectionHeader\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\t// Has unexported fields.\n}\n    A Section represents a single section in a Plan 9 a.out file.\n\nfunc (s *Section) Data() ([]byte, error)\n    Data reads and returns the contents of the Plan 9 a.out section.\n\nfunc (s *Section) Open() io.ReadSeeker\n    Open returns a new ReadSeeker reading the Plan 9 a.out section.\n\ntype SectionHeader struct {\n\tName   string\n\tSize   uint32\n\tOffset uint32\n}\n    A SectionHeader represents a single Plan 9 a.out section header. This\n    structure doesn't exist on-disk, but eases navigation through the object\n    file.\n\ntype Sym struct {\n\tValue uint64\n\tType  rune\n\tName  string\n}\n    A Symbol represents an entry in a Plan 9 a.out symbol table section.\n\n"}, {"path": "stdlib/encoding-base32.md", "category": "stdlib", "name": "stdlib/encoding-base32", "content": "package base32 // import \"encoding/base32\"\n\nPackage base32 implements base32 encoding as specified by RFC 4648.\n\nCONSTANTS\n\nconst (\n\tStdPadding rune = '=' // Standard padding character\n\tNoPadding  rune = -1  // No padding\n)\n\nVARIABLES\n\nvar HexEncoding = NewEncoding(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\")\n    HexEncoding is the \u201cExtended Hex Alphabet\u201d defined in RFC 4648. It is\n    typically used in DNS.\n\nvar StdEncoding = NewEncoding(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\")\n    StdEncoding is the standard base32 encoding, as defined in RFC 4648.\n\n\nFUNCTIONS\n\nfunc NewDecoder(enc *Encoding, r io.Reader) io.Reader\n    NewDecoder constructs a new base32 stream decoder.\n\nfunc NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser\n    NewEncoder returns a new base32 stream encoder. Data written to the returned\n    writer will be encoded using enc and then written to w. Base32 encodings\n    operate in 5-byte blocks; when finished writing, the caller must Close the\n    returned encoder to flush any partially written blocks.\n\n\nTYPES\n\ntype CorruptInputError int64\n\nfunc (e CorruptInputError) Error() string\n\ntype Encoding struct {\n\t// Has unexported fields.\n}\n    An Encoding is a radix 32 encoding/decoding scheme, defined by a\n    32-character alphabet. The most common is the \"base32\" encoding introduced\n    for SASL GSSAPI and standardized in RFC 4648. The alternate \"base32hex\"\n    encoding is used in DNSSEC.\n\nfunc NewEncoding(encoder string) *Encoding\n    NewEncoding returns a new padded Encoding defined by the given alphabet,\n    which must be a 32-byte string that contains unique byte values and does\n    not contain the padding character or CR / LF ('\\r', '\\n'). The alphabet\n    is treated as a sequence of byte values without any special treatment for\n    multi-byte UTF-8. The resulting Encoding uses the default padding character\n    ('='), which may be changed or disabled via Encoding.WithPadding.\n\nfunc (enc *Encoding) AppendDecode(dst, src []byte) ([]byte, error)\n    AppendDecode appends the base32 decoded src to dst and returns the extended\n    buffer. If the input is malformed, it returns the partially decoded src and\n    an error. New line characters (\\r and \\n) are ignored.\n\nfunc (enc *Encoding) AppendEncode(dst, src []byte) []byte\n    AppendEncode appends the base32 encoded src to dst and returns the extended\n    buffer.\n\nfunc (enc *Encoding) Decode(dst, src []byte) (n int, err error)\n    Decode decodes src using the encoding enc. It writes at most\n    Encoding.DecodedLen(len(src)) bytes to dst and returns the number of bytes\n    written. The caller must ensure that dst is large enough to hold all the\n    decoded data. If src contains invalid base32 data, it will return the number\n    of bytes successfully written and CorruptInputError. Newline characters (\\r\n    and \\n) are ignored.\n\nfunc (enc *Encoding) DecodeString(s string) ([]byte, error)\n    DecodeString returns the bytes represented by the base32 string s.\n    If the input is malformed, it returns the partially decoded data and\n    CorruptInputError. New line characters (\\r and \\n) are ignored.\n\nfunc (enc *Encoding) DecodedLen(n int) int\n    DecodedLen returns the maximum length in bytes of the decoded data\n    corresponding to n bytes of base32-encoded data.\n\nfunc (enc *Encoding) Encode(dst, src []byte)\n    Encode encodes src using the encoding enc, writing\n    Encoding.EncodedLen(len(src)) bytes to dst.\n\n    The encoding pads the output to a multiple of 8 bytes, so Encode is\n    not appropriate for use on individual blocks of a large data stream.\n    Use NewEncoder instead.\n\nfunc (enc *Encoding) EncodeToString(src []byte) string\n    EncodeToString returns the base32 encoding of src.\n\nfunc (enc *Encoding) EncodedLen(n int) int\n    EncodedLen returns the length in bytes of the base32 encoding of an input\n    buffer of length n.\n\nfunc (enc Encoding) WithPadding(padding rune) *Encoding\n    WithPadding creates a new encoding identical to enc except with a specified\n    padding character, or NoPadding to disable padding. The padding character\n    must not be '\\r' or '\\n', must not be contained in the encoding's alphabet,\n    must not be negative, and must be a rune equal or below '\\xff'. Padding\n    characters above '\\x7f' are encoded as their exact byte value rather than\n    using the UTF-8 representation of the codepoint.\n\n"}, {"path": "stdlib/internal-fmtsort.md", "category": "stdlib", "name": "stdlib/internal-fmtsort", "content": "package fmtsort // import \"internal/fmtsort\"\n\nPackage fmtsort provides a general stable ordering mechanism for maps, on behalf\nof the fmt and text/template packages. It is not guaranteed to be efficient and\nworks only for types that are valid map keys.\n\nTYPES\n\ntype KeyValue struct {\n\tKey, Value reflect.Value\n}\n    KeyValue holds a single key and value pair found in a map.\n\ntype SortedMap []KeyValue\n    SortedMap is a slice of KeyValue pairs that simplifies sorting and iterating\n    over map entries.\n\n    Each KeyValue pair contains a map key and its corresponding value.\n\nfunc Sort(mapValue reflect.Value) SortedMap\n    Sort accepts a map and returns a SortedMap that has the same keys and values\n    but in a stable sorted order according to the keys, modulo issues raised by\n    unorderable key values such as NaNs.\n\n    The ordering rules are more general than with Go's < operator:\n\n      - when applicable, nil compares low\n      - ints, floats, and strings order by <\n      - NaN compares less than non-NaN floats\n      - bool compares false before true\n      - complex compares real, then imag\n      - pointers compare by machine address\n      - channel values compare by machine address\n      - structs compare each field in turn\n      - arrays compare each element in turn. Otherwise identical arrays compare\n        by length.\n      - interface values compare first by reflect.Type describing the concrete\n        type and then by concrete value as described in the previous rules.\n\n"}, {"path": "stdlib/context.md", "category": "stdlib", "name": "stdlib/context", "content": "package context // import \"context\"\n\nPackage context defines the Context type, which carries deadlines, cancellation\nsignals, and other request-scoped values across API boundaries and between\nprocesses.\n\nIncoming requests to a server should create a Context, and outgoing calls to\nservers should accept a Context. The chain of function calls between them must\npropagate the Context, optionally replacing it with a derived Context created\nusing WithCancel, WithDeadline, WithTimeout, or WithValue.\n\nA Context may be canceled to indicate that work done on its behalf should stop.\nA Context with a deadline is canceled after the deadline passes. When a Context\nis canceled, all Contexts derived from it are also canceled.\n\nThe WithCancel, WithDeadline, and WithTimeout functions take a Context (the\nparent) and return a derived Context (the child) and a CancelFunc. Calling the\nCancelFunc directly cancels the child and its children, removes the parent's\nreference to the child, and stops any associated timers. Failing to call the\nCancelFunc leaks the child and its children until the parent is canceled.\nThe go vet tool checks that CancelFuncs are used on all control-flow paths.\n\nThe WithCancelCause, WithDeadlineCause, and WithTimeoutCause functions return a\nCancelCauseFunc, which takes an error and records it as the cancellation cause.\nCalling Cause on the canceled context or any of its children retrieves the\ncause. If no cause is specified, Cause(ctx) returns the same value as ctx.Err().\n\nPrograms that use Contexts should follow these rules to keep interfaces\nconsistent across packages and enable static analysis tools to check context\npropagation:\n\nDo not store Contexts inside a struct type; instead, pass a Context\nexplicitly to each function that needs it. This is discussed further in\nhttps://go.dev/blog/context-and-structs. The Context should be the first\nparameter, typically named ctx:\n\n    func DoSomething(ctx context.Context, arg Arg) error {\n    \t// ... use ctx ...\n    }\n\nDo not pass a nil Context, even if a function permits it. Pass context.TODO if\nyou are unsure about which Context to use.\n\nUse context Values only for request-scoped data that transits processes and\nAPIs, not for passing optional parameters to functions.\n\nThe same Context may be passed to functions running in different goroutines;\nContexts are safe for simultaneous use by multiple goroutines.\n\nSee https://go.dev/blog/context for example code for a server that uses\nContexts.\n\nVARIABLES\n\nvar Canceled = errors.New(\"context canceled\")\n    Canceled is the error returned by [Context.Err] when the context is canceled\n    for some reason other than its deadline passing.\n\nvar DeadlineExceeded error = deadlineExceededError{}\n    DeadlineExceeded is the error returned by [Context.Err] when the context is\n    canceled due to its deadline passing.\n\n\nFUNCTIONS\n\nfunc AfterFunc(ctx Context, f func()) (stop func() bool)\n    AfterFunc arranges to call f in its own goroutine after ctx is canceled. If\n    ctx is already canceled, AfterFunc calls f immediately in its own goroutine.\n\n    Multiple calls to AfterFunc on a context operate independently; one does not\n    replace another.\n\n    Calling the returned stop function stops the association of ctx with f.\n    It returns true if the call stopped f from being run. If stop returns false,\n    either the context is canceled and f has been started in its own goroutine;\n    or f was already stopped. The stop function does not wait for f to complete\n    before returning. If the caller needs to know whether f is completed,\n    it must coordinate with f explicitly.\n\n    If ctx has a \"AfterFunc(func()) func() bool\" method, AfterFunc will use it\n    to schedule the call.\n\nfunc Cause(c Context) error\n    Cause returns a non-nil error explaining why c was canceled. The first\n    cancellation of c or one of its parents sets the cause. If that cancellation\n    happened via a call to CancelCauseFunc(err), then Cause returns err.\n    Otherwise Cause(c) returns the same value as c.Err(). Cause returns nil if c\n    has not been canceled yet.\n\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc)\n    WithCancel returns a derived context that points to the parent context but\n    has a new Done channel. The returned context's Done channel is closed when\n    the returned cancel function is called or when the parent context's Done\n    channel is closed, whichever happens first.\n\n    Canceling this context releases resources associated with it, so code should\n    call cancel as soon as the operations running in this Context complete.\n\nfunc WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc)\n    WithCancelCause behaves like WithCancel but returns a CancelCauseFunc\n    instead of a CancelFunc. Calling cancel with a non-nil error (the \"cause\")\n    records that error in ctx; it can then be retrieved using Cause(ctx).\n    Calling cancel with nil sets the cause to Canceled.\n\n    Example use:\n\n        ctx, cancel := context.WithCancelCause(parent)\n        cancel(myError)\n        ctx.Err() // returns context.Canceled\n        context.Cause(ctx) // returns myError\n\nfunc WithDeadline(parent Context, d time.Time) (Context, CancelFunc)\n    WithDeadline returns a derived context that points to the parent context but\n    has the deadline adjusted to be no later than d. If the parent's deadline is\n    already earlier than d, WithDeadline(parent, d) is semantically equivalent\n    to parent. The returned [Context.Done] channel is closed when the deadline\n    expires, when the returned cancel function is called, or when the parent\n    context's Done channel is closed, whichever happens first.\n\n    Canceling this context releases resources associated with it, so code should\n    call cancel as soon as the operations running in this Context complete.\n\nfunc WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc)\n    WithDeadlineCause behaves like WithDeadline but also sets the cause of the\n    returned Context when the deadline is exceeded. The returned CancelFunc does\n    not set the cause.\n\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)\n    WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\n\n    Canceling this context releases resources associated with it, so code should\n    call cancel as soon as the operations running in this Context complete:\n\n        func slowOperationWithTimeout(ctx context.Context) (Result, error) {\n        \tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n        \tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n        \treturn slowOperation(ctx)\n        }\n\nfunc WithTimeoutCause(parent Context, timeout time.Duration, cause error) (Context, CancelFunc)\n    WithTimeoutCause behaves like WithTimeout but also sets the cause of the\n    returned Context when the timeout expires. The returned CancelFunc does not\n    set the cause.\n\n\nTYPES\n\ntype CancelCauseFunc func(cause error)\n    A CancelCauseFunc behaves like a CancelFunc but additionally sets the\n    cancellation cause. This cause can be retrieved by calling Cause on the\n    canceled Context or on any of its derived Contexts.\n\n    If the context has already been canceled, CancelCauseFunc does not set the\n    cause. For example, if childContext is derived from parentContext:\n      - if parentContext is canceled with cause1 before childContext is canceled\n        with cause2, then Cause(parentContext) == Cause(childContext) == cause1\n      - if childContext is canceled with cause2 before parentContext is canceled\n        with cause1, then Cause(parentContext) == cause1 and Cause(childContext)\n        == cause2\n\ntype CancelFunc func()\n    A CancelFunc tells an operation to abandon its work. A CancelFunc does not\n    wait for the work to stop. A CancelFunc may be called by multiple goroutines\n    simultaneously. After the first call, subsequent calls to a CancelFunc do\n    nothing.\n\ntype Context interface {\n\t// Deadline returns the time when work done on behalf of this context\n\t// should be canceled. Deadline returns ok==false when no deadline is\n\t// set. Successive calls to Deadline return the same results.\n\tDeadline() (deadline time.Time, ok bool)\n\n\t// Done returns a channel that's closed when work done on behalf of this\n\t// context should be canceled. Done may return nil if this context can\n\t// never be canceled. Successive calls to Done return the same value.\n\t// The close of the Done channel may happen asynchronously,\n\t// after the cancel function returns.\n\t//\n\t// WithCancel arranges for Done to be closed when cancel is called;\n\t// WithDeadline arranges for Done to be closed when the deadline\n\t// expires; WithTimeout arranges for Done to be closed when the timeout\n\t// elapses.\n\t//\n\t// Done is provided for use in select statements:\n\t//\n\t//  // Stream generates values with DoSomething and sends them to out\n\t//  // until DoSomething returns an error or ctx.Done is closed.\n\t//  func Stream(ctx context.Context, out chan<- Value) error {\n\t//  \tfor {\n\t//  \t\tv, err := DoSomething(ctx)\n\t//  \t\tif err != nil {\n\t//  \t\t\treturn err\n\t//  \t\t}\n\t//  \t\tselect {\n\t//  \t\tcase <-ctx.Done():\n\t//  \t\t\treturn ctx.Err()\n\t//  \t\tcase out <- v:\n\t//  \t\t}\n\t//  \t}\n\t//  }\n\t//\n\t// See https://blog.golang.org/pipelines for more examples of how to use\n\t// a Done channel for cancellation.\n\tDone() <-chan struct{}\n\n\t// If Done is not yet closed, Err returns nil.\n\t// If Done is closed, Err returns a non-nil error explaining why:\n\t// DeadlineExceeded if the context's deadline passed,\n\t// or Canceled if the context was canceled for some other reason.\n\t// After Err returns a non-nil error, successive calls to Err return the same error.\n\tErr() error\n\n\t// Value returns the value associated with this context for key, or nil\n\t// if no value is associated with key. Successive calls to Value with\n\t// the same key returns the same result.\n\t//\n\t// Use context values only for request-scoped data that transits\n\t// processes and API boundaries, not for passing optional parameters to\n\t// functions.\n\t//\n\t// A key identifies a specific value in a Context. Functions that wish\n\t// to store values in Context typically allocate a key in a global\n\t// variable then use that key as the argument to context.WithValue and\n\t// Context.Value. A key can be any type that supports equality;\n\t// packages should define keys as an unexported type to avoid\n\t// collisions.\n\t//\n\t// Packages that define a Context key should provide type-safe accessors\n\t// for the values stored using that key:\n\t//\n\t//\t// Package user defines a User type that's stored in Contexts.\n\t//\tpackage user\n\t//\n\t//\timport \"context\"\n\t//\n\t//\t// User is the type of value stored in the Contexts.\n\t//\ttype User struct {...}\n\t//\n\t//\t// key is an unexported type for keys defined in this package.\n\t//\t// This prevents collisions with keys defined in other packages.\n\t//\ttype key int\n\t//\n\t//\t// userKey is the key for user.User values in Contexts. It is\n\t//\t// unexported; clients use user.NewContext and user.FromContext\n\t//\t// instead of using this key directly.\n\t//\tvar userKey key\n\t//\n\t//\t// NewContext returns a new Context that carries value u.\n\t//\tfunc NewContext(ctx context.Context, u *User) context.Context {\n\t//\t\treturn context.WithValue(ctx, userKey, u)\n\t//\t}\n\t//\n\t//\t// FromContext returns the User value stored in ctx, if any.\n\t//\tfunc FromContext(ctx context.Context) (*User, bool) {\n\t//\t\tu, ok := ctx.Value(userKey).(*User)\n\t//\t\treturn u, ok\n\t//\t}\n\tValue(key any) any\n}\n    A Context carries a deadline, a cancellation signal, and other values across\n    API boundaries.\n\n    Context's methods may be called by multiple goroutines simultaneously.\n\nfunc Background() Context\n    Background returns a non-nil, empty Context. It is never canceled, has no\n    values, and has no deadline. It is typically used by the main function,\n    initialization, and tests, and as the top-level Context for incoming\n    requests.\n\nfunc TODO() Context\n    TODO returns a non-nil, empty Context. Code should use context.TODO when\n    it's unclear which Context to use or it is not yet available (because\n    the surrounding function has not yet been extended to accept a Context\n    parameter).\n\nfunc WithValue(parent Context, key, val any) Context\n    WithValue returns a derived context that points to the parent Context.\n    In the derived context, the value associated with key is val.\n\n    Use context Values only for request-scoped data that transits processes and\n    APIs, not for passing optional parameters to functions.\n\n    The provided key must be comparable and should not be of type string or any\n    other built-in type to avoid collisions between packages using context.\n    Users of WithValue should define their own types for keys. To avoid\n    allocating when assigning to an interface{}, context keys often have\n    concrete type struct{}. Alternatively, exported context key variables'\n    static type should be a pointer or interface.\n\nfunc WithoutCancel(parent Context) Context\n    WithoutCancel returns a derived context that points to the parent context\n    and is not canceled when parent is canceled. The returned context returns no\n    Deadline or Err, and its Done channel is nil. Calling Cause on the returned\n    context returns nil.\n\n"}, {"path": "stdlib/internal-testpty.md", "category": "stdlib", "name": "stdlib/internal-testpty", "content": "package testpty // import \"internal/testpty\"\n\nPackage testpty is a simple pseudo-terminal package for Unix systems,\nimplemented by calling C functions via cgo.\n\nVARIABLES\n\nvar ErrNotSupported = errors.New(\"testpty.Open not implemented on this platform\")\n\nFUNCTIONS\n\nfunc Open() (pty *os.File, processTTY string, err error)\n    Open returns a control pty and the name of the linked process tty.\n\n    If Open is not implemented on this platform, it returns ErrNotSupported.\n\n\nTYPES\n\ntype PtyError struct {\n\tFuncName    string\n\tErrorString string\n\tErrno       error\n}\n\nfunc (e *PtyError) Error() string\n\nfunc (e *PtyError) Unwrap() error\n\n"}, {"path": "stdlib/runtime-cgo.md", "category": "stdlib", "name": "stdlib/runtime-cgo", "content": "package cgo // import \"runtime/cgo\"\n\nPackage cgo contains runtime support for code generated by the cgo tool.\nSee the documentation for the cgo command for details on using cgo.\n\nTYPES\n\ntype Handle uintptr\n    Handle provides a way to pass values that contain Go pointers (pointers to\n    memory allocated by Go) between Go and C without breaking the cgo pointer\n    passing rules. A Handle is an integer value that can represent any Go value.\n    A Handle can be passed through C and back to Go, and Go code can use the\n    Handle to retrieve the original Go value.\n\n    The underlying type of Handle is guaranteed to fit in an integer type that\n    is large enough to hold the bit pattern of any pointer. The zero value of a\n    Handle is not valid, and thus is safe to use as a sentinel in C APIs.\n\n    For instance, on the Go side:\n\n        package main\n\n        /*\n        #include <stdint.h> // for uintptr_t\n\n        extern void MyGoPrint(uintptr_t handle);\n        void myprint(uintptr_t handle);\n        */\n        import \"C\"\n        import \"runtime/cgo\"\n\n        //export MyGoPrint\n        func MyGoPrint(handle C.uintptr_t) {\n        \th := cgo.Handle(handle)\n        \tval := h.Value().(string)\n        \tprintln(val)\n        \th.Delete()\n        }\n\n        func main() {\n        \tval := \"hello Go\"\n        \tC.myprint(C.uintptr_t(cgo.NewHandle(val)))\n        \t// Output: hello Go\n        }\n\n    and on the C side:\n\n        #include <stdint.h> // for uintptr_t\n\n        // A Go function\n        extern void MyGoPrint(uintptr_t handle);\n\n        // A C function\n        void myprint(uintptr_t handle) {\n            MyGoPrint(handle);\n        }\n\n    Some C functions accept a void* argument that points to an arbitrary\n    data value supplied by the caller. It is not safe to coerce a Handle (an\n    integer) to a Go unsafe.Pointer, but instead we can pass the address of\n    the cgo.Handle to the void* parameter, as in this variant of the previous\n    example.\n\n    Note that, as described in the cmd/cgo documentation, the C code must\n    not keep a copy of the Go pointer that it receives, unless the memory is\n    explicitly pinned using runtime.Pinner. This example is OK because the C\n    function myprint does not keep a copy of the pointer.\n\n        package main\n\n        /*\n        extern void MyGoPrint(void *context);\n        static inline void myprint(void *context) {\n            MyGoPrint(context);\n        }\n        */\n        import \"C\"\n        import (\n        \t\"runtime/cgo\"\n        \t\"unsafe\"\n        )\n\n        //export MyGoPrint\n        func MyGoPrint(context unsafe.Pointer) {\n        \th := *(*cgo.Handle)(context)\n        \tval := h.Value().(string)\n        \tprintln(val)\n        \th.Delete()\n        }\n\n        func main() {\n        \tval := \"hello Go\"\n        \th := cgo.NewHandle(val)\n        \tC.myprint(unsafe.Pointer(&h))\n        \t// Output: hello Go\n        }\n\nfunc NewHandle(v any) Handle\n    NewHandle returns a handle for a given value.\n\n    The handle is valid until the program calls Delete on it. The handle uses\n    resources, and this package assumes that C code may hold on to the handle,\n    so a program must explicitly call Delete when the handle is no longer\n    needed.\n\n    The intended use is to pass the returned handle to C code, which passes it\n    back to Go, which calls Value.\n\nfunc (h Handle) Delete()\n    Delete invalidates a handle. This method should only be called once the\n    program no longer needs to pass the handle to C and the C code no longer has\n    a copy of the handle value.\n\n    The method panics if the handle is invalid.\n\nfunc (h Handle) Value() any\n    Value returns the associated Go value for a valid handle.\n\n    The method panics if the handle is invalid.\n\ntype Incomplete struct {\n\t// Has unexported fields.\n}\n    Incomplete is used specifically for the semantics of incomplete C types.\n\n"}, {"path": "stdlib/internal-runtime-strconv.md", "category": "stdlib", "name": "stdlib/internal-runtime-strconv", "content": "package strconv // import \"internal/runtime/strconv\"\n\n\nFUNCTIONS\n\nfunc Atoi(s string) (int, bool)\n    Atoi is like Atoi64 but for integers that fit into an int.\n\nfunc Atoi32(s string) (int32, bool)\n    Atoi32 is like Atoi but for integers that fit into an int32.\n\nfunc Atoi64(s string) (int64, bool)\n    Atoi64 parses an int64 from a string s. The bool result reports whether s is\n    a number representable by a value of type int64.\n\n"}, {"path": "stdlib/internal-msan.md", "category": "stdlib", "name": "stdlib/internal-msan", "content": "package msan // import \"internal/msan\"\n\nPackage msan contains helper functions for manually instrumenting code for the\nmemory sanitizer. This package exports the private msan routines in runtime\nunconditionally but without the \"msan\" build tag they are no-ops.\n\nCONSTANTS\n\nconst Enabled = false\n\nFUNCTIONS\n\nfunc Free(addr unsafe.Pointer, sz uintptr)\nfunc Malloc(addr unsafe.Pointer, sz uintptr)\nfunc Move(dst, src unsafe.Pointer, sz uintptr)\nfunc Read(addr unsafe.Pointer, sz uintptr)\nfunc Write(addr unsafe.Pointer, sz uintptr)\n"}, {"path": "stdlib/expvar.md", "category": "stdlib", "name": "stdlib/expvar", "content": "package expvar // import \"expvar\"\n\nPackage expvar provides a standardized interface to public variables,\nsuch as operation counters in servers. It exposes these variables via HTTP at\n/debug/vars in JSON format. As of Go 1.22, the /debug/vars request must use GET.\n\nOperations to set or modify these public variables are atomic.\n\nIn addition to adding the HTTP handler, this package registers the following\nvariables:\n\n    cmdline   os.Args\n    memstats  runtime.Memstats\n\nThe package is sometimes only imported for the side effect of registering its\nHTTP handler and the above variables. To use it this way, link this package into\nyour program:\n\n    import _ \"expvar\"\n\nFUNCTIONS\n\nfunc Do(f func(KeyValue))\n    Do calls f for each exported variable. The global variable map is locked\n    during the iteration, but existing entries may be concurrently updated.\n\nfunc Handler() http.Handler\n    Handler returns the expvar HTTP Handler.\n\n    This is only needed to install the handler in a non-standard location.\n\nfunc Publish(name string, v Var)\n    Publish declares a named exported variable. This should be called from a\n    package's init function when it creates its Vars. If the name is already\n    registered then this will log.Panic.\n\n\nTYPES\n\ntype Float struct {\n\t// Has unexported fields.\n}\n    Float is a 64-bit float variable that satisfies the Var interface.\n\nfunc NewFloat(name string) *Float\n\nfunc (v *Float) Add(delta float64)\n    Add adds delta to v.\n\nfunc (v *Float) Set(value float64)\n    Set sets v to value.\n\nfunc (v *Float) String() string\n\nfunc (v *Float) Value() float64\n\ntype Func func() any\n    Func implements Var by calling the function and formatting the returned\n    value using JSON.\n\nfunc (f Func) String() string\n\nfunc (f Func) Value() any\n\ntype Int struct {\n\t// Has unexported fields.\n}\n    Int is a 64-bit integer variable that satisfies the Var interface.\n\nfunc NewInt(name string) *Int\n\nfunc (v *Int) Add(delta int64)\n\nfunc (v *Int) Set(value int64)\n\nfunc (v *Int) String() string\n\nfunc (v *Int) Value() int64\n\ntype KeyValue struct {\n\tKey   string\n\tValue Var\n}\n    KeyValue represents a single entry in a Map.\n\ntype Map struct {\n\t// Has unexported fields.\n}\n    Map is a string-to-Var map variable that satisfies the Var interface.\n\nfunc NewMap(name string) *Map\n\nfunc (v *Map) Add(key string, delta int64)\n    Add adds delta to the *Int value stored under the given map key.\n\nfunc (v *Map) AddFloat(key string, delta float64)\n    AddFloat adds delta to the *Float value stored under the given map key.\n\nfunc (v *Map) Delete(key string)\n    Delete deletes the given key from the map.\n\nfunc (v *Map) Do(f func(KeyValue))\n    Do calls f for each entry in the map. The map is locked during the\n    iteration, but existing entries may be concurrently updated.\n\nfunc (v *Map) Get(key string) Var\n\nfunc (v *Map) Init() *Map\n    Init removes all keys from the map.\n\nfunc (v *Map) Set(key string, av Var)\n\nfunc (v *Map) String() string\n\ntype String struct {\n\t// Has unexported fields.\n}\n    String is a string variable, and satisfies the Var interface.\n\nfunc NewString(name string) *String\n\nfunc (v *String) Set(value string)\n\nfunc (v *String) String() string\n    String implements the Var interface. To get the unquoted string use\n    String.Value.\n\nfunc (v *String) Value() string\n\ntype Var interface {\n\t// String returns a valid JSON value for the variable.\n\t// Types with String methods that do not return valid JSON\n\t// (such as time.Time) must not be used as a Var.\n\tString() string\n}\n    Var is an abstract type for all exported variables.\n\nfunc Get(name string) Var\n    Get retrieves a named exported variable. It returns nil if the name has not\n    been registered.\n\n"}, {"path": "stdlib/crypto.md", "category": "stdlib", "name": "stdlib/crypto", "content": "package crypto // import \"crypto\"\n\nPackage crypto collects common cryptographic constants.\n\nFUNCTIONS\n\nfunc RegisterHash(h Hash, f func() hash.Hash)\n    RegisterHash registers a function that returns a new instance of the given\n    hash function. This is intended to be called from the init function in\n    packages that implement hash functions.\n\nfunc SignMessage(signer Signer, rand io.Reader, msg []byte, opts SignerOpts) (signature []byte, err error)\n    SignMessage signs msg with signer. If signer implements MessageSigner,\n    [MessageSigner.SignMessage] is called directly. Otherwise, msg is hashed\n    with opts.HashFunc() and signed with [Signer.Sign].\n\n\nTYPES\n\ntype Decrypter interface {\n\t// Public returns the public key corresponding to the opaque,\n\t// private key.\n\tPublic() PublicKey\n\n\t// Decrypt decrypts msg. The opts argument should be appropriate for\n\t// the primitive used. See the documentation in each implementation for\n\t// details.\n\tDecrypt(rand io.Reader, msg []byte, opts DecrypterOpts) (plaintext []byte, err error)\n}\n    Decrypter is an interface for an opaque private key that can be used for\n    asymmetric decryption operations. An example would be an RSA key kept in a\n    hardware module.\n\ntype DecrypterOpts any\n\ntype Hash uint\n    Hash identifies a cryptographic hash function that is implemented in another\n    package.\n\nconst (\n\tMD4         Hash = 1 + iota // import golang.org/x/crypto/md4\n\tMD5                         // import crypto/md5\n\tSHA1                        // import crypto/sha1\n\tSHA224                      // import crypto/sha256\n\tSHA256                      // import crypto/sha256\n\tSHA384                      // import crypto/sha512\n\tSHA512                      // import crypto/sha512\n\tMD5SHA1                     // no implementation; MD5+SHA1 used for TLS RSA\n\tRIPEMD160                   // import golang.org/x/crypto/ripemd160\n\tSHA3_224                    // import golang.org/x/crypto/sha3\n\tSHA3_256                    // import golang.org/x/crypto/sha3\n\tSHA3_384                    // import golang.org/x/crypto/sha3\n\tSHA3_512                    // import golang.org/x/crypto/sha3\n\tSHA512_224                  // import crypto/sha512\n\tSHA512_256                  // import crypto/sha512\n\tBLAKE2s_256                 // import golang.org/x/crypto/blake2s\n\tBLAKE2b_256                 // import golang.org/x/crypto/blake2b\n\tBLAKE2b_384                 // import golang.org/x/crypto/blake2b\n\tBLAKE2b_512                 // import golang.org/x/crypto/blake2b\n\n)\nfunc (h Hash) Available() bool\n    Available reports whether the given hash function is linked into the binary.\n\nfunc (h Hash) HashFunc() Hash\n    HashFunc simply returns the value of h so that Hash implements SignerOpts.\n\nfunc (h Hash) New() hash.Hash\n    New returns a new hash.Hash calculating the given hash function. New panics\n    if the hash function is not linked into the binary.\n\nfunc (h Hash) Size() int\n    Size returns the length, in bytes, of a digest resulting from the given hash\n    function. It doesn't require that the hash function in question be linked\n    into the program.\n\nfunc (h Hash) String() string\n\ntype MessageSigner interface {\n\tSigner\n\tSignMessage(rand io.Reader, msg []byte, opts SignerOpts) (signature []byte, err error)\n}\n    MessageSigner is an interface for an opaque private key that can be used\n    for signing operations where the message is not pre-hashed by the caller.\n    It is a superset of the Signer interface so that it can be passed to APIs\n    which accept Signer, which may try to do an interface upgrade.\n\n    MessageSigner.SignMessage and MessageSigner.Sign should produce the same\n    result given the same opts. In particular, MessageSigner.SignMessage should\n    only accept a zero opts.HashFunc if the Signer would also accept messages\n    which are not pre-hashed.\n\n    Implementations which do not provide the pre-hashed Sign API should\n    implement Signer.Sign by always returning an error.\n\ntype PrivateKey any\n    PrivateKey represents a private key using an unspecified algorithm.\n\n    Although this type is an empty interface for backwards compatibility\n    reasons, all private key types in the standard library implement the\n    following interface\n\n        interface{\n            Public() crypto.PublicKey\n            Equal(x crypto.PrivateKey) bool\n        }\n\n    as well as purpose-specific interfaces such as Signer and Decrypter,\n    which can be used for increased type safety within applications.\n\ntype PublicKey any\n    PublicKey represents a public key using an unspecified algorithm.\n\n    Although this type is an empty interface for backwards compatibility\n    reasons, all public key types in the standard library implement the\n    following interface\n\n        interface{\n            Equal(x crypto.PublicKey) bool\n        }\n\n    which can be used for increased type safety within applications.\n\ntype Signer interface {\n\t// Public returns the public key corresponding to the opaque,\n\t// private key.\n\tPublic() PublicKey\n\n\t// Sign signs digest with the private key, possibly using entropy from\n\t// rand. For an RSA key, the resulting signature should be either a\n\t// PKCS #1 v1.5 or PSS signature (as indicated by opts). For an (EC)DSA\n\t// key, it should be a DER-serialised, ASN.1 signature structure.\n\t//\n\t// Hash implements the SignerOpts interface and, in most cases, one can\n\t// simply pass in the hash function used as opts. Sign may also attempt\n\t// to type assert opts to other types in order to obtain algorithm\n\t// specific values. See the documentation in each package for details.\n\t//\n\t// Note that when a signature of a hash of a larger message is needed,\n\t// the caller is responsible for hashing the larger message and passing\n\t// the hash (as digest) and the hash function (as opts) to Sign.\n\tSign(rand io.Reader, digest []byte, opts SignerOpts) (signature []byte, err error)\n}\n    Signer is an interface for an opaque private key that can be used for\n    signing operations. For example, an RSA key kept in a hardware module.\n\ntype SignerOpts interface {\n\t// HashFunc returns an identifier for the hash function used to produce\n\t// the message passed to Signer.Sign, or else zero to indicate that no\n\t// hashing was done.\n\tHashFunc() Hash\n}\n    SignerOpts contains options for signing with a Signer.\n\n"}, {"path": "stdlib/compress-zlib.md", "category": "stdlib", "name": "stdlib/compress-zlib", "content": "package zlib // import \"compress/zlib\"\n\nPackage zlib implements reading and writing of zlib format compressed data,\nas specified in RFC 1950.\n\nThe implementation provides filters that uncompress during reading and compress\nduring writing. For example, to write compressed data to a buffer:\n\n    var b bytes.Buffer\n    w := zlib.NewWriter(&b)\n    w.Write([]byte(\"hello, world\\n\"))\n    w.Close()\n\nand to read that data back:\n\n    r, err := zlib.NewReader(&b)\n    io.Copy(os.Stdout, r)\n    r.Close()\n\nCONSTANTS\n\nconst (\n\tNoCompression      = flate.NoCompression\n\tBestSpeed          = flate.BestSpeed\n\tBestCompression    = flate.BestCompression\n\tDefaultCompression = flate.DefaultCompression\n\tHuffmanOnly        = flate.HuffmanOnly\n)\n    These constants are copied from the flate package, so that code that imports\n    compress/zlib does not also have to import compress/flate.\n\n\nVARIABLES\n\nvar (\n\t// ErrChecksum is returned when reading ZLIB data that has an invalid checksum.\n\tErrChecksum = errors.New(\"zlib: invalid checksum\")\n\t// ErrDictionary is returned when reading ZLIB data that has an invalid dictionary.\n\tErrDictionary = errors.New(\"zlib: invalid dictionary\")\n\t// ErrHeader is returned when reading ZLIB data that has an invalid header.\n\tErrHeader = errors.New(\"zlib: invalid header\")\n)\n\nFUNCTIONS\n\nfunc NewReader(r io.Reader) (io.ReadCloser, error)\n    NewReader creates a new ReadCloser. Reads from the returned ReadCloser\n    read and decompress data from r. If r does not implement io.ByteReader, the\n    decompressor may read more data than necessary from r. It is the caller's\n    responsibility to call Close on the ReadCloser when done.\n\n    The io.ReadCloser returned by NewReader also implements Resetter.\n\nfunc NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)\n    NewReaderDict is like NewReader but uses a preset dictionary. NewReaderDict\n    ignores the dictionary if the compressed data does not refer to it. If the\n    compressed data refers to a different dictionary, NewReaderDict returns\n    ErrDictionary.\n\n    The ReadCloser returned by NewReaderDict also implements Resetter.\n\n\nTYPES\n\ntype Resetter interface {\n\t// Reset discards any buffered data and resets the Resetter as if it was\n\t// newly initialized with the given reader.\n\tReset(r io.Reader, dict []byte) error\n}\n    Resetter resets a ReadCloser returned by NewReader or NewReaderDict to\n    switch to a new underlying Reader. This permits reusing a ReadCloser instead\n    of allocating a new one.\n\ntype Writer struct {\n\t// Has unexported fields.\n}\n    A Writer takes data written to it and writes the compressed form of that\n    data to an underlying writer (see NewWriter).\n\nfunc NewWriter(w io.Writer) *Writer\n    NewWriter creates a new Writer. Writes to the returned Writer are compressed\n    and written to w.\n\n    It is the caller's responsibility to call Close on the Writer when done.\n    Writes may be buffered and not flushed until Close.\n\nfunc NewWriterLevel(w io.Writer, level int) (*Writer, error)\n    NewWriterLevel is like NewWriter but specifies the compression level instead\n    of assuming DefaultCompression.\n\n    The compression level can be DefaultCompression, NoCompression, HuffmanOnly\n    or any integer value between BestSpeed and BestCompression inclusive.\n    The error returned will be nil if the level is valid.\n\nfunc NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)\n    NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to\n    compress with.\n\n    The dictionary may be nil. If not, its contents should not be modified until\n    the Writer is closed.\n\nfunc (z *Writer) Close() error\n    Close closes the Writer, flushing any unwritten data to the underlying\n    io.Writer, but does not close the underlying io.Writer.\n\nfunc (z *Writer) Flush() error\n    Flush flushes the Writer to its underlying io.Writer.\n\nfunc (z *Writer) Reset(w io.Writer)\n    Reset clears the state of the Writer z such that it is equivalent to its\n    initial state from NewWriterLevel or NewWriterLevelDict, but instead writing\n    to w.\n\nfunc (z *Writer) Write(p []byte) (n int, err error)\n    Write writes a compressed form of p to the underlying io.Writer. The\n    compressed bytes are not necessarily flushed until the Writer is closed or\n    explicitly flushed.\n\n"}, {"path": "stdlib/internal-trace-traceviewer-format.md", "category": "stdlib", "name": "stdlib/internal-trace-traceviewer-format", "content": "package format // import \"internal/trace/traceviewer/format\"\n\nPackage traceviewer provides definitions of the JSON data structures used by the\nChrome trace viewer.\n\nThe official description of the format is in this file:\nhttps://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview\n\nNote: This can't be part of the parent traceviewer package as that would throw.\ngo_bootstrap cannot depend on the cgo version of package net in ./make.bash.\n\nCONSTANTS\n\nconst (\n\tProcsSection = 0 // where Goroutines or per-P timelines are presented.\n\tStatsSection = 1 // where counters are presented.\n\tTasksSection = 2 // where Task hierarchy & timeline is presented.\n)\n\nTYPES\n\ntype BlockedArg struct {\n\tBlocked string `json:\"blocked\"`\n}\n\ntype Data struct {\n\tEvents   []*Event         `json:\"traceEvents\"`\n\tFrames   map[string]Frame `json:\"stackFrames\"`\n\tTimeUnit string           `json:\"displayTimeUnit\"`\n}\n\ntype Event struct {\n\tName      string  `json:\"name,omitempty\"`\n\tPhase     string  `json:\"ph\"`\n\tScope     string  `json:\"s,omitempty\"`\n\tTime      float64 `json:\"ts\"`\n\tDur       float64 `json:\"dur,omitempty\"`\n\tPID       uint64  `json:\"pid\"`\n\tTID       uint64  `json:\"tid\"`\n\tID        uint64  `json:\"id,omitempty\"`\n\tBindPoint string  `json:\"bp,omitempty\"`\n\tStack     int     `json:\"sf,omitempty\"`\n\tEndStack  int     `json:\"esf,omitempty\"`\n\tArg       any     `json:\"args,omitempty\"`\n\tCname     string  `json:\"cname,omitempty\"`\n\tCategory  string  `json:\"cat,omitempty\"`\n}\n\ntype Frame struct {\n\tName   string `json:\"name\"`\n\tParent int    `json:\"parent,omitempty\"`\n}\n\ntype GoroutineCountersArg struct {\n\tRunning   uint64\n\tRunnable  uint64\n\tGCWaiting uint64\n}\n\ntype HeapCountersArg struct {\n\tAllocated uint64\n\tNextGC    uint64\n}\n\ntype NameArg struct {\n\tName string `json:\"name\"`\n}\n\ntype SortIndexArg struct {\n\tIndex int `json:\"sort_index\"`\n}\n\ntype ThreadCountersArg struct {\n\tRunning   int64\n\tInSyscall int64\n}\n\ntype ThreadIDArg struct {\n\tThreadID uint64\n}\n\n"}, {"path": "stdlib/internal-goarch.md", "category": "stdlib", "name": "stdlib/internal-goarch", "content": "package goarch // import \"internal/goarch\"\n\npackage goarch contains GOARCH-specific constants.\n\nCONSTANTS\n\nconst BigEndian = IsArmbe|IsArm64be|IsMips|IsMips64|IsPpc|IsPpc64|IsS390|IsS390x|IsSparc|IsSparc64 == 1\n    BigEndian reports whether the architecture is big-endian.\n\nconst DefaultPhysPageSize = _DefaultPhysPageSize\n    DefaultPhysPageSize is the default physical page size.\n\nconst GOARCH = `arm64`\nconst Int64Align = PtrSize\n    Int64Align is the required alignment for a 64-bit integer (4 on 32-bit\n    systems, 8 on 64-bit).\n\nconst Is386 = 0\nconst IsAmd64 = 0\nconst IsAmd64p32 = 0\nconst IsArm = 0\nconst IsArm64 = 1\nconst IsArm64be = 0\nconst IsArmbe = 0\nconst IsLoong64 = 0\nconst IsMips = 0\nconst IsMips64 = 0\nconst IsMips64le = 0\nconst IsMips64p32 = 0\nconst IsMips64p32le = 0\nconst IsMipsle = 0\nconst IsPpc = 0\nconst IsPpc64 = 0\nconst IsPpc64le = 0\nconst IsRiscv = 0\nconst IsRiscv64 = 0\nconst IsS390 = 0\nconst IsS390x = 0\nconst IsSparc = 0\nconst IsSparc64 = 0\nconst IsWasm = 0\nconst MinFrameSize = _MinFrameSize\n    MinFrameSize is the size of the system-reserved words at the bottom of\n    a frame (just above the architectural stack pointer). It is zero on x86\n    and PtrSize on most non-x86 (LR-based) systems. On PowerPC it is larger,\n    to cover three more reserved words: the compiler word, the link editor word,\n    and the TOC save word.\n\nconst PCQuantum = _PCQuantum\n    PCQuantum is the minimal unit for a program counter (1 on x86, 4 on most\n    other systems). The various PC tables record PC deltas pre-divided by\n    PCQuantum.\n\nconst PtrSize = 4 << (^uintptr(0) >> 63)\n    PtrSize is the size of a pointer in bytes - unsafe.Sizeof(uintptr(0)) but\n    as an ideal constant. It is also the size of the machine's native word size\n    (that is, 4 on 32-bit systems, 8 on 64-bit).\n\nconst StackAlign = _StackAlign\n    StackAlign is the required alignment of the SP register. The stack must be\n    at least word aligned, but some architectures require more.\n\n\nTYPES\n\ntype ArchFamilyType int\n    ArchFamilyType represents a family of one or more related architectures.\n    For example, ppc64 and ppc64le are both members of the PPC64 family.\n\nconst (\n\tAMD64 ArchFamilyType = iota\n\tARM\n\tARM64\n\tI386\n\tLOONG64\n\tMIPS\n\tMIPS64\n\tPPC64\n\tRISCV64\n\tS390X\n\tWASM\n)\nconst ArchFamily ArchFamilyType = _ArchFamily\n    ArchFamily is the architecture family (AMD64, ARM, ...)\n\n"}, {"path": "stdlib/net-internal-cgotest.md", "category": "stdlib", "name": "stdlib/net-internal-cgotest", "content": "package cgotest // import \"net/internal/cgotest\"\n\n"}, {"path": "stdlib/regexp.md", "category": "stdlib", "name": "stdlib/regexp", "content": "package regexp // import \"regexp\"\n\nPackage regexp implements regular expression search.\n\nThe syntax of the regular expressions accepted is the same general syntax\nused by Perl, Python, and other languages. More precisely, it is the syntax\naccepted by RE2 and described at https://golang.org/s/re2syntax, except for \\C.\nFor an overview of the syntax, see the regexp/syntax package.\n\nThe regexp implementation provided by this package is guaranteed to run in time\nlinear in the size of the input. (This is a property not guaranteed by most\nopen source implementations of regular expressions.) For more information about\nthis property, see https://swtch.com/~rsc/regexp/regexp1.html or any book about\nautomata theory.\n\nAll characters are UTF-8-encoded code points. Following utf8.DecodeRune, each\nbyte of an invalid UTF-8 sequence is treated as if it encoded utf8.RuneError\n(U+FFFD).\n\nThere are 16 methods of Regexp that match a regular expression and identify the\nmatched text. Their names are matched by this regular expression:\n\n    Find(All)?(String)?(Submatch)?(Index)?\n\nIf 'All' is present, the routine matches successive non-overlapping matches of\nthe entire expression. Empty matches abutting a preceding match are ignored.\nThe return value is a slice containing the successive return values of the\ncorresponding non-'All' routine. These routines take an extra integer argument,\nn. If n >= 0, the function returns at most n matches/submatches; otherwise,\nit returns all of them.\n\nIf 'String' is present, the argument is a string; otherwise it is a slice of\nbytes; return values are adjusted as appropriate.\n\nIf 'Submatch' is present, the return value is a slice identifying the\nsuccessive submatches of the expression. Submatches are matches of parenthesized\nsubexpressions (also known as capturing groups) within the regular expression,\nnumbered from left to right in order of opening parenthesis. Submatch 0 is\nthe match of the entire expression, submatch 1 is the match of the first\nparenthesized subexpression, and so on.\n\nIf 'Index' is present, matches and submatches are identified by byte index\npairs within the input string: result[2*n:2*n+2] identifies the indexes\nof the nth submatch. The pair for n==0 identifies the match of the entire\nexpression. If 'Index' is not present, the match is identified by the text\nof the match/submatch. If an index is negative or text is nil, it means that\nsubexpression did not match any string in the input. For 'String' versions an\nempty string means either no match or an empty match.\n\nThere is also a subset of the methods that can be applied to text read\nfrom an io.RuneReader: Regexp.MatchReader, Regexp.FindReaderIndex,\nRegexp.FindReaderSubmatchIndex.\n\nThis set may grow. Note that regular expression matches may need to examine\ntext beyond the text returned by a match, so the methods that match text from an\nio.RuneReader may read arbitrarily far into the input before returning.\n\n(There are a few other methods that do not match this pattern.)\n\nFUNCTIONS\n\nfunc Match(pattern string, b []byte) (matched bool, err error)\n    Match reports whether the byte slice b contains any match of the regular\n    expression pattern. More complicated queries need to use Compile and the\n    full Regexp interface.\n\nfunc MatchReader(pattern string, r io.RuneReader) (matched bool, err error)\n    MatchReader reports whether the text returned by the io.RuneReader contains\n    any match of the regular expression pattern. More complicated queries need\n    to use Compile and the full Regexp interface.\n\nfunc MatchString(pattern string, s string) (matched bool, err error)\n    MatchString reports whether the string s contains any match of the regular\n    expression pattern. More complicated queries need to use Compile and the\n    full Regexp interface.\n\nfunc QuoteMeta(s string) string\n    QuoteMeta returns a string that escapes all regular expression\n    metacharacters inside the argument text; the returned string is a regular\n    expression matching the literal text.\n\n\nTYPES\n\ntype Regexp struct {\n\t// Has unexported fields.\n}\n    Regexp is the representation of a compiled regular expression. A Regexp is\n    safe for concurrent use by multiple goroutines, except for configuration\n    methods, such as Regexp.Longest.\n\nfunc Compile(expr string) (*Regexp, error)\n    Compile parses a regular expression and returns, if successful, a Regexp\n    object that can be used to match against text.\n\n    When matching against text, the regexp returns a match that begins as\n    early as possible in the input (leftmost), and among those it chooses\n    the one that a backtracking search would have found first. This so-called\n    leftmost-first matching is the same semantics that Perl, Python, and other\n    implementations use, although this package implements it without the expense\n    of backtracking. For POSIX leftmost-longest matching, see CompilePOSIX.\n\nfunc CompilePOSIX(expr string) (*Regexp, error)\n    CompilePOSIX is like Compile but restricts the regular expression to POSIX\n    ERE (egrep) syntax and changes the match semantics to leftmost-longest.\n\n    That is, when matching against text, the regexp returns a match that begins\n    as early as possible in the input (leftmost), and among those it chooses a\n    match that is as long as possible. This so-called leftmost-longest matching\n    is the same semantics that early regular expression implementations used and\n    that POSIX specifies.\n\n    However, there can be multiple leftmost-longest matches, with\n    different submatch choices, and here this package diverges from POSIX.\n    Among the possible leftmost-longest matches, this package chooses the\n    one that a backtracking search would have found first, while POSIX\n    specifies that the match be chosen to maximize the length of the\n    first subexpression, then the second, and so on from left to right.\n    The POSIX rule is computationally prohibitive and not even well-defined.\n    See https://swtch.com/~rsc/regexp/regexp2.html#posix for details.\n\nfunc MustCompile(str string) *Regexp\n    MustCompile is like Compile but panics if the expression cannot be parsed.\n    It simplifies safe initialization of global variables holding compiled\n    regular expressions.\n\nfunc MustCompilePOSIX(str string) *Regexp\n    MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot\n    be parsed. It simplifies safe initialization of global variables holding\n    compiled regular expressions.\n\nfunc (re *Regexp) AppendText(b []byte) ([]byte, error)\n    AppendText implements encoding.TextAppender. The output matches that of\n    calling the Regexp.String method.\n\n    Note that the output is lossy in some cases: This method does not indicate\n    POSIX regular expressions (i.e. those compiled by calling CompilePOSIX),\n    or those for which the Regexp.Longest method has been called.\n\nfunc (re *Regexp) Copy() *Regexp\n    Copy returns a new Regexp object copied from re. Calling Regexp.Longest on\n    one copy does not affect another.\n\n    Deprecated: In earlier releases, when using a Regexp in multiple goroutines,\n    giving each goroutine its own copy helped to avoid lock contention.\n    As of Go 1.12, using Copy is no longer necessary to avoid lock contention.\n    Copy may still be appropriate if the reason for its use is to make two\n    copies with different Regexp.Longest settings.\n\nfunc (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte\n    Expand appends template to dst and returns the result; during the\n    append, Expand replaces variables in the template with corresponding\n    matches drawn from src. The match slice should have been returned by\n    Regexp.FindSubmatchIndex.\n\n    In the template, a variable is denoted by a substring of the form $name\n    or ${name}, where name is a non-empty sequence of letters, digits, and\n    underscores. A purely numeric name like $1 refers to the submatch with the\n    corresponding index; other names refer to capturing parentheses named with\n    the (?P<name>...) syntax. A reference to an out of range or unmatched index\n    or a name that is not present in the regular expression is replaced with an\n    empty slice.\n\n    In the $name form, name is taken to be as long as possible: $1x is\n    equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.\n\n    To insert a literal $ in the output, use $$ in the template.\n\nfunc (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte\n    ExpandString is like Regexp.Expand but the template and source are strings.\n    It appends to and returns a byte slice in order to give the calling code\n    control over allocation.\n\nfunc (re *Regexp) Find(b []byte) []byte\n    Find returns a slice holding the text of the leftmost match in b of the\n    regular expression. A return value of nil indicates no match.\n\nfunc (re *Regexp) FindAll(b []byte, n int) [][]byte\n    FindAll is the 'All' version of Regexp.Find; it returns a slice of all\n    successive matches of the expression, as defined by the 'All' description in\n    the package comment. A return value of nil indicates no match.\n\nfunc (re *Regexp) FindAllIndex(b []byte, n int) [][]int\n    FindAllIndex is the 'All' version of Regexp.FindIndex; it returns a slice\n    of all successive matches of the expression, as defined by the 'All'\n    description in the package comment. A return value of nil indicates no\n    match.\n\nfunc (re *Regexp) FindAllString(s string, n int) []string\n    FindAllString is the 'All' version of Regexp.FindString; it returns a\n    slice of all successive matches of the expression, as defined by the 'All'\n    description in the package comment. A return value of nil indicates no\n    match.\n\nfunc (re *Regexp) FindAllStringIndex(s string, n int) [][]int\n    FindAllStringIndex is the 'All' version of Regexp.FindStringIndex;\n    it returns a slice of all successive matches of the expression, as defined\n    by the 'All' description in the package comment. A return value of nil\n    indicates no match.\n\nfunc (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string\n    FindAllStringSubmatch is the 'All' version of Regexp.FindStringSubmatch;\n    it returns a slice of all successive matches of the expression, as defined\n    by the 'All' description in the package comment. A return value of nil\n    indicates no match.\n\nfunc (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int\n    FindAllStringSubmatchIndex is the 'All' version of\n    Regexp.FindStringSubmatchIndex; it returns a slice of all successive matches\n    of the expression, as defined by the 'All' description in the package\n    comment. A return value of nil indicates no match.\n\nfunc (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte\n    FindAllSubmatch is the 'All' version of Regexp.FindSubmatch; it returns a\n    slice of all successive matches of the expression, as defined by the 'All'\n    description in the package comment. A return value of nil indicates no\n    match.\n\nfunc (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int\n    FindAllSubmatchIndex is the 'All' version of Regexp.FindSubmatchIndex;\n    it returns a slice of all successive matches of the expression, as defined\n    by the 'All' description in the package comment. A return value of nil\n    indicates no match.\n\nfunc (re *Regexp) FindIndex(b []byte) (loc []int)\n    FindIndex returns a two-element slice of integers defining the location of\n    the leftmost match in b of the regular expression. The match itself is at\n    b[loc[0]:loc[1]]. A return value of nil indicates no match.\n\nfunc (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)\n    FindReaderIndex returns a two-element slice of integers defining the\n    location of the leftmost match of the regular expression in text read from\n    the io.RuneReader. The match text was found in the input stream at byte\n    offset loc[0] through loc[1]-1. A return value of nil indicates no match.\n\nfunc (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int\n    FindReaderSubmatchIndex returns a slice holding the index pairs identifying\n    the leftmost match of the regular expression of text read by the\n    io.RuneReader, and the matches, if any, of its subexpressions, as defined\n    by the 'Submatch' and 'Index' descriptions in the package comment. A return\n    value of nil indicates no match.\n\nfunc (re *Regexp) FindString(s string) string\n    FindString returns a string holding the text of the leftmost match in\n    s of the regular expression. If there is no match, the return value is\n    an empty string, but it will also be empty if the regular expression\n    successfully matches an empty string. Use Regexp.FindStringIndex or\n    Regexp.FindStringSubmatch if it is necessary to distinguish these cases.\n\nfunc (re *Regexp) FindStringIndex(s string) (loc []int)\n    FindStringIndex returns a two-element slice of integers defining the\n    location of the leftmost match in s of the regular expression. The match\n    itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match.\n\nfunc (re *Regexp) FindStringSubmatch(s string) []string\n    FindStringSubmatch returns a slice of strings holding the text of the\n    leftmost match of the regular expression in s and the matches, if any,\n    of its subexpressions, as defined by the 'Submatch' description in the\n    package comment. A return value of nil indicates no match.\n\nfunc (re *Regexp) FindStringSubmatchIndex(s string) []int\n    FindStringSubmatchIndex returns a slice holding the index pairs identifying\n    the leftmost match of the regular expression in s and the matches, if any,\n    of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions\n    in the package comment. A return value of nil indicates no match.\n\nfunc (re *Regexp) FindSubmatch(b []byte) [][]byte\n    FindSubmatch returns a slice of slices holding the text of the leftmost\n    match of the regular expression in b and the matches, if any, of its\n    subexpressions, as defined by the 'Submatch' descriptions in the package\n    comment. A return value of nil indicates no match.\n\nfunc (re *Regexp) FindSubmatchIndex(b []byte) []int\n    FindSubmatchIndex returns a slice holding the index pairs identifying the\n    leftmost match of the regular expression in b and the matches, if any,\n    of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions\n    in the package comment. A return value of nil indicates no match.\n\nfunc (re *Regexp) LiteralPrefix() (prefix string, complete bool)\n    LiteralPrefix returns a literal string that must begin any match of the\n    regular expression re. It returns the boolean true if the literal string\n    comprises the entire regular expression.\n\nfunc (re *Regexp) Longest()\n    Longest makes future searches prefer the leftmost-longest match. That is,\n    when matching against text, the regexp returns a match that begins as early\n    as possible in the input (leftmost), and among those it chooses a match\n    that is as long as possible. This method modifies the Regexp and may not be\n    called concurrently with any other methods.\n\nfunc (re *Regexp) MarshalText() ([]byte, error)\n    MarshalText implements encoding.TextMarshaler. The output matches that of\n    calling the Regexp.AppendText method.\n\n    See Regexp.AppendText for more information.\n\nfunc (re *Regexp) Match(b []byte) bool\n    Match reports whether the byte slice b contains any match of the regular\n    expression re.\n\nfunc (re *Regexp) MatchReader(r io.RuneReader) bool\n    MatchReader reports whether the text returned by the io.RuneReader contains\n    any match of the regular expression re.\n\nfunc (re *Regexp) MatchString(s string) bool\n    MatchString reports whether the string s contains any match of the regular\n    expression re.\n\nfunc (re *Regexp) NumSubexp() int\n    NumSubexp returns the number of parenthesized subexpressions in this Regexp.\n\nfunc (re *Regexp) ReplaceAll(src, repl []byte) []byte\n    ReplaceAll returns a copy of src, replacing matches of the Regexp with\n    the replacement text repl. Inside repl, $ signs are interpreted as in\n    Regexp.Expand.\n\nfunc (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte\n    ReplaceAllFunc returns a copy of src in which all matches of the Regexp have\n    been replaced by the return value of function repl applied to the matched\n    byte slice. The replacement returned by repl is substituted directly,\n    without using Regexp.Expand.\n\nfunc (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte\n    ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp\n    with the replacement bytes repl. The replacement repl is substituted\n    directly, without using Regexp.Expand.\n\nfunc (re *Regexp) ReplaceAllLiteralString(src, repl string) string\n    ReplaceAllLiteralString returns a copy of src, replacing matches of the\n    Regexp with the replacement string repl. The replacement repl is substituted\n    directly, without using Regexp.Expand.\n\nfunc (re *Regexp) ReplaceAllString(src, repl string) string\n    ReplaceAllString returns a copy of src, replacing matches of the Regexp\n    with the replacement string repl. Inside repl, $ signs are interpreted as in\n    Regexp.Expand.\n\nfunc (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string\n    ReplaceAllStringFunc returns a copy of src in which all matches of the\n    Regexp have been replaced by the return value of function repl applied to\n    the matched substring. The replacement returned by repl is substituted\n    directly, without using Regexp.Expand.\n\nfunc (re *Regexp) Split(s string, n int) []string\n    Split slices s into substrings separated by the expression and returns a\n    slice of the substrings between those expression matches.\n\n    The slice returned by this method consists of all the substrings of s\n    not contained in the slice returned by Regexp.FindAllString. When called\n    on an expression that contains no metacharacters, it is equivalent to\n    strings.SplitN.\n\n    Example:\n\n        s := regexp.MustCompile(\"a*\").Split(\"abaabaccadaaae\", 5)\n        // s: [\"\", \"b\", \"b\", \"c\", \"cadaaae\"]\n\n    The count determines the number of substrings to return:\n      - n > 0: at most n substrings; the last substring will be the unsplit\n        remainder;\n      - n == 0: the result is nil (zero substrings);\n      - n < 0: all substrings.\n\nfunc (re *Regexp) String() string\n    String returns the source text used to compile the regular expression.\n\nfunc (re *Regexp) SubexpIndex(name string) int\n    SubexpIndex returns the index of the first subexpression with the given\n    name, or -1 if there is no subexpression with that name.\n\n    Note that multiple subexpressions can be written using the same name, as in\n    (?P<bob>a+)(?P<bob>b+), which declares two subexpressions named \"bob\". In\n    this case, SubexpIndex returns the index of the leftmost such subexpression\n    in the regular expression.\n\nfunc (re *Regexp) SubexpNames() []string\n    SubexpNames returns the names of the parenthesized subexpressions in this\n    Regexp. The name for the first sub-expression is names[1], so that if m is\n    a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a\n    whole cannot be named, names[0] is always the empty string. The slice should\n    not be modified.\n\nfunc (re *Regexp) UnmarshalText(text []byte) error\n    UnmarshalText implements encoding.TextUnmarshaler by calling Compile on the\n    encoded value.\n\n"}, {"path": "stdlib/math-rand-v2.md", "category": "stdlib", "name": "stdlib/math-rand-v2", "content": "package rand // import \"math/rand/v2\"\n\nPackage rand implements pseudo-random number generators suitable for tasks such\nas simulation, but it should not be used for security-sensitive work.\n\nRandom numbers are generated by a Source, usually wrapped in a Rand. Both\ntypes should be used by a single goroutine at a time: sharing among multiple\ngoroutines requires some kind of synchronization.\n\nTop-level functions, such as Float64 and Int, are safe for concurrent use by\nmultiple goroutines.\n\nThis package's outputs might be easily predictable regardless of how it's\nseeded. For random numbers suitable for security-sensitive work, see the\ncrypto/rand package.\n\nFUNCTIONS\n\nfunc ExpFloat64() float64\n    ExpFloat64 returns an exponentially distributed float64 in the range (0,\n    +math.MaxFloat64] with an exponential distribution whose rate parameter\n    (lambda) is 1 and whose mean is 1/lambda (1) from the default Source. To\n    produce a distribution with a different rate parameter, callers can adjust\n    the output using:\n\n        sample = ExpFloat64() / desiredRateParameter\n\nfunc Float32() float32\n    Float32 returns, as a float32, a pseudo-random number in the half-open\n    interval [0.0,1.0) from the default Source.\n\nfunc Float64() float64\n    Float64 returns, as a float64, a pseudo-random number in the half-open\n    interval [0.0,1.0) from the default Source.\n\nfunc Int() int\n    Int returns a non-negative pseudo-random int from the default Source.\n\nfunc Int32() int32\n    Int32 returns a non-negative pseudo-random 31-bit integer as an int32 from\n    the default Source.\n\nfunc Int32N(n int32) int32\n    Int32N returns, as an int32, a pseudo-random number in the half-open\n    interval [0,n) from the default Source. It panics if n <= 0.\n\nfunc Int64() int64\n    Int64 returns a non-negative pseudo-random 63-bit integer as an int64 from\n    the default Source.\n\nfunc Int64N(n int64) int64\n    Int64N returns, as an int64, a pseudo-random number in the half-open\n    interval [0,n) from the default Source. It panics if n <= 0.\n\nfunc IntN(n int) int\n    IntN returns, as an int, a pseudo-random number in the half-open interval\n    [0,n) from the default Source. It panics if n <= 0.\n\nfunc N[Int intType](n Int) Int\n    N returns a pseudo-random number in the half-open interval [0,n) from the\n    default Source. The type parameter Int can be any integer type. It panics if\n    n <= 0.\n\nfunc NormFloat64() float64\n    NormFloat64 returns a normally distributed float64 in the range\n    [-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution (mean\n    = 0, stddev = 1) from the default Source. To produce a different normal\n    distribution, callers can adjust the output using:\n\n        sample = NormFloat64() * desiredStdDev + desiredMean\n\nfunc Perm(n int) []int\n    Perm returns, as a slice of n ints, a pseudo-random permutation of the\n    integers in the half-open interval [0,n) from the default Source.\n\nfunc Shuffle(n int, swap func(i, j int))\n    Shuffle pseudo-randomizes the order of elements using the default Source. n\n    is the number of elements. Shuffle panics if n < 0. swap swaps the elements\n    with indexes i and j.\n\nfunc Uint() uint\n    Uint returns a pseudo-random uint from the default Source.\n\nfunc Uint32() uint32\n    Uint32 returns a pseudo-random 32-bit value as a uint32 from the default\n    Source.\n\nfunc Uint32N(n uint32) uint32\n    Uint32N returns, as a uint32, a pseudo-random number in the half-open\n    interval [0,n) from the default Source. It panics if n == 0.\n\nfunc Uint64() uint64\n    Uint64 returns a pseudo-random 64-bit value as a uint64 from the default\n    Source.\n\nfunc Uint64N(n uint64) uint64\n    Uint64N returns, as a uint64, a pseudo-random number in the half-open\n    interval [0,n) from the default Source. It panics if n == 0.\n\nfunc UintN(n uint) uint\n    UintN returns, as a uint, a pseudo-random number in the half-open interval\n    [0,n) from the default Source. It panics if n == 0.\n\n\nTYPES\n\ntype ChaCha8 struct {\n\t// Has unexported fields.\n}\n    A ChaCha8 is a ChaCha8-based cryptographically strong random number\n    generator.\n\nfunc NewChaCha8(seed [32]byte) *ChaCha8\n    NewChaCha8 returns a new ChaCha8 seeded with the given seed.\n\nfunc (c *ChaCha8) AppendBinary(b []byte) ([]byte, error)\n    AppendBinary implements the encoding.BinaryAppender interface.\n\nfunc (c *ChaCha8) MarshalBinary() ([]byte, error)\n    MarshalBinary implements the encoding.BinaryMarshaler interface.\n\nfunc (c *ChaCha8) Read(p []byte) (n int, err error)\n    Read reads exactly len(p) bytes into p. It always returns len(p) and a nil\n    error.\n\n    If calls to Read and Uint64 are interleaved, the order in which bits are\n    returned by the two is undefined, and Read may return bits generated before\n    the last call to Uint64.\n\nfunc (c *ChaCha8) Seed(seed [32]byte)\n    Seed resets the ChaCha8 to behave the same way as NewChaCha8(seed).\n\nfunc (c *ChaCha8) Uint64() uint64\n    Uint64 returns a uniformly distributed random uint64 value.\n\nfunc (c *ChaCha8) UnmarshalBinary(data []byte) error\n    UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\n\ntype PCG struct {\n\t// Has unexported fields.\n}\n    A PCG is a PCG generator with 128 bits of internal state. A zero PCG is\n    equivalent to NewPCG(0, 0).\n\nfunc NewPCG(seed1, seed2 uint64) *PCG\n    NewPCG returns a new PCG seeded with the given values.\n\nfunc (p *PCG) AppendBinary(b []byte) ([]byte, error)\n    AppendBinary implements the encoding.BinaryAppender interface.\n\nfunc (p *PCG) MarshalBinary() ([]byte, error)\n    MarshalBinary implements the encoding.BinaryMarshaler interface.\n\nfunc (p *PCG) Seed(seed1, seed2 uint64)\n    Seed resets the PCG to behave the same way as NewPCG(seed1, seed2).\n\nfunc (p *PCG) Uint64() uint64\n    Uint64 return a uniformly-distributed random uint64 value.\n\nfunc (p *PCG) UnmarshalBinary(data []byte) error\n    UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\n\ntype Rand struct {\n\t// Has unexported fields.\n}\n    A Rand is a source of random numbers.\n\nfunc New(src Source) *Rand\n    New returns a new Rand that uses random values from src to generate other\n    random values.\n\nfunc (r *Rand) ExpFloat64() float64\n    ExpFloat64 returns an exponentially distributed float64 in the range (0,\n    +math.MaxFloat64] with an exponential distribution whose rate parameter\n    (lambda) is 1 and whose mean is 1/lambda (1). To produce a distribution with\n    a different rate parameter, callers can adjust the output using:\n\n        sample = ExpFloat64() / desiredRateParameter\n\nfunc (r *Rand) Float32() float32\n    Float32 returns, as a float32, a pseudo-random number in the half-open\n    interval [0.0,1.0).\n\nfunc (r *Rand) Float64() float64\n    Float64 returns, as a float64, a pseudo-random number in the half-open\n    interval [0.0,1.0).\n\nfunc (r *Rand) Int() int\n    Int returns a non-negative pseudo-random int.\n\nfunc (r *Rand) Int32() int32\n    Int32 returns a non-negative pseudo-random 31-bit integer as an int32.\n\nfunc (r *Rand) Int32N(n int32) int32\n    Int32N returns, as an int32, a non-negative pseudo-random number in the\n    half-open interval [0,n). It panics if n <= 0.\n\nfunc (r *Rand) Int64() int64\n    Int64 returns a non-negative pseudo-random 63-bit integer as an int64.\n\nfunc (r *Rand) Int64N(n int64) int64\n    Int64N returns, as an int64, a non-negative pseudo-random number in the\n    half-open interval [0,n). It panics if n <= 0.\n\nfunc (r *Rand) IntN(n int) int\n    IntN returns, as an int, a non-negative pseudo-random number in the\n    half-open interval [0,n). It panics if n <= 0.\n\nfunc (r *Rand) NormFloat64() float64\n    NormFloat64 returns a normally distributed float64 in the range\n    -math.MaxFloat64 through +math.MaxFloat64 inclusive, with standard\n    normal distribution (mean = 0, stddev = 1). To produce a different normal\n    distribution, callers can adjust the output using:\n\n        sample = NormFloat64() * desiredStdDev + desiredMean\n\nfunc (r *Rand) Perm(n int) []int\n    Perm returns, as a slice of n ints, a pseudo-random permutation of the\n    integers in the half-open interval [0,n).\n\nfunc (r *Rand) Shuffle(n int, swap func(i, j int))\n    Shuffle pseudo-randomizes the order of elements. n is the number of\n    elements. Shuffle panics if n < 0. swap swaps the elements with indexes i\n    and j.\n\nfunc (r *Rand) Uint() uint\n    Uint returns a pseudo-random uint.\n\nfunc (r *Rand) Uint32() uint32\n    Uint32 returns a pseudo-random 32-bit value as a uint32.\n\nfunc (r *Rand) Uint32N(n uint32) uint32\n    Uint32N returns, as a uint32, a non-negative pseudo-random number in the\n    half-open interval [0,n). It panics if n == 0.\n\nfunc (r *Rand) Uint64() uint64\n    Uint64 returns a pseudo-random 64-bit value as a uint64.\n\nfunc (r *Rand) Uint64N(n uint64) uint64\n    Uint64N returns, as a uint64, a non-negative pseudo-random number in the\n    half-open interval [0,n). It panics if n == 0.\n\nfunc (r *Rand) UintN(n uint) uint\n    UintN returns, as a uint, a non-negative pseudo-random number in the\n    half-open interval [0,n). It panics if n == 0.\n\ntype Source interface {\n\tUint64() uint64\n}\n    A Source is a source of uniformly-distributed pseudo-random uint64 values in\n    the range [0, 1<<64).\n\n    A Source is not safe for concurrent use by multiple goroutines.\n\ntype Zipf struct {\n\t// Has unexported fields.\n}\n    A Zipf generates Zipf distributed variates.\n\nfunc NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf\n    NewZipf returns a Zipf variate generator. The generator generates values k \u2208\n    [0, imax] such that P(k) is proportional to (v + k) ** (-s). Requirements:\n    s > 1 and v >= 1.\n\nfunc (z *Zipf) Uint64() uint64\n    Uint64 returns a value drawn from the Zipf distribution described by the\n    Zipf object.\n\n"}, {"path": "stdlib/net-rpc-jsonrpc.md", "category": "stdlib", "name": "stdlib/net-rpc-jsonrpc", "content": "package jsonrpc // import \"net/rpc/jsonrpc\"\n\nPackage jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the\nrpc package. For JSON-RPC 2.0 support, see https://godoc.org/?q=json-rpc+2.0\n\nFUNCTIONS\n\nfunc Dial(network, address string) (*rpc.Client, error)\n    Dial connects to a JSON-RPC server at the specified network address.\n\nfunc NewClient(conn io.ReadWriteCloser) *rpc.Client\n    NewClient returns a new rpc.Client to handle requests to the set of services\n    at the other end of the connection.\n\nfunc NewClientCodec(conn io.ReadWriteCloser) rpc.ClientCodec\n    NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n\nfunc NewServerCodec(conn io.ReadWriteCloser) rpc.ServerCodec\n    NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n\nfunc ServeConn(conn io.ReadWriteCloser)\n    ServeConn runs the JSON-RPC server on a single connection. ServeConn blocks,\n    serving the connection until the client hangs up. The caller typically\n    invokes ServeConn in a go statement.\n\n"}, {"path": "stdlib/internal-goexperiment.md", "category": "stdlib", "name": "stdlib/internal-goexperiment", "content": "package goexperiment // import \"internal/goexperiment\"\n\nPackage goexperiment implements support for toolchain experiments.\n\nToolchain experiments are controlled by the GOEXPERIMENT environment variable.\nGOEXPERIMENT is a comma-separated list of experiment names. GOEXPERIMENT can\nbe set at make.bash time, which sets the default experiments for binaries built\nwith the tool chain; or it can be set at build time. GOEXPERIMENT can also be\nset to \"none\", which disables any experiments that were enabled at make.bash\ntime.\n\nExperiments are exposed to the build in the following ways:\n\n  - Build tag goexperiment.x is set if experiment x (lower case) is enabled.\n\n  - For each experiment x (in camel case), this package contains a boolean\n    constant x and an integer constant xInt.\n\n  - In runtime assembly, the macro GOEXPERIMENT_x is defined if experiment x\n    (lower case) is enabled.\n\nIn the toolchain, the set of experiments enabled for the current build should be\naccessed via objabi.Experiment.\n\nThe set of experiments is included in the output of runtime.Version() and \"go\nversion <binary>\" if it differs from the default experiments.\n\nFor the set of experiments supported by the current toolchain, see \"go doc\ngoexperiment.Flags\".\n\nNote that this package defines the set of experiments (in Flags) and records\nthe experiments that were enabled when the package was compiled (as boolean and\ninteger constants).\n\nNote especially that this package does not itself change behavior at run time\nbased on the GOEXPERIMENT variable. The code used in builds to interpret the\nGOEXPERIMENT variable is in the separate package internal/buildcfg.\n\nCONSTANTS\n\nconst AliasTypeParams = true\nconst AliasTypeParamsInt = 1\nconst Arenas = false\nconst ArenasInt = 0\nconst BoringCrypto = false\nconst BoringCryptoInt = 0\nconst CacheProg = false\nconst CacheProgInt = 0\nconst CgoCheck2 = false\nconst CgoCheck2Int = 0\nconst Dwarf5 = false\nconst Dwarf5Int = 0\nconst FieldTrack = false\nconst FieldTrackInt = 0\nconst GreenTeaGC = false\nconst GreenTeaGCInt = 0\nconst HeapMinimum512KiB = false\nconst HeapMinimum512KiBInt = 0\nconst JSONv2 = false\nconst JSONv2Int = 0\nconst LoopVar = false\nconst LoopVarInt = 0\nconst NewInliner = false\nconst NewInlinerInt = 0\nconst PreemptibleLoops = false\nconst PreemptibleLoopsInt = 0\nconst RangeFunc = false\nconst RangeFuncInt = 0\nconst RegabiArgs = true\nconst RegabiArgsInt = 1\nconst RegabiWrappers = true\nconst RegabiWrappersInt = 1\nconst StaticLockRanking = false\nconst StaticLockRankingInt = 0\nconst SwissMap = true\nconst SwissMapInt = 1\nconst SyncHashTrieMap = true\nconst SyncHashTrieMapInt = 1\nconst Synctest = false\nconst SynctestInt = 0\n\nTYPES\n\ntype Flags struct {\n\tFieldTrack        bool\n\tPreemptibleLoops  bool\n\tStaticLockRanking bool\n\tBoringCrypto      bool\n\n\t// RegabiWrappers enables ABI wrappers for calling between\n\t// ABI0 and ABIInternal functions. Without this, the ABIs are\n\t// assumed to be identical so cross-ABI calls are direct.\n\tRegabiWrappers bool\n\t// RegabiArgs enables register arguments/results in all\n\t// compiled Go functions.\n\t//\n\t// Requires wrappers (to do ABI translation), and reflect (so\n\t// reflection calls use registers).\n\tRegabiArgs bool\n\n\t// HeapMinimum512KiB reduces the minimum heap size to 512 KiB.\n\t//\n\t// This was originally reduced as part of PacerRedesign, but\n\t// has been broken out to its own experiment that is disabled\n\t// by default.\n\tHeapMinimum512KiB bool\n\n\t// Arenas causes the \"arena\" standard library package to be visible\n\t// to the outside world.\n\tArenas bool\n\n\t// CgoCheck2 enables an expensive cgo rule checker.\n\t// When this experiment is enabled, cgo rule checks occur regardless\n\t// of the GODEBUG=cgocheck setting provided at runtime.\n\tCgoCheck2 bool\n\n\t// LoopVar changes loop semantics so that each iteration gets its own\n\t// copy of the iteration variable.\n\tLoopVar bool\n\n\t// CacheProg adds support to cmd/go to use a child process to implement\n\t// the build cache; see https://github.com/golang/go/issues/59719.\n\tCacheProg bool\n\n\t// NewInliner enables a new+improved version of the function\n\t// inlining phase within the Go compiler.\n\tNewInliner bool\n\n\t// RangeFunc enables range over func.\n\tRangeFunc bool\n\n\t// AliasTypeParams enables type parameters for alias types.\n\t// Requires that gotypesalias=1 is set with GODEBUG.\n\t// This flag will be removed with Go 1.25.\n\tAliasTypeParams bool\n\n\t// SwissMap enables the SwissTable-based map implementation.\n\tSwissMap bool\n\n\t// SyncHashTrieMap enables the HashTrieMap sync.Map implementation.\n\tSyncHashTrieMap bool\n\n\t// Synctest enables the testing/synctest package.\n\tSynctest bool\n\n\t// Dwarf5 enables DWARF version 5 debug info generation.\n\tDwarf5 bool\n\n\t// JSONv2 enables the json/v2 package.\n\tJSONv2 bool\n\n\t// GreenTeaGC enables the Green Tea GC implementation.\n\tGreenTeaGC bool\n}\n    Flags is the set of experiments that can be enabled or disabled in the\n    current toolchain.\n\n    When specified in the GOEXPERIMENT environment variable or as build tags,\n    experiments use the strings.ToLower of their field name.\n\n    For the baseline experimental configuration, see\n    internal/buildcfg.Experiment.\n\n    If you change this struct definition, run \"go generate\".\n\n"}, {"path": "stdlib/crypto-des.md", "category": "stdlib", "name": "stdlib/crypto-des", "content": "package des // import \"crypto/des\"\n\nPackage des implements the Data Encryption Standard (DES) and the Triple Data\nEncryption Algorithm (TDEA) as defined in U.S. Federal Information Processing\nStandards Publication 46-3.\n\nDES is cryptographically broken and should not be used for secure applications.\n\nCONSTANTS\n\nconst BlockSize = 8\n    The DES block size in bytes.\n\n\nFUNCTIONS\n\nfunc NewCipher(key []byte) (cipher.Block, error)\n    NewCipher creates and returns a new cipher.Block.\n\nfunc NewTripleDESCipher(key []byte) (cipher.Block, error)\n    NewTripleDESCipher creates and returns a new cipher.Block.\n\n\nTYPES\n\ntype KeySizeError int\n\nfunc (k KeySizeError) Error() string\n\n"}, {"path": "stdlib/database-sql.md", "category": "stdlib", "name": "stdlib/database-sql", "content": "package sql // import \"database/sql\"\n\nPackage sql provides a generic interface around SQL (or SQL-like) databases.\n\nThe sql package must be used in conjunction with a database driver. See\nhttps://golang.org/s/sqldrivers for a list of drivers.\n\nDrivers that do not support context cancellation will not return until after the\nquery is completed.\n\nFor usage examples, see the wiki page at https://golang.org/s/sqlwiki.\n\nVARIABLES\n\nvar ErrConnDone = errors.New(\"sql: connection is already closed\")\n    ErrConnDone is returned by any operation that is performed on a connection\n    that has already been returned to the connection pool.\n\nvar ErrNoRows = errors.New(\"sql: no rows in result set\")\n    ErrNoRows is returned by Row.Scan when DB.QueryRow doesn't return a row.\n    In such a case, QueryRow returns a placeholder *Row value that defers this\n    error until a Scan.\n\nvar ErrTxDone = errors.New(\"sql: transaction has already been committed or rolled back\")\n    ErrTxDone is returned by any operation that is performed on a transaction\n    that has already been committed or rolled back.\n\n\nFUNCTIONS\n\nfunc Drivers() []string\n    Drivers returns a sorted list of the names of the registered drivers.\n\nfunc Register(name string, driver driver.Driver)\n    Register makes a database driver available by the provided name. If Register\n    is called twice with the same name or if driver is nil, it panics.\n\n\nTYPES\n\ntype ColumnType struct {\n\t// Has unexported fields.\n}\n    ColumnType contains the name and type of a column.\n\nfunc (ci *ColumnType) DatabaseTypeName() string\n    DatabaseTypeName returns the database system name of the column type.\n    If an empty string is returned, then the driver type name is not supported.\n    Consult your driver documentation for a list of driver data types.\n    ColumnType.Length specifiers are not included. Common type names include\n    \"VARCHAR\", \"TEXT\", \"NVARCHAR\", \"DECIMAL\", \"BOOL\", \"INT\", and \"BIGINT\".\n\nfunc (ci *ColumnType) DecimalSize() (precision, scale int64, ok bool)\n    DecimalSize returns the scale and precision of a decimal type. If not\n    applicable or if not supported ok is false.\n\nfunc (ci *ColumnType) Length() (length int64, ok bool)\n    Length returns the column type length for variable length column types such\n    as text and binary field types. If the type length is unbounded the value\n    will be math.MaxInt64 (any database limits will still apply). If the column\n    type is not variable length, such as an int, or if not supported by the\n    driver ok is false.\n\nfunc (ci *ColumnType) Name() string\n    Name returns the name or alias of the column.\n\nfunc (ci *ColumnType) Nullable() (nullable, ok bool)\n    Nullable reports whether the column may be null. If a driver does not\n    support this property ok will be false.\n\nfunc (ci *ColumnType) ScanType() reflect.Type\n    ScanType returns a Go type suitable for scanning into using Rows.Scan.\n    If a driver does not support this property ScanType will return the type of\n    an empty interface.\n\ntype Conn struct {\n\t// Has unexported fields.\n}\n    Conn represents a single database connection rather than a pool of database\n    connections. Prefer running queries from DB unless there is a specific need\n    for a continuous single database connection.\n\n    A Conn must call Conn.Close to return the connection to the database pool\n    and may do so concurrently with a running query.\n\n    After a call to Conn.Close, all operations on the connection fail with\n    ErrConnDone.\n\nfunc (c *Conn) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)\n    BeginTx starts a transaction.\n\n    The provided context is used until the transaction is committed or rolled\n    back. If the context is canceled, the sql package will roll back the\n    transaction. Tx.Commit will return an error if the context provided to\n    BeginTx is canceled.\n\n    The provided TxOptions is optional and may be nil if defaults should be\n    used. If a non-default isolation level is used that the driver doesn't\n    support, an error will be returned.\n\nfunc (c *Conn) Close() error\n    Close returns the connection to the connection pool. All operations after a\n    Close will return with ErrConnDone. Close is safe to call concurrently with\n    other operations and will block until all other operations finish. It may be\n    useful to first cancel any used context and then call close directly after.\n\nfunc (c *Conn) ExecContext(ctx context.Context, query string, args ...any) (Result, error)\n    ExecContext executes a query without returning any rows. The args are for\n    any placeholder parameters in the query.\n\nfunc (c *Conn) PingContext(ctx context.Context) error\n    PingContext verifies the connection to the database is still alive.\n\nfunc (c *Conn) PrepareContext(ctx context.Context, query string) (*Stmt, error)\n    PrepareContext creates a prepared statement for later queries or executions.\n    Multiple queries or executions may be run concurrently from the returned\n    statement. The caller must call the statement's *Stmt.Close method when the\n    statement is no longer needed.\n\n    The provided context is used for the preparation of the statement, not for\n    the execution of the statement.\n\nfunc (c *Conn) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error)\n    QueryContext executes a query that returns rows, typically a SELECT.\n    The args are for any placeholder parameters in the query.\n\nfunc (c *Conn) QueryRowContext(ctx context.Context, query string, args ...any) *Row\n    QueryRowContext executes a query that is expected to return at most one row.\n    QueryRowContext always returns a non-nil value. Errors are deferred until\n    the *Row.Scan method is called. If the query selects no rows, the *Row.Scan\n    will return ErrNoRows. Otherwise, the *Row.Scan scans the first selected row\n    and discards the rest.\n\nfunc (c *Conn) Raw(f func(driverConn any) error) (err error)\n    Raw executes f exposing the underlying driver connection for the duration of\n    f. The driverConn must not be used outside of f.\n\n    Once f returns and err is not driver.ErrBadConn, the Conn will continue to\n    be usable until Conn.Close is called.\n\ntype DB struct {\n\t// Has unexported fields.\n}\n    DB is a database handle representing a pool of zero or more underlying\n    connections. It's safe for concurrent use by multiple goroutines.\n\n    The sql package creates and frees connections automatically; it also\n    maintains a free pool of idle connections. If the database has a concept\n    of per-connection state, such state can be reliably observed within a\n    transaction (Tx) or connection (Conn). Once DB.Begin is called, the returned\n    Tx is bound to a single connection. Once Tx.Commit or Tx.Rollback is called\n    on the transaction, that transaction's connection is returned to DB's idle\n    connection pool. The pool size can be controlled with DB.SetMaxIdleConns.\n\nfunc Open(driverName, dataSourceName string) (*DB, error)\n    Open opens a database specified by its database driver name and a\n    driver-specific data source name, usually consisting of at least a database\n    name and connection information.\n\n    Most users will open a database via a driver-specific connection helper\n    function that returns a *DB. No database drivers are included in the\n    Go standard library. See https://golang.org/s/sqldrivers for a list of\n    third-party drivers.\n\n    Open may just validate its arguments without creating a connection to the\n    database. To verify that the data source name is valid, call DB.Ping.\n\n    The returned DB is safe for concurrent use by multiple goroutines and\n    maintains its own pool of idle connections. Thus, the Open function should\n    be called just once. It is rarely necessary to close a DB.\n\nfunc OpenDB(c driver.Connector) *DB\n    OpenDB opens a database using a driver.Connector, allowing drivers to bypass\n    a string based data source name.\n\n    Most users will open a database via a driver-specific connection helper\n    function that returns a *DB. No database drivers are included in the\n    Go standard library. See https://golang.org/s/sqldrivers for a list of\n    third-party drivers.\n\n    OpenDB may just validate its arguments without creating a connection to the\n    database. To verify that the data source name is valid, call DB.Ping.\n\n    The returned DB is safe for concurrent use by multiple goroutines and\n    maintains its own pool of idle connections. Thus, the OpenDB function should\n    be called just once. It is rarely necessary to close a DB.\n\nfunc (db *DB) Begin() (*Tx, error)\n    Begin starts a transaction. The default isolation level is dependent on the\n    driver.\n\n    Begin uses context.Background internally; to specify the context, use\n    DB.BeginTx.\n\nfunc (db *DB) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)\n    BeginTx starts a transaction.\n\n    The provided context is used until the transaction is committed or rolled\n    back. If the context is canceled, the sql package will roll back the\n    transaction. Tx.Commit will return an error if the context provided to\n    BeginTx is canceled.\n\n    The provided TxOptions is optional and may be nil if defaults should be\n    used. If a non-default isolation level is used that the driver doesn't\n    support, an error will be returned.\n\nfunc (db *DB) Close() error\n    Close closes the database and prevents new queries from starting. Close then\n    waits for all queries that have started processing on the server to finish.\n\n    It is rare to Close a DB, as the DB handle is meant to be long-lived and\n    shared between many goroutines.\n\nfunc (db *DB) Conn(ctx context.Context) (*Conn, error)\n    Conn returns a single connection by either opening a new connection or\n    returning an existing connection from the connection pool. Conn will block\n    until either a connection is returned or ctx is canceled. Queries run on the\n    same Conn will be run in the same database session.\n\n    Every Conn must be returned to the database pool after use by calling\n    Conn.Close.\n\nfunc (db *DB) Driver() driver.Driver\n    Driver returns the database's underlying driver.\n\nfunc (db *DB) Exec(query string, args ...any) (Result, error)\n    Exec executes a query without returning any rows. The args are for any\n    placeholder parameters in the query.\n\n    Exec uses context.Background internally; to specify the context, use\n    DB.ExecContext.\n\nfunc (db *DB) ExecContext(ctx context.Context, query string, args ...any) (Result, error)\n    ExecContext executes a query without returning any rows. The args are for\n    any placeholder parameters in the query.\n\nfunc (db *DB) Ping() error\n    Ping verifies a connection to the database is still alive, establishing a\n    connection if necessary.\n\n    Ping uses context.Background internally; to specify the context, use\n    DB.PingContext.\n\nfunc (db *DB) PingContext(ctx context.Context) error\n    PingContext verifies a connection to the database is still alive,\n    establishing a connection if necessary.\n\nfunc (db *DB) Prepare(query string) (*Stmt, error)\n    Prepare creates a prepared statement for later queries or executions.\n    Multiple queries or executions may be run concurrently from the returned\n    statement. The caller must call the statement's *Stmt.Close method when the\n    statement is no longer needed.\n\n    Prepare uses context.Background internally; to specify the context,\n    use DB.PrepareContext.\n\nfunc (db *DB) PrepareContext(ctx context.Context, query string) (*Stmt, error)\n    PrepareContext creates a prepared statement for later queries or executions.\n    Multiple queries or executions may be run concurrently from the returned\n    statement. The caller must call the statement's *Stmt.Close method when the\n    statement is no longer needed.\n\n    The provided context is used for the preparation of the statement, not for\n    the execution of the statement.\n\nfunc (db *DB) Query(query string, args ...any) (*Rows, error)\n    Query executes a query that returns rows, typically a SELECT. The args are\n    for any placeholder parameters in the query.\n\n    Query uses context.Background internally; to specify the context, use\n    DB.QueryContext.\n\nfunc (db *DB) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error)\n    QueryContext executes a query that returns rows, typically a SELECT.\n    The args are for any placeholder parameters in the query.\n\nfunc (db *DB) QueryRow(query string, args ...any) *Row\n    QueryRow executes a query that is expected to return at most one row.\n    QueryRow always returns a non-nil value. Errors are deferred until Row's\n    Scan method is called. If the query selects no rows, the *Row.Scan will\n    return ErrNoRows. Otherwise, *Row.Scan scans the first selected row and\n    discards the rest.\n\n    QueryRow uses context.Background internally; to specify the context,\n    use DB.QueryRowContext.\n\nfunc (db *DB) QueryRowContext(ctx context.Context, query string, args ...any) *Row\n    QueryRowContext executes a query that is expected to return at most one row.\n    QueryRowContext always returns a non-nil value. Errors are deferred until\n    Row's Scan method is called. If the query selects no rows, the *Row.Scan\n    will return ErrNoRows. Otherwise, *Row.Scan scans the first selected row and\n    discards the rest.\n\nfunc (db *DB) SetConnMaxIdleTime(d time.Duration)\n    SetConnMaxIdleTime sets the maximum amount of time a connection may be idle.\n\n    Expired connections may be closed lazily before reuse.\n\n    If d <= 0, connections are not closed due to a connection's idle time.\n\nfunc (db *DB) SetConnMaxLifetime(d time.Duration)\n    SetConnMaxLifetime sets the maximum amount of time a connection may be\n    reused.\n\n    Expired connections may be closed lazily before reuse.\n\n    If d <= 0, connections are not closed due to a connection's age.\n\nfunc (db *DB) SetMaxIdleConns(n int)\n    SetMaxIdleConns sets the maximum number of connections in the idle\n    connection pool.\n\n    If MaxOpenConns is greater than 0 but less than the new MaxIdleConns,\n    then the new MaxIdleConns will be reduced to match the MaxOpenConns limit.\n\n    If n <= 0, no idle connections are retained.\n\n    The default max idle connections is currently 2. This may change in a future\n    release.\n\nfunc (db *DB) SetMaxOpenConns(n int)\n    SetMaxOpenConns sets the maximum number of open connections to the database.\n\n    If MaxIdleConns is greater than 0 and the new MaxOpenConns is less\n    than MaxIdleConns, then MaxIdleConns will be reduced to match the new\n    MaxOpenConns limit.\n\n    If n <= 0, then there is no limit on the number of open connections.\n    The default is 0 (unlimited).\n\nfunc (db *DB) Stats() DBStats\n    Stats returns database statistics.\n\ntype DBStats struct {\n\tMaxOpenConnections int // Maximum number of open connections to the database.\n\n\t// Pool Status\n\tOpenConnections int // The number of established connections both in use and idle.\n\tInUse           int // The number of connections currently in use.\n\tIdle            int // The number of idle connections.\n\n\t// Counters\n\tWaitCount         int64         // The total number of connections waited for.\n\tWaitDuration      time.Duration // The total time blocked waiting for a new connection.\n\tMaxIdleClosed     int64         // The total number of connections closed due to SetMaxIdleConns.\n\tMaxIdleTimeClosed int64         // The total number of connections closed due to SetConnMaxIdleTime.\n\tMaxLifetimeClosed int64         // The total number of connections closed due to SetConnMaxLifetime.\n}\n    DBStats contains database statistics.\n\ntype IsolationLevel int\n    IsolationLevel is the transaction isolation level used in TxOptions.\n\nconst (\n\tLevelDefault IsolationLevel = iota\n\tLevelReadUncommitted\n\tLevelReadCommitted\n\tLevelWriteCommitted\n\tLevelRepeatableRead\n\tLevelSnapshot\n\tLevelSerializable\n\tLevelLinearizable\n)\n    Various isolation levels that drivers may support in DB.BeginTx. If a driver\n    does not support a given isolation level an error may be returned.\n\n    See\n    https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.\n\nfunc (i IsolationLevel) String() string\n    String returns the name of the transaction isolation level.\n\ntype NamedArg struct {\n\n\t// Name is the name of the parameter placeholder.\n\t//\n\t// If empty, the ordinal position in the argument list will be\n\t// used.\n\t//\n\t// Name must omit any symbol prefix.\n\tName string\n\n\t// Value is the value of the parameter.\n\t// It may be assigned the same value types as the query\n\t// arguments.\n\tValue any\n\t// Has unexported fields.\n}\n    A NamedArg is a named argument. NamedArg values may be used as arguments to\n    DB.Query or DB.Exec and bind to the corresponding named parameter in the SQL\n    statement.\n\n    For a more concise way to create NamedArg values, see the Named function.\n\nfunc Named(name string, value any) NamedArg\n    Named provides a more concise way to create NamedArg values.\n\n    Example usage:\n\n        db.ExecContext(ctx, `\n            delete from Invoice\n            where\n                TimeCreated < @end\n                and TimeCreated >= @start;`,\n            sql.Named(\"start\", startTime),\n            sql.Named(\"end\", endTime),\n        )\n\ntype Null[T any] struct {\n\tV     T\n\tValid bool\n}\n    Null represents a value that may be null. Null implements the Scanner\n    interface so it can be used as a scan destination:\n\n        var s Null[string]\n        err := db.QueryRow(\"SELECT name FROM foo WHERE id=?\", id).Scan(&s)\n        ...\n        if s.Valid {\n           // use s.V\n        } else {\n           // NULL value\n        }\n\n    T should be one of the types accepted by driver.Value.\n\nfunc (n *Null[T]) Scan(value any) error\n\nfunc (n Null[T]) Value() (driver.Value, error)\n\ntype NullBool struct {\n\tBool  bool\n\tValid bool // Valid is true if Bool is not NULL\n}\n    NullBool represents a bool that may be null. NullBool implements the Scanner\n    interface so it can be used as a scan destination, similar to NullString.\n\nfunc (n *NullBool) Scan(value any) error\n    Scan implements the Scanner interface.\n\nfunc (n NullBool) Value() (driver.Value, error)\n    Value implements the driver.Valuer interface.\n\ntype NullByte struct {\n\tByte  byte\n\tValid bool // Valid is true if Byte is not NULL\n}\n    NullByte represents a byte that may be null. NullByte implements the Scanner\n    interface so it can be used as a scan destination, similar to NullString.\n\nfunc (n *NullByte) Scan(value any) error\n    Scan implements the Scanner interface.\n\nfunc (n NullByte) Value() (driver.Value, error)\n    Value implements the driver.Valuer interface.\n\ntype NullFloat64 struct {\n\tFloat64 float64\n\tValid   bool // Valid is true if Float64 is not NULL\n}\n    NullFloat64 represents a float64 that may be null. NullFloat64 implements\n    the Scanner interface so it can be used as a scan destination, similar to\n    NullString.\n\nfunc (n *NullFloat64) Scan(value any) error\n    Scan implements the Scanner interface.\n\nfunc (n NullFloat64) Value() (driver.Value, error)\n    Value implements the driver.Valuer interface.\n\ntype NullInt16 struct {\n\tInt16 int16\n\tValid bool // Valid is true if Int16 is not NULL\n}\n    NullInt16 represents an int16 that may be null. NullInt16 implements the\n    Scanner interface so it can be used as a scan destination, similar to\n    NullString.\n\nfunc (n *NullInt16) Scan(value any) error\n    Scan implements the Scanner interface.\n\nfunc (n NullInt16) Value() (driver.Value, error)\n    Value implements the driver.Valuer interface.\n\ntype NullInt32 struct {\n\tInt32 int32\n\tValid bool // Valid is true if Int32 is not NULL\n}\n    NullInt32 represents an int32 that may be null. NullInt32 implements the\n    Scanner interface so it can be used as a scan destination, similar to\n    NullString.\n\nfunc (n *NullInt32) Scan(value any) error\n    Scan implements the Scanner interface.\n\nfunc (n NullInt32) Value() (driver.Value, error)\n    Value implements the driver.Valuer interface.\n\ntype NullInt64 struct {\n\tInt64 int64\n\tValid bool // Valid is true if Int64 is not NULL\n}\n    NullInt64 represents an int64 that may be null. NullInt64 implements the\n    Scanner interface so it can be used as a scan destination, similar to\n    NullString.\n\nfunc (n *NullInt64) Scan(value any) error\n    Scan implements the Scanner interface.\n\nfunc (n NullInt64) Value() (driver.Value, error)\n    Value implements the driver.Valuer interface.\n\ntype NullString struct {\n\tString string\n\tValid  bool // Valid is true if String is not NULL\n}\n    NullString represents a string that may be null. NullString implements the\n    Scanner interface so it can be used as a scan destination:\n\n        var s NullString\n        err := db.QueryRow(\"SELECT name FROM foo WHERE id=?\", id).Scan(&s)\n        ...\n        if s.Valid {\n           // use s.String\n        } else {\n           // NULL value\n        }\n\nfunc (ns *NullString) Scan(value any) error\n    Scan implements the Scanner interface.\n\nfunc (ns NullString) Value() (driver.Value, error)\n    Value implements the driver.Valuer interface.\n\ntype NullTime struct {\n\tTime  time.Time\n\tValid bool // Valid is true if Time is not NULL\n}\n    NullTime represents a time.Time that may be null. NullTime implements\n    the Scanner interface so it can be used as a scan destination, similar to\n    NullString.\n\nfunc (n *NullTime) Scan(value any) error\n    Scan implements the Scanner interface.\n\nfunc (n NullTime) Value() (driver.Value, error)\n    Value implements the driver.Valuer interface.\n\ntype Out struct {\n\n\t// Dest is a pointer to the value that will be set to the result of the\n\t// stored procedure's OUTPUT parameter.\n\tDest any\n\n\t// In is whether the parameter is an INOUT parameter. If so, the input value to the stored\n\t// procedure is the dereferenced value of Dest's pointer, which is then replaced with\n\t// the output value.\n\tIn bool\n\t// Has unexported fields.\n}\n    Out may be used to retrieve OUTPUT value parameters from stored procedures.\n\n    Not all drivers and databases support OUTPUT value parameters.\n\n    Example usage:\n\n        var outArg string\n        _, err := db.ExecContext(ctx, \"ProcName\", sql.Named(\"Arg1\", sql.Out{Dest: &outArg}))\n\ntype RawBytes []byte\n    RawBytes is a byte slice that holds a reference to memory owned by the\n    database itself. After a Rows.Scan into a RawBytes, the slice is only valid\n    until the next call to Rows.Next, Rows.Scan, or Rows.Close.\n\ntype Result interface {\n\t// LastInsertId returns the integer generated by the database\n\t// in response to a command. Typically this will be from an\n\t// \"auto increment\" column when inserting a new row. Not all\n\t// databases support this feature, and the syntax of such\n\t// statements varies.\n\tLastInsertId() (int64, error)\n\n\t// RowsAffected returns the number of rows affected by an\n\t// update, insert, or delete. Not every database or database\n\t// driver may support this.\n\tRowsAffected() (int64, error)\n}\n    A Result summarizes an executed SQL command.\n\ntype Row struct {\n\t// Has unexported fields.\n}\n    Row is the result of calling DB.QueryRow to select a single row.\n\nfunc (r *Row) Err() error\n    Err provides a way for wrapping packages to check for query errors without\n    calling Row.Scan. Err returns the error, if any, that was encountered\n    while running the query. If this error is not nil, this error will also be\n    returned from Row.Scan.\n\nfunc (r *Row) Scan(dest ...any) error\n    Scan copies the columns from the matched row into the values pointed at by\n    dest. See the documentation on Rows.Scan for details. If more than one row\n    matches the query, Scan uses the first row and discards the rest. If no row\n    matches the query, Scan returns ErrNoRows.\n\ntype Rows struct {\n\t// Has unexported fields.\n}\n    Rows is the result of a query. Its cursor starts before the first row of the\n    result set. Use Rows.Next to advance from row to row.\n\nfunc (rs *Rows) Close() error\n    Close closes the Rows, preventing further enumeration. If Rows.Next is\n    called and returns false and there are no further result sets, the Rows are\n    closed automatically and it will suffice to check the result of Rows.Err.\n    Close is idempotent and does not affect the result of Rows.Err.\n\nfunc (rs *Rows) ColumnTypes() ([]*ColumnType, error)\n    ColumnTypes returns column information such as column type, length,\n    and nullable. Some information may not be available from some drivers.\n\nfunc (rs *Rows) Columns() ([]string, error)\n    Columns returns the column names. Columns returns an error if the rows are\n    closed.\n\nfunc (rs *Rows) Err() error\n    Err returns the error, if any, that was encountered during iteration.\n    Err may be called after an explicit or implicit Rows.Close.\n\nfunc (rs *Rows) Next() bool\n    Next prepares the next result row for reading with the Rows.Scan method. It\n    returns true on success, or false if there is no next result row or an error\n    happened while preparing it. Rows.Err should be consulted to distinguish\n    between the two cases.\n\n    Every call to Rows.Scan, even the first one, must be preceded by a call to\n    Rows.Next.\n\nfunc (rs *Rows) NextResultSet() bool\n    NextResultSet prepares the next result set for reading. It reports whether\n    there is further result sets, or false if there is no further result set\n    or if there is an error advancing to it. The Rows.Err method should be\n    consulted to distinguish between the two cases.\n\n    After calling NextResultSet, the Rows.Next method should always be called\n    before scanning. If there are further result sets they may not have rows in\n    the result set.\n\nfunc (rs *Rows) Scan(dest ...any) error\n    Scan copies the columns in the current row into the values pointed at by\n    dest. The number of values in dest must be the same as the number of columns\n    in Rows.\n\n    Scan converts columns read from the database into the following common Go\n    types and special types provided by the sql package:\n\n        *string\n        *[]byte\n        *int, *int8, *int16, *int32, *int64\n        *uint, *uint8, *uint16, *uint32, *uint64\n        *bool\n        *float32, *float64\n        *interface{}\n        *RawBytes\n        *Rows (cursor value)\n        any type implementing Scanner (see Scanner docs)\n\n    In the most simple case, if the type of the value from the source column\n    is an integer, bool or string type T and dest is of type *T, Scan simply\n    assigns the value through the pointer.\n\n    Scan also converts between string and numeric types, as long as no\n    information would be lost. While Scan stringifies all numbers scanned from\n    numeric database columns into *string, scans into numeric types are checked\n    for overflow. For example, a float64 with value 300 or a string with value\n    \"300\" can scan into a uint16, but not into a uint8, though float64(255) or\n    \"255\" can scan into a uint8. One exception is that scans of some float64\n    numbers to strings may lose information when stringifying. In general,\n    scan floating point columns into *float64.\n\n    If a dest argument has type *[]byte, Scan saves in that argument a copy of\n    the corresponding data. The copy is owned by the caller and can be modified\n    and held indefinitely. The copy can be avoided by using an argument of type\n    *RawBytes instead; see the documentation for RawBytes for restrictions on\n    its use.\n\n    If an argument has type *interface{}, Scan copies the value provided by the\n    underlying driver without conversion. When scanning from a source value of\n    type []byte to *interface{}, a copy of the slice is made and the caller owns\n    the result.\n\n    Source values of type time.Time may be scanned into values of type\n    *time.Time, *interface{}, *string, or *[]byte. When converting to the latter\n    two, time.RFC3339Nano is used.\n\n    Source values of type bool may be scanned into types *bool, *interface{},\n    *string, *[]byte, or *RawBytes.\n\n    For scanning into *bool, the source may be true, false, 1, 0, or string\n    inputs parseable by strconv.ParseBool.\n\n    Scan can also convert a cursor returned from a query, such as \"select\n    cursor(select * from my_table) from dual\", into a *Rows value that can\n    itself be scanned from. The parent select query will close any cursor *Rows\n    if the parent *Rows is closed.\n\n    If any of the first arguments implementing Scanner returns an error,\n    that error will be wrapped in the returned error.\n\ntype Scanner interface {\n\t// Scan assigns a value from a database driver.\n\t//\n\t// The src value will be of one of the following types:\n\t//\n\t//    int64\n\t//    float64\n\t//    bool\n\t//    []byte\n\t//    string\n\t//    time.Time\n\t//    nil - for NULL values\n\t//\n\t// An error should be returned if the value cannot be stored\n\t// without loss of information.\n\t//\n\t// Reference types such as []byte are only valid until the next call to Scan\n\t// and should not be retained. Their underlying memory is owned by the driver.\n\t// If retention is necessary, copy their values before the next call to Scan.\n\tScan(src any) error\n}\n    Scanner is an interface used by Rows.Scan.\n\ntype Stmt struct {\n\t// Has unexported fields.\n}\n    Stmt is a prepared statement. A Stmt is safe for concurrent use by multiple\n    goroutines.\n\n    If a Stmt is prepared on a Tx or Conn, it will be bound to a single\n    underlying connection forever. If the Tx or Conn closes, the Stmt will\n    become unusable and all operations will return an error. If a Stmt is\n    prepared on a DB, it will remain usable for the lifetime of the DB. When the\n    Stmt needs to execute on a new underlying connection, it will prepare itself\n    on the new connection automatically.\n\nfunc (s *Stmt) Close() error\n    Close closes the statement.\n\nfunc (s *Stmt) Exec(args ...any) (Result, error)\n    Exec executes a prepared statement with the given arguments and returns a\n    Result summarizing the effect of the statement.\n\n    Exec uses context.Background internally; to specify the context, use\n    Stmt.ExecContext.\n\nfunc (s *Stmt) ExecContext(ctx context.Context, args ...any) (Result, error)\n    ExecContext executes a prepared statement with the given arguments and\n    returns a Result summarizing the effect of the statement.\n\nfunc (s *Stmt) Query(args ...any) (*Rows, error)\n    Query executes a prepared query statement with the given arguments and\n    returns the query results as a *Rows.\n\n    Query uses context.Background internally; to specify the context, use\n    Stmt.QueryContext.\n\nfunc (s *Stmt) QueryContext(ctx context.Context, args ...any) (*Rows, error)\n    QueryContext executes a prepared query statement with the given arguments\n    and returns the query results as a *Rows.\n\nfunc (s *Stmt) QueryRow(args ...any) *Row\n    QueryRow executes a prepared query statement with the given arguments.\n    If an error occurs during the execution of the statement, that error will be\n    returned by a call to Scan on the returned *Row, which is always non-nil. If\n    the query selects no rows, the *Row.Scan will return ErrNoRows. Otherwise,\n    the *Row.Scan scans the first selected row and discards the rest.\n\n    Example usage:\n\n        var name string\n        err := nameByUseridStmt.QueryRow(id).Scan(&name)\n\n    QueryRow uses context.Background internally; to specify the context,\n    use Stmt.QueryRowContext.\n\nfunc (s *Stmt) QueryRowContext(ctx context.Context, args ...any) *Row\n    QueryRowContext executes a prepared query statement with the given\n    arguments. If an error occurs during the execution of the statement,\n    that error will be returned by a call to Scan on the returned *Row,\n    which is always non-nil. If the query selects no rows, the *Row.Scan will\n    return ErrNoRows. Otherwise, the *Row.Scan scans the first selected row and\n    discards the rest.\n\ntype Tx struct {\n\t// Has unexported fields.\n}\n    Tx is an in-progress database transaction.\n\n    A transaction must end with a call to Tx.Commit or Tx.Rollback.\n\n    After a call to Tx.Commit or Tx.Rollback, all operations on the transaction\n    fail with ErrTxDone.\n\n    The statements prepared for a transaction by calling the transaction's\n    Tx.Prepare or Tx.Stmt methods are closed by the call to Tx.Commit or\n    Tx.Rollback.\n\nfunc (tx *Tx) Commit() error\n    Commit commits the transaction.\n\nfunc (tx *Tx) Exec(query string, args ...any) (Result, error)\n    Exec executes a query that doesn't return rows. For example: an INSERT and\n    UPDATE.\n\n    Exec uses context.Background internally; to specify the context, use\n    Tx.ExecContext.\n\nfunc (tx *Tx) ExecContext(ctx context.Context, query string, args ...any) (Result, error)\n    ExecContext executes a query that doesn't return rows. For example:\n    an INSERT and UPDATE.\n\nfunc (tx *Tx) Prepare(query string) (*Stmt, error)\n    Prepare creates a prepared statement for use within a transaction.\n\n    The returned statement operates within the transaction and will be closed\n    when the transaction has been committed or rolled back.\n\n    To use an existing prepared statement on this transaction, see Tx.Stmt.\n\n    Prepare uses context.Background internally; to specify the context,\n    use Tx.PrepareContext.\n\nfunc (tx *Tx) PrepareContext(ctx context.Context, query string) (*Stmt, error)\n    PrepareContext creates a prepared statement for use within a transaction.\n\n    The returned statement operates within the transaction and will be closed\n    when the transaction has been committed or rolled back.\n\n    To use an existing prepared statement on this transaction, see Tx.Stmt.\n\n    The provided context will be used for the preparation of the context,\n    not for the execution of the returned statement. The returned statement will\n    run in the transaction context.\n\nfunc (tx *Tx) Query(query string, args ...any) (*Rows, error)\n    Query executes a query that returns rows, typically a SELECT.\n\n    Query uses context.Background internally; to specify the context, use\n    Tx.QueryContext.\n\nfunc (tx *Tx) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error)\n    QueryContext executes a query that returns rows, typically a SELECT.\n\nfunc (tx *Tx) QueryRow(query string, args ...any) *Row\n    QueryRow executes a query that is expected to return at most one row.\n    QueryRow always returns a non-nil value. Errors are deferred until Row's\n    Scan method is called. If the query selects no rows, the *Row.Scan will\n    return ErrNoRows. Otherwise, the *Row.Scan scans the first selected row and\n    discards the rest.\n\n    QueryRow uses context.Background internally; to specify the context,\n    use Tx.QueryRowContext.\n\nfunc (tx *Tx) QueryRowContext(ctx context.Context, query string, args ...any) *Row\n    QueryRowContext executes a query that is expected to return at most one row.\n    QueryRowContext always returns a non-nil value. Errors are deferred until\n    Row's Scan method is called. If the query selects no rows, the *Row.Scan\n    will return ErrNoRows. Otherwise, the *Row.Scan scans the first selected row\n    and discards the rest.\n\nfunc (tx *Tx) Rollback() error\n    Rollback aborts the transaction.\n\nfunc (tx *Tx) Stmt(stmt *Stmt) *Stmt\n    Stmt returns a transaction-specific prepared statement from an existing\n    statement.\n\n    Example:\n\n        updateMoney, err := db.Prepare(\"UPDATE balance SET money=money+? WHERE id=?\")\n        ...\n        tx, err := db.Begin()\n        ...\n        res, err := tx.Stmt(updateMoney).Exec(123.45, 98293203)\n\n    The returned statement operates within the transaction and will be closed\n    when the transaction has been committed or rolled back.\n\n    Stmt uses context.Background internally; to specify the context, use\n    Tx.StmtContext.\n\nfunc (tx *Tx) StmtContext(ctx context.Context, stmt *Stmt) *Stmt\n    StmtContext returns a transaction-specific prepared statement from an\n    existing statement.\n\n    Example:\n\n        updateMoney, err := db.Prepare(\"UPDATE balance SET money=money+? WHERE id=?\")\n        ...\n        tx, err := db.Begin()\n        ...\n        res, err := tx.StmtContext(ctx, updateMoney).Exec(123.45, 98293203)\n\n    The provided context is used for the preparation of the statement, not for\n    the execution of the statement.\n\n    The returned statement operates within the transaction and will be closed\n    when the transaction has been committed or rolled back.\n\ntype TxOptions struct {\n\t// Isolation is the transaction isolation level.\n\t// If zero, the driver or database's default level is used.\n\tIsolation IsolationLevel\n\tReadOnly  bool\n}\n    TxOptions holds the transaction options to be used in DB.BeginTx.\n\n"}, {"path": "stdlib/net-smtp.md", "category": "stdlib", "name": "stdlib/net-smtp", "content": "package smtp // import \"net/smtp\"\n\nPackage smtp implements the Simple Mail Transfer Protocol as defined in RFC\n5321. It also implements the following extensions:\n\n    8BITMIME  RFC 1652\n    AUTH      RFC 2554\n    STARTTLS  RFC 3207\n\nAdditional extensions may be handled by clients.\n\nThe smtp package is frozen and is not accepting new features. Some external\npackages provide more functionality. See:\n\n    https://godoc.org/?q=smtp\n\nFUNCTIONS\n\nfunc SendMail(addr string, a Auth, from string, to []string, msg []byte) error\n    SendMail connects to the server at addr, switches to TLS if possible,\n    authenticates with the optional mechanism a if possible, and then sends an\n    email from address from, to addresses to, with message msg. The addr must\n    include a port, as in \"mail.example.com:smtp\".\n\n    The addresses in the to parameter are the SMTP RCPT addresses.\n\n    The msg parameter should be an RFC 822-style email with headers first,\n    a blank line, and then the message body. The lines of msg should be CRLF\n    terminated. The msg headers should usually include fields such as \"From\",\n    \"To\", \"Subject\", and \"Cc\". Sending \"Bcc\" messages is accomplished by\n    including an email address in the to parameter but not including it in the\n    msg headers.\n\n    The SendMail function and the net/smtp package are low-level mechanisms\n    and provide no support for DKIM signing, MIME attachments (see the\n    mime/multipart package), or other mail functionality. Higher-level packages\n    exist outside of the standard library.\n\n\nTYPES\n\ntype Auth interface {\n\t// Start begins an authentication with a server.\n\t// It returns the name of the authentication protocol\n\t// and optionally data to include in the initial AUTH message\n\t// sent to the server.\n\t// If it returns a non-nil error, the SMTP client aborts\n\t// the authentication attempt and closes the connection.\n\tStart(server *ServerInfo) (proto string, toServer []byte, err error)\n\n\t// Next continues the authentication. The server has just sent\n\t// the fromServer data. If more is true, the server expects a\n\t// response, which Next should return as toServer; otherwise\n\t// Next should return toServer == nil.\n\t// If Next returns a non-nil error, the SMTP client aborts\n\t// the authentication attempt and closes the connection.\n\tNext(fromServer []byte, more bool) (toServer []byte, err error)\n}\n    Auth is implemented by an SMTP authentication mechanism.\n\nfunc CRAMMD5Auth(username, secret string) Auth\n    CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\n    mechanism as defined in RFC 2195. The returned Auth uses the given username\n    and secret to authenticate to the server using the challenge-response\n    mechanism.\n\nfunc PlainAuth(identity, username, password, host string) Auth\n    PlainAuth returns an Auth that implements the PLAIN authentication mechanism\n    as defined in RFC 4616. The returned Auth uses the given username and\n    password to authenticate to host and act as identity. Usually identity\n    should be the empty string, to act as username.\n\n    PlainAuth will only send the credentials if the connection is using TLS or\n    is connected to localhost. Otherwise authentication will fail with an error,\n    without sending the credentials.\n\ntype Client struct {\n\t// Text is the textproto.Conn used by the Client. It is exported to allow for\n\t// clients to add extensions.\n\tText *textproto.Conn\n\n\t// Has unexported fields.\n}\n    A Client represents a client connection to an SMTP server.\n\nfunc Dial(addr string) (*Client, error)\n    Dial returns a new Client connected to an SMTP server at addr. The addr must\n    include a port, as in \"mail.example.com:smtp\".\n\nfunc NewClient(conn net.Conn, host string) (*Client, error)\n    NewClient returns a new Client using an existing connection and host as a\n    server name to be used when authenticating.\n\nfunc (c *Client) Auth(a Auth) error\n    Auth authenticates a client using the provided authentication mechanism.\n    A failed authentication closes the connection. Only servers that advertise\n    the AUTH extension support this function.\n\nfunc (c *Client) Close() error\n    Close closes the connection.\n\nfunc (c *Client) Data() (io.WriteCloser, error)\n    Data issues a DATA command to the server and returns a writer that can be\n    used to write the mail headers and body. The caller should close the writer\n    before calling any more methods on c. A call to Data must be preceded by one\n    or more calls to Client.Rcpt.\n\nfunc (c *Client) Extension(ext string) (bool, string)\n    Extension reports whether an extension is support by the server. The\n    extension name is case-insensitive. If the extension is supported, Extension\n    also returns a string that contains any parameters the server specifies for\n    the extension.\n\nfunc (c *Client) Hello(localName string) error\n    Hello sends a HELO or EHLO to the server as the given host name. Calling\n    this method is only necessary if the client needs control over the host\n    name used. The client will introduce itself as \"localhost\" automatically\n    otherwise. If Hello is called, it must be called before any of the other\n    methods.\n\nfunc (c *Client) Mail(from string) error\n    Mail issues a MAIL command to the server using the provided email address.\n    If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME\n    parameter. If the server supports the SMTPUTF8 extension, Mail adds the\n    SMTPUTF8 parameter. This initiates a mail transaction and is followed by one\n    or more Client.Rcpt calls.\n\nfunc (c *Client) Noop() error\n    Noop sends the NOOP command to the server. It does nothing but check that\n    the connection to the server is okay.\n\nfunc (c *Client) Quit() error\n    Quit sends the QUIT command and closes the connection to the server.\n\nfunc (c *Client) Rcpt(to string) error\n    Rcpt issues a RCPT command to the server using the provided email address.\n    A call to Rcpt must be preceded by a call to Client.Mail and may be followed\n    by a Client.Data call or another Rcpt call.\n\nfunc (c *Client) Reset() error\n    Reset sends the RSET command to the server, aborting the current mail\n    transaction.\n\nfunc (c *Client) StartTLS(config *tls.Config) error\n    StartTLS sends the STARTTLS command and encrypts all further communication.\n    Only servers that advertise the STARTTLS extension support this function.\n\nfunc (c *Client) TLSConnectionState() (state tls.ConnectionState, ok bool)\n    TLSConnectionState returns the client's TLS connection state. The return\n    values are their zero values if Client.StartTLS did not succeed.\n\nfunc (c *Client) Verify(addr string) error\n    Verify checks the validity of an email address on the server. If Verify\n    returns nil, the address is valid. A non-nil return does not necessarily\n    indicate an invalid address. Many servers will not verify addresses for\n    security reasons.\n\ntype ServerInfo struct {\n\tName string   // SMTP server name\n\tTLS  bool     // using TLS, with valid certificate for Name\n\tAuth []string // advertised authentication mechanisms\n}\n    ServerInfo records information about an SMTP server.\n\n"}, {"path": "stdlib/internal-sync.md", "category": "stdlib", "name": "stdlib/internal-sync", "content": "package sync // import \"internal/sync\"\n\nPackage sync provides basic synchronization primitives such as mutual exclusion\nlocks to internal packages (including ones that depend on sync).\n\nTests are defined in package sync.\n\nTYPES\n\ntype HashTrieMap[K comparable, V any] struct {\n\t// Has unexported fields.\n}\n    HashTrieMap is an implementation of a concurrent hash-trie.\n    The implementation is designed around frequent loads, but offers decent\n    performance for stores and deletes as well, especially if the map is larger.\n    Its primary use-case is the unique package, but can be used elsewhere as\n    well.\n\n    The zero HashTrieMap is empty and ready to use. It must not be copied after\n    first use.\n\nfunc (ht *HashTrieMap[K, V]) All() func(yield func(K, V) bool)\n    All returns an iterator over each key and value present in the map.\n\n    The iterator does not necessarily correspond to any consistent snapshot\n    of the HashTrieMap's contents: no key will be visited more than once,\n    but if the value for any key is stored or deleted concurrently (including\n    by yield), the iterator may reflect any mapping for that key from any point\n    during iteration. The iterator does not block other methods on the receiver;\n    even yield itself may call any method on the HashTrieMap.\n\nfunc (ht *HashTrieMap[K, V]) Clear()\n    Clear deletes all the entries, resulting in an empty HashTrieMap.\n\nfunc (ht *HashTrieMap[K, V]) CompareAndDelete(key K, old V) (deleted bool)\n    CompareAndDelete deletes the entry for key if its value is equal to old. The\n    value type must be comparable, otherwise this CompareAndDelete will panic.\n\n    If there is no current value for key in the map, CompareAndDelete returns\n    false (even if the old value is the nil interface value).\n\nfunc (ht *HashTrieMap[K, V]) CompareAndSwap(key K, old, new V) (swapped bool)\n    CompareAndSwap swaps the old and new values for key if the value stored\n    in the map is equal to old. The value type must be of a comparable type,\n    otherwise CompareAndSwap will panic.\n\nfunc (ht *HashTrieMap[K, V]) Delete(key K)\n    Delete deletes the value for a key.\n\nfunc (ht *HashTrieMap[K, V]) Load(key K) (value V, ok bool)\n    Load returns the value stored in the map for a key, or nil if no value is\n    present. The ok result indicates whether value was found in the map.\n\nfunc (ht *HashTrieMap[K, V]) LoadAndDelete(key K) (value V, loaded bool)\n    LoadAndDelete deletes the value for a key, returning the previous value if\n    any. The loaded result reports whether the key was present.\n\nfunc (ht *HashTrieMap[K, V]) LoadOrStore(key K, value V) (result V, loaded bool)\n    LoadOrStore returns the existing value for the key if present. Otherwise,\n    it stores and returns the given value. The loaded result is true if the\n    value was loaded, false if stored.\n\nfunc (ht *HashTrieMap[K, V]) Range(yield func(K, V) bool)\n    Range calls f sequentially for each key and value present in the map.\n    If f returns false, range stops the iteration.\n\n    This exists for compatibility with sync.Map; All should be preferred.\n    It provides the same guarantees as sync.Map, and All.\n\nfunc (ht *HashTrieMap[K, V]) Store(key K, old V)\n    Store sets the value for a key.\n\nfunc (ht *HashTrieMap[K, V]) Swap(key K, new V) (previous V, loaded bool)\n    Swap swaps the value for a key and returns the previous value if any.\n    The loaded result reports whether the key was present.\n\ntype Mutex struct {\n\t// Has unexported fields.\n}\n    A Mutex is a mutual exclusion lock.\n\n    See package sync.Mutex documentation.\n\nfunc (m *Mutex) Lock()\n    Lock locks m.\n\n    See package sync.Mutex documentation.\n\nfunc (m *Mutex) TryLock() bool\n    TryLock tries to lock m and reports whether it succeeded.\n\n    See package sync.Mutex documentation.\n\nfunc (m *Mutex) Unlock()\n    Unlock unlocks m.\n\n    See package sync.Mutex documentation.\n\n"}, {"path": "stdlib/internal-trace-traceviewer.md", "category": "stdlib", "name": "stdlib/internal-trace-traceviewer", "content": "package traceviewer // import \"internal/trace/traceviewer\"\n\n\nCONSTANTS\n\nconst (\n\t// Special P identifiers:\n\tFakeP    = 1000000 + iota\n\tTimerP   // depicts timer unblocks\n\tNetpollP // depicts network unblocks\n\tSyscallP // depicts returns from syscalls\n\tGCP      // depicts GC state\n\tProfileP // depicts recording of CPU profile samples\n)\nconst CommonStyle = `\n/* See https://github.com/golang/pkgsite/blob/master/static/shared/typography/typography.css */\nbody {\n  font-family:\t-apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji';\n  font-size:\t1rem;\n  line-height:\tnormal;\n  max-width:\t9in;\n  margin:\t1em;\n}\nh1 { font-size: 1.5rem; }\nh2 { font-size: 1.375rem; }\nh1,h2 {\n  font-weight: 600;\n  line-height: 1.25em;\n  word-break: break-word;\n}\np  { color: grey85; font-size:85%; }\ncode,\npre,\ntextarea.code {\n  font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;\n  font-size: 0.875rem;\n  line-height: 1.5em;\n}\n\npre,\ntextarea.code {\n  background-color: var(--color-background-accented);\n  border: var(--border);\n  border-radius: var(--border-radius);\n  color: var(--color-text);\n  overflow-x: auto;\n  padding: 0.625rem;\n  tab-size: 4;\n  white-space: pre;\n}\n`\n\nFUNCTIONS\n\nfunc BuildProfile(prof []ProfileRecord) *profile.Profile\nfunc MMUHandlerFunc(ranges []Range, f MutatorUtilFunc) http.HandlerFunc\nfunc MainHandler(views []View) http.Handler\nfunc SVGProfileHandlerFunc(f ProfileFunc) http.HandlerFunc\n    SVGProfileHandlerFunc serves pprof-like profile generated by prof as svg.\n\nfunc SplittingTraceConsumer(max int) (*splitter, TraceConsumer)\nfunc StaticHandler() http.Handler\nfunc TraceHandler() http.Handler\nfunc WalkStackFrames(allFrames map[string]format.Frame, id int, fn func(id int))\n    WalkStackFrames calls fn for id and all of its parent frames from allFrames.\n\n\nTYPES\n\ntype ArrowEvent struct {\n\tName         string\n\tStart        time.Duration\n\tEnd          time.Duration\n\tFromResource uint64\n\tFromStack    int\n\tToResource   uint64\n}\n\ntype AsyncSliceEvent struct {\n\tSliceEvent\n\tCategory       string\n\tScope          string\n\tTaskColorIndex uint64 // Take on the same color as the task with this ID.\n}\n\ntype Emitter struct {\n\t// Has unexported fields.\n}\n\nfunc NewEmitter(c TraceConsumer, rangeStart, rangeEnd time.Duration) *Emitter\n    NewEmitter returns a new Emitter that writes to c. The rangeStart and\n    rangeEnd args are used for splitting large traces.\n\nfunc (e *Emitter) Arrow(a ArrowEvent)\n\nfunc (e *Emitter) AsyncSlice(s AsyncSliceEvent)\n\nfunc (e *Emitter) Err() error\n    Err returns an error if the emitter is in an invalid state.\n\nfunc (e *Emitter) Event(ev *format.Event)\n\nfunc (e *Emitter) Flush()\n\nfunc (e *Emitter) Focus(id uint64)\n\nfunc (e *Emitter) Gomaxprocs(v uint64)\n\nfunc (e *Emitter) GoroutineTransition(ts time.Duration, from, to GState)\n\nfunc (e *Emitter) HeapAlloc(ts time.Duration, v uint64)\n\nfunc (e *Emitter) HeapGoal(ts time.Duration, v uint64)\n\nfunc (e *Emitter) IncThreadStateCount(ts time.Duration, state ThreadState, delta int64)\n\nfunc (e *Emitter) Instant(i InstantEvent)\n\nfunc (e *Emitter) OptionalEvent(ev *format.Event)\n    OptionalEvent emits ev if it's within the time range of the consumer, i.e.\n    the selected trace split range.\n\nfunc (e *Emitter) Resource(id uint64, name string)\n\nfunc (e *Emitter) SetResourceFilter(filter func(uint64) bool)\n\nfunc (e *Emitter) SetResourceType(name string)\n\nfunc (e *Emitter) Slice(s SliceEvent)\n\nfunc (e *Emitter) Stack(stk []trace.StackFrame) int\n    Stack emits the given frames and returns a unique id for the stack.\n    No pointers to the given data are being retained beyond the call to Stack.\n\nfunc (e *Emitter) Task(id uint64, name string, sortIndex int)\n\nfunc (e *Emitter) TaskArrow(a ArrowEvent)\n\nfunc (e *Emitter) TaskSlice(s SliceEvent)\n\ntype GState int\n\nconst (\n\tGDead GState = iota\n\tGRunnable\n\tGRunning\n\tGWaiting\n\tGWaitingGC\n)\ntype InstantEvent struct {\n\tTs       time.Duration\n\tName     string\n\tCategory string\n\tResource uint64\n\tStack    int\n\tArg      any\n}\n\ntype Mode int\n\nconst (\n\tModeGoroutineOriented Mode = 1 << iota\n\tModeTaskOriented\n\tModeThreadOriented // Mutually exclusive with ModeGoroutineOriented.\n)\ntype MutatorUtilFunc func(trace.UtilFlags) ([][]trace.MutatorUtil, error)\n\ntype ProfileFunc func(r *http.Request) ([]ProfileRecord, error)\n\ntype ProfileRecord struct {\n\tStack []trace.StackFrame\n\tCount uint64\n\tTime  time.Duration\n}\n\ntype Range struct {\n\tName      string\n\tStart     int\n\tEnd       int\n\tStartTime int64\n\tEndTime   int64\n}\n\nfunc (r Range) URL(viewType ViewType) string\n\ntype SliceEvent struct {\n\tName     string\n\tTs       time.Duration\n\tDur      time.Duration\n\tResource uint64\n\tStack    int\n\tEndStack int\n\tArg      any\n}\n\ntype ThreadState int\n\nconst (\n\tThreadStateInSyscall ThreadState = iota\n\tThreadStateInSyscallRuntime\n\tThreadStateRunning\n)\ntype TimeHistogram struct {\n\tCount                int\n\tBuckets              []int\n\tMinBucket, MaxBucket int\n}\n    TimeHistogram is an high-dynamic-range histogram for durations.\n\nfunc (h *TimeHistogram) Add(d time.Duration)\n    Add adds a single sample to the histogram.\n\nfunc (h *TimeHistogram) BucketMin(bucket int) time.Duration\n    BucketMin returns the minimum duration value for a provided bucket.\n\nfunc (h *TimeHistogram) ToHTML(urlmaker func(min, max time.Duration) string) template.HTML\n    ToHTML renders the histogram as HTML.\n\ntype TraceConsumer struct {\n\tConsumeTimeUnit    func(unit string)\n\tConsumeViewerEvent func(v *format.Event, required bool)\n\tConsumeViewerFrame func(key string, f format.Frame)\n\tFlush              func()\n}\n\nfunc ViewerDataTraceConsumer(w io.Writer, startIdx, endIdx int64) TraceConsumer\n    ViewerDataTraceConsumer returns a TraceConsumer that writes to w.\n    The startIdx and endIdx are used for splitting large traces. They refer to\n    indexes in the traceEvents output array, not the events in the trace input.\n\ntype View struct {\n\tType   ViewType\n\tRanges []Range\n}\n\nfunc (v View) URL(rangeIdx int) string\n\ntype ViewType string\n\nconst (\n\tViewProc   ViewType = \"proc\"\n\tViewThread ViewType = \"thread\"\n)\n"}, {"path": "stdlib/strings.md", "category": "stdlib", "name": "stdlib/strings", "content": "package strings // import \"strings\"\n\nPackage strings implements simple functions to manipulate UTF-8 encoded strings.\n\nFor information about UTF-8 strings in Go, see https://blog.golang.org/strings.\n\nFUNCTIONS\n\nfunc Clone(s string) string\n    Clone returns a fresh copy of s. It guarantees to make a copy of s into a\n    new allocation, which can be important when retaining only a small substring\n    of a much larger string. Using Clone can help such programs use less memory.\n    Of course, since using Clone makes a copy, overuse of Clone can make\n    programs use more memory. Clone should typically be used only rarely,\n    and only when profiling indicates that it is needed. For strings of length\n    zero the string \"\" will be returned and no allocation is made.\n\nfunc Compare(a, b string) int\n    Compare returns an integer comparing two strings lexicographically.\n    The result will be 0 if a == b, -1 if a < b, and +1 if a > b.\n\n    Use Compare when you need to perform a three-way comparison (with\n    slices.SortFunc, for example). It is usually clearer and always faster to\n    use the built-in string comparison operators ==, <, >, and so on.\n\nfunc Contains(s, substr string) bool\n    Contains reports whether substr is within s.\n\nfunc ContainsAny(s, chars string) bool\n    ContainsAny reports whether any Unicode code points in chars are within s.\n\nfunc ContainsFunc(s string, f func(rune) bool) bool\n    ContainsFunc reports whether any Unicode code points r within s satisfy\n    f(r).\n\nfunc ContainsRune(s string, r rune) bool\n    ContainsRune reports whether the Unicode code point r is within s.\n\nfunc Count(s, substr string) int\n    Count counts the number of non-overlapping instances of substr in s.\n    If substr is an empty string, Count returns 1 + the number of Unicode code\n    points in s.\n\nfunc Cut(s, sep string) (before, after string, found bool)\n    Cut slices s around the first instance of sep, returning the text before and\n    after sep. The found result reports whether sep appears in s. If sep does\n    not appear in s, cut returns s, \"\", false.\n\nfunc CutPrefix(s, prefix string) (after string, found bool)\n    CutPrefix returns s without the provided leading prefix string and reports\n    whether it found the prefix. If s doesn't start with prefix, CutPrefix\n    returns s, false. If prefix is the empty string, CutPrefix returns s, true.\n\nfunc CutSuffix(s, suffix string) (before string, found bool)\n    CutSuffix returns s without the provided ending suffix string and reports\n    whether it found the suffix. If s doesn't end with suffix, CutSuffix returns\n    s, false. If suffix is the empty string, CutSuffix returns s, true.\n\nfunc EqualFold(s, t string) bool\n    EqualFold reports whether s and t, interpreted as UTF-8 strings,\n    are equal under simple Unicode case-folding, which is a more general form of\n    case-insensitivity.\n\nfunc Fields(s string) []string\n    Fields splits the string s around each instance of one or more consecutive\n    white space characters, as defined by unicode.IsSpace, returning a slice\n    of substrings of s or an empty slice if s contains only white space.\n    Every element of the returned slice is non-empty. Unlike Split, leading and\n    trailing runs runs of white space characters are discarded.\n\nfunc FieldsFunc(s string, f func(rune) bool) []string\n    FieldsFunc splits the string s at each run of Unicode code points c\n    satisfying f(c) and returns an array of slices of s. If all code points\n    in s satisfy f(c) or the string is empty, an empty slice is returned.\n    Every element of the returned slice is non-empty. Unlike [SplitFunc],\n    leading and trailing runs of code points satisfying f(c) are discarded.\n\n    FieldsFunc makes no guarantees about the order in which it calls f(c) and\n    assumes that f always returns the same value for a given c.\n\nfunc FieldsFuncSeq(s string, f func(rune) bool) iter.Seq[string]\n    FieldsFuncSeq returns an iterator over substrings of s split around runs of\n    Unicode code points satisfying f(c). The iterator yields the same strings\n    that would be returned by FieldsFunc(s), but without constructing the slice.\n\nfunc FieldsSeq(s string) iter.Seq[string]\n    FieldsSeq returns an iterator over substrings of s split around runs\n    of whitespace characters, as defined by unicode.IsSpace. The iterator\n    yields the same strings that would be returned by Fields(s), but without\n    constructing the slice.\n\nfunc HasPrefix(s, prefix string) bool\n    HasPrefix reports whether the string s begins with prefix.\n\nfunc HasSuffix(s, suffix string) bool\n    HasSuffix reports whether the string s ends with suffix.\n\nfunc Index(s, substr string) int\n    Index returns the index of the first instance of substr in s, or -1 if\n    substr is not present in s.\n\nfunc IndexAny(s, chars string) int\n    IndexAny returns the index of the first instance of any Unicode code point\n    from chars in s, or -1 if no Unicode code point from chars is present in s.\n\nfunc IndexByte(s string, c byte) int\n    IndexByte returns the index of the first instance of c in s, or -1 if c is\n    not present in s.\n\nfunc IndexFunc(s string, f func(rune) bool) int\n    IndexFunc returns the index into s of the first Unicode code point\n    satisfying f(c), or -1 if none do.\n\nfunc IndexRune(s string, r rune) int\n    IndexRune returns the index of the first instance of the Unicode code point\n    r, or -1 if rune is not present in s. If r is utf8.RuneError, it returns the\n    first instance of any invalid UTF-8 byte sequence.\n\nfunc Join(elems []string, sep string) string\n    Join concatenates the elements of its first argument to create a single\n    string. The separator string sep is placed between elements in the resulting\n    string.\n\nfunc LastIndex(s, substr string) int\n    LastIndex returns the index of the last instance of substr in s, or -1 if\n    substr is not present in s.\n\nfunc LastIndexAny(s, chars string) int\n    LastIndexAny returns the index of the last instance of any Unicode code\n    point from chars in s, or -1 if no Unicode code point from chars is present\n    in s.\n\nfunc LastIndexByte(s string, c byte) int\n    LastIndexByte returns the index of the last instance of c in s, or -1 if c\n    is not present in s.\n\nfunc LastIndexFunc(s string, f func(rune) bool) int\n    LastIndexFunc returns the index into s of the last Unicode code point\n    satisfying f(c), or -1 if none do.\n\nfunc Lines(s string) iter.Seq[string]\n    Lines returns an iterator over the newline-terminated lines in the string s.\n    The lines yielded by the iterator include their terminating newlines.\n    If s is empty, the iterator yields no lines at all. If s does not end in\n    a newline, the final yielded line will not end in a newline. It returns a\n    single-use iterator.\n\nfunc Map(mapping func(rune) rune, s string) string\n    Map returns a copy of the string s with all its characters modified\n    according to the mapping function. If mapping returns a negative value,\n    the character is dropped from the string with no replacement.\n\nfunc Repeat(s string, count int) string\n    Repeat returns a new string consisting of count copies of the string s.\n\n    It panics if count is negative or if the result of (len(s) * count)\n    overflows.\n\nfunc Replace(s, old, new string, n int) string\n    Replace returns a copy of the string s with the first n non-overlapping\n    instances of old replaced by new. If old is empty, it matches at the\n    beginning of the string and after each UTF-8 sequence, yielding up to k+1\n    replacements for a k-rune string. If n < 0, there is no limit on the number\n    of replacements.\n\nfunc ReplaceAll(s, old, new string) string\n    ReplaceAll returns a copy of the string s with all non-overlapping instances\n    of old replaced by new. If old is empty, it matches at the beginning of the\n    string and after each UTF-8 sequence, yielding up to k+1 replacements for a\n    k-rune string.\n\nfunc Split(s, sep string) []string\n    Split slices s into all substrings separated by sep and returns a slice of\n    the substrings between those separators.\n\n    If s does not contain sep and sep is not empty, Split returns a slice of\n    length 1 whose only element is s.\n\n    If sep is empty, Split splits after each UTF-8 sequence. If both s and sep\n    are empty, Split returns an empty slice.\n\n    It is equivalent to SplitN with a count of -1.\n\n    To split around the first instance of a separator, see Cut.\n\nfunc SplitAfter(s, sep string) []string\n    SplitAfter slices s into all substrings after each instance of sep and\n    returns a slice of those substrings.\n\n    If s does not contain sep and sep is not empty, SplitAfter returns a slice\n    of length 1 whose only element is s.\n\n    If sep is empty, SplitAfter splits after each UTF-8 sequence. If both s and\n    sep are empty, SplitAfter returns an empty slice.\n\n    It is equivalent to SplitAfterN with a count of -1.\n\nfunc SplitAfterN(s, sep string, n int) []string\n    SplitAfterN slices s into substrings after each instance of sep and returns\n    a slice of those substrings.\n\n    The count determines the number of substrings to return:\n      - n > 0: at most n substrings; the last substring will be the unsplit\n        remainder;\n      - n == 0: the result is nil (zero substrings);\n      - n < 0: all substrings.\n\n    Edge cases for s and sep (for example, empty strings) are handled as\n    described in the documentation for SplitAfter.\n\nfunc SplitAfterSeq(s, sep string) iter.Seq[string]\n    SplitAfterSeq returns an iterator over substrings of s split after each\n    instance of sep. The iterator yields the same strings that would be returned\n    by SplitAfter(s, sep), but without constructing the slice. It returns a\n    single-use iterator.\n\nfunc SplitN(s, sep string, n int) []string\n    SplitN slices s into substrings separated by sep and returns a slice of the\n    substrings between those separators.\n\n    The count determines the number of substrings to return:\n      - n > 0: at most n substrings; the last substring will be the unsplit\n        remainder;\n      - n == 0: the result is nil (zero substrings);\n      - n < 0: all substrings.\n\n    Edge cases for s and sep (for example, empty strings) are handled as\n    described in the documentation for Split.\n\n    To split around the first instance of a separator, see Cut.\n\nfunc SplitSeq(s, sep string) iter.Seq[string]\n    SplitSeq returns an iterator over all substrings of s separated by sep.\n    The iterator yields the same strings that would be returned by Split(s,\n    sep), but without constructing the slice. It returns a single-use iterator.\n\nfunc Title(s string) string\n    Title returns a copy of the string s with all Unicode letters that begin\n    words mapped to their Unicode title case.\n\n    Deprecated: The rule Title uses for word boundaries does not handle Unicode\n    punctuation properly. Use golang.org/x/text/cases instead.\n\nfunc ToLower(s string) string\n    ToLower returns s with all Unicode letters mapped to their lower case.\n\nfunc ToLowerSpecial(c unicode.SpecialCase, s string) string\n    ToLowerSpecial returns a copy of the string s with all Unicode letters\n    mapped to their lower case using the case mapping specified by c.\n\nfunc ToTitle(s string) string\n    ToTitle returns a copy of the string s with all Unicode letters mapped to\n    their Unicode title case.\n\nfunc ToTitleSpecial(c unicode.SpecialCase, s string) string\n    ToTitleSpecial returns a copy of the string s with all Unicode letters\n    mapped to their Unicode title case, giving priority to the special casing\n    rules.\n\nfunc ToUpper(s string) string\n    ToUpper returns s with all Unicode letters mapped to their upper case.\n\nfunc ToUpperSpecial(c unicode.SpecialCase, s string) string\n    ToUpperSpecial returns a copy of the string s with all Unicode letters\n    mapped to their upper case using the case mapping specified by c.\n\nfunc ToValidUTF8(s, replacement string) string\n    ToValidUTF8 returns a copy of the string s with each run of invalid UTF-8\n    byte sequences replaced by the replacement string, which may be empty.\n\nfunc Trim(s, cutset string) string\n    Trim returns a slice of the string s with all leading and trailing Unicode\n    code points contained in cutset removed.\n\nfunc TrimFunc(s string, f func(rune) bool) string\n    TrimFunc returns a slice of the string s with all leading and trailing\n    Unicode code points c satisfying f(c) removed.\n\nfunc TrimLeft(s, cutset string) string\n    TrimLeft returns a slice of the string s with all leading Unicode code\n    points contained in cutset removed.\n\n    To remove a prefix, use TrimPrefix instead.\n\nfunc TrimLeftFunc(s string, f func(rune) bool) string\n    TrimLeftFunc returns a slice of the string s with all leading Unicode code\n    points c satisfying f(c) removed.\n\nfunc TrimPrefix(s, prefix string) string\n    TrimPrefix returns s without the provided leading prefix string. If s\n    doesn't start with prefix, s is returned unchanged.\n\nfunc TrimRight(s, cutset string) string\n    TrimRight returns a slice of the string s, with all trailing Unicode code\n    points contained in cutset removed.\n\n    To remove a suffix, use TrimSuffix instead.\n\nfunc TrimRightFunc(s string, f func(rune) bool) string\n    TrimRightFunc returns a slice of the string s with all trailing Unicode code\n    points c satisfying f(c) removed.\n\nfunc TrimSpace(s string) string\n    TrimSpace returns a slice of the string s, with all leading and trailing\n    white space removed, as defined by Unicode.\n\nfunc TrimSuffix(s, suffix string) string\n    TrimSuffix returns s without the provided trailing suffix string. If s\n    doesn't end with suffix, s is returned unchanged.\n\n\nTYPES\n\ntype Builder struct {\n\t// Has unexported fields.\n}\n    A Builder is used to efficiently build a string using Builder.Write methods.\n    It minimizes memory copying. The zero value is ready to use. Do not copy a\n    non-zero Builder.\n\nfunc (b *Builder) Cap() int\n    Cap returns the capacity of the builder's underlying byte slice. It is the\n    total space allocated for the string being built and includes any bytes\n    already written.\n\nfunc (b *Builder) Grow(n int)\n    Grow grows b's capacity, if necessary, to guarantee space for another n\n    bytes. After Grow(n), at least n bytes can be written to b without another\n    allocation. If n is negative, Grow panics.\n\nfunc (b *Builder) Len() int\n    Len returns the number of accumulated bytes; b.Len() == len(b.String()).\n\nfunc (b *Builder) Reset()\n    Reset resets the Builder to be empty.\n\nfunc (b *Builder) String() string\n    String returns the accumulated string.\n\nfunc (b *Builder) Write(p []byte) (int, error)\n    Write appends the contents of p to b's buffer. Write always returns len(p),\n    nil.\n\nfunc (b *Builder) WriteByte(c byte) error\n    WriteByte appends the byte c to b's buffer. The returned error is always\n    nil.\n\nfunc (b *Builder) WriteRune(r rune) (int, error)\n    WriteRune appends the UTF-8 encoding of Unicode code point r to b's buffer.\n    It returns the length of r and a nil error.\n\nfunc (b *Builder) WriteString(s string) (int, error)\n    WriteString appends the contents of s to b's buffer. It returns the length\n    of s and a nil error.\n\ntype Reader struct {\n\t// Has unexported fields.\n}\n    A Reader implements the io.Reader, io.ReaderAt, io.ByteReader,\n    io.ByteScanner, io.RuneReader, io.RuneScanner, io.Seeker, and io.WriterTo\n    interfaces by reading from a string. The zero value for Reader operates like\n    a Reader of an empty string.\n\nfunc NewReader(s string) *Reader\n    NewReader returns a new Reader reading from s. It is similar to\n    bytes.NewBufferString but more efficient and non-writable.\n\nfunc (r *Reader) Len() int\n    Len returns the number of bytes of the unread portion of the string.\n\nfunc (r *Reader) Read(b []byte) (n int, err error)\n    Read implements the io.Reader interface.\n\nfunc (r *Reader) ReadAt(b []byte, off int64) (n int, err error)\n    ReadAt implements the io.ReaderAt interface.\n\nfunc (r *Reader) ReadByte() (byte, error)\n    ReadByte implements the io.ByteReader interface.\n\nfunc (r *Reader) ReadRune() (ch rune, size int, err error)\n    ReadRune implements the io.RuneReader interface.\n\nfunc (r *Reader) Reset(s string)\n    Reset resets the Reader to be reading from s.\n\nfunc (r *Reader) Seek(offset int64, whence int) (int64, error)\n    Seek implements the io.Seeker interface.\n\nfunc (r *Reader) Size() int64\n    Size returns the original length of the underlying string. Size is the\n    number of bytes available for reading via Reader.ReadAt. The returned value\n    is always the same and is not affected by calls to any other method.\n\nfunc (r *Reader) UnreadByte() error\n    UnreadByte implements the io.ByteScanner interface.\n\nfunc (r *Reader) UnreadRune() error\n    UnreadRune implements the io.RuneScanner interface.\n\nfunc (r *Reader) WriteTo(w io.Writer) (n int64, err error)\n    WriteTo implements the io.WriterTo interface.\n\ntype Replacer struct {\n\t// Has unexported fields.\n}\n    Replacer replaces a list of strings with replacements. It is safe for\n    concurrent use by multiple goroutines.\n\nfunc NewReplacer(oldnew ...string) *Replacer\n    NewReplacer returns a new Replacer from a list of old, new string pairs.\n    Replacements are performed in the order they appear in the target string,\n    without overlapping matches. The old string comparisons are done in argument\n    order.\n\n    NewReplacer panics if given an odd number of arguments.\n\nfunc (r *Replacer) Replace(s string) string\n    Replace returns a copy of s with all replacements performed.\n\nfunc (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)\n    WriteString writes s to w with all replacements performed.\n\n"}, {"path": "stdlib/internal-runtime-exithook.md", "category": "stdlib", "name": "stdlib/internal-runtime-exithook", "content": "package exithook // import \"internal/runtime/exithook\"\n\nPackage exithook provides limited support for on-exit cleanup.\n\nCAREFUL! The expectation is that Add should only be called from a safe\ncontext (e.g. not an error/panic path or signal handler, preemption enabled,\nallocation allowed, write barriers allowed, etc), and that the exit function F\nwill be invoked under similar circumstances. That is the say, we are expecting\nthat F uses normal / high-level Go code as opposed to one of the more restricted\ndialects used for the trickier parts of the runtime.\n\nVARIABLES\n\nvar (\n\n\t// runtime sets these for us\n\tGosched func()\n\tGoid    func() uint64\n\tThrow   func(string)\n)\n\nFUNCTIONS\n\nfunc Add(h Hook)\n    Add adds a new exit hook.\n\nfunc Run(code int)\n    Run runs the exit hooks.\n\n    If an exit hook panics, Run will throw with the panic on the stack. If an\n    exit hook invokes exit in the same goroutine, the goroutine will throw.\n    If an exit hook invokes exit in another goroutine, that exit will block.\n\n\nTYPES\n\ntype Hook struct {\n\tF            func() // func to run\n\tRunOnFailure bool   // whether to run on non-zero exit code\n}\n    A Hook is a function to be run at program termination (when someone invokes\n    os.Exit, or when main.main returns). Hooks are run in reverse order of\n    registration: the first hook added is the last one run.\n\n"}, {"path": "stdlib/crypto-internal-boring-bcache.md", "category": "stdlib", "name": "stdlib/crypto-internal-boring-bcache", "content": "package bcache // import \"crypto/internal/boring/bcache\"\n\nPackage bcache implements a GC-friendly cache (see Cache) for BoringCrypto.\n\nTYPES\n\ntype Cache[K, V any] struct {\n\t// Has unexported fields.\n}\n    A Cache is a GC-friendly concurrent map from unsafe.Pointer to\n    unsafe.Pointer. It is meant to be used for maintaining shadow BoringCrypto\n    state associated with certain allocated structs, in particular public and\n    private RSA and ECDSA keys.\n\n    The cache is GC-friendly in the sense that the keys do not indefinitely\n    prevent the garbage collector from collecting them. Instead, at the start\n    of each GC, the cache is cleared entirely. That is, the cache is lossy,\n    and the loss happens at the start of each GC. This means that clients need\n    to be able to cope with cache entries disappearing, but it also means that\n    clients don't need to worry about cache entries keeping the keys from being\n    collected.\n\nfunc (c *Cache[K, V]) Clear()\n    Clear clears the cache. The runtime does this automatically at each garbage\n    collection; this method is exposed only for testing.\n\nfunc (c *Cache[K, V]) Get(k *K) *V\n    Get returns the cached value associated with v, which is either the value\n    v corresponding to the most recent call to Put(k, v) or nil if that cache\n    entry has been dropped.\n\nfunc (c *Cache[K, V]) Put(k *K, v *V)\n    Put sets the cached value associated with k to v.\n\nfunc (c *Cache[K, V]) Register()\n    Register registers the cache with the runtime, so that c.ptable can be\n    cleared at the start of each GC. Register must be called during package\n    initialization.\n\n"}, {"path": "stdlib/log-syslog.md", "category": "stdlib", "name": "stdlib/log-syslog", "content": "package syslog // import \"log/syslog\"\n\nPackage syslog provides a simple interface to the system log service. It can\nsend messages to the syslog daemon using UNIX domain sockets, UDP or TCP.\n\nOnly one call to Dial is necessary. On write failures, the syslog client will\nattempt to reconnect to the server and write again.\n\nThe syslog package is frozen and is not accepting new features. Some external\npackages provide more functionality. See:\n\n    https://godoc.org/?q=syslog\n\nFUNCTIONS\n\nfunc NewLogger(p Priority, logFlag int) (*log.Logger, error)\n    NewLogger creates a log.Logger whose output is written to the system log\n    service with the specified priority, a combination of the syslog facility\n    and severity. The logFlag argument is the flag set passed through to log.New\n    to create the Logger.\n\n\nTYPES\n\ntype Priority int\n    The Priority is a combination of the syslog facility and severity.\n    For example, LOG_ALERT | LOG_FTP sends an alert severity message from the\n    FTP facility. The default severity is LOG_EMERG; the default facility is\n    LOG_KERN.\n\nconst (\n\n\t// From /usr/include/sys/syslog.h.\n\t// These are the same on Linux, BSD, and OS X.\n\tLOG_EMERG Priority = iota\n\tLOG_ALERT\n\tLOG_CRIT\n\tLOG_ERR\n\tLOG_WARNING\n\tLOG_NOTICE\n\tLOG_INFO\n\tLOG_DEBUG\n)\nconst (\n\n\t// From /usr/include/sys/syslog.h.\n\t// These are the same up to LOG_FTP on Linux, BSD, and OS X.\n\tLOG_KERN Priority = iota << 3\n\tLOG_USER\n\tLOG_MAIL\n\tLOG_DAEMON\n\tLOG_AUTH\n\tLOG_SYSLOG\n\tLOG_LPR\n\tLOG_NEWS\n\tLOG_UUCP\n\tLOG_CRON\n\tLOG_AUTHPRIV\n\tLOG_FTP\n\n\tLOG_LOCAL0\n\tLOG_LOCAL1\n\tLOG_LOCAL2\n\tLOG_LOCAL3\n\tLOG_LOCAL4\n\tLOG_LOCAL5\n\tLOG_LOCAL6\n\tLOG_LOCAL7\n)\ntype Writer struct {\n\t// Has unexported fields.\n}\n    A Writer is a connection to a syslog server.\n\nfunc Dial(network, raddr string, priority Priority, tag string) (*Writer, error)\n    Dial establishes a connection to a log daemon by connecting to address raddr\n    on the specified network. Each write to the returned writer sends a log\n    message with the facility and severity (from priority) and tag. If tag is\n    empty, the os.Args[0] is used. If network is empty, Dial will connect to the\n    local syslog server. Otherwise, see the documentation for net.Dial for valid\n    values of network and raddr.\n\nfunc New(priority Priority, tag string) (*Writer, error)\n    New establishes a new connection to the system log daemon. Each write to the\n    returned writer sends a log message with the given priority (a combination\n    of the syslog facility and severity) and prefix tag. If tag is empty,\n    the os.Args[0] is used.\n\nfunc (w *Writer) Alert(m string) error\n    Alert logs a message with severity LOG_ALERT, ignoring the severity passed\n    to New.\n\nfunc (w *Writer) Close() error\n    Close closes a connection to the syslog daemon.\n\nfunc (w *Writer) Crit(m string) error\n    Crit logs a message with severity LOG_CRIT, ignoring the severity passed to\n    New.\n\nfunc (w *Writer) Debug(m string) error\n    Debug logs a message with severity LOG_DEBUG, ignoring the severity passed\n    to New.\n\nfunc (w *Writer) Emerg(m string) error\n    Emerg logs a message with severity LOG_EMERG, ignoring the severity passed\n    to New.\n\nfunc (w *Writer) Err(m string) error\n    Err logs a message with severity LOG_ERR, ignoring the severity passed to\n    New.\n\nfunc (w *Writer) Info(m string) error\n    Info logs a message with severity LOG_INFO, ignoring the severity passed to\n    New.\n\nfunc (w *Writer) Notice(m string) error\n    Notice logs a message with severity LOG_NOTICE, ignoring the severity passed\n    to New.\n\nfunc (w *Writer) Warning(m string) error\n    Warning logs a message with severity LOG_WARNING, ignoring the severity\n    passed to New.\n\nfunc (w *Writer) Write(b []byte) (int, error)\n    Write sends a log message to the syslog daemon.\n\n\nBUG: This package is not implemented on Windows. As the\nsyslog package is frozen, Windows users are encouraged to\nuse a package outside of the standard library. For background,\nsee https://golang.org/issue/1108.\n\nBUG: This package is not implemented on Plan 9.\n\n"}, {"path": "stdlib/crypto-internal-fips140-nistec.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-nistec", "content": "package nistec // import \"crypto/internal/fips140/nistec\"\n\nPackage nistec implements the elliptic curves from NIST SP 800-186.\n\nThis package uses fiat-crypto or specialized assembly and Go code for its\nbackend field arithmetic (not math/big) and exposes constant-time, heap\nallocation-free, byte slice-based safe APIs. Group operations use modern and\nsafe complete addition formulas where possible. The point at infinity is handled\nand encoded according to SEC 1, Version 2.0, and invalid curve points can't be\nrepresented.\n\nFUNCTIONS\n\nfunc P256OrdInverse(k []byte) ([]byte, error)\n\nTYPES\n\ntype P224Point struct {\n\t// Has unexported fields.\n}\n    P224Point is a P224 point. The zero value is NOT valid.\n\nfunc NewP224Point() *P224Point\n    NewP224Point returns a new P224Point representing the point at infinity\n    point.\n\nfunc (q *P224Point) Add(p1, p2 *P224Point) *P224Point\n    Add sets q = p1 + p2, and returns q. The points may overlap.\n\nfunc (p *P224Point) Bytes() []byte\n    Bytes returns the uncompressed or infinity encoding of p, as specified in\n    SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at\n    infinity is shorter than all other encodings.\n\nfunc (p *P224Point) BytesCompressed() []byte\n    BytesCompressed returns the compressed or infinity encoding of p,\n    as specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of\n    the point at infinity is shorter than all other encodings.\n\nfunc (p *P224Point) BytesX() ([]byte, error)\n    BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,\n    Version 2.0, Section 2.3.5, or an error if p is the point at infinity.\n\nfunc (q *P224Point) Double(p *P224Point) *P224Point\n    Double sets q = p + p, and returns q. The points may overlap.\n\nfunc (p *P224Point) ScalarBaseMult(scalar []byte) (*P224Point, error)\n    ScalarBaseMult sets p = scalar * B, where B is the canonical generator,\n    and returns p.\n\nfunc (p *P224Point) ScalarMult(q *P224Point, scalar []byte) (*P224Point, error)\n    ScalarMult sets p = scalar * q, and returns p.\n\nfunc (q *P224Point) Select(p1, p2 *P224Point, cond int) *P224Point\n    Select sets q to p1 if cond == 1, and to p2 if cond == 0.\n\nfunc (p *P224Point) Set(q *P224Point) *P224Point\n    Set sets p = q and returns p.\n\nfunc (p *P224Point) SetBytes(b []byte) (*P224Point, error)\n    SetBytes sets p to the compressed, uncompressed, or infinity value encoded\n    in b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not\n    on the curve, it returns nil and an error, and the receiver is unchanged.\n    Otherwise, it returns p.\n\nfunc (p *P224Point) SetGenerator() *P224Point\n    SetGenerator sets p to the canonical generator and returns p.\n\ntype P256Point struct {\n\t// Has unexported fields.\n}\n    P256Point is a P-256 point. The zero value should not be assumed to be valid\n    (although it is in this implementation).\n\nfunc NewP256Point() *P256Point\n    NewP256Point returns a new P256Point representing the point at infinity.\n\nfunc (q *P256Point) Add(r1, r2 *P256Point) *P256Point\n    Add sets q = p1 + p2, and returns q. The points may overlap.\n\nfunc (p *P256Point) Bytes() []byte\n    Bytes returns the uncompressed or infinity encoding of p, as specified in\n    SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at\n    infinity is shorter than all other encodings.\n\nfunc (p *P256Point) BytesCompressed() []byte\n    BytesCompressed returns the compressed or infinity encoding of p,\n    as specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of\n    the point at infinity is shorter than all other encodings.\n\nfunc (p *P256Point) BytesX() ([]byte, error)\n    BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,\n    Version 2.0, Section 2.3.5, or an error if p is the point at infinity.\n\nfunc (q *P256Point) Double(p *P256Point) *P256Point\n    Double sets q = p + p, and returns q. The points may overlap.\n\nfunc (r *P256Point) ScalarBaseMult(scalar []byte) (*P256Point, error)\n    ScalarBaseMult sets r = scalar * generator, where scalar is a 32-byte big\n    endian value, and returns r. If scalar is not 32 bytes long, ScalarBaseMult\n    returns an error and the receiver is unchanged.\n\nfunc (r *P256Point) ScalarMult(q *P256Point, scalar []byte) (*P256Point, error)\n    ScalarMult sets r = scalar * q, where scalar is a 32-byte big endian value,\n    and returns r. If scalar is not 32 bytes long, ScalarBaseMult returns an\n    error and the receiver is unchanged.\n\nfunc (q *P256Point) Select(p1, p2 *P256Point, cond int) *P256Point\n    Select sets q to p1 if cond == 1, and to p2 if cond == 0.\n\nfunc (p *P256Point) Set(q *P256Point) *P256Point\n    Set sets p = q and returns p.\n\nfunc (p *P256Point) SetBytes(b []byte) (*P256Point, error)\n    SetBytes sets p to the compressed, uncompressed, or infinity value encoded\n    in b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not\n    on the curve, it returns nil and an error, and the receiver is unchanged.\n    Otherwise, it returns p.\n\nfunc (p *P256Point) SetGenerator() *P256Point\n    SetGenerator sets p to the canonical generator and returns p.\n\ntype P384Point struct {\n\t// Has unexported fields.\n}\n    P384Point is a P384 point. The zero value is NOT valid.\n\nfunc NewP384Point() *P384Point\n    NewP384Point returns a new P384Point representing the point at infinity\n    point.\n\nfunc (q *P384Point) Add(p1, p2 *P384Point) *P384Point\n    Add sets q = p1 + p2, and returns q. The points may overlap.\n\nfunc (p *P384Point) Bytes() []byte\n    Bytes returns the uncompressed or infinity encoding of p, as specified in\n    SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at\n    infinity is shorter than all other encodings.\n\nfunc (p *P384Point) BytesCompressed() []byte\n    BytesCompressed returns the compressed or infinity encoding of p,\n    as specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of\n    the point at infinity is shorter than all other encodings.\n\nfunc (p *P384Point) BytesX() ([]byte, error)\n    BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,\n    Version 2.0, Section 2.3.5, or an error if p is the point at infinity.\n\nfunc (q *P384Point) Double(p *P384Point) *P384Point\n    Double sets q = p + p, and returns q. The points may overlap.\n\nfunc (p *P384Point) ScalarBaseMult(scalar []byte) (*P384Point, error)\n    ScalarBaseMult sets p = scalar * B, where B is the canonical generator,\n    and returns p.\n\nfunc (p *P384Point) ScalarMult(q *P384Point, scalar []byte) (*P384Point, error)\n    ScalarMult sets p = scalar * q, and returns p.\n\nfunc (q *P384Point) Select(p1, p2 *P384Point, cond int) *P384Point\n    Select sets q to p1 if cond == 1, and to p2 if cond == 0.\n\nfunc (p *P384Point) Set(q *P384Point) *P384Point\n    Set sets p = q and returns p.\n\nfunc (p *P384Point) SetBytes(b []byte) (*P384Point, error)\n    SetBytes sets p to the compressed, uncompressed, or infinity value encoded\n    in b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not\n    on the curve, it returns nil and an error, and the receiver is unchanged.\n    Otherwise, it returns p.\n\nfunc (p *P384Point) SetGenerator() *P384Point\n    SetGenerator sets p to the canonical generator and returns p.\n\ntype P521Point struct {\n\t// Has unexported fields.\n}\n    P521Point is a P521 point. The zero value is NOT valid.\n\nfunc NewP521Point() *P521Point\n    NewP521Point returns a new P521Point representing the point at infinity\n    point.\n\nfunc (q *P521Point) Add(p1, p2 *P521Point) *P521Point\n    Add sets q = p1 + p2, and returns q. The points may overlap.\n\nfunc (p *P521Point) Bytes() []byte\n    Bytes returns the uncompressed or infinity encoding of p, as specified in\n    SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at\n    infinity is shorter than all other encodings.\n\nfunc (p *P521Point) BytesCompressed() []byte\n    BytesCompressed returns the compressed or infinity encoding of p,\n    as specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of\n    the point at infinity is shorter than all other encodings.\n\nfunc (p *P521Point) BytesX() ([]byte, error)\n    BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,\n    Version 2.0, Section 2.3.5, or an error if p is the point at infinity.\n\nfunc (q *P521Point) Double(p *P521Point) *P521Point\n    Double sets q = p + p, and returns q. The points may overlap.\n\nfunc (p *P521Point) ScalarBaseMult(scalar []byte) (*P521Point, error)\n    ScalarBaseMult sets p = scalar * B, where B is the canonical generator,\n    and returns p.\n\nfunc (p *P521Point) ScalarMult(q *P521Point, scalar []byte) (*P521Point, error)\n    ScalarMult sets p = scalar * q, and returns p.\n\nfunc (q *P521Point) Select(p1, p2 *P521Point, cond int) *P521Point\n    Select sets q to p1 if cond == 1, and to p2 if cond == 0.\n\nfunc (p *P521Point) Set(q *P521Point) *P521Point\n    Set sets p = q and returns p.\n\nfunc (p *P521Point) SetBytes(b []byte) (*P521Point, error)\n    SetBytes sets p to the compressed, uncompressed, or infinity value encoded\n    in b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not\n    on the curve, it returns nil and an error, and the receiver is unchanged.\n    Otherwise, it returns p.\n\nfunc (p *P521Point) SetGenerator() *P521Point\n    SetGenerator sets p to the canonical generator and returns p.\n\n"}, {"path": "stdlib/crypto-x509.md", "category": "stdlib", "name": "stdlib/crypto-x509", "content": "package x509 // import \"crypto/x509\"\n\nPackage x509 implements a subset of the X.509 standard.\n\nIt allows parsing and generating certificates, certificate signing requests,\ncertificate revocation lists, and encoded public and private keys. It provides a\ncertificate verifier, complete with a chain builder.\n\nThe package targets the X.509 technical profile defined by the IETF (RFC\n2459/3280/5280), and as further restricted by the CA/Browser Forum Baseline\nRequirements. There is minimal support for features outside of these profiles,\nas the primary goal of the package is to provide compatibility with the publicly\ntrusted TLS certificate ecosystem and its policies and constraints.\n\nOn macOS and Windows, certificate verification is handled by system APIs, but\nthe package aims to apply consistent validation rules across operating systems.\n\nVARIABLES\n\nvar ErrUnsupportedAlgorithm = errors.New(\"x509: cannot verify signature: algorithm unimplemented\")\n    ErrUnsupportedAlgorithm results from attempting to perform an operation that\n    involves algorithms that are not currently implemented.\n\nvar IncorrectPasswordError = errors.New(\"x509: decryption password incorrect\")\n    IncorrectPasswordError is returned when an incorrect password is detected.\n\n\nFUNCTIONS\n\nfunc CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv any) ([]byte, error)\n    CreateCertificate creates a new X.509 v3 certificate based on a template.\n    The following members of template are currently used:\n\n      - AuthorityKeyId\n      - BasicConstraintsValid\n      - CRLDistributionPoints\n      - DNSNames\n      - EmailAddresses\n      - ExcludedDNSDomains\n      - ExcludedEmailAddresses\n      - ExcludedIPRanges\n      - ExcludedURIDomains\n      - ExtKeyUsage\n      - ExtraExtensions\n      - IPAddresses\n      - IsCA\n      - IssuingCertificateURL\n      - KeyUsage\n      - MaxPathLen\n      - MaxPathLenZero\n      - NotAfter\n      - NotBefore\n      - OCSPServer\n      - PermittedDNSDomains\n      - PermittedDNSDomainsCritical\n      - PermittedEmailAddresses\n      - PermittedIPRanges\n      - PermittedURIDomains\n      - PolicyIdentifiers (see note below)\n      - Policies (see note below)\n      - SerialNumber\n      - SignatureAlgorithm\n      - Subject\n      - SubjectKeyId\n      - URIs\n      - UnknownExtKeyUsage\n\n    The certificate is signed by parent. If parent is equal to template then\n    the certificate is self-signed. The parameter pub is the public key of the\n    certificate to be generated and priv is the private key of the signer.\n\n    The returned slice is the certificate in DER encoding.\n\n    The currently supported key types are *rsa.PublicKey, *ecdsa.PublicKey and\n    ed25519.PublicKey. pub must be a supported key type, and priv must be a\n    crypto.Signer or crypto.MessageSigner with a supported public key.\n\n    The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any,\n    unless the resulting certificate is self-signed. Otherwise the value from\n    template will be used.\n\n    If SubjectKeyId from template is empty and the template is a CA,\n    SubjectKeyId will be generated from the hash of the public key.\n\n    If template.SerialNumber is nil, a serial number will be generated which\n    conforms to RFC 5280, Section 4.1.2.2 using entropy from rand.\n\n    The PolicyIdentifier and Policies fields can both be used to marshal\n    certificate policy OIDs. By default, only the Policies is marshaled,\n    but if the GODEBUG setting \"x509usepolicies\" has the value \"0\", the\n    PolicyIdentifiers field will be marshaled instead of the Policies field.\n    This changed in Go 1.24. The Policies field can be used to marshal policy\n    OIDs which have components that are larger than 31 bits.\n\nfunc CreateCertificateRequest(rand io.Reader, template *CertificateRequest, priv any) (csr []byte, err error)\n    CreateCertificateRequest creates a new certificate request based on a\n    template. The following members of template are used:\n\n      - SignatureAlgorithm\n      - Subject\n      - DNSNames\n      - EmailAddresses\n      - IPAddresses\n      - URIs\n      - ExtraExtensions\n      - Attributes (deprecated)\n\n    priv is the private key to sign the CSR with, and the corresponding\n    public key will be included in the CSR. It must implement crypto.Signer or\n    crypto.MessageSigner and its Public() method must return a *rsa.PublicKey\n    or a *ecdsa.PublicKey or a ed25519.PublicKey. (A *rsa.PrivateKey,\n    *ecdsa.PrivateKey or ed25519.PrivateKey satisfies this.)\n\n    The returned slice is the certificate request in DER encoding.\n\nfunc CreateRevocationList(rand io.Reader, template *RevocationList, issuer *Certificate, priv crypto.Signer) ([]byte, error)\n    CreateRevocationList creates a new X.509 v2 Certificate Revocation List,\n    according to RFC 5280, based on template.\n\n    The CRL is signed by priv which should be a crypto.Signer or\n    crypto.MessageSigner associated with the public key in the issuer\n    certificate.\n\n    The issuer may not be nil, and the crlSign bit must be set in KeyUsage in\n    order to use it as a CRL issuer.\n\n    The issuer distinguished name CRL field and authority key identifier\n    extension are populated using the issuer certificate. issuer must have\n    SubjectKeyId set.\n\nfunc DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error)\n    DecryptPEMBlock takes a PEM block encrypted according to RFC 1423 and the\n    password used to encrypt it and returns a slice of decrypted DER encoded\n    bytes. It inspects the DEK-Info header to determine the algorithm used\n    for decryption. If no DEK-Info header is present, an error is returned.\n    If an incorrect password is detected an IncorrectPasswordError is returned.\n    Because of deficiencies in the format, it's not always possible to detect\n    an incorrect password. In these cases no error will be returned but the\n    decrypted DER bytes will be random noise.\n\n    Deprecated: Legacy PEM encryption as specified in RFC 1423 is insecure by\n    design. Since it does not authenticate the ciphertext, it is vulnerable to\n    padding oracle attacks that can let an attacker recover the plaintext.\n\nfunc EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error)\n    EncryptPEMBlock returns a PEM block of the specified type holding the\n    given DER encoded data encrypted with the specified algorithm and password\n    according to RFC 1423.\n\n    Deprecated: Legacy PEM encryption as specified in RFC 1423 is insecure by\n    design. Since it does not authenticate the ciphertext, it is vulnerable to\n    padding oracle attacks that can let an attacker recover the plaintext.\n\nfunc IsEncryptedPEMBlock(b *pem.Block) bool\n    IsEncryptedPEMBlock returns whether the PEM block is password encrypted\n    according to RFC 1423.\n\n    Deprecated: Legacy PEM encryption as specified in RFC 1423 is insecure by\n    design. Since it does not authenticate the ciphertext, it is vulnerable to\n    padding oracle attacks that can let an attacker recover the plaintext.\n\nfunc MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)\n    MarshalECPrivateKey converts an EC private key to SEC 1, ASN.1 DER form.\n\n    This kind of key is commonly encoded in PEM blocks of type \"EC PRIVATE\n    KEY\". For a more flexible key format which is not EC specific, use\n    MarshalPKCS8PrivateKey.\n\nfunc MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte\n    MarshalPKCS1PrivateKey converts an RSA private key to PKCS #1, ASN.1 DER\n    form.\n\n    This kind of key is commonly encoded in PEM blocks of type \"RSA PRIVATE\n    KEY\". For a more flexible key format which is not RSA specific, use\n    MarshalPKCS8PrivateKey.\n\n    The key must have passed validation by calling rsa.PrivateKey.Validate\n    first. MarshalPKCS1PrivateKey calls rsa.PrivateKey.Precompute, which may\n    modify the key if not already precomputed.\n\nfunc MarshalPKCS1PublicKey(key *rsa.PublicKey) []byte\n    MarshalPKCS1PublicKey converts an RSA public key to PKCS #1, ASN.1 DER form.\n\n    This kind of key is commonly encoded in PEM blocks of type \"RSA PUBLIC KEY\".\n\nfunc MarshalPKCS8PrivateKey(key any) ([]byte, error)\n    MarshalPKCS8PrivateKey converts a private key to PKCS #8, ASN.1 DER form.\n\n    The following key types are currently supported: *rsa.PrivateKey,\n    *ecdsa.PrivateKey, ed25519.PrivateKey (not a pointer), and *ecdh.PrivateKey.\n    Unsupported key types result in an error.\n\n    This kind of key is commonly encoded in PEM blocks of type \"PRIVATE KEY\".\n\n    MarshalPKCS8PrivateKey runs rsa.PrivateKey.Precompute on RSA keys.\n\nfunc MarshalPKIXPublicKey(pub any) ([]byte, error)\n    MarshalPKIXPublicKey converts a public key to PKIX, ASN.1 DER form.\n    The encoded public key is a SubjectPublicKeyInfo structure (see RFC 5280,\n    Section 4.1).\n\n    The following key types are currently supported: *rsa.PublicKey,\n    *ecdsa.PublicKey, ed25519.PublicKey (not a pointer), and *ecdh.PublicKey.\n    Unsupported key types result in an error.\n\n    This kind of key is commonly encoded in PEM blocks of type \"PUBLIC KEY\".\n\nfunc ParseCRL(crlBytes []byte) (*pkix.CertificateList, error)\n    ParseCRL parses a CRL from the given bytes. It's often the case that PEM\n    encoded CRLs will appear where they should be DER encoded, so this function\n    will transparently handle PEM encoding as long as there isn't any leading\n    garbage.\n\n    Deprecated: Use ParseRevocationList instead.\n\nfunc ParseDERCRL(derBytes []byte) (*pkix.CertificateList, error)\n    ParseDERCRL parses a DER encoded CRL from the given bytes.\n\n    Deprecated: Use ParseRevocationList instead.\n\nfunc ParseECPrivateKey(der []byte) (*ecdsa.PrivateKey, error)\n    ParseECPrivateKey parses an EC private key in SEC 1, ASN.1 DER form.\n\n    This kind of key is commonly encoded in PEM blocks of type \"EC PRIVATE KEY\".\n\nfunc ParsePKCS1PrivateKey(der []byte) (*rsa.PrivateKey, error)\n    ParsePKCS1PrivateKey parses an RSA private key in PKCS #1, ASN.1 DER form.\n\n    This kind of key is commonly encoded in PEM blocks of type \"RSA PRIVATE\n    KEY\".\n\n    Before Go 1.24, the CRT parameters were ignored and recomputed. To restore\n    the old behavior, use the GODEBUG=x509rsacrt=0 environment variable.\n\nfunc ParsePKCS1PublicKey(der []byte) (*rsa.PublicKey, error)\n    ParsePKCS1PublicKey parses an RSA public key in PKCS #1, ASN.1 DER form.\n\n    This kind of key is commonly encoded in PEM blocks of type \"RSA PUBLIC KEY\".\n\nfunc ParsePKCS8PrivateKey(der []byte) (key any, err error)\n    ParsePKCS8PrivateKey parses an unencrypted private key in PKCS #8, ASN.1 DER\n    form.\n\n    It returns a *rsa.PrivateKey, an *ecdsa.PrivateKey, an ed25519.PrivateKey\n    (not a pointer), or an *ecdh.PrivateKey (for X25519). More types might be\n    supported in the future.\n\n    This kind of key is commonly encoded in PEM blocks of type \"PRIVATE KEY\".\n\n    Before Go 1.24, the CRT parameters of RSA keys were ignored and recomputed.\n    To restore the old behavior, use the GODEBUG=x509rsacrt=0 environment\n    variable.\n\nfunc ParsePKIXPublicKey(derBytes []byte) (pub any, err error)\n    ParsePKIXPublicKey parses a public key in PKIX, ASN.1 DER form. The encoded\n    public key is a SubjectPublicKeyInfo structure (see RFC 5280, Section 4.1).\n\n    It returns a *rsa.PublicKey, *dsa.PublicKey, *ecdsa.PublicKey,\n    ed25519.PublicKey (not a pointer), or *ecdh.PublicKey (for X25519). More\n    types might be supported in the future.\n\n    This kind of key is commonly encoded in PEM blocks of type \"PUBLIC KEY\".\n\nfunc SetFallbackRoots(roots *CertPool)\n    SetFallbackRoots sets the roots to use during certificate verification,\n    if no custom roots are specified and a platform verifier or a system\n    certificate pool is not available (for instance in a container which does\n    not have a root certificate bundle). SetFallbackRoots will panic if roots is\n    nil.\n\n    SetFallbackRoots may only be called once, if called multiple times it will\n    panic.\n\n    The fallback behavior can be forced on all platforms, even when there\n    is a system certificate pool, by setting GODEBUG=x509usefallbackroots=1\n    (note that on Windows and macOS this will disable usage of the platform\n    verification APIs and cause the pure Go verifier to be used). Setting\n    x509usefallbackroots=1 without calling SetFallbackRoots has no effect.\n\n\nTYPES\n\ntype CertPool struct {\n\t// Has unexported fields.\n}\n    CertPool is a set of certificates.\n\nfunc NewCertPool() *CertPool\n    NewCertPool returns a new, empty CertPool.\n\nfunc SystemCertPool() (*CertPool, error)\n    SystemCertPool returns a copy of the system cert pool.\n\n    On Unix systems other than macOS the environment variables SSL_CERT_FILE\n    and SSL_CERT_DIR can be used to override the system default locations for\n    the SSL certificate file and SSL certificate files directory, respectively.\n    The latter can be a colon-separated list.\n\n    Any mutations to the returned pool are not written to disk and do not affect\n    any other pool returned by SystemCertPool.\n\n    New changes in the system cert pool might not be reflected in subsequent\n    calls.\n\nfunc (s *CertPool) AddCert(cert *Certificate)\n    AddCert adds a certificate to a pool.\n\nfunc (s *CertPool) AddCertWithConstraint(cert *Certificate, constraint func([]*Certificate) error)\n    AddCertWithConstraint adds a certificate to the pool with the additional\n    constraint. When Certificate.Verify builds a chain which is rooted by cert,\n    it will additionally pass the whole chain to constraint to determine\n    its validity. If constraint returns a non-nil error, the chain will be\n    discarded. constraint may be called concurrently from multiple goroutines.\n\nfunc (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool)\n    AppendCertsFromPEM attempts to parse a series of PEM encoded certificates.\n    It appends any certificates found to s and reports whether any certificates\n    were successfully parsed.\n\n    On many Linux systems, /etc/ssl/cert.pem will contain the system wide set of\n    root CAs in a format suitable for this function.\n\nfunc (s *CertPool) Clone() *CertPool\n    Clone returns a copy of s.\n\nfunc (s *CertPool) Equal(other *CertPool) bool\n    Equal reports whether s and other are equal.\n\nfunc (s *CertPool) Subjects() [][]byte\n    Subjects returns a list of the DER-encoded subjects of all of the\n    certificates in the pool.\n\n    Deprecated: if s was returned by SystemCertPool, Subjects will not include\n    the system roots.\n\ntype Certificate struct {\n\tRaw                     []byte // Complete ASN.1 DER content (certificate, signature algorithm and signature).\n\tRawTBSCertificate       []byte // Certificate part of raw ASN.1 DER content.\n\tRawSubjectPublicKeyInfo []byte // DER encoded SubjectPublicKeyInfo.\n\tRawSubject              []byte // DER encoded Subject\n\tRawIssuer               []byte // DER encoded Issuer\n\n\tSignature          []byte\n\tSignatureAlgorithm SignatureAlgorithm\n\n\tPublicKeyAlgorithm PublicKeyAlgorithm\n\tPublicKey          any\n\n\tVersion             int\n\tSerialNumber        *big.Int\n\tIssuer              pkix.Name\n\tSubject             pkix.Name\n\tNotBefore, NotAfter time.Time // Validity bounds.\n\tKeyUsage            KeyUsage\n\n\t// Extensions contains raw X.509 extensions. When parsing certificates,\n\t// this can be used to extract non-critical extensions that are not\n\t// parsed by this package. When marshaling certificates, the Extensions\n\t// field is ignored, see ExtraExtensions.\n\tExtensions []pkix.Extension\n\n\t// ExtraExtensions contains extensions to be copied, raw, into any\n\t// marshaled certificates. Values override any extensions that would\n\t// otherwise be produced based on the other fields. The ExtraExtensions\n\t// field is not populated when parsing certificates, see Extensions.\n\tExtraExtensions []pkix.Extension\n\n\t// UnhandledCriticalExtensions contains a list of extension IDs that\n\t// were not (fully) processed when parsing. Verify will fail if this\n\t// slice is non-empty, unless verification is delegated to an OS\n\t// library which understands all the critical extensions.\n\t//\n\t// Users can access these extensions using Extensions and can remove\n\t// elements from this slice if they believe that they have been\n\t// handled.\n\tUnhandledCriticalExtensions []asn1.ObjectIdentifier\n\n\tExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.\n\tUnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package.\n\n\t// BasicConstraintsValid indicates whether IsCA, MaxPathLen,\n\t// and MaxPathLenZero are valid.\n\tBasicConstraintsValid bool\n\tIsCA                  bool\n\n\t// MaxPathLen and MaxPathLenZero indicate the presence and\n\t// value of the BasicConstraints' \"pathLenConstraint\".\n\t//\n\t// When parsing a certificate, a positive non-zero MaxPathLen\n\t// means that the field was specified, -1 means it was unset,\n\t// and MaxPathLenZero being true mean that the field was\n\t// explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false\n\t// should be treated equivalent to -1 (unset).\n\t//\n\t// When generating a certificate, an unset pathLenConstraint\n\t// can be requested with either MaxPathLen == -1 or using the\n\t// zero value for both MaxPathLen and MaxPathLenZero.\n\tMaxPathLen int\n\t// MaxPathLenZero indicates that BasicConstraintsValid==true\n\t// and MaxPathLen==0 should be interpreted as an actual\n\t// maximum path length of zero. Otherwise, that combination is\n\t// interpreted as MaxPathLen not being set.\n\tMaxPathLenZero bool\n\n\tSubjectKeyId   []byte\n\tAuthorityKeyId []byte\n\n\t// RFC 5280, 4.2.2.1 (Authority Information Access)\n\tOCSPServer            []string\n\tIssuingCertificateURL []string\n\n\t// Subject Alternate Name values. (Note that these values may not be valid\n\t// if invalid values were contained within a parsed certificate. For\n\t// example, an element of DNSNames may not be a valid DNS domain name.)\n\tDNSNames       []string\n\tEmailAddresses []string\n\tIPAddresses    []net.IP\n\tURIs           []*url.URL\n\n\t// Name constraints\n\tPermittedDNSDomainsCritical bool // if true then the name constraints are marked critical.\n\tPermittedDNSDomains         []string\n\tExcludedDNSDomains          []string\n\tPermittedIPRanges           []*net.IPNet\n\tExcludedIPRanges            []*net.IPNet\n\tPermittedEmailAddresses     []string\n\tExcludedEmailAddresses      []string\n\tPermittedURIDomains         []string\n\tExcludedURIDomains          []string\n\n\t// CRL Distribution Points\n\tCRLDistributionPoints []string\n\n\t// PolicyIdentifiers contains asn1.ObjectIdentifiers, the components\n\t// of which are limited to int32. If a certificate contains a policy which\n\t// cannot be represented by asn1.ObjectIdentifier, it will not be included in\n\t// PolicyIdentifiers, but will be present in Policies, which contains all parsed\n\t// policy OIDs.\n\t// See CreateCertificate for context about how this field and the Policies field\n\t// interact.\n\tPolicyIdentifiers []asn1.ObjectIdentifier\n\n\t// Policies contains all policy identifiers included in the certificate.\n\t// See CreateCertificate for context about how this field and the PolicyIdentifiers field\n\t// interact.\n\t// In Go 1.22, encoding/gob cannot handle and ignores this field.\n\tPolicies []OID\n\n\t// InhibitAnyPolicy and InhibitAnyPolicyZero indicate the presence and value\n\t// of the inhibitAnyPolicy extension.\n\t//\n\t// The value of InhibitAnyPolicy indicates the number of additional\n\t// certificates in the path after this certificate that may use the\n\t// anyPolicy policy OID to indicate a match with any other policy.\n\t//\n\t// When parsing a certificate, a positive non-zero InhibitAnyPolicy means\n\t// that the field was specified, -1 means it was unset, and\n\t// InhibitAnyPolicyZero being true mean that the field was explicitly set to\n\t// zero. The case of InhibitAnyPolicy==0 with InhibitAnyPolicyZero==false\n\t// should be treated equivalent to -1 (unset).\n\tInhibitAnyPolicy int\n\t// InhibitAnyPolicyZero indicates that InhibitAnyPolicy==0 should be\n\t// interpreted as an actual maximum path length of zero. Otherwise, that\n\t// combination is interpreted as InhibitAnyPolicy not being set.\n\tInhibitAnyPolicyZero bool\n\n\t// InhibitPolicyMapping and InhibitPolicyMappingZero indicate the presence\n\t// and value of the inhibitPolicyMapping field of the policyConstraints\n\t// extension.\n\t//\n\t// The value of InhibitPolicyMapping indicates the number of additional\n\t// certificates in the path after this certificate that may use policy\n\t// mapping.\n\t//\n\t// When parsing a certificate, a positive non-zero InhibitPolicyMapping\n\t// means that the field was specified, -1 means it was unset, and\n\t// InhibitPolicyMappingZero being true mean that the field was explicitly\n\t// set to zero. The case of InhibitPolicyMapping==0 with\n\t// InhibitPolicyMappingZero==false should be treated equivalent to -1\n\t// (unset).\n\tInhibitPolicyMapping int\n\t// InhibitPolicyMappingZero indicates that InhibitPolicyMapping==0 should be\n\t// interpreted as an actual maximum path length of zero. Otherwise, that\n\t// combination is interpreted as InhibitAnyPolicy not being set.\n\tInhibitPolicyMappingZero bool\n\n\t// RequireExplicitPolicy and RequireExplicitPolicyZero indicate the presence\n\t// and value of the requireExplicitPolicy field of the policyConstraints\n\t// extension.\n\t//\n\t// The value of RequireExplicitPolicy indicates the number of additional\n\t// certificates in the path after this certificate before an explicit policy\n\t// is required for the rest of the path. When an explicit policy is required,\n\t// each subsequent certificate in the path must contain a required policy OID,\n\t// or a policy OID which has been declared as equivalent through the policy\n\t// mapping extension.\n\t//\n\t// When parsing a certificate, a positive non-zero RequireExplicitPolicy\n\t// means that the field was specified, -1 means it was unset, and\n\t// RequireExplicitPolicyZero being true mean that the field was explicitly\n\t// set to zero. The case of RequireExplicitPolicy==0 with\n\t// RequireExplicitPolicyZero==false should be treated equivalent to -1\n\t// (unset).\n\tRequireExplicitPolicy int\n\t// RequireExplicitPolicyZero indicates that RequireExplicitPolicy==0 should be\n\t// interpreted as an actual maximum path length of zero. Otherwise, that\n\t// combination is interpreted as InhibitAnyPolicy not being set.\n\tRequireExplicitPolicyZero bool\n\n\t// PolicyMappings contains a list of policy mappings included in the certificate.\n\tPolicyMappings []PolicyMapping\n}\n    A Certificate represents an X.509 certificate.\n\nfunc ParseCertificate(der []byte) (*Certificate, error)\n    ParseCertificate parses a single certificate from the given ASN.1 DER data.\n\n    Before Go 1.23, ParseCertificate accepted certificates with negative serial\n    numbers. This behavior can be restored by including \"x509negativeserial=1\"\n    in the GODEBUG environment variable.\n\nfunc ParseCertificates(der []byte) ([]*Certificate, error)\n    ParseCertificates parses one or more certificates from the given ASN.1 DER\n    data. The certificates must be concatenated with no intermediate padding.\n\nfunc (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) error\n    CheckCRLSignature checks that the signature in crl is from c.\n\n    Deprecated: Use RevocationList.CheckSignatureFrom instead.\n\nfunc (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) error\n    CheckSignature verifies that signature is a valid signature over signed from\n    c's public key.\n\n    This is a low-level API that performs no validity checks on the certificate.\n\n    MD5WithRSA signatures are rejected, while SHA1WithRSA and ECDSAWithSHA1\n    signatures are currently accepted.\n\nfunc (c *Certificate) CheckSignatureFrom(parent *Certificate) error\n    CheckSignatureFrom verifies that the signature on c is a valid signature\n    from parent.\n\n    This is a low-level API that performs very limited checks, and not a full\n    path verifier. Most users should use Certificate.Verify instead.\n\nfunc (c *Certificate) CreateCRL(rand io.Reader, priv any, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)\n    CreateCRL returns a DER encoded CRL, signed by this Certificate, that\n    contains the given list of revoked certificates.\n\n    Deprecated: this method does not generate an RFC 5280 conformant X.509\n    v2 CRL. To generate a standards compliant CRL, use CreateRevocationList\n    instead.\n\nfunc (c *Certificate) Equal(other *Certificate) bool\n\nfunc (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error)\n    Verify attempts to verify c by building one or more chains from c to a\n    certificate in opts.Roots, using certificates in opts.Intermediates if\n    needed. If successful, it returns one or more chains where the first element\n    of the chain is c and the last element is from opts.Roots.\n\n    If opts.Roots is nil, the platform verifier might be used, and verification\n    details might differ from what is described below. If system roots are\n    unavailable the returned error will be of type SystemRootsError.\n\n    Name constraints in the intermediates will be applied to all names claimed\n    in the chain, not just opts.DNSName. Thus it is invalid for a leaf to claim\n    example.com if an intermediate doesn't permit it, even if example.com is\n    not the name being validated. Note that DirectoryName constraints are not\n    supported.\n\n    Name constraint validation follows the rules from RFC 5280, with the\n    addition that DNS name constraints may use the leading period format defined\n    for emails and URIs. When a constraint has a leading period it indicates\n    that at least one additional label must be prepended to the constrained name\n    to be considered valid.\n\n    Extended Key Usage values are enforced nested down a chain, so an\n    intermediate or root that enumerates EKUs prevents a leaf from asserting an\n    EKU not in that list. (While this is not specified, it is common practice in\n    order to limit the types of certificates a CA can issue.)\n\n    Certificates that use SHA1WithRSA and ECDSAWithSHA1 signatures are not\n    supported, and will not be used to build chains.\n\n    Certificates other than c in the returned chains should not be modified.\n\n    WARNING: this function doesn't do any revocation checking.\n\nfunc (c *Certificate) VerifyHostname(h string) error\n    VerifyHostname returns nil if c is a valid certificate for the named host.\n    Otherwise it returns an error describing the mismatch.\n\n    IP addresses can be optionally enclosed in square brackets and are checked\n    against the IPAddresses field. Other names are checked case insensitively\n    against the DNSNames field. If the names are valid hostnames, the\n    certificate fields can have a wildcard as the complete left-most label (e.g.\n    *.example.com).\n\n    Note that the legacy Common Name field is ignored.\n\ntype CertificateInvalidError struct {\n\tCert   *Certificate\n\tReason InvalidReason\n\tDetail string\n}\n    CertificateInvalidError results when an odd error occurs. Users of this\n    library probably want to handle all these errors uniformly.\n\nfunc (e CertificateInvalidError) Error() string\n\ntype CertificateRequest struct {\n\tRaw                      []byte // Complete ASN.1 DER content (CSR, signature algorithm and signature).\n\tRawTBSCertificateRequest []byte // Certificate request info part of raw ASN.1 DER content.\n\tRawSubjectPublicKeyInfo  []byte // DER encoded SubjectPublicKeyInfo.\n\tRawSubject               []byte // DER encoded Subject.\n\n\tVersion            int\n\tSignature          []byte\n\tSignatureAlgorithm SignatureAlgorithm\n\n\tPublicKeyAlgorithm PublicKeyAlgorithm\n\tPublicKey          any\n\n\tSubject pkix.Name\n\n\t// Attributes contains the CSR attributes that can parse as\n\t// pkix.AttributeTypeAndValueSET.\n\t//\n\t// Deprecated: Use Extensions and ExtraExtensions instead for parsing and\n\t// generating the requestedExtensions attribute.\n\tAttributes []pkix.AttributeTypeAndValueSET\n\n\t// Extensions contains all requested extensions, in raw form. When parsing\n\t// CSRs, this can be used to extract extensions that are not parsed by this\n\t// package.\n\tExtensions []pkix.Extension\n\n\t// ExtraExtensions contains extensions to be copied, raw, into any CSR\n\t// marshaled by CreateCertificateRequest. Values override any extensions\n\t// that would otherwise be produced based on the other fields but are\n\t// overridden by any extensions specified in Attributes.\n\t//\n\t// The ExtraExtensions field is not populated by ParseCertificateRequest,\n\t// see Extensions instead.\n\tExtraExtensions []pkix.Extension\n\n\t// Subject Alternate Name values.\n\tDNSNames       []string\n\tEmailAddresses []string\n\tIPAddresses    []net.IP\n\tURIs           []*url.URL\n}\n    CertificateRequest represents a PKCS #10, certificate signature request.\n\nfunc ParseCertificateRequest(asn1Data []byte) (*CertificateRequest, error)\n    ParseCertificateRequest parses a single certificate request from the given\n    ASN.1 DER data.\n\nfunc (c *CertificateRequest) CheckSignature() error\n    CheckSignature reports whether the signature on c is valid.\n\ntype ConstraintViolationError struct{}\n    ConstraintViolationError results when a requested usage is not permitted by\n    a certificate. For example: checking a signature when the public key isn't a\n    certificate signing key.\n\nfunc (ConstraintViolationError) Error() string\n\ntype ExtKeyUsage int\n    ExtKeyUsage represents an extended set of actions that are valid for a given\n    key. Each of the ExtKeyUsage* constants define a unique action.\n\nconst (\n\tExtKeyUsageAny ExtKeyUsage = iota\n\tExtKeyUsageServerAuth\n\tExtKeyUsageClientAuth\n\tExtKeyUsageCodeSigning\n\tExtKeyUsageEmailProtection\n\tExtKeyUsageIPSECEndSystem\n\tExtKeyUsageIPSECTunnel\n\tExtKeyUsageIPSECUser\n\tExtKeyUsageTimeStamping\n\tExtKeyUsageOCSPSigning\n\tExtKeyUsageMicrosoftServerGatedCrypto\n\tExtKeyUsageNetscapeServerGatedCrypto\n\tExtKeyUsageMicrosoftCommercialCodeSigning\n\tExtKeyUsageMicrosoftKernelCodeSigning\n)\ntype HostnameError struct {\n\tCertificate *Certificate\n\tHost        string\n}\n    HostnameError results when the set of authorized names doesn't match the\n    requested name.\n\nfunc (h HostnameError) Error() string\n\ntype InsecureAlgorithmError SignatureAlgorithm\n    An InsecureAlgorithmError indicates that the SignatureAlgorithm used to\n    generate the signature is not secure, and the signature has been rejected.\n\nfunc (e InsecureAlgorithmError) Error() string\n\ntype InvalidReason int\n\nconst (\n\t// NotAuthorizedToSign results when a certificate is signed by another\n\t// which isn't marked as a CA certificate.\n\tNotAuthorizedToSign InvalidReason = iota\n\t// Expired results when a certificate has expired, based on the time\n\t// given in the VerifyOptions.\n\tExpired\n\t// CANotAuthorizedForThisName results when an intermediate or root\n\t// certificate has a name constraint which doesn't permit a DNS or\n\t// other name (including IP address) in the leaf certificate.\n\tCANotAuthorizedForThisName\n\t// TooManyIntermediates results when a path length constraint is\n\t// violated.\n\tTooManyIntermediates\n\t// IncompatibleUsage results when the certificate's key usage indicates\n\t// that it may only be used for a different purpose.\n\tIncompatibleUsage\n\t// NameMismatch results when the subject name of a parent certificate\n\t// does not match the issuer name in the child.\n\tNameMismatch\n\t// NameConstraintsWithoutSANs is a legacy error and is no longer returned.\n\tNameConstraintsWithoutSANs\n\t// UnconstrainedName results when a CA certificate contains permitted\n\t// name constraints, but leaf certificate contains a name of an\n\t// unsupported or unconstrained type.\n\tUnconstrainedName\n\t// TooManyConstraints results when the number of comparison operations\n\t// needed to check a certificate exceeds the limit set by\n\t// VerifyOptions.MaxConstraintComparisions. This limit exists to\n\t// prevent pathological certificates can consuming excessive amounts of\n\t// CPU time to verify.\n\tTooManyConstraints\n\t// CANotAuthorizedForExtKeyUsage results when an intermediate or root\n\t// certificate does not permit a requested extended key usage.\n\tCANotAuthorizedForExtKeyUsage\n\t// NoValidChains results when there are no valid chains to return.\n\tNoValidChains\n)\ntype KeyUsage int\n    KeyUsage represents the set of actions that are valid for a given key.\n    It's a bitmap of the KeyUsage* constants.\n\nconst (\n\tKeyUsageDigitalSignature KeyUsage = 1 << iota\n\tKeyUsageContentCommitment\n\tKeyUsageKeyEncipherment\n\tKeyUsageDataEncipherment\n\tKeyUsageKeyAgreement\n\tKeyUsageCertSign\n\tKeyUsageCRLSign\n\tKeyUsageEncipherOnly\n\tKeyUsageDecipherOnly\n)\ntype OID struct {\n\t// Has unexported fields.\n}\n    An OID represents an ASN.1 OBJECT IDENTIFIER.\n\nfunc OIDFromInts(oid []uint64) (OID, error)\n    OIDFromInts creates a new OID using ints, each integer is a separate\n    component.\n\nfunc ParseOID(oid string) (OID, error)\n    ParseOID parses a Object Identifier string, represented by ASCII numbers\n    separated by dots.\n\nfunc (o OID) AppendBinary(b []byte) ([]byte, error)\n    AppendBinary implements encoding.BinaryAppender\n\nfunc (o OID) AppendText(b []byte) ([]byte, error)\n    AppendText implements encoding.TextAppender\n\nfunc (oid OID) Equal(other OID) bool\n    Equal returns true when oid and other represents the same Object Identifier.\n\nfunc (oid OID) EqualASN1OID(other asn1.ObjectIdentifier) bool\n    EqualASN1OID returns whether an OID equals an asn1.ObjectIdentifier.\n    If asn1.ObjectIdentifier cannot represent the OID specified by oid, because\n    a component of OID requires more than 31 bits, it returns false.\n\nfunc (o OID) MarshalBinary() ([]byte, error)\n    MarshalBinary implements encoding.BinaryMarshaler\n\nfunc (o OID) MarshalText() ([]byte, error)\n    MarshalText implements encoding.TextMarshaler\n\nfunc (oid OID) String() string\n    Strings returns the string representation of the Object Identifier.\n\nfunc (o *OID) UnmarshalBinary(b []byte) error\n    UnmarshalBinary implements encoding.BinaryUnmarshaler\n\nfunc (o *OID) UnmarshalText(text []byte) error\n    UnmarshalText implements encoding.TextUnmarshaler\n\ntype PEMCipher int\n\nconst (\n\tPEMCipherDES PEMCipher\n\tPEMCipher3DES\n\tPEMCipherAES128\n\tPEMCipherAES192\n\tPEMCipherAES256\n)\n    Possible values for the EncryptPEMBlock encryption algorithm.\n\ntype PolicyMapping struct {\n\t// IssuerDomainPolicy contains a policy OID the issuing certificate considers\n\t// equivalent to SubjectDomainPolicy in the subject certificate.\n\tIssuerDomainPolicy OID\n\t// SubjectDomainPolicy contains a OID the issuing certificate considers\n\t// equivalent to IssuerDomainPolicy in the subject certificate.\n\tSubjectDomainPolicy OID\n}\n    PolicyMapping represents a policy mapping entry in the policyMappings\n    extension.\n\ntype PublicKeyAlgorithm int\n\nconst (\n\tUnknownPublicKeyAlgorithm PublicKeyAlgorithm = iota\n\tRSA\n\tDSA // Only supported for parsing.\n\tECDSA\n\tEd25519\n)\nfunc (algo PublicKeyAlgorithm) String() string\n\ntype RevocationList struct {\n\t// Raw contains the complete ASN.1 DER content of the CRL (tbsCertList,\n\t// signatureAlgorithm, and signatureValue.)\n\tRaw []byte\n\t// RawTBSRevocationList contains just the tbsCertList portion of the ASN.1\n\t// DER.\n\tRawTBSRevocationList []byte\n\t// RawIssuer contains the DER encoded Issuer.\n\tRawIssuer []byte\n\n\t// Issuer contains the DN of the issuing certificate.\n\tIssuer pkix.Name\n\t// AuthorityKeyId is used to identify the public key associated with the\n\t// issuing certificate. It is populated from the authorityKeyIdentifier\n\t// extension when parsing a CRL. It is ignored when creating a CRL; the\n\t// extension is populated from the issuing certificate itself.\n\tAuthorityKeyId []byte\n\n\tSignature []byte\n\t// SignatureAlgorithm is used to determine the signature algorithm to be\n\t// used when signing the CRL. If 0 the default algorithm for the signing\n\t// key will be used.\n\tSignatureAlgorithm SignatureAlgorithm\n\n\t// RevokedCertificateEntries represents the revokedCertificates sequence in\n\t// the CRL. It is used when creating a CRL and also populated when parsing a\n\t// CRL. When creating a CRL, it may be empty or nil, in which case the\n\t// revokedCertificates ASN.1 sequence will be omitted from the CRL entirely.\n\tRevokedCertificateEntries []RevocationListEntry\n\n\t// RevokedCertificates is used to populate the revokedCertificates\n\t// sequence in the CRL if RevokedCertificateEntries is empty. It may be empty\n\t// or nil, in which case an empty CRL will be created.\n\t//\n\t// Deprecated: Use RevokedCertificateEntries instead.\n\tRevokedCertificates []pkix.RevokedCertificate\n\n\t// Number is used to populate the X.509 v2 cRLNumber extension in the CRL,\n\t// which should be a monotonically increasing sequence number for a given\n\t// CRL scope and CRL issuer. It is also populated from the cRLNumber\n\t// extension when parsing a CRL.\n\tNumber *big.Int\n\n\t// ThisUpdate is used to populate the thisUpdate field in the CRL, which\n\t// indicates the issuance date of the CRL.\n\tThisUpdate time.Time\n\t// NextUpdate is used to populate the nextUpdate field in the CRL, which\n\t// indicates the date by which the next CRL will be issued. NextUpdate\n\t// must be greater than ThisUpdate.\n\tNextUpdate time.Time\n\n\t// Extensions contains raw X.509 extensions. When creating a CRL,\n\t// the Extensions field is ignored, see ExtraExtensions.\n\tExtensions []pkix.Extension\n\n\t// ExtraExtensions contains any additional extensions to add directly to\n\t// the CRL.\n\tExtraExtensions []pkix.Extension\n}\n    RevocationList represents a Certificate Revocation List (CRL) as specified\n    by RFC 5280.\n\nfunc ParseRevocationList(der []byte) (*RevocationList, error)\n    ParseRevocationList parses a X509 v2 Certificate Revocation List from the\n    given ASN.1 DER data.\n\nfunc (rl *RevocationList) CheckSignatureFrom(parent *Certificate) error\n    CheckSignatureFrom verifies that the signature on rl is a valid signature\n    from issuer.\n\ntype RevocationListEntry struct {\n\t// Raw contains the raw bytes of the revokedCertificates entry. It is set when\n\t// parsing a CRL; it is ignored when generating a CRL.\n\tRaw []byte\n\n\t// SerialNumber represents the serial number of a revoked certificate. It is\n\t// both used when creating a CRL and populated when parsing a CRL. It must not\n\t// be nil.\n\tSerialNumber *big.Int\n\t// RevocationTime represents the time at which the certificate was revoked. It\n\t// is both used when creating a CRL and populated when parsing a CRL. It must\n\t// not be the zero time.\n\tRevocationTime time.Time\n\t// ReasonCode represents the reason for revocation, using the integer enum\n\t// values specified in RFC 5280 Section 5.3.1. When creating a CRL, the zero\n\t// value will result in the reasonCode extension being omitted. When parsing a\n\t// CRL, the zero value may represent either the reasonCode extension being\n\t// absent (which implies the default revocation reason of 0/Unspecified), or\n\t// it may represent the reasonCode extension being present and explicitly\n\t// containing a value of 0/Unspecified (which should not happen according to\n\t// the DER encoding rules, but can and does happen anyway).\n\tReasonCode int\n\n\t// Extensions contains raw X.509 extensions. When parsing CRL entries,\n\t// this can be used to extract non-critical extensions that are not\n\t// parsed by this package. When marshaling CRL entries, the Extensions\n\t// field is ignored, see ExtraExtensions.\n\tExtensions []pkix.Extension\n\t// ExtraExtensions contains extensions to be copied, raw, into any\n\t// marshaled CRL entries. Values override any extensions that would\n\t// otherwise be produced based on the other fields. The ExtraExtensions\n\t// field is not populated when parsing CRL entries, see Extensions.\n\tExtraExtensions []pkix.Extension\n}\n    RevocationListEntry represents an entry in the revokedCertificates sequence\n    of a CRL.\n\ntype SignatureAlgorithm int\n\nconst (\n\tUnknownSignatureAlgorithm SignatureAlgorithm = iota\n\n\tMD2WithRSA  // Unsupported.\n\tMD5WithRSA  // Only supported for signing, not verification.\n\tSHA1WithRSA // Only supported for signing, and verification of CRLs, CSRs, and OCSP responses.\n\tSHA256WithRSA\n\tSHA384WithRSA\n\tSHA512WithRSA\n\tDSAWithSHA1   // Unsupported.\n\tDSAWithSHA256 // Unsupported.\n\tECDSAWithSHA1 // Only supported for signing, and verification of CRLs, CSRs, and OCSP responses.\n\tECDSAWithSHA256\n\tECDSAWithSHA384\n\tECDSAWithSHA512\n\tSHA256WithRSAPSS\n\tSHA384WithRSAPSS\n\tSHA512WithRSAPSS\n\tPureEd25519\n)\nfunc (algo SignatureAlgorithm) String() string\n\ntype SystemRootsError struct {\n\tErr error\n}\n    SystemRootsError results when we fail to load the system root certificates.\n\nfunc (se SystemRootsError) Error() string\n\nfunc (se SystemRootsError) Unwrap() error\n\ntype UnhandledCriticalExtension struct{}\n\nfunc (h UnhandledCriticalExtension) Error() string\n\ntype UnknownAuthorityError struct {\n\tCert *Certificate\n\n\t// Has unexported fields.\n}\n    UnknownAuthorityError results when the certificate issuer is unknown\n\nfunc (e UnknownAuthorityError) Error() string\n\ntype VerifyOptions struct {\n\t// DNSName, if set, is checked against the leaf certificate with\n\t// Certificate.VerifyHostname or the platform verifier.\n\tDNSName string\n\n\t// Intermediates is an optional pool of certificates that are not trust\n\t// anchors, but can be used to form a chain from the leaf certificate to a\n\t// root certificate.\n\tIntermediates *CertPool\n\t// Roots is the set of trusted root certificates the leaf certificate needs\n\t// to chain up to. If nil, the system roots or the platform verifier are used.\n\tRoots *CertPool\n\n\t// CurrentTime is used to check the validity of all certificates in the\n\t// chain. If zero, the current time is used.\n\tCurrentTime time.Time\n\n\t// KeyUsages specifies which Extended Key Usage values are acceptable. A\n\t// chain is accepted if it allows any of the listed values. An empty list\n\t// means ExtKeyUsageServerAuth. To accept any key usage, include ExtKeyUsageAny.\n\tKeyUsages []ExtKeyUsage\n\n\t// MaxConstraintComparisions is the maximum number of comparisons to\n\t// perform when checking a given certificate's name constraints. If\n\t// zero, a sensible default is used. This limit prevents pathological\n\t// certificates from consuming excessive amounts of CPU time when\n\t// validating. It does not apply to the platform verifier.\n\tMaxConstraintComparisions int\n\n\t// CertificatePolicies specifies which certificate policy OIDs are\n\t// acceptable during policy validation. An empty CertificatePolices\n\t// field implies any valid policy is acceptable.\n\tCertificatePolicies []OID\n\n\t// Has unexported fields.\n}\n    VerifyOptions contains parameters for Certificate.Verify.\n\n"}, {"path": "stdlib/strconv.md", "category": "stdlib", "name": "stdlib/strconv", "content": "package strconv // import \"strconv\"\n\nPackage strconv implements conversions to and from string representations of\nbasic data types.\n\n# Numeric Conversions\n\nThe most common numeric conversions are Atoi (string to int) and Itoa (int to\nstring).\n\n    i, err := strconv.Atoi(\"-42\")\n    s := strconv.Itoa(-42)\n\nThese assume decimal and the Go int type.\n\nParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values:\n\n    b, err := strconv.ParseBool(\"true\")\n    f, err := strconv.ParseFloat(\"3.1415\", 64)\n    i, err := strconv.ParseInt(\"-42\", 10, 64)\n    u, err := strconv.ParseUint(\"42\", 10, 64)\n\nThe parse functions return the widest type (float64, int64, and uint64), but if\nthe size argument specifies a narrower width the result can be converted to that\nnarrower type without data loss:\n\n    s := \"2147483647\" // biggest int32\n    i64, err := strconv.ParseInt(s, 10, 32)\n    ...\n    i := int32(i64)\n\nFormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:\n\n    s := strconv.FormatBool(true)\n    s := strconv.FormatFloat(3.1415, 'E', -1, 64)\n    s := strconv.FormatInt(-42, 16)\n    s := strconv.FormatUint(42, 16)\n\nAppendBool, AppendFloat, AppendInt, and AppendUint are similar but append the\nformatted value to a destination slice.\n\n# String Conversions\n\nQuote and QuoteToASCII convert strings to quoted Go string literals. The latter\nguarantees that the result is an ASCII string, by escaping any non-ASCII Unicode\nwith \\u:\n\n    q := strconv.Quote(\"Hello, \u4e16\u754c\")\n    q := strconv.QuoteToASCII(\"Hello, \u4e16\u754c\")\n\nQuoteRune and QuoteRuneToASCII are similar but accept runes and return quoted Go\nrune literals.\n\nUnquote and UnquoteChar unquote Go string and rune literals.\n\nCONSTANTS\n\nconst IntSize = intSize\n    IntSize is the size in bits of an int or uint value.\n\n\nVARIABLES\n\nvar ErrRange = errors.New(\"value out of range\")\n    ErrRange indicates that a value is out of range for the target type.\n\nvar ErrSyntax = errors.New(\"invalid syntax\")\n    ErrSyntax indicates that a value does not have the right syntax for the\n    target type.\n\n\nFUNCTIONS\n\nfunc AppendBool(dst []byte, b bool) []byte\n    AppendBool appends \"true\" or \"false\", according to the value of b, to dst\n    and returns the extended buffer.\n\nfunc AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte\n    AppendFloat appends the string form of the floating-point number f,\n    as generated by FormatFloat, to dst and returns the extended buffer.\n\nfunc AppendInt(dst []byte, i int64, base int) []byte\n    AppendInt appends the string form of the integer i, as generated by\n    FormatInt, to dst and returns the extended buffer.\n\nfunc AppendQuote(dst []byte, s string) []byte\n    AppendQuote appends a double-quoted Go string literal representing s,\n    as generated by Quote, to dst and returns the extended buffer.\n\nfunc AppendQuoteRune(dst []byte, r rune) []byte\n    AppendQuoteRune appends a single-quoted Go character literal representing\n    the rune, as generated by QuoteRune, to dst and returns the extended buffer.\n\nfunc AppendQuoteRuneToASCII(dst []byte, r rune) []byte\n    AppendQuoteRuneToASCII appends a single-quoted Go character literal\n    representing the rune, as generated by QuoteRuneToASCII, to dst and returns\n    the extended buffer.\n\nfunc AppendQuoteRuneToGraphic(dst []byte, r rune) []byte\n    AppendQuoteRuneToGraphic appends a single-quoted Go character literal\n    representing the rune, as generated by QuoteRuneToGraphic, to dst and\n    returns the extended buffer.\n\nfunc AppendQuoteToASCII(dst []byte, s string) []byte\n    AppendQuoteToASCII appends a double-quoted Go string literal representing s,\n    as generated by QuoteToASCII, to dst and returns the extended buffer.\n\nfunc AppendQuoteToGraphic(dst []byte, s string) []byte\n    AppendQuoteToGraphic appends a double-quoted Go string literal representing\n    s, as generated by QuoteToGraphic, to dst and returns the extended buffer.\n\nfunc AppendUint(dst []byte, i uint64, base int) []byte\n    AppendUint appends the string form of the unsigned integer i, as generated\n    by FormatUint, to dst and returns the extended buffer.\n\nfunc Atoi(s string) (int, error)\n    Atoi is equivalent to ParseInt(s, 10, 0), converted to type int.\n\nfunc CanBackquote(s string) bool\n    CanBackquote reports whether the string s can be represented unchanged as a\n    single-line backquoted string without control characters other than tab.\n\nfunc FormatBool(b bool) string\n    FormatBool returns \"true\" or \"false\" according to the value of b.\n\nfunc FormatComplex(c complex128, fmt byte, prec, bitSize int) string\n    FormatComplex converts the complex number c to a string of the form (a+bi)\n    where a and b are the real and imaginary parts, formatted according to the\n    format fmt and precision prec.\n\n    The format fmt and precision prec have the same meaning as in FormatFloat.\n    It rounds the result assuming that the original was obtained from a\n    complex value of bitSize bits, which must be 64 for complex64 and 128 for\n    complex128.\n\nfunc FormatFloat(f float64, fmt byte, prec, bitSize int) string\n    FormatFloat converts the floating-point number f to a string, according to\n    the format fmt and precision prec. It rounds the result assuming that the\n    original was obtained from a floating-point value of bitSize bits (32 for\n    float32, 64 for float64).\n\n    The format fmt is one of\n      - 'b' (-ddddp\u00b1ddd, a binary exponent),\n      - 'e' (-d.dddde\u00b1dd, a decimal exponent),\n      - 'E' (-d.ddddE\u00b1dd, a decimal exponent),\n      - 'f' (-ddd.dddd, no exponent),\n      - 'g' ('e' for large exponents, 'f' otherwise),\n      - 'G' ('E' for large exponents, 'f' otherwise),\n      - 'x' (-0xd.ddddp\u00b1ddd, a hexadecimal fraction and binary exponent), or\n      - 'X' (-0Xd.ddddP\u00b1ddd, a hexadecimal fraction and binary exponent).\n\n    The precision prec controls the number of digits (excluding the exponent)\n    printed by the 'e', 'E', 'f', 'g', 'G', 'x', and 'X' formats. For 'e', 'E',\n    'f', 'x', and 'X', it is the number of digits after the decimal point.\n    For 'g' and 'G' it is the maximum number of significant digits (trailing\n    zeros are removed). The special precision -1 uses the smallest number of\n    digits necessary such that ParseFloat will return f exactly. The exponent is\n    written as a decimal integer; for all formats other than 'b', it will be at\n    least two digits.\n\nfunc FormatInt(i int64, base int) string\n    FormatInt returns the string representation of i in the given base, for 2\n    <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit\n    values >= 10.\n\nfunc FormatUint(i uint64, base int) string\n    FormatUint returns the string representation of i in the given base,\n    for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for\n    digit values >= 10.\n\nfunc IsGraphic(r rune) bool\n    IsGraphic reports whether the rune is defined as a Graphic by Unicode.\n    Such characters include letters, marks, numbers, punctuation, symbols,\n    and spaces, from categories L, M, N, P, S, and Zs.\n\nfunc IsPrint(r rune) bool\n    IsPrint reports whether the rune is defined as printable by Go, with the\n    same definition as unicode.IsPrint: letters, numbers, punctuation, symbols\n    and ASCII space.\n\nfunc Itoa(i int) string\n    Itoa is equivalent to FormatInt(int64(i), 10).\n\nfunc ParseBool(str string) (bool, error)\n    ParseBool returns the boolean value represented by the string. It accepts 1,\n    t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value\n    returns an error.\n\nfunc ParseComplex(s string, bitSize int) (complex128, error)\n    ParseComplex converts the string s to a complex number with the precision\n    specified by bitSize: 64 for complex64, or 128 for complex128. When\n    bitSize=64, the result still has type complex128, but it will be convertible\n    to complex64 without changing its value.\n\n    The number represented by s must be of the form N, Ni, or N\u00b1Ni, where N\n    stands for a floating-point number as recognized by ParseFloat, and i is\n    the imaginary component. If the second N is unsigned, a + sign is required\n    between the two components as indicated by the \u00b1. If the second N is NaN,\n    only a + sign is accepted. The form may be parenthesized and cannot contain\n    any spaces. The resulting complex number consists of the two components\n    converted by ParseFloat.\n\n    The errors that ParseComplex returns have concrete type *NumError and\n    include err.Num = s.\n\n    If s is not syntactically well-formed, ParseComplex returns err.Err =\n    ErrSyntax.\n\n    If s is syntactically well-formed but either component is more than 1/2 ULP\n    away from the largest floating point number of the given component's size,\n    ParseComplex returns err.Err = ErrRange and c = \u00b1Inf for the respective\n    component.\n\nfunc ParseFloat(s string, bitSize int) (float64, error)\n    ParseFloat converts the string s to a floating-point number with the\n    precision specified by bitSize: 32 for float32, or 64 for float64. When\n    bitSize=32, the result still has type float64, but it will be convertible to\n    float32 without changing its value.\n\n    ParseFloat accepts decimal and hexadecimal floating-point numbers as defined\n    by the Go syntax for floating-point literals. If s is well-formed and near a\n    valid floating-point number, ParseFloat returns the nearest floating-point\n    number rounded using IEEE754 unbiased rounding. (Parsing a hexadecimal\n    floating-point value only rounds when there are more bits in the hexadecimal\n    representation than will fit in the mantissa.)\n\n    The errors that ParseFloat returns have concrete type *NumError and include\n    err.Num = s.\n\n    If s is not syntactically well-formed, ParseFloat returns err.Err =\n    ErrSyntax.\n\n    If s is syntactically well-formed but is more than 1/2 ULP away from the\n    largest floating point number of the given size, ParseFloat returns f =\n    \u00b1Inf, err.Err = ErrRange.\n\n    ParseFloat recognizes the string \"NaN\", and the (possibly signed) strings\n    \"Inf\" and \"Infinity\" as their respective special floating point values.\n    It ignores case when matching.\n\n[floating-point literals]: https://go.dev/ref/spec#Floating-point_literals\n\nfunc ParseInt(s string, base int, bitSize int) (i int64, err error)\n    ParseInt interprets a string s in the given base (0, 2 to 36) and bit size\n    (0 to 64) and returns the corresponding value i.\n\n    The string may begin with a leading sign: \"+\" or \"-\".\n\n    If the base argument is 0, the true base is implied by the string's prefix\n    following the sign (if present): 2 for \"0b\", 8 for \"0\" or \"0o\", 16 for \"0x\",\n    and 10 otherwise. Also, for argument base 0 only, underscore characters are\n    permitted as defined by the Go syntax for integer literals.\n\n    The bitSize argument specifies the integer type that the result must fit\n    into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32,\n    and int64. If bitSize is below 0 or above 64, an error is returned.\n\n    The errors that ParseInt returns have concrete type *NumError and include\n    err.Num = s. If s is empty or contains invalid digits, err.Err = ErrSyntax\n    and the returned value is 0; if the value corresponding to s cannot be\n    represented by a signed integer of the given size, err.Err = ErrRange and\n    the returned value is the maximum magnitude integer of the appropriate\n    bitSize and sign.\n\n[integer literals]: https://go.dev/ref/spec#Integer_literals\n\nfunc ParseUint(s string, base int, bitSize int) (uint64, error)\n    ParseUint is like ParseInt but for unsigned numbers.\n\n    A sign prefix is not permitted.\n\nfunc Quote(s string) string\n    Quote returns a double-quoted Go string literal representing s. The\n    returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for control\n    characters and non-printable characters as defined by IsPrint.\n\nfunc QuoteRune(r rune) string\n    QuoteRune returns a single-quoted Go character literal representing the\n    rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\n    for control characters and non-printable characters as defined by IsPrint.\n    If r is not a valid Unicode code point, it is interpreted as the Unicode\n    replacement character U+FFFD.\n\nfunc QuoteRuneToASCII(r rune) string\n    QuoteRuneToASCII returns a single-quoted Go character literal representing\n    the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n    \\u0100) for non-ASCII characters and non-printable characters as defined by\n    IsPrint. If r is not a valid Unicode code point, it is interpreted as the\n    Unicode replacement character U+FFFD.\n\nfunc QuoteRuneToGraphic(r rune) string\n    QuoteRuneToGraphic returns a single-quoted Go character literal representing\n    the rune. If the rune is not a Unicode graphic character, as defined by\n    IsGraphic, the returned string will use a Go escape sequence (\\t, \\n, \\xFF,\n    \\u0100). If r is not a valid Unicode code point, it is interpreted as the\n    Unicode replacement character U+FFFD.\n\nfunc QuoteToASCII(s string) string\n    QuoteToASCII returns a double-quoted Go string literal representing s.\n    The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\n    non-ASCII characters and non-printable characters as defined by IsPrint.\n\nfunc QuoteToGraphic(s string) string\n    QuoteToGraphic returns a double-quoted Go string literal representing s.\n    The returned string leaves Unicode graphic characters, as defined by\n    IsGraphic, unchanged and uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\n    non-graphic characters.\n\nfunc QuotedPrefix(s string) (string, error)\n    QuotedPrefix returns the quoted string (as understood by Unquote) at the\n    prefix of s. If s does not start with a valid quoted string, QuotedPrefix\n    returns an error.\n\nfunc Unquote(s string) (string, error)\n    Unquote interprets s as a single-quoted, double-quoted, or backquoted\n    Go string literal, returning the string value that s quotes. (If s is\n    single-quoted, it would be a Go character literal; Unquote returns the\n    corresponding one-character string. For an empty character literal Unquote\n    returns the empty string.)\n\nfunc UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)\n    UnquoteChar decodes the first character or byte in the escaped string or\n    character literal represented by the string s. It returns four values:\n\n     1. value, the decoded Unicode code point or byte value;\n     2. multibyte, a boolean indicating whether the decoded character requires a\n        multibyte UTF-8 representation;\n     3. tail, the remainder of the string after the character; and\n     4. an error that will be nil if the character is syntactically valid.\n\n    The second argument, quote, specifies the type of literal being parsed and\n    therefore which escaped quote character is permitted. If set to a single\n    quote, it permits the sequence \\' and disallows unescaped '. If set to a\n    double quote, it permits \\\" and disallows unescaped \". If set to zero,\n    it does not permit either escape and allows both quote characters to appear\n    unescaped.\n\n\nTYPES\n\ntype NumError struct {\n\tFunc string // the failing function (ParseBool, ParseInt, ParseUint, ParseFloat, ParseComplex)\n\tNum  string // the input\n\tErr  error  // the reason the conversion failed (e.g. ErrRange, ErrSyntax, etc.)\n}\n    A NumError records a failed conversion.\n\nfunc (e *NumError) Error() string\n\nfunc (e *NumError) Unwrap() error\n\n"}, {"path": "stdlib/image-jpeg.md", "category": "stdlib", "name": "stdlib/image-jpeg", "content": "package jpeg // import \"image/jpeg\"\n\nPackage jpeg implements a JPEG image decoder and encoder.\n\nJPEG is defined in ITU-T T.81: https://www.w3.org/Graphics/JPEG/itu-t81.pdf.\n\nCONSTANTS\n\nconst DefaultQuality = 75\n    DefaultQuality is the default quality encoding parameter.\n\n\nFUNCTIONS\n\nfunc Decode(r io.Reader) (image.Image, error)\n    Decode reads a JPEG image from r and returns it as an image.Image.\n\nfunc DecodeConfig(r io.Reader) (image.Config, error)\n    DecodeConfig returns the color model and dimensions of a JPEG image without\n    decoding the entire image.\n\nfunc Encode(w io.Writer, m image.Image, o *Options) error\n    Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given\n    options. Default parameters are used if a nil *Options is passed.\n\n\nTYPES\n\ntype FormatError string\n    A FormatError reports that the input is not a valid JPEG.\n\nfunc (e FormatError) Error() string\n\ntype Options struct {\n\tQuality int\n}\n    Options are the encoding parameters. Quality ranges from 1 to 100 inclusive,\n    higher is better.\n\ntype Reader interface {\n\tio.ByteReader\n\tio.Reader\n}\n    Deprecated: Reader is not used by the image/jpeg package and should not be\n    used by others. It is kept for compatibility.\n\ntype UnsupportedError string\n    An UnsupportedError reports that the input uses a valid but unimplemented\n    JPEG feature.\n\nfunc (e UnsupportedError) Error() string\n\n"}, {"path": "stdlib/image.md", "category": "stdlib", "name": "stdlib/image", "content": "package image // import \"image\"\n\nPackage image implements a basic 2-D image library.\n\nThe fundamental interface is called Image. An Image contains colors, which are\ndescribed in the image/color package.\n\nValues of the Image interface are created either by calling functions such as\nNewRGBA and NewPaletted, or by calling Decode on an io.Reader containing image\ndata in a format such as GIF, JPEG or PNG. Decoding any particular image format\nrequires the prior registration of a decoder function. Registration is typically\nautomatic as a side effect of initializing that format's package so that,\nto decode a PNG image, it suffices to have\n\n    import _ \"image/png\"\n\nin a program's main package. The _ means to import a package purely for its\ninitialization side effects.\n\nSee \"The Go image package\" for more details:\nhttps://golang.org/doc/articles/image_package.html\n\n# Security Considerations\n\nThe image package can be used to parse arbitrarily large images, which can cause\nresource exhaustion on machines which do not have enough memory to store them.\nWhen operating on arbitrary images, DecodeConfig should be called before\nDecode, so that the program can decide whether the image, as defined in\nthe returned header, can be safely decoded with the available resources.\nA call to Decode which produces an extremely large image, as defined in the\nheader returned by DecodeConfig, is not considered a security issue, regardless\nof whether the image is itself malformed or not. A call to DecodeConfig which\nreturns a header which does not match the image returned by Decode may be\nconsidered a security issue, and should be reported per the [Go Security\nPolicy](https://go.dev/security/policy).\n\nVARIABLES\n\nvar (\n\t// Black is an opaque black uniform image.\n\tBlack = NewUniform(color.Black)\n\t// White is an opaque white uniform image.\n\tWhite = NewUniform(color.White)\n\t// Transparent is a fully transparent uniform image.\n\tTransparent = NewUniform(color.Transparent)\n\t// Opaque is a fully opaque uniform image.\n\tOpaque = NewUniform(color.Opaque)\n)\nvar ErrFormat = errors.New(\"image: unknown format\")\n    ErrFormat indicates that decoding encountered an unknown format.\n\n\nFUNCTIONS\n\nfunc RegisterFormat(name, magic string, decode func(io.Reader) (Image, error), decodeConfig func(io.Reader) (Config, error))\n    RegisterFormat registers an image format for use by Decode. Name is the\n    name of the format, like \"jpeg\" or \"png\". Magic is the magic prefix\n    that identifies the format's encoding. The magic string can contain \"?\"\n    wildcards that each match any one byte. Decode is the function that decodes\n    the encoded image. DecodeConfig is the function that decodes just its\n    configuration.\n\n\nTYPES\n\ntype Alpha struct {\n\t// Pix holds the image's pixels, as alpha values. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].\n\tPix []uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride int\n\t// Rect is the image's bounds.\n\tRect Rectangle\n}\n    Alpha is an in-memory image whose At method returns color.Alpha values.\n\nfunc NewAlpha(r Rectangle) *Alpha\n    NewAlpha returns a new Alpha image with the given bounds.\n\nfunc (p *Alpha) AlphaAt(x, y int) color.Alpha\n\nfunc (p *Alpha) At(x, y int) color.Color\n\nfunc (p *Alpha) Bounds() Rectangle\n\nfunc (p *Alpha) ColorModel() color.Model\n\nfunc (p *Alpha) Opaque() bool\n    Opaque scans the entire image and reports whether it is fully opaque.\n\nfunc (p *Alpha) PixOffset(x, y int) int\n    PixOffset returns the index of the first element of Pix that corresponds to\n    the pixel at (x, y).\n\nfunc (p *Alpha) RGBA64At(x, y int) color.RGBA64\n\nfunc (p *Alpha) Set(x, y int, c color.Color)\n\nfunc (p *Alpha) SetAlpha(x, y int, c color.Alpha)\n\nfunc (p *Alpha) SetRGBA64(x, y int, c color.RGBA64)\n\nfunc (p *Alpha) SubImage(r Rectangle) Image\n    SubImage returns an image representing the portion of the image p visible\n    through r. The returned value shares pixels with the original image.\n\ntype Alpha16 struct {\n\t// Pix holds the image's pixels, as alpha values in big-endian format. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2].\n\tPix []uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride int\n\t// Rect is the image's bounds.\n\tRect Rectangle\n}\n    Alpha16 is an in-memory image whose At method returns color.Alpha16 values.\n\nfunc NewAlpha16(r Rectangle) *Alpha16\n    NewAlpha16 returns a new Alpha16 image with the given bounds.\n\nfunc (p *Alpha16) Alpha16At(x, y int) color.Alpha16\n\nfunc (p *Alpha16) At(x, y int) color.Color\n\nfunc (p *Alpha16) Bounds() Rectangle\n\nfunc (p *Alpha16) ColorModel() color.Model\n\nfunc (p *Alpha16) Opaque() bool\n    Opaque scans the entire image and reports whether it is fully opaque.\n\nfunc (p *Alpha16) PixOffset(x, y int) int\n    PixOffset returns the index of the first element of Pix that corresponds to\n    the pixel at (x, y).\n\nfunc (p *Alpha16) RGBA64At(x, y int) color.RGBA64\n\nfunc (p *Alpha16) Set(x, y int, c color.Color)\n\nfunc (p *Alpha16) SetAlpha16(x, y int, c color.Alpha16)\n\nfunc (p *Alpha16) SetRGBA64(x, y int, c color.RGBA64)\n\nfunc (p *Alpha16) SubImage(r Rectangle) Image\n    SubImage returns an image representing the portion of the image p visible\n    through r. The returned value shares pixels with the original image.\n\ntype CMYK struct {\n\t// Pix holds the image's pixels, in C, M, Y, K order. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].\n\tPix []uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride int\n\t// Rect is the image's bounds.\n\tRect Rectangle\n}\n    CMYK is an in-memory image whose At method returns color.CMYK values.\n\nfunc NewCMYK(r Rectangle) *CMYK\n    NewCMYK returns a new CMYK image with the given bounds.\n\nfunc (p *CMYK) At(x, y int) color.Color\n\nfunc (p *CMYK) Bounds() Rectangle\n\nfunc (p *CMYK) CMYKAt(x, y int) color.CMYK\n\nfunc (p *CMYK) ColorModel() color.Model\n\nfunc (p *CMYK) Opaque() bool\n    Opaque scans the entire image and reports whether it is fully opaque.\n\nfunc (p *CMYK) PixOffset(x, y int) int\n    PixOffset returns the index of the first element of Pix that corresponds to\n    the pixel at (x, y).\n\nfunc (p *CMYK) RGBA64At(x, y int) color.RGBA64\n\nfunc (p *CMYK) Set(x, y int, c color.Color)\n\nfunc (p *CMYK) SetCMYK(x, y int, c color.CMYK)\n\nfunc (p *CMYK) SetRGBA64(x, y int, c color.RGBA64)\n\nfunc (p *CMYK) SubImage(r Rectangle) Image\n    SubImage returns an image representing the portion of the image p visible\n    through r. The returned value shares pixels with the original image.\n\ntype Config struct {\n\tColorModel    color.Model\n\tWidth, Height int\n}\n    Config holds an image's color model and dimensions.\n\nfunc DecodeConfig(r io.Reader) (Config, string, error)\n    DecodeConfig decodes the color model and dimensions of an image that has\n    been encoded in a registered format. The string returned is the format name\n    used during format registration. Format registration is typically done by an\n    init function in the codec-specific package.\n\ntype Gray struct {\n\t// Pix holds the image's pixels, as gray values. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].\n\tPix []uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride int\n\t// Rect is the image's bounds.\n\tRect Rectangle\n}\n    Gray is an in-memory image whose At method returns color.Gray values.\n\nfunc NewGray(r Rectangle) *Gray\n    NewGray returns a new Gray image with the given bounds.\n\nfunc (p *Gray) At(x, y int) color.Color\n\nfunc (p *Gray) Bounds() Rectangle\n\nfunc (p *Gray) ColorModel() color.Model\n\nfunc (p *Gray) GrayAt(x, y int) color.Gray\n\nfunc (p *Gray) Opaque() bool\n    Opaque scans the entire image and reports whether it is fully opaque.\n\nfunc (p *Gray) PixOffset(x, y int) int\n    PixOffset returns the index of the first element of Pix that corresponds to\n    the pixel at (x, y).\n\nfunc (p *Gray) RGBA64At(x, y int) color.RGBA64\n\nfunc (p *Gray) Set(x, y int, c color.Color)\n\nfunc (p *Gray) SetGray(x, y int, c color.Gray)\n\nfunc (p *Gray) SetRGBA64(x, y int, c color.RGBA64)\n\nfunc (p *Gray) SubImage(r Rectangle) Image\n    SubImage returns an image representing the portion of the image p visible\n    through r. The returned value shares pixels with the original image.\n\ntype Gray16 struct {\n\t// Pix holds the image's pixels, as gray values in big-endian format. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2].\n\tPix []uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride int\n\t// Rect is the image's bounds.\n\tRect Rectangle\n}\n    Gray16 is an in-memory image whose At method returns color.Gray16 values.\n\nfunc NewGray16(r Rectangle) *Gray16\n    NewGray16 returns a new Gray16 image with the given bounds.\n\nfunc (p *Gray16) At(x, y int) color.Color\n\nfunc (p *Gray16) Bounds() Rectangle\n\nfunc (p *Gray16) ColorModel() color.Model\n\nfunc (p *Gray16) Gray16At(x, y int) color.Gray16\n\nfunc (p *Gray16) Opaque() bool\n    Opaque scans the entire image and reports whether it is fully opaque.\n\nfunc (p *Gray16) PixOffset(x, y int) int\n    PixOffset returns the index of the first element of Pix that corresponds to\n    the pixel at (x, y).\n\nfunc (p *Gray16) RGBA64At(x, y int) color.RGBA64\n\nfunc (p *Gray16) Set(x, y int, c color.Color)\n\nfunc (p *Gray16) SetGray16(x, y int, c color.Gray16)\n\nfunc (p *Gray16) SetRGBA64(x, y int, c color.RGBA64)\n\nfunc (p *Gray16) SubImage(r Rectangle) Image\n    SubImage returns an image representing the portion of the image p visible\n    through r. The returned value shares pixels with the original image.\n\ntype Image interface {\n\t// ColorModel returns the Image's color model.\n\tColorModel() color.Model\n\t// Bounds returns the domain for which At can return non-zero color.\n\t// The bounds do not necessarily contain the point (0, 0).\n\tBounds() Rectangle\n\t// At returns the color of the pixel at (x, y).\n\t// At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid.\n\t// At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one.\n\tAt(x, y int) color.Color\n}\n    Image is a finite rectangular grid of color.Color values taken from a color\n    model.\n\nfunc Decode(r io.Reader) (Image, string, error)\n    Decode decodes an image that has been encoded in a registered format.\n    The string returned is the format name used during format registration.\n    Format registration is typically done by an init function in the codec-\n    specific package.\n\ntype NRGBA struct {\n\t// Pix holds the image's pixels, in R, G, B, A order. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].\n\tPix []uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride int\n\t// Rect is the image's bounds.\n\tRect Rectangle\n}\n    NRGBA is an in-memory image whose At method returns color.NRGBA values.\n\nfunc NewNRGBA(r Rectangle) *NRGBA\n    NewNRGBA returns a new NRGBA image with the given bounds.\n\nfunc (p *NRGBA) At(x, y int) color.Color\n\nfunc (p *NRGBA) Bounds() Rectangle\n\nfunc (p *NRGBA) ColorModel() color.Model\n\nfunc (p *NRGBA) NRGBAAt(x, y int) color.NRGBA\n\nfunc (p *NRGBA) Opaque() bool\n    Opaque scans the entire image and reports whether it is fully opaque.\n\nfunc (p *NRGBA) PixOffset(x, y int) int\n    PixOffset returns the index of the first element of Pix that corresponds to\n    the pixel at (x, y).\n\nfunc (p *NRGBA) RGBA64At(x, y int) color.RGBA64\n\nfunc (p *NRGBA) Set(x, y int, c color.Color)\n\nfunc (p *NRGBA) SetNRGBA(x, y int, c color.NRGBA)\n\nfunc (p *NRGBA) SetRGBA64(x, y int, c color.RGBA64)\n\nfunc (p *NRGBA) SubImage(r Rectangle) Image\n    SubImage returns an image representing the portion of the image p visible\n    through r. The returned value shares pixels with the original image.\n\ntype NRGBA64 struct {\n\t// Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8].\n\tPix []uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride int\n\t// Rect is the image's bounds.\n\tRect Rectangle\n}\n    NRGBA64 is an in-memory image whose At method returns color.NRGBA64 values.\n\nfunc NewNRGBA64(r Rectangle) *NRGBA64\n    NewNRGBA64 returns a new NRGBA64 image with the given bounds.\n\nfunc (p *NRGBA64) At(x, y int) color.Color\n\nfunc (p *NRGBA64) Bounds() Rectangle\n\nfunc (p *NRGBA64) ColorModel() color.Model\n\nfunc (p *NRGBA64) NRGBA64At(x, y int) color.NRGBA64\n\nfunc (p *NRGBA64) Opaque() bool\n    Opaque scans the entire image and reports whether it is fully opaque.\n\nfunc (p *NRGBA64) PixOffset(x, y int) int\n    PixOffset returns the index of the first element of Pix that corresponds to\n    the pixel at (x, y).\n\nfunc (p *NRGBA64) RGBA64At(x, y int) color.RGBA64\n\nfunc (p *NRGBA64) Set(x, y int, c color.Color)\n\nfunc (p *NRGBA64) SetNRGBA64(x, y int, c color.NRGBA64)\n\nfunc (p *NRGBA64) SetRGBA64(x, y int, c color.RGBA64)\n\nfunc (p *NRGBA64) SubImage(r Rectangle) Image\n    SubImage returns an image representing the portion of the image p visible\n    through r. The returned value shares pixels with the original image.\n\ntype NYCbCrA struct {\n\tYCbCr\n\tA       []uint8\n\tAStride int\n}\n    NYCbCrA is an in-memory image of non-alpha-premultiplied Y'CbCr-with-alpha\n    colors. A and AStride are analogous to the Y and YStride fields of the\n    embedded YCbCr.\n\nfunc NewNYCbCrA(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *NYCbCrA\n    NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample\n    ratio.\n\nfunc (p *NYCbCrA) AOffset(x, y int) int\n    AOffset returns the index of the first element of A that corresponds to the\n    pixel at (x, y).\n\nfunc (p *NYCbCrA) At(x, y int) color.Color\n\nfunc (p *NYCbCrA) ColorModel() color.Model\n\nfunc (p *NYCbCrA) NYCbCrAAt(x, y int) color.NYCbCrA\n\nfunc (p *NYCbCrA) Opaque() bool\n    Opaque scans the entire image and reports whether it is fully opaque.\n\nfunc (p *NYCbCrA) RGBA64At(x, y int) color.RGBA64\n\nfunc (p *NYCbCrA) SubImage(r Rectangle) Image\n    SubImage returns an image representing the portion of the image p visible\n    through r. The returned value shares pixels with the original image.\n\ntype Paletted struct {\n\t// Pix holds the image's pixels, as palette indices. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].\n\tPix []uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride int\n\t// Rect is the image's bounds.\n\tRect Rectangle\n\t// Palette is the image's palette.\n\tPalette color.Palette\n}\n    Paletted is an in-memory image of uint8 indices into a given palette.\n\nfunc NewPaletted(r Rectangle, p color.Palette) *Paletted\n    NewPaletted returns a new Paletted image with the given width, height and\n    palette.\n\nfunc (p *Paletted) At(x, y int) color.Color\n\nfunc (p *Paletted) Bounds() Rectangle\n\nfunc (p *Paletted) ColorIndexAt(x, y int) uint8\n\nfunc (p *Paletted) ColorModel() color.Model\n\nfunc (p *Paletted) Opaque() bool\n    Opaque scans the entire image and reports whether it is fully opaque.\n\nfunc (p *Paletted) PixOffset(x, y int) int\n    PixOffset returns the index of the first element of Pix that corresponds to\n    the pixel at (x, y).\n\nfunc (p *Paletted) RGBA64At(x, y int) color.RGBA64\n\nfunc (p *Paletted) Set(x, y int, c color.Color)\n\nfunc (p *Paletted) SetColorIndex(x, y int, index uint8)\n\nfunc (p *Paletted) SetRGBA64(x, y int, c color.RGBA64)\n\nfunc (p *Paletted) SubImage(r Rectangle) Image\n    SubImage returns an image representing the portion of the image p visible\n    through r. The returned value shares pixels with the original image.\n\ntype PalettedImage interface {\n\t// ColorIndexAt returns the palette index of the pixel at (x, y).\n\tColorIndexAt(x, y int) uint8\n\tImage\n}\n    PalettedImage is an image whose colors may come from a limited palette.\n    If m is a PalettedImage and m.ColorModel() returns a color.Palette p, then\n    m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m's color\n    model is not a color.Palette, then ColorIndexAt's behavior is undefined.\n\ntype Point struct {\n\tX, Y int\n}\n    A Point is an X, Y coordinate pair. The axes increase right and down.\n\nvar ZP Point\n    ZP is the zero Point.\n\n    Deprecated: Use a literal image.Point instead.\n\nfunc Pt(X, Y int) Point\n    Pt is shorthand for Point{X, Y}.\n\nfunc (p Point) Add(q Point) Point\n    Add returns the vector p+q.\n\nfunc (p Point) Div(k int) Point\n    Div returns the vector p/k.\n\nfunc (p Point) Eq(q Point) bool\n    Eq reports whether p and q are equal.\n\nfunc (p Point) In(r Rectangle) bool\n    In reports whether p is in r.\n\nfunc (p Point) Mod(r Rectangle) Point\n    Mod returns the point q in r such that p.X-q.X is a multiple of r's width\n    and p.Y-q.Y is a multiple of r's height.\n\nfunc (p Point) Mul(k int) Point\n    Mul returns the vector p*k.\n\nfunc (p Point) String() string\n    String returns a string representation of p like \"(3,4)\".\n\nfunc (p Point) Sub(q Point) Point\n    Sub returns the vector p-q.\n\ntype RGBA struct {\n\t// Pix holds the image's pixels, in R, G, B, A order. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].\n\tPix []uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride int\n\t// Rect is the image's bounds.\n\tRect Rectangle\n}\n    RGBA is an in-memory image whose At method returns color.RGBA values.\n\nfunc NewRGBA(r Rectangle) *RGBA\n    NewRGBA returns a new RGBA image with the given bounds.\n\nfunc (p *RGBA) At(x, y int) color.Color\n\nfunc (p *RGBA) Bounds() Rectangle\n\nfunc (p *RGBA) ColorModel() color.Model\n\nfunc (p *RGBA) Opaque() bool\n    Opaque scans the entire image and reports whether it is fully opaque.\n\nfunc (p *RGBA) PixOffset(x, y int) int\n    PixOffset returns the index of the first element of Pix that corresponds to\n    the pixel at (x, y).\n\nfunc (p *RGBA) RGBA64At(x, y int) color.RGBA64\n\nfunc (p *RGBA) RGBAAt(x, y int) color.RGBA\n\nfunc (p *RGBA) Set(x, y int, c color.Color)\n\nfunc (p *RGBA) SetRGBA(x, y int, c color.RGBA)\n\nfunc (p *RGBA) SetRGBA64(x, y int, c color.RGBA64)\n\nfunc (p *RGBA) SubImage(r Rectangle) Image\n    SubImage returns an image representing the portion of the image p visible\n    through r. The returned value shares pixels with the original image.\n\ntype RGBA64 struct {\n\t// Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8].\n\tPix []uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride int\n\t// Rect is the image's bounds.\n\tRect Rectangle\n}\n    RGBA64 is an in-memory image whose At method returns color.RGBA64 values.\n\nfunc NewRGBA64(r Rectangle) *RGBA64\n    NewRGBA64 returns a new RGBA64 image with the given bounds.\n\nfunc (p *RGBA64) At(x, y int) color.Color\n\nfunc (p *RGBA64) Bounds() Rectangle\n\nfunc (p *RGBA64) ColorModel() color.Model\n\nfunc (p *RGBA64) Opaque() bool\n    Opaque scans the entire image and reports whether it is fully opaque.\n\nfunc (p *RGBA64) PixOffset(x, y int) int\n    PixOffset returns the index of the first element of Pix that corresponds to\n    the pixel at (x, y).\n\nfunc (p *RGBA64) RGBA64At(x, y int) color.RGBA64\n\nfunc (p *RGBA64) Set(x, y int, c color.Color)\n\nfunc (p *RGBA64) SetRGBA64(x, y int, c color.RGBA64)\n\nfunc (p *RGBA64) SubImage(r Rectangle) Image\n    SubImage returns an image representing the portion of the image p visible\n    through r. The returned value shares pixels with the original image.\n\ntype RGBA64Image interface {\n\t// RGBA64At returns the RGBA64 color of the pixel at (x, y). It is\n\t// equivalent to calling At(x, y).RGBA() and converting the resulting\n\t// 32-bit return values to a color.RGBA64, but it can avoid allocations\n\t// from converting concrete color types to the color.Color interface type.\n\tRGBA64At(x, y int) color.RGBA64\n\tImage\n}\n    RGBA64Image is an Image whose pixels can be converted directly to a\n    color.RGBA64.\n\ntype Rectangle struct {\n\tMin, Max Point\n}\n    A Rectangle contains the points with Min.X <= X < Max.X, Min.Y <= Y < Max.Y.\n    It is well-formed if Min.X <= Max.X and likewise for Y. Points are always\n    well-formed. A rectangle's methods always return well-formed outputs for\n    well-formed inputs.\n\n    A Rectangle is also an Image whose bounds are the rectangle itself.\n    At returns color.Opaque for points in the rectangle and color.Transparent\n    otherwise.\n\nvar ZR Rectangle\n    ZR is the zero Rectangle.\n\n    Deprecated: Use a literal image.Rectangle instead.\n\nfunc Rect(x0, y0, x1, y1 int) Rectangle\n    Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned\n    rectangle has minimum and maximum coordinates swapped if necessary so that\n    it is well-formed.\n\nfunc (r Rectangle) Add(p Point) Rectangle\n    Add returns the rectangle r translated by p.\n\nfunc (r Rectangle) At(x, y int) color.Color\n    At implements the Image interface.\n\nfunc (r Rectangle) Bounds() Rectangle\n    Bounds implements the Image interface.\n\nfunc (r Rectangle) Canon() Rectangle\n    Canon returns the canonical version of r. The returned rectangle has minimum\n    and maximum coordinates swapped if necessary so that it is well-formed.\n\nfunc (r Rectangle) ColorModel() color.Model\n    ColorModel implements the Image interface.\n\nfunc (r Rectangle) Dx() int\n    Dx returns r's width.\n\nfunc (r Rectangle) Dy() int\n    Dy returns r's height.\n\nfunc (r Rectangle) Empty() bool\n    Empty reports whether the rectangle contains no points.\n\nfunc (r Rectangle) Eq(s Rectangle) bool\n    Eq reports whether r and s contain the same set of points. All empty\n    rectangles are considered equal.\n\nfunc (r Rectangle) In(s Rectangle) bool\n    In reports whether every point in r is in s.\n\nfunc (r Rectangle) Inset(n int) Rectangle\n    Inset returns the rectangle r inset by n, which may be negative. If either\n    of r's dimensions is less than 2*n then an empty rectangle near the center\n    of r will be returned.\n\nfunc (r Rectangle) Intersect(s Rectangle) Rectangle\n    Intersect returns the largest rectangle contained by both r and s. If the\n    two rectangles do not overlap then the zero rectangle will be returned.\n\nfunc (r Rectangle) Overlaps(s Rectangle) bool\n    Overlaps reports whether r and s have a non-empty intersection.\n\nfunc (r Rectangle) RGBA64At(x, y int) color.RGBA64\n    RGBA64At implements the RGBA64Image interface.\n\nfunc (r Rectangle) Size() Point\n    Size returns r's width and height.\n\nfunc (r Rectangle) String() string\n    String returns a string representation of r like \"(3,4)-(6,5)\".\n\nfunc (r Rectangle) Sub(p Point) Rectangle\n    Sub returns the rectangle r translated by -p.\n\nfunc (r Rectangle) Union(s Rectangle) Rectangle\n    Union returns the smallest rectangle that contains both r and s.\n\ntype Uniform struct {\n\tC color.Color\n}\n    Uniform is an infinite-sized Image of uniform color. It implements the\n    color.Color, color.Model, and Image interfaces.\n\nfunc NewUniform(c color.Color) *Uniform\n    NewUniform returns a new Uniform image of the given color.\n\nfunc (c *Uniform) At(x, y int) color.Color\n\nfunc (c *Uniform) Bounds() Rectangle\n\nfunc (c *Uniform) ColorModel() color.Model\n\nfunc (c *Uniform) Convert(color.Color) color.Color\n\nfunc (c *Uniform) Opaque() bool\n    Opaque scans the entire image and reports whether it is fully opaque.\n\nfunc (c *Uniform) RGBA() (r, g, b, a uint32)\n\nfunc (c *Uniform) RGBA64At(x, y int) color.RGBA64\n\ntype YCbCr struct {\n\tY, Cb, Cr      []uint8\n\tYStride        int\n\tCStride        int\n\tSubsampleRatio YCbCrSubsampleRatio\n\tRect           Rectangle\n}\n    YCbCr is an in-memory image of Y'CbCr colors. There is one Y sample per\n    pixel, but each Cb and Cr sample can span one or more pixels. YStride is\n    the Y slice index delta between vertically adjacent pixels. CStride is the\n    Cb and Cr slice index delta between vertically adjacent pixels that map to\n    separate chroma samples. It is not an absolute requirement, but YStride and\n    len(Y) are typically multiples of 8, and:\n\n        For 4:4:4, CStride == YStride/1 && len(Cb) == len(Cr) == len(Y)/1.\n        For 4:2:2, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/2.\n        For 4:2:0, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/4.\n        For 4:4:0, CStride == YStride/1 && len(Cb) == len(Cr) == len(Y)/2.\n        For 4:1:1, CStride == YStride/4 && len(Cb) == len(Cr) == len(Y)/4.\n        For 4:1:0, CStride == YStride/4 && len(Cb) == len(Cr) == len(Y)/8.\n\nfunc NewYCbCr(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *YCbCr\n    NewYCbCr returns a new YCbCr image with the given bounds and subsample\n    ratio.\n\nfunc (p *YCbCr) At(x, y int) color.Color\n\nfunc (p *YCbCr) Bounds() Rectangle\n\nfunc (p *YCbCr) COffset(x, y int) int\n    COffset returns the index of the first element of Cb or Cr that corresponds\n    to the pixel at (x, y).\n\nfunc (p *YCbCr) ColorModel() color.Model\n\nfunc (p *YCbCr) Opaque() bool\n\nfunc (p *YCbCr) RGBA64At(x, y int) color.RGBA64\n\nfunc (p *YCbCr) SubImage(r Rectangle) Image\n    SubImage returns an image representing the portion of the image p visible\n    through r. The returned value shares pixels with the original image.\n\nfunc (p *YCbCr) YCbCrAt(x, y int) color.YCbCr\n\nfunc (p *YCbCr) YOffset(x, y int) int\n    YOffset returns the index of the first element of Y that corresponds to the\n    pixel at (x, y).\n\ntype YCbCrSubsampleRatio int\n    YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image.\n\nconst (\n\tYCbCrSubsampleRatio444 YCbCrSubsampleRatio = iota\n\tYCbCrSubsampleRatio422\n\tYCbCrSubsampleRatio420\n\tYCbCrSubsampleRatio440\n\tYCbCrSubsampleRatio411\n\tYCbCrSubsampleRatio410\n)\nfunc (s YCbCrSubsampleRatio) String() string\n\n"}, {"path": "stdlib/math-bits.md", "category": "stdlib", "name": "stdlib/math-bits", "content": "package bits // import \"math/bits\"\n\nPackage bits implements bit counting and manipulation functions for the\npredeclared unsigned integer types.\n\nFunctions in this package may be implemented directly by the compiler,\nfor better performance. For those functions the code in this package will\nnot be used. Which functions are implemented by the compiler depends on the\narchitecture and the Go release.\n\nCONSTANTS\n\nconst UintSize = uintSize\n    UintSize is the size of a uint in bits.\n\n\nFUNCTIONS\n\nfunc Add(x, y, carry uint) (sum, carryOut uint)\n    Add returns the sum with carry of x, y and carry: sum = x + y + carry.\n    The carry input must be 0 or 1; otherwise the behavior is undefined.\n    The carryOut output is guaranteed to be 0 or 1.\n\n    This function's execution time does not depend on the inputs.\n\nfunc Add32(x, y, carry uint32) (sum, carryOut uint32)\n    Add32 returns the sum with carry of x, y and carry: sum = x + y + carry.\n    The carry input must be 0 or 1; otherwise the behavior is undefined.\n    The carryOut output is guaranteed to be 0 or 1.\n\n    This function's execution time does not depend on the inputs.\n\nfunc Add64(x, y, carry uint64) (sum, carryOut uint64)\n    Add64 returns the sum with carry of x, y and carry: sum = x + y + carry.\n    The carry input must be 0 or 1; otherwise the behavior is undefined.\n    The carryOut output is guaranteed to be 0 or 1.\n\n    This function's execution time does not depend on the inputs.\n\nfunc Div(hi, lo, y uint) (quo, rem uint)\n    Div returns the quotient and remainder of (hi, lo) divided by y: quo = (hi,\n    lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter hi\n    and the lower half in parameter lo. Div panics for y == 0 (division by zero)\n    or y <= hi (quotient overflow).\n\nfunc Div32(hi, lo, y uint32) (quo, rem uint32)\n    Div32 returns the quotient and remainder of (hi, lo) divided by y: quo =\n    (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter\n    hi and the lower half in parameter lo. Div32 panics for y == 0 (division by\n    zero) or y <= hi (quotient overflow).\n\nfunc Div64(hi, lo, y uint64) (quo, rem uint64)\n    Div64 returns the quotient and remainder of (hi, lo) divided by y: quo =\n    (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper half in parameter\n    hi and the lower half in parameter lo. Div64 panics for y == 0 (division by\n    zero) or y <= hi (quotient overflow).\n\nfunc LeadingZeros(x uint) int\n    LeadingZeros returns the number of leading zero bits in x; the result is\n    UintSize for x == 0.\n\nfunc LeadingZeros16(x uint16) int\n    LeadingZeros16 returns the number of leading zero bits in x; the result is\n    16 for x == 0.\n\nfunc LeadingZeros32(x uint32) int\n    LeadingZeros32 returns the number of leading zero bits in x; the result is\n    32 for x == 0.\n\nfunc LeadingZeros64(x uint64) int\n    LeadingZeros64 returns the number of leading zero bits in x; the result is\n    64 for x == 0.\n\nfunc LeadingZeros8(x uint8) int\n    LeadingZeros8 returns the number of leading zero bits in x; the result is 8\n    for x == 0.\n\nfunc Len(x uint) int\n    Len returns the minimum number of bits required to represent x; the result\n    is 0 for x == 0.\n\nfunc Len16(x uint16) (n int)\n    Len16 returns the minimum number of bits required to represent x; the result\n    is 0 for x == 0.\n\nfunc Len32(x uint32) (n int)\n    Len32 returns the minimum number of bits required to represent x; the result\n    is 0 for x == 0.\n\nfunc Len64(x uint64) (n int)\n    Len64 returns the minimum number of bits required to represent x; the result\n    is 0 for x == 0.\n\nfunc Len8(x uint8) int\n    Len8 returns the minimum number of bits required to represent x; the result\n    is 0 for x == 0.\n\nfunc Mul(x, y uint) (hi, lo uint)\n    Mul returns the full-width product of x and y: (hi, lo) = x * y with the\n    product bits' upper half returned in hi and the lower half returned in lo.\n\n    This function's execution time does not depend on the inputs.\n\nfunc Mul32(x, y uint32) (hi, lo uint32)\n    Mul32 returns the 64-bit product of x and y: (hi, lo) = x * y with the\n    product bits' upper half returned in hi and the lower half returned in lo.\n\n    This function's execution time does not depend on the inputs.\n\nfunc Mul64(x, y uint64) (hi, lo uint64)\n    Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y with the\n    product bits' upper half returned in hi and the lower half returned in lo.\n\n    This function's execution time does not depend on the inputs.\n\nfunc OnesCount(x uint) int\n    OnesCount returns the number of one bits (\"population count\") in x.\n\nfunc OnesCount16(x uint16) int\n    OnesCount16 returns the number of one bits (\"population count\") in x.\n\nfunc OnesCount32(x uint32) int\n    OnesCount32 returns the number of one bits (\"population count\") in x.\n\nfunc OnesCount64(x uint64) int\n    OnesCount64 returns the number of one bits (\"population count\") in x.\n\nfunc OnesCount8(x uint8) int\n    OnesCount8 returns the number of one bits (\"population count\") in x.\n\nfunc Rem(hi, lo, y uint) uint\n    Rem returns the remainder of (hi, lo) divided by y. Rem panics for y == 0\n    (division by zero) but, unlike Div, it doesn't panic on a quotient overflow.\n\nfunc Rem32(hi, lo, y uint32) uint32\n    Rem32 returns the remainder of (hi, lo) divided by y. Rem32 panics for y\n    == 0 (division by zero) but, unlike Div32, it doesn't panic on a quotient\n    overflow.\n\nfunc Rem64(hi, lo, y uint64) uint64\n    Rem64 returns the remainder of (hi, lo) divided by y. Rem64 panics for y\n    == 0 (division by zero) but, unlike Div64, it doesn't panic on a quotient\n    overflow.\n\nfunc Reverse(x uint) uint\n    Reverse returns the value of x with its bits in reversed order.\n\nfunc Reverse16(x uint16) uint16\n    Reverse16 returns the value of x with its bits in reversed order.\n\nfunc Reverse32(x uint32) uint32\n    Reverse32 returns the value of x with its bits in reversed order.\n\nfunc Reverse64(x uint64) uint64\n    Reverse64 returns the value of x with its bits in reversed order.\n\nfunc Reverse8(x uint8) uint8\n    Reverse8 returns the value of x with its bits in reversed order.\n\nfunc ReverseBytes(x uint) uint\n    ReverseBytes returns the value of x with its bytes in reversed order.\n\n    This function's execution time does not depend on the inputs.\n\nfunc ReverseBytes16(x uint16) uint16\n    ReverseBytes16 returns the value of x with its bytes in reversed order.\n\n    This function's execution time does not depend on the inputs.\n\nfunc ReverseBytes32(x uint32) uint32\n    ReverseBytes32 returns the value of x with its bytes in reversed order.\n\n    This function's execution time does not depend on the inputs.\n\nfunc ReverseBytes64(x uint64) uint64\n    ReverseBytes64 returns the value of x with its bytes in reversed order.\n\n    This function's execution time does not depend on the inputs.\n\nfunc RotateLeft(x uint, k int) uint\n    RotateLeft returns the value of x rotated left by (k mod UintSize) bits.\n    To rotate x right by k bits, call RotateLeft(x, -k).\n\n    This function's execution time does not depend on the inputs.\n\nfunc RotateLeft16(x uint16, k int) uint16\n    RotateLeft16 returns the value of x rotated left by (k mod 16) bits.\n    To rotate x right by k bits, call RotateLeft16(x, -k).\n\n    This function's execution time does not depend on the inputs.\n\nfunc RotateLeft32(x uint32, k int) uint32\n    RotateLeft32 returns the value of x rotated left by (k mod 32) bits.\n    To rotate x right by k bits, call RotateLeft32(x, -k).\n\n    This function's execution time does not depend on the inputs.\n\nfunc RotateLeft64(x uint64, k int) uint64\n    RotateLeft64 returns the value of x rotated left by (k mod 64) bits.\n    To rotate x right by k bits, call RotateLeft64(x, -k).\n\n    This function's execution time does not depend on the inputs.\n\nfunc RotateLeft8(x uint8, k int) uint8\n    RotateLeft8 returns the value of x rotated left by (k mod 8) bits. To rotate\n    x right by k bits, call RotateLeft8(x, -k).\n\n    This function's execution time does not depend on the inputs.\n\nfunc Sub(x, y, borrow uint) (diff, borrowOut uint)\n    Sub returns the difference of x, y and borrow: diff = x - y - borrow.\n    The borrow input must be 0 or 1; otherwise the behavior is undefined.\n    The borrowOut output is guaranteed to be 0 or 1.\n\n    This function's execution time does not depend on the inputs.\n\nfunc Sub32(x, y, borrow uint32) (diff, borrowOut uint32)\n    Sub32 returns the difference of x, y and borrow, diff = x - y - borrow.\n    The borrow input must be 0 or 1; otherwise the behavior is undefined.\n    The borrowOut output is guaranteed to be 0 or 1.\n\n    This function's execution time does not depend on the inputs.\n\nfunc Sub64(x, y, borrow uint64) (diff, borrowOut uint64)\n    Sub64 returns the difference of x, y and borrow: diff = x - y - borrow.\n    The borrow input must be 0 or 1; otherwise the behavior is undefined.\n    The borrowOut output is guaranteed to be 0 or 1.\n\n    This function's execution time does not depend on the inputs.\n\nfunc TrailingZeros(x uint) int\n    TrailingZeros returns the number of trailing zero bits in x; the result is\n    UintSize for x == 0.\n\nfunc TrailingZeros16(x uint16) int\n    TrailingZeros16 returns the number of trailing zero bits in x; the result is\n    16 for x == 0.\n\nfunc TrailingZeros32(x uint32) int\n    TrailingZeros32 returns the number of trailing zero bits in x; the result is\n    32 for x == 0.\n\nfunc TrailingZeros64(x uint64) int\n    TrailingZeros64 returns the number of trailing zero bits in x; the result is\n    64 for x == 0.\n\nfunc TrailingZeros8(x uint8) int\n    TrailingZeros8 returns the number of trailing zero bits in x; the result is\n    8 for x == 0.\n\n"}, {"path": "stdlib/internal-lazyregexp.md", "category": "stdlib", "name": "stdlib/internal-lazyregexp", "content": "package lazyregexp // import \"internal/lazyregexp\"\n\nPackage lazyregexp is a thin wrapper over regexp, allowing the use of global\nregexp variables without forcing them to be compiled at init.\n\nTYPES\n\ntype Regexp struct {\n\t// Has unexported fields.\n}\n    Regexp is a wrapper around regexp.Regexp, where the underlying regexp will\n    be compiled the first time it is needed.\n\nfunc New(str string) *Regexp\n    New creates a new lazy regexp, delaying the compiling work until it is first\n    needed. If the code is being run as part of tests, the regexp compiling will\n    happen immediately.\n\nfunc (r *Regexp) FindAllString(s string, n int) []string\n\nfunc (r *Regexp) FindString(s string) string\n\nfunc (r *Regexp) FindStringSubmatch(s string) []string\n\nfunc (r *Regexp) FindStringSubmatchIndex(s string) []int\n\nfunc (r *Regexp) FindSubmatch(s []byte) [][]byte\n\nfunc (r *Regexp) MatchString(s string) bool\n\nfunc (r *Regexp) ReplaceAllString(src, repl string) string\n\nfunc (r *Regexp) SubexpNames() []string\n\n"}, {"path": "stdlib/crypto-internal-boring-sig.md", "category": "stdlib", "name": "stdlib/crypto-internal-boring-sig", "content": "package sig // import \"crypto/internal/boring/sig\"\n\nPackage sig holds \u201ccode signatures\u201d that can be called and will result in\ncertain code sequences being linked into the final binary. The functions\nthemselves are no-ops.\n\nFUNCTIONS\n\nfunc BoringCrypto()\n    BoringCrypto indicates that the BoringCrypto module is present.\n\nfunc FIPSOnly()\n    FIPSOnly indicates that package crypto/tls/fipsonly is present.\n\nfunc StandardCrypto()\n    StandardCrypto indicates that standard Go crypto is present.\n\n"}, {"path": "stdlib/internal-trace-version.md", "category": "stdlib", "name": "stdlib/internal-trace-version", "content": "package version // import \"internal/trace/version\"\n\n\nFUNCTIONS\n\nfunc WriteHeader(w io.Writer, v Version) (int, error)\n    WriteHeader writes a header for a trace version v to w.\n\n\nTYPES\n\ntype Version uint32\n    Version represents the version of a trace file.\n\nconst (\n\tGo111   Version = 11 // v1\n\tGo119   Version = 19 // v1\n\tGo121   Version = 21 // v1\n\tGo122   Version = 22 // v2\n\tGo123   Version = 23 // v2\n\tGo125   Version = 25 // v2\n\tCurrent         = Go125\n)\nfunc ReadHeader(r io.Reader) (Version, error)\n    ReadHeader reads the version of the trace out of the trace file's header,\n    whose prefix must be present in v.\n\nfunc (v Version) EventName(typ tracev2.EventType) string\n    EventName returns a string name of a wire format event for a particular\n    trace version.\n\nfunc (v Version) Specs() []tracev2.EventSpec\n    Specs returns the set of event.Specs for this version.\n\nfunc (v Version) Valid() bool\n\n"}, {"path": "stdlib/vendor-golang.org-x-crypto-cryptobyte.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-crypto-cryptobyte", "content": ""}, {"path": "stdlib/path.md", "category": "stdlib", "name": "stdlib/path", "content": "package path // import \"path\"\n\nPackage path implements utility routines for manipulating slash-separated paths.\n\nThe path package should only be used for paths separated by forward slashes,\nsuch as the paths in URLs. This package does not deal with Windows paths with\ndrive letters or backslashes; to manipulate operating system paths, use the\npath/filepath package.\n\nVARIABLES\n\nvar ErrBadPattern = errors.New(\"syntax error in pattern\")\n    ErrBadPattern indicates a pattern was malformed.\n\n\nFUNCTIONS\n\nfunc Base(path string) string\n    Base returns the last element of path. Trailing slashes are removed before\n    extracting the last element. If the path is empty, Base returns \".\".\n    If the path consists entirely of slashes, Base returns \"/\".\n\nfunc Clean(path string) string\n    Clean returns the shortest path name equivalent to path by purely lexical\n    processing. It applies the following rules iteratively until no further\n    processing can be done:\n\n     1. Replace multiple slashes with a single slash.\n     2. Eliminate each . path name element (the current directory).\n     3. Eliminate each inner .. path name element (the parent directory) along\n        with the non-.. element that precedes it.\n     4. Eliminate .. elements that begin a rooted path: that is, replace \"/..\"\n        by \"/\" at the beginning of a path.\n\n    The returned path ends in a slash only if it is the root \"/\".\n\n    If the result of this process is an empty string, Clean returns the string\n    \".\".\n\n    See also Rob Pike, \u201cLexical File Names in Plan 9 or Getting Dot-Dot Right,\u201d\n    https://9p.io/sys/doc/lexnames.html\n\nfunc Dir(path string) string\n    Dir returns all but the last element of path, typically the path's\n    directory. After dropping the final element using Split, the path is Cleaned\n    and trailing slashes are removed. If the path is empty, Dir returns \".\".\n    If the path consists entirely of slashes followed by non-slash bytes,\n    Dir returns a single slash. In any other case, the returned path does not\n    end in a slash.\n\nfunc Ext(path string) string\n    Ext returns the file name extension used by path. The extension is the\n    suffix beginning at the final dot in the final slash-separated element of\n    path; it is empty if there is no dot.\n\nfunc IsAbs(path string) bool\n    IsAbs reports whether the path is absolute.\n\nfunc Join(elem ...string) string\n    Join joins any number of path elements into a single path, separating them\n    with slashes. Empty elements are ignored. The result is Cleaned. However,\n    if the argument list is empty or all its elements are empty, Join returns an\n    empty string.\n\nfunc Match(pattern, name string) (matched bool, err error)\n    Match reports whether name matches the shell pattern. The pattern syntax is:\n\n        pattern:\n        \t{ term }\n        term:\n        \t'*'         matches any sequence of non-/ characters\n        \t'?'         matches any single non-/ character\n        \t'[' [ '^' ] { character-range } ']'\n        \t            character class (must be non-empty)\n        \tc           matches character c (c != '*', '?', '\\\\', '[')\n        \t'\\\\' c      matches character c\n\n        character-range:\n        \tc           matches character c (c != '\\\\', '-', ']')\n        \t'\\\\' c      matches character c\n        \tlo '-' hi   matches character c for lo <= c <= hi\n\n    Match requires pattern to match all of name, not just a substring. The only\n    possible returned error is ErrBadPattern, when pattern is malformed.\n\nfunc Split(path string) (dir, file string)\n    Split splits path immediately following the final slash, separating it\n    into a directory and file name component. If there is no slash in path,\n    Split returns an empty dir and file set to path. The returned values have\n    the property that path = dir+file.\n\n"}, {"path": "stdlib/mime-quotedprintable.md", "category": "stdlib", "name": "stdlib/mime-quotedprintable", "content": "package quotedprintable // import \"mime/quotedprintable\"\n\nPackage quotedprintable implements quoted-printable encoding as specified by RFC\n2045.\n\nTYPES\n\ntype Reader struct {\n\t// Has unexported fields.\n}\n    Reader is a quoted-printable decoder.\n\nfunc NewReader(r io.Reader) *Reader\n    NewReader returns a quoted-printable reader, decoding from r.\n\nfunc (r *Reader) Read(p []byte) (n int, err error)\n    Read reads and decodes quoted-printable data from the underlying reader.\n\ntype Writer struct {\n\t// Binary mode treats the writer's input as pure binary and processes end of\n\t// line bytes as binary data.\n\tBinary bool\n\n\t// Has unexported fields.\n}\n    A Writer is a quoted-printable writer that implements io.WriteCloser.\n\nfunc NewWriter(w io.Writer) *Writer\n    NewWriter returns a new Writer that writes to w.\n\nfunc (w *Writer) Close() error\n    Close closes the Writer, flushing any unwritten data to the underlying\n    io.Writer, but does not close the underlying io.Writer.\n\nfunc (w *Writer) Write(p []byte) (n int, err error)\n    Write encodes p using quoted-printable encoding and writes it to the\n    underlying io.Writer. It limits line length to 76 characters. The encoded\n    bytes are not necessarily flushed until the Writer is closed.\n\n"}, {"path": "stdlib/debug-macho.md", "category": "stdlib", "name": "stdlib/debug-macho", "content": "package macho // import \"debug/macho\"\n\nPackage macho implements access to Mach-O object files.\n\n# Security\n\nThis package is not designed to be hardened against adversarial inputs,\nand is outside the scope of https://go.dev/security/policy. In particular,\nonly basic validation is done when parsing object files. As such, care should\nbe taken when parsing untrusted inputs, as parsing malformed files may consume\nsignificant resources, or cause panics.\n\nCONSTANTS\n\nconst (\n\tMagic32  uint32 = 0xfeedface\n\tMagic64  uint32 = 0xfeedfacf\n\tMagicFat uint32 = 0xcafebabe\n)\nconst (\n\tFlagNoUndefs              uint32 = 0x1\n\tFlagIncrLink              uint32 = 0x2\n\tFlagDyldLink              uint32 = 0x4\n\tFlagBindAtLoad            uint32 = 0x8\n\tFlagPrebound              uint32 = 0x10\n\tFlagSplitSegs             uint32 = 0x20\n\tFlagLazyInit              uint32 = 0x40\n\tFlagTwoLevel              uint32 = 0x80\n\tFlagForceFlat             uint32 = 0x100\n\tFlagNoMultiDefs           uint32 = 0x200\n\tFlagNoFixPrebinding       uint32 = 0x400\n\tFlagPrebindable           uint32 = 0x800\n\tFlagAllModsBound          uint32 = 0x1000\n\tFlagSubsectionsViaSymbols uint32 = 0x2000\n\tFlagCanonical             uint32 = 0x4000\n\tFlagWeakDefines           uint32 = 0x8000\n\tFlagBindsToWeak           uint32 = 0x10000\n\tFlagAllowStackExecution   uint32 = 0x20000\n\tFlagRootSafe              uint32 = 0x40000\n\tFlagSetuidSafe            uint32 = 0x80000\n\tFlagNoReexportedDylibs    uint32 = 0x100000\n\tFlagPIE                   uint32 = 0x200000\n\tFlagDeadStrippableDylib   uint32 = 0x400000\n\tFlagHasTLVDescriptors     uint32 = 0x800000\n\tFlagNoHeapExecution       uint32 = 0x1000000\n\tFlagAppExtensionSafe      uint32 = 0x2000000\n)\n\nVARIABLES\n\nvar ErrNotFat = &FormatError{0, \"not a fat Mach-O file\", nil}\n    ErrNotFat is returned from NewFatFile or OpenFat when the file is not a\n    universal binary but may be a thin binary, based on its magic number.\n\n\nTYPES\n\ntype Cpu uint32\n    A Cpu is a Mach-O cpu type.\n\nconst (\n\tCpu386   Cpu = 7\n\tCpuAmd64 Cpu = Cpu386 | cpuArch64\n\tCpuArm   Cpu = 12\n\tCpuArm64 Cpu = CpuArm | cpuArch64\n\tCpuPpc   Cpu = 18\n\tCpuPpc64 Cpu = CpuPpc | cpuArch64\n)\nfunc (i Cpu) GoString() string\n\nfunc (i Cpu) String() string\n\ntype Dylib struct {\n\tLoadBytes\n\tName           string\n\tTime           uint32\n\tCurrentVersion uint32\n\tCompatVersion  uint32\n}\n    A Dylib represents a Mach-O load dynamic library command.\n\ntype DylibCmd struct {\n\tCmd            LoadCmd\n\tLen            uint32\n\tName           uint32\n\tTime           uint32\n\tCurrentVersion uint32\n\tCompatVersion  uint32\n}\n    A DylibCmd is a Mach-O load dynamic library command.\n\ntype Dysymtab struct {\n\tLoadBytes\n\tDysymtabCmd\n\tIndirectSyms []uint32 // indices into Symtab.Syms\n}\n    A Dysymtab represents a Mach-O dynamic symbol table command.\n\ntype DysymtabCmd struct {\n\tCmd            LoadCmd\n\tLen            uint32\n\tIlocalsym      uint32\n\tNlocalsym      uint32\n\tIextdefsym     uint32\n\tNextdefsym     uint32\n\tIundefsym      uint32\n\tNundefsym      uint32\n\tTocoffset      uint32\n\tNtoc           uint32\n\tModtaboff      uint32\n\tNmodtab        uint32\n\tExtrefsymoff   uint32\n\tNextrefsyms    uint32\n\tIndirectsymoff uint32\n\tNindirectsyms  uint32\n\tExtreloff      uint32\n\tNextrel        uint32\n\tLocreloff      uint32\n\tNlocrel        uint32\n}\n    A DysymtabCmd is a Mach-O dynamic symbol table command.\n\ntype FatArch struct {\n\tFatArchHeader\n\t*File\n}\n    A FatArch is a Mach-O File inside a FatFile.\n\ntype FatArchHeader struct {\n\tCpu    Cpu\n\tSubCpu uint32\n\tOffset uint32\n\tSize   uint32\n\tAlign  uint32\n}\n    A FatArchHeader represents a fat header for a specific image architecture.\n\ntype FatFile struct {\n\tMagic  uint32\n\tArches []FatArch\n\t// Has unexported fields.\n}\n    A FatFile is a Mach-O universal binary that contains at least one\n    architecture.\n\nfunc NewFatFile(r io.ReaderAt) (*FatFile, error)\n    NewFatFile creates a new FatFile for accessing all the Mach-O images in a\n    universal binary. The Mach-O binary is expected to start at position 0 in\n    the ReaderAt.\n\nfunc OpenFat(name string) (*FatFile, error)\n    OpenFat opens the named file using os.Open and prepares it for use as a\n    Mach-O universal binary.\n\nfunc (ff *FatFile) Close() error\n\ntype File struct {\n\tFileHeader\n\tByteOrder binary.ByteOrder\n\tLoads     []Load\n\tSections  []*Section\n\n\tSymtab   *Symtab\n\tDysymtab *Dysymtab\n\n\t// Has unexported fields.\n}\n    A File represents an open Mach-O file.\n\nfunc NewFile(r io.ReaderAt) (*File, error)\n    NewFile creates a new File for accessing a Mach-O binary in an underlying\n    reader. The Mach-O binary is expected to start at position 0 in the\n    ReaderAt.\n\nfunc Open(name string) (*File, error)\n    Open opens the named file using os.Open and prepares it for use as a Mach-O\n    binary.\n\nfunc (f *File) Close() error\n    Close closes the File. If the File was created using NewFile directly\n    instead of Open, Close has no effect.\n\nfunc (f *File) DWARF() (*dwarf.Data, error)\n    DWARF returns the DWARF debug information for the Mach-O file.\n\nfunc (f *File) ImportedLibraries() ([]string, error)\n    ImportedLibraries returns the paths of all libraries referred to by the\n    binary f that are expected to be linked with the binary at dynamic link\n    time.\n\nfunc (f *File) ImportedSymbols() ([]string, error)\n    ImportedSymbols returns the names of all symbols referred to by the binary f\n    that are expected to be satisfied by other libraries at dynamic load time.\n\nfunc (f *File) Section(name string) *Section\n    Section returns the first section with the given name, or nil if no such\n    section exists.\n\nfunc (f *File) Segment(name string) *Segment\n    Segment returns the first Segment with the given name, or nil if no such\n    segment exists.\n\ntype FileHeader struct {\n\tMagic  uint32\n\tCpu    Cpu\n\tSubCpu uint32\n\tType   Type\n\tNcmd   uint32\n\tCmdsz  uint32\n\tFlags  uint32\n}\n    A FileHeader represents a Mach-O file header.\n\ntype FormatError struct {\n\t// Has unexported fields.\n}\n    FormatError is returned by some operations if the data does not have the\n    correct format for an object file.\n\nfunc (e *FormatError) Error() string\n\ntype Load interface {\n\tRaw() []byte\n}\n    A Load represents any Mach-O load command.\n\ntype LoadBytes []byte\n    A LoadBytes is the uninterpreted bytes of a Mach-O load command.\n\nfunc (b LoadBytes) Raw() []byte\n\ntype LoadCmd uint32\n    A LoadCmd is a Mach-O load command.\n\nconst (\n\tLoadCmdSegment    LoadCmd = 0x1\n\tLoadCmdSymtab     LoadCmd = 0x2\n\tLoadCmdThread     LoadCmd = 0x4\n\tLoadCmdUnixThread LoadCmd = 0x5 // thread+stack\n\tLoadCmdDysymtab   LoadCmd = 0xb\n\tLoadCmdDylib      LoadCmd = 0xc // load dylib command\n\tLoadCmdDylinker   LoadCmd = 0xf // id dylinker command (not load dylinker command)\n\tLoadCmdSegment64  LoadCmd = 0x19\n\tLoadCmdRpath      LoadCmd = 0x8000001c\n)\nfunc (i LoadCmd) GoString() string\n\nfunc (i LoadCmd) String() string\n\ntype Nlist32 struct {\n\tName  uint32\n\tType  uint8\n\tSect  uint8\n\tDesc  uint16\n\tValue uint32\n}\n    An Nlist32 is a Mach-O 32-bit symbol table entry.\n\ntype Nlist64 struct {\n\tName  uint32\n\tType  uint8\n\tSect  uint8\n\tDesc  uint16\n\tValue uint64\n}\n    An Nlist64 is a Mach-O 64-bit symbol table entry.\n\ntype Regs386 struct {\n\tAX    uint32\n\tBX    uint32\n\tCX    uint32\n\tDX    uint32\n\tDI    uint32\n\tSI    uint32\n\tBP    uint32\n\tSP    uint32\n\tSS    uint32\n\tFLAGS uint32\n\tIP    uint32\n\tCS    uint32\n\tDS    uint32\n\tES    uint32\n\tFS    uint32\n\tGS    uint32\n}\n    Regs386 is the Mach-O 386 register structure.\n\ntype RegsAMD64 struct {\n\tAX    uint64\n\tBX    uint64\n\tCX    uint64\n\tDX    uint64\n\tDI    uint64\n\tSI    uint64\n\tBP    uint64\n\tSP    uint64\n\tR8    uint64\n\tR9    uint64\n\tR10   uint64\n\tR11   uint64\n\tR12   uint64\n\tR13   uint64\n\tR14   uint64\n\tR15   uint64\n\tIP    uint64\n\tFLAGS uint64\n\tCS    uint64\n\tFS    uint64\n\tGS    uint64\n}\n    RegsAMD64 is the Mach-O AMD64 register structure.\n\ntype Reloc struct {\n\tAddr  uint32\n\tValue uint32\n\t// when Scattered == false && Extern == true, Value is the symbol number.\n\t// when Scattered == false && Extern == false, Value is the section number.\n\t// when Scattered == true, Value is the value that this reloc refers to.\n\tType      uint8\n\tLen       uint8 // 0=byte, 1=word, 2=long, 3=quad\n\tPcrel     bool\n\tExtern    bool // valid if Scattered == false\n\tScattered bool\n}\n    A Reloc represents a Mach-O relocation.\n\ntype RelocTypeARM int\n\nconst (\n\tARM_RELOC_VANILLA        RelocTypeARM = 0\n\tARM_RELOC_PAIR           RelocTypeARM = 1\n\tARM_RELOC_SECTDIFF       RelocTypeARM = 2\n\tARM_RELOC_LOCAL_SECTDIFF RelocTypeARM = 3\n\tARM_RELOC_PB_LA_PTR      RelocTypeARM = 4\n\tARM_RELOC_BR24           RelocTypeARM = 5\n\tARM_THUMB_RELOC_BR22     RelocTypeARM = 6\n\tARM_THUMB_32BIT_BRANCH   RelocTypeARM = 7\n\tARM_RELOC_HALF           RelocTypeARM = 8\n\tARM_RELOC_HALF_SECTDIFF  RelocTypeARM = 9\n)\nfunc (r RelocTypeARM) GoString() string\n\nfunc (i RelocTypeARM) String() string\n\ntype RelocTypeARM64 int\n\nconst (\n\tARM64_RELOC_UNSIGNED            RelocTypeARM64 = 0\n\tARM64_RELOC_SUBTRACTOR          RelocTypeARM64 = 1\n\tARM64_RELOC_BRANCH26            RelocTypeARM64 = 2\n\tARM64_RELOC_PAGE21              RelocTypeARM64 = 3\n\tARM64_RELOC_PAGEOFF12           RelocTypeARM64 = 4\n\tARM64_RELOC_GOT_LOAD_PAGE21     RelocTypeARM64 = 5\n\tARM64_RELOC_GOT_LOAD_PAGEOFF12  RelocTypeARM64 = 6\n\tARM64_RELOC_POINTER_TO_GOT      RelocTypeARM64 = 7\n\tARM64_RELOC_TLVP_LOAD_PAGE21    RelocTypeARM64 = 8\n\tARM64_RELOC_TLVP_LOAD_PAGEOFF12 RelocTypeARM64 = 9\n\tARM64_RELOC_ADDEND              RelocTypeARM64 = 10\n)\nfunc (r RelocTypeARM64) GoString() string\n\nfunc (i RelocTypeARM64) String() string\n\ntype RelocTypeGeneric int\n\nconst (\n\tGENERIC_RELOC_VANILLA        RelocTypeGeneric = 0\n\tGENERIC_RELOC_PAIR           RelocTypeGeneric = 1\n\tGENERIC_RELOC_SECTDIFF       RelocTypeGeneric = 2\n\tGENERIC_RELOC_PB_LA_PTR      RelocTypeGeneric = 3\n\tGENERIC_RELOC_LOCAL_SECTDIFF RelocTypeGeneric = 4\n\tGENERIC_RELOC_TLV            RelocTypeGeneric = 5\n)\nfunc (r RelocTypeGeneric) GoString() string\n\nfunc (i RelocTypeGeneric) String() string\n\ntype RelocTypeX86_64 int\n\nconst (\n\tX86_64_RELOC_UNSIGNED   RelocTypeX86_64 = 0\n\tX86_64_RELOC_SIGNED     RelocTypeX86_64 = 1\n\tX86_64_RELOC_BRANCH     RelocTypeX86_64 = 2\n\tX86_64_RELOC_GOT_LOAD   RelocTypeX86_64 = 3\n\tX86_64_RELOC_GOT        RelocTypeX86_64 = 4\n\tX86_64_RELOC_SUBTRACTOR RelocTypeX86_64 = 5\n\tX86_64_RELOC_SIGNED_1   RelocTypeX86_64 = 6\n\tX86_64_RELOC_SIGNED_2   RelocTypeX86_64 = 7\n\tX86_64_RELOC_SIGNED_4   RelocTypeX86_64 = 8\n\tX86_64_RELOC_TLV        RelocTypeX86_64 = 9\n)\nfunc (r RelocTypeX86_64) GoString() string\n\nfunc (i RelocTypeX86_64) String() string\n\ntype Rpath struct {\n\tLoadBytes\n\tPath string\n}\n    A Rpath represents a Mach-O rpath command.\n\ntype RpathCmd struct {\n\tCmd  LoadCmd\n\tLen  uint32\n\tPath uint32\n}\n    A RpathCmd is a Mach-O rpath command.\n\ntype Section struct {\n\tSectionHeader\n\tRelocs []Reloc\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\t// Has unexported fields.\n}\n\nfunc (s *Section) Data() ([]byte, error)\n    Data reads and returns the contents of the Mach-O section.\n\nfunc (s *Section) Open() io.ReadSeeker\n    Open returns a new ReadSeeker reading the Mach-O section.\n\ntype Section32 struct {\n\tName     [16]byte\n\tSeg      [16]byte\n\tAddr     uint32\n\tSize     uint32\n\tOffset   uint32\n\tAlign    uint32\n\tReloff   uint32\n\tNreloc   uint32\n\tFlags    uint32\n\tReserve1 uint32\n\tReserve2 uint32\n}\n    A Section32 is a 32-bit Mach-O section header.\n\ntype Section64 struct {\n\tName     [16]byte\n\tSeg      [16]byte\n\tAddr     uint64\n\tSize     uint64\n\tOffset   uint32\n\tAlign    uint32\n\tReloff   uint32\n\tNreloc   uint32\n\tFlags    uint32\n\tReserve1 uint32\n\tReserve2 uint32\n\tReserve3 uint32\n}\n    A Section64 is a 64-bit Mach-O section header.\n\ntype SectionHeader struct {\n\tName   string\n\tSeg    string\n\tAddr   uint64\n\tSize   uint64\n\tOffset uint32\n\tAlign  uint32\n\tReloff uint32\n\tNreloc uint32\n\tFlags  uint32\n}\n\ntype Segment struct {\n\tLoadBytes\n\tSegmentHeader\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\t// Has unexported fields.\n}\n    A Segment represents a Mach-O 32-bit or 64-bit load segment command.\n\nfunc (s *Segment) Data() ([]byte, error)\n    Data reads and returns the contents of the segment.\n\nfunc (s *Segment) Open() io.ReadSeeker\n    Open returns a new ReadSeeker reading the segment.\n\ntype Segment32 struct {\n\tCmd     LoadCmd\n\tLen     uint32\n\tName    [16]byte\n\tAddr    uint32\n\tMemsz   uint32\n\tOffset  uint32\n\tFilesz  uint32\n\tMaxprot uint32\n\tProt    uint32\n\tNsect   uint32\n\tFlag    uint32\n}\n    A Segment32 is a 32-bit Mach-O segment load command.\n\ntype Segment64 struct {\n\tCmd     LoadCmd\n\tLen     uint32\n\tName    [16]byte\n\tAddr    uint64\n\tMemsz   uint64\n\tOffset  uint64\n\tFilesz  uint64\n\tMaxprot uint32\n\tProt    uint32\n\tNsect   uint32\n\tFlag    uint32\n}\n    A Segment64 is a 64-bit Mach-O segment load command.\n\ntype SegmentHeader struct {\n\tCmd     LoadCmd\n\tLen     uint32\n\tName    string\n\tAddr    uint64\n\tMemsz   uint64\n\tOffset  uint64\n\tFilesz  uint64\n\tMaxprot uint32\n\tProt    uint32\n\tNsect   uint32\n\tFlag    uint32\n}\n    A SegmentHeader is the header for a Mach-O 32-bit or 64-bit load segment\n    command.\n\ntype Symbol struct {\n\tName  string\n\tType  uint8\n\tSect  uint8\n\tDesc  uint16\n\tValue uint64\n}\n    A Symbol is a Mach-O 32-bit or 64-bit symbol table entry.\n\ntype Symtab struct {\n\tLoadBytes\n\tSymtabCmd\n\tSyms []Symbol\n}\n    A Symtab represents a Mach-O symbol table command.\n\ntype SymtabCmd struct {\n\tCmd     LoadCmd\n\tLen     uint32\n\tSymoff  uint32\n\tNsyms   uint32\n\tStroff  uint32\n\tStrsize uint32\n}\n    A SymtabCmd is a Mach-O symbol table command.\n\ntype Thread struct {\n\tCmd  LoadCmd\n\tLen  uint32\n\tType uint32\n\tData []uint32\n}\n    A Thread is a Mach-O thread state command.\n\ntype Type uint32\n    A Type is the Mach-O file type, e.g. an object file, executable, or dynamic\n    library.\n\nconst (\n\tTypeObj    Type = 1\n\tTypeExec   Type = 2\n\tTypeDylib  Type = 6\n\tTypeBundle Type = 8\n)\nfunc (t Type) GoString() string\n\nfunc (t Type) String() string\n\n"}, {"path": "stdlib/text-scanner.md", "category": "stdlib", "name": "stdlib/text-scanner", "content": "package scanner // import \"text/scanner\"\n\nPackage scanner provides a scanner and tokenizer for UTF-8-encoded text.\nIt takes an io.Reader providing the source, which then can be tokenized through\nrepeated calls to the Scan function. For compatibility with existing tools,\nthe NUL character is not allowed. If the first character in the source is a\nUTF-8 encoded byte order mark (BOM), it is discarded.\n\nBy default, a Scanner skips white space and Go comments and recognizes all\nliterals as defined by the Go language specification. It may be customized to\nrecognize only a subset of those literals and to recognize different identifier\nand white space characters.\n\nCONSTANTS\n\nconst (\n\tScanIdents     = 1 << -Ident\n\tScanInts       = 1 << -Int\n\tScanFloats     = 1 << -Float // includes Ints and hexadecimal floats\n\tScanChars      = 1 << -Char\n\tScanStrings    = 1 << -String\n\tScanRawStrings = 1 << -RawString\n\tScanComments   = 1 << -Comment\n\tSkipComments   = 1 << -skipComment // if set with ScanComments, comments become white space\n\tGoTokens       = ScanIdents | ScanFloats | ScanChars | ScanStrings | ScanRawStrings | ScanComments | SkipComments\n)\n    Predefined mode bits to control recognition of tokens. For instance, to\n    configure a Scanner such that it only recognizes (Go) identifiers, integers,\n    and skips comments, set the Scanner's Mode field to:\n\n        ScanIdents | ScanInts | ScanComments | SkipComments\n\n    With the exceptions of comments, which are skipped if SkipComments is set,\n    unrecognized tokens are not ignored. Instead, the scanner simply returns the\n    respective individual characters (or possibly sub-tokens). For instance,\n    if the mode is ScanIdents (not ScanStrings), the string \"foo\" is scanned as\n    the token sequence '\"' Ident '\"'.\n\n    Use GoTokens to configure the Scanner such that it accepts all Go literal\n    tokens including Go identifiers. Comments will be skipped.\n\nconst (\n\tEOF = -(iota + 1)\n\tIdent\n\tInt\n\tFloat\n\tChar\n\tString\n\tRawString\n\tComment\n)\n    The result of Scan is one of these tokens or a Unicode character.\n\nconst GoWhitespace = 1<<'\\t' | 1<<'\\n' | 1<<'\\r' | 1<<' '\n    GoWhitespace is the default value for the Scanner's Whitespace field.\n    Its value selects Go's white space characters.\n\n\nFUNCTIONS\n\nfunc TokenString(tok rune) string\n    TokenString returns a printable string for a token or Unicode character.\n\n\nTYPES\n\ntype Position struct {\n\tFilename string // filename, if any\n\tOffset   int    // byte offset, starting at 0\n\tLine     int    // line number, starting at 1\n\tColumn   int    // column number, starting at 1 (character count per line)\n}\n    Position is a value that represents a source position. A position is valid\n    if Line > 0.\n\nfunc (pos *Position) IsValid() bool\n    IsValid reports whether the position is valid.\n\nfunc (pos Position) String() string\n\ntype Scanner struct {\n\n\t// Error is called for each error encountered. If no Error\n\t// function is set, the error is reported to os.Stderr.\n\tError func(s *Scanner, msg string)\n\n\t// ErrorCount is incremented by one for each error encountered.\n\tErrorCount int\n\n\t// The Mode field controls which tokens are recognized. For instance,\n\t// to recognize Ints, set the ScanInts bit in Mode. The field may be\n\t// changed at any time.\n\tMode uint\n\n\t// The Whitespace field controls which characters are recognized\n\t// as white space. To recognize a character ch <= ' ' as white space,\n\t// set the ch'th bit in Whitespace (the Scanner's behavior is undefined\n\t// for values ch > ' '). The field may be changed at any time.\n\tWhitespace uint64\n\n\t// IsIdentRune is a predicate controlling the characters accepted\n\t// as the ith rune in an identifier. The set of valid characters\n\t// must not intersect with the set of white space characters.\n\t// If no IsIdentRune function is set, regular Go identifiers are\n\t// accepted instead. The field may be changed at any time.\n\tIsIdentRune func(ch rune, i int) bool\n\n\t// Start position of most recently scanned token; set by Scan.\n\t// Calling Init or Next invalidates the position (Line == 0).\n\t// The Filename field is always left untouched by the Scanner.\n\t// If an error is reported (via Error) and Position is invalid,\n\t// the scanner is not inside a token. Call Pos to obtain an error\n\t// position in that case, or to obtain the position immediately\n\t// after the most recently scanned token.\n\tPosition\n\t// Has unexported fields.\n}\n    A Scanner implements reading of Unicode characters and tokens from an\n    io.Reader.\n\nfunc (s *Scanner) Init(src io.Reader) *Scanner\n    Init initializes a Scanner with a new source and returns s. [Scanner.Error]\n    is set to nil, [Scanner.ErrorCount] is set to 0, [Scanner.Mode] is set to\n    GoTokens, and [Scanner.Whitespace] is set to GoWhitespace.\n\nfunc (s *Scanner) Next() rune\n    Next reads and returns the next Unicode character. It returns EOF at the\n    end of the source. It reports a read error by calling s.Error, if not nil;\n    otherwise it prints an error message to os.Stderr. Next does not update the\n    [Scanner.Position] field; use Scanner.Pos() to get the current position.\n\nfunc (s *Scanner) Peek() rune\n    Peek returns the next Unicode character in the source without advancing the\n    scanner. It returns EOF if the scanner's position is at the last character\n    of the source.\n\nfunc (s *Scanner) Pos() (pos Position)\n    Pos returns the position of the character immediately after the character\n    or token returned by the last call to Scanner.Next or Scanner.Scan. Use the\n    [Scanner.Position] field for the start position of the most recently scanned\n    token.\n\nfunc (s *Scanner) Scan() rune\n    Scan reads the next token or Unicode character from source and returns it.\n    It only recognizes tokens t for which the respective [Scanner.Mode] bit\n    (1<<-t) is set. It returns EOF at the end of the source. It reports scanner\n    errors (read and token errors) by calling s.Error, if not nil; otherwise it\n    prints an error message to os.Stderr.\n\nfunc (s *Scanner) TokenText() string\n    TokenText returns the string corresponding to the most recently scanned\n    token. Valid after calling Scanner.Scan and in calls of [Scanner.Error].\n\n"}, {"path": "stdlib/internal-coverage-cfile.md", "category": "stdlib", "name": "stdlib/internal-coverage-cfile", "content": "package cfile // import \"internal/coverage/cfile\"\n\nPackage cfile implements management of coverage files. It provides functionality\nexported in runtime/coverage as well as additional functionality used directly\nby package testing through testing/internal/testdeps.\n\nFUNCTIONS\n\nfunc ClearCounters() error\n    ClearCounters implements runtime/coverage.ClearCounters.\n\nfunc InitHook(istest bool)\n    InitHook is invoked from the main package \"init\" routine in programs built\n    with \"-cover\". This function is intended to be called only by the compiler\n    (via runtime/coverage.initHook).\n\n    If 'istest' is false, it indicates we're building a regular program (\"go\n    build -cover ...\"), in which case we immediately try to write out the\n    meta-data file, and register emitCounterData as an exit hook.\n\n    If 'istest' is true (indicating that the program in question is a Go test\n    binary), then we tentatively queue up both emitMetaData and emitCounterData\n    as exit hooks. In the normal case (e.g. regular \"go test -cover\" run) the\n    testmain.go boilerplate will run at the end of the test, write out the\n    coverage percentage, and then invoke MarkProfileEmitted to indicate that\n    no more work needs to be done. If however that call is never made, this\n    is a sign that the test binary is being used as a replacement binary for\n    the tool being tested, hence we do want to run exit hooks when the program\n    terminates.\n\nfunc MarkProfileEmitted(val bool)\n    MarkProfileEmitted signals the coverage machinery that coverage data\n    output files have already been written out, and there is no need to take\n    any additional action at exit time. This function is called from the\n    coverage-related boilerplate code in _testmain.go emitted for go unit tests.\n\nfunc ProcessCoverTestDir(dir string, cfile string, cm string, cpkg string, w io.Writer, selpkgs []string) error\n    ProcessCoverTestDir is called from testmain code when \"go test -cover\" is\n    in effect. It is not intended to be used other than internally by the Go\n    command's generated code.\n\nfunc Snapshot() float64\n    Snapshot returns a snapshot of coverage percentage at a moment of time\n    within a running test, so as to support the testing.Coverage() function.\n    This version doesn't examine coverage meta-data, so the result it returns\n    will be less accurate (more \"slop\") due to the fact that we don't look at\n    the meta data to see how many statements are associated with each counter.\n\nfunc WriteCounters(w io.Writer) error\n    WriteCounters implements runtime/coverage.WriteCounters.\n\nfunc WriteCountersDir(dir string) error\n    WriteCountersDir implements runtime/coverage.WriteCountersDir.\n\nfunc WriteMeta(w io.Writer) error\n    WriteMeta implements runtime/coverage.WriteMeta.\n\nfunc WriteMetaDir(dir string) error\n    WriteMetaDir implements runtime/coverage.WriteMetaDir.\n\n"}, {"path": "stdlib/crypto-internal-fips140-sha512.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-sha512", "content": "package sha512 // import \"crypto/internal/fips140/sha512\"\n\nPackage sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256\nhash algorithms as defined in FIPS 180-4.\n\nTYPES\n\ntype Digest struct {\n\t// Has unexported fields.\n}\n    Digest is a SHA-384, SHA-512, SHA-512/224, or SHA-512/256 hash.Hash\n    implementation.\n\nfunc New() *Digest\n    New returns a new Digest computing the SHA-512 hash.\n\nfunc New384() *Digest\n    New384 returns a new Digest computing the SHA-384 hash.\n\nfunc New512_224() *Digest\n    New512_224 returns a new Digest computing the SHA-512/224 hash.\n\nfunc New512_256() *Digest\n    New512_256 returns a new Digest computing the SHA-512/256 hash.\n\nfunc (d *Digest) AppendBinary(b []byte) ([]byte, error)\n\nfunc (d *Digest) BlockSize() int\n\nfunc (d *Digest) Clone() (hash.Cloner, error)\n\nfunc (d *Digest) MarshalBinary() ([]byte, error)\n\nfunc (d *Digest) Reset()\n\nfunc (d *Digest) Size() int\n\nfunc (d *Digest) Sum(in []byte) []byte\n\nfunc (d *Digest) UnmarshalBinary(b []byte) error\n\nfunc (d *Digest) Write(p []byte) (nn int, err error)\n\n"}, {"path": "stdlib/internal-routebsd.md", "category": "stdlib", "name": "stdlib/internal-routebsd", "content": "package routebsd // import \"internal/routebsd\"\n\nPackage routebsd supports reading interface addresses on BSD systems. This is\na very stripped down version of x/net/route, for use by the net package in the\nstandard library.\n\nTYPES\n\ntype Addr interface {\n\t// Family returns an address family.\n\tFamily() int\n}\n    An Addr represents an address associated with packet routing.\n\ntype InetAddr struct {\n\tIP netip.Addr\n}\n    An InetAddr represent an internet address using IPv4 or IPv6.\n\nfunc (a *InetAddr) Family() int\n\ntype InterfaceAddrMessage struct {\n\tVersion int    // message version\n\tType    int    // message type\n\tFlags   int    // interface flags\n\tIndex   int    // interface index\n\tAddrs   []Addr // addresses\n\n\t// Has unexported fields.\n}\n    An InterfaceAddrMessage represents an interface address message.\n\ntype InterfaceMessage struct {\n\tVersion int    // message version\n\tType    int    // message type\n\tFlags   int    // interface flags\n\tIndex   int    // interface index\n\tName    string // interface name\n\tAddrs   []Addr // addresses\n\n\t// Has unexported fields.\n}\n    An InterfaceMessage represents an interface message.\n\nfunc (m *InterfaceMessage) MTU() int\n    MTU returns the interface MTU.\n\ntype InterfaceMulticastAddrMessage struct {\n\tVersion int    // message version\n\tType    int    // message type\n\tFlags   int    // interface flags\n\tIndex   int    // interface index\n\tAddrs   []Addr // addresses\n\n\t// Has unexported fields.\n}\n    An InterfaceMulticastAddrMessage represents an interface multicast address\n    message.\n\ntype LinkAddr struct {\n\tIndex int    // interface index when attached\n\tName  string // interface name when attached\n\tAddr  []byte // link-layer address when attached\n}\n    A LinkAddr represents a link-layer address.\n\nfunc (a *LinkAddr) Family() int\n    Family implements the Family method of Addr interface.\n\ntype Message interface {\n\t// Has unexported methods.\n}\n    A Message represents a routing message.\n\nfunc FetchRIBMessages(typ, arg int) ([]Message, error)\n    FetchRIBMessages fetches a list of addressing messages for an interface.\n    The typ argument is something like syscall.NET_RT_IFLIST. The argument is an\n    interface index or 0 for all.\n\n"}, {"path": "stdlib/encoding-xml.md", "category": "stdlib", "name": "stdlib/encoding-xml", "content": "package xml // import \"encoding/xml\"\n\nPackage xml implements a simple XML 1.0 parser that understands XML name spaces.\n\nCONSTANTS\n\nconst (\n\t// Header is a generic XML header suitable for use with the output of [Marshal].\n\t// This is not automatically added to any output of this package,\n\t// it is provided as a convenience.\n\tHeader = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>` + \"\\n\"\n)\n\nVARIABLES\n\nvar HTMLAutoClose []string = htmlAutoClose\n    HTMLAutoClose is the set of HTML elements that should be considered to close\n    automatically.\n\n    See the [Decoder.Strict] and [Decoder.Entity] fields' documentation.\n\nvar HTMLEntity map[string]string = htmlEntity\n    HTMLEntity is an entity map containing translations for the standard HTML\n    entity characters.\n\n    See the [Decoder.Strict] and [Decoder.Entity] fields' documentation.\n\n\nFUNCTIONS\n\nfunc Escape(w io.Writer, s []byte)\n    Escape is like EscapeText but omits the error return value. It is provided\n    for backwards compatibility with Go 1.0. Code targeting Go 1.1 or later\n    should use EscapeText.\n\nfunc EscapeText(w io.Writer, s []byte) error\n    EscapeText writes to w the properly escaped XML equivalent of the plain text\n    data s.\n\nfunc Marshal(v any) ([]byte, error)\n    Marshal returns the XML encoding of v.\n\n    Marshal handles an array or slice by marshaling each of the elements.\n    Marshal handles a pointer by marshaling the value it points at or,\n    if the pointer is nil, by writing nothing. Marshal handles an interface\n    value by marshaling the value it contains or, if the interface value is nil,\n    by writing nothing. Marshal handles all other data by writing one or more\n    XML elements containing the data.\n\n    The name for the XML elements is taken from, in order of preference:\n      - the tag on the XMLName field, if the data is a struct\n      - the value of the XMLName field of type Name\n      - the tag of the struct field used to obtain the data\n      - the name of the struct field used to obtain the data\n      - the name of the marshaled type\n\n    The XML element for a struct contains marshaled elements for each of the\n    exported fields of the struct, with these exceptions:\n      - the XMLName field, described above, is omitted.\n      - a field with tag \"-\" is omitted.\n      - a field with tag \"name,attr\" becomes an attribute with the given name in\n        the XML element.\n      - a field with tag \",attr\" becomes an attribute with the field name in the\n        XML element.\n      - a field with tag \",chardata\" is written as character data, not as an XML\n        element.\n      - a field with tag \",cdata\" is written as character data wrapped in one or\n        more <![CDATA[ ... ]]> tags, not as an XML element.\n      - a field with tag \",innerxml\" is written verbatim, not subject to the\n        usual marshaling procedure.\n      - a field with tag \",comment\" is written as an XML comment, not subject\n        to the usual marshaling procedure. It must not contain the \"--\" string\n        within it.\n      - a field with a tag including the \"omitempty\" option is omitted if the\n        field value is empty. The empty values are false, 0, any nil pointer or\n        interface value, and any array, slice, map, or string of length zero.\n      - an anonymous struct field is handled as if the fields of its value were\n        part of the outer struct.\n      - an anonymous struct field of interface type is treated the same as\n        having that type as its name, rather than being anonymous.\n      - a field implementing Marshaler is written by calling its MarshalXML\n        method.\n      - a field implementing encoding.TextMarshaler is written by encoding the\n        result of its MarshalText method as text.\n\n    If a field uses a tag \"a>b>c\", then the element c will be nested inside\n    parent elements a and b. Fields that appear next to each other that name the\n    same parent will be enclosed in one XML element.\n\n    If the XML name for a struct field is defined by both the field tag and the\n    struct's XMLName field, the names must match.\n\n    See MarshalIndent for an example.\n\n    Marshal will return an error if asked to marshal a channel, function,\n    or map.\n\nfunc MarshalIndent(v any, prefix, indent string) ([]byte, error)\n    MarshalIndent works like Marshal, but each XML element begins on a new\n    indented line that starts with prefix and is followed by one or more copies\n    of indent according to the nesting depth.\n\nfunc Unmarshal(data []byte, v any) error\n    Unmarshal parses the XML-encoded data and stores the result in the value\n    pointed to by v, which must be an arbitrary struct, slice, or string.\n    Well-formed data that does not fit into v is discarded.\n\n    Because Unmarshal uses the reflect package, it can only assign to exported\n    (upper case) fields. Unmarshal uses a case-sensitive comparison to match XML\n    element names to tag values and struct field names.\n\n    Unmarshal maps an XML element to a struct using the following rules.\n    In the rules, the tag of a field refers to the value associated with the key\n    'xml' in the struct field's tag (see the example above).\n\n      - If the struct has a field of type []byte or string with tag \",innerxml\",\n        Unmarshal accumulates the raw XML nested inside the element in that\n        field. The rest of the rules still apply.\n\n      - If the struct has a field named XMLName of type Name, Unmarshal records\n        the element name in that field.\n\n      - If the XMLName field has an associated tag of the form \"name\" or\n        \"namespace-URL name\", the XML element must have the given name (and,\n        optionally, name space) or else Unmarshal returns an error.\n\n      - If the XML element has an attribute whose name matches a struct field\n        name with an associated tag containing \",attr\" or the explicit name\n        in a struct field tag of the form \"name,attr\", Unmarshal records the\n        attribute value in that field.\n\n      - If the XML element has an attribute not handled by the previous rule and\n        the struct has a field with an associated tag containing \",any,attr\",\n        Unmarshal records the attribute value in the first such field.\n\n      - If the XML element contains character data, that data is accumulated in\n        the first struct field that has tag \",chardata\". The struct field may\n        have type []byte or string. If there is no such field, the character\n        data is discarded.\n\n      - If the XML element contains comments, they are accumulated in the first\n        struct field that has tag \",comment\". The struct field may have type\n        []byte or string. If there is no such field, the comments are discarded.\n\n      - If the XML element contains a sub-element whose name matches the prefix\n        of a tag formatted as \"a\" or \"a>b>c\", unmarshal will descend into the\n        XML structure looking for elements with the given names, and will map\n        the innermost elements to that struct field. A tag starting with \">\" is\n        equivalent to one starting with the field name followed by \">\".\n\n      - If the XML element contains a sub-element whose name matches a struct\n        field's XMLName tag and the struct field has no explicit name tag as per\n        the previous rule, unmarshal maps the sub-element to that struct field.\n\n      - If the XML element contains a sub-element whose name matches a field\n        without any mode flags (\",attr\", \",chardata\", etc), Unmarshal maps the\n        sub-element to that struct field.\n\n      - If the XML element contains a sub-element that hasn't matched any of the\n        above rules and the struct has a field with tag \",any\", unmarshal maps\n        the sub-element to that struct field.\n\n      - An anonymous struct field is handled as if the fields of its value were\n        part of the outer struct.\n\n      - A struct field with tag \"-\" is never unmarshaled into.\n\n    If Unmarshal encounters a field type that implements the Unmarshaler\n    interface, Unmarshal calls its UnmarshalXML method to produce the\n    value from the XML element. Otherwise, if the value implements\n    encoding.TextUnmarshaler, Unmarshal calls that value's UnmarshalText method.\n\n    Unmarshal maps an XML element to a string or []byte by saving the\n    concatenation of that element's character data in the string or []byte.\n    The saved []byte is never nil.\n\n    Unmarshal maps an attribute value to a string or []byte by saving the value\n    in the string or slice.\n\n    Unmarshal maps an attribute value to an Attr by saving the attribute,\n    including its name, in the Attr.\n\n    Unmarshal maps an XML element or attribute value to a slice by extending\n    the length of the slice and mapping the element or attribute to the newly\n    created value.\n\n    Unmarshal maps an XML element or attribute value to a bool by setting it\n    to the boolean value represented by the string. Whitespace is trimmed and\n    ignored.\n\n    Unmarshal maps an XML element or attribute value to an integer or\n    floating-point field by setting the field to the result of interpreting\n    the string value in decimal. There is no check for overflow. Whitespace is\n    trimmed and ignored.\n\n    Unmarshal maps an XML element to a Name by recording the element name.\n\n    Unmarshal maps an XML element to a pointer by setting the pointer to a\n    freshly allocated value and then mapping the element to that value.\n\n    A missing element or empty attribute value will be unmarshaled as a zero\n    value. If the field is a slice, a zero value will be appended to the field.\n    Otherwise, the field will be set to its zero value.\n\n\nTYPES\n\ntype Attr struct {\n\tName  Name\n\tValue string\n}\n    An Attr represents an attribute in an XML element (Name=Value).\n\ntype CharData []byte\n    A CharData represents XML character data (raw text), in which XML escape\n    sequences have been replaced by the characters they represent.\n\nfunc (c CharData) Copy() CharData\n    Copy creates a new copy of CharData.\n\ntype Comment []byte\n    A Comment represents an XML comment of the form <!--comment-->. The bytes do\n    not include the <!-- and --> comment markers.\n\nfunc (c Comment) Copy() Comment\n    Copy creates a new copy of Comment.\n\ntype Decoder struct {\n\t// Strict defaults to true, enforcing the requirements\n\t// of the XML specification.\n\t// If set to false, the parser allows input containing common\n\t// mistakes:\n\t//\t* If an element is missing an end tag, the parser invents\n\t//\t  end tags as necessary to keep the return values from Token\n\t//\t  properly balanced.\n\t//\t* In attribute values and character data, unknown or malformed\n\t//\t  character entities (sequences beginning with &) are left alone.\n\t//\n\t// Setting:\n\t//\n\t//\td.Strict = false\n\t//\td.AutoClose = xml.HTMLAutoClose\n\t//\td.Entity = xml.HTMLEntity\n\t//\n\t// creates a parser that can handle typical HTML.\n\t//\n\t// Strict mode does not enforce the requirements of the XML name spaces TR.\n\t// In particular it does not reject name space tags using undefined prefixes.\n\t// Such tags are recorded with the unknown prefix as the name space URL.\n\tStrict bool\n\n\t// When Strict == false, AutoClose indicates a set of elements to\n\t// consider closed immediately after they are opened, regardless\n\t// of whether an end element is present.\n\tAutoClose []string\n\n\t// Entity can be used to map non-standard entity names to string replacements.\n\t// The parser behaves as if these standard mappings are present in the map,\n\t// regardless of the actual map content:\n\t//\n\t//\t\"lt\": \"<\",\n\t//\t\"gt\": \">\",\n\t//\t\"amp\": \"&\",\n\t//\t\"apos\": \"'\",\n\t//\t\"quot\": `\"`,\n\tEntity map[string]string\n\n\t// CharsetReader, if non-nil, defines a function to generate\n\t// charset-conversion readers, converting from the provided\n\t// non-UTF-8 charset into UTF-8. If CharsetReader is nil or\n\t// returns an error, parsing stops with an error. One of the\n\t// CharsetReader's result values must be non-nil.\n\tCharsetReader func(charset string, input io.Reader) (io.Reader, error)\n\n\t// DefaultSpace sets the default name space used for unadorned tags,\n\t// as if the entire XML stream were wrapped in an element containing\n\t// the attribute xmlns=\"DefaultSpace\".\n\tDefaultSpace string\n\n\t// Has unexported fields.\n}\n    A Decoder represents an XML parser reading a particular input stream.\n    The parser assumes that its input is encoded in UTF-8.\n\nfunc NewDecoder(r io.Reader) *Decoder\n    NewDecoder creates a new XML parser reading from r. If r does not implement\n    io.ByteReader, NewDecoder will do its own buffering.\n\nfunc NewTokenDecoder(t TokenReader) *Decoder\n    NewTokenDecoder creates a new XML parser using an underlying token stream.\n\nfunc (d *Decoder) Decode(v any) error\n    Decode works like Unmarshal, except it reads the decoder stream to find the\n    start element.\n\nfunc (d *Decoder) DecodeElement(v any, start *StartElement) error\n    DecodeElement works like Unmarshal except that it takes a pointer to the\n    start XML element to decode into v. It is useful when a client reads\n    some raw XML tokens itself but also wants to defer to Unmarshal for some\n    elements.\n\nfunc (d *Decoder) InputOffset() int64\n    InputOffset returns the input stream byte offset of the current decoder\n    position. The offset gives the location of the end of the most recently\n    returned token and the beginning of the next token.\n\nfunc (d *Decoder) InputPos() (line, column int)\n    InputPos returns the line of the current decoder position and the 1 based\n    input position of the line. The position gives the location of the end of\n    the most recently returned token.\n\nfunc (d *Decoder) RawToken() (Token, error)\n    RawToken is like Decoder.Token but does not verify that start and end\n    elements match and does not translate name space prefixes to their\n    corresponding URLs.\n\nfunc (d *Decoder) Skip() error\n    Skip reads tokens until it has consumed the end element matching the\n    most recent start element already consumed, skipping nested structures.\n    It returns nil if it finds an end element matching the start element;\n    otherwise it returns an error describing the problem.\n\nfunc (d *Decoder) Token() (Token, error)\n    Token returns the next XML token in the input stream. At the end of the\n    input stream, Token returns nil, io.EOF.\n\n    Slices of bytes in the returned token data refer to the parser's internal\n    buffer and remain valid only until the next call to Token. To acquire a copy\n    of the bytes, call CopyToken or the token's Copy method.\n\n    Token expands self-closing elements such as <br> into separate start and end\n    elements returned by successive calls.\n\n    Token guarantees that the StartElement and EndElement tokens it returns are\n    properly nested and matched: if Token encounters an unexpected end element\n    or EOF before all expected end elements, it will return an error.\n\n    If [Decoder.CharsetReader] is called and returns an error, the error is\n    wrapped and returned.\n\n    Token implements XML name spaces as described by\n    https://www.w3.org/TR/REC-xml-names/. Each of the Name structures contained\n    in the Token has the Space set to the URL identifying its name space when\n    known. If Token encounters an unrecognized name space prefix, it uses the\n    prefix as the Space rather than report an error.\n\ntype Directive []byte\n    A Directive represents an XML directive of the form <!text>. The bytes do\n    not include the <! and > markers.\n\nfunc (d Directive) Copy() Directive\n    Copy creates a new copy of Directive.\n\ntype Encoder struct {\n\t// Has unexported fields.\n}\n    An Encoder writes XML data to an output stream.\n\nfunc NewEncoder(w io.Writer) *Encoder\n    NewEncoder returns a new encoder that writes to w.\n\nfunc (enc *Encoder) Close() error\n    Close the Encoder, indicating that no more data will be written. It flushes\n    any buffered XML to the underlying writer and returns an error if the\n    written XML is invalid (e.g. by containing unclosed elements).\n\nfunc (enc *Encoder) Encode(v any) error\n    Encode writes the XML encoding of v to the stream.\n\n    See the documentation for Marshal for details about the conversion of Go\n    values to XML.\n\n    Encode calls Encoder.Flush before returning.\n\nfunc (enc *Encoder) EncodeElement(v any, start StartElement) error\n    EncodeElement writes the XML encoding of v to the stream, using start as the\n    outermost tag in the encoding.\n\n    See the documentation for Marshal for details about the conversion of Go\n    values to XML.\n\n    EncodeElement calls Encoder.Flush before returning.\n\nfunc (enc *Encoder) EncodeToken(t Token) error\n    EncodeToken writes the given XML token to the stream. It returns an error if\n    StartElement and EndElement tokens are not properly matched.\n\n    EncodeToken does not call Encoder.Flush, because usually it is part of\n    a larger operation such as Encoder.Encode or Encoder.EncodeElement (or\n    a custom Marshaler's MarshalXML invoked during those), and those will\n    call Flush when finished. Callers that create an Encoder and then invoke\n    EncodeToken directly, without using Encode or EncodeElement, need to call\n    Flush when finished to ensure that the XML is written to the underlying\n    writer.\n\n    EncodeToken allows writing a ProcInst with Target set to \"xml\" only as the\n    first token in the stream.\n\nfunc (enc *Encoder) Flush() error\n    Flush flushes any buffered XML to the underlying writer. See the\n    Encoder.EncodeToken documentation for details about when it is necessary.\n\nfunc (enc *Encoder) Indent(prefix, indent string)\n    Indent sets the encoder to generate XML in which each element begins on a\n    new indented line that starts with prefix and is followed by one or more\n    copies of indent according to the nesting depth.\n\ntype EndElement struct {\n\tName Name\n}\n    An EndElement represents an XML end element.\n\ntype Marshaler interface {\n\tMarshalXML(e *Encoder, start StartElement) error\n}\n    Marshaler is the interface implemented by objects that can marshal\n    themselves into valid XML elements.\n\n    MarshalXML encodes the receiver as zero or more XML elements. By convention,\n    arrays or slices are typically encoded as a sequence of elements, one per\n    entry. Using start as the element tag is not required, but doing so will\n    enable Unmarshal to match the XML elements to the correct struct field.\n    One common implementation strategy is to construct a separate value with\n    a layout corresponding to the desired XML and then to encode it using\n    e.EncodeElement. Another common strategy is to use repeated calls to\n    e.EncodeToken to generate the XML output one token at a time. The sequence\n    of encoded tokens must make up zero or more valid XML elements.\n\ntype MarshalerAttr interface {\n\tMarshalXMLAttr(name Name) (Attr, error)\n}\n    MarshalerAttr is the interface implemented by objects that can marshal\n    themselves into valid XML attributes.\n\n    MarshalXMLAttr returns an XML attribute with the encoded value of the\n    receiver. Using name as the attribute name is not required, but doing so\n    will enable Unmarshal to match the attribute to the correct struct field.\n    If MarshalXMLAttr returns the zero attribute Attr{}, no attribute will be\n    generated in the output. MarshalXMLAttr is used only for struct fields with\n    the \"attr\" option in the field tag.\n\ntype Name struct {\n\tSpace, Local string\n}\n    A Name represents an XML name (Local) annotated with a name space identifier\n    (Space). In tokens returned by Decoder.Token, the Space identifier is given\n    as a canonical URL, not the short prefix used in the document being parsed.\n\ntype ProcInst struct {\n\tTarget string\n\tInst   []byte\n}\n    A ProcInst represents an XML processing instruction of the form <?target\n    inst?>\n\nfunc (p ProcInst) Copy() ProcInst\n    Copy creates a new copy of ProcInst.\n\ntype StartElement struct {\n\tName Name\n\tAttr []Attr\n}\n    A StartElement represents an XML start element.\n\nfunc (e StartElement) Copy() StartElement\n    Copy creates a new copy of StartElement.\n\nfunc (e StartElement) End() EndElement\n    End returns the corresponding XML end element.\n\ntype SyntaxError struct {\n\tMsg  string\n\tLine int\n}\n    A SyntaxError represents a syntax error in the XML input stream.\n\nfunc (e *SyntaxError) Error() string\n\ntype TagPathError struct {\n\tStruct       reflect.Type\n\tField1, Tag1 string\n\tField2, Tag2 string\n}\n    A TagPathError represents an error in the unmarshaling process caused by the\n    use of field tags with conflicting paths.\n\nfunc (e *TagPathError) Error() string\n\ntype Token any\n    A Token is an interface holding one of the token types: StartElement,\n    EndElement, CharData, Comment, ProcInst, or Directive.\n\nfunc CopyToken(t Token) Token\n    CopyToken returns a copy of a Token.\n\ntype TokenReader interface {\n\tToken() (Token, error)\n}\n    A TokenReader is anything that can decode a stream of XML tokens, including\n    a Decoder.\n\n    When Token encounters an error or end-of-file condition after successfully\n    reading a token, it returns the token. It may return the (non-nil) error\n    from the same call or return the error (and a nil token) from a subsequent\n    call. An instance of this general case is that a TokenReader returning a\n    non-nil token at the end of the token stream may return either io.EOF or a\n    nil error. The next Read should return nil, io.EOF.\n\n    Implementations of Token are discouraged from returning a nil token with\n    a nil error. Callers should treat a return of nil, nil as indicating that\n    nothing happened; in particular it does not indicate EOF.\n\ntype UnmarshalError string\n    An UnmarshalError represents an error in the unmarshaling process.\n\nfunc (e UnmarshalError) Error() string\n\ntype Unmarshaler interface {\n\tUnmarshalXML(d *Decoder, start StartElement) error\n}\n    Unmarshaler is the interface implemented by objects that can unmarshal an\n    XML element description of themselves.\n\n    UnmarshalXML decodes a single XML element beginning with the given start\n    element. If it returns an error, the outer call to Unmarshal stops and\n    returns that error. UnmarshalXML must consume exactly one XML element.\n    One common implementation strategy is to unmarshal into a separate value\n    with a layout matching the expected XML using d.DecodeElement, and then to\n    copy the data from that value into the receiver. Another common strategy is\n    to use d.Token to process the XML object one token at a time. UnmarshalXML\n    may not use d.RawToken.\n\ntype UnmarshalerAttr interface {\n\tUnmarshalXMLAttr(attr Attr) error\n}\n    UnmarshalerAttr is the interface implemented by objects that can unmarshal\n    an XML attribute description of themselves.\n\n    UnmarshalXMLAttr decodes a single XML attribute. If it returns an error,\n    the outer call to Unmarshal stops and returns that error. UnmarshalXMLAttr\n    is used only for struct fields with the \"attr\" option in the field tag.\n\ntype UnsupportedTypeError struct {\n\tType reflect.Type\n}\n    UnsupportedTypeError is returned when Marshal encounters a type that cannot\n    be converted into XML.\n\nfunc (e *UnsupportedTypeError) Error() string\n\n\nBUG: Mapping between XML elements and data structures is inherently flawed:\nan XML element is an order-dependent collection of anonymous\nvalues, while a data structure is an order-independent collection\nof named values.\nSee [encoding/json] for a textual representation more suitable\nto data structures.\n\n"}, {"path": "stdlib/os-signal.md", "category": "stdlib", "name": "stdlib/os-signal", "content": "package signal // import \"os/signal\"\n\nPackage signal implements access to incoming signals.\n\nSignals are primarily used on Unix-like systems. For the use of this package on\nWindows and Plan 9, see below.\n\n# Types of signals\n\nThe signals SIGKILL and SIGSTOP may not be caught by a program, and therefore\ncannot be affected by this package.\n\nSynchronous signals are signals triggered by errors in program execution:\nSIGBUS, SIGFPE, and SIGSEGV. These are only considered synchronous when caused\nby program execution, not when sent using os.Process.Kill or the kill program or\nsome similar mechanism. In general, except as discussed below, Go programs will\nconvert a synchronous signal into a run-time panic.\n\nThe remaining signals are asynchronous signals. They are not triggered by\nprogram errors, but are instead sent from the kernel or from some other program.\n\nOf the asynchronous signals, the SIGHUP signal is sent when a program loses its\ncontrolling terminal. The SIGINT signal is sent when the user at the controlling\nterminal presses the interrupt character, which by default is ^C (Control-C).\nThe SIGQUIT signal is sent when the user at the controlling terminal presses the\nquit character, which by default is ^\\ (Control-Backslash). In general you can\ncause a program to simply exit by pressing ^C, and you can cause it to exit with\na stack dump by pressing ^\\.\n\n# Default behavior of signals in Go programs\n\nBy default, a synchronous signal is converted into a run-time panic. A SIGHUP,\nSIGINT, or SIGTERM signal causes the program to exit. A SIGQUIT, SIGILL,\nSIGTRAP, SIGABRT, SIGSTKFLT, SIGEMT, or SIGSYS signal causes the program to exit\nwith a stack dump. A SIGTSTP, SIGTTIN, or SIGTTOU signal gets the system default\nbehavior (these signals are used by the shell for job control). The SIGPROF\nsignal is handled directly by the Go runtime to implement runtime.CPUProfile.\nOther signals will be caught but no action will be taken.\n\nIf the Go program is started with either SIGHUP or SIGINT ignored (signal\nhandler set to SIG_IGN), they will remain ignored.\n\nIf the Go program is started with a non-empty signal mask, that will generally\nbe honored. However, some signals are explicitly unblocked: the synchronous\nsignals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD, SIGPROF, and, on Linux, signals\n32 (SIGCANCEL) and 33 (SIGSETXID) (SIGCANCEL and SIGSETXID are used internally\nby glibc). Subprocesses started by os.Exec, or by os/exec, will inherit the\nmodified signal mask.\n\n# Changing the behavior of signals in Go programs\n\nThe functions in this package allow a program to change the way Go programs\nhandle signals.\n\nNotify disables the default behavior for a given set of asynchronous signals\nand instead delivers them over one or more registered channels. Specifically,\nit applies to the signals SIGHUP, SIGINT, SIGQUIT, SIGABRT, and SIGTERM. It also\napplies to the job control signals SIGTSTP, SIGTTIN, and SIGTTOU, in which case\nthe system default behavior does not occur. It also applies to some signals that\notherwise cause no action: SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGCHLD, SIGCONT,\nSIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH, SIGIO, SIGPWR, SIGINFO, SIGTHR,\nSIGWAITING, SIGLWP, SIGFREEZE, SIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2,\nand any real time signals used on the system. Note that not all of these signals\nare available on all systems.\n\nIf the program was started with SIGHUP or SIGINT ignored, and Notify is called\nfor either signal, a signal handler will be installed for that signal and it\nwill no longer be ignored. If, later, Reset or Ignore is called for that signal,\nor Stop is called on all channels passed to Notify for that signal, the signal\nwill once again be ignored. Reset will restore the system default behavior for\nthe signal, while Ignore will cause the system to ignore the signal entirely.\n\nIf the program is started with a non-empty signal mask, some signals will be\nexplicitly unblocked as described above. If Notify is called for a blocked\nsignal, it will be unblocked. If, later, Reset is called for that signal,\nor Stop is called on all channels passed to Notify for that signal, the signal\nwill once again be blocked.\n\n# SIGPIPE\n\nWhen a Go program writes to a broken pipe, the kernel will raise a SIGPIPE\nsignal.\n\nIf the program has not called Notify to receive SIGPIPE signals, then the\nbehavior depends on the file descriptor number. A write to a broken pipe on file\ndescriptors 1 or 2 (standard output or standard error) will cause the program\nto exit with a SIGPIPE signal. A write to a broken pipe on some other file\ndescriptor will take no action on the SIGPIPE signal, and the write will fail\nwith a syscall.EPIPE error.\n\nIf the program has called Notify to receive SIGPIPE signals, the file descriptor\nnumber does not matter. The SIGPIPE signal will be delivered to the Notify\nchannel, and the write will fail with a syscall.EPIPE error.\n\nThis means that, by default, command line programs will behave like typical Unix\ncommand line programs, while other programs will not crash with SIGPIPE when\nwriting to a closed network connection.\n\n# Go programs that use cgo or SWIG\n\nIn a Go program that includes non-Go code, typically C/C++ code accessed using\ncgo or SWIG, Go's startup code normally runs first. It configures the signal\nhandlers as expected by the Go runtime, before the non-Go startup code runs.\nIf the non-Go startup code wishes to install its own signal handlers, it must\ntake certain steps to keep Go working well. This section documents those steps\nand the overall effect changes to signal handler settings by the non-Go code can\nhave on Go programs. In rare cases, the non-Go code may run before the Go code,\nin which case the next section also applies.\n\nIf the non-Go code called by the Go program does not change any signal handlers\nor masks, then the behavior is the same as for a pure Go program.\n\nIf the non-Go code installs any signal handlers, it must use the SA_ONSTACK\nflag with sigaction. Failing to do so is likely to cause the program to crash\nif the signal is received. Go programs routinely run with a limited stack,\nand therefore set up an alternate signal stack.\n\nIf the non-Go code installs a signal handler for any of the synchronous signals\n(SIGBUS, SIGFPE, SIGSEGV), then it should record the existing Go signal handler.\nIf those signals occur while executing Go code, it should invoke the Go signal\nhandler (whether the signal occurs while executing Go code can be determined\nby looking at the PC passed to the signal handler). Otherwise some Go run-time\npanics will not occur as expected.\n\nIf the non-Go code installs a signal handler for any of the asynchronous\nsignals, it may invoke the Go signal handler or not as it chooses. Naturally,\nif it does not invoke the Go signal handler, the Go behavior described above\nwill not occur. This can be an issue with the SIGPROF signal in particular.\n\nThe non-Go code should not change the signal mask on any threads created by the\nGo runtime. If the non-Go code starts new threads itself, those threads may set\nthe signal mask as they please.\n\nIf the non-Go code starts a new thread, changes the signal mask, and then\ninvokes a Go function in that thread, the Go runtime will automatically unblock\ncertain signals: the synchronous signals, SIGILL, SIGTRAP, SIGSTKFLT, SIGCHLD,\nSIGPROF, SIGCANCEL, and SIGSETXID. When the Go function returns, the non-Go\nsignal mask will be restored.\n\nIf the Go signal handler is invoked on a non-Go thread not running Go code,\nthe handler generally forwards the signal to the non-Go code, as follows.\nIf the signal is SIGPROF, the Go handler does nothing. Otherwise, the Go handler\nremoves itself, unblocks the signal, and raises it again, to invoke any non-Go\nhandler or default system handler. If the program does not exit, the Go handler\nthen reinstalls itself and continues execution of the program.\n\nIf a SIGPIPE signal is received, the Go program will invoke the special handling\ndescribed above if the SIGPIPE is received on a Go thread. If the SIGPIPE is\nreceived on a non-Go thread the signal will be forwarded to the non-Go handler,\nif any; if there is none the default system handler will cause the program to\nterminate.\n\n# Non-Go programs that call Go code\n\nWhen Go code is built with options like -buildmode=c-shared, it will be run as\npart of an existing non-Go program. The non-Go code may have already installed\nsignal handlers when the Go code starts (that may also happen in unusual\ncases when using cgo or SWIG; in that case, the discussion here applies).\nFor -buildmode=c-archive the Go runtime will initialize signals at global\nconstructor time. For -buildmode=c-shared the Go runtime will initialize signals\nwhen the shared library is loaded.\n\nIf the Go runtime sees an existing signal handler for the SIGCANCEL or SIGSETXID\nsignals (which are used only on Linux), it will turn on the SA_ONSTACK flag and\notherwise keep the signal handler.\n\nFor the synchronous signals and SIGPIPE, the Go runtime will install a signal\nhandler. It will save any existing signal handler. If a synchronous signal\narrives while executing non-Go code, the Go runtime will invoke the existing\nsignal handler instead of the Go signal handler.\n\nGo code built with -buildmode=c-archive or -buildmode=c-shared will not install\nany other signal handlers by default. If there is an existing signal handler,\nthe Go runtime will turn on the SA_ONSTACK flag and otherwise keep the signal\nhandler. If Notify is called for an asynchronous signal, a Go signal handler\nwill be installed for that signal. If, later, Reset is called for that signal,\nthe original handling for that signal will be reinstalled, restoring the non-Go\nsignal handler if any.\n\nGo code built without -buildmode=c-archive or -buildmode=c-shared will install a\nsignal handler for the asynchronous signals listed above, and save any existing\nsignal handler. If a signal is delivered to a non-Go thread, it will act as\ndescribed above, except that if there is an existing non-Go signal handler,\nthat handler will be installed before raising the signal.\n\n# Windows\n\nOn Windows a ^C (Control-C) or ^BREAK (Control-Break) normally cause the\nprogram to exit. If Notify is called for os.Interrupt, ^C or ^BREAK will cause\nos.Interrupt to be sent on the channel, and the program will not exit. If Reset\nis called, or Stop is called on all channels passed to Notify, then the default\nbehavior will be restored.\n\nAdditionally, if Notify is called, and Windows sends CTRL_CLOSE_EVENT,\nCTRL_LOGOFF_EVENT or CTRL_SHUTDOWN_EVENT to the process, Notify will return\nsyscall.SIGTERM. Unlike Control-C and Control-Break, Notify does not\nchange process behavior when either CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT or\nCTRL_SHUTDOWN_EVENT is received - the process will still get terminated unless\nit exits. But receiving syscall.SIGTERM will give the process an opportunity to\nclean up before termination.\n\n# Plan 9\n\nOn Plan 9, signals have type syscall.Note, which is a string. Calling Notify\nwith a syscall.Note will cause that value to be sent on the channel when that\nstring is posted as a note.\n\nFUNCTIONS\n\nfunc Ignore(sig ...os.Signal)\n    Ignore causes the provided signals to be ignored. If they are received by\n    the program, nothing will happen. Ignore undoes the effect of any prior\n    calls to Notify for the provided signals. If no signals are provided,\n    all incoming signals will be ignored.\n\nfunc Ignored(sig os.Signal) bool\n    Ignored reports whether sig is currently ignored.\n\nfunc Notify(c chan<- os.Signal, sig ...os.Signal)\n    Notify causes package signal to relay incoming signals to c. If no signals\n    are provided, all incoming signals will be relayed to c. Otherwise, just the\n    provided signals will.\n\n    Package signal will not block sending to c: the caller must ensure that\n    c has sufficient buffer space to keep up with the expected signal rate.\n    For a channel used for notification of just one signal value, a buffer of\n    size 1 is sufficient.\n\n    It is allowed to call Notify multiple times with the same channel: each call\n    expands the set of signals sent to that channel. The only way to remove\n    signals from the set is to call Stop.\n\n    It is allowed to call Notify multiple times with different channels\n    and the same signals: each channel receives copies of incoming signals\n    independently.\n\nfunc NotifyContext(parent context.Context, signals ...os.Signal) (ctx context.Context, stop context.CancelFunc)\n    NotifyContext returns a copy of the parent context that is marked done (its\n    Done channel is closed) when one of the listed signals arrives, when the\n    returned stop function is called, or when the parent context's Done channel\n    is closed, whichever happens first.\n\n    The stop function unregisters the signal behavior, which, like signal.Reset,\n    may restore the default behavior for a given signal. For example,\n    the default behavior of a Go program receiving os.Interrupt is to exit.\n    Calling NotifyContext(parent, os.Interrupt) will change the behavior to\n    cancel the returned context. Future interrupts received will not trigger the\n    default (exit) behavior until the returned stop function is called.\n\n    The stop function releases resources associated with it, so code should call\n    stop as soon as the operations running in this Context complete and signals\n    no longer need to be diverted to the context.\n\nfunc Reset(sig ...os.Signal)\n    Reset undoes the effect of any prior calls to Notify for the provided\n    signals. If no signals are provided, all signal handlers will be reset.\n\nfunc Stop(c chan<- os.Signal)\n    Stop causes package signal to stop relaying incoming signals to c. It\n    undoes the effect of all prior calls to Notify using c. When Stop returns,\n    it is guaranteed that c will receive no more signals.\n\n"}, {"path": "stdlib/os-exec.md", "category": "stdlib", "name": "stdlib/os-exec", "content": "package exec // import \"os/exec\"\n\nPackage exec runs external commands. It wraps os.StartProcess to make it easier\nto remap stdin and stdout, connect I/O with pipes, and do other adjustments.\n\nUnlike the \"system\" library call from C and other languages, the os/exec\npackage intentionally does not invoke the system shell and does not expand any\nglob patterns or handle other expansions, pipelines, or redirections typically\ndone by shells. The package behaves more like C's \"exec\" family of functions.\nTo expand glob patterns, either call the shell directly, taking care to escape\nany dangerous input, or use the path/filepath package's Glob function. To expand\nenvironment variables, use package os's ExpandEnv.\n\nNote that the examples in this package assume a Unix system. They may not run on\nWindows, and they do not run in the Go Playground used by go.dev and pkg.go.dev.\n\n# Executables in the current directory\n\nThe functions Command and LookPath look for a program in the directories listed\nin the current path, following the conventions of the host operating system.\nOperating systems have for decades included the current directory in this\nsearch, sometimes implicitly and sometimes configured explicitly that way by\ndefault. Modern practice is that including the current directory is usually\nunexpected and often leads to security problems.\n\nTo avoid those security problems, as of Go 1.19, this package will not resolve\na program using an implicit or explicit path entry relative to the current\ndirectory. That is, if you run LookPath(\"go\"), it will not successfully return\n./go on Unix nor .\\go.exe on Windows, no matter how the path is configured.\nInstead, if the usual path algorithms would result in that answer, these\nfunctions return an error err satisfying errors.Is(err, ErrDot).\n\nFor example, consider these two program snippets:\n\n    path, err := exec.LookPath(\"prog\")\n    if err != nil {\n    \tlog.Fatal(err)\n    }\n    use(path)\n\nand\n\n    cmd := exec.Command(\"prog\")\n    if err := cmd.Run(); err != nil {\n    \tlog.Fatal(err)\n    }\n\nThese will not find and run ./prog or .\\prog.exe, no matter how the current path\nis configured.\n\nCode that always wants to run a program from the current directory can be\nrewritten to say \"./prog\" instead of \"prog\".\n\nCode that insists on including results from relative path entries can instead\noverride the error using an errors.Is check:\n\n    path, err := exec.LookPath(\"prog\")\n    if errors.Is(err, exec.ErrDot) {\n    \terr = nil\n    }\n    if err != nil {\n    \tlog.Fatal(err)\n    }\n    use(path)\n\nand\n\n    cmd := exec.Command(\"prog\")\n    if errors.Is(cmd.Err, exec.ErrDot) {\n    \tcmd.Err = nil\n    }\n    if err := cmd.Run(); err != nil {\n    \tlog.Fatal(err)\n    }\n\nSetting the environment variable GODEBUG=execerrdot=0 disables generation of\nErrDot entirely, temporarily restoring the pre-Go 1.19 behavior for programs\nthat are unable to apply more targeted fixes. A future version of Go may remove\nsupport for this variable.\n\nBefore adding such overrides, make sure you understand the security implications\nof doing so. See https://go.dev/blog/path-security for more information.\n\nVARIABLES\n\nvar ErrDot = errors.New(\"cannot run executable found relative to current directory\")\n    ErrDot indicates that a path lookup resolved to an executable in the current\n    directory due to \u2018.\u2019 being in the path, either implicitly or explicitly.\n    See the package documentation for details.\n\n    Note that functions in this package do not return ErrDot directly.\n    Code should use errors.Is(err, ErrDot), not err == ErrDot, to test whether a\n    returned error err is due to this condition.\n\nvar ErrNotFound = errors.New(\"executable file not found in $PATH\")\n    ErrNotFound is the error resulting if a path search failed to find an\n    executable file.\n\nvar ErrWaitDelay = errors.New(\"exec: WaitDelay expired before I/O complete\")\n    ErrWaitDelay is returned by Cmd.Wait if the process exits with a successful\n    status code but its output pipes are not closed before the command's\n    WaitDelay expires.\n\n\nFUNCTIONS\n\nfunc LookPath(file string) (string, error)\n    LookPath searches for an executable named file in the directories named\n    by the PATH environment variable. If file contains a slash, it is tried\n    directly and the PATH is not consulted. Otherwise, on success, the result is\n    an absolute path.\n\n    In older versions of Go, LookPath could return a path relative to the\n    current directory. As of Go 1.19, LookPath will instead return that path\n    along with an error satisfying errors.Is(err, ErrDot). See the package\n    documentation for more details.\n\n\nTYPES\n\ntype Cmd struct {\n\t// Path is the path of the command to run.\n\t//\n\t// This is the only field that must be set to a non-zero\n\t// value. If Path is relative, it is evaluated relative\n\t// to Dir.\n\tPath string\n\n\t// Args holds command line arguments, including the command as Args[0].\n\t// If the Args field is empty or nil, Run uses {Path}.\n\t//\n\t// In typical use, both Path and Args are set by calling Command.\n\tArgs []string\n\n\t// Env specifies the environment of the process.\n\t// Each entry is of the form \"key=value\".\n\t// If Env is nil, the new process uses the current process's\n\t// environment.\n\t// If Env contains duplicate environment keys, only the last\n\t// value in the slice for each duplicate key is used.\n\t// As a special case on Windows, SYSTEMROOT is always added if\n\t// missing and not explicitly set to the empty string.\n\t//\n\t// See also the Dir field, which may set PWD in the environment.\n\tEnv []string\n\n\t// Dir specifies the working directory of the command.\n\t// If Dir is the empty string, Run runs the command in the\n\t// calling process's current directory.\n\t//\n\t// On Unix systems, the value of Dir also determines the\n\t// child process's PWD environment variable if not otherwise\n\t// specified. A Unix process represents its working directory\n\t// not by name but as an implicit reference to a node in the\n\t// file tree. So, if the child process obtains its working\n\t// directory by calling a function such as C's getcwd, which\n\t// computes the canonical name by walking up the file tree, it\n\t// will not recover the original value of Dir if that value\n\t// was an alias involving symbolic links. However, if the\n\t// child process calls Go's [os.Getwd] or GNU C's\n\t// get_current_dir_name, and the value of PWD is an alias for\n\t// the current directory, those functions will return the\n\t// value of PWD, which matches the value of Dir.\n\tDir string\n\n\t// Stdin specifies the process's standard input.\n\t//\n\t// If Stdin is nil, the process reads from the null device (os.DevNull).\n\t//\n\t// If Stdin is an *os.File, the process's standard input is connected\n\t// directly to that file.\n\t//\n\t// Otherwise, during the execution of the command a separate\n\t// goroutine reads from Stdin and delivers that data to the command\n\t// over a pipe. In this case, Wait does not complete until the goroutine\n\t// stops copying, either because it has reached the end of Stdin\n\t// (EOF or a read error), or because writing to the pipe returned an error,\n\t// or because a nonzero WaitDelay was set and expired.\n\tStdin io.Reader\n\n\t// Stdout and Stderr specify the process's standard output and error.\n\t//\n\t// If either is nil, Run connects the corresponding file descriptor\n\t// to the null device (os.DevNull).\n\t//\n\t// If either is an *os.File, the corresponding output from the process\n\t// is connected directly to that file.\n\t//\n\t// Otherwise, during the execution of the command a separate goroutine\n\t// reads from the process over a pipe and delivers that data to the\n\t// corresponding Writer. In this case, Wait does not complete until the\n\t// goroutine reaches EOF or encounters an error or a nonzero WaitDelay\n\t// expires.\n\t//\n\t// If Stdout and Stderr are the same writer, and have a type that can\n\t// be compared with ==, at most one goroutine at a time will call Write.\n\tStdout io.Writer\n\tStderr io.Writer\n\n\t// ExtraFiles specifies additional open files to be inherited by the\n\t// new process. It does not include standard input, standard output, or\n\t// standard error. If non-nil, entry i becomes file descriptor 3+i.\n\t//\n\t// ExtraFiles is not supported on Windows.\n\tExtraFiles []*os.File\n\n\t// SysProcAttr holds optional, operating system-specific attributes.\n\t// Run passes it to os.StartProcess as the os.ProcAttr's Sys field.\n\tSysProcAttr *syscall.SysProcAttr\n\n\t// Process is the underlying process, once started.\n\tProcess *os.Process\n\n\t// ProcessState contains information about an exited process.\n\t// If the process was started successfully, Wait or Run will\n\t// populate its ProcessState when the command completes.\n\tProcessState *os.ProcessState\n\n\tErr error // LookPath error, if any.\n\n\t// If Cancel is non-nil, the command must have been created with\n\t// CommandContext and Cancel will be called when the command's\n\t// Context is done. By default, CommandContext sets Cancel to\n\t// call the Kill method on the command's Process.\n\t//\n\t// Typically a custom Cancel will send a signal to the command's\n\t// Process, but it may instead take other actions to initiate cancellation,\n\t// such as closing a stdin or stdout pipe or sending a shutdown request on a\n\t// network socket.\n\t//\n\t// If the command exits with a success status after Cancel is\n\t// called, and Cancel does not return an error equivalent to\n\t// os.ErrProcessDone, then Wait and similar methods will return a non-nil\n\t// error: either an error wrapping the one returned by Cancel,\n\t// or the error from the Context.\n\t// (If the command exits with a non-success status, or Cancel\n\t// returns an error that wraps os.ErrProcessDone, Wait and similar methods\n\t// continue to return the command's usual exit status.)\n\t//\n\t// If Cancel is set to nil, nothing will happen immediately when the command's\n\t// Context is done, but a nonzero WaitDelay will still take effect. That may\n\t// be useful, for example, to work around deadlocks in commands that do not\n\t// support shutdown signals but are expected to always finish quickly.\n\t//\n\t// Cancel will not be called if Start returns a non-nil error.\n\tCancel func() error\n\n\t// If WaitDelay is non-zero, it bounds the time spent waiting on two sources\n\t// of unexpected delay in Wait: a child process that fails to exit after the\n\t// associated Context is canceled, and a child process that exits but leaves\n\t// its I/O pipes unclosed.\n\t//\n\t// The WaitDelay timer starts when either the associated Context is done or a\n\t// call to Wait observes that the child process has exited, whichever occurs\n\t// first. When the delay has elapsed, the command shuts down the child process\n\t// and/or its I/O pipes.\n\t//\n\t// If the child process has failed to exit \u2014 perhaps because it ignored or\n\t// failed to receive a shutdown signal from a Cancel function, or because no\n\t// Cancel function was set \u2014 then it will be terminated using os.Process.Kill.\n\t//\n\t// Then, if the I/O pipes communicating with the child process are still open,\n\t// those pipes are closed in order to unblock any goroutines currently blocked\n\t// on Read or Write calls.\n\t//\n\t// If pipes are closed due to WaitDelay, no Cancel call has occurred,\n\t// and the command has otherwise exited with a successful status, Wait and\n\t// similar methods will return ErrWaitDelay instead of nil.\n\t//\n\t// If WaitDelay is zero (the default), I/O pipes will be read until EOF,\n\t// which might not occur until orphaned subprocesses of the command have\n\t// also closed their descriptors for the pipes.\n\tWaitDelay time.Duration\n\n\t// Has unexported fields.\n}\n    Cmd represents an external command being prepared or run.\n\n    A Cmd cannot be reused after calling its Cmd.Run, Cmd.Output or\n    Cmd.CombinedOutput methods.\n\nfunc Command(name string, arg ...string) *Cmd\n    Command returns the Cmd struct to execute the named program with the given\n    arguments.\n\n    It sets only the Path and Args in the returned structure.\n\n    If name contains no path separators, Command uses LookPath to resolve name\n    to a complete path if possible. Otherwise it uses name directly as Path.\n\n    The returned Cmd's Args field is constructed from the command name followed\n    by the elements of arg, so arg should not include the command name itself.\n    For example, Command(\"echo\", \"hello\"). Args[0] is always name, not the\n    possibly resolved Path.\n\n    On Windows, processes receive the whole command line as a single string\n    and do their own parsing. Command combines and quotes Args into a\n    command line string with an algorithm compatible with applications using\n    CommandLineToArgvW (which is the most common way). Notable exceptions are\n    msiexec.exe and cmd.exe (and thus, all batch files), which have a different\n    unquoting algorithm. In these or other similar cases, you can do the quoting\n    yourself and provide the full command line in SysProcAttr.CmdLine, leaving\n    Args empty.\n\nfunc CommandContext(ctx context.Context, name string, arg ...string) *Cmd\n    CommandContext is like Command but includes a context.\n\n    The provided context is used to interrupt the process (by calling cmd.Cancel\n    or os.Process.Kill) if the context becomes done before the command completes\n    on its own.\n\n    CommandContext sets the command's Cancel function to invoke the Kill method\n    on its Process, and leaves its WaitDelay unset. The caller may change the\n    cancellation behavior by modifying those fields before starting the command.\n\nfunc (c *Cmd) CombinedOutput() ([]byte, error)\n    CombinedOutput runs the command and returns its combined standard output and\n    standard error.\n\nfunc (c *Cmd) Environ() []string\n    Environ returns a copy of the environment in which the command would be run\n    as it is currently configured.\n\nfunc (c *Cmd) Output() ([]byte, error)\n    Output runs the command and returns its standard output. Any returned error\n    will usually be of type *ExitError. If c.Stderr was nil and the returned\n    error is of type *ExitError, Output populates the Stderr field of the\n    returned error.\n\nfunc (c *Cmd) Run() error\n    Run starts the specified command and waits for it to complete.\n\n    The returned error is nil if the command runs, has no problems copying\n    stdin, stdout, and stderr, and exits with a zero exit status.\n\n    If the command starts but does not complete successfully, the error is of\n    type *ExitError. Other error types may be returned for other situations.\n\n    If the calling goroutine has locked the operating system thread with\n    runtime.LockOSThread and modified any inheritable OS-level thread state\n    (for example, Linux or Plan 9 name spaces), the new process will inherit the\n    caller's thread state.\n\nfunc (c *Cmd) Start() error\n    Start starts the specified command but does not wait for it to complete.\n\n    If Start returns successfully, the c.Process field will be set.\n\n    After a successful call to Start the Cmd.Wait method must be called in order\n    to release associated system resources.\n\nfunc (c *Cmd) StderrPipe() (io.ReadCloser, error)\n    StderrPipe returns a pipe that will be connected to the command's standard\n    error when the command starts.\n\n    Cmd.Wait will close the pipe after seeing the command exit, so most callers\n    need not close the pipe themselves. It is thus incorrect to call Wait\n    before all reads from the pipe have completed. For the same reason, it is\n    incorrect to use Cmd.Run when using StderrPipe. See the StdoutPipe example\n    for idiomatic usage.\n\nfunc (c *Cmd) StdinPipe() (io.WriteCloser, error)\n    StdinPipe returns a pipe that will be connected to the command's standard\n    input when the command starts. The pipe will be closed automatically after\n    Cmd.Wait sees the command exit. A caller need only call Close to force the\n    pipe to close sooner. For example, if the command being run will not exit\n    until standard input is closed, the caller must close the pipe.\n\nfunc (c *Cmd) StdoutPipe() (io.ReadCloser, error)\n    StdoutPipe returns a pipe that will be connected to the command's standard\n    output when the command starts.\n\n    Cmd.Wait will close the pipe after seeing the command exit, so most callers\n    need not close the pipe themselves. It is thus incorrect to call Wait before\n    all reads from the pipe have completed. For the same reason, it is incorrect\n    to call Cmd.Run when using StdoutPipe. See the example for idiomatic usage.\n\nfunc (c *Cmd) String() string\n    String returns a human-readable description of c. It is intended only for\n    debugging. In particular, it is not suitable for use as input to a shell.\n    The output of String may vary across Go releases.\n\nfunc (c *Cmd) Wait() error\n    Wait waits for the command to exit and waits for any copying to stdin or\n    copying from stdout or stderr to complete.\n\n    The command must have been started by Cmd.Start.\n\n    The returned error is nil if the command runs, has no problems copying\n    stdin, stdout, and stderr, and exits with a zero exit status.\n\n    If the command fails to run or doesn't complete successfully, the error is\n    of type *ExitError. Other error types may be returned for I/O problems.\n\n    If any of c.Stdin, c.Stdout or c.Stderr are not an *os.File, Wait also waits\n    for the respective I/O loop copying to or from the process to complete.\n\n    Wait releases any resources associated with the Cmd.\n\ntype Error struct {\n\t// Name is the file name for which the error occurred.\n\tName string\n\t// Err is the underlying error.\n\tErr error\n}\n    Error is returned by LookPath when it fails to classify a file as an\n    executable.\n\nfunc (e *Error) Error() string\n\nfunc (e *Error) Unwrap() error\n\ntype ExitError struct {\n\t*os.ProcessState\n\n\t// Stderr holds a subset of the standard error output from the\n\t// Cmd.Output method if standard error was not otherwise being\n\t// collected.\n\t//\n\t// If the error output is long, Stderr may contain only a prefix\n\t// and suffix of the output, with the middle replaced with\n\t// text about the number of omitted bytes.\n\t//\n\t// Stderr is provided for debugging, for inclusion in error messages.\n\t// Users with other needs should redirect Cmd.Stderr as needed.\n\tStderr []byte\n}\n    An ExitError reports an unsuccessful exit by a command.\n\nfunc (e *ExitError) Error() string\n\n"}, {"path": "stdlib/math-cmplx.md", "category": "stdlib", "name": "stdlib/math-cmplx", "content": "package cmplx // import \"math/cmplx\"\n\nPackage cmplx provides basic constants and mathematical functions for complex\nnumbers. Special case handling conforms to the C99 standard Annex G IEC\n60559-compatible complex arithmetic.\n\nFUNCTIONS\n\nfunc Abs(x complex128) float64\n    Abs returns the absolute value (also called the modulus) of x.\n\nfunc Acos(x complex128) complex128\n    Acos returns the inverse cosine of x.\n\nfunc Acosh(x complex128) complex128\n    Acosh returns the inverse hyperbolic cosine of x.\n\nfunc Asin(x complex128) complex128\n    Asin returns the inverse sine of x.\n\nfunc Asinh(x complex128) complex128\n    Asinh returns the inverse hyperbolic sine of x.\n\nfunc Atan(x complex128) complex128\n    Atan returns the inverse tangent of x.\n\nfunc Atanh(x complex128) complex128\n    Atanh returns the inverse hyperbolic tangent of x.\n\nfunc Conj(x complex128) complex128\n    Conj returns the complex conjugate of x.\n\nfunc Cos(x complex128) complex128\n    Cos returns the cosine of x.\n\nfunc Cosh(x complex128) complex128\n    Cosh returns the hyperbolic cosine of x.\n\nfunc Cot(x complex128) complex128\n    Cot returns the cotangent of x.\n\nfunc Exp(x complex128) complex128\n    Exp returns e**x, the base-e exponential of x.\n\nfunc Inf() complex128\n    Inf returns a complex infinity, complex(+Inf, +Inf).\n\nfunc IsInf(x complex128) bool\n    IsInf reports whether either real(x) or imag(x) is an infinity.\n\nfunc IsNaN(x complex128) bool\n    IsNaN reports whether either real(x) or imag(x) is NaN and neither is an\n    infinity.\n\nfunc Log(x complex128) complex128\n    Log returns the natural logarithm of x.\n\nfunc Log10(x complex128) complex128\n    Log10 returns the decimal logarithm of x.\n\nfunc NaN() complex128\n    NaN returns a complex \u201cnot-a-number\u201d value.\n\nfunc Phase(x complex128) float64\n    Phase returns the phase (also called the argument) of x. The returned value\n    is in the range [-Pi, Pi].\n\nfunc Polar(x complex128) (r, \u03b8 float64)\n    Polar returns the absolute value r and phase \u03b8 of x, such that x = r *\n    e**\u03b8i. The phase is in the range [-Pi, Pi].\n\nfunc Pow(x, y complex128) complex128\n    Pow returns x**y, the base-x exponential of y. For generalized compatibility\n    with math.Pow:\n\n        Pow(0, \u00b10) returns 1+0i\n        Pow(0, c) for real(c)<0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i.\n\nfunc Rect(r, \u03b8 float64) complex128\n    Rect returns the complex number x with polar coordinates r, \u03b8.\n\nfunc Sin(x complex128) complex128\n    Sin returns the sine of x.\n\nfunc Sinh(x complex128) complex128\n    Sinh returns the hyperbolic sine of x.\n\nfunc Sqrt(x complex128) complex128\n    Sqrt returns the square root of x. The result r is chosen so that real(r) \u2265\n    0 and imag(r) has the same sign as imag(x).\n\nfunc Tan(x complex128) complex128\n    Tan returns the tangent of x.\n\nfunc Tanh(x complex128) complex128\n    Tanh returns the hyperbolic tangent of x.\n\n"}, {"path": "stdlib/encoding-gob.md", "category": "stdlib", "name": "stdlib/encoding-gob", "content": "package gob // import \"encoding/gob\"\n\nPackage gob manages streams of gobs - binary values exchanged between an Encoder\n(transmitter) and a Decoder (receiver). A typical use is transporting arguments\nand results of remote procedure calls (RPCs) such as those provided by net/rpc.\n\nThe implementation compiles a custom codec for each data type in the stream and\nis most efficient when a single Encoder is used to transmit a stream of values,\namortizing the cost of compilation.\n\n# Basics\n\nA stream of gobs is self-describing. Each data item in the stream is preceded\nby a specification of its type, expressed in terms of a small set of predefined\ntypes. Pointers are not transmitted, but the things they point to are\ntransmitted; that is, the values are flattened. Nil pointers are not permitted,\nas they have no value. Recursive types work fine, but recursive values (data\nwith cycles) are problematic. This may change.\n\nTo use gobs, create an Encoder and present it with a series of data items as\nvalues or addresses that can be dereferenced to values. The Encoder makes sure\nall type information is sent before it is needed. At the receive side, a Decoder\nretrieves values from the encoded stream and unpacks them into local variables.\n\n# Types and Values\n\nThe source and destination values/types need not correspond exactly.\nFor structs, fields (identified by name) that are in the source but absent\nfrom the receiving variable will be ignored. Fields that are in the receiving\nvariable but missing from the transmitted type or value will be ignored in the\ndestination. If a field with the same name is present in both, their types\nmust be compatible. Both the receiver and transmitter will do all necessary\nindirection and dereferencing to convert between gobs and actual Go values.\nFor instance, a gob type that is schematically,\n\n    struct { A, B int }\n\ncan be sent from or received into any of these Go types:\n\n    struct { A, B int }\t// the same\n    *struct { A, B int }\t// extra indirection of the struct\n    struct { *A, **B int }\t// extra indirection of the fields\n    struct { A, B int64 }\t// different concrete value type; see below\n\nIt may also be received into any of these:\n\n    struct { A, B int }\t// the same\n    struct { B, A int }\t// ordering doesn't matter; matching is by name\n    struct { A, B, C int }\t// extra field (C) ignored\n    struct { B int }\t// missing field (A) ignored; data will be dropped\n    struct { B, C int }\t// missing field (A) ignored; extra field (C) ignored.\n\nAttempting to receive into these types will draw a decode error:\n\n    struct { A int; B uint }\t// change of signedness for B\n    struct { A int; B float }\t// change of type for B\n    struct { }\t\t\t// no field names in common\n    struct { C, D int }\t\t// no field names in common\n\nIntegers are transmitted two ways: arbitrary precision signed integers\nor arbitrary precision unsigned integers. There is no int8, int16 etc.\ndiscrimination in the gob format; there are only signed and unsigned integers.\nAs described below, the transmitter sends the value in a variable-length\nencoding; the receiver accepts the value and stores it in the destination\nvariable. Floating-point numbers are always sent using IEEE 754 64-bit precision\n(see below).\n\nSigned integers may be received into any signed integer variable: int, int16,\netc.; unsigned integers may be received into any unsigned integer variable;\nand floating point values may be received into any floating point variable.\nHowever, the destination variable must be able to represent the value or the\ndecode operation will fail.\n\nStructs, arrays and slices are also supported. Structs encode and decode only\nexported fields. Strings and arrays of bytes are supported with a special,\nefficient representation (see below). When a slice is decoded, if the existing\nslice has capacity the slice will be extended in place; if not, a new array is\nallocated. Regardless, the length of the resulting slice reports the number of\nelements decoded.\n\nIn general, if allocation is required, the decoder will allocate memory. If not,\nit will update the destination variables with values read from the stream.\nIt does not initialize them first, so if the destination is a compound value\nsuch as a map, struct, or slice, the decoded values will be merged elementwise\ninto the existing variables.\n\nFunctions and channels will not be sent in a gob. Attempting to encode such a\nvalue at the top level will fail. A struct field of chan or func type is treated\nexactly like an unexported field and is ignored.\n\nGob can encode a value of any type implementing the GobEncoder or\nencoding.BinaryMarshaler interfaces by calling the corresponding method, in that\norder of preference.\n\nGob can decode a value of any type implementing the GobDecoder or\nencoding.BinaryUnmarshaler interfaces by calling the corresponding method,\nagain in that order of preference.\n\n# Encoding Details\n\nThis section documents the encoding, details that are not important for most\nusers. Details are presented bottom-up.\n\nAn unsigned integer is sent one of two ways. If it is less than 128, it is sent\nas a byte with that value. Otherwise it is sent as a minimal-length big-endian\n(high byte first) byte stream holding the value, preceded by one byte holding\nthe byte count, negated. Thus 0 is transmitted as (00), 7 is transmitted as (07)\nand 256 is transmitted as (FE 01 00).\n\nA boolean is encoded within an unsigned integer: 0 for false, 1 for true.\n\nA signed integer, i, is encoded within an unsigned integer, u. Within u,\nbits 1 upward contain the value; bit 0 says whether they should be complemented\nupon receipt. The encode algorithm looks like this:\n\n    var u uint\n    if i < 0 {\n    \tu = (^uint(i) << 1) | 1 // complement i, bit 0 is 1\n    } else {\n    \tu = (uint(i) << 1) // do not complement i, bit 0 is 0\n    }\n    encodeUnsigned(u)\n\nThe low bit is therefore analogous to a sign bit, but making it the complement\nbit instead guarantees that the largest negative integer is not a special case.\nFor example, -129=^128=(^256>>1) encodes as (FE 01 01).\n\nFloating-point numbers are always sent as a representation of a float64 value.\nThat value is converted to a uint64 using math.Float64bits. The uint64 is then\nbyte-reversed and sent as a regular unsigned integer. The byte-reversal means\nthe exponent and high-precision part of the mantissa go first. Since the low\nbits are often zero, this can save encoding bytes. For instance, 17.0 is encoded\nin only three bytes (FE 31 40).\n\nStrings and slices of bytes are sent as an unsigned count followed by that many\nuninterpreted bytes of the value.\n\nAll other slices and arrays are sent as an unsigned count followed by that many\nelements using the standard gob encoding for their type, recursively.\n\nMaps are sent as an unsigned count followed by that many key, element pairs.\nEmpty but non-nil maps are sent, so if the receiver has not allocated one\nalready, one will always be allocated on receipt unless the transmitted map is\nnil and not at the top level.\n\nIn slices and arrays, as well as maps, all elements, even zero-valued elements,\nare transmitted, even if all the elements are zero.\n\nStructs are sent as a sequence of (field number, field value) pairs. The field\nvalue is sent using the standard gob encoding for its type, recursively.\nIf a field has the zero value for its type (except for arrays; see above),\nit is omitted from the transmission. The field number is defined by the type of\nthe encoded struct: the first field of the encoded type is field 0, the second\nis field 1, etc. When encoding a value, the field numbers are delta encoded for\nefficiency and the fields are always sent in order of increasing field number;\nthe deltas are therefore unsigned. The initialization for the delta encoding\nsets the field number to -1, so an unsigned integer field 0 with value 7 is\ntransmitted as unsigned delta = 1, unsigned value = 7 or (01 07). Finally, after\nall the fields have been sent a terminating mark denotes the end of the struct.\nThat mark is a delta=0 value, which has representation (00).\n\nInterface types are not checked for compatibility; all interface types are\ntreated, for transmission, as members of a single \"interface\" type, analogous\nto int or []byte - in effect they're all treated as interface{}. Interface\nvalues are transmitted as a string identifying the concrete type being sent (a\nname that must be pre-defined by calling Register), followed by a byte count of\nthe length of the following data (so the value can be skipped if it cannot be\nstored), followed by the usual encoding of concrete (dynamic) value stored in\nthe interface value. (A nil interface value is identified by the empty string\nand transmits no value.) Upon receipt, the decoder verifies that the unpacked\nconcrete item satisfies the interface of the receiving variable.\n\nIf a value is passed to Encoder.Encode and the type is not a struct (or pointer\nto struct, etc.), for simplicity of processing it is represented as a struct of\none field. The only visible effect of this is to encode a zero byte after the\nvalue, just as after the last field of an encoded struct, so that the decode\nalgorithm knows when the top-level value is complete.\n\nThe representation of types is described below. When a type is defined on a\ngiven connection between an Encoder and Decoder, it is assigned a signed integer\ntype id. When Encoder.Encode(v) is called, it makes sure there is an id assigned\nfor the type of v and all its elements and then it sends the pair (typeid,\nencoded-v) where typeid is the type id of the encoded type of v and encoded-v is\nthe gob encoding of the value v.\n\nTo define a type, the encoder chooses an unused, positive type id and sends\nthe pair (-type id, encoded-type) where encoded-type is the gob encoding of a\nwireType description, constructed from these types:\n\n    type wireType struct {\n    \tArrayT           *arrayType\n    \tSliceT           *sliceType\n    \tStructT          *structType\n    \tMapT             *mapType\n    \tGobEncoderT      *gobEncoderType\n    \tBinaryMarshalerT *gobEncoderType\n    \tTextMarshalerT   *gobEncoderType\n    }\n    type arrayType struct {\n    \tCommonType\n    \tElem typeId\n    \tLen  int\n    }\n    type CommonType struct {\n    \tName string // the name of the struct type\n    \tId  int    // the id of the type, repeated so it's inside the type\n    }\n    type sliceType struct {\n    \tCommonType\n    \tElem typeId\n    }\n    type structType struct {\n    \tCommonType\n    \tField []fieldType // the fields of the struct.\n    }\n    type fieldType struct {\n    \tName string // the name of the field.\n    \tId   int    // the type id of the field, which must be already defined\n    }\n    type mapType struct {\n    \tCommonType\n    \tKey  typeId\n    \tElem typeId\n    }\n    type gobEncoderType struct {\n    \tCommonType\n    }\n\nIf there are nested type ids, the types for all inner type ids must be defined\nbefore the top-level type id is used to describe an encoded-v.\n\nFor simplicity in setup, the connection is defined to understand these types a\npriori, as well as the basic gob types int, uint, etc. Their ids are:\n\n    bool        1\n    int         2\n    uint        3\n    float       4\n    []byte      5\n    string      6\n    complex     7\n    interface   8\n    // gap for reserved ids.\n    WireType    16\n    ArrayType   17\n    CommonType  18\n    SliceType   19\n    StructType  20\n    FieldType   21\n    // 22 is slice of fieldType.\n    MapType     23\n\nFinally, each message created by a call to Encode is preceded by an encoded\nunsigned integer count of the number of bytes remaining in the message. After\nthe initial type name, interface values are wrapped the same way; in effect,\nthe interface value acts like a recursive invocation of Encode.\n\nIn summary, a gob stream looks like\n\n    (byteCount (-type id, encoding of a wireType)* (type id, encoding of a value))*\n\nwhere * signifies zero or more repetitions and the type id of a value must be\npredefined or be defined before the value in the stream.\n\nCompatibility: Any future changes to the package will endeavor to maintain\ncompatibility with streams encoded using previous versions. That is, any\nreleased version of this package should be able to decode data written with any\npreviously released version, subject to issues such as security fixes. See the\nGo compatibility document for background: https://golang.org/doc/go1compat\n\nSee \"Gobs of data\" for a design discussion of the gob wire format:\nhttps://blog.golang.org/gobs-of-data\n\n# Security\n\nThis package is not designed to be hardened against adversarial inputs,\nand is outside the scope of https://go.dev/security/policy. In particular,\nthe Decoder does only basic sanity checking on decoded input sizes, and its\nlimits are not configurable. Care should be taken when decoding gob data from\nuntrusted sources, which may consume significant resources.\n\nFUNCTIONS\n\nfunc Register(value any)\n    Register records a type, identified by a value for that type, under\n    its internal type name. That name will identify the concrete type of a\n    value sent or received as an interface variable. Only types that will be\n    transferred as implementations of interface values need to be registered.\n    Expecting to be used only during initialization, it panics if the mapping\n    between types and names is not a bijection.\n\nfunc RegisterName(name string, value any)\n    RegisterName is like Register but uses the provided name rather than the\n    type's default.\n\n\nTYPES\n\ntype CommonType struct {\n\tName string\n\tId   typeId\n}\n    CommonType holds elements of all types. It is a historical artifact, kept\n    for binary compatibility and exported only for the benefit of the package's\n    encoding of type descriptors. It is not intended for direct use by clients.\n\ntype Decoder struct {\n\t// Has unexported fields.\n}\n    A Decoder manages the receipt of type and data information read from the\n    remote side of a connection. It is safe for concurrent use by multiple\n    goroutines.\n\n    The Decoder does only basic sanity checking on decoded input sizes,\n    and its limits are not configurable. Take caution when decoding gob data\n    from untrusted sources.\n\nfunc NewDecoder(r io.Reader) *Decoder\n    NewDecoder returns a new decoder that reads from the io.Reader. If r does\n    not also implement io.ByteReader, it will be wrapped in a bufio.Reader.\n\nfunc (dec *Decoder) Decode(e any) error\n    Decode reads the next value from the input stream and stores it in the\n    data represented by the empty interface value. If e is nil, the value\n    will be discarded. Otherwise, the value underlying e must be a pointer to\n    the correct type for the next data item received. If the input is at EOF,\n    Decode returns io.EOF and does not modify e.\n\nfunc (dec *Decoder) DecodeValue(v reflect.Value) error\n    DecodeValue reads the next value from the input stream. If v is the zero\n    reflect.Value (v.Kind() == Invalid), DecodeValue discards the value.\n    Otherwise, it stores the value into v. In that case, v must represent a\n    non-nil pointer to data or be an assignable reflect.Value (v.CanSet()) If\n    the input is at EOF, DecodeValue returns io.EOF and does not modify v.\n\ntype Encoder struct {\n\t// Has unexported fields.\n}\n    An Encoder manages the transmission of type and data information to the\n    other side of a connection. It is safe for concurrent use by multiple\n    goroutines.\n\nfunc NewEncoder(w io.Writer) *Encoder\n    NewEncoder returns a new encoder that will transmit on the io.Writer.\n\nfunc (enc *Encoder) Encode(e any) error\n    Encode transmits the data item represented by the empty interface value,\n    guaranteeing that all necessary type information has been transmitted first.\n    Passing a nil pointer to Encoder will panic, as they cannot be transmitted\n    by gob.\n\nfunc (enc *Encoder) EncodeValue(value reflect.Value) error\n    EncodeValue transmits the data item represented by the reflection value,\n    guaranteeing that all necessary type information has been transmitted first.\n    Passing a nil pointer to EncodeValue will panic, as they cannot be\n    transmitted by gob.\n\ntype GobDecoder interface {\n\t// GobDecode overwrites the receiver, which must be a pointer,\n\t// with the value represented by the byte slice, which was written\n\t// by GobEncode, usually for the same concrete type.\n\tGobDecode([]byte) error\n}\n    GobDecoder is the interface describing data that provides its own routine\n    for decoding transmitted values sent by a GobEncoder.\n\ntype GobEncoder interface {\n\t// GobEncode returns a byte slice representing the encoding of the\n\t// receiver for transmission to a GobDecoder, usually of the same\n\t// concrete type.\n\tGobEncode() ([]byte, error)\n}\n    GobEncoder is the interface describing data that provides its own\n    representation for encoding values for transmission to a GobDecoder. A type\n    that implements GobEncoder and GobDecoder has complete control over the\n    representation of its data and may therefore contain things such as private\n    fields, channels, and functions, which are not usually transmissible in gob\n    streams.\n\n    Note: Since gobs can be stored permanently, it is good design to guarantee\n    the encoding used by a GobEncoder is stable as the software evolves.\n    For instance, it might make sense for GobEncode to include a version number\n    in the encoding.\n\n"}, {"path": "stdlib/go-internal-srcimporter.md", "category": "stdlib", "name": "stdlib/go-internal-srcimporter", "content": "package srcimporter // import \"go/internal/srcimporter\"\n\nPackage srcimporter implements importing directly from source files rather than\ninstalled packages.\n\nTYPES\n\ntype Importer struct {\n\t// Has unexported fields.\n}\n    An Importer provides the context for importing packages from source code.\n\nfunc New(ctxt *build.Context, fset *token.FileSet, packages map[string]*types.Package) *Importer\n    New returns a new Importer for the given context, file set, and map of\n    packages. The context is used to resolve import paths to package paths,\n    and identifying the files belonging to the package. If the context provides\n    non-nil file system functions, they are used instead of the regular package\n    os functions. The file set is used to track position information of package\n    files; and imported packages are added to the packages map.\n\nfunc (p *Importer) Import(path string) (*types.Package, error)\n    Import(path) is a shortcut for ImportFrom(path, \".\", 0).\n\nfunc (p *Importer) ImportFrom(path, srcDir string, mode types.ImportMode) (*types.Package, error)\n    ImportFrom imports the package with the given import path resolved from the\n    given srcDir, adds the new package to the set of packages maintained by the\n    importer, and returns the package. Package path resolution and file system\n    operations are controlled by the context maintained with the importer.\n    The import mode must be zero but is otherwise ignored. Packages that are\n    not comprised entirely of pure Go files may fail to import because the type\n    checker may not be able to determine all exported entities (e.g. due to cgo\n    dependencies).\n\n"}, {"path": "stdlib/vendor-golang.org-x-net-http-httpguts.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-net-http-httpguts", "content": ""}, {"path": "stdlib/container-ring.md", "category": "stdlib", "name": "stdlib/container-ring", "content": "package ring // import \"container/ring\"\n\nPackage ring implements operations on circular lists.\n\nTYPES\n\ntype Ring struct {\n\tValue any // for use by client; untouched by this library\n\t// Has unexported fields.\n}\n    A Ring is an element of a circular list, or ring. Rings do not have a\n    beginning or end; a pointer to any ring element serves as reference to the\n    entire ring. Empty rings are represented as nil Ring pointers. The zero\n    value for a Ring is a one-element ring with a nil Value.\n\nfunc New(n int) *Ring\n    New creates a ring of n elements.\n\nfunc (r *Ring) Do(f func(any))\n    Do calls function f on each element of the ring, in forward order. The\n    behavior of Do is undefined if f changes *r.\n\nfunc (r *Ring) Len() int\n    Len computes the number of elements in ring r. It executes in time\n    proportional to the number of elements.\n\nfunc (r *Ring) Link(s *Ring) *Ring\n    Link connects ring r with ring s such that r.Next() becomes s and returns\n    the original value for r.Next(). r must not be empty.\n\n    If r and s point to the same ring, linking them removes the elements between\n    r and s from the ring. The removed elements form a subring and the result\n    is a reference to that subring (if no elements were removed, the result is\n    still the original value for r.Next(), and not nil).\n\n    If r and s point to different rings, linking them creates a single ring\n    with the elements of s inserted after r. The result points to the element\n    following the last element of s after insertion.\n\nfunc (r *Ring) Move(n int) *Ring\n    Move moves n % r.Len() elements backward (n < 0) or forward (n >= 0) in the\n    ring and returns that ring element. r must not be empty.\n\nfunc (r *Ring) Next() *Ring\n    Next returns the next ring element. r must not be empty.\n\nfunc (r *Ring) Prev() *Ring\n    Prev returns the previous ring element. r must not be empty.\n\nfunc (r *Ring) Unlink(n int) *Ring\n    Unlink removes n % r.Len() elements from the ring r, starting at r.Next().\n    If n % r.Len() == 0, r remains unchanged. The result is the removed subring.\n    r must not be empty.\n\n"}, {"path": "stdlib/internal-trace-tracev2.md", "category": "stdlib", "name": "stdlib/internal-trace-tracev2", "content": "package tracev2 // import \"internal/trace/tracev2\"\n\nPackage tracev2 contains definitions for the v2 execution trace wire format.\n\nThese definitions are shared between the trace parser and the runtime, so it\nmust not depend on any package that depends on the runtime (most packages).\n\nCONSTANTS\n\nconst (\n\t// MaxBatchSize sets the maximum size that a batch can be.\n\t//\n\t// Directly controls the trace batch size in the runtime.\n\t//\n\t// NOTE: If this number decreases, the trace format version must change.\n\tMaxBatchSize = 64 << 10\n\n\t// Maximum number of PCs in a single stack trace.\n\t//\n\t// Since events contain only stack ID rather than whole stack trace,\n\t// we can allow quite large values here.\n\t//\n\t// Directly controls the maximum number of frames per stack\n\t// in the runtime.\n\t//\n\t// NOTE: If this number decreases, the trace format version must change.\n\tMaxFramesPerStack = 128\n\n\t// MaxEventTrailerDataSize controls the amount of trailer data that\n\t// an event can have in bytes. Must be smaller than MaxBatchSize.\n\t// Controls the maximum string size in the trace.\n\t//\n\t// Directly controls the maximum such value in the runtime.\n\t//\n\t// NOTE: If this number decreases, the trace format version must change.\n\tMaxEventTrailerDataSize = 1 << 10\n)\nconst MaxTimedEventArgs = 5\n    MaxTimedEventArgs is the maximum number of arguments for timed events.\n\nconst NumExperimentalEvents = MaxExperimentalEvent - MaxEvent\n\nVARIABLES\n\nvar EventArgTypes = [...]string{\n\t\"seq\",\n\t\"pstatus\",\n\t\"gstatus\",\n\t\"g\",\n\t\"m\",\n\t\"p\",\n\t\"string\",\n\t\"stack\",\n\t\"value\",\n\t\"task\",\n}\n    EventArgTypes is a list of valid argument types for use in Args.\n\n    See the documentation of Args for more details.\n\n\nFUNCTIONS\n\nfunc EventNames(specs []EventSpec) map[string]EventType\n    EventNames is a helper that produces a mapping of event names to event\n    types.\n\nfunc Experiments() []string\n\nTYPES\n\ntype EventSpec struct {\n\t// Name is the human-readable name of the trace event.\n\tName string\n\n\t// Args contains the names of each trace event's argument.\n\t// Its length determines the number of arguments an event has.\n\t//\n\t// Argument names follow a certain structure and this structure\n\t// is relied on by the testing framework to type-check arguments\n\t// and to produce Values for experimental events.\n\t//\n\t// The structure is:\n\t//\n\t//     (?P<name>[A-Za-z]+)(_(?P<type>[A-Za-z]+))?\n\t//\n\t// In sum, it's a name followed by an optional type.\n\t// If the type is present, it is preceded with an underscore.\n\t// Arguments without types will be interpreted as just raw uint64s.\n\t// The valid argument types and the Go types they map to are listed\n\t// in the ArgTypes variable.\n\tArgs []string\n\n\t// StringIDs indicates which of the arguments are string IDs.\n\tStringIDs []int\n\n\t// StackIDs indicates which of the arguments are stack IDs.\n\t//\n\t// The list is not sorted. The first index always refers to\n\t// the main stack for the current execution context of the event.\n\tStackIDs []int\n\n\t// StartEv indicates the event type of the corresponding \"start\"\n\t// event, if this event is an \"end,\" for a pair of events that\n\t// represent a time range.\n\tStartEv EventType\n\n\t// IsTimedEvent indicates whether this is an event that both\n\t// appears in the main event stream and is surfaced to the\n\t// trace reader.\n\t//\n\t// Events that are not \"timed\" are considered \"structural\"\n\t// since they either need significant reinterpretation or\n\t// otherwise aren't actually surfaced by the trace reader.\n\tIsTimedEvent bool\n\n\t// HasData is true if the event has trailer consisting of a\n\t// varint length followed by unencoded bytes of some data.\n\t//\n\t// An event may not be both a timed event and have data.\n\tHasData bool\n\n\t// IsStack indicates that the event represents a complete\n\t// stack trace. Specifically, it means that after the arguments\n\t// there's a varint length, followed by 4*length varints. Each\n\t// group of 4 represents the PC, file ID, func ID, and line number\n\t// in that order.\n\tIsStack bool\n\n\t// Experiment indicates the ID of an experiment this event is associated\n\t// with. If Experiment is not NoExperiment, then the event is experimental\n\t// and will be exposed as an EventExperiment.\n\tExperiment Experiment\n}\n    EventSpec is a specification for a trace event. It contains sufficient\n    information to perform basic parsing of any trace event for any version of\n    Go.\n\nfunc Specs() []EventSpec\n\ntype EventType uint8\n    EventType indicates an event's type from which its arguments and semantics\n    can be derived. Its representation matches the wire format's representation\n    of the event types that precede all event data.\n\nconst (\n\tEvNone EventType = iota // unused\n\n\t// Structural events.\n\tEvEventBatch // start of per-M batch of events [generation, M ID, timestamp, batch length]\n\tEvStacks     // start of a section of the stack table [...EvStack]\n\tEvStack      // stack table entry [ID, ...{PC, func string ID, file string ID, line #}]\n\tEvStrings    // start of a section of the string dictionary [...EvString]\n\tEvString     // string dictionary entry [ID, length, string]\n\tEvCPUSamples // start of a section of CPU samples [...EvCPUSample]\n\tEvCPUSample  // CPU profiling sample [timestamp, M ID, P ID, goroutine ID, stack ID]\n\tEvFrequency  // timestamp units per sec [freq]\n\n\t// Procs.\n\tEvProcsChange // current value of GOMAXPROCS [timestamp, GOMAXPROCS, stack ID]\n\tEvProcStart   // start of P [timestamp, P ID, P seq]\n\tEvProcStop    // stop of P [timestamp]\n\tEvProcSteal   // P was stolen [timestamp, P ID, P seq, M ID]\n\tEvProcStatus  // P status at the start of a generation [timestamp, P ID, status]\n\n\t// Goroutines.\n\tEvGoCreate            // goroutine creation [timestamp, new goroutine ID, new stack ID, stack ID]\n\tEvGoCreateSyscall     // goroutine appears in syscall (cgo callback) [timestamp, new goroutine ID]\n\tEvGoStart             // goroutine starts running [timestamp, goroutine ID, goroutine seq]\n\tEvGoDestroy           // goroutine ends [timestamp]\n\tEvGoDestroySyscall    // goroutine ends in syscall (cgo callback) [timestamp]\n\tEvGoStop              // goroutine yields its time, but is runnable [timestamp, reason, stack ID]\n\tEvGoBlock             // goroutine blocks [timestamp, reason, stack ID]\n\tEvGoUnblock           // goroutine is unblocked [timestamp, goroutine ID, goroutine seq, stack ID]\n\tEvGoSyscallBegin      // syscall enter [timestamp, P seq, stack ID]\n\tEvGoSyscallEnd        // syscall exit [timestamp]\n\tEvGoSyscallEndBlocked // syscall exit and it blocked at some point [timestamp]\n\tEvGoStatus            // goroutine status at the start of a generation [timestamp, goroutine ID, thread ID, status]\n\n\t// STW.\n\tEvSTWBegin // STW start [timestamp, kind]\n\tEvSTWEnd   // STW done [timestamp]\n\n\t// GC events.\n\tEvGCActive           // GC active [timestamp, seq]\n\tEvGCBegin            // GC start [timestamp, seq, stack ID]\n\tEvGCEnd              // GC done [timestamp, seq]\n\tEvGCSweepActive      // GC sweep active [timestamp, P ID]\n\tEvGCSweepBegin       // GC sweep start [timestamp, stack ID]\n\tEvGCSweepEnd         // GC sweep done [timestamp, swept bytes, reclaimed bytes]\n\tEvGCMarkAssistActive // GC mark assist active [timestamp, goroutine ID]\n\tEvGCMarkAssistBegin  // GC mark assist start [timestamp, stack ID]\n\tEvGCMarkAssistEnd    // GC mark assist done [timestamp]\n\tEvHeapAlloc          // gcController.heapLive change [timestamp, heap alloc in bytes]\n\tEvHeapGoal           // gcController.heapGoal() change [timestamp, heap goal in bytes]\n\n\t// Annotations.\n\tEvGoLabel         // apply string label to current running goroutine [timestamp, label string ID]\n\tEvUserTaskBegin   // trace.NewTask [timestamp, internal task ID, internal parent task ID, name string ID, stack ID]\n\tEvUserTaskEnd     // end of a task [timestamp, internal task ID, stack ID]\n\tEvUserRegionBegin // trace.{Start,With}Region [timestamp, internal task ID, name string ID, stack ID]\n\tEvUserRegionEnd   // trace.{End,With}Region [timestamp, internal task ID, name string ID, stack ID]\n\tEvUserLog         // trace.Log [timestamp, internal task ID, key string ID, value string ID, stack]\n\n\t// Coroutines. Added in Go 1.23.\n\tEvGoSwitch        // goroutine switch (coroswitch) [timestamp, goroutine ID, goroutine seq]\n\tEvGoSwitchDestroy // goroutine switch and destroy [timestamp, goroutine ID, goroutine seq]\n\tEvGoCreateBlocked // goroutine creation (starts blocked) [timestamp, new goroutine ID, new stack ID, stack ID]\n\n\t// GoStatus with stack. Added in Go 1.23.\n\tEvGoStatusStack // goroutine status at the start of a generation, with a stack [timestamp, goroutine ID, M ID, status, stack ID]\n\n\t// Batch event for an experimental batch with a custom format. Added in Go 1.23.\n\tEvExperimentalBatch // start of extra data [experiment ID, generation, M ID, timestamp, batch length, batch data...]\n\n\t// Sync batch. Added in Go 1.25. Previously a lone EvFrequency event.\n\tEvSync          // start of a sync batch [...EvFrequency|EvClockSnapshot]\n\tEvClockSnapshot // snapshot of trace, mono and wall clocks [timestamp, mono, sec, nsec]\n\n\t// Reserved internal in-band end-of-generation signal. Must never appear in the trace. Added in Go 1.25.\n\t// This could be used as an explicit in-band end-of-generation signal in the future.\n\tEvEndOfGeneration\n\n\tNumEvents\n)\n    Event types in the trace, args are given in square brackets.\n\n    Naming scheme:\n      - Time range event pairs have suffixes \"Begin\" and \"End\".\n      - \"Start\", \"Stop\", \"Create\", \"Destroy\", \"Block\", \"Unblock\" are suffixes\n        reserved for scheduling resources.\n\n    NOTE: If you add an event type, make sure you also update all tables in this\n    file!\n\nconst (\n\tMaxEvent EventType = 127 + iota\n\n\t// Experimental heap span events. Added in Go 1.23.\n\tEvSpan      // heap span exists [timestamp, id, npages, type/class]\n\tEvSpanAlloc // heap span alloc [timestamp, id, npages, type/class]\n\tEvSpanFree  // heap span free [timestamp, id]\n\n\t// Experimental heap object events. Added in Go 1.23.\n\tEvHeapObject      // heap object exists [timestamp, id, type]\n\tEvHeapObjectAlloc // heap object alloc [timestamp, id, type]\n\tEvHeapObjectFree  // heap object free [timestamp, id]\n\n\t// Experimental goroutine stack events. Added in Go 1.23.\n\tEvGoroutineStack      // stack exists [timestamp, id, order]\n\tEvGoroutineStackAlloc // stack alloc [timestamp, id, order]\n\tEvGoroutineStackFree  // stack free [timestamp, id]\n\n\tMaxExperimentalEvent\n)\n    Experimental events.\n\nfunc (ev EventType) Experimental() bool\n\ntype Experiment uint\n    Experiment is an experiment ID that events may be associated with.\n\nconst (\n\t// AllocFree is the alloc-free events experiment.\n\tAllocFree Experiment = 1 + iota\n\n\tNumExperiments\n)\n    Experiments.\n\nconst NoExperiment Experiment = 0\n    NoExperiment is the reserved ID 0 indicating no experiment.\n\ntype GoStatus uint8\n    GoStatus is the status of a goroutine.\n\n    They correspond directly to the various goroutine states.\n\nconst (\n\tGoBad GoStatus = iota\n\tGoRunnable\n\tGoRunning\n\tGoSyscall\n\tGoWaiting\n)\nfunc (s GoStatus) String() string\n\ntype ProcStatus uint8\n    ProcStatus is the status of a P.\n\n    They mostly correspond to the various P states.\n\nconst (\n\tProcBad ProcStatus = iota\n\tProcRunning\n\tProcIdle\n\tProcSyscall\n\n\t// ProcSyscallAbandoned is a special case of\n\t// ProcSyscall. It's used in the very specific case\n\t// where the first a P is mentioned in a generation is\n\t// part of a ProcSteal event. If that's the first time\n\t// it's mentioned, then there's no GoSyscallBegin to\n\t// connect the P stealing back to at that point. This\n\t// special state indicates this to the parser, so it\n\t// doesn't try to find a GoSyscallEndBlocked that\n\t// corresponds with the ProcSteal.\n\tProcSyscallAbandoned\n)\nfunc (s ProcStatus) String() string\n\n"}, {"path": "stdlib/reflect.md", "category": "stdlib", "name": "stdlib/reflect", "content": "package reflect // import \"reflect\"\n\nPackage reflect implements run-time reflection, allowing a program to manipulate\nobjects with arbitrary types. The typical use is to take a value with static\ntype interface{} and extract its dynamic type information by calling TypeOf,\nwhich returns a Type.\n\nA call to ValueOf returns a Value representing the run-time data. Zero takes a\nType and returns a Value representing a zero value for that type.\n\nSee \"The Laws of Reflection\" for an introduction to reflection in Go:\nhttps://golang.org/doc/articles/laws_of_reflection.html\n\nCONSTANTS\n\nconst Ptr = Pointer\n    Ptr is the old name for the Pointer kind.\n\n\nFUNCTIONS\n\nfunc Copy(dst, src Value) int\n    Copy copies the contents of src into dst until either dst has been filled\n    or src has been exhausted. It returns the number of elements copied. Dst and\n    src each must have kind Slice or Array, and dst and src must have the same\n    element type. It dst is an Array, it panics if Value.CanSet returns false.\n\n    As a special case, src can have kind String if the element type of dst is\n    kind Uint8.\n\nfunc DeepEqual(x, y any) bool\n    DeepEqual reports whether x and y are \u201cdeeply equal,\u201d defined as follows.\n    Two values of identical type are deeply equal if one of the following cases\n    applies. Values of distinct types are never deeply equal.\n\n    Array values are deeply equal when their corresponding elements are deeply\n    equal.\n\n    Struct values are deeply equal if their corresponding fields, both exported\n    and unexported, are deeply equal.\n\n    Func values are deeply equal if both are nil; otherwise they are not deeply\n    equal.\n\n    Interface values are deeply equal if they hold deeply equal concrete values.\n\n    Map values are deeply equal when all of the following are true: they are\n    both nil or both non-nil, they have the same length, and either they are the\n    same map object or their corresponding keys (matched using Go equality) map\n    to deeply equal values.\n\n    Pointer values are deeply equal if they are equal using Go's == operator or\n    if they point to deeply equal values.\n\n    Slice values are deeply equal when all of the following are true: they are\n    both nil or both non-nil, they have the same length, and either they point\n    to the same initial entry of the same underlying array (that is, &x[0] ==\n    &y[0]) or their corresponding elements (up to length) are deeply equal.\n    Note that a non-nil empty slice and a nil slice (for example, []byte{} and\n    []byte(nil)) are not deeply equal.\n\n    Other values - numbers, bools, strings, and channels - are deeply equal if\n    they are equal using Go's == operator.\n\n    In general DeepEqual is a recursive relaxation of Go's == operator.\n    However, this idea is impossible to implement without some inconsistency.\n    Specifically, it is possible for a value to be unequal to itself, either\n    because it is of func type (uncomparable in general) or because it is a\n    floating-point NaN value (not equal to itself in floating-point comparison),\n    or because it is an array, struct, or interface containing such a value.\n    On the other hand, pointer values are always equal to themselves, even if\n    they point at or contain such problematic values, because they compare equal\n    using Go's == operator, and that is a sufficient condition to be deeply\n    equal, regardless of content. DeepEqual has been defined so that the same\n    short-cut applies to slices and maps: if x and y are the same slice or the\n    same map, they are deeply equal regardless of content.\n\n    As DeepEqual traverses the data values it may find a cycle. The second and\n    subsequent times that DeepEqual compares two pointer values that have been\n    compared before, it treats the values as equal rather than examining the\n    values to which they point. This ensures that DeepEqual terminates.\n\nfunc Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)\n    Select executes a select operation described by the list of cases. Like the\n    Go select statement, it blocks until at least one of the cases can proceed,\n    makes a uniform pseudo-random choice, and then executes that case.\n    It returns the index of the chosen case and, if that case was a receive\n    operation, the value received and a boolean indicating whether the value\n    corresponds to a send on the channel (as opposed to a zero value received\n    because the channel is closed). Select supports a maximum of 65536 cases.\n\nfunc Swapper(slice any) func(i, j int)\n    Swapper returns a function that swaps the elements in the provided slice.\n\n    Swapper panics if the provided interface is not a slice.\n\nfunc TypeAssert[T any](v Value) (T, bool)\n    TypeAssert is semantically equivalent to:\n\n        v2, ok := v.Interface().(T)\n\n\nTYPES\n\ntype ChanDir int\n    ChanDir represents a channel type's direction.\n\nconst (\n\tRecvDir ChanDir             = 1 << iota // <-chan\n\tSendDir                                 // chan<-\n\tBothDir = RecvDir | SendDir             // chan\n)\nfunc (d ChanDir) String() string\n\ntype Kind uint\n    A Kind represents the specific kind of type that a Type represents. The zero\n    Kind is not a valid kind.\n\nconst (\n\tInvalid Kind = iota\n\tBool\n\tInt\n\tInt8\n\tInt16\n\tInt32\n\tInt64\n\tUint\n\tUint8\n\tUint16\n\tUint32\n\tUint64\n\tUintptr\n\tFloat32\n\tFloat64\n\tComplex64\n\tComplex128\n\tArray\n\tChan\n\tFunc\n\tInterface\n\tMap\n\tPointer\n\tSlice\n\tString\n\tStruct\n\tUnsafePointer\n)\nfunc (k Kind) String() string\n    String returns the name of k.\n\ntype MapIter struct {\n\t// Has unexported fields.\n}\n    A MapIter is an iterator for ranging over a map. See Value.MapRange.\n\nfunc (iter *MapIter) Key() Value\n    Key returns the key of iter's current map entry.\n\nfunc (iter *MapIter) Next() bool\n    Next advances the map iterator and reports whether there is another entry.\n    It returns false when iter is exhausted; subsequent calls to MapIter.Key,\n    MapIter.Value, or MapIter.Next will panic.\n\nfunc (iter *MapIter) Reset(v Value)\n    Reset modifies iter to iterate over v. It panics if v's Kind is not Map\n    and v is not the zero Value. Reset(Value{}) causes iter to not to refer to\n    any map, which may allow the previously iterated-over map to be garbage\n    collected.\n\nfunc (iter *MapIter) Value() Value\n    Value returns the value of iter's current map entry.\n\ntype Method struct {\n\t// Name is the method name.\n\tName string\n\n\t// PkgPath is the package path that qualifies a lower case (unexported)\n\t// method name. It is empty for upper case (exported) method names.\n\t// The combination of PkgPath and Name uniquely identifies a method\n\t// in a method set.\n\t// See https://golang.org/ref/spec#Uniqueness_of_identifiers\n\tPkgPath string\n\n\tType  Type  // method type\n\tFunc  Value // func with receiver as first argument\n\tIndex int   // index for Type.Method\n}\n    Method represents a single method.\n\nfunc (m Method) IsExported() bool\n    IsExported reports whether the method is exported.\n\ntype SelectCase struct {\n\tDir  SelectDir // direction of case\n\tChan Value     // channel to use (for send or receive)\n\tSend Value     // value to send (for send)\n}\n    A SelectCase describes a single case in a select operation. The kind of case\n    depends on Dir, the communication direction.\n\n    If Dir is SelectDefault, the case represents a default case. Chan and Send\n    must be zero Values.\n\n    If Dir is SelectSend, the case represents a send operation. Normally Chan's\n    underlying value must be a channel, and Send's underlying value must be\n    assignable to the channel's element type. As a special case, if Chan is\n    a zero Value, then the case is ignored, and the field Send will also be\n    ignored and may be either zero or non-zero.\n\n    If Dir is SelectRecv, the case represents a receive operation. Normally\n    Chan's underlying value must be a channel and Send must be a zero Value.\n    If Chan is a zero Value, then the case is ignored, but Send must still be\n    a zero Value. When a receive operation is selected, the received Value is\n    returned by Select.\n\ntype SelectDir int\n    A SelectDir describes the communication direction of a select case.\n\nconst (\n\tSelectSend    SelectDir // case Chan <- Send\n\tSelectRecv              // case <-Chan:\n\tSelectDefault           // default\n)\ntype SliceHeader struct {\n\tData uintptr\n\tLen  int\n\tCap  int\n}\n    SliceHeader is the runtime representation of a slice. It cannot be used\n    safely or portably and its representation may change in a later release.\n    Moreover, the Data field is not sufficient to guarantee the data it\n    references will not be garbage collected, so programs must keep a separate,\n    correctly typed pointer to the underlying data.\n\n    Deprecated: Use unsafe.Slice or unsafe.SliceData instead.\n\ntype StringHeader struct {\n\tData uintptr\n\tLen  int\n}\n    StringHeader is the runtime representation of a string. It cannot be used\n    safely or portably and its representation may change in a later release.\n    Moreover, the Data field is not sufficient to guarantee the data it\n    references will not be garbage collected, so programs must keep a separate,\n    correctly typed pointer to the underlying data.\n\n    Deprecated: Use unsafe.String or unsafe.StringData instead.\n\ntype StructField struct {\n\t// Name is the field name.\n\tName string\n\n\t// PkgPath is the package path that qualifies a lower case (unexported)\n\t// field name. It is empty for upper case (exported) field names.\n\t// See https://golang.org/ref/spec#Uniqueness_of_identifiers\n\tPkgPath string\n\n\tType      Type      // field type\n\tTag       StructTag // field tag string\n\tOffset    uintptr   // offset within struct, in bytes\n\tIndex     []int     // index sequence for Type.FieldByIndex\n\tAnonymous bool      // is an embedded field\n}\n    A StructField describes a single field in a struct.\n\nfunc VisibleFields(t Type) []StructField\n    VisibleFields returns all the visible fields in t, which must be a struct\n    type. A field is defined as visible if it's accessible directly with a\n    FieldByName call. The returned fields include fields inside anonymous struct\n    members and unexported fields. They follow the same order found in the\n    struct, with anonymous fields followed immediately by their promoted fields.\n\n    For each element e of the returned slice, the corresponding field can be\n    retrieved from a value v of type t by calling v.FieldByIndex(e.Index).\n\nfunc (f StructField) IsExported() bool\n    IsExported reports whether the field is exported.\n\ntype StructTag string\n    A StructTag is the tag string in a struct field.\n\n    By convention, tag strings are a concatenation of optionally space-separated\n    key:\"value\" pairs. Each key is a non-empty string consisting of non-control\n    characters other than space (U+0020 ' '), quote (U+0022 '\"'), and colon\n    (U+003A ':'). Each value is quoted using U+0022 '\"' characters and Go string\n    literal syntax.\n\nfunc (tag StructTag) Get(key string) string\n    Get returns the value associated with key in the tag string. If there is\n    no such key in the tag, Get returns the empty string. If the tag does not\n    have the conventional format, the value returned by Get is unspecified.\n    To determine whether a tag is explicitly set to the empty string, use\n    StructTag.Lookup.\n\nfunc (tag StructTag) Lookup(key string) (value string, ok bool)\n    Lookup returns the value associated with key in the tag string. If the key\n    is present in the tag the value (which may be empty) is returned. Otherwise\n    the returned value will be the empty string. The ok return value reports\n    whether the value was explicitly set in the tag string. If the tag does not\n    have the conventional format, the value returned by Lookup is unspecified.\n\ntype Type interface {\n\n\t// Align returns the alignment in bytes of a value of\n\t// this type when allocated in memory.\n\tAlign() int\n\n\t// FieldAlign returns the alignment in bytes of a value of\n\t// this type when used as a field in a struct.\n\tFieldAlign() int\n\n\t// Method returns the i'th method in the type's method set.\n\t// It panics if i is not in the range [0, NumMethod()).\n\t//\n\t// For a non-interface type T or *T, the returned Method's Type and Func\n\t// fields describe a function whose first argument is the receiver,\n\t// and only exported methods are accessible.\n\t//\n\t// For an interface type, the returned Method's Type field gives the\n\t// method signature, without a receiver, and the Func field is nil.\n\t//\n\t// Methods are sorted in lexicographic order.\n\t//\n\t// Calling this method will force the linker to retain all exported methods in all packages.\n\t// This may make the executable binary larger but will not affect execution time.\n\tMethod(int) Method\n\n\t// MethodByName returns the method with that name in the type's\n\t// method set and a boolean indicating if the method was found.\n\t//\n\t// For a non-interface type T or *T, the returned Method's Type and Func\n\t// fields describe a function whose first argument is the receiver.\n\t//\n\t// For an interface type, the returned Method's Type field gives the\n\t// method signature, without a receiver, and the Func field is nil.\n\t//\n\t// Calling this method will cause the linker to retain all methods with this name in all packages.\n\t// If the linker can't determine the name, it will retain all exported methods.\n\t// This may make the executable binary larger but will not affect execution time.\n\tMethodByName(string) (Method, bool)\n\n\t// NumMethod returns the number of methods accessible using Method.\n\t//\n\t// For a non-interface type, it returns the number of exported methods.\n\t//\n\t// For an interface type, it returns the number of exported and unexported methods.\n\tNumMethod() int\n\n\t// Name returns the type's name within its package for a defined type.\n\t// For other (non-defined) types it returns the empty string.\n\tName() string\n\n\t// PkgPath returns a defined type's package path, that is, the import path\n\t// that uniquely identifies the package, such as \"encoding/base64\".\n\t// If the type was predeclared (string, error) or not defined (*T, struct{},\n\t// []int, or A where A is an alias for a non-defined type), the package path\n\t// will be the empty string.\n\tPkgPath() string\n\n\t// Size returns the number of bytes needed to store\n\t// a value of the given type; it is analogous to unsafe.Sizeof.\n\tSize() uintptr\n\n\t// String returns a string representation of the type.\n\t// The string representation may use shortened package names\n\t// (e.g., base64 instead of \"encoding/base64\") and is not\n\t// guaranteed to be unique among types. To test for type identity,\n\t// compare the Types directly.\n\tString() string\n\n\t// Kind returns the specific kind of this type.\n\tKind() Kind\n\n\t// Implements reports whether the type implements the interface type u.\n\tImplements(u Type) bool\n\n\t// AssignableTo reports whether a value of the type is assignable to type u.\n\tAssignableTo(u Type) bool\n\n\t// ConvertibleTo reports whether a value of the type is convertible to type u.\n\t// Even if ConvertibleTo returns true, the conversion may still panic.\n\t// For example, a slice of type []T is convertible to *[N]T,\n\t// but the conversion will panic if its length is less than N.\n\tConvertibleTo(u Type) bool\n\n\t// Comparable reports whether values of this type are comparable.\n\t// Even if Comparable returns true, the comparison may still panic.\n\t// For example, values of interface type are comparable,\n\t// but the comparison will panic if their dynamic type is not comparable.\n\tComparable() bool\n\n\t// Bits returns the size of the type in bits.\n\t// It panics if the type's Kind is not one of the\n\t// sized or unsized Int, Uint, Float, or Complex kinds.\n\tBits() int\n\n\t// ChanDir returns a channel type's direction.\n\t// It panics if the type's Kind is not Chan.\n\tChanDir() ChanDir\n\n\t// IsVariadic reports whether a function type's final input parameter\n\t// is a \"...\" parameter. If so, t.In(t.NumIn() - 1) returns the parameter's\n\t// implicit actual type []T.\n\t//\n\t// For concreteness, if t represents func(x int, y ... float64), then\n\t//\n\t//\tt.NumIn() == 2\n\t//\tt.In(0) is the reflect.Type for \"int\"\n\t//\tt.In(1) is the reflect.Type for \"[]float64\"\n\t//\tt.IsVariadic() == true\n\t//\n\t// IsVariadic panics if the type's Kind is not Func.\n\tIsVariadic() bool\n\n\t// Elem returns a type's element type.\n\t// It panics if the type's Kind is not Array, Chan, Map, Pointer, or Slice.\n\tElem() Type\n\n\t// Field returns a struct type's i'th field.\n\t// It panics if the type's Kind is not Struct.\n\t// It panics if i is not in the range [0, NumField()).\n\tField(i int) StructField\n\n\t// FieldByIndex returns the nested field corresponding\n\t// to the index sequence. It is equivalent to calling Field\n\t// successively for each index i.\n\t// It panics if the type's Kind is not Struct.\n\tFieldByIndex(index []int) StructField\n\n\t// FieldByName returns the struct field with the given name\n\t// and a boolean indicating if the field was found.\n\t// If the returned field is promoted from an embedded struct,\n\t// then Offset in the returned StructField is the offset in\n\t// the embedded struct.\n\tFieldByName(name string) (StructField, bool)\n\n\t// FieldByNameFunc returns the struct field with a name\n\t// that satisfies the match function and a boolean indicating if\n\t// the field was found.\n\t//\n\t// FieldByNameFunc considers the fields in the struct itself\n\t// and then the fields in any embedded structs, in breadth first order,\n\t// stopping at the shallowest nesting depth containing one or more\n\t// fields satisfying the match function. If multiple fields at that depth\n\t// satisfy the match function, they cancel each other\n\t// and FieldByNameFunc returns no match.\n\t// This behavior mirrors Go's handling of name lookup in\n\t// structs containing embedded fields.\n\t//\n\t// If the returned field is promoted from an embedded struct,\n\t// then Offset in the returned StructField is the offset in\n\t// the embedded struct.\n\tFieldByNameFunc(match func(string) bool) (StructField, bool)\n\n\t// In returns the type of a function type's i'th input parameter.\n\t// It panics if the type's Kind is not Func.\n\t// It panics if i is not in the range [0, NumIn()).\n\tIn(i int) Type\n\n\t// Key returns a map type's key type.\n\t// It panics if the type's Kind is not Map.\n\tKey() Type\n\n\t// Len returns an array type's length.\n\t// It panics if the type's Kind is not Array.\n\tLen() int\n\n\t// NumField returns a struct type's field count.\n\t// It panics if the type's Kind is not Struct.\n\tNumField() int\n\n\t// NumIn returns a function type's input parameter count.\n\t// It panics if the type's Kind is not Func.\n\tNumIn() int\n\n\t// NumOut returns a function type's output parameter count.\n\t// It panics if the type's Kind is not Func.\n\tNumOut() int\n\n\t// Out returns the type of a function type's i'th output parameter.\n\t// It panics if the type's Kind is not Func.\n\t// It panics if i is not in the range [0, NumOut()).\n\tOut(i int) Type\n\n\t// OverflowComplex reports whether the complex128 x cannot be represented by type t.\n\t// It panics if t's Kind is not Complex64 or Complex128.\n\tOverflowComplex(x complex128) bool\n\n\t// OverflowFloat reports whether the float64 x cannot be represented by type t.\n\t// It panics if t's Kind is not Float32 or Float64.\n\tOverflowFloat(x float64) bool\n\n\t// OverflowInt reports whether the int64 x cannot be represented by type t.\n\t// It panics if t's Kind is not Int, Int8, Int16, Int32, or Int64.\n\tOverflowInt(x int64) bool\n\n\t// OverflowUint reports whether the uint64 x cannot be represented by type t.\n\t// It panics if t's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.\n\tOverflowUint(x uint64) bool\n\n\t// CanSeq reports whether a [Value] with this type can be iterated over using [Value.Seq].\n\tCanSeq() bool\n\n\t// CanSeq2 reports whether a [Value] with this type can be iterated over using [Value.Seq2].\n\tCanSeq2() bool\n\n\t// Has unexported methods.\n}\n    Type is the representation of a Go type.\n\n    Not all methods apply to all kinds of types. Restrictions, if any,\n    are noted in the documentation for each method. Use the Kind method to find\n    out the kind of type before calling kind-specific methods. Calling a method\n    inappropriate to the kind of type causes a run-time panic.\n\n    Type values are comparable, such as with the == operator, so they can be\n    used as map keys. Two Type values are equal if they represent identical\n    types.\n\nfunc ArrayOf(length int, elem Type) Type\n    ArrayOf returns the array type with the given length and element type.\n    For example, if t represents int, ArrayOf(5, t) represents [5]int.\n\n    If the resulting type would be larger than the available address space,\n    ArrayOf panics.\n\nfunc ChanOf(dir ChanDir, t Type) Type\n    ChanOf returns the channel type with the given direction and element type.\n    For example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.\n\n    The gc runtime imposes a limit of 64 kB on channel element types. If t's\n    size is equal to or exceeds this limit, ChanOf panics.\n\nfunc FuncOf(in, out []Type, variadic bool) Type\n    FuncOf returns the function type with the given argument and result types.\n    For example if k represents int and e represents string, FuncOf([]Type{k},\n    []Type{e}, false) represents func(int) string.\n\n    The variadic argument controls whether the function is variadic. FuncOf\n    panics if the in[len(in)-1] does not represent a slice and variadic is true.\n\nfunc MapOf(key, elem Type) Type\n    MapOf returns the map type with the given key and element types. For\n    example, if k represents int and e represents string, MapOf(k, e) represents\n    map[int]string.\n\n    If the key type is not a valid map key type (that is, if it does not\n    implement Go's == operator), MapOf panics.\n\nfunc PointerTo(t Type) Type\n    PointerTo returns the pointer type with element t. For example, if t\n    represents type Foo, PointerTo(t) represents *Foo.\n\nfunc PtrTo(t Type) Type\n    PtrTo returns the pointer type with element t. For example, if t represents\n    type Foo, PtrTo(t) represents *Foo.\n\n    PtrTo is the old spelling of PointerTo. The two functions behave\n    identically.\n\n    Deprecated: Superseded by PointerTo.\n\nfunc SliceOf(t Type) Type\n    SliceOf returns the slice type with element type t. For example, if t\n    represents int, SliceOf(t) represents []int.\n\nfunc StructOf(fields []StructField) Type\n    StructOf returns the struct type containing fields. The Offset and Index\n    fields are ignored and computed as they would be by the compiler.\n\n    StructOf currently does not support promoted methods of embedded fields and\n    panics if passed unexported StructFields.\n\nfunc TypeFor[T any]() Type\n    TypeFor returns the Type that represents the type argument T.\n\nfunc TypeOf(i any) Type\n    TypeOf returns the reflection Type that represents the dynamic type of i.\n    If i is a nil interface value, TypeOf returns nil.\n\ntype Value struct {\n\t// Has unexported fields.\n}\n    Value is the reflection interface to a Go value.\n\n    Not all methods apply to all kinds of values. Restrictions, if any,\n    are noted in the documentation for each method. Use the Kind method to find\n    out the kind of value before calling kind-specific methods. Calling a method\n    inappropriate to the kind of type causes a run time panic.\n\n    The zero Value represents no value. Its Value.IsValid method returns false,\n    its Kind method returns Invalid, its String method returns \"<invalid\n    Value>\", and all other methods panic. Most functions and methods never\n    return an invalid value. If one does, its documentation states the\n    conditions explicitly.\n\n    A Value can be used concurrently by multiple goroutines provided that the\n    underlying Go value can be used concurrently for the equivalent direct\n    operations.\n\n    To compare two Values, compare the results of the Interface method. Using ==\n    on two Values does not compare the underlying values they represent.\n\nfunc Append(s Value, x ...Value) Value\n    Append appends the values x to a slice s and returns the resulting slice.\n    As in Go, each x's value must be assignable to the slice's element type.\n\nfunc AppendSlice(s, t Value) Value\n    AppendSlice appends a slice t to a slice s and returns the resulting slice.\n    The slices s and t must have the same element type.\n\nfunc Indirect(v Value) Value\n    Indirect returns the value that v points to. If v is a nil pointer, Indirect\n    returns a zero Value. If v is not a pointer, Indirect returns v.\n\nfunc MakeChan(typ Type, buffer int) Value\n    MakeChan creates a new channel with the specified type and buffer size.\n\nfunc MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value\n    MakeFunc returns a new function of the given Type that wraps the function\n    fn. When called, that new function does the following:\n\n      - converts its arguments to a slice of Values.\n      - runs results := fn(args).\n      - returns the results as a slice of Values, one per formal result.\n\n    The implementation fn can assume that the argument Value slice has the\n    number and type of arguments given by typ. If typ describes a variadic\n    function, the final Value is itself a slice representing the variadic\n    arguments, as in the body of a variadic function. The result Value slice\n    returned by fn must have the number and type of results given by typ.\n\n    The Value.Call method allows the caller to invoke a typed function in terms\n    of Values; in contrast, MakeFunc allows the caller to implement a typed\n    function in terms of Values.\n\n    The Examples section of the documentation includes an illustration of how to\n    use MakeFunc to build a swap function for different types.\n\nfunc MakeMap(typ Type) Value\n    MakeMap creates a new map with the specified type.\n\nfunc MakeMapWithSize(typ Type, n int) Value\n    MakeMapWithSize creates a new map with the specified type and initial space\n    for approximately n elements.\n\nfunc MakeSlice(typ Type, len, cap int) Value\n    MakeSlice creates a new zero-initialized slice value for the specified slice\n    type, length, and capacity.\n\nfunc New(typ Type) Value\n    New returns a Value representing a pointer to a new zero value for the\n    specified type. That is, the returned Value's Type is PointerTo(typ).\n\nfunc NewAt(typ Type, p unsafe.Pointer) Value\n    NewAt returns a Value representing a pointer to a value of the specified\n    type, using p as that pointer.\n\nfunc SliceAt(typ Type, p unsafe.Pointer, n int) Value\n    SliceAt returns a Value representing a slice whose underlying data starts at\n    p, with length and capacity equal to n.\n\n    This is like unsafe.Slice.\n\nfunc ValueOf(i any) Value\n    ValueOf returns a new Value initialized to the concrete value stored in the\n    interface i. ValueOf(nil) returns the zero Value.\n\nfunc Zero(typ Type) Value\n    Zero returns a Value representing the zero value for the specified type.\n    The result is different from the zero value of the Value struct, which\n    represents no value at all. For example, Zero(TypeOf(42)) returns a Value\n    with Kind Int and value 0. The returned value is neither addressable nor\n    settable.\n\nfunc (v Value) Addr() Value\n    Addr returns a pointer value representing the address of v. It panics if\n    Value.CanAddr returns false. Addr is typically used to obtain a pointer to\n    a struct field or slice element in order to call a method that requires a\n    pointer receiver.\n\nfunc (v Value) Bool() bool\n    Bool returns v's underlying value. It panics if v's kind is not Bool.\n\nfunc (v Value) Bytes() []byte\n    Bytes returns v's underlying value. It panics if v's underlying value is not\n    a slice of bytes or an addressable array of bytes.\n\nfunc (v Value) Call(in []Value) []Value\n    Call calls the function v with the input arguments in. For example, if\n    len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]). Call\n    panics if v's Kind is not Func. It returns the output results as Values. As\n    in Go, each input argument must be assignable to the type of the function's\n    corresponding input parameter. If v is a variadic function, Call creates the\n    variadic slice parameter itself, copying in the corresponding values.\n\nfunc (v Value) CallSlice(in []Value) []Value\n    CallSlice calls the variadic function v with the input arguments in,\n    assigning the slice in[len(in)-1] to v's final variadic argument. For\n    example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0],\n    in[1], in[2]...). CallSlice panics if v's Kind is not Func or if v is not\n    variadic. It returns the output results as Values. As in Go, each input\n    argument must be assignable to the type of the function's corresponding\n    input parameter.\n\nfunc (v Value) CanAddr() bool\n    CanAddr reports whether the value's address can be obtained with Value.Addr.\n    Such values are called addressable. A value is addressable if it is an\n    element of a slice, an element of an addressable array, a field of an\n    addressable struct, or the result of dereferencing a pointer. If CanAddr\n    returns false, calling Value.Addr will panic.\n\nfunc (v Value) CanComplex() bool\n    CanComplex reports whether Value.Complex can be used without panicking.\n\nfunc (v Value) CanConvert(t Type) bool\n    CanConvert reports whether the value v can be converted to type t.\n    If v.CanConvert(t) returns true then v.Convert(t) will not panic.\n\nfunc (v Value) CanFloat() bool\n    CanFloat reports whether Value.Float can be used without panicking.\n\nfunc (v Value) CanInt() bool\n    CanInt reports whether Int can be used without panicking.\n\nfunc (v Value) CanInterface() bool\n    CanInterface reports whether Value.Interface can be used without panicking.\n\nfunc (v Value) CanSet() bool\n    CanSet reports whether the value of v can be changed. A Value can be\n    changed only if it is addressable and was not obtained by the use of\n    unexported struct fields. If CanSet returns false, calling Value.Set or any\n    type-specific setter (e.g., Value.SetBool, Value.SetInt) will panic.\n\nfunc (v Value) CanUint() bool\n    CanUint reports whether Value.Uint can be used without panicking.\n\nfunc (v Value) Cap() int\n    Cap returns v's capacity. It panics if v's Kind is not Array, Chan, Slice or\n    pointer to Array.\n\nfunc (v Value) Clear()\n    Clear clears the contents of a map or zeros the contents of a slice.\n\n    It panics if v's Kind is not Map or Slice.\n\nfunc (v Value) Close()\n    Close closes the channel v. It panics if v's Kind is not Chan or v is a\n    receive-only channel.\n\nfunc (v Value) Comparable() bool\n    Comparable reports whether the value v is comparable. If the type of v\n    is an interface, this checks the dynamic type. If this reports true then\n    v.Interface() == x will not panic for any x, nor will v.Equal(u) for any\n    Value u.\n\nfunc (v Value) Complex() complex128\n    Complex returns v's underlying value, as a complex128. It panics if v's Kind\n    is not Complex64 or Complex128\n\nfunc (v Value) Convert(t Type) Value\n    Convert returns the value v converted to type t. If the usual Go conversion\n    rules do not allow conversion of the value v to type t, or if converting v\n    to type t panics, Convert panics.\n\nfunc (v Value) Elem() Value\n    Elem returns the value that the interface v contains or that the pointer v\n    points to. It panics if v's Kind is not Interface or Pointer. It returns the\n    zero Value if v is nil.\n\nfunc (v Value) Equal(u Value) bool\n    Equal reports true if v is equal to u. For two invalid values, Equal will\n    report true. For an interface value, Equal will compare the value within the\n    interface. Otherwise, If the values have different types, Equal will report\n    false. Otherwise, for arrays and structs Equal will compare each element\n    in order, and report false if it finds non-equal elements. During all\n    comparisons, if values of the same type are compared, and the type is not\n    comparable, Equal will panic.\n\nfunc (v Value) Field(i int) Value\n    Field returns the i'th field of the struct v. It panics if v's Kind is not\n    Struct or i is out of range.\n\nfunc (v Value) FieldByIndex(index []int) Value\n    FieldByIndex returns the nested field corresponding to index. It panics if\n    evaluation requires stepping through a nil pointer or a field that is not a\n    struct.\n\nfunc (v Value) FieldByIndexErr(index []int) (Value, error)\n    FieldByIndexErr returns the nested field corresponding to index. It returns\n    an error if evaluation requires stepping through a nil pointer, but panics\n    if it must step through a field that is not a struct.\n\nfunc (v Value) FieldByName(name string) Value\n    FieldByName returns the struct field with the given name. It returns the\n    zero Value if no field was found. It panics if v's Kind is not Struct.\n\nfunc (v Value) FieldByNameFunc(match func(string) bool) Value\n    FieldByNameFunc returns the struct field with a name that satisfies the\n    match function. It panics if v's Kind is not Struct. It returns the zero\n    Value if no field was found.\n\nfunc (v Value) Float() float64\n    Float returns v's underlying value, as a float64. It panics if v's Kind is\n    not Float32 or Float64\n\nfunc (v Value) Grow(n int)\n    Grow increases the slice's capacity, if necessary, to guarantee space for\n    another n elements. After Grow(n), at least n elements can be appended to\n    the slice without another allocation.\n\n    It panics if v's Kind is not a Slice, or if n is negative or too large to\n    allocate the memory, or if Value.CanSet returns false.\n\nfunc (v Value) Index(i int) Value\n    Index returns v's i'th element. It panics if v's Kind is not Array, Slice,\n    or String or i is out of range.\n\nfunc (v Value) Int() int64\n    Int returns v's underlying value, as an int64. It panics if v's Kind is not\n    Int, Int8, Int16, Int32, or Int64.\n\nfunc (v Value) Interface() (i any)\n    Interface returns v's current value as an interface{}. It is equivalent to:\n\n        var i interface{} = (v's underlying value)\n\n    It panics if the Value was obtained by accessing unexported struct fields.\n\nfunc (v Value) InterfaceData() [2]uintptr\n    InterfaceData returns a pair of unspecified uintptr values. It panics if v's\n    Kind is not Interface.\n\n    In earlier versions of Go, this function returned the interface's value as a\n    uintptr pair. As of Go 1.4, the implementation of interface values precludes\n    any defined use of InterfaceData.\n\n    Deprecated: The memory representation of interface values is not compatible\n    with InterfaceData.\n\nfunc (v Value) IsNil() bool\n    IsNil reports whether its argument v is nil. The argument must be a chan,\n    func, interface, map, pointer, or slice value; if it is not, IsNil panics.\n    Note that IsNil is not always equivalent to a regular comparison with nil in\n    Go. For example, if v was created by calling ValueOf with an uninitialized\n    interface variable i, i==nil will be true but v.IsNil will panic as v will\n    be the zero Value.\n\nfunc (v Value) IsValid() bool\n    IsValid reports whether v represents a value. It returns false if v is\n    the zero Value. If Value.IsValid returns false, all other methods except\n    String panic. Most functions and methods never return an invalid Value.\n    If one does, its documentation states the conditions explicitly.\n\nfunc (v Value) IsZero() bool\n    IsZero reports whether v is the zero value for its type. It panics if the\n    argument is invalid.\n\nfunc (v Value) Kind() Kind\n    Kind returns v's Kind. If v is the zero Value (Value.IsValid returns false),\n    Kind returns Invalid.\n\nfunc (v Value) Len() int\n    Len returns v's length. It panics if v's Kind is not Array, Chan, Map,\n    Slice, String, or pointer to Array.\n\nfunc (v Value) MapIndex(key Value) Value\n    MapIndex returns the value associated with key in the map v. It panics\n    if v's Kind is not Map. It returns the zero Value if key is not found in\n    the map or if v represents a nil map. As in Go, the key's value must be\n    assignable to the map's key type.\n\nfunc (v Value) MapKeys() []Value\n    MapKeys returns a slice containing all the keys present in the map,\n    in unspecified order. It panics if v's Kind is not Map. It returns an empty\n    slice if v represents a nil map.\n\nfunc (v Value) MapRange() *MapIter\n    MapRange returns a range iterator for a map. It panics if v's Kind is not\n    Map.\n\n    Call MapIter.Next to advance the iterator, and MapIter.Key/MapIter.Value\n    to access each entry. MapIter.Next returns false when the iterator is\n    exhausted. MapRange follows the same iteration semantics as a range\n    statement.\n\n    Example:\n\n        iter := reflect.ValueOf(m).MapRange()\n        for iter.Next() {\n        \tk := iter.Key()\n        \tv := iter.Value()\n        \t...\n        }\n\nfunc (v Value) Method(i int) Value\n    Method returns a function value corresponding to v's i'th method. The\n    arguments to a Call on the returned function should not include a receiver;\n    the returned function will always use v as the receiver. Method panics if i\n    is out of range or if v is a nil interface value.\n\n    Calling this method will force the linker to retain all exported methods in\n    all packages. This may make the executable binary larger but will not affect\n    execution time.\n\nfunc (v Value) MethodByName(name string) Value\n    MethodByName returns a function value corresponding to the method of v with\n    the given name. The arguments to a Call on the returned function should not\n    include a receiver; the returned function will always use v as the receiver.\n    It returns the zero Value if no method was found.\n\n    Calling this method will cause the linker to retain all methods with this\n    name in all packages. If the linker can't determine the name, it will retain\n    all exported methods. This may make the executable binary larger but will\n    not affect execution time.\n\nfunc (v Value) NumField() int\n    NumField returns the number of fields in the struct v. It panics if v's Kind\n    is not Struct.\n\nfunc (v Value) NumMethod() int\n    NumMethod returns the number of methods in the value's method set.\n\n    For a non-interface type, it returns the number of exported methods.\n\n    For an interface type, it returns the number of exported and unexported\n    methods.\n\nfunc (v Value) OverflowComplex(x complex128) bool\n    OverflowComplex reports whether the complex128 x cannot be represented by\n    v's type. It panics if v's Kind is not Complex64 or Complex128.\n\nfunc (v Value) OverflowFloat(x float64) bool\n    OverflowFloat reports whether the float64 x cannot be represented by v's\n    type. It panics if v's Kind is not Float32 or Float64.\n\nfunc (v Value) OverflowInt(x int64) bool\n    OverflowInt reports whether the int64 x cannot be represented by v's type.\n    It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.\n\nfunc (v Value) OverflowUint(x uint64) bool\n    OverflowUint reports whether the uint64 x cannot be represented by v's type.\n    It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32,\n    or Uint64.\n\nfunc (v Value) Pointer() uintptr\n    Pointer returns v's value as a uintptr. It panics if v's Kind is not Chan,\n    Func, Map, Pointer, Slice, String, or UnsafePointer.\n\n    If v's Kind is Func, the returned pointer is an underlying code pointer,\n    but not necessarily enough to identify a single function uniquely. The only\n    guarantee is that the result is zero if and only if v is a nil func Value.\n\n    If v's Kind is Slice, the returned pointer is to the first element of the\n    slice. If the slice is nil the returned value is 0. If the slice is empty\n    but non-nil the return value is non-zero.\n\n    If v's Kind is String, the returned pointer is to the first element of the\n    underlying bytes of string.\n\n    It's preferred to use uintptr(Value.UnsafePointer()) to get the equivalent\n    result.\n\nfunc (v Value) Recv() (x Value, ok bool)\n    Recv receives and returns a value from the channel v. It panics if v's Kind\n    is not Chan. The receive blocks until a value is ready. The boolean value ok\n    is true if the value x corresponds to a send on the channel, false if it is\n    a zero value received because the channel is closed.\n\nfunc (v Value) Send(x Value)\n    Send sends x on the channel v. It panics if v's kind is not Chan or if x's\n    type is not the same type as v's element type. As in Go, x's value must be\n    assignable to the channel's element type.\n\nfunc (v Value) Seq() iter.Seq[Value]\n    Seq returns an iter.Seq[Value] that loops over the elements of v.\n    If v's kind is Func, it must be a function that has no results and that\n    takes a single argument of type func(T) bool for some type T. If v's kind is\n    Pointer, the pointer element type must have kind Array. Otherwise v's kind\n    must be Int, Int8, Int16, Int32, Int64, Uint, Uint8, Uint16, Uint32, Uint64,\n    Uintptr, Array, Chan, Map, Slice, or String.\n\nfunc (v Value) Seq2() iter.Seq2[Value, Value]\n    Seq2 returns an iter.Seq2[Value, Value] that loops over the elements of v.\n    If v's kind is Func, it must be a function that has no results and that\n    takes a single argument of type func(K, V) bool for some type K, V.\n    If v's kind is Pointer, the pointer element type must have kind Array.\n    Otherwise v's kind must be Array, Map, Slice, or String.\n\nfunc (v Value) Set(x Value)\n    Set assigns x to the value v. It panics if Value.CanSet returns false.\n    As in Go, x's value must be assignable to v's type and must not be derived\n    from an unexported field.\n\nfunc (v Value) SetBool(x bool)\n    SetBool sets v's underlying value. It panics if v's Kind is not Bool or if\n    Value.CanSet returns false.\n\nfunc (v Value) SetBytes(x []byte)\n    SetBytes sets v's underlying value. It panics if v's underlying value is not\n    a slice of bytes or if Value.CanSet returns false.\n\nfunc (v Value) SetCap(n int)\n    SetCap sets v's capacity to n. It panics if v's Kind is not Slice, or if\n    n is smaller than the length or greater than the capacity of the slice,\n    or if Value.CanSet returns false.\n\nfunc (v Value) SetComplex(x complex128)\n    SetComplex sets v's underlying value to x. It panics if v's Kind is not\n    Complex64 or Complex128, or if Value.CanSet returns false.\n\nfunc (v Value) SetFloat(x float64)\n    SetFloat sets v's underlying value to x. It panics if v's Kind is not\n    Float32 or Float64, or if Value.CanSet returns false.\n\nfunc (v Value) SetInt(x int64)\n    SetInt sets v's underlying value to x. It panics if v's Kind is not Int,\n    Int8, Int16, Int32, or Int64, or if Value.CanSet returns false.\n\nfunc (v Value) SetIterKey(iter *MapIter)\n    SetIterKey assigns to v the key of iter's current map entry. It is\n    equivalent to v.Set(iter.Key()), but it avoids allocating a new Value.\n    As in Go, the key must be assignable to v's type and must not be derived\n    from an unexported field. It panics if Value.CanSet returns false.\n\nfunc (v Value) SetIterValue(iter *MapIter)\n    SetIterValue assigns to v the value of iter's current map entry. It is\n    equivalent to v.Set(iter.Value()), but it avoids allocating a new Value.\n    As in Go, the value must be assignable to v's type and must not be derived\n    from an unexported field. It panics if Value.CanSet returns false.\n\nfunc (v Value) SetLen(n int)\n    SetLen sets v's length to n. It panics if v's Kind is not Slice, or if n\n    is negative or greater than the capacity of the slice, or if Value.CanSet\n    returns false.\n\nfunc (v Value) SetMapIndex(key, elem Value)\n    SetMapIndex sets the element associated with key in the map v to elem.\n    It panics if v's Kind is not Map. If elem is the zero Value, SetMapIndex\n    deletes the key from the map. Otherwise if v holds a nil map, SetMapIndex\n    will panic. As in Go, key's elem must be assignable to the map's key type,\n    and elem's value must be assignable to the map's elem type.\n\nfunc (v Value) SetPointer(x unsafe.Pointer)\n    SetPointer sets the unsafe.Pointer value v to x. It panics if v's Kind is\n    not UnsafePointer or if Value.CanSet returns false.\n\nfunc (v Value) SetString(x string)\n    SetString sets v's underlying value to x. It panics if v's Kind is not\n    String or if Value.CanSet returns false.\n\nfunc (v Value) SetUint(x uint64)\n    SetUint sets v's underlying value to x. It panics if v's Kind is not Uint,\n    Uintptr, Uint8, Uint16, Uint32, or Uint64, or if Value.CanSet returns false.\n\nfunc (v Value) SetZero()\n    SetZero sets v to be the zero value of v's type. It panics if Value.CanSet\n    returns false.\n\nfunc (v Value) Slice(i, j int) Value\n    Slice returns v[i:j]. It panics if v's Kind is not Array, Slice or String,\n    or if v is an unaddressable array, or if the indexes are out of bounds.\n\nfunc (v Value) Slice3(i, j, k int) Value\n    Slice3 is the 3-index form of the slice operation: it returns v[i:j:k]. It\n    panics if v's Kind is not Array or Slice, or if v is an unaddressable array,\n    or if the indexes are out of bounds.\n\nfunc (v Value) String() string\n    String returns the string v's underlying value, as a string. String is a\n    special case because of Go's String method convention. Unlike the other\n    getters, it does not panic if v's Kind is not String. Instead, it returns a\n    string of the form \"<T value>\" where T is v's type. The fmt package treats\n    Values specially. It does not call their String method implicitly but\n    instead prints the concrete values they hold.\n\nfunc (v Value) TryRecv() (x Value, ok bool)\n    TryRecv attempts to receive a value from the channel v but will not block.\n    It panics if v's Kind is not Chan. If the receive delivers a value, x is\n    the transferred value and ok is true. If the receive cannot finish without\n    blocking, x is the zero Value and ok is false. If the channel is closed,\n    x is the zero value for the channel's element type and ok is false.\n\nfunc (v Value) TrySend(x Value) bool\n    TrySend attempts to send x on the channel v but will not block. It panics\n    if v's Kind is not Chan. It reports whether the value was sent. As in Go,\n    x's value must be assignable to the channel's element type.\n\nfunc (v Value) Type() Type\n    Type returns v's type.\n\nfunc (v Value) Uint() uint64\n    Uint returns v's underlying value, as a uint64. It panics if v's Kind is not\n    Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.\n\nfunc (v Value) UnsafeAddr() uintptr\n    UnsafeAddr returns a pointer to v's data, as a uintptr. It panics if v is\n    not addressable.\n\n    It's preferred to use uintptr(Value.Addr().UnsafePointer()) to get the\n    equivalent result.\n\nfunc (v Value) UnsafePointer() unsafe.Pointer\n    UnsafePointer returns v's value as a unsafe.Pointer. It panics if v's Kind\n    is not Chan, Func, Map, Pointer, Slice, String or UnsafePointer.\n\n    If v's Kind is Func, the returned pointer is an underlying code pointer,\n    but not necessarily enough to identify a single function uniquely. The only\n    guarantee is that the result is zero if and only if v is a nil func Value.\n\n    If v's Kind is Slice, the returned pointer is to the first element of the\n    slice. If the slice is nil the returned value is nil. If the slice is empty\n    but non-nil the return value is non-nil.\n\n    If v's Kind is String, the returned pointer is to the first element of the\n    underlying bytes of string.\n\ntype ValueError struct {\n\tMethod string\n\tKind   Kind\n}\n    A ValueError occurs when a Value method is invoked on a Value that does not\n    support it. Such cases are documented in the description of each method.\n\nfunc (e *ValueError) Error() string\n\n\nBUG: FieldByName and related functions consider struct field names to be equal\nif the names are equal, even if they are unexported names originating\nin different packages. The practical effect of this is that the result of\nt.FieldByName(\"x\") is not well defined if the struct type t contains\nmultiple fields named x (embedded from different packages).\nFieldByName may return one of the fields named x or may report that there are none.\nSee https://golang.org/issue/4876 for more details.\n\n"}, {"path": "stdlib/crypto-sha256.md", "category": "stdlib", "name": "stdlib/crypto-sha256", "content": "package sha256 // import \"crypto/sha256\"\n\nPackage sha256 implements the SHA224 and SHA256 hash algorithms as defined in\nFIPS 180-4.\n\nCONSTANTS\n\nconst BlockSize = 64\n    The blocksize of SHA256 and SHA224 in bytes.\n\nconst Size = 32\n    The size of a SHA256 checksum in bytes.\n\nconst Size224 = 28\n    The size of a SHA224 checksum in bytes.\n\n\nFUNCTIONS\n\nfunc New() hash.Hash\n    New returns a new hash.Hash computing the SHA256 checksum. The Hash\n    also implements encoding.BinaryMarshaler, encoding.BinaryAppender and\n    encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of\n    the hash.\n\nfunc New224() hash.Hash\n    New224 returns a new hash.Hash computing the SHA224 checksum. The Hash\n    also implements encoding.BinaryMarshaler, encoding.BinaryAppender and\n    encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of\n    the hash.\n\nfunc Sum224(data []byte) [Size224]byte\n    Sum224 returns the SHA224 checksum of the data.\n\nfunc Sum256(data []byte) [Size]byte\n    Sum256 returns the SHA256 checksum of the data.\n\n"}, {"path": "stdlib/internal-coverage-calloc.md", "category": "stdlib", "name": "stdlib/internal-coverage-calloc", "content": "package calloc // import \"internal/coverage/calloc\"\n\n\nTYPES\n\ntype BatchCounterAlloc struct {\n\t// Has unexported fields.\n}\n\nfunc (ca *BatchCounterAlloc) AllocateCounters(n int) []uint32\n\n"}, {"path": "stdlib/testing-internal-testdeps.md", "category": "stdlib", "name": "stdlib/testing-internal-testdeps", "content": "package testdeps // import \"testing/internal/testdeps\"\n\nPackage testdeps provides access to dependencies needed by test execution.\n\nThis package is imported by the generated main package, which passes TestDeps\ninto testing.Main. This allows tests to use packages at run time without making\nthose packages direct dependencies of package testing. Direct dependencies of\npackage testing are harder to write tests for.\n\nVARIABLES\n\nvar (\n\tCoverSnapshotFunc           func() float64\n\tCoverProcessTestDirFunc     func(dir string, cfile string, cm string, cpkg string, w io.Writer, selpkgs []string) error\n\tCoverMarkProfileEmittedFunc func(val bool)\n)\n    These variables below are set at runtime (via code in testmain) to point to\n    the equivalent functions in package internal/coverage/cfile; doing things\n    this way allows us to have tests import internal/coverage/cfile only when\n    -cover is in effect (as opposed to importing for all tests).\n\nvar Cover bool\n    Cover indicates whether coverage is enabled.\n\nvar CoverMode string\nvar CoverSelectedPackages []string\nvar Covered string\nvar ImportPath string\n    ImportPath is the import path of the testing binary, set by the generated\n    main function.\n\n\nTYPES\n\ntype TestDeps struct{}\n    TestDeps is an implementation of the testing.testDeps interface, suitable\n    for passing to testing.MainStart.\n\nfunc (TestDeps) CheckCorpus(vals []any, types []reflect.Type) error\n\nfunc (TestDeps) CoordinateFuzzing(\n\ttimeout time.Duration,\n\tlimit int64,\n\tminimizeTimeout time.Duration,\n\tminimizeLimit int64,\n\tparallel int,\n\tseed []fuzz.CorpusEntry,\n\ttypes []reflect.Type,\n\tcorpusDir,\n\tcacheDir string) (err error)\n\nfunc (TestDeps) ImportPath() string\n\nfunc (TestDeps) InitRuntimeCoverage() (mode string, tearDown func(string, string) (string, error), snapcov func() float64)\n\nfunc (TestDeps) MatchString(pat, str string) (result bool, err error)\n\nfunc (TestDeps) ReadCorpus(dir string, types []reflect.Type) ([]fuzz.CorpusEntry, error)\n\nfunc (TestDeps) ResetCoverage()\n\nfunc (TestDeps) RunFuzzWorker(fn func(fuzz.CorpusEntry) error) error\n\nfunc (TestDeps) SetPanicOnExit0(v bool)\n    SetPanicOnExit0 tells the os package whether to panic on os.Exit(0).\n\nfunc (TestDeps) SnapshotCoverage()\n\nfunc (TestDeps) StartCPUProfile(w io.Writer) error\n\nfunc (TestDeps) StartTestLog(w io.Writer)\n\nfunc (TestDeps) StopCPUProfile()\n\nfunc (TestDeps) StopTestLog() error\n\nfunc (TestDeps) WriteProfileTo(name string, w io.Writer, debug int) error\n\n"}, {"path": "stdlib/crypto-md5.md", "category": "stdlib", "name": "stdlib/crypto-md5", "content": "package md5 // import \"crypto/md5\"\n\nPackage md5 implements the MD5 hash algorithm as defined in RFC 1321.\n\nMD5 is cryptographically broken and should not be used for secure applications.\n\nCONSTANTS\n\nconst BlockSize = 64\n    The blocksize of MD5 in bytes.\n\nconst Size = 16\n    The size of an MD5 checksum in bytes.\n\n\nFUNCTIONS\n\nfunc New() hash.Hash\n    New returns a new hash.Hash computing the MD5 checksum. The Hash\n    also implements encoding.BinaryMarshaler, encoding.BinaryAppender and\n    encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of\n    the hash.\n\nfunc Sum(data []byte) [Size]byte\n    Sum returns the MD5 checksum of the data.\n\n"}, {"path": "stdlib/net-http.md", "category": "stdlib", "name": "stdlib/net-http", "content": "package http // import \"net/http\"\n\nPackage http provides HTTP client and server implementations.\n\nGet, Head, Post, and PostForm make HTTP (or HTTPS) requests:\n\n    resp, err := http.Get(\"http://example.com/\")\n    ...\n    resp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", &buf)\n    ...\n    resp, err := http.PostForm(\"http://example.com/form\",\n    \turl.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}})\n\nThe caller must close the response body when finished with it:\n\n    resp, err := http.Get(\"http://example.com/\")\n    if err != nil {\n    \t// handle error\n    }\n    defer resp.Body.Close()\n    body, err := io.ReadAll(resp.Body)\n    // ...\n\n# Clients and Transports\n\nFor control over HTTP client headers, redirect policy, and other settings,\ncreate a Client:\n\n    client := &http.Client{\n    \tCheckRedirect: redirectPolicyFunc,\n    }\n\n    resp, err := client.Get(\"http://example.com\")\n    // ...\n\n    req, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n    // ...\n    req.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\n    resp, err := client.Do(req)\n    // ...\n\nFor control over proxies, TLS configuration, keep-alives, compression, and other\nsettings, create a Transport:\n\n    tr := &http.Transport{\n    \tMaxIdleConns:       10,\n    \tIdleConnTimeout:    30 * time.Second,\n    \tDisableCompression: true,\n    }\n    client := &http.Client{Transport: tr}\n    resp, err := client.Get(\"https://example.com\")\n\nClients and Transports are safe for concurrent use by multiple goroutines and\nfor efficiency should only be created once and re-used.\n\n# Servers\n\nListenAndServe starts an HTTP server with a given address and handler.\nThe handler is usually nil, which means to use DefaultServeMux. Handle and\nHandleFunc add handlers to DefaultServeMux:\n\n    http.Handle(\"/foo\", fooHandler)\n\n    http.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n    \tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n    })\n\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n\nMore control over the server's behavior is available by creating a custom\nServer:\n\n    s := &http.Server{\n    \tAddr:           \":8080\",\n    \tHandler:        myHandler,\n    \tReadTimeout:    10 * time.Second,\n    \tWriteTimeout:   10 * time.Second,\n    \tMaxHeaderBytes: 1 << 20,\n    }\n    log.Fatal(s.ListenAndServe())\n\n# HTTP/2\n\nStarting with Go 1.6, the http package has transparent support for the HTTP/2\nprotocol when using HTTPS. Programs that must disable HTTP/2 can do so by\nsetting [Transport.TLSNextProto] (for clients) or [Server.TLSNextProto] (for\nservers) to a non-nil, empty map. Alternatively, the following GODEBUG settings\nare currently supported:\n\n    GODEBUG=http2client=0  # disable HTTP/2 client support\n    GODEBUG=http2server=0  # disable HTTP/2 server support\n    GODEBUG=http2debug=1   # enable verbose HTTP/2 debug logs\n    GODEBUG=http2debug=2   # ... even more verbose, with frame dumps\n\nPlease report any issues before disabling HTTP/2 support:\nhttps://golang.org/s/http2bug\n\nThe http package's Transport and Server both automatically enable HTTP/2 support\nfor simple configurations. To enable HTTP/2 for more complex configurations,\nto use lower-level HTTP/2 features, or to use a newer version of Go's http2\npackage, import \"golang.org/x/net/http2\" directly and use its ConfigureTransport\nand/or ConfigureServer functions. Manually configuring HTTP/2 via the\ngolang.org/x/net/http2 package takes precedence over the net/http package's\nbuilt-in HTTP/2 support.\n\nCONSTANTS\n\nconst (\n\tMethodGet     = \"GET\"\n\tMethodHead    = \"HEAD\"\n\tMethodPost    = \"POST\"\n\tMethodPut     = \"PUT\"\n\tMethodPatch   = \"PATCH\" // RFC 5789\n\tMethodDelete  = \"DELETE\"\n\tMethodConnect = \"CONNECT\"\n\tMethodOptions = \"OPTIONS\"\n\tMethodTrace   = \"TRACE\"\n)\n    Common HTTP methods.\n\n    Unless otherwise noted, these are defined in RFC 7231 section 4.3.\n\nconst (\n\tStatusContinue           = 100 // RFC 9110, 15.2.1\n\tStatusSwitchingProtocols = 101 // RFC 9110, 15.2.2\n\tStatusProcessing         = 102 // RFC 2518, 10.1\n\tStatusEarlyHints         = 103 // RFC 8297\n\n\tStatusOK                   = 200 // RFC 9110, 15.3.1\n\tStatusCreated              = 201 // RFC 9110, 15.3.2\n\tStatusAccepted             = 202 // RFC 9110, 15.3.3\n\tStatusNonAuthoritativeInfo = 203 // RFC 9110, 15.3.4\n\tStatusNoContent            = 204 // RFC 9110, 15.3.5\n\tStatusResetContent         = 205 // RFC 9110, 15.3.6\n\tStatusPartialContent       = 206 // RFC 9110, 15.3.7\n\tStatusMultiStatus          = 207 // RFC 4918, 11.1\n\tStatusAlreadyReported      = 208 // RFC 5842, 7.1\n\tStatusIMUsed               = 226 // RFC 3229, 10.4.1\n\n\tStatusMultipleChoices  = 300 // RFC 9110, 15.4.1\n\tStatusMovedPermanently = 301 // RFC 9110, 15.4.2\n\tStatusFound            = 302 // RFC 9110, 15.4.3\n\tStatusSeeOther         = 303 // RFC 9110, 15.4.4\n\tStatusNotModified      = 304 // RFC 9110, 15.4.5\n\tStatusUseProxy         = 305 // RFC 9110, 15.4.6\n\n\tStatusTemporaryRedirect = 307 // RFC 9110, 15.4.8\n\tStatusPermanentRedirect = 308 // RFC 9110, 15.4.9\n\n\tStatusBadRequest                   = 400 // RFC 9110, 15.5.1\n\tStatusUnauthorized                 = 401 // RFC 9110, 15.5.2\n\tStatusPaymentRequired              = 402 // RFC 9110, 15.5.3\n\tStatusForbidden                    = 403 // RFC 9110, 15.5.4\n\tStatusNotFound                     = 404 // RFC 9110, 15.5.5\n\tStatusMethodNotAllowed             = 405 // RFC 9110, 15.5.6\n\tStatusNotAcceptable                = 406 // RFC 9110, 15.5.7\n\tStatusProxyAuthRequired            = 407 // RFC 9110, 15.5.8\n\tStatusRequestTimeout               = 408 // RFC 9110, 15.5.9\n\tStatusConflict                     = 409 // RFC 9110, 15.5.10\n\tStatusGone                         = 410 // RFC 9110, 15.5.11\n\tStatusLengthRequired               = 411 // RFC 9110, 15.5.12\n\tStatusPreconditionFailed           = 412 // RFC 9110, 15.5.13\n\tStatusRequestEntityTooLarge        = 413 // RFC 9110, 15.5.14\n\tStatusRequestURITooLong            = 414 // RFC 9110, 15.5.15\n\tStatusUnsupportedMediaType         = 415 // RFC 9110, 15.5.16\n\tStatusRequestedRangeNotSatisfiable = 416 // RFC 9110, 15.5.17\n\tStatusExpectationFailed            = 417 // RFC 9110, 15.5.18\n\tStatusTeapot                       = 418 // RFC 9110, 15.5.19 (Unused)\n\tStatusMisdirectedRequest           = 421 // RFC 9110, 15.5.20\n\tStatusUnprocessableEntity          = 422 // RFC 9110, 15.5.21\n\tStatusLocked                       = 423 // RFC 4918, 11.3\n\tStatusFailedDependency             = 424 // RFC 4918, 11.4\n\tStatusTooEarly                     = 425 // RFC 8470, 5.2.\n\tStatusUpgradeRequired              = 426 // RFC 9110, 15.5.22\n\tStatusPreconditionRequired         = 428 // RFC 6585, 3\n\tStatusTooManyRequests              = 429 // RFC 6585, 4\n\tStatusRequestHeaderFieldsTooLarge  = 431 // RFC 6585, 5\n\tStatusUnavailableForLegalReasons   = 451 // RFC 7725, 3\n\n\tStatusInternalServerError           = 500 // RFC 9110, 15.6.1\n\tStatusNotImplemented                = 501 // RFC 9110, 15.6.2\n\tStatusBadGateway                    = 502 // RFC 9110, 15.6.3\n\tStatusServiceUnavailable            = 503 // RFC 9110, 15.6.4\n\tStatusGatewayTimeout                = 504 // RFC 9110, 15.6.5\n\tStatusHTTPVersionNotSupported       = 505 // RFC 9110, 15.6.6\n\tStatusVariantAlsoNegotiates         = 506 // RFC 2295, 8.1\n\tStatusInsufficientStorage           = 507 // RFC 4918, 11.5\n\tStatusLoopDetected                  = 508 // RFC 5842, 7.2\n\tStatusNotExtended                   = 510 // RFC 2774, 7\n\tStatusNetworkAuthenticationRequired = 511 // RFC 6585, 6\n)\n    HTTP status codes as registered with IANA. See:\n    https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n\nconst DefaultMaxHeaderBytes = 1 << 20 // 1 MB\n    DefaultMaxHeaderBytes is the maximum permitted size of the headers in an\n    HTTP request. This can be overridden by setting [Server.MaxHeaderBytes].\n\nconst DefaultMaxIdleConnsPerHost = 2\n    DefaultMaxIdleConnsPerHost is the default value of Transport's\n    MaxIdleConnsPerHost.\n\nconst TimeFormat = \"Mon, 02 Jan 2006 15:04:05 GMT\"\n    TimeFormat is the time format to use when generating times in HTTP headers.\n    It is like time.RFC1123 but hard-codes GMT as the time zone. The time being\n    formatted must be in UTC for Format to generate the correct format.\n\n    For parsing this time format, see ParseTime.\n\nconst TrailerPrefix = \"Trailer:\"\n    TrailerPrefix is a magic prefix for [ResponseWriter.Header] map keys that,\n    if present, signals that the map entry is actually for the response\n    trailers, and not the response headers. The prefix is stripped after the\n    ServeHTTP call finishes and the values are sent in the trailers.\n\n    This mechanism is intended only for trailers that are not known prior to the\n    headers being written. If the set of trailers is fixed or known before the\n    header is written, the normal Go trailers mechanism is preferred:\n\n        https://pkg.go.dev/net/http#ResponseWriter\n        https://pkg.go.dev/net/http#example-ResponseWriter-Trailers\n\n\nVARIABLES\n\nvar (\n\t// ErrNotSupported indicates that a feature is not supported.\n\t//\n\t// It is returned by ResponseController methods to indicate that\n\t// the handler does not support the method, and by the Push method\n\t// of Pusher implementations to indicate that HTTP/2 Push support\n\t// is not available.\n\tErrNotSupported = &ProtocolError{\"feature not supported\"}\n\n\t// Deprecated: ErrUnexpectedTrailer is no longer returned by\n\t// anything in the net/http package. Callers should not\n\t// compare errors against this variable.\n\tErrUnexpectedTrailer = &ProtocolError{\"trailer header without chunked transfer encoding\"}\n\n\t// ErrMissingBoundary is returned by Request.MultipartReader when the\n\t// request's Content-Type does not include a \"boundary\" parameter.\n\tErrMissingBoundary = &ProtocolError{\"no multipart boundary param in Content-Type\"}\n\n\t// ErrNotMultipart is returned by Request.MultipartReader when the\n\t// request's Content-Type is not multipart/form-data.\n\tErrNotMultipart = &ProtocolError{\"request Content-Type isn't multipart/form-data\"}\n\n\t// Deprecated: ErrHeaderTooLong is no longer returned by\n\t// anything in the net/http package. Callers should not\n\t// compare errors against this variable.\n\tErrHeaderTooLong = &ProtocolError{\"header too long\"}\n\n\t// Deprecated: ErrShortBody is no longer returned by\n\t// anything in the net/http package. Callers should not\n\t// compare errors against this variable.\n\tErrShortBody = &ProtocolError{\"entity body too short\"}\n\n\t// Deprecated: ErrMissingContentLength is no longer returned by\n\t// anything in the net/http package. Callers should not\n\t// compare errors against this variable.\n\tErrMissingContentLength = &ProtocolError{\"missing ContentLength in HEAD response\"}\n)\nvar (\n\t// ErrBodyNotAllowed is returned by ResponseWriter.Write calls\n\t// when the HTTP method or response code does not permit a\n\t// body.\n\tErrBodyNotAllowed = errors.New(\"http: request method or response status code does not allow body\")\n\n\t// ErrHijacked is returned by ResponseWriter.Write calls when\n\t// the underlying connection has been hijacked using the\n\t// Hijacker interface. A zero-byte write on a hijacked\n\t// connection will return ErrHijacked without any other side\n\t// effects.\n\tErrHijacked = errors.New(\"http: connection has been hijacked\")\n\n\t// ErrContentLength is returned by ResponseWriter.Write calls\n\t// when a Handler set a Content-Length response header with a\n\t// declared size and then attempted to write more bytes than\n\t// declared.\n\tErrContentLength = errors.New(\"http: wrote more than the declared Content-Length\")\n\n\t// Deprecated: ErrWriteAfterFlush is no longer returned by\n\t// anything in the net/http package. Callers should not\n\t// compare errors against this variable.\n\tErrWriteAfterFlush = errors.New(\"unused\")\n)\n    Errors used by the HTTP server.\n\nvar (\n\t// ServerContextKey is a context key. It can be used in HTTP\n\t// handlers with Context.Value to access the server that\n\t// started the handler. The associated value will be of\n\t// type *Server.\n\tServerContextKey = &contextKey{\"http-server\"}\n\n\t// LocalAddrContextKey is a context key. It can be used in\n\t// HTTP handlers with Context.Value to access the local\n\t// address the connection arrived on.\n\t// The associated value will be of type net.Addr.\n\tLocalAddrContextKey = &contextKey{\"local-addr\"}\n)\nvar DefaultClient = &Client{}\n    DefaultClient is the default Client and is used by Get, Head, and Post.\n\nvar DefaultServeMux = &defaultServeMux\n    DefaultServeMux is the default ServeMux used by Serve.\n\nvar ErrAbortHandler = errors.New(\"net/http: abort Handler\")\n    ErrAbortHandler is a sentinel panic value to abort a handler. While any\n    panic from ServeHTTP aborts the response to the client, panicking with\n    ErrAbortHandler also suppresses logging of a stack trace to the server's\n    error log.\n\nvar ErrBodyReadAfterClose = errors.New(\"http: invalid Read on closed Body\")\n    ErrBodyReadAfterClose is returned when reading a Request or Response Body\n    after the body has been closed. This typically happens when the body is read\n    after an HTTP Handler calls WriteHeader or Write on its ResponseWriter.\n\nvar ErrHandlerTimeout = errors.New(\"http: Handler timeout\")\n    ErrHandlerTimeout is returned on ResponseWriter Write calls in handlers\n    which have timed out.\n\nvar ErrLineTooLong = internal.ErrLineTooLong\n    ErrLineTooLong is returned when reading request or response bodies with\n    malformed chunked encoding.\n\nvar ErrMissingFile = errors.New(\"http: no such file\")\n    ErrMissingFile is returned by FormFile when the provided file field name is\n    either not present in the request or not a file field.\n\nvar ErrNoCookie = errors.New(\"http: named cookie not present\")\n    ErrNoCookie is returned by Request's Cookie method when a cookie is not\n    found.\n\nvar ErrNoLocation = errors.New(\"http: no Location header in response\")\n    ErrNoLocation is returned by the Response.Location method when no Location\n    header is present.\n\nvar ErrSchemeMismatch = errors.New(\"http: server gave HTTP response to HTTPS client\")\n    ErrSchemeMismatch is returned when a server returns an HTTP response to an\n    HTTPS client.\n\nvar ErrServerClosed = errors.New(\"http: Server closed\")\n    ErrServerClosed is returned by the Server.Serve, ServeTLS, ListenAndServe,\n    and ListenAndServeTLS methods after a call to Server.Shutdown or\n    Server.Close.\n\nvar ErrSkipAltProtocol = errors.New(\"net/http: skip alternate protocol\")\n    ErrSkipAltProtocol is a sentinel error value defined by\n    Transport.RegisterProtocol.\n\nvar ErrUseLastResponse = errors.New(\"net/http: use last response\")\n    ErrUseLastResponse can be returned by Client.CheckRedirect hooks to control\n    how redirects are processed. If returned, the next request is not sent and\n    the most recent response is returned with its body unclosed.\n\nvar NoBody = noBody{}\n    NoBody is an io.ReadCloser with no bytes. Read always returns EOF and\n    Close always returns nil. It can be used in an outgoing client request to\n    explicitly signal that a request has zero bytes. An alternative, however,\n    is to simply set [Request.Body] to nil.\n\n\nFUNCTIONS\n\nfunc CanonicalHeaderKey(s string) string\n    CanonicalHeaderKey returns the canonical format of the header key s.\n    The canonicalization converts the first letter and any letter following a\n    hyphen to upper case; the rest are converted to lowercase. For example,\n    the canonical key for \"accept-encoding\" is \"Accept-Encoding\". If s contains\n    a space or invalid header field bytes, it is returned without modifications.\n\nfunc DetectContentType(data []byte) string\n    DetectContentType implements the algorithm described at\n    https://mimesniff.spec.whatwg.org/ to determine the Content-Type of\n    the given data. It considers at most the first 512 bytes of data.\n    DetectContentType always returns a valid MIME type: if it cannot determine a\n    more specific one, it returns \"application/octet-stream\".\n\nfunc Error(w ResponseWriter, error string, code int)\n    Error replies to the request with the specified error message and HTTP code.\n    It does not otherwise end the request; the caller should ensure no further\n    writes are done to w. The error message should be plain text.\n\n    Error deletes the Content-Length header, sets Content-Type to \u201ctext/plain;\n    charset=utf-8\u201d, and sets X-Content-Type-Options to \u201cnosniff\u201d. This\n    configures the header properly for the error message, in case the caller had\n    set it up expecting a successful output.\n\nfunc Get(url string) (resp *Response, err error)\n    Get issues a GET to the specified URL. If the response is one of the\n    following redirect codes, Get follows the redirect, up to a maximum of 10\n    redirects:\n\n        301 (Moved Permanently)\n        302 (Found)\n        303 (See Other)\n        307 (Temporary Redirect)\n        308 (Permanent Redirect)\n\n    An error is returned if there were too many redirects or if there was an\n    HTTP protocol error. A non-2xx response doesn't cause an error. Any returned\n    error will be of type *url.Error. The url.Error value's Timeout method will\n    report true if the request timed out.\n\n    When err is nil, resp always contains a non-nil resp.Body. Caller should\n    close resp.Body when done reading from it.\n\n    Get is a wrapper around DefaultClient.Get.\n\n    To make a request with custom headers, use NewRequest and DefaultClient.Do.\n\n    To make a request with a specified context.Context, use\n    NewRequestWithContext and DefaultClient.Do.\n\nfunc Handle(pattern string, handler Handler)\n    Handle registers the handler for the given pattern in DefaultServeMux.\n    The documentation for ServeMux explains how patterns are matched.\n\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request))\n    HandleFunc registers the handler function for the given pattern in\n    DefaultServeMux. The documentation for ServeMux explains how patterns are\n    matched.\n\nfunc Head(url string) (resp *Response, err error)\n    Head issues a HEAD to the specified URL. If the response is one of the\n    following redirect codes, Head follows the redirect, up to a maximum of 10\n    redirects:\n\n        301 (Moved Permanently)\n        302 (Found)\n        303 (See Other)\n        307 (Temporary Redirect)\n        308 (Permanent Redirect)\n\n    Head is a wrapper around DefaultClient.Head.\n\n    To make a request with a specified context.Context, use\n    NewRequestWithContext and DefaultClient.Do.\n\nfunc ListenAndServe(addr string, handler Handler) error\n    ListenAndServe listens on the TCP network address addr and then calls\n    Serve with handler to handle requests on incoming connections. Accepted\n    connections are configured to enable TCP keep-alives.\n\n    The handler is typically nil, in which case DefaultServeMux is used.\n\n    ListenAndServe always returns a non-nil error.\n\nfunc ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error\n    ListenAndServeTLS acts identically to ListenAndServe, except that it expects\n    HTTPS connections. Additionally, files containing a certificate and matching\n    private key for the server must be provided. If the certificate is signed\n    by a certificate authority, the certFile should be the concatenation of the\n    server's certificate, any intermediates, and the CA's certificate.\n\nfunc MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser\n    MaxBytesReader is similar to io.LimitReader but is intended for limiting\n    the size of incoming request bodies. In contrast to io.LimitReader,\n    MaxBytesReader's result is a ReadCloser, returns a non-nil error of type\n    *MaxBytesError for a Read beyond the limit, and closes the underlying reader\n    when its Close method is called.\n\n    MaxBytesReader prevents clients from accidentally or maliciously sending\n    a large request and wasting server resources. If possible, it tells the\n    ResponseWriter to close the connection after the limit has been reached.\n\nfunc NewRequest(method, url string, body io.Reader) (*Request, error)\n    NewRequest wraps NewRequestWithContext using context.Background.\n\nfunc NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error)\n    NewRequestWithContext returns a new Request given a method, URL, and\n    optional body.\n\n    If the provided body is also an io.Closer, the returned [Request.Body]\n    is set to body and will be closed (possibly asynchronously) by the Client\n    methods Do, Post, and PostForm, and Transport.RoundTrip.\n\n    NewRequestWithContext returns a Request suitable for use with Client.Do\n    or Transport.RoundTrip. To create a request for use with testing a\n    Server Handler, either use the net/http/httptest.NewRequest function,\n    use ReadRequest, or manually update the Request fields. For an outgoing\n    client request, the context controls the entire lifetime of a request and\n    its response: obtaining a connection, sending the request, and reading the\n    response headers and body. See the Request type's documentation for the\n    difference between inbound and outbound request fields.\n\n    If body is of type *bytes.Buffer, *bytes.Reader, or *strings.Reader,\n    the returned request's ContentLength is set to its exact value (instead of\n    -1), GetBody is populated (so 307 and 308 redirects can replay the body),\n    and Body is set to NoBody if the ContentLength is 0.\n\nfunc NotFound(w ResponseWriter, r *Request)\n    NotFound replies to the request with an HTTP 404 not found error.\n\nfunc ParseCookie(line string) ([]*Cookie, error)\n    ParseCookie parses a Cookie header value and returns all the cookies which\n    were set in it. Since the same cookie name can appear multiple times the\n    returned Values can contain more than one value for a given key.\n\nfunc ParseHTTPVersion(vers string) (major, minor int, ok bool)\n    ParseHTTPVersion parses an HTTP version string according to RFC 7230,\n    section 2.6. \"HTTP/1.0\" returns (1, 0, true). Note that strings without a\n    minor version, such as \"HTTP/2\", are not valid.\n\nfunc ParseSetCookie(line string) (*Cookie, error)\n    ParseSetCookie parses a Set-Cookie header value and returns a cookie.\n    It returns an error on syntax error.\n\nfunc ParseTime(text string) (t time.Time, err error)\n    ParseTime parses a time header (such as the Date: header), trying each\n    of the three formats allowed by HTTP/1.1: TimeFormat, time.RFC850,\n    and time.ANSIC.\n\nfunc Post(url, contentType string, body io.Reader) (resp *Response, err error)\n    Post issues a POST to the specified URL.\n\n    Caller should close resp.Body when done reading from it.\n\n    If the provided body is an io.Closer, it is closed after the request.\n\n    Post is a wrapper around DefaultClient.Post.\n\n    To set custom headers, use NewRequest and DefaultClient.Do.\n\n    See the Client.Do method documentation for details on how redirects are\n    handled.\n\n    To make a request with a specified context.Context, use\n    NewRequestWithContext and DefaultClient.Do.\n\nfunc PostForm(url string, data url.Values) (resp *Response, err error)\n    PostForm issues a POST to the specified URL, with data's keys and values\n    URL-encoded as the request body.\n\n    The Content-Type header is set to application/x-www-form-urlencoded.\n    To set other headers, use NewRequest and DefaultClient.Do.\n\n    When err is nil, resp always contains a non-nil resp.Body. Caller should\n    close resp.Body when done reading from it.\n\n    PostForm is a wrapper around DefaultClient.PostForm.\n\n    See the Client.Do method documentation for details on how redirects are\n    handled.\n\n    To make a request with a specified context.Context, use\n    NewRequestWithContext and DefaultClient.Do.\n\nfunc ProxyFromEnvironment(req *Request) (*url.URL, error)\n    ProxyFromEnvironment returns the URL of the proxy to use for a given\n    request, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY\n    and NO_PROXY (or the lowercase versions thereof). Requests use the proxy\n    from the environment variable matching their scheme, unless excluded by\n    NO_PROXY.\n\n    The environment values may be either a complete URL or a \"host[:port]\",\n    in which case the \"http\" scheme is assumed. An error is returned if the\n    value is a different form.\n\n    A nil URL and nil error are returned if no proxy is defined in the\n    environment, or a proxy should not be used for the given request, as defined\n    by NO_PROXY.\n\n    As a special case, if req.URL.Host is \"localhost\" (with or without a port\n    number), then a nil URL and nil error will be returned.\n\nfunc ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)\n    ProxyURL returns a proxy function (for use in a Transport) that always\n    returns the same URL.\n\nfunc ReadRequest(b *bufio.Reader) (*Request, error)\n    ReadRequest reads and parses an incoming request from b.\n\n    ReadRequest is a low-level function and should only be used for specialized\n    applications; most code should use the Server to read requests and handle\n    them via the Handler interface. ReadRequest only supports HTTP/1.x requests.\n    For HTTP/2, use golang.org/x/net/http2.\n\nfunc ReadResponse(r *bufio.Reader, req *Request) (*Response, error)\n    ReadResponse reads and returns an HTTP response from r. The req parameter\n    optionally specifies the Request that corresponds to this Response. If nil,\n    a GET request is assumed. Clients must call resp.Body.Close when finished\n    reading resp.Body. After that call, clients can inspect resp.Trailer to find\n    key/value pairs included in the response trailer.\n\nfunc Redirect(w ResponseWriter, r *Request, url string, code int)\n    Redirect replies to the request with a redirect to url, which may be a\n    path relative to the request path. Any non-ASCII characters in url will be\n    percent-encoded, but existing percent encodings will not be changed.\n\n    The provided code should be in the 3xx range and is usually\n    StatusMovedPermanently, StatusFound or StatusSeeOther.\n\n    If the Content-Type header has not been set, Redirect sets it to \"text/html;\n    charset=utf-8\" and writes a small HTML body. Setting the Content-Type header\n    to any value, including nil, disables that behavior.\n\nfunc Serve(l net.Listener, handler Handler) error\n    Serve accepts incoming HTTP connections on the listener l, creating a new\n    service goroutine for each. The service goroutines read requests and then\n    call handler to reply to them.\n\n    The handler is typically nil, in which case DefaultServeMux is used.\n\n    HTTP/2 support is only enabled if the Listener returns *tls.Conn connections\n    and they were configured with \"h2\" in the TLS Config.NextProtos.\n\n    Serve always returns a non-nil error.\n\nfunc ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)\n    ServeContent replies to the request using the content in the provided\n    ReadSeeker. The main benefit of ServeContent over io.Copy is that it\n    handles Range requests properly, sets the MIME type, and handles If-Match,\n    If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range\n    requests.\n\n    If the response's Content-Type header is not set, ServeContent first\n    tries to deduce the type from name's file extension and, if that fails,\n    falls back to reading the first block of the content and passing it to\n    DetectContentType. The name is otherwise unused; in particular it can be\n    empty and is never sent in the response.\n\n    If modtime is not the zero time or Unix epoch, ServeContent includes it\n    in a Last-Modified header in the response. If the request includes an\n    If-Modified-Since header, ServeContent uses modtime to decide whether the\n    content needs to be sent at all.\n\n    The content's Seek method must work: ServeContent uses a seek to the end\n    of the content to determine its size. Note that *os.File implements the\n    io.ReadSeeker interface.\n\n    If the caller has set w's ETag header formatted per RFC 7232, section 2.3,\n    ServeContent uses it to handle requests using If-Match, If-None-Match,\n    or If-Range.\n\n    If an error occurs when serving the request (for example, when handling\n    an invalid range request), ServeContent responds with an error message.\n    By default, ServeContent strips the Cache-Control, Content-Encoding,\n    ETag, and Last-Modified headers from error responses. The GODEBUG setting\n    httpservecontentkeepheaders=1 causes ServeContent to preserve these headers.\n\nfunc ServeFile(w ResponseWriter, r *Request, name string)\n    ServeFile replies to the request with the contents of the named file or\n    directory.\n\n    If the provided file or directory name is a relative path, it is interpreted\n    relative to the current directory and may ascend to parent directories.\n    If the provided name is constructed from user input, it should be sanitized\n    before calling ServeFile.\n\n    As a precaution, ServeFile will reject requests where r.URL.Path contains\n    a \"..\" path element; this protects against callers who might unsafely\n    use filepath.Join on r.URL.Path without sanitizing it and then use that\n    filepath.Join result as the name argument.\n\n    As another special case, ServeFile redirects any request where r.URL.Path\n    ends in \"/index.html\" to the same path, without the final \"index.html\".\n    To avoid such redirects either modify the path or use ServeContent.\n\n    Outside of those two special cases, ServeFile does not use r.URL.Path\n    for selecting the file or directory to serve; only the file or directory\n    provided in the name argument is used.\n\nfunc ServeFileFS(w ResponseWriter, r *Request, fsys fs.FS, name string)\n    ServeFileFS replies to the request with the contents of the named file\n    or directory from the file system fsys. The files provided by fsys must\n    implement io.Seeker.\n\n    If the provided name is constructed from user input, it should be sanitized\n    before calling ServeFileFS.\n\n    As a precaution, ServeFileFS will reject requests where r.URL.Path contains\n    a \"..\" path element; this protects against callers who might unsafely\n    use filepath.Join on r.URL.Path without sanitizing it and then use that\n    filepath.Join result as the name argument.\n\n    As another special case, ServeFileFS redirects any request where r.URL.Path\n    ends in \"/index.html\" to the same path, without the final \"index.html\".\n    To avoid such redirects either modify the path or use ServeContent.\n\n    Outside of those two special cases, ServeFileFS does not use r.URL.Path\n    for selecting the file or directory to serve; only the file or directory\n    provided in the name argument is used.\n\nfunc ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error\n    ServeTLS accepts incoming HTTPS connections on the listener l, creating a\n    new service goroutine for each. The service goroutines read requests and\n    then call handler to reply to them.\n\n    The handler is typically nil, in which case DefaultServeMux is used.\n\n    Additionally, files containing a certificate and matching private key for\n    the server must be provided. If the certificate is signed by a certificate\n    authority, the certFile should be the concatenation of the server's\n    certificate, any intermediates, and the CA's certificate.\n\n    ServeTLS always returns a non-nil error.\n\nfunc SetCookie(w ResponseWriter, cookie *Cookie)\n    SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\n    The provided cookie must have a valid Name. Invalid cookies may be silently\n    dropped.\n\nfunc StatusText(code int) string\n    StatusText returns a text for the HTTP status code. It returns the empty\n    string if the code is unknown.\n\n\nTYPES\n\ntype Client struct {\n\t// Transport specifies the mechanism by which individual\n\t// HTTP requests are made.\n\t// If nil, DefaultTransport is used.\n\tTransport RoundTripper\n\n\t// CheckRedirect specifies the policy for handling redirects.\n\t// If CheckRedirect is not nil, the client calls it before\n\t// following an HTTP redirect. The arguments req and via are\n\t// the upcoming request and the requests made already, oldest\n\t// first. If CheckRedirect returns an error, the Client's Get\n\t// method returns both the previous Response (with its Body\n\t// closed) and CheckRedirect's error (wrapped in a url.Error)\n\t// instead of issuing the Request req.\n\t// As a special case, if CheckRedirect returns ErrUseLastResponse,\n\t// then the most recent response is returned with its body\n\t// unclosed, along with a nil error.\n\t//\n\t// If CheckRedirect is nil, the Client uses its default policy,\n\t// which is to stop after 10 consecutive requests.\n\tCheckRedirect func(req *Request, via []*Request) error\n\n\t// Jar specifies the cookie jar.\n\t//\n\t// The Jar is used to insert relevant cookies into every\n\t// outbound Request and is updated with the cookie values\n\t// of every inbound Response. The Jar is consulted for every\n\t// redirect that the Client follows.\n\t//\n\t// If Jar is nil, cookies are only sent if they are explicitly\n\t// set on the Request.\n\tJar CookieJar\n\n\t// Timeout specifies a time limit for requests made by this\n\t// Client. The timeout includes connection time, any\n\t// redirects, and reading the response body. The timer remains\n\t// running after Get, Head, Post, or Do return and will\n\t// interrupt reading of the Response.Body.\n\t//\n\t// A Timeout of zero means no timeout.\n\t//\n\t// The Client cancels requests to the underlying Transport\n\t// as if the Request's Context ended.\n\t//\n\t// For compatibility, the Client will also use the deprecated\n\t// CancelRequest method on Transport if found. New\n\t// RoundTripper implementations should use the Request's Context\n\t// for cancellation instead of implementing CancelRequest.\n\tTimeout time.Duration\n}\n    A Client is an HTTP client. Its zero value (DefaultClient) is a usable\n    client that uses DefaultTransport.\n\n    The [Client.Transport] typically has internal state (cached TCP\n    connections), so Clients should be reused instead of created as needed.\n    Clients are safe for concurrent use by multiple goroutines.\n\n    A Client is higher-level than a RoundTripper (such as Transport) and\n    additionally handles HTTP details such as cookies and redirects.\n\n    When following redirects, the Client will forward all headers set on the\n    initial Request except:\n\n      - when forwarding sensitive headers like \"Authorization\",\n        \"WWW-Authenticate\", and \"Cookie\" to untrusted targets. These headers\n        will be ignored when following a redirect to a domain that is not a\n        subdomain match or exact match of the initial domain. For example,\n        a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\" will\n        forward the sensitive headers, but a redirect to \"bar.com\" will not.\n      - when forwarding the \"Cookie\" header with a non-nil cookie Jar.\n        Since each redirect may mutate the state of the cookie jar,\n        a redirect may possibly alter a cookie set in the initial request. When\n        forwarding the \"Cookie\" header, any mutated cookies will be omitted,\n        with the expectation that the Jar will insert those mutated cookies\n        with the updated values (assuming the origin matches). If Jar is nil,\n        the initial cookies are forwarded without change.\n\nfunc (c *Client) CloseIdleConnections()\n    CloseIdleConnections closes any connections on its Transport which were\n    previously connected from previous requests but are now sitting idle in a\n    \"keep-alive\" state. It does not interrupt any connections currently in use.\n\n    If [Client.Transport] does not have a Client.CloseIdleConnections method\n    then this method does nothing.\n\nfunc (c *Client) Do(req *Request) (*Response, error)\n    Do sends an HTTP request and returns an HTTP response, following policy\n    (such as redirects, cookies, auth) as configured on the client.\n\n    An error is returned if caused by client policy (such as CheckRedirect),\n    or failure to speak HTTP (such as a network connectivity problem). A non-2xx\n    status code doesn't cause an error.\n\n    If the returned error is nil, the Response will contain a non-nil Body\n    which the user is expected to close. If the Body is not both read to EOF and\n    closed, the Client's underlying RoundTripper (typically Transport) may not\n    be able to re-use a persistent TCP connection to the server for a subsequent\n    \"keep-alive\" request.\n\n    The request Body, if non-nil, will be closed by the underlying Transport,\n    even on errors. The Body may be closed asynchronously after Do returns.\n\n    On error, any Response can be ignored. A non-nil Response with a non-nil\n    error only occurs when CheckRedirect fails, and even then the returned\n    [Response.Body] is already closed.\n\n    Generally Get, Post, or PostForm will be used instead of Do.\n\n    If the server replies with a redirect, the Client first uses the\n    CheckRedirect function to determine whether the redirect should be followed.\n    If permitted, a 301, 302, or 303 redirect causes subsequent requests to use\n    HTTP method GET (or HEAD if the original request was HEAD), with no body.\n    A 307 or 308 redirect preserves the original HTTP method and body, provided\n    that the [Request.GetBody] function is defined. The NewRequest function\n    automatically sets GetBody for common standard library body types.\n\n    Any returned error will be of type *url.Error. The url.Error value's Timeout\n    method will report true if the request timed out.\n\nfunc (c *Client) Get(url string) (resp *Response, err error)\n    Get issues a GET to the specified URL. If the response is one of the\n    following redirect codes, Get follows the redirect after calling the\n    [Client.CheckRedirect] function:\n\n        301 (Moved Permanently)\n        302 (Found)\n        303 (See Other)\n        307 (Temporary Redirect)\n        308 (Permanent Redirect)\n\n    An error is returned if the [Client.CheckRedirect] function fails or if\n    there was an HTTP protocol error. A non-2xx response doesn't cause an error.\n    Any returned error will be of type *url.Error. The url.Error value's Timeout\n    method will report true if the request timed out.\n\n    When err is nil, resp always contains a non-nil resp.Body. Caller should\n    close resp.Body when done reading from it.\n\n    To make a request with custom headers, use NewRequest and Client.Do.\n\n    To make a request with a specified context.Context, use\n    NewRequestWithContext and Client.Do.\n\nfunc (c *Client) Head(url string) (resp *Response, err error)\n    Head issues a HEAD to the specified URL. If the response is one of the\n    following redirect codes, Head follows the redirect after calling the\n    [Client.CheckRedirect] function:\n\n        301 (Moved Permanently)\n        302 (Found)\n        303 (See Other)\n        307 (Temporary Redirect)\n        308 (Permanent Redirect)\n\n    To make a request with a specified context.Context, use\n    NewRequestWithContext and Client.Do.\n\nfunc (c *Client) Post(url, contentType string, body io.Reader) (resp *Response, err error)\n    Post issues a POST to the specified URL.\n\n    Caller should close resp.Body when done reading from it.\n\n    If the provided body is an io.Closer, it is closed after the request.\n\n    To set custom headers, use NewRequest and Client.Do.\n\n    To make a request with a specified context.Context, use\n    NewRequestWithContext and Client.Do.\n\n    See the Client.Do method documentation for details on how redirects are\n    handled.\n\nfunc (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)\n    PostForm issues a POST to the specified URL, with data's keys and values\n    URL-encoded as the request body.\n\n    The Content-Type header is set to application/x-www-form-urlencoded.\n    To set other headers, use NewRequest and Client.Do.\n\n    When err is nil, resp always contains a non-nil resp.Body. Caller should\n    close resp.Body when done reading from it.\n\n    See the Client.Do method documentation for details on how redirects are\n    handled.\n\n    To make a request with a specified context.Context, use\n    NewRequestWithContext and Client.Do.\n\ntype CloseNotifier interface {\n\t// CloseNotify returns a channel that receives at most a\n\t// single value (true) when the client connection has gone\n\t// away.\n\t//\n\t// CloseNotify may wait to notify until Request.Body has been\n\t// fully read.\n\t//\n\t// After the Handler has returned, there is no guarantee\n\t// that the channel receives a value.\n\t//\n\t// If the protocol is HTTP/1.1 and CloseNotify is called while\n\t// processing an idempotent request (such as GET) while\n\t// HTTP/1.1 pipelining is in use, the arrival of a subsequent\n\t// pipelined request may cause a value to be sent on the\n\t// returned channel. In practice HTTP/1.1 pipelining is not\n\t// enabled in browsers and not seen often in the wild. If this\n\t// is a problem, use HTTP/2 or only use CloseNotify on methods\n\t// such as POST.\n\tCloseNotify() <-chan bool\n}\n    The CloseNotifier interface is implemented by ResponseWriters which allow\n    detecting when the underlying connection has gone away.\n\n    This mechanism can be used to cancel long operations on the server if the\n    client has disconnected before the response is ready.\n\n    Deprecated: the CloseNotifier interface predates Go's context package.\n    New code should use Request.Context instead.\n\ntype ConnState int\n    A ConnState represents the state of a client connection to a server.\n    It's used by the optional [Server.ConnState] hook.\n\nconst (\n\t// StateNew represents a new connection that is expected to\n\t// send a request immediately. Connections begin at this\n\t// state and then transition to either StateActive or\n\t// StateClosed.\n\tStateNew ConnState = iota\n\n\t// StateActive represents a connection that has read 1 or more\n\t// bytes of a request. The Server.ConnState hook for\n\t// StateActive fires before the request has entered a handler\n\t// and doesn't fire again until the request has been\n\t// handled. After the request is handled, the state\n\t// transitions to StateClosed, StateHijacked, or StateIdle.\n\t// For HTTP/2, StateActive fires on the transition from zero\n\t// to one active request, and only transitions away once all\n\t// active requests are complete. That means that ConnState\n\t// cannot be used to do per-request work; ConnState only notes\n\t// the overall state of the connection.\n\tStateActive\n\n\t// StateIdle represents a connection that has finished\n\t// handling a request and is in the keep-alive state, waiting\n\t// for a new request. Connections transition from StateIdle\n\t// to either StateActive or StateClosed.\n\tStateIdle\n\n\t// StateHijacked represents a hijacked connection.\n\t// This is a terminal state. It does not transition to StateClosed.\n\tStateHijacked\n\n\t// StateClosed represents a closed connection.\n\t// This is a terminal state. Hijacked connections do not\n\t// transition to StateClosed.\n\tStateClosed\n)\nfunc (c ConnState) String() string\n\ntype Cookie struct {\n\tName   string\n\tValue  string\n\tQuoted bool // indicates whether the Value was originally quoted\n\n\tPath       string    // optional\n\tDomain     string    // optional\n\tExpires    time.Time // optional\n\tRawExpires string    // for reading cookies only\n\n\t// MaxAge=0 means no 'Max-Age' attribute specified.\n\t// MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'\n\t// MaxAge>0 means Max-Age attribute present and given in seconds\n\tMaxAge      int\n\tSecure      bool\n\tHttpOnly    bool\n\tSameSite    SameSite\n\tPartitioned bool\n\tRaw         string\n\tUnparsed    []string // Raw text of unparsed attribute-value pairs\n}\n    A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an\n    HTTP response or the Cookie header of an HTTP request.\n\n    See https://tools.ietf.org/html/rfc6265 for details.\n\nfunc (c *Cookie) String() string\n    String returns the serialization of the cookie for use in a Cookie header\n    (if only Name and Value are set) or a Set-Cookie response header (if other\n    fields are set). If c is nil or c.Name is invalid, the empty string is\n    returned.\n\nfunc (c *Cookie) Valid() error\n    Valid reports whether the cookie is valid.\n\ntype CookieJar interface {\n\t// SetCookies handles the receipt of the cookies in a reply for the\n\t// given URL.  It may or may not choose to save the cookies, depending\n\t// on the jar's policy and implementation.\n\tSetCookies(u *url.URL, cookies []*Cookie)\n\n\t// Cookies returns the cookies to send in a request for the given URL.\n\t// It is up to the implementation to honor the standard cookie use\n\t// restrictions such as in RFC 6265.\n\tCookies(u *url.URL) []*Cookie\n}\n    A CookieJar manages storage and use of cookies in HTTP requests.\n\n    Implementations of CookieJar must be safe for concurrent use by multiple\n    goroutines.\n\n    The net/http/cookiejar package provides a CookieJar implementation.\n\ntype CrossOriginProtection struct {\n\t// Has unexported fields.\n}\n    CrossOriginProtection implements protections against Cross-Site Request\n    Forgery (CSRF) by rejecting non-safe cross-origin browser requests.\n\n    Cross-origin requests are currently detected with the Sec-Fetch-Site header,\n    available in all browsers since 2023, or by comparing the hostname of the\n    Origin header with the Host header.\n\n    The GET, HEAD, and OPTIONS methods are safe methods and are always allowed.\n    It's important that applications do not perform any state changing actions\n    due to requests with safe methods.\n\n    Requests without Sec-Fetch-Site or Origin headers are currently assumed to\n    be either same-origin or non-browser requests, and are allowed.\n\n    The zero value of CrossOriginProtection is valid and has no trusted origins\n    or bypass patterns.\n\n[Sec-Fetch-Site]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site\n[Origin]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin\n[Cross-Site Request Forgery (CSRF)]: https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/CSRF\n[safe methods]: https://developer.mozilla.org/en-US/docs/Glossary/Safe/HTTP\n\nfunc NewCrossOriginProtection() *CrossOriginProtection\n    NewCrossOriginProtection returns a new CrossOriginProtection value.\n\nfunc (c *CrossOriginProtection) AddInsecureBypassPattern(pattern string)\n    AddInsecureBypassPattern permits all requests that match the given pattern.\n\n    The pattern syntax and precedence rules are the same as ServeMux.\n    Only requests that match the pattern directly are permitted. Those that\n    ServeMux would redirect to a pattern (e.g. after cleaning the path or adding\n    a trailing slash) are not.\n\n    AddInsecureBypassPattern can be called concurrently with other methods or\n    request handling, and applies to future requests.\n\nfunc (c *CrossOriginProtection) AddTrustedOrigin(origin string) error\n    AddTrustedOrigin allows all requests with an Origin header which exactly\n    matches the given value.\n\n    Origin header values are of the form \"scheme://host[:port]\".\n\n    AddTrustedOrigin can be called concurrently with other methods or request\n    handling, and applies to future requests.\n\n[Origin]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin\n\nfunc (c *CrossOriginProtection) Check(req *Request) error\n    Check applies cross-origin checks to a request. It returns an error if the\n    request should be rejected.\n\nfunc (c *CrossOriginProtection) Handler(h Handler) Handler\n    Handler returns a handler that applies cross-origin checks before invoking\n    the handler h.\n\n    If a request fails cross-origin checks, the request is rejected\n    with a 403 Forbidden status or handled with the handler passed to\n    CrossOriginProtection.SetDenyHandler.\n\nfunc (c *CrossOriginProtection) SetDenyHandler(h Handler)\n    SetDenyHandler sets a handler to invoke when a request is rejected.\n    The default error handler responds with a 403 Forbidden status.\n\n    SetDenyHandler can be called concurrently with other methods or request\n    handling, and applies to future requests.\n\n    Check does not call the error handler.\n\ntype Dir string\n    A Dir implements FileSystem using the native file system restricted to a\n    specific directory tree.\n\n    While the [FileSystem.Open] method takes '/'-separated paths, a Dir's string\n    value is a directory path on the native file system, not a URL, so it is\n    separated by filepath.Separator, which isn't necessarily '/'.\n\n    Note that Dir could expose sensitive files and directories. Dir will\n    follow symlinks pointing out of the directory tree, which can be especially\n    dangerous if serving from a directory in which users are able to create\n    arbitrary symlinks. Dir will also allow access to files and directories\n    starting with a period, which could expose sensitive directories like .git\n    or sensitive files like .htpasswd. To exclude files with a leading period,\n    remove the files/directories from the server or create a custom FileSystem\n    implementation.\n\n    An empty Dir is treated as \".\".\n\nfunc (d Dir) Open(name string) (File, error)\n    Open implements FileSystem using os.Open, opening files for reading rooted\n    and relative to the directory d.\n\ntype File interface {\n\tio.Closer\n\tio.Reader\n\tio.Seeker\n\tReaddir(count int) ([]fs.FileInfo, error)\n\tStat() (fs.FileInfo, error)\n}\n    A File is returned by a FileSystem's Open method and can be served by the\n    FileServer implementation.\n\n    The methods should behave the same as those on an *os.File.\n\ntype FileSystem interface {\n\tOpen(name string) (File, error)\n}\n    A FileSystem implements access to a collection of named files. The elements\n    in a file path are separated by slash ('/', U+002F) characters, regardless\n    of host operating system convention. See the FileServer function to convert\n    a FileSystem to a Handler.\n\n    This interface predates the fs.FS interface, which can be used instead:\n    the FS adapter function converts an fs.FS to a FileSystem.\n\nfunc FS(fsys fs.FS) FileSystem\n    FS converts fsys to a FileSystem implementation, for use with FileServer and\n    NewFileTransport. The files provided by fsys must implement io.Seeker.\n\ntype Flusher interface {\n\t// Flush sends any buffered data to the client.\n\tFlush()\n}\n    The Flusher interface is implemented by ResponseWriters that allow an HTTP\n    handler to flush buffered data to the client.\n\n    The default HTTP/1.x and HTTP/2 ResponseWriter implementations support\n    Flusher, but ResponseWriter wrappers may not. Handlers should always test\n    for this ability at runtime.\n\n    Note that even for ResponseWriters that support Flush, if the client is\n    connected through an HTTP proxy, the buffered data may not reach the client\n    until the response completes.\n\ntype HTTP2Config struct {\n\t// MaxConcurrentStreams optionally specifies the number of\n\t// concurrent streams that a peer may have open at a time.\n\t// If zero, MaxConcurrentStreams defaults to at least 100.\n\tMaxConcurrentStreams int\n\n\t// MaxDecoderHeaderTableSize optionally specifies an upper limit for the\n\t// size of the header compression table used for decoding headers sent\n\t// by the peer.\n\t// A valid value is less than 4MiB.\n\t// If zero or invalid, a default value is used.\n\tMaxDecoderHeaderTableSize int\n\n\t// MaxEncoderHeaderTableSize optionally specifies an upper limit for the\n\t// header compression table used for sending headers to the peer.\n\t// A valid value is less than 4MiB.\n\t// If zero or invalid, a default value is used.\n\tMaxEncoderHeaderTableSize int\n\n\t// MaxReadFrameSize optionally specifies the largest frame\n\t// this endpoint is willing to read.\n\t// A valid value is between 16KiB and 16MiB, inclusive.\n\t// If zero or invalid, a default value is used.\n\tMaxReadFrameSize int\n\n\t// MaxReceiveBufferPerConnection is the maximum size of the\n\t// flow control window for data received on a connection.\n\t// A valid value is at least 64KiB and less than 4MiB.\n\t// If invalid, a default value is used.\n\tMaxReceiveBufferPerConnection int\n\n\t// MaxReceiveBufferPerStream is the maximum size of\n\t// the flow control window for data received on a stream (request).\n\t// A valid value is less than 4MiB.\n\t// If zero or invalid, a default value is used.\n\tMaxReceiveBufferPerStream int\n\n\t// SendPingTimeout is the timeout after which a health check using a ping\n\t// frame will be carried out if no frame is received on a connection.\n\t// If zero, no health check is performed.\n\tSendPingTimeout time.Duration\n\n\t// PingTimeout is the timeout after which a connection will be closed\n\t// if a response to a ping is not received.\n\t// If zero, a default of 15 seconds is used.\n\tPingTimeout time.Duration\n\n\t// WriteByteTimeout is the timeout after which a connection will be\n\t// closed if no data can be written to it. The timeout begins when data is\n\t// available to write, and is extended whenever any bytes are written.\n\tWriteByteTimeout time.Duration\n\n\t// PermitProhibitedCipherSuites, if true, permits the use of\n\t// cipher suites prohibited by the HTTP/2 spec.\n\tPermitProhibitedCipherSuites bool\n\n\t// CountError, if non-nil, is called on HTTP/2 errors.\n\t// It is intended to increment a metric for monitoring.\n\t// The errType contains only lowercase letters, digits, and underscores\n\t// (a-z, 0-9, _).\n\tCountError func(errType string)\n}\n    HTTP2Config defines HTTP/2 configuration parameters common to both Transport\n    and Server.\n\ntype Handler interface {\n\tServeHTTP(ResponseWriter, *Request)\n}\n    A Handler responds to an HTTP request.\n\n    [Handler.ServeHTTP] should write reply headers and data to the\n    ResponseWriter and then return. Returning signals that the request is\n    finished; it is not valid to use the ResponseWriter or read from the\n    [Request.Body] after or concurrently with the completion of the ServeHTTP\n    call.\n\n    Depending on the HTTP client software, HTTP protocol version, and any\n    intermediaries between the client and the Go server, it may not be possible\n    to read from the [Request.Body] after writing to the ResponseWriter.\n    Cautious handlers should read the [Request.Body] first, and then reply.\n\n    Except for reading the body, handlers should not modify the provided\n    Request.\n\n    If ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the\n    effect of the panic was isolated to the active request. It recovers the\n    panic, logs a stack trace to the server error log, and either closes the\n    network connection or sends an HTTP/2 RST_STREAM, depending on the HTTP\n    protocol. To abort a handler so the client sees an interrupted response but\n    the server doesn't log an error, panic with the value ErrAbortHandler.\n\nfunc AllowQuerySemicolons(h Handler) Handler\n    AllowQuerySemicolons returns a handler that serves requests by converting\n    any unescaped semicolons in the URL query to ampersands, and invoking the\n    handler h.\n\n    This restores the pre-Go 1.17 behavior of splitting query parameters on\n    both semicolons and ampersands. (See golang.org/issue/25192). Note that this\n    behavior doesn't match that of many proxies, and the mismatch can lead to\n    security issues.\n\n    AllowQuerySemicolons should be invoked before Request.ParseForm is called.\n\nfunc FileServer(root FileSystem) Handler\n    FileServer returns a handler that serves HTTP requests with the contents of\n    the file system rooted at root.\n\n    As a special case, the returned file server redirects any request ending in\n    \"/index.html\" to the same path, without the final \"index.html\".\n\n    To use the operating system's file system implementation, use http.Dir:\n\n        http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\n    To use an fs.FS implementation, use http.FileServerFS instead.\n\nfunc FileServerFS(root fs.FS) Handler\n    FileServerFS returns a handler that serves HTTP requests with the contents\n    of the file system fsys. The files provided by fsys must implement\n    io.Seeker.\n\n    As a special case, the returned file server redirects any request ending in\n    \"/index.html\" to the same path, without the final \"index.html\".\n\n        http.Handle(\"/\", http.FileServerFS(fsys))\n\nfunc MaxBytesHandler(h Handler, n int64) Handler\n    MaxBytesHandler returns a Handler that runs h with its ResponseWriter and\n    [Request.Body] wrapped by a MaxBytesReader.\n\nfunc NotFoundHandler() Handler\n    NotFoundHandler returns a simple request handler that replies to each\n    request with a \u201c404 page not found\u201d reply.\n\nfunc RedirectHandler(url string, code int) Handler\n    RedirectHandler returns a request handler that redirects each request it\n    receives to the given url using the given status code.\n\n    The provided code should be in the 3xx range and is usually\n    StatusMovedPermanently, StatusFound or StatusSeeOther.\n\nfunc StripPrefix(prefix string, h Handler) Handler\n    StripPrefix returns a handler that serves HTTP requests by removing the\n    given prefix from the request URL's Path (and RawPath if set) and invoking\n    the handler h. StripPrefix handles a request for a path that doesn't begin\n    with prefix by replying with an HTTP 404 not found error. The prefix must\n    match exactly: if the prefix in the request contains escaped characters the\n    reply is also an HTTP 404 not found error.\n\nfunc TimeoutHandler(h Handler, dt time.Duration, msg string) Handler\n    TimeoutHandler returns a Handler that runs h with the given time limit.\n\n    The new Handler calls h.ServeHTTP to handle each request, but if a call\n    runs for longer than its time limit, the handler responds with a 503 Service\n    Unavailable error and the given message in its body. (If msg is empty,\n    a suitable default message will be sent.) After such a timeout, writes by h\n    to its ResponseWriter will return ErrHandlerTimeout.\n\n    TimeoutHandler supports the Pusher interface but does not support the\n    Hijacker or Flusher interfaces.\n\ntype HandlerFunc func(ResponseWriter, *Request)\n    The HandlerFunc type is an adapter to allow the use of ordinary functions\n    as HTTP handlers. If f is a function with the appropriate signature,\n    HandlerFunc(f) is a Handler that calls f.\n\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)\n    ServeHTTP calls f(w, r).\n\ntype Header map[string][]string\n    A Header represents the key-value pairs in an HTTP header.\n\n    The keys should be in canonical form, as returned by CanonicalHeaderKey.\n\nfunc (h Header) Add(key, value string)\n    Add adds the key, value pair to the header. It appends to any existing\n    values associated with key. The key is case insensitive; it is canonicalized\n    by CanonicalHeaderKey.\n\nfunc (h Header) Clone() Header\n    Clone returns a copy of h or nil if h is nil.\n\nfunc (h Header) Del(key string)\n    Del deletes the values associated with key. The key is case insensitive;\n    it is canonicalized by CanonicalHeaderKey.\n\nfunc (h Header) Get(key string) string\n    Get gets the first value associated with the given key. If there are no\n    values associated with the key, Get returns \"\". It is case insensitive;\n    textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key.\n    Get assumes that all keys are stored in canonical form. To use non-canonical\n    keys, access the map directly.\n\nfunc (h Header) Set(key, value string)\n    Set sets the header entries associated with key to the single element value.\n    It replaces any existing values associated with key. The key is case\n    insensitive; it is canonicalized by textproto.CanonicalMIMEHeaderKey.\n    To use non-canonical keys, assign to the map directly.\n\nfunc (h Header) Values(key string) []string\n    Values returns all values associated with the given key. It is case\n    insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize\n    the provided key. To use non-canonical keys, access the map directly.\n    The returned slice is not a copy.\n\nfunc (h Header) Write(w io.Writer) error\n    Write writes a header in wire format.\n\nfunc (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error\n    WriteSubset writes a header in wire format. If exclude is not nil,\n    keys where exclude[key] == true are not written. Keys are not canonicalized\n    before checking the exclude map.\n\ntype Hijacker interface {\n\t// Hijack lets the caller take over the connection.\n\t// After a call to Hijack the HTTP server library\n\t// will not do anything else with the connection.\n\t//\n\t// It becomes the caller's responsibility to manage\n\t// and close the connection.\n\t//\n\t// The returned net.Conn may have read or write deadlines\n\t// already set, depending on the configuration of the\n\t// Server. It is the caller's responsibility to set\n\t// or clear those deadlines as needed.\n\t//\n\t// The returned bufio.Reader may contain unprocessed buffered\n\t// data from the client.\n\t//\n\t// After a call to Hijack, the original Request.Body must not\n\t// be used. The original Request's Context remains valid and\n\t// is not canceled until the Request's ServeHTTP method\n\t// returns.\n\tHijack() (net.Conn, *bufio.ReadWriter, error)\n}\n    The Hijacker interface is implemented by ResponseWriters that allow an HTTP\n    handler to take over the connection.\n\n    The default ResponseWriter for HTTP/1.x connections supports Hijacker,\n    but HTTP/2 connections intentionally do not. ResponseWriter wrappers may\n    also not support Hijacker. Handlers should always test for this ability at\n    runtime.\n\ntype MaxBytesError struct {\n\tLimit int64\n}\n    MaxBytesError is returned by MaxBytesReader when its read limit is exceeded.\n\nfunc (e *MaxBytesError) Error() string\n\ntype ProtocolError struct {\n\tErrorString string\n}\n    ProtocolError represents an HTTP protocol error.\n\n    Deprecated: Not all errors in the http package related to protocol errors\n    are of type ProtocolError.\n\nfunc (pe *ProtocolError) Error() string\n\nfunc (pe *ProtocolError) Is(err error) bool\n    Is lets http.ErrNotSupported match errors.ErrUnsupported.\n\ntype Protocols struct {\n\t// Has unexported fields.\n}\n    Protocols is a set of HTTP protocols. The zero value is an empty set of\n    protocols.\n\n    The supported protocols are:\n\n      - HTTP1 is the HTTP/1.0 and HTTP/1.1 protocols. HTTP1 is supported on both\n        unsecured TCP and secured TLS connections.\n\n      - HTTP2 is the HTTP/2 protcol over a TLS connection.\n\n      - UnencryptedHTTP2 is the HTTP/2 protocol over an unsecured TCP\n        connection.\n\nfunc (p Protocols) HTTP1() bool\n    HTTP1 reports whether p includes HTTP/1.\n\nfunc (p Protocols) HTTP2() bool\n    HTTP2 reports whether p includes HTTP/2.\n\nfunc (p *Protocols) SetHTTP1(ok bool)\n    SetHTTP1 adds or removes HTTP/1 from p.\n\nfunc (p *Protocols) SetHTTP2(ok bool)\n    SetHTTP2 adds or removes HTTP/2 from p.\n\nfunc (p *Protocols) SetUnencryptedHTTP2(ok bool)\n    SetUnencryptedHTTP2 adds or removes unencrypted HTTP/2 from p.\n\nfunc (p Protocols) String() string\n\nfunc (p Protocols) UnencryptedHTTP2() bool\n    UnencryptedHTTP2 reports whether p includes unencrypted HTTP/2.\n\ntype PushOptions struct {\n\t// Method specifies the HTTP method for the promised request.\n\t// If set, it must be \"GET\" or \"HEAD\". Empty means \"GET\".\n\tMethod string\n\n\t// Header specifies additional promised request headers. This cannot\n\t// include HTTP/2 pseudo header fields like \":path\" and \":scheme\",\n\t// which will be added automatically.\n\tHeader Header\n}\n    PushOptions describes options for [Pusher.Push].\n\ntype Pusher interface {\n\t// Push initiates an HTTP/2 server push. This constructs a synthetic\n\t// request using the given target and options, serializes that request\n\t// into a PUSH_PROMISE frame, then dispatches that request using the\n\t// server's request handler. If opts is nil, default options are used.\n\t//\n\t// The target must either be an absolute path (like \"/path\") or an absolute\n\t// URL that contains a valid host and the same scheme as the parent request.\n\t// If the target is a path, it will inherit the scheme and host of the\n\t// parent request.\n\t//\n\t// The HTTP/2 spec disallows recursive pushes and cross-authority pushes.\n\t// Push may or may not detect these invalid pushes; however, invalid\n\t// pushes will be detected and canceled by conforming clients.\n\t//\n\t// Handlers that wish to push URL X should call Push before sending any\n\t// data that may trigger a request for URL X. This avoids a race where the\n\t// client issues requests for X before receiving the PUSH_PROMISE for X.\n\t//\n\t// Push will run in a separate goroutine making the order of arrival\n\t// non-deterministic. Any required synchronization needs to be implemented\n\t// by the caller.\n\t//\n\t// Push returns ErrNotSupported if the client has disabled push or if push\n\t// is not supported on the underlying connection.\n\tPush(target string, opts *PushOptions) error\n}\n    Pusher is the interface implemented by ResponseWriters\n    that support HTTP/2 server push. For more background, see\n    https://tools.ietf.org/html/rfc7540#section-8.2.\n\ntype Request struct {\n\t// Method specifies the HTTP method (GET, POST, PUT, etc.).\n\t// For client requests, an empty string means GET.\n\tMethod string\n\n\t// URL specifies either the URI being requested (for server\n\t// requests) or the URL to access (for client requests).\n\t//\n\t// For server requests, the URL is parsed from the URI\n\t// supplied on the Request-Line as stored in RequestURI.  For\n\t// most requests, fields other than Path and RawQuery will be\n\t// empty. (See RFC 7230, Section 5.3)\n\t//\n\t// For client requests, the URL's Host specifies the server to\n\t// connect to, while the Request's Host field optionally\n\t// specifies the Host header value to send in the HTTP\n\t// request.\n\tURL *url.URL\n\n\t// The protocol version for incoming server requests.\n\t//\n\t// For client requests, these fields are ignored. The HTTP\n\t// client code always uses either HTTP/1.1 or HTTP/2.\n\t// See the docs on Transport for details.\n\tProto      string // \"HTTP/1.0\"\n\tProtoMajor int    // 1\n\tProtoMinor int    // 0\n\n\t// Header contains the request header fields either received\n\t// by the server or to be sent by the client.\n\t//\n\t// If a server received a request with header lines,\n\t//\n\t//\tHost: example.com\n\t//\taccept-encoding: gzip, deflate\n\t//\tAccept-Language: en-us\n\t//\tfOO: Bar\n\t//\tfoo: two\n\t//\n\t// then\n\t//\n\t//\tHeader = map[string][]string{\n\t//\t\t\"Accept-Encoding\": {\"gzip, deflate\"},\n\t//\t\t\"Accept-Language\": {\"en-us\"},\n\t//\t\t\"Foo\": {\"Bar\", \"two\"},\n\t//\t}\n\t//\n\t// For incoming requests, the Host header is promoted to the\n\t// Request.Host field and removed from the Header map.\n\t//\n\t// HTTP defines that header names are case-insensitive. The\n\t// request parser implements this by using CanonicalHeaderKey,\n\t// making the first character and any characters following a\n\t// hyphen uppercase and the rest lowercase.\n\t//\n\t// For client requests, certain headers such as Content-Length\n\t// and Connection are automatically written when needed and\n\t// values in Header may be ignored. See the documentation\n\t// for the Request.Write method.\n\tHeader Header\n\n\t// Body is the request's body.\n\t//\n\t// For client requests, a nil body means the request has no\n\t// body, such as a GET request. The HTTP Client's Transport\n\t// is responsible for calling the Close method.\n\t//\n\t// For server requests, the Request Body is always non-nil\n\t// but will return EOF immediately when no body is present.\n\t// The Server will close the request body. The ServeHTTP\n\t// Handler does not need to.\n\t//\n\t// Body must allow Read to be called concurrently with Close.\n\t// In particular, calling Close should unblock a Read waiting\n\t// for input.\n\tBody io.ReadCloser\n\n\t// GetBody defines an optional func to return a new copy of\n\t// Body. It is used for client requests when a redirect requires\n\t// reading the body more than once. Use of GetBody still\n\t// requires setting Body.\n\t//\n\t// For server requests, it is unused.\n\tGetBody func() (io.ReadCloser, error)\n\n\t// ContentLength records the length of the associated content.\n\t// The value -1 indicates that the length is unknown.\n\t// Values >= 0 indicate that the given number of bytes may\n\t// be read from Body.\n\t//\n\t// For client requests, a value of 0 with a non-nil Body is\n\t// also treated as unknown.\n\tContentLength int64\n\n\t// TransferEncoding lists the transfer encodings from outermost to\n\t// innermost. An empty list denotes the \"identity\" encoding.\n\t// TransferEncoding can usually be ignored; chunked encoding is\n\t// automatically added and removed as necessary when sending and\n\t// receiving requests.\n\tTransferEncoding []string\n\n\t// Close indicates whether to close the connection after\n\t// replying to this request (for servers) or after sending this\n\t// request and reading its response (for clients).\n\t//\n\t// For server requests, the HTTP server handles this automatically\n\t// and this field is not needed by Handlers.\n\t//\n\t// For client requests, setting this field prevents re-use of\n\t// TCP connections between requests to the same hosts, as if\n\t// Transport.DisableKeepAlives were set.\n\tClose bool\n\n\t// For server requests, Host specifies the host on which the\n\t// URL is sought. For HTTP/1 (per RFC 7230, section 5.4), this\n\t// is either the value of the \"Host\" header or the host name\n\t// given in the URL itself. For HTTP/2, it is the value of the\n\t// \":authority\" pseudo-header field.\n\t// It may be of the form \"host:port\". For international domain\n\t// names, Host may be in Punycode or Unicode form. Use\n\t// golang.org/x/net/idna to convert it to either format if\n\t// needed.\n\t// To prevent DNS rebinding attacks, server Handlers should\n\t// validate that the Host header has a value for which the\n\t// Handler considers itself authoritative. The included\n\t// ServeMux supports patterns registered to particular host\n\t// names and thus protects its registered Handlers.\n\t//\n\t// For client requests, Host optionally overrides the Host\n\t// header to send. If empty, the Request.Write method uses\n\t// the value of URL.Host. Host may contain an international\n\t// domain name.\n\tHost string\n\n\t// Form contains the parsed form data, including both the URL\n\t// field's query parameters and the PATCH, POST, or PUT form data.\n\t// This field is only available after ParseForm is called.\n\t// The HTTP client ignores Form and uses Body instead.\n\tForm url.Values\n\n\t// PostForm contains the parsed form data from PATCH, POST\n\t// or PUT body parameters.\n\t//\n\t// This field is only available after ParseForm is called.\n\t// The HTTP client ignores PostForm and uses Body instead.\n\tPostForm url.Values\n\n\t// MultipartForm is the parsed multipart form, including file uploads.\n\t// This field is only available after ParseMultipartForm is called.\n\t// The HTTP client ignores MultipartForm and uses Body instead.\n\tMultipartForm *multipart.Form\n\n\t// Trailer specifies additional headers that are sent after the request\n\t// body.\n\t//\n\t// For server requests, the Trailer map initially contains only the\n\t// trailer keys, with nil values. (The client declares which trailers it\n\t// will later send.)  While the handler is reading from Body, it must\n\t// not reference Trailer. After reading from Body returns EOF, Trailer\n\t// can be read again and will contain non-nil values, if they were sent\n\t// by the client.\n\t//\n\t// For client requests, Trailer must be initialized to a map containing\n\t// the trailer keys to later send. The values may be nil or their final\n\t// values. The ContentLength must be 0 or -1, to send a chunked request.\n\t// After the HTTP request is sent the map values can be updated while\n\t// the request body is read. Once the body returns EOF, the caller must\n\t// not mutate Trailer.\n\t//\n\t// Few HTTP clients, servers, or proxies support HTTP trailers.\n\tTrailer Header\n\n\t// RemoteAddr allows HTTP servers and other software to record\n\t// the network address that sent the request, usually for\n\t// logging. This field is not filled in by ReadRequest and\n\t// has no defined format. The HTTP server in this package\n\t// sets RemoteAddr to an \"IP:port\" address before invoking a\n\t// handler.\n\t// This field is ignored by the HTTP client.\n\tRemoteAddr string\n\n\t// RequestURI is the unmodified request-target of the\n\t// Request-Line (RFC 7230, Section 3.1.1) as sent by the client\n\t// to a server. Usually the URL field should be used instead.\n\t// It is an error to set this field in an HTTP client request.\n\tRequestURI string\n\n\t// TLS allows HTTP servers and other software to record\n\t// information about the TLS connection on which the request\n\t// was received. This field is not filled in by ReadRequest.\n\t// The HTTP server in this package sets the field for\n\t// TLS-enabled connections before invoking a handler;\n\t// otherwise it leaves the field nil.\n\t// This field is ignored by the HTTP client.\n\tTLS *tls.ConnectionState\n\n\t// Cancel is an optional channel whose closure indicates that the client\n\t// request should be regarded as canceled. Not all implementations of\n\t// RoundTripper may support Cancel.\n\t//\n\t// For server requests, this field is not applicable.\n\t//\n\t// Deprecated: Set the Request's context with NewRequestWithContext\n\t// instead. If a Request's Cancel field and context are both\n\t// set, it is undefined whether Cancel is respected.\n\tCancel <-chan struct{}\n\n\t// Response is the redirect response which caused this request\n\t// to be created. This field is only populated during client\n\t// redirects.\n\tResponse *Response\n\n\t// Pattern is the [ServeMux] pattern that matched the request.\n\t// It is empty if the request was not matched against a pattern.\n\tPattern string\n\n\t// Has unexported fields.\n}\n    A Request represents an HTTP request received by a server or to be sent by a\n    client.\n\n    The field semantics differ slightly between client and server usage.\n    In addition to the notes on the fields below, see the documentation for\n    Request.Write and RoundTripper.\n\nfunc (r *Request) AddCookie(c *Cookie)\n    AddCookie adds a cookie to the request. Per RFC 6265 section 5.4, AddCookie\n    does not attach more than one Cookie header field. That means all cookies,\n    if any, are written into the same line, separated by semicolon. AddCookie\n    only sanitizes c's name and value, and does not sanitize a Cookie header\n    already present in the request.\n\nfunc (r *Request) BasicAuth() (username, password string, ok bool)\n    BasicAuth returns the username and password provided in the request's\n    Authorization header, if the request uses HTTP Basic Authentication. See RFC\n    2617, Section 2.\n\nfunc (r *Request) Clone(ctx context.Context) *Request\n    Clone returns a deep copy of r with its context changed to ctx. The provided\n    ctx must be non-nil.\n\n    Clone only makes a shallow copy of the Body field.\n\n    For an outgoing client request, the context controls the entire lifetime of\n    a request and its response: obtaining a connection, sending the request,\n    and reading the response headers and body.\n\nfunc (r *Request) Context() context.Context\n    Context returns the request's context. To change the context, use\n    Request.Clone or Request.WithContext.\n\n    The returned context is always non-nil; it defaults to the background\n    context.\n\n    For outgoing client requests, the context controls cancellation.\n\n    For incoming server requests, the context is canceled when the client's\n    connection closes, the request is canceled (with HTTP/2), or when the\n    ServeHTTP method returns.\n\nfunc (r *Request) Cookie(name string) (*Cookie, error)\n    Cookie returns the named cookie provided in the request or ErrNoCookie if\n    not found. If multiple cookies match the given name, only one cookie will be\n    returned.\n\nfunc (r *Request) Cookies() []*Cookie\n    Cookies parses and returns the HTTP cookies sent with the request.\n\nfunc (r *Request) CookiesNamed(name string) []*Cookie\n    CookiesNamed parses and returns the named HTTP cookies sent with the request\n    or an empty slice if none matched.\n\nfunc (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)\n    FormFile returns the first file for the provided form key. FormFile calls\n    Request.ParseMultipartForm and Request.ParseForm if necessary.\n\nfunc (r *Request) FormValue(key string) string\n    FormValue returns the first value for the named component of the query.\n    The precedence order:\n     1. application/x-www-form-urlencoded form body (POST, PUT, PATCH only)\n     2. query parameters (always)\n     3. multipart/form-data form body (always)\n\n    FormValue calls Request.ParseMultipartForm and Request.ParseForm if\n    necessary and ignores any errors returned by these functions. If key is not\n    present, FormValue returns the empty string. To access multiple values of\n    the same key, call ParseForm and then inspect [Request.Form] directly.\n\nfunc (r *Request) MultipartReader() (*multipart.Reader, error)\n    MultipartReader returns a MIME multipart reader if this is a\n    multipart/form-data or a multipart/mixed POST request, else returns nil and\n    an error. Use this function instead of Request.ParseMultipartForm to process\n    the request body as a stream.\n\nfunc (r *Request) ParseForm() error\n    ParseForm populates r.Form and r.PostForm.\n\n    For all requests, ParseForm parses the raw query from the URL and updates\n    r.Form.\n\n    For POST, PUT, and PATCH requests, it also reads the request body, parses it\n    as a form and puts the results into both r.PostForm and r.Form. Request body\n    parameters take precedence over URL query string values in r.Form.\n\n    If the request Body's size has not already been limited by MaxBytesReader,\n    the size is capped at 10MB.\n\n    For other HTTP methods, or when the Content-Type is not\n    application/x-www-form-urlencoded, the request Body is not read, and\n    r.PostForm is initialized to a non-nil, empty value.\n\n    Request.ParseMultipartForm calls ParseForm automatically. ParseForm is\n    idempotent.\n\nfunc (r *Request) ParseMultipartForm(maxMemory int64) error\n    ParseMultipartForm parses a request body as multipart/form-data.\n    The whole request body is parsed and up to a total of maxMemory bytes of\n    its file parts are stored in memory, with the remainder stored on disk in\n    temporary files. ParseMultipartForm calls Request.ParseForm if necessary.\n    If ParseForm returns an error, ParseMultipartForm returns it but also\n    continues parsing the request body. After one call to ParseMultipartForm,\n    subsequent calls have no effect.\n\nfunc (r *Request) PathValue(name string) string\n    PathValue returns the value for the named path wildcard in the ServeMux\n    pattern that matched the request. It returns the empty string if the request\n    was not matched against a pattern or there is no such wildcard in the\n    pattern.\n\nfunc (r *Request) PostFormValue(key string) string\n    PostFormValue returns the first value for the named component of the POST,\n    PUT, or PATCH request body. URL query parameters are ignored. PostFormValue\n    calls Request.ParseMultipartForm and Request.ParseForm if necessary and\n    ignores any errors returned by these functions. If key is not present,\n    PostFormValue returns the empty string.\n\nfunc (r *Request) ProtoAtLeast(major, minor int) bool\n    ProtoAtLeast reports whether the HTTP protocol used in the request is at\n    least major.minor.\n\nfunc (r *Request) Referer() string\n    Referer returns the referring URL, if sent in the request.\n\n    Referer is misspelled as in the request itself, a mistake from the\n    earliest days of HTTP. This value can also be fetched from the Header map\n    as Header[\"Referer\"]; the benefit of making it available as a method is\n    that the compiler can diagnose programs that use the alternate (correct\n    English) spelling req.Referrer() but cannot diagnose programs that use\n    Header[\"Referrer\"].\n\nfunc (r *Request) SetBasicAuth(username, password string)\n    SetBasicAuth sets the request's Authorization header to use HTTP Basic\n    Authentication with the provided username and password.\n\n    With HTTP Basic Authentication the provided username and password are not\n    encrypted. It should generally only be used in an HTTPS request.\n\n    The username may not contain a colon. Some protocols may impose additional\n    requirements on pre-escaping the username and password. For instance,\n    when used with OAuth2, both arguments must be URL encoded first with\n    url.QueryEscape.\n\nfunc (r *Request) SetPathValue(name, value string)\n    SetPathValue sets name to value, so that subsequent calls to\n    r.PathValue(name) return value.\n\nfunc (r *Request) UserAgent() string\n    UserAgent returns the client's User-Agent, if sent in the request.\n\nfunc (r *Request) WithContext(ctx context.Context) *Request\n    WithContext returns a shallow copy of r with its context changed to ctx.\n    The provided ctx must be non-nil.\n\n    For outgoing client request, the context controls the entire lifetime of\n    a request and its response: obtaining a connection, sending the request,\n    and reading the response headers and body.\n\n    To create a new request with a context, use NewRequestWithContext. To make a\n    deep copy of a request with a new context, use Request.Clone.\n\nfunc (r *Request) Write(w io.Writer) error\n    Write writes an HTTP/1.1 request, which is the header and body, in wire\n    format. This method consults the following fields of the request:\n\n        Host\n        URL\n        Method (defaults to \"GET\")\n        Header\n        ContentLength\n        TransferEncoding\n        Body\n\n    If Body is present, Content-Length is <= 0 and [Request.TransferEncoding]\n    hasn't been set to \"identity\", Write adds \"Transfer-Encoding: chunked\" to\n    the header. Body is closed after it is sent.\n\nfunc (r *Request) WriteProxy(w io.Writer) error\n    WriteProxy is like Request.Write but writes the request in the form expected\n    by an HTTP proxy. In particular, Request.WriteProxy writes the initial\n    Request-URI line of the request with an absolute URI, per section 5.3 of RFC\n    7230, including the scheme and host. In either case, WriteProxy also writes\n    a Host header, using either r.Host or r.URL.Host.\n\ntype Response struct {\n\tStatus     string // e.g. \"200 OK\"\n\tStatusCode int    // e.g. 200\n\tProto      string // e.g. \"HTTP/1.0\"\n\tProtoMajor int    // e.g. 1\n\tProtoMinor int    // e.g. 0\n\n\t// Header maps header keys to values. If the response had multiple\n\t// headers with the same key, they may be concatenated, with comma\n\t// delimiters.  (RFC 7230, section 3.2.2 requires that multiple headers\n\t// be semantically equivalent to a comma-delimited sequence.) When\n\t// Header values are duplicated by other fields in this struct (e.g.,\n\t// ContentLength, TransferEncoding, Trailer), the field values are\n\t// authoritative.\n\t//\n\t// Keys in the map are canonicalized (see CanonicalHeaderKey).\n\tHeader Header\n\n\t// Body represents the response body.\n\t//\n\t// The response body is streamed on demand as the Body field\n\t// is read. If the network connection fails or the server\n\t// terminates the response, Body.Read calls return an error.\n\t//\n\t// The http Client and Transport guarantee that Body is always\n\t// non-nil, even on responses without a body or responses with\n\t// a zero-length body. It is the caller's responsibility to\n\t// close Body. The default HTTP client's Transport may not\n\t// reuse HTTP/1.x \"keep-alive\" TCP connections if the Body is\n\t// not read to completion and closed.\n\t//\n\t// The Body is automatically dechunked if the server replied\n\t// with a \"chunked\" Transfer-Encoding.\n\t//\n\t// As of Go 1.12, the Body will also implement io.Writer\n\t// on a successful \"101 Switching Protocols\" response,\n\t// as used by WebSockets and HTTP/2's \"h2c\" mode.\n\tBody io.ReadCloser\n\n\t// ContentLength records the length of the associated content. The\n\t// value -1 indicates that the length is unknown. Unless Request.Method\n\t// is \"HEAD\", values >= 0 indicate that the given number of bytes may\n\t// be read from Body.\n\tContentLength int64\n\n\t// Contains transfer encodings from outer-most to inner-most. Value is\n\t// nil, means that \"identity\" encoding is used.\n\tTransferEncoding []string\n\n\t// Close records whether the header directed that the connection be\n\t// closed after reading Body. The value is advice for clients: neither\n\t// ReadResponse nor Response.Write ever closes a connection.\n\tClose bool\n\n\t// Uncompressed reports whether the response was sent compressed but\n\t// was decompressed by the http package. When true, reading from\n\t// Body yields the uncompressed content instead of the compressed\n\t// content actually set from the server, ContentLength is set to -1,\n\t// and the \"Content-Length\" and \"Content-Encoding\" fields are deleted\n\t// from the responseHeader. To get the original response from\n\t// the server, set Transport.DisableCompression to true.\n\tUncompressed bool\n\n\t// Trailer maps trailer keys to values in the same\n\t// format as Header.\n\t//\n\t// The Trailer initially contains only nil values, one for\n\t// each key specified in the server's \"Trailer\" header\n\t// value. Those values are not added to Header.\n\t//\n\t// Trailer must not be accessed concurrently with Read calls\n\t// on the Body.\n\t//\n\t// After Body.Read has returned io.EOF, Trailer will contain\n\t// any trailer values sent by the server.\n\tTrailer Header\n\n\t// Request is the request that was sent to obtain this Response.\n\t// Request's Body is nil (having already been consumed).\n\t// This is only populated for Client requests.\n\tRequest *Request\n\n\t// TLS contains information about the TLS connection on which the\n\t// response was received. It is nil for unencrypted responses.\n\t// The pointer is shared between responses and should not be\n\t// modified.\n\tTLS *tls.ConnectionState\n}\n    Response represents the response from an HTTP request.\n\n    The Client and Transport return Responses from servers once the response\n    headers have been received. The response body is streamed on demand as the\n    Body field is read.\n\nfunc (r *Response) Cookies() []*Cookie\n    Cookies parses and returns the cookies set in the Set-Cookie headers.\n\nfunc (r *Response) Location() (*url.URL, error)\n    Location returns the URL of the response's \"Location\" header, if present.\n    Relative redirects are resolved relative to [Response.Request].\n    ErrNoLocation is returned if no Location header is present.\n\nfunc (r *Response) ProtoAtLeast(major, minor int) bool\n    ProtoAtLeast reports whether the HTTP protocol used in the response is at\n    least major.minor.\n\nfunc (r *Response) Write(w io.Writer) error\n    Write writes r to w in the HTTP/1.x server response format, including the\n    status line, headers, body, and optional trailer.\n\n    This method consults the following fields of the response r:\n\n        StatusCode\n        ProtoMajor\n        ProtoMinor\n        Request.Method\n        TransferEncoding\n        Trailer\n        Body\n        ContentLength\n        Header, values for non-canonical keys will have unpredictable behavior\n\n    The Response Body is closed after it is sent.\n\ntype ResponseController struct {\n\t// Has unexported fields.\n}\n    A ResponseController is used by an HTTP handler to control the response.\n\n    A ResponseController may not be used after the [Handler.ServeHTTP] method\n    has returned.\n\nfunc NewResponseController(rw ResponseWriter) *ResponseController\n    NewResponseController creates a ResponseController for a request.\n\n    The ResponseWriter should be the original value passed to the\n    [Handler.ServeHTTP] method, or have an Unwrap method returning the original\n    ResponseWriter.\n\n    If the ResponseWriter implements any of the following methods, the\n    ResponseController will call them as appropriate:\n\n        Flush()\n        FlushError() error // alternative Flush returning an error\n        Hijack() (net.Conn, *bufio.ReadWriter, error)\n        SetReadDeadline(deadline time.Time) error\n        SetWriteDeadline(deadline time.Time) error\n        EnableFullDuplex() error\n\n    If the ResponseWriter does not support a method, ResponseController returns\n    an error matching ErrNotSupported.\n\nfunc (c *ResponseController) EnableFullDuplex() error\n    EnableFullDuplex indicates that the request handler will interleave reads\n    from [Request.Body] with writes to the ResponseWriter.\n\n    For HTTP/1 requests, the Go HTTP server by default consumes any unread\n    portion of the request body before beginning to write the response,\n    preventing handlers from concurrently reading from the request and writing\n    the response. Calling EnableFullDuplex disables this behavior and permits\n    handlers to continue to read from the request while concurrently writing the\n    response.\n\n    For HTTP/2 requests, the Go HTTP server always permits concurrent reads and\n    responses.\n\nfunc (c *ResponseController) Flush() error\n    Flush flushes buffered data to the client.\n\nfunc (c *ResponseController) Hijack() (net.Conn, *bufio.ReadWriter, error)\n    Hijack lets the caller take over the connection. See the Hijacker interface\n    for details.\n\nfunc (c *ResponseController) SetReadDeadline(deadline time.Time) error\n    SetReadDeadline sets the deadline for reading the entire request, including\n    the body. Reads from the request body after the deadline has been exceeded\n    will return an error. A zero value means no deadline.\n\n    Setting the read deadline after it has been exceeded will not extend it.\n\nfunc (c *ResponseController) SetWriteDeadline(deadline time.Time) error\n    SetWriteDeadline sets the deadline for writing the response. Writes to the\n    response body after the deadline has been exceeded will not block, but may\n    succeed if the data has been buffered. A zero value means no deadline.\n\n    Setting the write deadline after it has been exceeded will not extend it.\n\ntype ResponseWriter interface {\n\t// Header returns the header map that will be sent by\n\t// [ResponseWriter.WriteHeader]. The [Header] map also is the mechanism with which\n\t// [Handler] implementations can set HTTP trailers.\n\t//\n\t// Changing the header map after a call to [ResponseWriter.WriteHeader] (or\n\t// [ResponseWriter.Write]) has no effect unless the HTTP status code was of the\n\t// 1xx class or the modified headers are trailers.\n\t//\n\t// There are two ways to set Trailers. The preferred way is to\n\t// predeclare in the headers which trailers you will later\n\t// send by setting the \"Trailer\" header to the names of the\n\t// trailer keys which will come later. In this case, those\n\t// keys of the Header map are treated as if they were\n\t// trailers. See the example. The second way, for trailer\n\t// keys not known to the [Handler] until after the first [ResponseWriter.Write],\n\t// is to prefix the [Header] map keys with the [TrailerPrefix]\n\t// constant value.\n\t//\n\t// To suppress automatic response headers (such as \"Date\"), set\n\t// their value to nil.\n\tHeader() Header\n\n\t// Write writes the data to the connection as part of an HTTP reply.\n\t//\n\t// If [ResponseWriter.WriteHeader] has not yet been called, Write calls\n\t// WriteHeader(http.StatusOK) before writing the data. If the Header\n\t// does not contain a Content-Type line, Write adds a Content-Type set\n\t// to the result of passing the initial 512 bytes of written data to\n\t// [DetectContentType]. Additionally, if the total size of all written\n\t// data is under a few KB and there are no Flush calls, the\n\t// Content-Length header is added automatically.\n\t//\n\t// Depending on the HTTP protocol version and the client, calling\n\t// Write or WriteHeader may prevent future reads on the\n\t// Request.Body. For HTTP/1.x requests, handlers should read any\n\t// needed request body data before writing the response. Once the\n\t// headers have been flushed (due to either an explicit Flusher.Flush\n\t// call or writing enough data to trigger a flush), the request body\n\t// may be unavailable. For HTTP/2 requests, the Go HTTP server permits\n\t// handlers to continue to read the request body while concurrently\n\t// writing the response. However, such behavior may not be supported\n\t// by all HTTP/2 clients. Handlers should read before writing if\n\t// possible to maximize compatibility.\n\tWrite([]byte) (int, error)\n\n\t// WriteHeader sends an HTTP response header with the provided\n\t// status code.\n\t//\n\t// If WriteHeader is not called explicitly, the first call to Write\n\t// will trigger an implicit WriteHeader(http.StatusOK).\n\t// Thus explicit calls to WriteHeader are mainly used to\n\t// send error codes or 1xx informational responses.\n\t//\n\t// The provided code must be a valid HTTP 1xx-5xx status code.\n\t// Any number of 1xx headers may be written, followed by at most\n\t// one 2xx-5xx header. 1xx headers are sent immediately, but 2xx-5xx\n\t// headers may be buffered. Use the Flusher interface to send\n\t// buffered data. The header map is cleared when 2xx-5xx headers are\n\t// sent, but not with 1xx headers.\n\t//\n\t// The server will automatically send a 100 (Continue) header\n\t// on the first read from the request body if the request has\n\t// an \"Expect: 100-continue\" header.\n\tWriteHeader(statusCode int)\n}\n    A ResponseWriter interface is used by an HTTP handler to construct an HTTP\n    response.\n\n    A ResponseWriter may not be used after [Handler.ServeHTTP] has returned.\n\ntype RoundTripper interface {\n\t// RoundTrip executes a single HTTP transaction, returning\n\t// a Response for the provided Request.\n\t//\n\t// RoundTrip should not attempt to interpret the response. In\n\t// particular, RoundTrip must return err == nil if it obtained\n\t// a response, regardless of the response's HTTP status code.\n\t// A non-nil err should be reserved for failure to obtain a\n\t// response. Similarly, RoundTrip should not attempt to\n\t// handle higher-level protocol details such as redirects,\n\t// authentication, or cookies.\n\t//\n\t// RoundTrip should not modify the request, except for\n\t// consuming and closing the Request's Body. RoundTrip may\n\t// read fields of the request in a separate goroutine. Callers\n\t// should not mutate or reuse the request until the Response's\n\t// Body has been closed.\n\t//\n\t// RoundTrip must always close the body, including on errors,\n\t// but depending on the implementation may do so in a separate\n\t// goroutine even after RoundTrip returns. This means that\n\t// callers wanting to reuse the body for subsequent requests\n\t// must arrange to wait for the Close call before doing so.\n\t//\n\t// The Request's URL and Header fields must be initialized.\n\tRoundTrip(*Request) (*Response, error)\n}\n    RoundTripper is an interface representing the ability to execute a single\n    HTTP transaction, obtaining the Response for a given Request.\n\n    A RoundTripper must be safe for concurrent use by multiple goroutines.\n\nvar DefaultTransport RoundTripper = &Transport{\n\tProxy: ProxyFromEnvironment,\n\tDialContext: defaultTransportDialContext(&net.Dialer{\n\t\tTimeout:   30 * time.Second,\n\t\tKeepAlive: 30 * time.Second,\n\t}),\n\tForceAttemptHTTP2:     true,\n\tMaxIdleConns:          100,\n\tIdleConnTimeout:       90 * time.Second,\n\tTLSHandshakeTimeout:   10 * time.Second,\n\tExpectContinueTimeout: 1 * time.Second,\n}\n    DefaultTransport is the default implementation of Transport and is used\n    by DefaultClient. It establishes network connections as needed and caches\n    them for reuse by subsequent calls. It uses HTTP proxies as directed by the\n    environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase\n    versions thereof).\n\nfunc NewFileTransport(fs FileSystem) RoundTripper\n    NewFileTransport returns a new RoundTripper, serving the provided\n    FileSystem. The returned RoundTripper ignores the URL host in its incoming\n    requests, as well as most other properties of the request.\n\n    The typical use case for NewFileTransport is to register the \"file\" protocol\n    with a Transport, as in:\n\n        t := &http.Transport{}\n        t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n        c := &http.Client{Transport: t}\n        res, err := c.Get(\"file:///etc/passwd\")\n        ...\n\nfunc NewFileTransportFS(fsys fs.FS) RoundTripper\n    NewFileTransportFS returns a new RoundTripper, serving the provided file\n    system fsys. The returned RoundTripper ignores the URL host in its incoming\n    requests, as well as most other properties of the request. The files\n    provided by fsys must implement io.Seeker.\n\n    The typical use case for NewFileTransportFS is to register the \"file\"\n    protocol with a Transport, as in:\n\n        fsys := os.DirFS(\"/\")\n        t := &http.Transport{}\n        t.RegisterProtocol(\"file\", http.NewFileTransportFS(fsys))\n        c := &http.Client{Transport: t}\n        res, err := c.Get(\"file:///etc/passwd\")\n        ...\n\ntype SameSite int\n    SameSite allows a server to define a cookie attribute making it impossible\n    for the browser to send this cookie along with cross-site requests.\n    The main goal is to mitigate the risk of cross-origin information leakage,\n    and provide some protection against cross-site request forgery attacks.\n\n    See https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 for\n    details.\n\nconst (\n\tSameSiteDefaultMode SameSite = iota + 1\n\tSameSiteLaxMode\n\tSameSiteStrictMode\n\tSameSiteNoneMode\n)\ntype ServeMux struct {\n\t// Has unexported fields.\n}\n    ServeMux is an HTTP request multiplexer. It matches the URL of each incoming\n    request against a list of registered patterns and calls the handler for the\n    pattern that most closely matches the URL.\n\n    # Patterns\n\n    Patterns can match the method, host and path of a request. Some examples:\n\n      - \"/index.html\" matches the path \"/index.html\" for any host and method.\n      - \"GET /static/\" matches a GET request whose path begins with \"/static/\".\n      - \"example.com/\" matches any request to the host \"example.com\".\n      - \"example.com/{$}\" matches requests with host \"example.com\" and path \"/\".\n      - \"/b/{bucket}/o/{objectname...}\" matches paths whose first segment is \"b\"\n        and whose third segment is \"o\". The name \"bucket\" denotes the second\n        segment and \"objectname\" denotes the remainder of the path.\n\n    In general, a pattern looks like\n\n        [METHOD ][HOST]/[PATH]\n\n    All three parts are optional; \"/\" is a valid pattern. If METHOD is present,\n    it must be followed by at least one space or tab.\n\n    Literal (that is, non-wildcard) parts of a pattern match the corresponding\n    parts of a request case-sensitively.\n\n    A pattern with no method matches every method. A pattern with the method\n    GET matches both GET and HEAD requests. Otherwise, the method must match\n    exactly.\n\n    A pattern with no host matches every host. A pattern with a host matches\n    URLs on that host only.\n\n    A path can include wildcard segments of the form {NAME} or {NAME...}.\n    For example, \"/b/{bucket}/o/{objectname...}\". The wildcard name must be\n    a valid Go identifier. Wildcards must be full path segments: they must be\n    preceded by a slash and followed by either a slash or the end of the string.\n    For example, \"/b_{bucket}\" is not a valid pattern.\n\n    Normally a wildcard matches only a single path segment, ending at the next\n    literal slash (not %2F) in the request URL. But if the \"...\" is present,\n    then the wildcard matches the remainder of the URL path, including slashes.\n    (Therefore it is invalid for a \"...\" wildcard to appear anywhere but at\n    the end of a pattern.) The match for a wildcard can be obtained by calling\n    Request.PathValue with the wildcard's name. A trailing slash in a path acts\n    as an anonymous \"...\" wildcard.\n\n    The special wildcard {$} matches only the end of the URL. For example, the\n    pattern \"/{$}\" matches only the path \"/\", whereas the pattern \"/\" matches\n    every path.\n\n    For matching, both pattern paths and incoming request paths are unescaped\n    segment by segment. So, for example, the path \"/a%2Fb/100%25\" is treated as\n    having two segments, \"a/b\" and \"100%\". The pattern \"/a%2fb/\" matches it,\n    but the pattern \"/a/b/\" does not.\n\n    # Precedence\n\n    If two or more patterns match a request, then the most specific pattern\n    takes precedence. A pattern P1 is more specific than P2 if P1 matches a\n    strict subset of P2\u2019s requests; that is, if P2 matches all the requests\n    of P1 and more. If neither is more specific, then the patterns conflict.\n    There is one exception to this rule, for backwards compatibility: if two\n    patterns would otherwise conflict and one has a host while the other does\n    not, then the pattern with the host takes precedence. If a pattern passed to\n    ServeMux.Handle or ServeMux.HandleFunc conflicts with another pattern that\n    is already registered, those functions panic.\n\n    As an example of the general rule, \"/images/thumbnails/\" is more specific\n    than \"/images/\", so both can be registered. The former matches paths\n    beginning with \"/images/thumbnails/\" and the latter will match any other\n    path in the \"/images/\" subtree.\n\n    As another example, consider the patterns \"GET /\" and \"/index.html\":\n    both match a GET request for \"/index.html\", but the former pattern matches\n    all other GET and HEAD requests, while the latter matches any request for\n    \"/index.html\" that uses a different method. The patterns conflict.\n\n    # Trailing-slash redirection\n\n    Consider a ServeMux with a handler for a subtree, registered using a\n    trailing slash or \"...\" wildcard. If the ServeMux receives a request for\n    the subtree root without a trailing slash, it redirects the request by\n    adding the trailing slash. This behavior can be overridden with a separate\n    registration for the path without the trailing slash or \"...\" wildcard. For\n    example, registering \"/images/\" causes ServeMux to redirect a request for\n    \"/images\" to \"/images/\", unless \"/images\" has been registered separately.\n\n    # Request sanitizing\n\n    ServeMux also takes care of sanitizing the URL request path and the Host\n    header, stripping the port number and redirecting any request containing .\n    or .. segments or repeated slashes to an equivalent, cleaner URL. Escaped\n    path elements such as \"%2e\" for \".\" and \"%2f\" for \"/\" are preserved and\n    aren't considered separators for request routing.\n\n    # Compatibility\n\n    The pattern syntax and matching behavior of ServeMux changed significantly\n    in Go 1.22. To restore the old behavior, set the GODEBUG environment\n    variable to \"httpmuxgo121=1\". This setting is read once, at program startup;\n    changes during execution will be ignored.\n\n    The backwards-incompatible changes include:\n      - Wildcards are just ordinary literal path segments in 1.21. For example,\n        the pattern \"/{x}\" will match only that path in 1.21, but will match any\n        one-segment path in 1.22.\n      - In 1.21, no pattern was rejected, unless it was empty or conflicted with\n        an existing pattern. In 1.22, syntactically invalid patterns will cause\n        ServeMux.Handle and ServeMux.HandleFunc to panic. For example, in 1.21,\n        the patterns \"/{\" and \"/a{x}\" match themselves, but in 1.22 they are\n        invalid and will cause a panic when registered.\n      - In 1.22, each segment of a pattern is unescaped; this was not done in\n        1.21. For example, in 1.22 the pattern \"/%61\" matches the path \"/a\"\n        (\"%61\" being the URL escape sequence for \"a\"), but in 1.21 it would\n        match only the path \"/%2561\" (where \"%25\" is the escape for the percent\n        sign).\n      - When matching patterns to paths, in 1.22 each segment of the path is\n        unescaped; in 1.21, the entire path is unescaped. This change mostly\n        affects how paths with %2F escapes adjacent to slashes are treated.\n        See https://go.dev/issue/21955 for details.\n\nfunc NewServeMux() *ServeMux\n    NewServeMux allocates and returns a new ServeMux.\n\nfunc (mux *ServeMux) Handle(pattern string, handler Handler)\n    Handle registers the handler for the given pattern. If the given pattern\n    conflicts with one that is already registered, Handle panics.\n\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))\n    HandleFunc registers the handler function for the given pattern. If the\n    given pattern conflicts with one that is already registered, HandleFunc\n    panics.\n\nfunc (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)\n    Handler returns the handler to use for the given request, consulting\n    r.Method, r.Host, and r.URL.Path. It always returns a non-nil handler.\n    If the path is not in its canonical form, the handler will be an\n    internally-generated handler that redirects to the canonical path. If the\n    host contains a port, it is ignored when matching handlers.\n\n    The path and host are used unchanged for CONNECT requests.\n\n    Handler also returns the registered pattern that matches the request or,\n    in the case of internally-generated redirects, the path that will match\n    after following the redirect.\n\n    If there is no registered handler that applies to the request, Handler\n    returns a \u201cpage not found\u201d or \u201cmethod not supported\u201d handler and an empty\n    pattern.\n\n    Handler does not modify its argument. In particular, it does not populate\n    named path wildcards, so r.PathValue will always return the empty string.\n\nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)\n    ServeHTTP dispatches the request to the handler whose pattern most closely\n    matches the request URL.\n\ntype Server struct {\n\t// Addr optionally specifies the TCP address for the server to listen on,\n\t// in the form \"host:port\". If empty, \":http\" (port 80) is used.\n\t// The service names are defined in RFC 6335 and assigned by IANA.\n\t// See net.Dial for details of the address format.\n\tAddr string\n\n\tHandler Handler // handler to invoke, http.DefaultServeMux if nil\n\n\t// DisableGeneralOptionsHandler, if true, passes \"OPTIONS *\" requests to the Handler,\n\t// otherwise responds with 200 OK and Content-Length: 0.\n\tDisableGeneralOptionsHandler bool\n\n\t// TLSConfig optionally provides a TLS configuration for use\n\t// by ServeTLS and ListenAndServeTLS. Note that this value is\n\t// cloned by ServeTLS and ListenAndServeTLS, so it's not\n\t// possible to modify the configuration with methods like\n\t// tls.Config.SetSessionTicketKeys. To use\n\t// SetSessionTicketKeys, use Server.Serve with a TLS Listener\n\t// instead.\n\tTLSConfig *tls.Config\n\n\t// ReadTimeout is the maximum duration for reading the entire\n\t// request, including the body. A zero or negative value means\n\t// there will be no timeout.\n\t//\n\t// Because ReadTimeout does not let Handlers make per-request\n\t// decisions on each request body's acceptable deadline or\n\t// upload rate, most users will prefer to use\n\t// ReadHeaderTimeout. It is valid to use them both.\n\tReadTimeout time.Duration\n\n\t// ReadHeaderTimeout is the amount of time allowed to read\n\t// request headers. The connection's read deadline is reset\n\t// after reading the headers and the Handler can decide what\n\t// is considered too slow for the body. If zero, the value of\n\t// ReadTimeout is used. If negative, or if zero and ReadTimeout\n\t// is zero or negative, there is no timeout.\n\tReadHeaderTimeout time.Duration\n\n\t// WriteTimeout is the maximum duration before timing out\n\t// writes of the response. It is reset whenever a new\n\t// request's header is read. Like ReadTimeout, it does not\n\t// let Handlers make decisions on a per-request basis.\n\t// A zero or negative value means there will be no timeout.\n\tWriteTimeout time.Duration\n\n\t// IdleTimeout is the maximum amount of time to wait for the\n\t// next request when keep-alives are enabled. If zero, the value\n\t// of ReadTimeout is used. If negative, or if zero and ReadTimeout\n\t// is zero or negative, there is no timeout.\n\tIdleTimeout time.Duration\n\n\t// MaxHeaderBytes controls the maximum number of bytes the\n\t// server will read parsing the request header's keys and\n\t// values, including the request line. It does not limit the\n\t// size of the request body.\n\t// If zero, DefaultMaxHeaderBytes is used.\n\tMaxHeaderBytes int\n\n\t// TLSNextProto optionally specifies a function to take over\n\t// ownership of the provided TLS connection when an ALPN\n\t// protocol upgrade has occurred. The map key is the protocol\n\t// name negotiated. The Handler argument should be used to\n\t// handle HTTP requests and will initialize the Request's TLS\n\t// and RemoteAddr if not already set. The connection is\n\t// automatically closed when the function returns.\n\t// If TLSNextProto is not nil, HTTP/2 support is not enabled\n\t// automatically.\n\tTLSNextProto map[string]func(*Server, *tls.Conn, Handler)\n\n\t// ConnState specifies an optional callback function that is\n\t// called when a client connection changes state. See the\n\t// ConnState type and associated constants for details.\n\tConnState func(net.Conn, ConnState)\n\n\t// ErrorLog specifies an optional logger for errors accepting\n\t// connections, unexpected behavior from handlers, and\n\t// underlying FileSystem errors.\n\t// If nil, logging is done via the log package's standard logger.\n\tErrorLog *log.Logger\n\n\t// BaseContext optionally specifies a function that returns\n\t// the base context for incoming requests on this server.\n\t// The provided Listener is the specific Listener that's\n\t// about to start accepting requests.\n\t// If BaseContext is nil, the default is context.Background().\n\t// If non-nil, it must return a non-nil context.\n\tBaseContext func(net.Listener) context.Context\n\n\t// ConnContext optionally specifies a function that modifies\n\t// the context used for a new connection c. The provided ctx\n\t// is derived from the base context and has a ServerContextKey\n\t// value.\n\tConnContext func(ctx context.Context, c net.Conn) context.Context\n\n\t// HTTP2 configures HTTP/2 connections.\n\t//\n\t// This field does not yet have any effect.\n\t// See https://go.dev/issue/67813.\n\tHTTP2 *HTTP2Config\n\n\t// Protocols is the set of protocols accepted by the server.\n\t//\n\t// If Protocols includes UnencryptedHTTP2, the server will accept\n\t// unencrypted HTTP/2 connections. The server can serve both\n\t// HTTP/1 and unencrypted HTTP/2 on the same address and port.\n\t//\n\t// If Protocols is nil, the default is usually HTTP/1 and HTTP/2.\n\t// If TLSNextProto is non-nil and does not contain an \"h2\" entry,\n\t// the default is HTTP/1 only.\n\tProtocols *Protocols\n\n\t// Has unexported fields.\n}\n    A Server defines parameters for running an HTTP server. The zero value for\n    Server is a valid configuration.\n\nfunc (s *Server) Close() error\n    Close immediately closes all active net.Listeners and any connections\n    in state StateNew, StateActive, or StateIdle. For a graceful shutdown,\n    use Server.Shutdown.\n\n    Close does not attempt to close (and does not even know about) any hijacked\n    connections, such as WebSockets.\n\n    Close returns any error returned from closing the Server's underlying\n    Listener(s).\n\nfunc (s *Server) ListenAndServe() error\n    ListenAndServe listens on the TCP network address s.Addr and then calls\n    Serve to handle requests on incoming connections. Accepted connections are\n    configured to enable TCP keep-alives.\n\n    If s.Addr is blank, \":http\" is used.\n\n    ListenAndServe always returns a non-nil error. After Server.Shutdown or\n    Server.Close, the returned error is ErrServerClosed.\n\nfunc (s *Server) ListenAndServeTLS(certFile, keyFile string) error\n    ListenAndServeTLS listens on the TCP network address s.Addr and then\n    calls ServeTLS to handle requests on incoming TLS connections. Accepted\n    connections are configured to enable TCP keep-alives.\n\n    Filenames containing a certificate and matching private key for the\n    server must be provided if neither the Server's TLSConfig.Certificates nor\n    TLSConfig.GetCertificate are populated. If the certificate is signed by\n    a certificate authority, the certFile should be the concatenation of the\n    server's certificate, any intermediates, and the CA's certificate.\n\n    If s.Addr is blank, \":https\" is used.\n\n    ListenAndServeTLS always returns a non-nil error. After Server.Shutdown or\n    Server.Close, the returned error is ErrServerClosed.\n\nfunc (s *Server) RegisterOnShutdown(f func())\n    RegisterOnShutdown registers a function to call on Server.Shutdown.\n    This can be used to gracefully shutdown connections that have undergone\n    ALPN protocol upgrade or that have been hijacked. This function should start\n    protocol-specific graceful shutdown, but should not wait for shutdown to\n    complete.\n\nfunc (s *Server) Serve(l net.Listener) error\n    Serve accepts incoming connections on the Listener l, creating a new service\n    goroutine for each. The service goroutines read requests and then call\n    s.Handler to reply to them.\n\n    HTTP/2 support is only enabled if the Listener returns *tls.Conn connections\n    and they were configured with \"h2\" in the TLS Config.NextProtos.\n\n    Serve always returns a non-nil error and closes l. After Server.Shutdown or\n    Server.Close, the returned error is ErrServerClosed.\n\nfunc (s *Server) ServeTLS(l net.Listener, certFile, keyFile string) error\n    ServeTLS accepts incoming connections on the Listener l, creating a new\n    service goroutine for each. The service goroutines perform TLS setup and\n    then read requests, calling s.Handler to reply to them.\n\n    Files containing a certificate and matching private key for the server\n    must be provided if neither the Server's TLSConfig.Certificates,\n    TLSConfig.GetCertificate nor config.GetConfigForClient are populated.\n    If the certificate is signed by a certificate authority, the certFile\n    should be the concatenation of the server's certificate, any intermediates,\n    and the CA's certificate.\n\n    ServeTLS always returns a non-nil error. After Server.Shutdown or\n    Server.Close, the returned error is ErrServerClosed.\n\nfunc (s *Server) SetKeepAlivesEnabled(v bool)\n    SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled.\n    By default, keep-alives are always enabled. Only very resource-constrained\n    environments or servers in the process of shutting down should disable them.\n\nfunc (s *Server) Shutdown(ctx context.Context) error\n    Shutdown gracefully shuts down the server without interrupting any active\n    connections. Shutdown works by first closing all open listeners, then\n    closing all idle connections, and then waiting indefinitely for connections\n    to return to idle and then shut down. If the provided context expires before\n    the shutdown is complete, Shutdown returns the context's error, otherwise it\n    returns any error returned from closing the Server's underlying Listener(s).\n\n    When Shutdown is called, Serve, ServeTLS, ListenAndServe, and\n    ListenAndServeTLS immediately return ErrServerClosed. Make sure the program\n    doesn't exit and waits instead for Shutdown to return.\n\n    Shutdown does not attempt to close nor wait for hijacked connections\n    such as WebSockets. The caller of Shutdown should separately notify such\n    long-lived connections of shutdown and wait for them to close, if desired.\n    See Server.RegisterOnShutdown for a way to register shutdown notification\n    functions.\n\n    Once Shutdown has been called on a server, it may not be reused; future\n    calls to methods such as Serve will return ErrServerClosed.\n\ntype Transport struct {\n\n\t// Proxy specifies a function to return a proxy for a given\n\t// Request. If the function returns a non-nil error, the\n\t// request is aborted with the provided error.\n\t//\n\t// The proxy type is determined by the URL scheme. \"http\",\n\t// \"https\", \"socks5\", and \"socks5h\" are supported. If the scheme is empty,\n\t// \"http\" is assumed.\n\t// \"socks5\" is treated the same as \"socks5h\".\n\t//\n\t// If the proxy URL contains a userinfo subcomponent,\n\t// the proxy request will pass the username and password\n\t// in a Proxy-Authorization header.\n\t//\n\t// If Proxy is nil or returns a nil *URL, no proxy is used.\n\tProxy func(*Request) (*url.URL, error)\n\n\t// OnProxyConnectResponse is called when the Transport gets an HTTP response from\n\t// a proxy for a CONNECT request. It's called before the check for a 200 OK response.\n\t// If it returns an error, the request fails with that error.\n\tOnProxyConnectResponse func(ctx context.Context, proxyURL *url.URL, connectReq *Request, connectRes *Response) error\n\n\t// DialContext specifies the dial function for creating unencrypted TCP connections.\n\t// If DialContext is nil (and the deprecated Dial below is also nil),\n\t// then the transport dials using package net.\n\t//\n\t// DialContext runs concurrently with calls to RoundTrip.\n\t// A RoundTrip call that initiates a dial may end up using\n\t// a connection dialed previously when the earlier connection\n\t// becomes idle before the later DialContext completes.\n\tDialContext func(ctx context.Context, network, addr string) (net.Conn, error)\n\n\t// Dial specifies the dial function for creating unencrypted TCP connections.\n\t//\n\t// Dial runs concurrently with calls to RoundTrip.\n\t// A RoundTrip call that initiates a dial may end up using\n\t// a connection dialed previously when the earlier connection\n\t// becomes idle before the later Dial completes.\n\t//\n\t// Deprecated: Use DialContext instead, which allows the transport\n\t// to cancel dials as soon as they are no longer needed.\n\t// If both are set, DialContext takes priority.\n\tDial func(network, addr string) (net.Conn, error)\n\n\t// DialTLSContext specifies an optional dial function for creating\n\t// TLS connections for non-proxied HTTPS requests.\n\t//\n\t// If DialTLSContext is nil (and the deprecated DialTLS below is also nil),\n\t// DialContext and TLSClientConfig are used.\n\t//\n\t// If DialTLSContext is set, the Dial and DialContext hooks are not used for HTTPS\n\t// requests and the TLSClientConfig and TLSHandshakeTimeout\n\t// are ignored. The returned net.Conn is assumed to already be\n\t// past the TLS handshake.\n\tDialTLSContext func(ctx context.Context, network, addr string) (net.Conn, error)\n\n\t// DialTLS specifies an optional dial function for creating\n\t// TLS connections for non-proxied HTTPS requests.\n\t//\n\t// Deprecated: Use DialTLSContext instead, which allows the transport\n\t// to cancel dials as soon as they are no longer needed.\n\t// If both are set, DialTLSContext takes priority.\n\tDialTLS func(network, addr string) (net.Conn, error)\n\n\t// TLSClientConfig specifies the TLS configuration to use with\n\t// tls.Client.\n\t// If nil, the default configuration is used.\n\t// If non-nil, HTTP/2 support may not be enabled by default.\n\tTLSClientConfig *tls.Config\n\n\t// TLSHandshakeTimeout specifies the maximum amount of time to\n\t// wait for a TLS handshake. Zero means no timeout.\n\tTLSHandshakeTimeout time.Duration\n\n\t// DisableKeepAlives, if true, disables HTTP keep-alives and\n\t// will only use the connection to the server for a single\n\t// HTTP request.\n\t//\n\t// This is unrelated to the similarly named TCP keep-alives.\n\tDisableKeepAlives bool\n\n\t// DisableCompression, if true, prevents the Transport from\n\t// requesting compression with an \"Accept-Encoding: gzip\"\n\t// request header when the Request contains no existing\n\t// Accept-Encoding value. If the Transport requests gzip on\n\t// its own and gets a gzipped response, it's transparently\n\t// decoded in the Response.Body. However, if the user\n\t// explicitly requested gzip it is not automatically\n\t// uncompressed.\n\tDisableCompression bool\n\n\t// MaxIdleConns controls the maximum number of idle (keep-alive)\n\t// connections across all hosts. Zero means no limit.\n\tMaxIdleConns int\n\n\t// MaxIdleConnsPerHost, if non-zero, controls the maximum idle\n\t// (keep-alive) connections to keep per-host. If zero,\n\t// DefaultMaxIdleConnsPerHost is used.\n\tMaxIdleConnsPerHost int\n\n\t// MaxConnsPerHost optionally limits the total number of\n\t// connections per host, including connections in the dialing,\n\t// active, and idle states. On limit violation, dials will block.\n\t//\n\t// Zero means no limit.\n\tMaxConnsPerHost int\n\n\t// IdleConnTimeout is the maximum amount of time an idle\n\t// (keep-alive) connection will remain idle before closing\n\t// itself.\n\t// Zero means no limit.\n\tIdleConnTimeout time.Duration\n\n\t// ResponseHeaderTimeout, if non-zero, specifies the amount of\n\t// time to wait for a server's response headers after fully\n\t// writing the request (including its body, if any). This\n\t// time does not include the time to read the response body.\n\tResponseHeaderTimeout time.Duration\n\n\t// ExpectContinueTimeout, if non-zero, specifies the amount of\n\t// time to wait for a server's first response headers after fully\n\t// writing the request headers if the request has an\n\t// \"Expect: 100-continue\" header. Zero means no timeout and\n\t// causes the body to be sent immediately, without\n\t// waiting for the server to approve.\n\t// This time does not include the time to send the request header.\n\tExpectContinueTimeout time.Duration\n\n\t// TLSNextProto specifies how the Transport switches to an\n\t// alternate protocol (such as HTTP/2) after a TLS ALPN\n\t// protocol negotiation. If Transport dials a TLS connection\n\t// with a non-empty protocol name and TLSNextProto contains a\n\t// map entry for that key (such as \"h2\"), then the func is\n\t// called with the request's authority (such as \"example.com\"\n\t// or \"example.com:1234\") and the TLS connection. The function\n\t// must return a RoundTripper that then handles the request.\n\t// If TLSNextProto is not nil, HTTP/2 support is not enabled\n\t// automatically.\n\tTLSNextProto map[string]func(authority string, c *tls.Conn) RoundTripper\n\n\t// ProxyConnectHeader optionally specifies headers to send to\n\t// proxies during CONNECT requests.\n\t// To set the header dynamically, see GetProxyConnectHeader.\n\tProxyConnectHeader Header\n\n\t// GetProxyConnectHeader optionally specifies a func to return\n\t// headers to send to proxyURL during a CONNECT request to the\n\t// ip:port target.\n\t// If it returns an error, the Transport's RoundTrip fails with\n\t// that error. It can return (nil, nil) to not add headers.\n\t// If GetProxyConnectHeader is non-nil, ProxyConnectHeader is\n\t// ignored.\n\tGetProxyConnectHeader func(ctx context.Context, proxyURL *url.URL, target string) (Header, error)\n\n\t// MaxResponseHeaderBytes specifies a limit on how many\n\t// response bytes are allowed in the server's response\n\t// header.\n\t//\n\t// Zero means to use a default limit.\n\tMaxResponseHeaderBytes int64\n\n\t// WriteBufferSize specifies the size of the write buffer used\n\t// when writing to the transport.\n\t// If zero, a default (currently 4KB) is used.\n\tWriteBufferSize int\n\n\t// ReadBufferSize specifies the size of the read buffer used\n\t// when reading from the transport.\n\t// If zero, a default (currently 4KB) is used.\n\tReadBufferSize int\n\n\t// ForceAttemptHTTP2 controls whether HTTP/2 is enabled when a non-zero\n\t// Dial, DialTLS, or DialContext func or TLSClientConfig is provided.\n\t// By default, use of any those fields conservatively disables HTTP/2.\n\t// To use a custom dialer or TLS config and still attempt HTTP/2\n\t// upgrades, set this to true.\n\tForceAttemptHTTP2 bool\n\n\t// HTTP2 configures HTTP/2 connections.\n\t//\n\t// This field does not yet have any effect.\n\t// See https://go.dev/issue/67813.\n\tHTTP2 *HTTP2Config\n\n\t// Protocols is the set of protocols supported by the transport.\n\t//\n\t// If Protocols includes UnencryptedHTTP2 and does not include HTTP1,\n\t// the transport will use unencrypted HTTP/2 for requests for http:// URLs.\n\t//\n\t// If Protocols is nil, the default is usually HTTP/1 only.\n\t// If ForceAttemptHTTP2 is true, or if TLSNextProto contains an \"h2\" entry,\n\t// the default is HTTP/1 and HTTP/2.\n\tProtocols *Protocols\n\t// Has unexported fields.\n}\n    Transport is an implementation of RoundTripper that supports HTTP, HTTPS,\n    and HTTP proxies (for either HTTP or HTTPS with CONNECT).\n\n    By default, Transport caches connections for future re-use. This may\n    leave many open connections when accessing many hosts. This behavior\n    can be managed using Transport.CloseIdleConnections method and the\n    [Transport.MaxIdleConnsPerHost] and [Transport.DisableKeepAlives] fields.\n\n    Transports should be reused instead of created as needed. Transports are\n    safe for concurrent use by multiple goroutines.\n\n    A Transport is a low-level primitive for making HTTP and HTTPS requests.\n    For high-level functionality, such as cookies and redirects, see Client.\n\n    Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for\n    HTTPS URLs, depending on whether the server supports HTTP/2, and how the\n    Transport is configured. The DefaultTransport supports HTTP/2. To explicitly\n    enable HTTP/2 on a transport, set [Transport.Protocols].\n\n    Responses with status codes in the 1xx range are either handled\n    automatically (100 expect-continue) or ignored. The one exception is HTTP\n    status code 101 (Switching Protocols), which is considered a terminal status\n    and returned by Transport.RoundTrip. To see the ignored 1xx responses,\n    use the httptrace trace package's ClientTrace.Got1xxResponse.\n\n    Transport only retries a request upon encountering a network error if the\n    connection has been already been used successfully and if the request is\n    idempotent and either has no body or has its [Request.GetBody] defined.\n    HTTP requests are considered idempotent if they have HTTP methods GET, HEAD,\n    OPTIONS, or TRACE; or if their Header map contains an \"Idempotency-Key\" or\n    \"X-Idempotency-Key\" entry. If the idempotency key value is a zero-length\n    slice, the request is treated as idempotent but the header is not sent on\n    the wire.\n\nfunc (t *Transport) CancelRequest(req *Request)\n    CancelRequest cancels an in-flight request by closing its connection.\n    CancelRequest should only be called after Transport.RoundTrip has returned.\n\n    Deprecated: Use Request.WithContext to create a request with a cancelable\n    context instead. CancelRequest cannot cancel HTTP/2 requests. This may\n    become a no-op in a future release of Go.\n\nfunc (t *Transport) Clone() *Transport\n    Clone returns a deep copy of t's exported fields.\n\nfunc (t *Transport) CloseIdleConnections()\n    CloseIdleConnections closes any connections which were previously connected\n    from previous requests but are now sitting idle in a \"keep-alive\" state.\n    It does not interrupt any connections currently in use.\n\nfunc (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)\n    RegisterProtocol registers a new protocol with scheme. The Transport will\n    pass requests using the given scheme to rt. It is rt's responsibility to\n    simulate HTTP request semantics.\n\n    RegisterProtocol can be used by other packages to provide implementations of\n    protocol schemes like \"ftp\" or \"file\".\n\n    If rt.RoundTrip returns ErrSkipAltProtocol, the Transport will handle the\n    Transport.RoundTrip itself for that one request, as if the protocol were not\n    registered.\n\nfunc (t *Transport) RoundTrip(req *Request) (*Response, error)\n    RoundTrip implements the RoundTripper interface.\n\n    For higher-level HTTP client support (such as handling of cookies and\n    redirects), see Get, Post, and the Client type.\n\n    Like the RoundTripper interface, the error types returned by RoundTrip are\n    unspecified.\n\n"}, {"path": "stdlib/weak.md", "category": "stdlib", "name": "stdlib/weak", "content": "package weak // import \"weak\"\n\nPackage weak provides ways to safely reference memory weakly, that is, without\npreventing its reclamation.\n\nTYPES\n\ntype Pointer[T any] struct {\n\t// Has unexported fields.\n}\n    Pointer is a weak pointer to a value of type T.\n\n    Just like regular pointers, Pointer may reference any part of an object,\n    such as a field of a struct or an element of an array. Objects that are\n    only pointed to by weak pointers are not considered reachable, and once the\n    object becomes unreachable, Pointer.Value may return nil.\n\n    The primary use-cases for weak pointers are for implementing caches,\n    canonicalization maps (like the unique package), and for tying together the\n    lifetimes of separate values (for example, through a map with weak keys).\n\n    Two Pointer values compare equal if and only if the pointers from which\n    they were created compare equal. This property is maintained even after\n    the object referenced by the pointer used to create a weak reference\n    is reclaimed. If multiple weak pointers are made to different offsets\n    within the same object (for example, pointers to different fields of\n    the same struct), those pointers will not compare equal. In other words,\n    weak pointers map to objects and offsets within those objects, not plain\n    addresses. If a weak pointer is created from an object that becomes\n    unreachable, but is then resurrected due to a finalizer, that weak pointer\n    will not compare equal with weak pointers created after the resurrection.\n\n    Calling Make with a nil pointer returns a weak pointer whose Pointer.Value\n    always returns nil. The zero value of a Pointer behaves as if it were\n    created by passing nil to Make and compares equal with such pointers.\n\n    Pointer.Value is not guaranteed to eventually return nil. Pointer.Value\n    may return nil as soon as the object becomes unreachable. Values stored\n    in global variables, or that can be found by tracing pointers from a\n    global variable, are reachable. A function argument or receiver may become\n    unreachable at the last point where the function mentions it. To ensure\n    Pointer.Value does not return nil, pass a pointer to the object to the\n    runtime.KeepAlive function after the last point where the object must remain\n    reachable.\n\n    Note that because Pointer.Value is not guaranteed to eventually return nil,\n    even after an object is no longer referenced, the runtime is allowed to\n    perform a space-saving optimization that batches objects together in a\n    single allocation slot. The weak pointer for an unreferenced object in such\n    an allocation may never become nil if it always exists in the same batch as\n    a referenced object. Typically, this batching only happens for tiny (on the\n    order of 16 bytes or less) and pointer-free objects.\n\nfunc Make[T any](ptr *T) Pointer[T]\n    Make creates a weak pointer from a pointer to some value of type T.\n\nfunc (p Pointer[T]) Value() *T\n    Value returns the original pointer used to create the weak pointer.\n    It returns nil if the value pointed to by the original pointer was reclaimed\n    by the garbage collector. If a weak pointer points to an object with a\n    finalizer, then Value will return nil as soon as the object's finalizer is\n    queued for execution.\n\n"}, {"path": "stdlib/hash-adler32.md", "category": "stdlib", "name": "stdlib/hash-adler32", "content": "package adler32 // import \"hash/adler32\"\n\nPackage adler32 implements the Adler-32 checksum.\n\nIt is defined in RFC 1950:\n\n    Adler-32 is composed of two sums accumulated per byte: s1 is\n    the sum of all bytes, s2 is the sum of all s1 values. Both sums\n    are done modulo 65521. s1 is initialized to 1, s2 to zero.  The\n    Adler-32 checksum is stored as s2*65536 + s1 in most-\n    significant-byte first (network) order.\n\nCONSTANTS\n\nconst Size = 4\n    The size of an Adler-32 checksum in bytes.\n\n\nFUNCTIONS\n\nfunc Checksum(data []byte) uint32\n    Checksum returns the Adler-32 checksum of data.\n\nfunc New() hash.Hash32\n    New returns a new hash.Hash32 computing the Adler-32 checksum. Its Sum\n    method will lay the value out in big-endian byte order. The returned Hash32\n    also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\n    marshal and unmarshal the internal state of the hash.\n\n"}, {"path": "stdlib/internal-lazytemplate.md", "category": "stdlib", "name": "stdlib/internal-lazytemplate", "content": "package lazytemplate // import \"internal/lazytemplate\"\n\nPackage lazytemplate is a thin wrapper over text/template, allowing the use of\nglobal template variables without forcing them to be parsed at init.\n\nTYPES\n\ntype Template struct {\n\t// Has unexported fields.\n}\n    Template is a wrapper around text/template.Template, where the underlying\n    template will be parsed the first time it is needed.\n\nfunc New(name, text string) *Template\n    New creates a new lazy template, delaying the parsing work until it is first\n    needed. If the code is being run as part of tests, the template parsing will\n    happen immediately.\n\nfunc (r *Template) Execute(w io.Writer, data any) error\n\n"}, {"path": "stdlib/io-ioutil.md", "category": "stdlib", "name": "stdlib/io-ioutil", "content": "package ioutil // import \"io/ioutil\"\n\nPackage ioutil implements some I/O utility functions.\n\nDeprecated: As of Go 1.16, the same functionality is now provided by package\nio or package os, and those implementations should be preferred in new code.\nSee the specific function documentation for details.\n\nVARIABLES\n\nvar Discard io.Writer = io.Discard\n    Discard is an io.Writer on which all Write calls succeed without doing\n    anything.\n\n    Deprecated: As of Go 1.16, this value is simply io.Discard.\n\n\nFUNCTIONS\n\nfunc NopCloser(r io.Reader) io.ReadCloser\n    NopCloser returns a ReadCloser with a no-op Close method wrapping the\n    provided Reader r.\n\n    Deprecated: As of Go 1.16, this function simply calls io.NopCloser.\n\nfunc ReadAll(r io.Reader) ([]byte, error)\n    ReadAll reads from r until an error or EOF and returns the data it read.\n    A successful call returns err == nil, not err == EOF. Because ReadAll is\n    defined to read from src until EOF, it does not treat an EOF from Read as an\n    error to be reported.\n\n    Deprecated: As of Go 1.16, this function simply calls io.ReadAll.\n\nfunc ReadDir(dirname string) ([]fs.FileInfo, error)\n    ReadDir reads the directory named by dirname and returns a list of\n    fs.FileInfo for the directory's contents, sorted by filename. If an error\n    occurs reading the directory, ReadDir returns no directory entries along\n    with the error.\n\n    Deprecated: As of Go 1.16, os.ReadDir is a more efficient and correct\n    choice: it returns a list of fs.DirEntry instead of fs.FileInfo, and it\n    returns partial results in the case of an error midway through reading a\n    directory.\n\n    If you must continue obtaining a list of fs.FileInfo, you still can:\n\n        entries, err := os.ReadDir(dirname)\n        if err != nil { ... }\n        infos := make([]fs.FileInfo, 0, len(entries))\n        for _, entry := range entries {\n        \tinfo, err := entry.Info()\n        \tif err != nil { ... }\n        \tinfos = append(infos, info)\n        }\n\nfunc ReadFile(filename string) ([]byte, error)\n    ReadFile reads the file named by filename and returns the contents.\n    A successful call returns err == nil, not err == EOF. Because ReadFile\n    reads the whole file, it does not treat an EOF from Read as an error to be\n    reported.\n\n    Deprecated: As of Go 1.16, this function simply calls os.ReadFile.\n\nfunc TempDir(dir, pattern string) (name string, err error)\n    TempDir creates a new temporary directory in the directory dir.\n    The directory name is generated by taking pattern and applying a random\n    string to the end. If pattern includes a \"*\", the random string replaces\n    the last \"*\". TempDir returns the name of the new directory. If dir is the\n    empty string, TempDir uses the default directory for temporary files (see\n    os.TempDir). Multiple programs calling TempDir simultaneously will not\n    choose the same directory. It is the caller's responsibility to remove the\n    directory when no longer needed.\n\n    Deprecated: As of Go 1.17, this function simply calls os.MkdirTemp.\n\nfunc TempFile(dir, pattern string) (f *os.File, err error)\n    TempFile creates a new temporary file in the directory dir, opens the file\n    for reading and writing, and returns the resulting *os.File. The filename\n    is generated by taking pattern and adding a random string to the end.\n    If pattern includes a \"*\", the random string replaces the last \"*\". If dir\n    is the empty string, TempFile uses the default directory for temporary files\n    (see os.TempDir). Multiple programs calling TempFile simultaneously will\n    not choose the same file. The caller can use f.Name() to find the pathname\n    of the file. It is the caller's responsibility to remove the file when no\n    longer needed.\n\n    Deprecated: As of Go 1.17, this function simply calls os.CreateTemp.\n\nfunc WriteFile(filename string, data []byte, perm fs.FileMode) error\n    WriteFile writes data to a file named by filename. If the file does not\n    exist, WriteFile creates it with permissions perm (before umask); otherwise\n    WriteFile truncates it before writing, without changing permissions.\n\n    Deprecated: As of Go 1.16, this function simply calls os.WriteFile.\n\n"}, {"path": "stdlib/go-parser.md", "category": "stdlib", "name": "stdlib/go-parser", "content": "package parser // import \"go/parser\"\n\nPackage parser implements a parser for Go source files.\n\nThe ParseFile function reads file input from a string, []byte, or io.Reader, and\nproduces an ast.File representing the complete abstract syntax tree of the file.\n\nThe ParseExprFrom function reads a single source-level expression and produces\nan ast.Expr, the syntax tree of the expression.\n\nThe parser accepts a larger language than is syntactically permitted by the Go\nspec, for simplicity, and for improved robustness in the presence of syntax\nerrors. For instance, in method declarations, the receiver is treated like\nan ordinary parameter list and thus may contain multiple entries where the\nspec permits exactly one. Consequently, the corresponding field in the AST\n(ast.FuncDecl.Recv) field is not restricted to one entry.\n\nApplications that need to parse one or more complete packages of Go source code\nmay find it more convenient not to interact directly with the parser but instead\nto use the Load function in package golang.org/x/tools/go/packages.\n\nFUNCTIONS\n\nfunc ParseDir(fset *token.FileSet, path string, filter func(fs.FileInfo) bool, mode Mode) (pkgs map[string]*ast.Package, first error)\n    ParseDir calls ParseFile for all files with names ending in \".go\" in the\n    directory specified by path and returns a map of package name -> package AST\n    with all the packages found.\n\n    If filter != nil, only the files with fs.FileInfo entries passing through\n    the filter (and ending in \".go\") are considered. The mode bits are passed\n    to ParseFile unchanged. Position information is recorded in fset, which must\n    not be nil.\n\n    If the directory couldn't be read, a nil map and the respective error are\n    returned. If a parse error occurred, a non-nil but incomplete map and the\n    first error encountered are returned.\n\n    Deprecated: ParseDir does not consider build tags when associating files\n    with packages. For precise information about the relationship between\n    packages and files, use golang.org/x/tools/go/packages, which can also\n    optionally parse and type-check the files too.\n\nfunc ParseExpr(x string) (ast.Expr, error)\n    ParseExpr is a convenience function for obtaining the AST of an expression\n    x. The position information recorded in the AST is undefined. The filename\n    used in error messages is the empty string.\n\n    If syntax errors were found, the result is a partial AST (with ast.Bad*\n    nodes representing the fragments of erroneous source code). Multiple errors\n    are returned via a scanner.ErrorList which is sorted by source position.\n\nfunc ParseExprFrom(fset *token.FileSet, filename string, src any, mode Mode) (expr ast.Expr, err error)\n    ParseExprFrom is a convenience function for parsing an expression.\n    The arguments have the same meaning as for ParseFile, but the source must be\n    a valid Go (type or value) expression. Specifically, fset must not be nil.\n\n    If the source couldn't be read, the returned AST is nil and the error\n    indicates the specific failure. If the source was read but syntax errors\n    were found, the result is a partial AST (with ast.Bad* nodes representing\n    the fragments of erroneous source code). Multiple errors are returned via a\n    scanner.ErrorList which is sorted by source position.\n\nfunc ParseFile(fset *token.FileSet, filename string, src any, mode Mode) (f *ast.File, err error)\n    ParseFile parses the source code of a single Go source file and returns\n    the corresponding ast.File node. The source code may be provided via the\n    filename of the source file, or via the src parameter.\n\n    If src != nil, ParseFile parses the source from src and the filename is\n    only used when recording position information. The type of the argument\n    for the src parameter must be string, []byte, or io.Reader. If src == nil,\n    ParseFile parses the file specified by filename.\n\n    The mode parameter controls the amount of source text parsed and other\n    optional parser functionality. If the SkipObjectResolution mode bit is set\n    (recommended), the object resolution phase of parsing will be skipped,\n    causing File.Scope, File.Unresolved, and all Ident.Obj fields to be nil.\n    Those fields are deprecated; see ast.Object for details.\n\n    Position information is recorded in the file set fset, which must not be\n    nil.\n\n    If the source couldn't be read, the returned AST is nil and the error\n    indicates the specific failure. If the source was read but syntax errors\n    were found, the result is a partial AST (with ast.Bad* nodes representing\n    the fragments of erroneous source code). Multiple errors are returned via a\n    scanner.ErrorList which is sorted by source position.\n\n\nTYPES\n\ntype Mode uint\n    A Mode value is a set of flags (or 0). They control the amount of source\n    code parsed and other optional parser functionality.\n\nconst (\n\tPackageClauseOnly    Mode             = 1 << iota // stop parsing after package clause\n\tImportsOnly                                       // stop parsing after import declarations\n\tParseComments                                     // parse comments and add them to AST\n\tTrace                                             // print a trace of parsed productions\n\tDeclarationErrors                                 // report declaration errors\n\tSpuriousErrors                                    // same as AllErrors, for backward-compatibility\n\tSkipObjectResolution                              // skip deprecated identifier resolution; see ParseFile\n\tAllErrors            = SpuriousErrors             // report all errors (not just the first 10 on different lines)\n)\n"}, {"path": "stdlib/crypto-internal-fips140-aes-gcm.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-aes-gcm", "content": "package gcm // import \"crypto/internal/fips140/aes/gcm\"\n\n\nFUNCTIONS\n\nfunc GHASH(key *[16]byte, inputs ...[]byte) []byte\n    GHASH is exposed to allow crypto/cipher to implement non-AES GCM modes.\n    It is not allowed as a stand-alone operation in FIPS mode because it is not\n    ACVP tested.\n\nfunc SealWithRandomNonce(g *GCM, nonce, out, plaintext, additionalData []byte)\n    SealWithRandomNonce encrypts plaintext to out, and writes a random\n    nonce to nonce. nonce must be 12 bytes, and out must be 16 bytes longer\n    than plaintext. out and plaintext may overlap exactly or not at all.\n    additionalData and out must not overlap.\n\n    This complies with FIPS 140-3 IG C.H Scenario 2.\n\n    Note that this is NOT a [cipher.AEAD].Seal method.\n\n\nTYPES\n\ntype CMAC struct {\n\t// Has unexported fields.\n}\n    CMAC implements the CMAC mode from NIST SP 800-38B.\n\n    It is optimized for use in Counter KDF (SP 800-108r1) and XAES-256-GCM\n    (https://c2sp.org/XAES-256-GCM), rather than for exposing it to applications\n    as a stand-alone MAC.\n\nfunc NewCMAC(b *aes.Block) *CMAC\n\nfunc (c *CMAC) MAC(m []byte) [aes.BlockSize]byte\n\ntype CounterKDF struct {\n\t// Has unexported fields.\n}\n    CounterKDF implements a KDF in Counter Mode instantiated with CMAC-AES,\n    according to NIST SP 800-108 Revision 1 Update 1, Section 4.1.\n\n    It produces a 256-bit output, and accepts a 8-bit Label and a 96-bit\n    Context. It uses a counter of 16 bits placed before the fixed data. The\n    fixed data is the sequence Label || 0x00 || Context. The L field is omitted,\n    since the output key length is fixed.\n\n    It's optimized for use in XAES-256-GCM (https://c2sp.org/XAES-256-GCM),\n    rather than for exposing it to applications as a stand-alone KDF.\n\nfunc NewCounterKDF(b *aes.Block) *CounterKDF\n    NewCounterKDF creates a new CounterKDF with the given key.\n\nfunc (kdf *CounterKDF) DeriveKey(label byte, context [12]byte) [32]byte\n    DeriveKey derives a key from the given label and context.\n\ntype GCM struct {\n\t// Has unexported fields.\n}\n    GCM represents a Galois Counter Mode with a specific key.\n\nfunc New(cipher *aes.Block, nonceSize, tagSize int) (*GCM, error)\n\nfunc (g *GCM) NonceSize() int\n\nfunc (g *GCM) Open(dst, nonce, ciphertext, data []byte) ([]byte, error)\n\nfunc (g *GCM) Overhead() int\n\nfunc (g *GCM) Seal(dst, nonce, plaintext, data []byte) []byte\n\ntype GCMForSSH struct {\n\t// Has unexported fields.\n}\n\nfunc NewGCMForSSH(cipher *aes.Block) (*GCMForSSH, error)\n    NewGCMForSSH returns a new AEAD that works like GCM, but enforces the\n    construction of nonces as specified in RFC 5647.\n\n    This complies with FIPS 140-3 IG C.H Scenario 1.d.\n\nfunc (g *GCMForSSH) NonceSize() int\n\nfunc (g *GCMForSSH) Open(dst, nonce, ciphertext, data []byte) ([]byte, error)\n\nfunc (g *GCMForSSH) Overhead() int\n\nfunc (g *GCMForSSH) Seal(dst, nonce, plaintext, data []byte) []byte\n\ntype GCMForTLS12 struct {\n\t// Has unexported fields.\n}\n\nfunc NewGCMForTLS12(cipher *aes.Block) (*GCMForTLS12, error)\n    NewGCMForTLS12 returns a new AEAD that works like GCM, but enforces the\n    construction of nonces as specified in RFC 5288, Section 3 and RFC 9325,\n    Section 7.2.1.\n\n    This complies with FIPS 140-3 IG C.H Scenario 1.a.\n\nfunc (g *GCMForTLS12) NonceSize() int\n\nfunc (g *GCMForTLS12) Open(dst, nonce, ciphertext, data []byte) ([]byte, error)\n\nfunc (g *GCMForTLS12) Overhead() int\n\nfunc (g *GCMForTLS12) Seal(dst, nonce, plaintext, data []byte) []byte\n\ntype GCMForTLS13 struct {\n\t// Has unexported fields.\n}\n\nfunc NewGCMForTLS13(cipher *aes.Block) (*GCMForTLS13, error)\n    NewGCMForTLS13 returns a new AEAD that works like GCM, but enforces the\n    construction of nonces as specified in RFC 8446, Section 5.3.\n\nfunc (g *GCMForTLS13) NonceSize() int\n\nfunc (g *GCMForTLS13) Open(dst, nonce, ciphertext, data []byte) ([]byte, error)\n\nfunc (g *GCMForTLS13) Overhead() int\n\nfunc (g *GCMForTLS13) Seal(dst, nonce, plaintext, data []byte) []byte\n\ntype GCMWithCounterNonce struct {\n\t// Has unexported fields.\n}\n\nfunc NewGCMWithCounterNonce(cipher *aes.Block) (*GCMWithCounterNonce, error)\n    NewGCMWithCounterNonce returns a new AEAD that works like GCM, but enforces\n    the construction of deterministic nonces. The nonce must be 96 bits,\n    the first 32 bits must be an encoding of the module name, and the last 64\n    bits must be a counter.\n\n    This complies with FIPS 140-3 IG C.H Scenario 3.\n\nfunc (g *GCMWithCounterNonce) NonceSize() int\n\nfunc (g *GCMWithCounterNonce) Open(dst, nonce, ciphertext, data []byte) ([]byte, error)\n\nfunc (g *GCMWithCounterNonce) Overhead() int\n\nfunc (g *GCMWithCounterNonce) Seal(dst, nonce, plaintext, data []byte) []byte\n\n"}, {"path": "stdlib/embed-internal-embedtest.md", "category": "stdlib", "name": "stdlib/embed-internal-embedtest", "content": ""}, {"path": "stdlib/vendor-golang.org-x-text-transform.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-text-transform", "content": ""}, {"path": "stdlib/internal-chacha8rand.md", "category": "stdlib", "name": "stdlib/internal-chacha8rand", "content": "package chacha8rand // import \"internal/chacha8rand\"\n\nPackage chacha8rand implements a pseudorandom generator based on ChaCha8.\nIt is used by both runtime and math/rand/v2 and must have minimal dependencies.\n\nChaCha8 is ChaCha with 8 rounds. See\nhttps://cr.yp.to/chacha/chacha-20080128.pdf.\n\nChaCha8 operates on a 4x4 matrix of uint32 values, initially set to:\n\n    const1 const2 const3 const4\n    seed   seed   seed   seed\n    seed   seed   seed   seed\n    counter64     0      0\n\nWe use the same constants as ChaCha20 does, a random seed, and a counter.\nRunning ChaCha8 on this input produces a 4x4 matrix of pseudo-random values with\nas much entropy as the seed.\n\nGiven SIMD registers that can hold N uint32s, it is possible to run N ChaCha8\nblock transformations in parallel by filling the first register with the N\ncopies of const1, the second with N copies of const2, and so on, and then\nrunning the operations.\n\nEach iteration of ChaCha8Rand operates over 32 bytes of input and produces 992\nbytes of RNG output, plus 32 bytes of input for the next iteration.\n\nThe 32 bytes of input are used as a ChaCha8 key, with a zero nonce, to produce\n1024 bytes of output (16 blocks, with counters 0 to 15). First, for each block,\nthe values 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574 are subtracted from\nthe 32-bit little-endian words at position 0, 1, 2, and 3 respectively, and an\nincreasing counter starting at zero is subtracted from each word at position 12.\nThen, this stream is permuted such that for each sequence of four blocks,\nfirst we output the first four bytes of each block, then the next four bytes\nof each block, and so on. Finally, the last 32 bytes of output are used as the\ninput of the next iteration, and the remaining 992 bytes are the RNG output.\n\nSee https://c2sp.org/chacha8rand for additional details.\n\nNormal ChaCha20 implementations for encryption use this same parallelism\nbut then have to deinterlace the results so that it appears the blocks were\ngenerated separately. For the purposes of generating random numbers, the\ninterlacing is fine. We are simply locked in to preserving the 4-way interlacing\nin any future optimizations.\n\nFUNCTIONS\n\nfunc Marshal(s *State) []byte\n    Marshal marshals the state into a byte slice. Marshal and Unmarshal are\n    functions, not methods, so that they will not be linked into the runtime\n    when it uses the State struct, since the runtime does not need these.\n\nfunc Unmarshal(s *State, data []byte) error\n    Unmarshal unmarshals the state from a byte slice.\n\n\nTYPES\n\ntype State struct {\n\t// Has unexported fields.\n}\n    A State holds the state for a single random generator. It must be used\n    from one goroutine at a time. If used by multiple goroutines at a time,\n    the goroutines may see the same random values, but the code will not crash\n    or cause out-of-bounds memory accesses.\n\nfunc (s *State) Init(seed [32]byte)\n    Init seeds the State with the given seed value.\n\nfunc (s *State) Init64(seed [4]uint64)\n    Init64 seeds the state with the given seed value.\n\nfunc (s *State) Next() (uint64, bool)\n    Next returns the next random value, along with a boolean indicating whether\n    one was available. If one is not available, the caller should call Refill\n    and then repeat the call to Next.\n\n    Next is //go:nosplit to allow its use in the runtime with per-m data without\n    holding the per-m lock.\n\nfunc (s *State) Refill()\n    Refill refills the state with more random values. After a call to Refill,\n    an immediate call to Next will succeed (unless multiple goroutines are\n    incorrectly sharing a state).\n\nfunc (s *State) Reseed()\n    Reseed reseeds the state with new random values. After a call to Reseed,\n    any previously returned random values have been erased from the memory of\n    the state and cannot be recovered.\n\n"}, {"path": "stdlib/net-http-internal-httpcommon.md", "category": "stdlib", "name": "stdlib/net-http-internal-httpcommon", "content": "package httpcommon // import \"net/http/internal/httpcommon\"\n\n\nVARIABLES\n\nvar (\n\tErrRequestHeaderListSize = errors.New(\"request header list larger than peer's advertised limit\")\n)\n\nFUNCTIONS\n\nfunc CachedCanonicalHeader(v string) (string, bool)\n    CachedCanonicalHeader returns the canonical form of a well-known header\n    name.\n\nfunc CanonicalHeader(v string) string\n    CanonicalHeader canonicalizes a header name. (For example, \"host\" becomes\n    \"Host\".)\n\nfunc IsRequestGzip(method string, header map[string][]string, disableCompression bool) bool\n    IsRequestGzip reports whether we should add an Accept-Encoding: gzip header\n    for a request.\n\nfunc LowerHeader(v string) (lower string, ascii bool)\n    LowerHeader returns the lowercase form of a header name, used on the wire\n    for HTTP/2 and HTTP/3 requests.\n\n\nTYPES\n\ntype EncodeHeadersParam struct {\n\tRequest Request\n\n\t// AddGzipHeader indicates that an \"accept-encoding: gzip\" header should be\n\t// added to the request.\n\tAddGzipHeader bool\n\n\t// PeerMaxHeaderListSize, when non-zero, is the peer's MAX_HEADER_LIST_SIZE setting.\n\tPeerMaxHeaderListSize uint64\n\n\t// DefaultUserAgent is the User-Agent header to send when the request\n\t// neither contains a User-Agent nor disables it.\n\tDefaultUserAgent string\n}\n    EncodeHeadersParam is parameters to EncodeHeaders.\n\ntype EncodeHeadersResult struct {\n\tHasBody     bool\n\tHasTrailers bool\n}\n    EncodeHeadersParam is the result of EncodeHeaders.\n\nfunc EncodeHeaders(ctx context.Context, param EncodeHeadersParam, headerf func(name, value string)) (res EncodeHeadersResult, _ error)\n    EncodeHeaders constructs request headers common to HTTP/2 and HTTP/3.\n    It validates a request and calls headerf with each pseudo-header and\n    header for the request. The headerf function is called with the validated,\n    canonicalized header name.\n\ntype Request struct {\n\tURL                 *url.URL\n\tMethod              string\n\tHost                string\n\tHeader              map[string][]string\n\tTrailer             map[string][]string\n\tActualContentLength int64 // 0 means 0, -1 means unknown\n}\n    Request is a subset of http.Request. It'd be simpler to pass an\n    *http.Request, of course, but we can't depend on net/http without creating a\n    dependency cycle.\n\ntype ServerRequestParam struct {\n\tMethod                  string\n\tScheme, Authority, Path string\n\tProtocol                string\n\tHeader                  map[string][]string\n}\n    ServerRequestParam is parameters to NewServerRequest.\n\ntype ServerRequestResult struct {\n\t// Various http.Request fields.\n\tURL        *url.URL\n\tRequestURI string\n\tTrailer    map[string][]string\n\n\tNeedsContinue bool // client provided an \"Expect: 100-continue\" header\n\n\t// If the request should be rejected, this is a short string suitable for passing\n\t// to the http2 package's CountError function.\n\t// It might be a bit odd to return errors this way rather than returing an error,\n\t// but this ensures we don't forget to include a CountError reason.\n\tInvalidReason string\n}\n    ServerRequestResult is the result of NewServerRequest.\n\nfunc NewServerRequest(rp ServerRequestParam) ServerRequestResult\n\n"}, {"path": "stdlib/internal-gover.md", "category": "stdlib", "name": "stdlib/internal-gover", "content": "package gover // import \"internal/gover\"\n\nPackage gover implements support for Go toolchain versions like 1.21.0 and\n1.21rc1. (For historical reasons, Go does not use semver for its toolchains.)\nThis package provides the same basic analysis that golang.org/x/mod/semver does\nfor semver.\n\nThe go/version package should be imported instead of this one when possible.\nNote that this package works on \"1.21\" while go/version works on \"go1.21\".\n\nFUNCTIONS\n\nfunc CmpInt(x, y string) int\n    CmpInt returns cmp.Compare(x, y) interpreting x and y as decimal numbers.\n    (Copied from golang.org/x/mod/semver's compareInt.)\n\nfunc Compare(x, y string) int\n    Compare returns -1, 0, or +1 depending on whether x < y, x == y, or x > y,\n    interpreted as toolchain versions. The versions x and y must not begin with\n    a \"go\" prefix: just \"1.21\" not \"go1.21\". Malformed versions compare less\n    than well-formed versions and equal to each other. The language version\n    \"1.21\" compares less than the release candidate and eventual releases\n    \"1.21rc1\" and \"1.21.0\".\n\nfunc DecInt(decimal string) string\n    DecInt returns the decimal string decremented by 1, or the empty string\n    if the decimal is all zeroes. (Copied from golang.org/x/mod/module's\n    decDecimal.)\n\nfunc IsLang(x string) bool\n    IsLang reports whether v denotes the overall Go language version and not\n    a specific release. Starting with the Go 1.21 release, \"1.x\" denotes the\n    overall language version; the first release is \"1.x.0\". The distinction is\n    important because the relative ordering is\n\n        1.21 < 1.21rc1 < 1.21.0\n\n    meaning that Go 1.21rc1 and Go 1.21.0 will both handle go.mod files that say\n    \"go 1.21\", but Go 1.21rc1 will not handle files that say \"go 1.21.0\".\n\nfunc IsValid(x string) bool\n    IsValid reports whether the version x is valid.\n\nfunc Lang(x string) string\n    Lang returns the Go language version. For example, Lang(\"1.2.3\") == \"1.2\".\n\nfunc Max(x, y string) string\n    Max returns the maximum of x and y interpreted as toolchain versions,\n    compared using Compare. If x and y compare equal, Max returns x.\n\n\nTYPES\n\ntype Version struct {\n\tMajor string // decimal\n\tMinor string // decimal or \"\"\n\tPatch string // decimal or \"\"\n\tKind  string // \"\", \"alpha\", \"beta\", \"rc\"\n\tPre   string // decimal or \"\"\n}\n    A Version is a parsed Go version: major[.Minor[.Patch]][kind[pre]] The\n    numbers are the original decimal strings to avoid integer overflows and\n    since there is very little actual math. (Probably overflow doesn't matter in\n    practice, but at the time this code was written, there was an existing test\n    that used go1.99999999999, which does not fit in an int on 32-bit platforms.\n    The \"big decimal\" representation avoids the problem entirely.)\n\nfunc Parse(x string) Version\n    Parse parses the Go version string x into a version. It returns the zero\n    version if x is malformed.\n\n"}, {"path": "stdlib/testing-slogtest.md", "category": "stdlib", "name": "stdlib/testing-slogtest", "content": "package slogtest // import \"testing/slogtest\"\n\nPackage slogtest implements support for testing implementations of\nlog/slog.Handler.\n\nFUNCTIONS\n\nfunc Run(t *testing.T, newHandler func(*testing.T) slog.Handler, result func(*testing.T) map[string]any)\n    Run exercises a slog.Handler on the same test cases as TestHandler, but runs\n    each case in a subtest. For each test case, it first calls newHandler to get\n    an instance of the handler under test, then runs the test case, then calls\n    result to get the result. If the test case fails, it calls t.Error.\n\nfunc TestHandler(h slog.Handler, results func() []map[string]any) error\n    TestHandler tests a slog.Handler. If TestHandler finds any misbehaviors,\n    it returns an error for each, combined into a single error with errors.Join.\n\n    TestHandler installs the given Handler in a slog.Logger and makes several\n    calls to the Logger's output methods. The Handler should be enabled for\n    levels Info and above.\n\n    The results function is invoked after all such calls. It should return\n    a slice of map[string]any, one for each call to a Logger output method.\n    The keys and values of the map should correspond to the keys and values of\n    the Handler's output. Each group in the output should be represented as its\n    own nested map[string]any. The standard keys slog.TimeKey, slog.LevelKey and\n    slog.MessageKey should be used.\n\n    If the Handler outputs JSON, then calling encoding/json.Unmarshal with a\n    `map[string]any` will create the right data structure.\n\n    If a Handler intentionally drops an attribute that is checked by a test,\n    then the results function should check for its absence and add it to the map\n    it returns.\n\n"}, {"path": "stdlib/errors.md", "category": "stdlib", "name": "stdlib/errors", "content": "package errors // import \"errors\"\n\nPackage errors implements functions to manipulate errors.\n\nThe New function creates errors whose only content is a text message.\n\nAn error e wraps another error if e's type has one of the methods\n\n    Unwrap() error\n    Unwrap() []error\n\nIf e.Unwrap() returns a non-nil error w or a slice containing w, then we say\nthat e wraps w. A nil error returned from e.Unwrap() indicates that e does\nnot wrap any error. It is invalid for an Unwrap method to return an []error\ncontaining a nil error value.\n\nAn easy way to create wrapped errors is to call fmt.Errorf and apply the %w verb\nto the error argument:\n\n    wrapsErr := fmt.Errorf(\"... %w ...\", ..., err, ...)\n\nSuccessive unwrapping of an error creates a tree. The Is and As functions\ninspect an error's tree by examining first the error itself followed by the tree\nof each of its children in turn (pre-order, depth-first traversal).\n\nSee https://go.dev/blog/go1.13-errors for a deeper discussion of the philosophy\nof wrapping and when to wrap.\n\nIs examines the tree of its first argument looking for an error that matches the\nsecond. It reports whether it finds a match. It should be used in preference to\nsimple equality checks:\n\n    if errors.Is(err, fs.ErrExist)\n\nis preferable to\n\n    if err == fs.ErrExist\n\nbecause the former will succeed if err wraps io/fs.ErrExist.\n\nAs examines the tree of its first argument looking for an error that can be\nassigned to its second argument, which must be a pointer. If it succeeds, it\nperforms the assignment and returns true. Otherwise, it returns false. The form\n\n    var perr *fs.PathError\n    if errors.As(err, &perr) {\n    \tfmt.Println(perr.Path)\n    }\n\nis preferable to\n\n    if perr, ok := err.(*fs.PathError); ok {\n    \tfmt.Println(perr.Path)\n    }\n\nbecause the former will succeed if err wraps an *io/fs.PathError.\n\nVARIABLES\n\nvar ErrUnsupported = New(\"unsupported operation\")\n    ErrUnsupported indicates that a requested operation cannot be performed,\n    because it is unsupported. For example, a call to os.Link when using a file\n    system that does not support hard links.\n\n    Functions and methods should not return this error but should instead return\n    an error including appropriate context that satisfies\n\n        errors.Is(err, errors.ErrUnsupported)\n\n    either by directly wrapping ErrUnsupported or by implementing an Is method.\n\n    Functions and methods should document the cases in which an error wrapping\n    this will be returned.\n\n\nFUNCTIONS\n\nfunc As(err error, target any) bool\n    As finds the first error in err's tree that matches target, and if one\n    is found, sets target to that error value and returns true. Otherwise,\n    it returns false.\n\n    The tree consists of err itself, followed by the errors obtained by\n    repeatedly calling its Unwrap() error or Unwrap() []error method. When err\n    wraps multiple errors, As examines err followed by a depth-first traversal\n    of its children.\n\n    An error matches target if the error's concrete value is assignable to\n    the value pointed to by target, or if the error has a method As(any) bool\n    such that As(target) returns true. In the latter case, the As method is\n    responsible for setting target.\n\n    An error type might provide an As method so it can be treated as if it were\n    a different error type.\n\n    As panics if target is not a non-nil pointer to either a type that\n    implements error, or to any interface type.\n\nfunc Is(err, target error) bool\n    Is reports whether any error in err's tree matches target.\n\n    The tree consists of err itself, followed by the errors obtained by\n    repeatedly calling its Unwrap() error or Unwrap() []error method. When err\n    wraps multiple errors, Is examines err followed by a depth-first traversal\n    of its children.\n\n    An error is considered to match a target if it is equal to that target or if\n    it implements a method Is(error) bool such that Is(target) returns true.\n\n    An error type might provide an Is method so it can be treated as equivalent\n    to an existing error. For example, if MyError defines\n\n        func (m MyError) Is(target error) bool { return target == fs.ErrExist }\n\n    then Is(MyError{}, fs.ErrExist) returns true. See syscall.Errno.Is for an\n    example in the standard library. An Is method should only shallowly compare\n    err and the target and not call Unwrap on either.\n\nfunc Join(errs ...error) error\n    Join returns an error that wraps the given errors. Any nil error values are\n    discarded. Join returns nil if every value in errs is nil. The error formats\n    as the concatenation of the strings obtained by calling the Error method of\n    each element of errs, with a newline between each string.\n\n    A non-nil error returned by Join implements the Unwrap() []error method.\n\nfunc New(text string) error\n    New returns an error that formats as the given text. Each call to New\n    returns a distinct error value even if the text is identical.\n\nfunc Unwrap(err error) error\n    Unwrap returns the result of calling the Unwrap method on err, if err's type\n    contains an Unwrap method returning error. Otherwise, Unwrap returns nil.\n\n    Unwrap only calls a method of the form \"Unwrap() error\". In particular\n    Unwrap does not unwrap errors returned by Join.\n\n"}, {"path": "stdlib/math.md", "category": "stdlib", "name": "stdlib/math", "content": "package math // import \"math\"\n\nPackage math provides basic constants and mathematical functions.\n\nThis package does not guarantee bit-identical results across architectures.\n\nCONSTANTS\n\nconst (\n\tE   = 2.71828182845904523536028747135266249775724709369995957496696763 // https://oeis.org/A001113\n\tPi  = 3.14159265358979323846264338327950288419716939937510582097494459 // https://oeis.org/A000796\n\tPhi = 1.61803398874989484820458683436563811772030917980576286213544862 // https://oeis.org/A001622\n\n\tSqrt2   = 1.41421356237309504880168872420969807856967187537694807317667974 // https://oeis.org/A002193\n\tSqrtE   = 1.64872127070012814684865078781416357165377610071014801157507931 // https://oeis.org/A019774\n\tSqrtPi  = 1.77245385090551602729816748334114518279754945612238712821380779 // https://oeis.org/A002161\n\tSqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038 // https://oeis.org/A139339\n\n\tLn2    = 0.693147180559945309417232121458176568075500134360255254120680009 // https://oeis.org/A002162\n\tLog2E  = 1 / Ln2\n\tLn10   = 2.30258509299404568401799145468436420760110148862877297603332790 // https://oeis.org/A002392\n\tLog10E = 1 / Ln10\n)\n    Mathematical constants.\n\nconst (\n\tMaxFloat32             = 0x1p127 * (1 + (1 - 0x1p-23)) // 3.40282346638528859811704183484516925440e+38\n\tSmallestNonzeroFloat32 = 0x1p-126 * 0x1p-23            // 1.401298464324817070923729583289916131280e-45\n\n\tMaxFloat64             = 0x1p1023 * (1 + (1 - 0x1p-52)) // 1.79769313486231570814527423731704356798070e+308\n\tSmallestNonzeroFloat64 = 0x1p-1022 * 0x1p-52            // 4.9406564584124654417656879286822137236505980e-324\n)\n    Floating-point limit values. Max is the largest finite value representable\n    by the type. SmallestNonzero is the smallest positive, non-zero value\n    representable by the type.\n\nconst (\n\tMaxInt    = 1<<(intSize-1) - 1  // MaxInt32 or MaxInt64 depending on intSize.\n\tMinInt    = -1 << (intSize - 1) // MinInt32 or MinInt64 depending on intSize.\n\tMaxInt8   = 1<<7 - 1            // 127\n\tMinInt8   = -1 << 7             // -128\n\tMaxInt16  = 1<<15 - 1           // 32767\n\tMinInt16  = -1 << 15            // -32768\n\tMaxInt32  = 1<<31 - 1           // 2147483647\n\tMinInt32  = -1 << 31            // -2147483648\n\tMaxInt64  = 1<<63 - 1           // 9223372036854775807\n\tMinInt64  = -1 << 63            // -9223372036854775808\n\tMaxUint   = 1<<intSize - 1      // MaxUint32 or MaxUint64 depending on intSize.\n\tMaxUint8  = 1<<8 - 1            // 255\n\tMaxUint16 = 1<<16 - 1           // 65535\n\tMaxUint32 = 1<<32 - 1           // 4294967295\n\tMaxUint64 = 1<<64 - 1           // 18446744073709551615\n)\n    Integer limit values.\n\n\nFUNCTIONS\n\nfunc Abs(x float64) float64\n    Abs returns the absolute value of x.\n\n    Special cases are:\n\n        Abs(\u00b1Inf) = +Inf\n        Abs(NaN) = NaN\n\nfunc Acos(x float64) float64\n    Acos returns the arccosine, in radians, of x.\n\n    Special case is:\n\n        Acos(x) = NaN if x < -1 or x > 1\n\nfunc Acosh(x float64) float64\n    Acosh returns the inverse hyperbolic cosine of x.\n\n    Special cases are:\n\n        Acosh(+Inf) = +Inf\n        Acosh(x) = NaN if x < 1\n        Acosh(NaN) = NaN\n\nfunc Asin(x float64) float64\n    Asin returns the arcsine, in radians, of x.\n\n    Special cases are:\n\n        Asin(\u00b10) = \u00b10\n        Asin(x) = NaN if x < -1 or x > 1\n\nfunc Asinh(x float64) float64\n    Asinh returns the inverse hyperbolic sine of x.\n\n    Special cases are:\n\n        Asinh(\u00b10) = \u00b10\n        Asinh(\u00b1Inf) = \u00b1Inf\n        Asinh(NaN) = NaN\n\nfunc Atan(x float64) float64\n    Atan returns the arctangent, in radians, of x.\n\n    Special cases are:\n\n        Atan(\u00b10) = \u00b10\n        Atan(\u00b1Inf) = \u00b1Pi/2\n\nfunc Atan2(y, x float64) float64\n    Atan2 returns the arc tangent of y/x, using the signs of the two to\n    determine the quadrant of the return value.\n\n    Special cases are (in order):\n\n        Atan2(y, NaN) = NaN\n        Atan2(NaN, x) = NaN\n        Atan2(+0, x>=0) = +0\n        Atan2(-0, x>=0) = -0\n        Atan2(+0, x<=-0) = +Pi\n        Atan2(-0, x<=-0) = -Pi\n        Atan2(y>0, 0) = +Pi/2\n        Atan2(y<0, 0) = -Pi/2\n        Atan2(+Inf, +Inf) = +Pi/4\n        Atan2(-Inf, +Inf) = -Pi/4\n        Atan2(+Inf, -Inf) = 3Pi/4\n        Atan2(-Inf, -Inf) = -3Pi/4\n        Atan2(y, +Inf) = 0\n        Atan2(y>0, -Inf) = +Pi\n        Atan2(y<0, -Inf) = -Pi\n        Atan2(+Inf, x) = +Pi/2\n        Atan2(-Inf, x) = -Pi/2\n\nfunc Atanh(x float64) float64\n    Atanh returns the inverse hyperbolic tangent of x.\n\n    Special cases are:\n\n        Atanh(1) = +Inf\n        Atanh(\u00b10) = \u00b10\n        Atanh(-1) = -Inf\n        Atanh(x) = NaN if x < -1 or x > 1\n        Atanh(NaN) = NaN\n\nfunc Cbrt(x float64) float64\n    Cbrt returns the cube root of x.\n\n    Special cases are:\n\n        Cbrt(\u00b10) = \u00b10\n        Cbrt(\u00b1Inf) = \u00b1Inf\n        Cbrt(NaN) = NaN\n\nfunc Ceil(x float64) float64\n    Ceil returns the least integer value greater than or equal to x.\n\n    Special cases are:\n\n        Ceil(\u00b10) = \u00b10\n        Ceil(\u00b1Inf) = \u00b1Inf\n        Ceil(NaN) = NaN\n\nfunc Copysign(f, sign float64) float64\n    Copysign returns a value with the magnitude of f and the sign of sign.\n\nfunc Cos(x float64) float64\n    Cos returns the cosine of the radian argument x.\n\n    Special cases are:\n\n        Cos(\u00b1Inf) = NaN\n        Cos(NaN) = NaN\n\nfunc Cosh(x float64) float64\n    Cosh returns the hyperbolic cosine of x.\n\n    Special cases are:\n\n        Cosh(\u00b10) = 1\n        Cosh(\u00b1Inf) = +Inf\n        Cosh(NaN) = NaN\n\nfunc Dim(x, y float64) float64\n    Dim returns the maximum of x-y or 0.\n\n    Special cases are:\n\n        Dim(+Inf, +Inf) = NaN\n        Dim(-Inf, -Inf) = NaN\n        Dim(x, NaN) = Dim(NaN, x) = NaN\n\nfunc Erf(x float64) float64\n    Erf returns the error function of x.\n\n    Special cases are:\n\n        Erf(+Inf) = 1\n        Erf(-Inf) = -1\n        Erf(NaN) = NaN\n\nfunc Erfc(x float64) float64\n    Erfc returns the complementary error function of x.\n\n    Special cases are:\n\n        Erfc(+Inf) = 0\n        Erfc(-Inf) = 2\n        Erfc(NaN) = NaN\n\nfunc Erfcinv(x float64) float64\n    Erfcinv returns the inverse of Erfc(x).\n\n    Special cases are:\n\n        Erfcinv(0) = +Inf\n        Erfcinv(2) = -Inf\n        Erfcinv(x) = NaN if x < 0 or x > 2\n        Erfcinv(NaN) = NaN\n\nfunc Erfinv(x float64) float64\n    Erfinv returns the inverse error function of x.\n\n    Special cases are:\n\n        Erfinv(1) = +Inf\n        Erfinv(-1) = -Inf\n        Erfinv(x) = NaN if x < -1 or x > 1\n        Erfinv(NaN) = NaN\n\nfunc Exp(x float64) float64\n    Exp returns e**x, the base-e exponential of x.\n\n    Special cases are:\n\n        Exp(+Inf) = +Inf\n        Exp(NaN) = NaN\n\n    Very large values overflow to 0 or +Inf. Very small values underflow to 1.\n\nfunc Exp2(x float64) float64\n    Exp2 returns 2**x, the base-2 exponential of x.\n\n    Special cases are the same as Exp.\n\nfunc Expm1(x float64) float64\n    Expm1 returns e**x - 1, the base-e exponential of x minus 1. It is more\n    accurate than Exp(x) - 1 when x is near zero.\n\n    Special cases are:\n\n        Expm1(+Inf) = +Inf\n        Expm1(-Inf) = -1\n        Expm1(NaN) = NaN\n\n    Very large values overflow to -1 or +Inf.\n\nfunc FMA(x, y, z float64) float64\n    FMA returns x * y + z, computed with only one rounding. (That is, FMA\n    returns the fused multiply-add of x, y, and z.)\n\nfunc Float32bits(f float32) uint32\n    Float32bits returns the IEEE 754 binary representation of f,\n    with the sign bit of f and the result in the same bit position.\n    Float32bits(Float32frombits(x)) == x.\n\nfunc Float32frombits(b uint32) float32\n    Float32frombits returns the floating-point number corresponding to the IEEE\n    754 binary representation b, with the sign bit of b and the result in the\n    same bit position. Float32frombits(Float32bits(x)) == x.\n\nfunc Float64bits(f float64) uint64\n    Float64bits returns the IEEE 754 binary representation of f,\n    with the sign bit of f and the result in the same bit position, and\n    Float64bits(Float64frombits(x)) == x.\n\nfunc Float64frombits(b uint64) float64\n    Float64frombits returns the floating-point number corresponding to the IEEE\n    754 binary representation b, with the sign bit of b and the result in the\n    same bit position. Float64frombits(Float64bits(x)) == x.\n\nfunc Floor(x float64) float64\n    Floor returns the greatest integer value less than or equal to x.\n\n    Special cases are:\n\n        Floor(\u00b10) = \u00b10\n        Floor(\u00b1Inf) = \u00b1Inf\n        Floor(NaN) = NaN\n\nfunc Frexp(f float64) (frac float64, exp int)\n    Frexp breaks f into a normalized fraction and an integral power of two.\n    It returns frac and exp satisfying f == frac \u00d7 2**exp, with the absolute\n    value of frac in the interval [\u00bd, 1).\n\n    Special cases are:\n\n        Frexp(\u00b10) = \u00b10, 0\n        Frexp(\u00b1Inf) = \u00b1Inf, 0\n        Frexp(NaN) = NaN, 0\n\nfunc Gamma(x float64) float64\n    Gamma returns the Gamma function of x.\n\n    Special cases are:\n\n        Gamma(+Inf) = +Inf\n        Gamma(+0) = +Inf\n        Gamma(-0) = -Inf\n        Gamma(x) = NaN for integer x < 0\n        Gamma(-Inf) = NaN\n        Gamma(NaN) = NaN\n\nfunc Hypot(p, q float64) float64\n    Hypot returns Sqrt(p*p + q*q), taking care to avoid unnecessary overflow and\n    underflow.\n\n    Special cases are:\n\n        Hypot(\u00b1Inf, q) = +Inf\n        Hypot(p, \u00b1Inf) = +Inf\n        Hypot(NaN, q) = NaN\n        Hypot(p, NaN) = NaN\n\nfunc Ilogb(x float64) int\n    Ilogb returns the binary exponent of x as an integer.\n\n    Special cases are:\n\n        Ilogb(\u00b1Inf) = MaxInt32\n        Ilogb(0) = MinInt32\n        Ilogb(NaN) = MaxInt32\n\nfunc Inf(sign int) float64\n    Inf returns positive infinity if sign >= 0, negative infinity if sign < 0.\n\nfunc IsInf(f float64, sign int) bool\n    IsInf reports whether f is an infinity, according to sign. If sign > 0,\n    IsInf reports whether f is positive infinity. If sign < 0, IsInf reports\n    whether f is negative infinity. If sign == 0, IsInf reports whether f is\n    either infinity.\n\nfunc IsNaN(f float64) (is bool)\n    IsNaN reports whether f is an IEEE 754 \u201cnot-a-number\u201d value.\n\nfunc J0(x float64) float64\n    J0 returns the order-zero Bessel function of the first kind.\n\n    Special cases are:\n\n        J0(\u00b1Inf) = 0\n        J0(0) = 1\n        J0(NaN) = NaN\n\nfunc J1(x float64) float64\n    J1 returns the order-one Bessel function of the first kind.\n\n    Special cases are:\n\n        J1(\u00b1Inf) = 0\n        J1(NaN) = NaN\n\nfunc Jn(n int, x float64) float64\n    Jn returns the order-n Bessel function of the first kind.\n\n    Special cases are:\n\n        Jn(n, \u00b1Inf) = 0\n        Jn(n, NaN) = NaN\n\nfunc Ldexp(frac float64, exp int) float64\n    Ldexp is the inverse of Frexp. It returns frac \u00d7 2**exp.\n\n    Special cases are:\n\n        Ldexp(\u00b10, exp) = \u00b10\n        Ldexp(\u00b1Inf, exp) = \u00b1Inf\n        Ldexp(NaN, exp) = NaN\n\nfunc Lgamma(x float64) (lgamma float64, sign int)\n    Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).\n\n    Special cases are:\n\n        Lgamma(+Inf) = +Inf\n        Lgamma(0) = +Inf\n        Lgamma(-integer) = +Inf\n        Lgamma(-Inf) = -Inf\n        Lgamma(NaN) = NaN\n\nfunc Log(x float64) float64\n    Log returns the natural logarithm of x.\n\n    Special cases are:\n\n        Log(+Inf) = +Inf\n        Log(0) = -Inf\n        Log(x < 0) = NaN\n        Log(NaN) = NaN\n\nfunc Log10(x float64) float64\n    Log10 returns the decimal logarithm of x. The special cases are the same as\n    for Log.\n\nfunc Log1p(x float64) float64\n    Log1p returns the natural logarithm of 1 plus its argument x. It is more\n    accurate than Log(1 + x) when x is near zero.\n\n    Special cases are:\n\n        Log1p(+Inf) = +Inf\n        Log1p(\u00b10) = \u00b10\n        Log1p(-1) = -Inf\n        Log1p(x < -1) = NaN\n        Log1p(NaN) = NaN\n\nfunc Log2(x float64) float64\n    Log2 returns the binary logarithm of x. The special cases are the same as\n    for Log.\n\nfunc Logb(x float64) float64\n    Logb returns the binary exponent of x.\n\n    Special cases are:\n\n        Logb(\u00b1Inf) = +Inf\n        Logb(0) = -Inf\n        Logb(NaN) = NaN\n\nfunc Max(x, y float64) float64\n    Max returns the larger of x or y.\n\n    Special cases are:\n\n        Max(x, +Inf) = Max(+Inf, x) = +Inf\n        Max(x, NaN) = Max(NaN, x) = NaN\n        Max(+0, \u00b10) = Max(\u00b10, +0) = +0\n        Max(-0, -0) = -0\n\n    Note that this differs from the built-in function max when called with NaN\n    and +Inf.\n\nfunc Min(x, y float64) float64\n    Min returns the smaller of x or y.\n\n    Special cases are:\n\n        Min(x, -Inf) = Min(-Inf, x) = -Inf\n        Min(x, NaN) = Min(NaN, x) = NaN\n        Min(-0, \u00b10) = Min(\u00b10, -0) = -0\n\n    Note that this differs from the built-in function min when called with NaN\n    and -Inf.\n\nfunc Mod(x, y float64) float64\n    Mod returns the floating-point remainder of x/y. The magnitude of the result\n    is less than y and its sign agrees with that of x.\n\n    Special cases are:\n\n        Mod(\u00b1Inf, y) = NaN\n        Mod(NaN, y) = NaN\n        Mod(x, 0) = NaN\n        Mod(x, \u00b1Inf) = x\n        Mod(x, NaN) = NaN\n\nfunc Modf(f float64) (int float64, frac float64)\n    Modf returns integer and fractional floating-point numbers that sum to f.\n    Both values have the same sign as f.\n\n    Special cases are:\n\n        Modf(\u00b1Inf) = \u00b1Inf, NaN\n        Modf(NaN) = NaN, NaN\n\nfunc NaN() float64\n    NaN returns an IEEE 754 \u201cnot-a-number\u201d value.\n\nfunc Nextafter(x, y float64) (r float64)\n    Nextafter returns the next representable float64 value after x towards y.\n\n    Special cases are:\n\n        Nextafter(x, x)   = x\n        Nextafter(NaN, y) = NaN\n        Nextafter(x, NaN) = NaN\n\nfunc Nextafter32(x, y float32) (r float32)\n    Nextafter32 returns the next representable float32 value after x towards y.\n\n    Special cases are:\n\n        Nextafter32(x, x)   = x\n        Nextafter32(NaN, y) = NaN\n        Nextafter32(x, NaN) = NaN\n\nfunc Pow(x, y float64) float64\n    Pow returns x**y, the base-x exponential of y.\n\n    Special cases are (in order):\n\n        Pow(x, \u00b10) = 1 for any x\n        Pow(1, y) = 1 for any y\n        Pow(x, 1) = x for any x\n        Pow(NaN, y) = NaN\n        Pow(x, NaN) = NaN\n        Pow(\u00b10, y) = \u00b1Inf for y an odd integer < 0\n        Pow(\u00b10, -Inf) = +Inf\n        Pow(\u00b10, +Inf) = +0\n        Pow(\u00b10, y) = +Inf for finite y < 0 and not an odd integer\n        Pow(\u00b10, y) = \u00b10 for y an odd integer > 0\n        Pow(\u00b10, y) = +0 for finite y > 0 and not an odd integer\n        Pow(-1, \u00b1Inf) = 1\n        Pow(x, +Inf) = +Inf for |x| > 1\n        Pow(x, -Inf) = +0 for |x| > 1\n        Pow(x, +Inf) = +0 for |x| < 1\n        Pow(x, -Inf) = +Inf for |x| < 1\n        Pow(+Inf, y) = +Inf for y > 0\n        Pow(+Inf, y) = +0 for y < 0\n        Pow(-Inf, y) = Pow(-0, -y)\n        Pow(x, y) = NaN for finite x < 0 and finite non-integer y\n\nfunc Pow10(n int) float64\n    Pow10 returns 10**n, the base-10 exponential of n.\n\n    Special cases are:\n\n        Pow10(n) =    0 for n < -323\n        Pow10(n) = +Inf for n > 308\n\nfunc Remainder(x, y float64) float64\n    Remainder returns the IEEE 754 floating-point remainder of x/y.\n\n    Special cases are:\n\n        Remainder(\u00b1Inf, y) = NaN\n        Remainder(NaN, y) = NaN\n        Remainder(x, 0) = NaN\n        Remainder(x, \u00b1Inf) = x\n        Remainder(x, NaN) = NaN\n\nfunc Round(x float64) float64\n    Round returns the nearest integer, rounding half away from zero.\n\n    Special cases are:\n\n        Round(\u00b10) = \u00b10\n        Round(\u00b1Inf) = \u00b1Inf\n        Round(NaN) = NaN\n\nfunc RoundToEven(x float64) float64\n    RoundToEven returns the nearest integer, rounding ties to even.\n\n    Special cases are:\n\n        RoundToEven(\u00b10) = \u00b10\n        RoundToEven(\u00b1Inf) = \u00b1Inf\n        RoundToEven(NaN) = NaN\n\nfunc Signbit(x float64) bool\n    Signbit reports whether x is negative or negative zero.\n\nfunc Sin(x float64) float64\n    Sin returns the sine of the radian argument x.\n\n    Special cases are:\n\n        Sin(\u00b10) = \u00b10\n        Sin(\u00b1Inf) = NaN\n        Sin(NaN) = NaN\n\nfunc Sincos(x float64) (sin, cos float64)\n    Sincos returns Sin(x), Cos(x).\n\n    Special cases are:\n\n        Sincos(\u00b10) = \u00b10, 1\n        Sincos(\u00b1Inf) = NaN, NaN\n        Sincos(NaN) = NaN, NaN\n\nfunc Sinh(x float64) float64\n    Sinh returns the hyperbolic sine of x.\n\n    Special cases are:\n\n        Sinh(\u00b10) = \u00b10\n        Sinh(\u00b1Inf) = \u00b1Inf\n        Sinh(NaN) = NaN\n\nfunc Sqrt(x float64) float64\n    Sqrt returns the square root of x.\n\n    Special cases are:\n\n        Sqrt(+Inf) = +Inf\n        Sqrt(\u00b10) = \u00b10\n        Sqrt(x < 0) = NaN\n        Sqrt(NaN) = NaN\n\nfunc Tan(x float64) float64\n    Tan returns the tangent of the radian argument x.\n\n    Special cases are:\n\n        Tan(\u00b10) = \u00b10\n        Tan(\u00b1Inf) = NaN\n        Tan(NaN) = NaN\n\nfunc Tanh(x float64) float64\n    Tanh returns the hyperbolic tangent of x.\n\n    Special cases are:\n\n        Tanh(\u00b10) = \u00b10\n        Tanh(\u00b1Inf) = \u00b11\n        Tanh(NaN) = NaN\n\nfunc Trunc(x float64) float64\n    Trunc returns the integer value of x.\n\n    Special cases are:\n\n        Trunc(\u00b10) = \u00b10\n        Trunc(\u00b1Inf) = \u00b1Inf\n        Trunc(NaN) = NaN\n\nfunc Y0(x float64) float64\n    Y0 returns the order-zero Bessel function of the second kind.\n\n    Special cases are:\n\n        Y0(+Inf) = 0\n        Y0(0) = -Inf\n        Y0(x < 0) = NaN\n        Y0(NaN) = NaN\n\nfunc Y1(x float64) float64\n    Y1 returns the order-one Bessel function of the second kind.\n\n    Special cases are:\n\n        Y1(+Inf) = 0\n        Y1(0) = -Inf\n        Y1(x < 0) = NaN\n        Y1(NaN) = NaN\n\nfunc Yn(n int, x float64) float64\n    Yn returns the order-n Bessel function of the second kind.\n\n    Special cases are:\n\n        Yn(n, +Inf) = 0\n        Yn(n \u2265 0, 0) = -Inf\n        Yn(n < 0, 0) = +Inf if n is odd, -Inf if n is even\n        Yn(n, x < 0) = NaN\n        Yn(n, NaN) = NaN\n\n"}, {"path": "stdlib/database-sql-driver.md", "category": "stdlib", "name": "stdlib/database-sql-driver", "content": "package driver // import \"database/sql/driver\"\n\nPackage driver defines interfaces to be implemented by database drivers as used\nby package sql.\n\nMost code should use the database/sql package.\n\nThe driver interface has evolved over time. Drivers should implement Connector\nand DriverContext interfaces. The Connector.Connect and Driver.Open methods\nshould never return ErrBadConn. ErrBadConn should only be returned from\nValidator, SessionResetter, or a query method if the connection is already in an\ninvalid (e.g. closed) state.\n\nAll Conn implementations should implement the following interfaces: Pinger,\nSessionResetter, and Validator.\n\nIf named parameters or context are supported, the driver's Conn should\nimplement: ExecerContext, QueryerContext, ConnPrepareContext, and ConnBeginTx.\n\nTo support custom data types, implement NamedValueChecker. NamedValueChecker\nalso allows queries to accept per-query options as a parameter by returning\nErrRemoveArgument from CheckNamedValue.\n\nIf multiple result sets are supported, Rows should implement RowsNextResultSet.\nIf the driver knows how to describe the types present in the returned result\nit should implement the following interfaces: RowsColumnTypeScanType,\nRowsColumnTypeDatabaseTypeName, RowsColumnTypeLength, RowsColumnTypeNullable,\nand RowsColumnTypePrecisionScale. A given row value may also return a Rows type,\nwhich may represent a database cursor value.\n\nIf a Conn implements Validator, then the IsValid method is called before\nreturning the connection to the connection pool. If an entry in the connection\npool implements SessionResetter, then ResetSession is called before reusing\nthe connection for another query. If a connection is never returned to the\nconnection pool but is immediately reused, then ResetSession is called prior to\nreuse but IsValid is not called.\n\nVARIABLES\n\nvar ErrBadConn = errors.New(\"driver: bad connection\")\n    ErrBadConn should be returned by a driver to signal to the database/sql\n    package that a driver.Conn is in a bad state (such as the server having\n    earlier closed the connection) and the database/sql package should retry on\n    a new connection.\n\n    To prevent duplicate operations, ErrBadConn should NOT be returned if\n    there's a possibility that the database server might have performed the\n    operation. Even if the server sends back an error, you shouldn't return\n    ErrBadConn.\n\n    Errors will be checked using errors.Is. An error may wrap ErrBadConn or\n    implement the Is(error) bool method.\n\nvar ErrRemoveArgument = errors.New(\"driver: remove argument from query\")\n    ErrRemoveArgument may be returned from NamedValueChecker to instruct the\n    database/sql package to not pass the argument to the driver query interface.\n    Return when accepting query specific options or structures that aren't SQL\n    query arguments.\n\nvar ErrSkip = errors.New(\"driver: skip fast-path; continue as if unimplemented\")\n    ErrSkip may be returned by some optional interfaces' methods to indicate\n    at runtime that the fast path is unavailable and the sql package should\n    continue as if the optional interface was not implemented. ErrSkip is only\n    supported where explicitly documented.\n\nvar Bool boolType\n    Bool is a ValueConverter that converts input values to bool.\n\n    The conversion rules are:\n      - booleans are returned unchanged\n      - for integer types, 1 is true 0 is false, other integers are an error\n      - for strings and []byte, same rules as strconv.ParseBool\n      - all other types are an error\n\nvar DefaultParameterConverter defaultConverter\n    DefaultParameterConverter is the default implementation of ValueConverter\n    that's used when a Stmt doesn't implement ColumnConverter.\n\n    DefaultParameterConverter returns its argument directly if IsValue(arg).\n    Otherwise, if the argument implements Valuer, its Value method is used to\n    return a Value. As a fallback, the provided argument's underlying type\n    is used to convert it to a Value: underlying integer types are converted\n    to int64, floats to float64, bool, string, and []byte to themselves.\n    If the argument is a nil pointer, defaultConverter.ConvertValue returns\n    a nil Value. If the argument is a non-nil pointer, it is dereferenced and\n    defaultConverter.ConvertValue is called recursively. Other types are an\n    error.\n\nvar Int32 int32Type\n    Int32 is a ValueConverter that converts input values to int64, respecting\n    the limits of an int32 value.\n\nvar ResultNoRows noRows\n    ResultNoRows is a pre-defined Result for drivers to return when a DDL\n    command (such as a CREATE TABLE) succeeds. It returns an error for both\n    LastInsertId and RowsAffected.\n\nvar String stringType\n    String is a ValueConverter that converts its input to a string. If the value\n    is already a string or []byte, it's unchanged. If the value is of another\n    type, conversion to string is done with fmt.Sprintf(\"%v\", v).\n\n\nFUNCTIONS\n\nfunc IsScanValue(v any) bool\n    IsScanValue is equivalent to IsValue. It exists for compatibility.\n\nfunc IsValue(v any) bool\n    IsValue reports whether v is a valid Value parameter type.\n\n\nTYPES\n\ntype ColumnConverter interface {\n\t// ColumnConverter returns a ValueConverter for the provided\n\t// column index. If the type of a specific column isn't known\n\t// or shouldn't be handled specially, [DefaultParameterConverter]\n\t// can be returned.\n\tColumnConverter(idx int) ValueConverter\n}\n    ColumnConverter may be optionally implemented by Stmt if the statement is\n    aware of its own columns' types and can convert from any type to a driver\n    Value.\n\n    Deprecated: Drivers should implement NamedValueChecker.\n\ntype Conn interface {\n\t// Prepare returns a prepared statement, bound to this connection.\n\tPrepare(query string) (Stmt, error)\n\n\t// Close invalidates and potentially stops any current\n\t// prepared statements and transactions, marking this\n\t// connection as no longer in use.\n\t//\n\t// Because the sql package maintains a free pool of\n\t// connections and only calls Close when there's a surplus of\n\t// idle connections, it shouldn't be necessary for drivers to\n\t// do their own connection caching.\n\t//\n\t// Drivers must ensure all network calls made by Close\n\t// do not block indefinitely (e.g. apply a timeout).\n\tClose() error\n\n\t// Begin starts and returns a new transaction.\n\t//\n\t// Deprecated: Drivers should implement ConnBeginTx instead (or additionally).\n\tBegin() (Tx, error)\n}\n    Conn is a connection to a database. It is not used concurrently by multiple\n    goroutines.\n\n    Conn is assumed to be stateful.\n\ntype ConnBeginTx interface {\n\t// BeginTx starts and returns a new transaction.\n\t// If the context is canceled by the user the sql package will\n\t// call Tx.Rollback before discarding and closing the connection.\n\t//\n\t// This must check opts.Isolation to determine if there is a set\n\t// isolation level. If the driver does not support a non-default\n\t// level and one is set or if there is a non-default isolation level\n\t// that is not supported, an error must be returned.\n\t//\n\t// This must also check opts.ReadOnly to determine if the read-only\n\t// value is true to either set the read-only transaction property if supported\n\t// or return an error if it is not supported.\n\tBeginTx(ctx context.Context, opts TxOptions) (Tx, error)\n}\n    ConnBeginTx enhances the Conn interface with context and TxOptions.\n\ntype ConnPrepareContext interface {\n\t// PrepareContext returns a prepared statement, bound to this connection.\n\t// context is for the preparation of the statement,\n\t// it must not store the context within the statement itself.\n\tPrepareContext(ctx context.Context, query string) (Stmt, error)\n}\n    ConnPrepareContext enhances the Conn interface with context.\n\ntype Connector interface {\n\t// Connect returns a connection to the database.\n\t// Connect may return a cached connection (one previously\n\t// closed), but doing so is unnecessary; the sql package\n\t// maintains a pool of idle connections for efficient re-use.\n\t//\n\t// The provided context.Context is for dialing purposes only\n\t// (see net.DialContext) and should not be stored or used for\n\t// other purposes. A default timeout should still be used\n\t// when dialing as a connection pool may call Connect\n\t// asynchronously to any query.\n\t//\n\t// The returned connection is only used by one goroutine at a\n\t// time.\n\tConnect(context.Context) (Conn, error)\n\n\t// Driver returns the underlying Driver of the Connector,\n\t// mainly to maintain compatibility with the Driver method\n\t// on sql.DB.\n\tDriver() Driver\n}\n    A Connector represents a driver in a fixed configuration and can create any\n    number of equivalent Conns for use by multiple goroutines.\n\n    A Connector can be passed to database/sql.OpenDB, to allow drivers\n    to implement their own database/sql.DB constructors, or returned by\n    DriverContext's OpenConnector method, to allow drivers access to context and\n    to avoid repeated parsing of driver configuration.\n\n    If a Connector implements io.Closer, the database/sql.DB.Close method will\n    call the Close method and return error (if any).\n\ntype Driver interface {\n\t// Open returns a new connection to the database.\n\t// The name is a string in a driver-specific format.\n\t//\n\t// Open may return a cached connection (one previously\n\t// closed), but doing so is unnecessary; the sql package\n\t// maintains a pool of idle connections for efficient re-use.\n\t//\n\t// The returned connection is only used by one goroutine at a\n\t// time.\n\tOpen(name string) (Conn, error)\n}\n    Driver is the interface that must be implemented by a database driver.\n\n    Database drivers may implement DriverContext for access to contexts and\n    to parse the name only once for a pool of connections, instead of once per\n    connection.\n\ntype DriverContext interface {\n\t// OpenConnector must parse the name in the same format that Driver.Open\n\t// parses the name parameter.\n\tOpenConnector(name string) (Connector, error)\n}\n    If a Driver implements DriverContext, then database/sql.DB will call\n    OpenConnector to obtain a Connector and then invoke that Connector's Connect\n    method to obtain each needed connection, instead of invoking the Driver's\n    Open method for each connection. The two-step sequence allows drivers to\n    parse the name just once and also provides access to per-Conn contexts.\n\ntype Execer interface {\n\tExec(query string, args []Value) (Result, error)\n}\n    Execer is an optional interface that may be implemented by a Conn.\n\n    If a Conn implements neither ExecerContext nor Execer, the\n    database/sql.DB.Exec will first prepare a query, execute the statement,\n    and then close the statement.\n\n    Exec may return ErrSkip.\n\n    Deprecated: Drivers should implement ExecerContext instead.\n\ntype ExecerContext interface {\n\tExecContext(ctx context.Context, query string, args []NamedValue) (Result, error)\n}\n    ExecerContext is an optional interface that may be implemented by a Conn.\n\n    If a Conn does not implement ExecerContext, the database/sql.DB.Exec\n    will fall back to Execer; if the Conn does not implement Execer either,\n    database/sql.DB.Exec will first prepare a query, execute the statement,\n    and then close the statement.\n\n    ExecContext may return ErrSkip.\n\n    ExecContext must honor the context timeout and return when the context is\n    canceled.\n\ntype IsolationLevel int\n    IsolationLevel is the transaction isolation level stored in TxOptions.\n\n    This type should be considered identical to database/sql.IsolationLevel\n    along with any values defined on it.\n\ntype NamedValue struct {\n\t// If the Name is not empty it should be used for the parameter identifier and\n\t// not the ordinal position.\n\t//\n\t// Name will not have a symbol prefix.\n\tName string\n\n\t// Ordinal position of the parameter starting from one and is always set.\n\tOrdinal int\n\n\t// Value is the parameter value.\n\tValue Value\n}\n    NamedValue holds both the value name and value.\n\ntype NamedValueChecker interface {\n\t// CheckNamedValue is called before passing arguments to the driver\n\t// and is called in place of any ColumnConverter. CheckNamedValue must do type\n\t// validation and conversion as appropriate for the driver.\n\tCheckNamedValue(*NamedValue) error\n}\n    NamedValueChecker may be optionally implemented by Conn or Stmt. It provides\n    the driver more control to handle Go and database types beyond the default\n    Value types allowed.\n\n    The database/sql package checks for value checkers in the following\n    order, stopping at the first found match: Stmt.NamedValueChecker,\n    Conn.NamedValueChecker, Stmt.ColumnConverter, DefaultParameterConverter.\n\n    If CheckNamedValue returns ErrRemoveArgument, the NamedValue will not be\n    included in the final query arguments. This may be used to pass special\n    options to the query itself.\n\n    If ErrSkip is returned the column converter error checking path is used for\n    the argument. Drivers may wish to return ErrSkip after they have exhausted\n    their own special cases.\n\ntype NotNull struct {\n\tConverter ValueConverter\n}\n    NotNull is a type that implements ValueConverter by disallowing nil values\n    but otherwise delegating to another ValueConverter.\n\nfunc (n NotNull) ConvertValue(v any) (Value, error)\n\ntype Null struct {\n\tConverter ValueConverter\n}\n    Null is a type that implements ValueConverter by allowing nil values but\n    otherwise delegating to another ValueConverter.\n\nfunc (n Null) ConvertValue(v any) (Value, error)\n\ntype Pinger interface {\n\tPing(ctx context.Context) error\n}\n    Pinger is an optional interface that may be implemented by a Conn.\n\n    If a Conn does not implement Pinger, the database/sql.DB.Ping and\n    database/sql.DB.PingContext will check if there is at least one Conn\n    available.\n\n    If Conn.Ping returns ErrBadConn, database/sql.DB.Ping and\n    database/sql.DB.PingContext will remove the Conn from pool.\n\ntype Queryer interface {\n\tQuery(query string, args []Value) (Rows, error)\n}\n    Queryer is an optional interface that may be implemented by a Conn.\n\n    If a Conn implements neither QueryerContext nor Queryer, the\n    database/sql.DB.Query will first prepare a query, execute the statement,\n    and then close the statement.\n\n    Query may return ErrSkip.\n\n    Deprecated: Drivers should implement QueryerContext instead.\n\ntype QueryerContext interface {\n\tQueryContext(ctx context.Context, query string, args []NamedValue) (Rows, error)\n}\n    QueryerContext is an optional interface that may be implemented by a Conn.\n\n    If a Conn does not implement QueryerContext, the database/sql.DB.Query\n    will fall back to Queryer; if the Conn does not implement Queryer either,\n    database/sql.DB.Query will first prepare a query, execute the statement,\n    and then close the statement.\n\n    QueryContext may return ErrSkip.\n\n    QueryContext must honor the context timeout and return when the context is\n    canceled.\n\ntype Result interface {\n\t// LastInsertId returns the database's auto-generated ID\n\t// after, for example, an INSERT into a table with primary\n\t// key.\n\tLastInsertId() (int64, error)\n\n\t// RowsAffected returns the number of rows affected by the\n\t// query.\n\tRowsAffected() (int64, error)\n}\n    Result is the result of a query execution.\n\ntype Rows interface {\n\t// Columns returns the names of the columns. The number of\n\t// columns of the result is inferred from the length of the\n\t// slice. If a particular column name isn't known, an empty\n\t// string should be returned for that entry.\n\tColumns() []string\n\n\t// Close closes the rows iterator.\n\tClose() error\n\n\t// Next is called to populate the next row of data into\n\t// the provided slice. The provided slice will be the same\n\t// size as the Columns() are wide.\n\t//\n\t// Next should return io.EOF when there are no more rows.\n\t//\n\t// The dest should not be written to outside of Next. Care\n\t// should be taken when closing Rows not to modify\n\t// a buffer held in dest.\n\tNext(dest []Value) error\n}\n    Rows is an iterator over an executed query's results.\n\ntype RowsAffected int64\n    RowsAffected implements Result for an INSERT or UPDATE operation which\n    mutates a number of rows.\n\nfunc (RowsAffected) LastInsertId() (int64, error)\n\nfunc (v RowsAffected) RowsAffected() (int64, error)\n\ntype RowsColumnTypeDatabaseTypeName interface {\n\tRows\n\tColumnTypeDatabaseTypeName(index int) string\n}\n    RowsColumnTypeDatabaseTypeName may be implemented by Rows. It should return\n    the database system type name without the length. Type names should be\n    uppercase. Examples of returned types: \"VARCHAR\", \"NVARCHAR\", \"VARCHAR2\",\n    \"CHAR\", \"TEXT\", \"DECIMAL\", \"SMALLINT\", \"INT\", \"BIGINT\", \"BOOL\", \"[]BIGINT\",\n    \"JSONB\", \"XML\", \"TIMESTAMP\".\n\ntype RowsColumnTypeLength interface {\n\tRows\n\tColumnTypeLength(index int) (length int64, ok bool)\n}\n    RowsColumnTypeLength may be implemented by Rows. It should return the length\n    of the column type if the column is a variable length type. If the column is\n    not a variable length type ok should return false. If length is not limited\n    other than system limits, it should return math.MaxInt64. The following are\n    examples of returned values for various types:\n\n        TEXT          (math.MaxInt64, true)\n        varchar(10)   (10, true)\n        nvarchar(10)  (10, true)\n        decimal       (0, false)\n        int           (0, false)\n        bytea(30)     (30, true)\n\ntype RowsColumnTypeNullable interface {\n\tRows\n\tColumnTypeNullable(index int) (nullable, ok bool)\n}\n    RowsColumnTypeNullable may be implemented by Rows. The nullable value should\n    be true if it is known the column may be null, or false if the column is\n    known to be not nullable. If the column nullability is unknown, ok should be\n    false.\n\ntype RowsColumnTypePrecisionScale interface {\n\tRows\n\tColumnTypePrecisionScale(index int) (precision, scale int64, ok bool)\n}\n    RowsColumnTypePrecisionScale may be implemented by Rows. It should return\n    the precision and scale for decimal types. If not applicable, ok should be\n    false. The following are examples of returned values for various types:\n\n        decimal(38, 4)    (38, 4, true)\n        int               (0, 0, false)\n        decimal           (math.MaxInt64, math.MaxInt64, true)\n\ntype RowsColumnTypeScanType interface {\n\tRows\n\tColumnTypeScanType(index int) reflect.Type\n}\n    RowsColumnTypeScanType may be implemented by Rows. It should return the\n    value type that can be used to scan types into. For example, the database\n    column type \"bigint\" this should return \"reflect.TypeOf(int64(0))\".\n\ntype RowsNextResultSet interface {\n\tRows\n\n\t// HasNextResultSet is called at the end of the current result set and\n\t// reports whether there is another result set after the current one.\n\tHasNextResultSet() bool\n\n\t// NextResultSet advances the driver to the next result set even\n\t// if there are remaining rows in the current result set.\n\t//\n\t// NextResultSet should return io.EOF when there are no more result sets.\n\tNextResultSet() error\n}\n    RowsNextResultSet extends the Rows interface by providing a way to signal\n    the driver to advance to the next result set.\n\ntype SessionResetter interface {\n\t// ResetSession is called prior to executing a query on the connection\n\t// if the connection has been used before. If the driver returns ErrBadConn\n\t// the connection is discarded.\n\tResetSession(ctx context.Context) error\n}\n    SessionResetter may be implemented by Conn to allow drivers to reset the\n    session state associated with the connection and to signal a bad connection.\n\ntype Stmt interface {\n\t// Close closes the statement.\n\t//\n\t// As of Go 1.1, a Stmt will not be closed if it's in use\n\t// by any queries.\n\t//\n\t// Drivers must ensure all network calls made by Close\n\t// do not block indefinitely (e.g. apply a timeout).\n\tClose() error\n\n\t// NumInput returns the number of placeholder parameters.\n\t//\n\t// If NumInput returns >= 0, the sql package will sanity check\n\t// argument counts from callers and return errors to the caller\n\t// before the statement's Exec or Query methods are called.\n\t//\n\t// NumInput may also return -1, if the driver doesn't know\n\t// its number of placeholders. In that case, the sql package\n\t// will not sanity check Exec or Query argument counts.\n\tNumInput() int\n\n\t// Exec executes a query that doesn't return rows, such\n\t// as an INSERT or UPDATE.\n\t//\n\t// Deprecated: Drivers should implement StmtExecContext instead (or additionally).\n\tExec(args []Value) (Result, error)\n\n\t// Query executes a query that may return rows, such as a\n\t// SELECT.\n\t//\n\t// Deprecated: Drivers should implement StmtQueryContext instead (or additionally).\n\tQuery(args []Value) (Rows, error)\n}\n    Stmt is a prepared statement. It is bound to a Conn and not used by multiple\n    goroutines concurrently.\n\ntype StmtExecContext interface {\n\t// ExecContext executes a query that doesn't return rows, such\n\t// as an INSERT or UPDATE.\n\t//\n\t// ExecContext must honor the context timeout and return when it is canceled.\n\tExecContext(ctx context.Context, args []NamedValue) (Result, error)\n}\n    StmtExecContext enhances the Stmt interface by providing Exec with context.\n\ntype StmtQueryContext interface {\n\t// QueryContext executes a query that may return rows, such as a\n\t// SELECT.\n\t//\n\t// QueryContext must honor the context timeout and return when it is canceled.\n\tQueryContext(ctx context.Context, args []NamedValue) (Rows, error)\n}\n    StmtQueryContext enhances the Stmt interface by providing Query with\n    context.\n\ntype Tx interface {\n\tCommit() error\n\tRollback() error\n}\n    Tx is a transaction.\n\ntype TxOptions struct {\n\tIsolation IsolationLevel\n\tReadOnly  bool\n}\n    TxOptions holds the transaction options.\n\n    This type should be considered identical to database/sql.TxOptions.\n\ntype Validator interface {\n\t// IsValid is called prior to placing the connection into the\n\t// connection pool. The connection will be discarded if false is returned.\n\tIsValid() bool\n}\n    Validator may be implemented by Conn to allow drivers to signal if a\n    connection is valid or if it should be discarded.\n\n    If implemented, drivers may return the underlying error from queries,\n    even if the connection should be discarded by the connection pool.\n\ntype Value any\n    Value is a value that drivers must be able to handle. It is either nil,\n    a type handled by a database driver's NamedValueChecker interface, or an\n    instance of one of these types:\n\n        int64\n        float64\n        bool\n        []byte\n        string\n        time.Time\n\n    If the driver supports cursors, a returned Value may also implement the\n    Rows interface in this package. This is used, for example, when a user\n    selects a cursor such as \"select cursor(select * from my_table) from dual\".\n    If the Rows from the select is closed, the cursor Rows will also be closed.\n\ntype ValueConverter interface {\n\t// ConvertValue converts a value to a driver Value.\n\tConvertValue(v any) (Value, error)\n}\n    ValueConverter is the interface providing the ConvertValue method.\n\n    Various implementations of ValueConverter are provided by the driver package\n    to provide consistent implementations of conversions between drivers.\n    The ValueConverters have several uses:\n\n      - converting from the Value types as provided by the sql package into a\n        database table's specific column type and making sure it fits, such as\n        making sure a particular int64 fits in a table's uint16 column.\n\n      - converting a value as given from the database into one of the driver\n        Value types.\n\n      - by the database/sql package, for converting from a driver's Value type\n        to a user's type in a scan.\n\ntype Valuer interface {\n\t// Value returns a driver Value.\n\t// Value must not panic.\n\tValue() (Value, error)\n}\n    Valuer is the interface providing the Value method.\n\n    Errors returned by the Value method are wrapped by the database/sql\n    package. This allows callers to use errors.Is for precise error\n    handling after operations like database/sql.Query, database/sql.Exec,\n    or database/sql.QueryRow.\n\n    Types implementing Valuer interface are able to convert themselves to a\n    driver Value.\n\n"}, {"path": "stdlib/net-url.md", "category": "stdlib", "name": "stdlib/net-url", "content": "package url // import \"net/url\"\n\nPackage url parses URLs and implements query escaping.\n\nSee RFC 3986. This package generally follows RFC 3986, except where it deviates\nfor compatibility reasons. RFC 6874 followed for IPv6 zone literals.\n\nFUNCTIONS\n\nfunc JoinPath(base string, elem ...string) (result string, err error)\n    JoinPath returns a URL string with the provided path elements joined to\n    the existing path of base and the resulting path cleaned of any ./ or ../\n    elements.\n\nfunc PathEscape(s string) string\n    PathEscape escapes the string so it can be safely placed inside a URL path\n    segment, replacing special characters (including /) with %XX sequences as\n    needed.\n\nfunc PathUnescape(s string) (string, error)\n    PathUnescape does the inverse transformation of PathEscape, converting each\n    3-byte encoded substring of the form \"%AB\" into the hex-decoded byte 0xAB.\n    It returns an error if any % is not followed by two hexadecimal digits.\n\n    PathUnescape is identical to QueryUnescape except that it does not unescape\n    '+' to ' ' (space).\n\nfunc QueryEscape(s string) string\n    QueryEscape escapes the string so it can be safely placed inside a URL\n    query.\n\nfunc QueryUnescape(s string) (string, error)\n    QueryUnescape does the inverse transformation of QueryEscape, converting\n    each 3-byte encoded substring of the form \"%AB\" into the hex-decoded byte\n    0xAB. It returns an error if any % is not followed by two hexadecimal\n    digits.\n\n\nTYPES\n\ntype Error struct {\n\tOp  string\n\tURL string\n\tErr error\n}\n    Error reports an error and the operation and URL that caused it.\n\nfunc (e *Error) Error() string\n\nfunc (e *Error) Temporary() bool\n\nfunc (e *Error) Timeout() bool\n\nfunc (e *Error) Unwrap() error\n\ntype EscapeError string\n\nfunc (e EscapeError) Error() string\n\ntype InvalidHostError string\n\nfunc (e InvalidHostError) Error() string\n\ntype URL struct {\n\tScheme      string\n\tOpaque      string    // encoded opaque data\n\tUser        *Userinfo // username and password information\n\tHost        string    // host or host:port (see Hostname and Port methods)\n\tPath        string    // path (relative paths may omit leading slash)\n\tRawPath     string    // encoded path hint (see EscapedPath method)\n\tOmitHost    bool      // do not emit empty host (authority)\n\tForceQuery  bool      // append a query ('?') even if RawQuery is empty\n\tRawQuery    string    // encoded query values, without '?'\n\tFragment    string    // fragment for references, without '#'\n\tRawFragment string    // encoded fragment hint (see EscapedFragment method)\n}\n    A URL represents a parsed URL (technically, a URI reference).\n\n    The general form represented is:\n\n        [scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\n    URLs that do not start with a slash after the scheme are interpreted as:\n\n        scheme:opaque[?query][#fragment]\n\n    The Host field contains the host and port subcomponents of the URL.\n    When the port is present, it is separated from the host with a colon.\n    When the host is an IPv6 address, it must be enclosed in square brackets:\n    \"[fe80::1]:80\". The net.JoinHostPort function combines a host and port into\n    a string suitable for the Host field, adding square brackets to the host\n    when necessary.\n\n    Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\n    A consequence is that it is impossible to tell which slashes in the Path\n    were slashes in the raw URL and which were %2f. This distinction is rarely\n    important, but when it is, the code should use the URL.EscapedPath method,\n    which preserves the original encoding of Path.\n\n    The RawPath field is an optional field which is only set when the default\n    encoding of Path is different from the escaped path. See the EscapedPath\n    method for more details.\n\n    URL's String method uses the EscapedPath method to obtain the path.\n\nfunc Parse(rawURL string) (*URL, error)\n    Parse parses a raw url into a URL structure.\n\n    The url may be relative (a path, without a host) or absolute (starting with\n    a scheme). Trying to parse a hostname and path without a scheme is invalid\n    but may not necessarily return an error, due to parsing ambiguities.\n\nfunc ParseRequestURI(rawURL string) (*URL, error)\n    ParseRequestURI parses a raw url into a URL structure. It assumes that\n    url was received in an HTTP request, so the url is interpreted only as an\n    absolute URI or an absolute path. The string url is assumed not to have a\n    #fragment suffix. (Web browsers strip #fragment before sending the URL to a\n    web server.)\n\nfunc (u *URL) AppendBinary(b []byte) ([]byte, error)\n\nfunc (u *URL) EscapedFragment() string\n    EscapedFragment returns the escaped form of u.Fragment. In general there\n    are multiple possible escaped forms of any fragment. EscapedFragment\n    returns u.RawFragment when it is a valid escaping of u.Fragment. Otherwise\n    EscapedFragment ignores u.RawFragment and computes an escaped form on its\n    own. The URL.String method uses EscapedFragment to construct its result. In\n    general, code should call EscapedFragment instead of reading u.RawFragment\n    directly.\n\nfunc (u *URL) EscapedPath() string\n    EscapedPath returns the escaped form of u.Path. In general there are\n    multiple possible escaped forms of any path. EscapedPath returns u.RawPath\n    when it is a valid escaping of u.Path. Otherwise EscapedPath ignores\n    u.RawPath and computes an escaped form on its own. The URL.String and\n    URL.RequestURI methods use EscapedPath to construct their results. In\n    general, code should call EscapedPath instead of reading u.RawPath directly.\n\nfunc (u *URL) Hostname() string\n    Hostname returns u.Host, stripping any valid port number if present.\n\n    If the result is enclosed in square brackets, as literal IPv6 addresses are,\n    the square brackets are removed from the result.\n\nfunc (u *URL) IsAbs() bool\n    IsAbs reports whether the URL is absolute. Absolute means that it has a\n    non-empty scheme.\n\nfunc (u *URL) JoinPath(elem ...string) *URL\n    JoinPath returns a new URL with the provided path elements joined to any\n    existing path and the resulting path cleaned of any ./ or ../ elements.\n    Any sequences of multiple / characters will be reduced to a single /.\n\nfunc (u *URL) MarshalBinary() (text []byte, err error)\n\nfunc (u *URL) Parse(ref string) (*URL, error)\n    Parse parses a URL in the context of the receiver. The provided URL may be\n    relative or absolute. Parse returns nil, err on parse failure, otherwise its\n    return value is the same as URL.ResolveReference.\n\nfunc (u *URL) Port() string\n    Port returns the port part of u.Host, without the leading colon.\n\n    If u.Host doesn't contain a valid numeric port, Port returns an empty\n    string.\n\nfunc (u *URL) Query() Values\n    Query parses RawQuery and returns the corresponding values. It silently\n    discards malformed value pairs. To check errors use ParseQuery.\n\nfunc (u *URL) Redacted() string\n    Redacted is like URL.String but replaces any password with \"xxxxx\". Only the\n    password in u.User is redacted.\n\nfunc (u *URL) RequestURI() string\n    RequestURI returns the encoded path?query or opaque?query string that would\n    be used in an HTTP request for u.\n\nfunc (u *URL) ResolveReference(ref *URL) *URL\n    ResolveReference resolves a URI reference to an absolute URI from an\n    absolute base URI u, per RFC 3986 Section 5.2. The URI reference may be\n    relative or absolute. ResolveReference always returns a new URL instance,\n    even if the returned URL is identical to either the base or reference.\n    If ref is an absolute URL, then ResolveReference ignores base and returns a\n    copy of ref.\n\nfunc (u *URL) String() string\n    String reassembles the URL into a valid URL string. The general form of the\n    result is one of:\n\n        scheme:opaque?query#fragment\n        scheme://userinfo@host/path?query#fragment\n\n    If u.Opaque is non-empty, String uses the first form; otherwise it uses the\n    second form. Any non-ASCII characters in host are escaped. To obtain the\n    path, String uses u.EscapedPath().\n\n    In the second form, the following rules apply:\n      - if u.Scheme is empty, scheme: is omitted.\n      - if u.User is nil, userinfo@ is omitted.\n      - if u.Host is empty, host/ is omitted.\n      - if u.Scheme and u.Host are empty and u.User is nil, the entire\n        scheme://userinfo@host/ is omitted.\n      - if u.Host is non-empty and u.Path begins with a /, the form host/path\n        does not add its own /.\n      - if u.RawQuery is empty, ?query is omitted.\n      - if u.Fragment is empty, #fragment is omitted.\n\nfunc (u *URL) UnmarshalBinary(text []byte) error\n\ntype Userinfo struct {\n\t// Has unexported fields.\n}\n    The Userinfo type is an immutable encapsulation of username and password\n    details for a URL. An existing Userinfo value is guaranteed to have a\n    username set (potentially empty, as allowed by RFC 2396), and optionally a\n    password.\n\nfunc User(username string) *Userinfo\n    User returns a Userinfo containing the provided username and no password\n    set.\n\nfunc UserPassword(username, password string) *Userinfo\n    UserPassword returns a Userinfo containing the provided username and\n    password.\n\n    This functionality should only be used with legacy web sites. RFC 2396 warns\n    that interpreting Userinfo this way \u201cis NOT RECOMMENDED, because the passing\n    of authentication information in clear text (such as URI) has proven to be a\n    security risk in almost every case where it has been used.\u201d\n\nfunc (u *Userinfo) Password() (string, bool)\n    Password returns the password in case it is set, and whether it is set.\n\nfunc (u *Userinfo) String() string\n    String returns the encoded userinfo information in the standard form of\n    \"username[:password]\".\n\nfunc (u *Userinfo) Username() string\n    Username returns the username.\n\ntype Values map[string][]string\n    Values maps a string key to a list of values. It is typically used for query\n    parameters and form values. Unlike in the http.Header map, the keys in a\n    Values map are case-sensitive.\n\nfunc ParseQuery(query string) (Values, error)\n    ParseQuery parses the URL-encoded query string and returns a map listing\n    the values specified for each key. ParseQuery always returns a non-nil map\n    containing all the valid query parameters found; err describes the first\n    decoding error encountered, if any.\n\n    Query is expected to be a list of key=value settings separated by\n    ampersands. A setting without an equals sign is interpreted as a key set\n    to an empty value. Settings containing a non-URL-encoded semicolon are\n    considered invalid.\n\nfunc (v Values) Add(key, value string)\n    Add adds the value to key. It appends to any existing values associated with\n    key.\n\nfunc (v Values) Del(key string)\n    Del deletes the values associated with key.\n\nfunc (v Values) Encode() string\n    Encode encodes the values into \u201cURL encoded\u201d form (\"bar=baz&foo=quux\")\n    sorted by key.\n\nfunc (v Values) Get(key string) string\n    Get gets the first value associated with the given key. If there are no\n    values associated with the key, Get returns the empty string. To access\n    multiple values, use the map directly.\n\nfunc (v Values) Has(key string) bool\n    Has checks whether a given key is set.\n\nfunc (v Values) Set(key, value string)\n    Set sets the key to value. It replaces any existing values.\n\n"}, {"path": "stdlib/internal-coverage-encodemeta.md", "category": "stdlib", "name": "stdlib/internal-coverage-encodemeta", "content": "package encodemeta // import \"internal/coverage/encodemeta\"\n\n\nFUNCTIONS\n\nfunc HashFuncDesc(f *coverage.FuncDesc) [16]byte\n    HashFuncDesc computes an md5 sum of a coverage.FuncDesc and returns a digest\n    for it.\n\n\nTYPES\n\ntype CoverageMetaDataBuilder struct {\n\t// Has unexported fields.\n}\n\nfunc NewCoverageMetaDataBuilder(pkgpath string, pkgname string, modulepath string) (*CoverageMetaDataBuilder, error)\n\nfunc (b *CoverageMetaDataBuilder) AddFunc(f coverage.FuncDesc) uint\n    AddFunc registers a new function with the meta data builder.\n\nfunc (b *CoverageMetaDataBuilder) Emit(w io.WriteSeeker) ([16]byte, error)\n    Emit writes the meta-data accumulated so far in this builder to 'w'. Returns\n    a hash of the meta-data payload and an error.\n\ntype CoverageMetaFileWriter struct {\n\t// Has unexported fields.\n}\n\nfunc NewCoverageMetaFileWriter(mfname string, w io.Writer) *CoverageMetaFileWriter\n\nfunc (m *CoverageMetaFileWriter) Write(finalHash [16]byte, blobs [][]byte, mode coverage.CounterMode, granularity coverage.CounterGranularity) error\n\n"}, {"path": "stdlib/archive-tar.md", "category": "stdlib", "name": "stdlib/archive-tar", "content": "package tar // import \"archive/tar\"\n\nPackage tar implements access to tar archives.\n\nTape archives (tar) are a file format for storing a sequence of files that\ncan be read and written in a streaming manner. This package aims to cover most\nvariations of the format, including those produced by GNU and BSD tar tools.\n\nCONSTANTS\n\nconst (\n\t// Type '0' indicates a regular file.\n\tTypeReg = '0'\n\n\t// Deprecated: Use TypeReg instead.\n\tTypeRegA = '\\x00'\n\n\t// Type '1' to '6' are header-only flags and may not have a data body.\n\tTypeLink    = '1' // Hard link\n\tTypeSymlink = '2' // Symbolic link\n\tTypeChar    = '3' // Character device node\n\tTypeBlock   = '4' // Block device node\n\tTypeDir     = '5' // Directory\n\tTypeFifo    = '6' // FIFO node\n\n\t// Type '7' is reserved.\n\tTypeCont = '7'\n\n\t// Type 'x' is used by the PAX format to store key-value records that\n\t// are only relevant to the next file.\n\t// This package transparently handles these types.\n\tTypeXHeader = 'x'\n\n\t// Type 'g' is used by the PAX format to store key-value records that\n\t// are relevant to all subsequent files.\n\t// This package only supports parsing and composing such headers,\n\t// but does not currently support persisting the global state across files.\n\tTypeXGlobalHeader = 'g'\n\n\t// Type 'S' indicates a sparse file in the GNU format.\n\tTypeGNUSparse = 'S'\n\n\t// Types 'L' and 'K' are used by the GNU format for a meta file\n\t// used to store the path or link name for the next file.\n\t// This package transparently handles these types.\n\tTypeGNULongName = 'L'\n\tTypeGNULongLink = 'K'\n)\n    Type flags for Header.Typeflag.\n\n\nVARIABLES\n\nvar (\n\tErrHeader          = errors.New(\"archive/tar: invalid tar header\")\n\tErrWriteTooLong    = errors.New(\"archive/tar: write too long\")\n\tErrFieldTooLong    = errors.New(\"archive/tar: header field too long\")\n\tErrWriteAfterClose = errors.New(\"archive/tar: write after close\")\n\tErrInsecurePath    = errors.New(\"archive/tar: insecure file path\")\n)\n\nTYPES\n\ntype FileInfoNames interface {\n\tfs.FileInfo\n\t// Uname should give a user name.\n\tUname() (string, error)\n\t// Gname should give a group name.\n\tGname() (string, error)\n}\n    FileInfoNames extends fs.FileInfo. Passing an instance of this to\n    FileInfoHeader permits the caller to avoid a system-dependent name lookup by\n    specifying the Uname and Gname directly.\n\ntype Format int\n    Format represents the tar archive format.\n\n    The original tar format was introduced in Unix V7. Since then, there have\n    been multiple competing formats attempting to standardize or extend the V7\n    format to overcome its limitations. The most common formats are the USTAR,\n    PAX, and GNU formats, each with their own advantages and limitations.\n\n    The following table captures the capabilities of each format:\n\n                          |  USTAR |       PAX |       GNU\n        ------------------+--------+-----------+----------\n        Name              |   256B | unlimited | unlimited\n        Linkname          |   100B | unlimited | unlimited\n        Size              | uint33 | unlimited |    uint89\n        Mode              | uint21 |    uint21 |    uint57\n        Uid/Gid           | uint21 | unlimited |    uint57\n        Uname/Gname       |    32B | unlimited |       32B\n        ModTime           | uint33 | unlimited |     int89\n        AccessTime        |    n/a | unlimited |     int89\n        ChangeTime        |    n/a | unlimited |     int89\n        Devmajor/Devminor | uint21 |    uint21 |    uint57\n        ------------------+--------+-----------+----------\n        string encoding   |  ASCII |     UTF-8 |    binary\n        sub-second times  |     no |       yes |        no\n        sparse files      |     no |       yes |       yes\n\n    The table's upper portion shows the Header fields, where each format reports\n    the maximum number of bytes allowed for each string field and the integer\n    type used to store each numeric field (where timestamps are stored as the\n    number of seconds since the Unix epoch).\n\n    The table's lower portion shows specialized features of each format,\n    such as supported string encodings, support for sub-second timestamps,\n    or support for sparse files.\n\n    The Writer currently provides no support for sparse files.\n\nconst (\n\n\t// FormatUnknown indicates that the format is unknown.\n\tFormatUnknown Format\n\n\t// FormatUSTAR represents the USTAR header format defined in POSIX.1-1988.\n\t//\n\t// While this format is compatible with most tar readers,\n\t// the format has several limitations making it unsuitable for some usages.\n\t// Most notably, it cannot support sparse files, files larger than 8GiB,\n\t// filenames larger than 256 characters, and non-ASCII filenames.\n\t//\n\t// Reference:\n\t//\thttp://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06\n\tFormatUSTAR\n\n\t// FormatPAX represents the PAX header format defined in POSIX.1-2001.\n\t//\n\t// PAX extends USTAR by writing a special file with Typeflag TypeXHeader\n\t// preceding the original header. This file contains a set of key-value\n\t// records, which are used to overcome USTAR's shortcomings, in addition to\n\t// providing the ability to have sub-second resolution for timestamps.\n\t//\n\t// Some newer formats add their own extensions to PAX by defining their\n\t// own keys and assigning certain semantic meaning to the associated values.\n\t// For example, sparse file support in PAX is implemented using keys\n\t// defined by the GNU manual (e.g., \"GNU.sparse.map\").\n\t//\n\t// Reference:\n\t//\thttp://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html\n\tFormatPAX\n\n\t// FormatGNU represents the GNU header format.\n\t//\n\t// The GNU header format is older than the USTAR and PAX standards and\n\t// is not compatible with them. The GNU format supports\n\t// arbitrary file sizes, filenames of arbitrary encoding and length,\n\t// sparse files, and other features.\n\t//\n\t// It is recommended that PAX be chosen over GNU unless the target\n\t// application can only parse GNU formatted archives.\n\t//\n\t// Reference:\n\t//\thttps://www.gnu.org/software/tar/manual/html_node/Standard.html\n\tFormatGNU\n)\n    Constants to identify various tar formats.\n\nfunc (f Format) String() string\n\ntype Header struct {\n\t// Typeflag is the type of header entry.\n\t// The zero value is automatically promoted to either TypeReg or TypeDir\n\t// depending on the presence of a trailing slash in Name.\n\tTypeflag byte\n\n\tName     string // Name of file entry\n\tLinkname string // Target name of link (valid for TypeLink or TypeSymlink)\n\n\tSize  int64  // Logical file size in bytes\n\tMode  int64  // Permission and mode bits\n\tUid   int    // User ID of owner\n\tGid   int    // Group ID of owner\n\tUname string // User name of owner\n\tGname string // Group name of owner\n\n\t// If the Format is unspecified, then Writer.WriteHeader rounds ModTime\n\t// to the nearest second and ignores the AccessTime and ChangeTime fields.\n\t//\n\t// To use AccessTime or ChangeTime, specify the Format as PAX or GNU.\n\t// To use sub-second resolution, specify the Format as PAX.\n\tModTime    time.Time // Modification time\n\tAccessTime time.Time // Access time (requires either PAX or GNU support)\n\tChangeTime time.Time // Change time (requires either PAX or GNU support)\n\n\tDevmajor int64 // Major device number (valid for TypeChar or TypeBlock)\n\tDevminor int64 // Minor device number (valid for TypeChar or TypeBlock)\n\n\t// Xattrs stores extended attributes as PAX records under the\n\t// \"SCHILY.xattr.\" namespace.\n\t//\n\t// The following are semantically equivalent:\n\t//  h.Xattrs[key] = value\n\t//  h.PAXRecords[\"SCHILY.xattr.\"+key] = value\n\t//\n\t// When Writer.WriteHeader is called, the contents of Xattrs will take\n\t// precedence over those in PAXRecords.\n\t//\n\t// Deprecated: Use PAXRecords instead.\n\tXattrs map[string]string\n\n\t// PAXRecords is a map of PAX extended header records.\n\t//\n\t// User-defined records should have keys of the following form:\n\t//\tVENDOR.keyword\n\t// Where VENDOR is some namespace in all uppercase, and keyword may\n\t// not contain the '=' character (e.g., \"GOLANG.pkg.version\").\n\t// The key and value should be non-empty UTF-8 strings.\n\t//\n\t// When Writer.WriteHeader is called, PAX records derived from the\n\t// other fields in Header take precedence over PAXRecords.\n\tPAXRecords map[string]string\n\n\t// Format specifies the format of the tar header.\n\t//\n\t// This is set by Reader.Next as a best-effort guess at the format.\n\t// Since the Reader liberally reads some non-compliant files,\n\t// it is possible for this to be FormatUnknown.\n\t//\n\t// If the format is unspecified when Writer.WriteHeader is called,\n\t// then it uses the first format (in the order of USTAR, PAX, GNU)\n\t// capable of encoding this Header (see Format).\n\tFormat Format\n}\n    A Header represents a single header in a tar archive. Some fields may not be\n    populated.\n\n    For forward compatibility, users that retrieve a Header from Reader.Next,\n    mutate it in some ways, and then pass it back to Writer.WriteHeader\n    should do so by creating a new Header and copying the fields that they are\n    interested in preserving.\n\nfunc FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)\n    FileInfoHeader creates a partially-populated Header from fi. If fi describes\n    a symlink, FileInfoHeader records link as the link target. If fi describes a\n    directory, a slash is appended to the name.\n\n    Since fs.FileInfo's Name method only returns the base name of the file it\n    describes, it may be necessary to modify Header.Name to provide the full\n    path name of the file.\n\n    If fi implements FileInfoNames Header.Gname and Header.Uname are provided by\n    the methods of the interface.\n\nfunc (h *Header) FileInfo() fs.FileInfo\n    FileInfo returns an fs.FileInfo for the Header.\n\ntype Reader struct {\n\t// Has unexported fields.\n}\n    Reader provides sequential access to the contents of a tar archive.\n    Reader.Next advances to the next file in the archive (including the first),\n    and then Reader can be treated as an io.Reader to access the file's data.\n\nfunc NewReader(r io.Reader) *Reader\n    NewReader creates a new Reader reading from r.\n\nfunc (tr *Reader) Next() (*Header, error)\n    Next advances to the next entry in the tar archive. The Header.Size\n    determines how many bytes can be read for the next file. Any remaining data\n    in the current file is automatically discarded. At the end of the archive,\n    Next returns the error io.EOF.\n\n    If Next encounters a non-local name (as defined by filepath.IsLocal) and the\n    GODEBUG environment variable contains `tarinsecurepath=0`, Next returns the\n    header with an ErrInsecurePath error. A future version of Go may introduce\n    this behavior by default. Programs that want to accept non-local names can\n    ignore the ErrInsecurePath error and use the returned header.\n\nfunc (tr *Reader) Read(b []byte) (int, error)\n    Read reads from the current file in the tar archive. It returns (0, io.EOF)\n    when it reaches the end of that file, until [Next] is called to advance to\n    the next file.\n\n    If the current file is sparse, then the regions marked as a hole are read\n    back as NUL-bytes.\n\n    Calling Read on special types like TypeLink, TypeSymlink, TypeChar,\n    TypeBlock, TypeDir, and TypeFifo returns (0, io.EOF) regardless of what the\n    [Header.Size] claims.\n\ntype Writer struct {\n\t// Has unexported fields.\n}\n    Writer provides sequential writing of a tar archive. Writer.WriteHeader\n    begins a new file with the provided Header, and then Writer can be treated\n    as an io.Writer to supply that file's data.\n\nfunc NewWriter(w io.Writer) *Writer\n    NewWriter creates a new Writer writing to w.\n\nfunc (tw *Writer) AddFS(fsys fs.FS) error\n    AddFS adds the files from fs.FS to the archive. It walks the directory tree\n    starting at the root of the filesystem adding each file to the tar archive\n    while maintaining the directory structure.\n\nfunc (tw *Writer) Close() error\n    Close closes the tar archive by flushing the padding, and writing the\n    footer. If the current file (from a prior call to Writer.WriteHeader) is not\n    fully written, then this returns an error.\n\nfunc (tw *Writer) Flush() error\n    Flush finishes writing the current file's block padding. The current file\n    must be fully written before Flush can be called.\n\n    This is unnecessary as the next call to Writer.WriteHeader or Writer.Close\n    will implicitly flush out the file's padding.\n\nfunc (tw *Writer) Write(b []byte) (int, error)\n    Write writes to the current file in the tar archive. Write returns the\n    error ErrWriteTooLong if more than Header.Size bytes are written after\n    Writer.WriteHeader.\n\n    Calling Write on special types like TypeLink, TypeSymlink, TypeChar,\n    TypeBlock, TypeDir, and TypeFifo returns (0, ErrWriteTooLong) regardless of\n    what the [Header.Size] claims.\n\nfunc (tw *Writer) WriteHeader(hdr *Header) error\n    WriteHeader writes hdr and prepares to accept the file's contents.\n    The Header.Size determines how many bytes can be written for the next file.\n    If the current file is not fully written, then this returns an error.\n    This implicitly flushes any padding necessary before writing the header.\n\n"}, {"path": "stdlib/internal-runtime-math.md", "category": "stdlib", "name": "stdlib/internal-runtime-math", "content": "package math // import \"internal/runtime/math\"\n\n\nCONSTANTS\n\nconst (\n\tMaxUint32  = ^uint32(0)\n\tMaxUint64  = ^uint64(0)\n\tMaxUintptr = ^uintptr(0)\n\n\tMaxInt64 = int64(MaxUint64 >> 1)\n)\n\nFUNCTIONS\n\nfunc Add64(x, y, carry uint64) (sum, carryOut uint64)\n    Add64 returns the sum with carry of x, y and carry: sum = x + y + carry.\n    The carry input must be 0 or 1; otherwise the behavior is undefined.\n    The carryOut output is guaranteed to be 0 or 1.\n\n    This function's execution time does not depend on the inputs. On supported\n    platforms this is an intrinsic lowered by the compiler.\n\nfunc Mul64(x, y uint64) (hi, lo uint64)\n    Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y with the\n    product bits' upper half returned in hi and the lower half returned in lo.\n    This is a copy from math/bits.Mul64 On supported platforms this is an\n    intrinsic lowered by the compiler.\n\nfunc MulUintptr(a, b uintptr) (uintptr, bool)\n    MulUintptr returns a * b and whether the multiplication overflowed.\n    On supported platforms this is an intrinsic lowered by the compiler.\n\n"}, {"path": "stdlib/text-template-parse.md", "category": "stdlib", "name": "stdlib/text-template-parse", "content": "package parse // import \"text/template/parse\"\n\nPackage parse builds parse trees for templates as defined by text/template and\nhtml/template. Clients should use those packages to construct templates rather\nthan this one, which provides shared internal data structures not intended for\ngeneral use.\n\nFUNCTIONS\n\nfunc IsEmptyTree(n Node) bool\n    IsEmptyTree reports whether this tree (node) is empty of everything but\n    space or comments.\n\nfunc Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]any) (map[string]*Tree, error)\n    Parse returns a map from template name to Tree, created by parsing the\n    templates described in the argument string. The top-level template will be\n    given the specified name. If an error is encountered, parsing stops and an\n    empty map is returned with the error.\n\n\nTYPES\n\ntype ActionNode struct {\n\tNodeType\n\tPos\n\n\tLine int       // The line number in the input. Deprecated: Kept for compatibility.\n\tPipe *PipeNode // The pipeline in the action.\n\t// Has unexported fields.\n}\n    ActionNode holds an action (something bounded by delimiters). Control\n    actions have their own nodes; ActionNode represents simple ones such as\n    field evaluations and parenthesized pipelines.\n\nfunc (a *ActionNode) Copy() Node\n\nfunc (a *ActionNode) String() string\n\ntype BoolNode struct {\n\tNodeType\n\tPos\n\n\tTrue bool // The value of the boolean constant.\n\t// Has unexported fields.\n}\n    BoolNode holds a boolean constant.\n\nfunc (b *BoolNode) Copy() Node\n\nfunc (b *BoolNode) String() string\n\ntype BranchNode struct {\n\tNodeType\n\tPos\n\n\tLine     int       // The line number in the input. Deprecated: Kept for compatibility.\n\tPipe     *PipeNode // The pipeline to be evaluated.\n\tList     *ListNode // What to execute if the value is non-empty.\n\tElseList *ListNode // What to execute if the value is empty (nil if absent).\n\t// Has unexported fields.\n}\n    BranchNode is the common representation of if, range, and with.\n\nfunc (b *BranchNode) Copy() Node\n\nfunc (b *BranchNode) String() string\n\ntype BreakNode struct {\n\tNodeType\n\tPos\n\tLine int\n\t// Has unexported fields.\n}\n    BreakNode represents a {{break}} action.\n\nfunc (b *BreakNode) Copy() Node\n\nfunc (b *BreakNode) String() string\n\ntype ChainNode struct {\n\tNodeType\n\tPos\n\n\tNode  Node\n\tField []string // The identifiers in lexical order.\n\t// Has unexported fields.\n}\n    ChainNode holds a term followed by a chain of field accesses (identifier\n    starting with '.'). The names may be chained ('.x.y'). The periods are\n    dropped from each ident.\n\nfunc (c *ChainNode) Add(field string)\n    Add adds the named field (which should start with a period) to the end of\n    the chain.\n\nfunc (c *ChainNode) Copy() Node\n\nfunc (c *ChainNode) String() string\n\ntype CommandNode struct {\n\tNodeType\n\tPos\n\n\tArgs []Node // Arguments in lexical order: Identifier, field, or constant.\n\t// Has unexported fields.\n}\n    CommandNode holds a command (a pipeline inside an evaluating action).\n\nfunc (c *CommandNode) Copy() Node\n\nfunc (c *CommandNode) String() string\n\ntype CommentNode struct {\n\tNodeType\n\tPos\n\n\tText string // Comment text.\n\t// Has unexported fields.\n}\n    CommentNode holds a comment.\n\nfunc (c *CommentNode) Copy() Node\n\nfunc (c *CommentNode) String() string\n\ntype ContinueNode struct {\n\tNodeType\n\tPos\n\tLine int\n\t// Has unexported fields.\n}\n    ContinueNode represents a {{continue}} action.\n\nfunc (c *ContinueNode) Copy() Node\n\nfunc (c *ContinueNode) String() string\n\ntype DotNode struct {\n\tNodeType\n\tPos\n\t// Has unexported fields.\n}\n    DotNode holds the special identifier '.'.\n\nfunc (d *DotNode) Copy() Node\n\nfunc (d *DotNode) String() string\n\nfunc (d *DotNode) Type() NodeType\n\ntype FieldNode struct {\n\tNodeType\n\tPos\n\n\tIdent []string // The identifiers in lexical order.\n\t// Has unexported fields.\n}\n    FieldNode holds a field (identifier starting with '.'). The names may be\n    chained ('.x.y'). The period is dropped from each ident.\n\nfunc (f *FieldNode) Copy() Node\n\nfunc (f *FieldNode) String() string\n\ntype IdentifierNode struct {\n\tNodeType\n\tPos\n\n\tIdent string // The identifier's name.\n\t// Has unexported fields.\n}\n    IdentifierNode holds an identifier.\n\nfunc NewIdentifier(ident string) *IdentifierNode\n    NewIdentifier returns a new IdentifierNode with the given identifier name.\n\nfunc (i *IdentifierNode) Copy() Node\n\nfunc (i *IdentifierNode) SetPos(pos Pos) *IdentifierNode\n    SetPos sets the position. NewIdentifier is a public method so we can't\n    modify its signature. Chained for convenience. TODO: fix one day?\n\nfunc (i *IdentifierNode) SetTree(t *Tree) *IdentifierNode\n    SetTree sets the parent tree for the node. NewIdentifier is a public method\n    so we can't modify its signature. Chained for convenience. TODO: fix one\n    day?\n\nfunc (i *IdentifierNode) String() string\n\ntype IfNode struct {\n\tBranchNode\n}\n    IfNode represents an {{if}} action and its commands.\n\nfunc (i *IfNode) Copy() Node\n\ntype ListNode struct {\n\tNodeType\n\tPos\n\n\tNodes []Node // The element nodes in lexical order.\n\t// Has unexported fields.\n}\n    ListNode holds a sequence of nodes.\n\nfunc (l *ListNode) Copy() Node\n\nfunc (l *ListNode) CopyList() *ListNode\n\nfunc (l *ListNode) String() string\n\ntype Mode uint\n    A mode value is a set of flags (or 0). Modes control parser behavior.\n\nconst (\n\tParseComments Mode = 1 << iota // parse comments and add them to AST\n\tSkipFuncCheck                  // do not check that functions are defined\n)\ntype NilNode struct {\n\tNodeType\n\tPos\n\t// Has unexported fields.\n}\n    NilNode holds the special identifier 'nil' representing an untyped nil\n    constant.\n\nfunc (n *NilNode) Copy() Node\n\nfunc (n *NilNode) String() string\n\nfunc (n *NilNode) Type() NodeType\n\ntype Node interface {\n\tType() NodeType\n\tString() string\n\t// Copy does a deep copy of the Node and all its components.\n\t// To avoid type assertions, some XxxNodes also have specialized\n\t// CopyXxx methods that return *XxxNode.\n\tCopy() Node\n\tPosition() Pos // byte position of start of node in full original input string\n\n\t// Has unexported methods.\n}\n    A Node is an element in the parse tree. The interface is trivial.\n    The interface contains an unexported method so that only types local to this\n    package can satisfy it.\n\ntype NodeType int\n    NodeType identifies the type of a parse tree node.\n\nconst (\n\tNodeText    NodeType = iota // Plain text.\n\tNodeAction                  // A non-control action such as a field evaluation.\n\tNodeBool                    // A boolean constant.\n\tNodeChain                   // A sequence of field accesses.\n\tNodeCommand                 // An element of a pipeline.\n\tNodeDot                     // The cursor, dot.\n\n\tNodeField      // A field or method name.\n\tNodeIdentifier // An identifier; always a function name.\n\tNodeIf         // An if action.\n\tNodeList       // A list of Nodes.\n\tNodeNil        // An untyped nil constant.\n\tNodeNumber     // A numerical constant.\n\tNodePipe       // A pipeline of commands.\n\tNodeRange      // A range action.\n\tNodeString     // A string constant.\n\tNodeTemplate   // A template invocation action.\n\tNodeVariable   // A $ variable.\n\tNodeWith       // A with action.\n\tNodeComment    // A comment.\n\tNodeBreak      // A break action.\n\tNodeContinue   // A continue action.\n)\nfunc (t NodeType) Type() NodeType\n    Type returns itself and provides an easy default implementation for\n    embedding in a Node. Embedded in all non-trivial Nodes.\n\ntype NumberNode struct {\n\tNodeType\n\tPos\n\n\tIsInt      bool       // Number has an integral value.\n\tIsUint     bool       // Number has an unsigned integral value.\n\tIsFloat    bool       // Number has a floating-point value.\n\tIsComplex  bool       // Number is complex.\n\tInt64      int64      // The signed integer value.\n\tUint64     uint64     // The unsigned integer value.\n\tFloat64    float64    // The floating-point value.\n\tComplex128 complex128 // The complex value.\n\tText       string     // The original textual representation from the input.\n\t// Has unexported fields.\n}\n    NumberNode holds a number: signed or unsigned integer, float, or complex.\n    The value is parsed and stored under all the types that can represent the\n    value. This simulates in a small amount of code the behavior of Go's ideal\n    constants.\n\nfunc (n *NumberNode) Copy() Node\n\nfunc (n *NumberNode) String() string\n\ntype PipeNode struct {\n\tNodeType\n\tPos\n\n\tLine     int             // The line number in the input. Deprecated: Kept for compatibility.\n\tIsAssign bool            // The variables are being assigned, not declared.\n\tDecl     []*VariableNode // Variables in lexical order.\n\tCmds     []*CommandNode  // The commands in lexical order.\n\t// Has unexported fields.\n}\n    PipeNode holds a pipeline with optional declaration\n\nfunc (p *PipeNode) Copy() Node\n\nfunc (p *PipeNode) CopyPipe() *PipeNode\n\nfunc (p *PipeNode) String() string\n\ntype Pos int\n    Pos represents a byte position in the original input text from which this\n    template was parsed.\n\nfunc (p Pos) Position() Pos\n\ntype RangeNode struct {\n\tBranchNode\n}\n    RangeNode represents a {{range}} action and its commands.\n\nfunc (r *RangeNode) Copy() Node\n\ntype StringNode struct {\n\tNodeType\n\tPos\n\n\tQuoted string // The original text of the string, with quotes.\n\tText   string // The string, after quote processing.\n\t// Has unexported fields.\n}\n    StringNode holds a string constant. The value has been \"unquoted\".\n\nfunc (s *StringNode) Copy() Node\n\nfunc (s *StringNode) String() string\n\ntype TemplateNode struct {\n\tNodeType\n\tPos\n\n\tLine int       // The line number in the input. Deprecated: Kept for compatibility.\n\tName string    // The name of the template (unquoted).\n\tPipe *PipeNode // The command to evaluate as dot for the template.\n\t// Has unexported fields.\n}\n    TemplateNode represents a {{template}} action.\n\nfunc (t *TemplateNode) Copy() Node\n\nfunc (t *TemplateNode) String() string\n\ntype TextNode struct {\n\tNodeType\n\tPos\n\n\tText []byte // The text; may span newlines.\n\t// Has unexported fields.\n}\n    TextNode holds plain text.\n\nfunc (t *TextNode) Copy() Node\n\nfunc (t *TextNode) String() string\n\ntype Tree struct {\n\tName      string    // name of the template represented by the tree.\n\tParseName string    // name of the top-level template during parsing, for error messages.\n\tRoot      *ListNode // top-level root of the tree.\n\tMode      Mode      // parsing mode.\n\n\t// Has unexported fields.\n}\n    Tree is the representation of a single parsed template.\n\nfunc New(name string, funcs ...map[string]any) *Tree\n    New allocates a new parse tree with the given name.\n\nfunc (t *Tree) Copy() *Tree\n    Copy returns a copy of the Tree. Any parsing state is discarded.\n\nfunc (t *Tree) ErrorContext(n Node) (location, context string)\n    ErrorContext returns a textual representation of the location of the node\n    in the input text. The receiver is only used when the node does not have a\n    pointer to the tree inside, which can occur in old code.\n\nfunc (t *Tree) Parse(text, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]any) (tree *Tree, err error)\n    Parse parses the template definition string to construct a representation\n    of the template for execution. If either action delimiter string is empty,\n    the default (\"{{\" or \"}}\") is used. Embedded template definitions are added\n    to the treeSet map.\n\ntype VariableNode struct {\n\tNodeType\n\tPos\n\n\tIdent []string // Variable name and fields in lexical order.\n\t// Has unexported fields.\n}\n    VariableNode holds a list of variable names, possibly with chained field\n    accesses. The dollar sign is part of the (first) name.\n\nfunc (v *VariableNode) Copy() Node\n\nfunc (v *VariableNode) String() string\n\ntype WithNode struct {\n\tBranchNode\n}\n    WithNode represents a {{with}} action and its commands.\n\nfunc (w *WithNode) Copy() Node\n\n"}, {"path": "stdlib/regexp-syntax.md", "category": "stdlib", "name": "stdlib/regexp-syntax", "content": "package syntax // import \"regexp/syntax\"\n\nPackage syntax parses regular expressions into parse trees and compiles parse\ntrees into programs. Most clients of regular expressions will use the facilities\nof package regexp (such as regexp.Compile and regexp.Match) instead of this\npackage.\n\n# Syntax\n\nThe regular expression syntax understood by this package when parsing with\nthe Perl flag is as follows. Parts of the syntax can be disabled by passing\nalternate flags to Parse.\n\nSingle characters:\n\n    .              any character, possibly including newline (flag s=true)\n    [xyz]          character class\n    [^xyz]         negated character class\n    \\d             Perl character class\n    \\D             negated Perl character class\n    [[:alpha:]]    ASCII character class\n    [[:^alpha:]]   negated ASCII character class\n    \\pN            Unicode character class (one-letter name)\n    \\p{Greek}      Unicode character class\n    \\PN            negated Unicode character class (one-letter name)\n    \\P{Greek}      negated Unicode character class\n\nComposites:\n\n    xy             x followed by y\n    x|y            x or y (prefer x)\n\nRepetitions:\n\n    x*             zero or more x, prefer more\n    x+             one or more x, prefer more\n    x?             zero or one x, prefer one\n    x{n,m}         n or n+1 or ... or m x, prefer more\n    x{n,}          n or more x, prefer more\n    x{n}           exactly n x\n    x*?            zero or more x, prefer fewer\n    x+?            one or more x, prefer fewer\n    x??            zero or one x, prefer zero\n    x{n,m}?        n or n+1 or ... or m x, prefer fewer\n    x{n,}?         n or more x, prefer fewer\n    x{n}?          exactly n x\n\nImplementation restriction: The counting forms x{n,m}, x{n,}, and x{n} reject\nforms that create a minimum or maximum repetition count above 1000. Unlimited\nrepetitions are not subject to this restriction.\n\nGrouping:\n\n    (re)           numbered capturing group (submatch)\n    (?P<name>re)   named & numbered capturing group (submatch)\n    (?<name>re)    named & numbered capturing group (submatch)\n    (?:re)         non-capturing group\n    (?flags)       set flags within current group; non-capturing\n    (?flags:re)    set flags during re; non-capturing\n\n    Flag syntax is xyz (set) or -xyz (clear) or xy-z (set xy, clear z). The flags are:\n\n    i              case-insensitive (default false)\n    m              multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false)\n    s              let . match \\n (default false)\n    U              ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false)\n\nEmpty strings:\n\n    ^              at beginning of text or line (flag m=true)\n    $              at end of text (like \\z not \\Z) or line (flag m=true)\n    \\A             at beginning of text\n    \\b             at ASCII word boundary (\\w on one side and \\W, \\A, or \\z on the other)\n    \\B             not at ASCII word boundary\n    \\z             at end of text\n\nEscape sequences:\n\n    \\a             bell (== \\007)\n    \\f             form feed (== \\014)\n    \\t             horizontal tab (== \\011)\n    \\n             newline (== \\012)\n    \\r             carriage return (== \\015)\n    \\v             vertical tab character (== \\013)\n    \\*             literal *, for any punctuation character *\n    \\123           octal character code (up to three digits)\n    \\x7F           hex character code (exactly two digits)\n    \\x{10FFFF}     hex character code\n    \\Q...\\E        literal text ... even if ... has punctuation\n\nCharacter class elements:\n\n    x              single character\n    A-Z            character range (inclusive)\n    \\d             Perl character class\n    [:foo:]        ASCII character class foo\n    \\p{Foo}        Unicode character class Foo\n    \\pF            Unicode character class F (one-letter name)\n\nNamed character classes as character class elements:\n\n    [\\d]           digits (== \\d)\n    [^\\d]          not digits (== \\D)\n    [\\D]           not digits (== \\D)\n    [^\\D]          not not digits (== \\d)\n    [[:name:]]     named ASCII class inside character class (== [:name:])\n    [^[:name:]]    named ASCII class inside negated character class (== [:^name:])\n    [\\p{Name}]     named Unicode property inside character class (== \\p{Name})\n    [^\\p{Name}]    named Unicode property inside negated character class (== \\P{Name})\n\nPerl character classes (all ASCII-only):\n\n    \\d             digits (== [0-9])\n    \\D             not digits (== [^0-9])\n    \\s             whitespace (== [\\t\\n\\f\\r ])\n    \\S             not whitespace (== [^\\t\\n\\f\\r ])\n    \\w             word characters (== [0-9A-Za-z_])\n    \\W             not word characters (== [^0-9A-Za-z_])\n\nASCII character classes:\n\n    [[:alnum:]]    alphanumeric (== [0-9A-Za-z])\n    [[:alpha:]]    alphabetic (== [A-Za-z])\n    [[:ascii:]]    ASCII (== [\\x00-\\x7F])\n    [[:blank:]]    blank (== [\\t ])\n    [[:cntrl:]]    control (== [\\x00-\\x1F\\x7F])\n    [[:digit:]]    digits (== [0-9])\n    [[:graph:]]    graphical (== [!-~] == [A-Za-z0-9!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~])\n    [[:lower:]]    lower case (== [a-z])\n    [[:print:]]    printable (== [ -~] == [ [:graph:]])\n    [[:punct:]]    punctuation (== [!-/:-@[-`{-~])\n    [[:space:]]    whitespace (== [\\t\\n\\v\\f\\r ])\n    [[:upper:]]    upper case (== [A-Z])\n    [[:word:]]     word characters (== [0-9A-Za-z_])\n    [[:xdigit:]]   hex digit (== [0-9A-Fa-f])\n\nUnicode character classes are those in unicode.Categories,\nunicode.CategoryAliases, and unicode.Scripts.\n\nFUNCTIONS\n\nfunc IsWordChar(r rune) bool\n    IsWordChar reports whether r is considered a \u201cword character\u201d during the\n    evaluation of the \\b and \\B zero-width assertions. These assertions are\n    ASCII-only: the word characters are [A-Za-z0-9_].\n\n\nTYPES\n\ntype EmptyOp uint8\n    An EmptyOp specifies a kind or mixture of zero-width assertions.\n\nconst (\n\tEmptyBeginLine EmptyOp = 1 << iota\n\tEmptyEndLine\n\tEmptyBeginText\n\tEmptyEndText\n\tEmptyWordBoundary\n\tEmptyNoWordBoundary\n)\nfunc EmptyOpContext(r1, r2 rune) EmptyOp\n    EmptyOpContext returns the zero-width assertions satisfied at the position\n    between the runes r1 and r2. Passing r1 == -1 indicates that the position is\n    at the beginning of the text. Passing r2 == -1 indicates that the position\n    is at the end of the text.\n\ntype Error struct {\n\tCode ErrorCode\n\tExpr string\n}\n    An Error describes a failure to parse a regular expression and gives the\n    offending expression.\n\nfunc (e *Error) Error() string\n\ntype ErrorCode string\n    An ErrorCode describes a failure to parse a regular expression.\n\nconst (\n\t// Unexpected error\n\tErrInternalError ErrorCode = \"regexp/syntax: internal error\"\n\n\t// Parse errors\n\tErrInvalidCharClass      ErrorCode = \"invalid character class\"\n\tErrInvalidCharRange      ErrorCode = \"invalid character class range\"\n\tErrInvalidEscape         ErrorCode = \"invalid escape sequence\"\n\tErrInvalidNamedCapture   ErrorCode = \"invalid named capture\"\n\tErrInvalidPerlOp         ErrorCode = \"invalid or unsupported Perl syntax\"\n\tErrInvalidRepeatOp       ErrorCode = \"invalid nested repetition operator\"\n\tErrInvalidRepeatSize     ErrorCode = \"invalid repeat count\"\n\tErrInvalidUTF8           ErrorCode = \"invalid UTF-8\"\n\tErrMissingBracket        ErrorCode = \"missing closing ]\"\n\tErrMissingParen          ErrorCode = \"missing closing )\"\n\tErrMissingRepeatArgument ErrorCode = \"missing argument to repetition operator\"\n\tErrTrailingBackslash     ErrorCode = \"trailing backslash at end of expression\"\n\tErrUnexpectedParen       ErrorCode = \"unexpected )\"\n\tErrNestingDepth          ErrorCode = \"expression nests too deeply\"\n\tErrLarge                 ErrorCode = \"expression too large\"\n)\nfunc (e ErrorCode) String() string\n\ntype Flags uint16\n    Flags control the behavior of the parser and record information about regexp\n    context.\n\nconst (\n\tFoldCase      Flags = 1 << iota // case-insensitive match\n\tLiteral                         // treat pattern as literal string\n\tClassNL                         // allow character classes like [^a-z] and [[:space:]] to match newline\n\tDotNL                           // allow . to match newline\n\tOneLine                         // treat ^ and $ as only matching at beginning and end of text\n\tNonGreedy                       // make repetition operators default to non-greedy\n\tPerlX                           // allow Perl extensions\n\tUnicodeGroups                   // allow \\p{Han}, \\P{Han} for Unicode group and negation\n\tWasDollar                       // regexp OpEndText was $, not \\z\n\tSimple                          // regexp contains no counted repetition\n\n\tMatchNL = ClassNL | DotNL\n\n\tPerl        = ClassNL | OneLine | PerlX | UnicodeGroups // as close to Perl as possible\n\tPOSIX Flags = 0                                         // POSIX syntax\n)\ntype Inst struct {\n\tOp   InstOp\n\tOut  uint32 // all but InstMatch, InstFail\n\tArg  uint32 // InstAlt, InstAltMatch, InstCapture, InstEmptyWidth\n\tRune []rune\n}\n    An Inst is a single instruction in a regular expression program.\n\nfunc (i *Inst) MatchEmptyWidth(before rune, after rune) bool\n    MatchEmptyWidth reports whether the instruction matches an empty string\n    between the runes before and after. It should only be called when i.Op ==\n    InstEmptyWidth.\n\nfunc (i *Inst) MatchRune(r rune) bool\n    MatchRune reports whether the instruction matches (and consumes) r.\n    It should only be called when i.Op == InstRune.\n\nfunc (i *Inst) MatchRunePos(r rune) int\n    MatchRunePos checks whether the instruction matches (and consumes) r.\n    If so, MatchRunePos returns the index of the matching rune pair (or,\n    when len(i.Rune) == 1, rune singleton). If not, MatchRunePos returns -1.\n    MatchRunePos should only be called when i.Op == InstRune.\n\nfunc (i *Inst) String() string\n\ntype InstOp uint8\n    An InstOp is an instruction opcode.\n\nconst (\n\tInstAlt InstOp = iota\n\tInstAltMatch\n\tInstCapture\n\tInstEmptyWidth\n\tInstMatch\n\tInstFail\n\tInstNop\n\tInstRune\n\tInstRune1\n\tInstRuneAny\n\tInstRuneAnyNotNL\n)\nfunc (i InstOp) String() string\n\ntype Op uint8\n    An Op is a single regular expression operator.\n\nconst (\n\tOpNoMatch        Op = 1 + iota // matches no strings\n\tOpEmptyMatch                   // matches empty string\n\tOpLiteral                      // matches Runes sequence\n\tOpCharClass                    // matches Runes interpreted as range pair list\n\tOpAnyCharNotNL                 // matches any character except newline\n\tOpAnyChar                      // matches any character\n\tOpBeginLine                    // matches empty string at beginning of line\n\tOpEndLine                      // matches empty string at end of line\n\tOpBeginText                    // matches empty string at beginning of text\n\tOpEndText                      // matches empty string at end of text\n\tOpWordBoundary                 // matches word boundary `\\b`\n\tOpNoWordBoundary               // matches word non-boundary `\\B`\n\tOpCapture                      // capturing subexpression with index Cap, optional name Name\n\tOpStar                         // matches Sub[0] zero or more times\n\tOpPlus                         // matches Sub[0] one or more times\n\tOpQuest                        // matches Sub[0] zero or one times\n\tOpRepeat                       // matches Sub[0] at least Min times, at most Max (Max == -1 is no limit)\n\tOpConcat                       // matches concatenation of Subs\n\tOpAlternate                    // matches alternation of Subs\n)\nfunc (i Op) String() string\n\ntype Prog struct {\n\tInst   []Inst\n\tStart  int // index of start instruction\n\tNumCap int // number of InstCapture insts in re\n}\n    A Prog is a compiled regular expression program.\n\nfunc Compile(re *Regexp) (*Prog, error)\n    Compile compiles the regexp into a program to be executed. The regexp should\n    have been simplified already (returned from re.Simplify).\n\nfunc (p *Prog) Prefix() (prefix string, complete bool)\n    Prefix returns a literal string that all matches for the regexp must start\n    with. Complete is true if the prefix is the entire match.\n\nfunc (p *Prog) StartCond() EmptyOp\n    StartCond returns the leading empty-width conditions that must be true in\n    any match. It returns ^EmptyOp(0) if no matches are possible.\n\nfunc (p *Prog) String() string\n\ntype Regexp struct {\n\tOp       Op // operator\n\tFlags    Flags\n\tSub      []*Regexp  // subexpressions, if any\n\tSub0     [1]*Regexp // storage for short Sub\n\tRune     []rune     // matched runes, for OpLiteral, OpCharClass\n\tRune0    [2]rune    // storage for short Rune\n\tMin, Max int        // min, max for OpRepeat\n\tCap      int        // capturing index, for OpCapture\n\tName     string     // capturing name, for OpCapture\n}\n    A Regexp is a node in a regular expression syntax tree.\n\nfunc Parse(s string, flags Flags) (*Regexp, error)\n    Parse parses a regular expression string s, controlled by the specified\n    Flags, and returns a regular expression parse tree. The syntax is described\n    in the top-level comment.\n\nfunc (re *Regexp) CapNames() []string\n    CapNames walks the regexp to find the names of capturing groups.\n\nfunc (x *Regexp) Equal(y *Regexp) bool\n    Equal reports whether x and y have identical structure.\n\nfunc (re *Regexp) MaxCap() int\n    MaxCap walks the regexp to find the maximum capture index.\n\nfunc (re *Regexp) Simplify() *Regexp\n    Simplify returns a regexp equivalent to re but without counted repetitions\n    and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/.\n    The resulting regexp will execute correctly but its string representation\n    will not produce the same parse tree, because capturing parentheses may have\n    been duplicated or removed. For example, the simplified form for /(x){1,2}/\n    is /(x)(x)?/ but both parentheses capture as $1. The returned regexp may\n    share structure with or be the original.\n\nfunc (re *Regexp) String() string\n\n"}, {"path": "stdlib/crypto-mlkem.md", "category": "stdlib", "name": "stdlib/crypto-mlkem", "content": "package mlkem // import \"crypto/mlkem\"\n\nPackage mlkem implements the quantum-resistant key encapsulation method ML-KEM\n(formerly known as Kyber), as specified in NIST FIPS 203.\n\nMost applications should use the ML-KEM-768 parameter set, as implemented by\nDecapsulationKey768 and EncapsulationKey768.\n\n[NIST FIPS 203]: https://doi.org/10.6028/NIST.FIPS.203\n\nCONSTANTS\n\nconst (\n\t// SharedKeySize is the size of a shared key produced by ML-KEM.\n\tSharedKeySize = 32\n\n\t// SeedSize is the size of a seed used to generate a decapsulation key.\n\tSeedSize = 64\n\n\t// CiphertextSize768 is the size of a ciphertext produced by ML-KEM-768.\n\tCiphertextSize768 = 1088\n\n\t// EncapsulationKeySize768 is the size of an ML-KEM-768 encapsulation key.\n\tEncapsulationKeySize768 = 1184\n\n\t// CiphertextSize1024 is the size of a ciphertext produced by ML-KEM-1024.\n\tCiphertextSize1024 = 1568\n\n\t// EncapsulationKeySize1024 is the size of an ML-KEM-1024 encapsulation key.\n\tEncapsulationKeySize1024 = 1568\n)\n\nTYPES\n\ntype DecapsulationKey1024 struct {\n\t// Has unexported fields.\n}\n    DecapsulationKey1024 is the secret key used to decapsulate a shared key from\n    a ciphertext. It includes various precomputed values.\n\nfunc GenerateKey1024() (*DecapsulationKey1024, error)\n    GenerateKey1024 generates a new decapsulation key, drawing random bytes from\n    the default crypto/rand source. The decapsulation key must be kept secret.\n\nfunc NewDecapsulationKey1024(seed []byte) (*DecapsulationKey1024, error)\n    NewDecapsulationKey1024 expands a decapsulation key from a 64-byte seed in\n    the \"d || z\" form. The seed must be uniformly random.\n\nfunc (dk *DecapsulationKey1024) Bytes() []byte\n    Bytes returns the decapsulation key as a 64-byte seed in the \"d || z\" form.\n\n    The decapsulation key must be kept secret.\n\nfunc (dk *DecapsulationKey1024) Decapsulate(ciphertext []byte) (sharedKey []byte, err error)\n    Decapsulate generates a shared key from a ciphertext and a decapsulation\n    key. If the ciphertext is not valid, Decapsulate returns an error.\n\n    The shared key must be kept secret.\n\nfunc (dk *DecapsulationKey1024) EncapsulationKey() *EncapsulationKey1024\n    EncapsulationKey returns the public encapsulation key necessary to produce\n    ciphertexts.\n\ntype DecapsulationKey768 struct {\n\t// Has unexported fields.\n}\n    DecapsulationKey768 is the secret key used to decapsulate a shared key from\n    a ciphertext. It includes various precomputed values.\n\nfunc GenerateKey768() (*DecapsulationKey768, error)\n    GenerateKey768 generates a new decapsulation key, drawing random bytes from\n    the default crypto/rand source. The decapsulation key must be kept secret.\n\nfunc NewDecapsulationKey768(seed []byte) (*DecapsulationKey768, error)\n    NewDecapsulationKey768 expands a decapsulation key from a 64-byte seed in\n    the \"d || z\" form. The seed must be uniformly random.\n\nfunc (dk *DecapsulationKey768) Bytes() []byte\n    Bytes returns the decapsulation key as a 64-byte seed in the \"d || z\" form.\n\n    The decapsulation key must be kept secret.\n\nfunc (dk *DecapsulationKey768) Decapsulate(ciphertext []byte) (sharedKey []byte, err error)\n    Decapsulate generates a shared key from a ciphertext and a decapsulation\n    key. If the ciphertext is not valid, Decapsulate returns an error.\n\n    The shared key must be kept secret.\n\nfunc (dk *DecapsulationKey768) EncapsulationKey() *EncapsulationKey768\n    EncapsulationKey returns the public encapsulation key necessary to produce\n    ciphertexts.\n\ntype EncapsulationKey1024 struct {\n\t// Has unexported fields.\n}\n    An EncapsulationKey1024 is the public key used to produce ciphertexts to be\n    decapsulated by the corresponding DecapsulationKey1024.\n\nfunc NewEncapsulationKey1024(encapsulationKey []byte) (*EncapsulationKey1024, error)\n    NewEncapsulationKey1024 parses an encapsulation key from its encoded form.\n    If the encapsulation key is not valid, NewEncapsulationKey1024 returns an\n    error.\n\nfunc (ek *EncapsulationKey1024) Bytes() []byte\n    Bytes returns the encapsulation key as a byte slice.\n\nfunc (ek *EncapsulationKey1024) Encapsulate() (sharedKey, ciphertext []byte)\n    Encapsulate generates a shared key and an associated ciphertext from an\n    encapsulation key, drawing random bytes from the default crypto/rand source.\n\n    The shared key must be kept secret.\n\ntype EncapsulationKey768 struct {\n\t// Has unexported fields.\n}\n    An EncapsulationKey768 is the public key used to produce ciphertexts to be\n    decapsulated by the corresponding DecapsulationKey768.\n\nfunc NewEncapsulationKey768(encapsulationKey []byte) (*EncapsulationKey768, error)\n    NewEncapsulationKey768 parses an encapsulation key from its encoded form. If\n    the encapsulation key is not valid, NewEncapsulationKey768 returns an error.\n\nfunc (ek *EncapsulationKey768) Bytes() []byte\n    Bytes returns the encapsulation key as a byte slice.\n\nfunc (ek *EncapsulationKey768) Encapsulate() (sharedKey, ciphertext []byte)\n    Encapsulate generates a shared key and an associated ciphertext from an\n    encapsulation key, drawing random bytes from the default crypto/rand source.\n\n    The shared key must be kept secret.\n\n"}, {"path": "stdlib/crypto-internal-entropy.md", "category": "stdlib", "name": "stdlib/crypto-internal-entropy", "content": "package entropy // import \"crypto/internal/entropy\"\n\nPackage entropy provides the passive entropy source for the FIPS 140-3 module.\nIt is only used in FIPS mode by crypto/internal/fips140/drbg.Read.\n\nThis complies with IG 9.3.A, Additional Comment 12, which until January 1,\n2026 allows new modules to meet an earlier version of Resolution 2(b):\n\"A software module that contains an approved DRBG that receives a LOAD command\n(or its logical equivalent) with entropy obtained from [...] inside the physical\nperimeter of the operational environment of the module [...].\"\n\nDistributions that have their own SP 800-90B entropy source should replace this\npackage with their own implementation.\n\n[earlier version]: https://csrc.nist.gov/CSRC/media/Projects/cryptographic-module-validation-program/documents/IG%209.3.A%20Resolution%202b%5BMarch%2026%202024%5D.pdf\n\nFUNCTIONS\n\nfunc Depleted(LOAD func(*[48]byte))\n    Depleted notifies the entropy source that the entropy in the module is\n    \"depleted\" and provides the callback for the LOAD command.\n\n"}, {"path": "stdlib/net-http-internal.md", "category": "stdlib", "name": "stdlib/net-http-internal", "content": "package internal // import \"net/http/internal\"\n\nPackage internal contains HTTP internals shared by net/http and\nnet/http/httputil.\n\nVARIABLES\n\nvar ErrLineTooLong = errors.New(\"header line too long\")\n\nFUNCTIONS\n\nfunc NewChunkedReader(r io.Reader) io.Reader\n    NewChunkedReader returns a new chunkedReader that translates the data read\n    from r out of HTTP \"chunked\" format before returning it. The chunkedReader\n    returns io.EOF when the final 0-length chunk is read.\n\n    NewChunkedReader is not needed by normal applications. The http package\n    automatically decodes chunking when reading response bodies.\n\nfunc NewChunkedWriter(w io.Writer) io.WriteCloser\n    NewChunkedWriter returns a new chunkedWriter that translates writes into\n    HTTP \"chunked\" format before writing them to w. Closing the returned\n    chunkedWriter sends the final 0-length chunk that marks the end of the\n    stream but does not send the final CRLF that appears after trailers;\n    trailers and the last CRLF must be written separately.\n\n    NewChunkedWriter is not needed by normal applications. The http package\n    adds chunking automatically if handlers don't set a Content-Length header.\n    Using newChunkedWriter inside a handler would result in double chunking or\n    chunking with a Content-Length length, both of which are wrong.\n\n\nTYPES\n\ntype FlushAfterChunkWriter struct {\n\t*bufio.Writer\n}\n    FlushAfterChunkWriter signals from the caller of NewChunkedWriter that each\n    chunk should be followed by a flush. It is used by the net/http.Transport\n    code to keep the buffering behavior for headers and trailers, but flush out\n    chunks aggressively in the middle for request bodies which may be generated\n    slowly. See Issue 6574.\n\n"}, {"path": "stdlib/testing.md", "category": "stdlib", "name": "stdlib/testing", "content": "package testing // import \"testing\"\n\nPackage testing provides support for automated testing of Go packages.\nIt is intended to be used in concert with the \"go test\" command, which automates\nexecution of any function of the form\n\n    func TestXxx(*testing.T)\n\nwhere Xxx does not start with a lowercase letter. The function name serves to\nidentify the test routine.\n\nWithin these functions, use T.Error, T.Fail or related methods to signal\nfailure.\n\nTo write a new test suite, create a file that contains the TestXxx functions as\ndescribed here, and give that file a name ending in \"_test.go\". The file will\nbe excluded from regular package builds but will be included when the \"go test\"\ncommand is run.\n\nThe test file can be in the same package as the one being tested, or in a\ncorresponding package with the suffix \"_test\".\n\nIf the test file is in the same package, it may refer to unexported identifiers\nwithin the package, as in this example:\n\n    package abs\n\n    import \"testing\"\n\n    func TestAbs(t *testing.T) {\n        got := Abs(-1)\n        if got != 1 {\n            t.Errorf(\"Abs(-1) = %d; want 1\", got)\n        }\n    }\n\nIf the file is in a separate \"_test\" package, the package being tested must be\nimported explicitly and only its exported identifiers may be used. This is known\nas \"black box\" testing.\n\n    package abs_test\n\n    import (\n    \t\"testing\"\n\n    \t\"path_to_pkg/abs\"\n    )\n\n    func TestAbs(t *testing.T) {\n        got := abs.Abs(-1)\n        if got != 1 {\n            t.Errorf(\"Abs(-1) = %d; want 1\", got)\n        }\n    }\n\nFor more detail, run go help test and go help testflag.\n\n# Benchmarks\n\nFunctions of the form\n\n    func BenchmarkXxx(*testing.B)\n\nare considered benchmarks, and are executed by the \"go test\" command when its\n-bench flag is provided. Benchmarks are run sequentially.\n\nFor a description of the testing flags, see go help testflag.\n\nA sample benchmark function looks like this:\n\n    func BenchmarkRandInt(b *testing.B) {\n        for b.Loop() {\n            rand.Int()\n        }\n    }\n\nThe output\n\n    BenchmarkRandInt-8   \t68453040\t        17.8 ns/op\n\nmeans that the body of the loop ran 68453040 times at a speed of 17.8 ns per\nloop.\n\nOnly the body of the loop is timed, so benchmarks may do expensive setup before\ncalling b.Loop, which will not be counted toward the benchmark measurement:\n\n    func BenchmarkBigLen(b *testing.B) {\n        big := NewBig()\n        for b.Loop() {\n            big.Len()\n        }\n    }\n\nIf a benchmark needs to test performance in a parallel setting, it may use the\nRunParallel helper function; such benchmarks are intended to be used with the go\ntest -cpu flag:\n\n    func BenchmarkTemplateParallel(b *testing.B) {\n        templ := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\"))\n        b.RunParallel(func(pb *testing.PB) {\n            var buf bytes.Buffer\n            for pb.Next() {\n                buf.Reset()\n                templ.Execute(&buf, \"World\")\n            }\n        })\n    }\n\nA detailed specification of the benchmark results format is given in\nhttps://go.dev/design/14313-benchmark-format.\n\nThere are standard tools for working with benchmark results at\ngolang.org/x/perf/cmd. In particular, golang.org/x/perf/cmd/benchstat performs\nstatistically robust A/B comparisons.\n\n# b.N-style benchmarks\n\nPrior to the introduction of B.Loop, benchmarks were written in a different\nstyle using B.N. For example:\n\n    func BenchmarkRandInt(b *testing.B) {\n        for range b.N {\n            rand.Int()\n        }\n    }\n\nIn this style of benchmark, the benchmark function must run the target code b.N\ntimes. The benchmark function is called multiple times with b.N adjusted until\nthe benchmark function lasts long enough to be timed reliably. This also means\nany setup done before the loop may be run several times.\n\nIf a benchmark needs some expensive setup before running, the timer should be\nexplicitly reset:\n\n    func BenchmarkBigLen(b *testing.B) {\n        big := NewBig()\n        b.ResetTimer()\n        for range b.N {\n            big.Len()\n        }\n    }\n\nNew benchmarks should prefer using B.Loop, which is more robust and more\nefficient.\n\n# Examples\n\nThe package also runs and verifies example code. Example functions may include\na concluding line comment that begins with \"Output:\" and is compared with the\nstandard output of the function when the tests are run. (The comparison ignores\nleading and trailing space.) These are examples of an example:\n\n    func ExampleHello() {\n        fmt.Println(\"hello\")\n        // Output: hello\n    }\n\n    func ExampleSalutations() {\n        fmt.Println(\"hello, and\")\n        fmt.Println(\"goodbye\")\n        // Output:\n        // hello, and\n        // goodbye\n    }\n\nThe comment prefix \"Unordered output:\" is like \"Output:\", but matches any line\norder:\n\n    func ExamplePerm() {\n        for _, value := range Perm(5) {\n            fmt.Println(value)\n        }\n        // Unordered output: 4\n        // 2\n        // 1\n        // 3\n        // 0\n    }\n\nExample functions without output comments are compiled but not executed.\n\nThe naming convention to declare examples for the package, a function F,\na type T and method M on type T are:\n\n    func Example() { ... }\n    func ExampleF() { ... }\n    func ExampleT() { ... }\n    func ExampleT_M() { ... }\n\nMultiple example functions for a package/type/function/method may be provided by\nappending a distinct suffix to the name. The suffix must start with a lower-case\nletter.\n\n    func Example_suffix() { ... }\n    func ExampleF_suffix() { ... }\n    func ExampleT_suffix() { ... }\n    func ExampleT_M_suffix() { ... }\n\nThe entire test file is presented as the example when it contains a single\nexample function, at least one other function, type, variable, or constant\ndeclaration, and no test or benchmark functions.\n\n# Fuzzing\n\n'go test' and the testing package support fuzzing, a testing technique where a\nfunction is called with randomly generated inputs to find bugs not anticipated\nby unit tests.\n\nFunctions of the form\n\n    func FuzzXxx(*testing.F)\n\nare considered fuzz tests.\n\nFor example:\n\n    func FuzzHex(f *testing.F) {\n      for _, seed := range [][]byte{{}, {0}, {9}, {0xa}, {0xf}, {1, 2, 3, 4}} {\n        f.Add(seed)\n      }\n      f.Fuzz(func(t *testing.T, in []byte) {\n        enc := hex.EncodeToString(in)\n        out, err := hex.DecodeString(enc)\n        if err != nil {\n          t.Fatalf(\"%v: decode: %v\", in, err)\n        }\n        if !bytes.Equal(in, out) {\n          t.Fatalf(\"%v: not equal after round trip: %v\", in, out)\n        }\n      })\n    }\n\nA fuzz test maintains a seed corpus, or a set of inputs which are run by\ndefault, and can seed input generation. Seed inputs may be registered by calling\nF.Add or by storing files in the directory testdata/fuzz/<Name> (where <Name>\nis the name of the fuzz test) within the package containing the fuzz test. Seed\ninputs are optional, but the fuzzing engine may find bugs more efficiently when\nprovided with a set of small seed inputs with good code coverage. These seed\ninputs can also serve as regression tests for bugs identified through fuzzing.\n\nThe function passed to F.Fuzz within the fuzz test is considered the fuzz\ntarget. A fuzz target must accept a *T parameter, followed by one or more\nparameters for random inputs. The types of arguments passed to F.Add must be\nidentical to the types of these parameters. The fuzz target may signal that it's\nfound a problem the same way tests do: by calling T.Fail (or any method that\ncalls it like T.Error or T.Fatal) or by panicking.\n\nWhen fuzzing is enabled (by setting the -fuzz flag to a regular expression\nthat matches a specific fuzz test), the fuzz target is called with arguments\ngenerated by repeatedly making random changes to the seed inputs. On supported\nplatforms, 'go test' compiles the test executable with fuzzing coverage\ninstrumentation. The fuzzing engine uses that instrumentation to find and\ncache inputs that expand coverage, increasing the likelihood of finding bugs.\nIf the fuzz target fails for a given input, the fuzzing engine writes the inputs\nthat caused the failure to a file in the directory testdata/fuzz/<Name> within\nthe package directory. This file later serves as a seed input. If the file can't\nbe written at that location (for example, because the directory is read-only),\nthe fuzzing engine writes the file to the fuzz cache directory within the build\ncache instead.\n\nWhen fuzzing is disabled, the fuzz target is called with the seed inputs\nregistered with F.Add and seed inputs from testdata/fuzz/<Name>. In this mode,\nthe fuzz test acts much like a regular test, with subtests started with F.Fuzz\ninstead of T.Run.\n\nSee https://go.dev/doc/fuzz for documentation about fuzzing.\n\n# Skipping\n\nTests or benchmarks may be skipped at run time with a call to T.Skip or B.Skip:\n\n    func TestTimeConsuming(t *testing.T) {\n        if testing.Short() {\n            t.Skip(\"skipping test in short mode.\")\n        }\n        ...\n    }\n\nThe T.Skip method can be used in a fuzz target if the input is invalid,\nbut should not be considered a failing input. For example:\n\n    func FuzzJSONMarshaling(f *testing.F) {\n        f.Fuzz(func(t *testing.T, b []byte) {\n            var v interface{}\n            if err := json.Unmarshal(b, &v); err != nil {\n                t.Skip()\n            }\n            if _, err := json.Marshal(v); err != nil {\n                t.Errorf(\"Marshal: %v\", err)\n            }\n        })\n    }\n\n# Subtests and Sub-benchmarks\n\nThe T.Run and B.Run methods allow defining subtests and sub-benchmarks,\nwithout having to define separate functions for each. This enables uses like\ntable-driven benchmarks and creating hierarchical tests. It also provides a way\nto share common setup and tear-down code:\n\n    func TestFoo(t *testing.T) {\n        // <setup code>\n        t.Run(\"A=1\", func(t *testing.T) { ... })\n        t.Run(\"A=2\", func(t *testing.T) { ... })\n        t.Run(\"B=1\", func(t *testing.T) { ... })\n        // <tear-down code>\n    }\n\nEach subtest and sub-benchmark has a unique name: the combination of the name\nof the top-level test and the sequence of names passed to Run, separated by\nslashes, with an optional trailing sequence number for disambiguation.\n\nThe argument to the -run, -bench, and -fuzz command-line flags is an\nunanchored regular expression that matches the test's name. For tests with\nmultiple slash-separated elements, such as subtests, the argument is itself\nslash-separated, with expressions matching each name element in turn.\nBecause it is unanchored, an empty expression matches any string. For example,\nusing \"matching\" to mean \"whose name contains\":\n\n    go test -run ''        # Run all tests.\n    go test -run Foo       # Run top-level tests matching \"Foo\", such as \"TestFooBar\".\n    go test -run Foo/A=    # For top-level tests matching \"Foo\", run subtests matching \"A=\".\n    go test -run /A=1      # For all top-level tests, run subtests matching \"A=1\".\n    go test -fuzz FuzzFoo  # Fuzz the target matching \"FuzzFoo\"\n\nThe -run argument can also be used to run a specific value in the seed corpus,\nfor debugging. For example:\n\n    go test -run=FuzzFoo/9ddb952d9814\n\nThe -fuzz and -run flags can both be set, in order to fuzz a target but skip the\nexecution of all other tests.\n\nSubtests can also be used to control parallelism. A parent test will only\ncomplete once all of its subtests complete. In this example, all tests are\nrun in parallel with each other, and only with each other, regardless of other\ntop-level tests that may be defined:\n\n    func TestGroupedParallel(t *testing.T) {\n        for _, tc := range tests {\n            t.Run(tc.Name, func(t *testing.T) {\n                t.Parallel()\n                ...\n            })\n        }\n    }\n\nRun does not return until parallel subtests have completed, providing a way to\nclean up after a group of parallel tests:\n\n    func TestTeardownParallel(t *testing.T) {\n        // This Run will not return until the parallel tests finish.\n        t.Run(\"group\", func(t *testing.T) {\n            t.Run(\"Test1\", parallelTest1)\n            t.Run(\"Test2\", parallelTest2)\n            t.Run(\"Test3\", parallelTest3)\n        })\n        // <tear-down code>\n    }\n\n# Main\n\nIt is sometimes necessary for a test or benchmark program to do extra setup or\nteardown before or after it executes. It is also sometimes necessary to control\nwhich code runs on the main thread. To support these and other cases, if a test\nfile contains a function:\n\n    func TestMain(m *testing.M)\n\nthen the generated test will call TestMain(m) instead of running the tests or\nbenchmarks directly. TestMain runs in the main goroutine and can do whatever\nsetup and teardown is necessary around a call to m.Run. m.Run will return an\nexit code that may be passed to os.Exit. If TestMain returns, the test wrapper\nwill pass the result of m.Run to os.Exit itself.\n\nWhen TestMain is called, flag.Parse has not been run. If TestMain depends on\ncommand-line flags, including those of the testing package, it should call\nflag.Parse explicitly. Command line flags are always parsed by the time test or\nbenchmark functions run.\n\nA simple implementation of TestMain is:\n\n    func TestMain(m *testing.M) {\n    \t// call flag.Parse() here if TestMain uses flags\n    \tm.Run()\n    }\n\nTestMain is a low-level primitive and should not be necessary for casual testing\nneeds, where ordinary test functions suffice.\n\n[go help test]: https://pkg.go.dev/cmd/go#hdr-Test_packages\n[go help testflag]: https://pkg.go.dev/cmd/go#hdr-Testing_flags\n\nFUNCTIONS\n\nfunc AllocsPerRun(runs int, f func()) (avg float64)\n    AllocsPerRun returns the average number of allocations during calls to f.\n    Although the return value has type float64, it will always be an integral\n    value.\n\n    To compute the number of allocations, the function will first be run once\n    as a warm-up. The average number of allocations over the specified number of\n    runs will then be measured and returned.\n\n    AllocsPerRun sets runtime.GOMAXPROCS to 1 during its measurement and will\n    restore it before returning.\n\nfunc CoverMode() string\n    CoverMode reports what the test coverage mode is set to. The values are\n    \"set\", \"count\", or \"atomic\". The return value will be empty if test coverage\n    is not enabled.\n\nfunc Coverage() float64\n    Coverage reports the current code coverage as a fraction in the range [0,\n    1]. If coverage is not enabled, Coverage returns 0.\n\n    When running a large set of sequential test cases, checking Coverage after\n    each one can be useful for identifying which test cases exercise new code\n    paths. It is not a replacement for the reports generated by 'go test -cover'\n    and 'go tool cover'.\n\nfunc Init()\n    Init registers testing flags. These flags are automatically registered by\n    the \"go test\" command before running test functions, so Init is only needed\n    when calling functions such as Benchmark without using \"go test\".\n\n    Init is not safe to call concurrently. It has no effect if it was already\n    called.\n\nfunc Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n    Main is an internal function, part of the implementation of the \"go test\"\n    command. It was exported because it is cross-package and predates \"internal\"\n    packages. It is no longer used by \"go test\" but preserved, as much as\n    possible, for other systems that simulate \"go test\" using Main, but Main\n    sometimes cannot be updated as new functionality is added to the testing\n    package. Systems simulating \"go test\" should be updated to use MainStart.\n\nfunc RegisterCover(c Cover)\n    RegisterCover records the coverage data accumulators for the tests. NOTE:\n    This function is internal to the testing infrastructure and may change.\n    It is not covered (yet) by the Go 1 compatibility guidelines.\n\nfunc RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)\n    RunBenchmarks is an internal function but exported because it is\n    cross-package; it is part of the implementation of the \"go test\" command.\n\nfunc RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)\n    RunExamples is an internal function but exported because it is\n    cross-package; it is part of the implementation of the \"go test\" command.\n\nfunc RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)\n    RunTests is an internal function but exported because it is cross-package;\n    it is part of the implementation of the \"go test\" command.\n\nfunc Short() bool\n    Short reports whether the -test.short flag is set.\n\nfunc Testing() bool\n    Testing reports whether the current code is being run in a test. This will\n    report true in programs created by \"go test\", false in programs created by\n    \"go build\".\n\nfunc Verbose() bool\n    Verbose reports whether the -test.v flag is set.\n\n\nTYPES\n\ntype B struct {\n\tN int\n\n\t// Has unexported fields.\n}\n    B is a type passed to Benchmark functions to manage benchmark timing and\n    control the number of iterations.\n\n    A benchmark ends when its Benchmark function returns or calls any of the\n    methods B.FailNow, B.Fatal, B.Fatalf, B.SkipNow, B.Skip, or B.Skipf.\n    Those methods must be called only from the goroutine running the Benchmark\n    function. The other reporting methods, such as the variations of B.Log and\n    B.Error, may be called simultaneously from multiple goroutines.\n\n    Like in tests, benchmark logs are accumulated during execution and dumped\n    to standard output when done. Unlike in tests, benchmark logs are always\n    printed, so as not to hide output whose existence may be affecting benchmark\n    results.\n\nfunc (c *B) Attr(key, value string)\n    Attr emits a test attribute associated with this test.\n\n    The key must not contain whitespace. The value must not contain newlines or\n    carriage returns.\n\n    The meaning of different attribute keys is left up to continuous integration\n    systems and test frameworks.\n\n    Test attributes are emitted immediately in the test log, but they are\n    intended to be treated as unordered.\n\nfunc (c *B) Chdir(dir string)\n    Chdir calls os.Chdir and uses Cleanup to restore the current working\n    directory to its original value after the test. On Unix, it also sets PWD\n    environment variable for the duration of the test.\n\n    Because Chdir affects the whole process, it cannot be used in parallel tests\n    or tests with parallel ancestors.\n\nfunc (c *B) Cleanup(f func())\n    Cleanup registers a function to be called when the test (or subtest) and\n    all its subtests complete. Cleanup functions will be called in last added,\n    first called order.\n\nfunc (c *B) Context() context.Context\n    Context returns a context that is canceled just before Cleanup-registered\n    functions are called.\n\n    Cleanup functions can wait for any resources that shut down on\n    context.Context.Done before the test or benchmark completes.\n\nfunc (b *B) Elapsed() time.Duration\n    Elapsed returns the measured elapsed time of the benchmark. The duration\n    reported by Elapsed matches the one measured by B.StartTimer, B.StopTimer,\n    and B.ResetTimer.\n\nfunc (c *B) Error(args ...any)\n    Error is equivalent to Log followed by Fail.\n\nfunc (c *B) Errorf(format string, args ...any)\n    Errorf is equivalent to Logf followed by Fail.\n\nfunc (c *B) Fail()\n    Fail marks the function as having failed but continues execution.\n\nfunc (c *B) FailNow()\n    FailNow marks the function as having failed and stops its execution by\n    calling runtime.Goexit (which then runs all deferred calls in the current\n    goroutine). Execution will continue at the next test or benchmark. FailNow\n    must be called from the goroutine running the test or benchmark function,\n    not from other goroutines created during the test. Calling FailNow does not\n    stop those other goroutines.\n\nfunc (c *B) Failed() bool\n    Failed reports whether the function has failed.\n\nfunc (c *B) Fatal(args ...any)\n    Fatal is equivalent to Log followed by FailNow.\n\nfunc (c *B) Fatalf(format string, args ...any)\n    Fatalf is equivalent to Logf followed by FailNow.\n\nfunc (c *B) Helper()\n    Helper marks the calling function as a test helper function. When printing\n    file and line information, that function will be skipped. Helper may be\n    called simultaneously from multiple goroutines.\n\nfunc (c *B) Log(args ...any)\n    Log formats its arguments using default formatting, analogous to\n    fmt.Println, and records the text in the error log. For tests, the text\n    will be printed only if the test fails or the -test.v flag is set. For\n    benchmarks, the text is always printed to avoid having performance depend\n    on the value of the -test.v flag. It is an error to call Log after a test or\n    benchmark returns.\n\nfunc (c *B) Logf(format string, args ...any)\n    Logf formats its arguments according to the format, analogous to fmt.Printf,\n    and records the text in the error log. A final newline is added if not\n    provided. For tests, the text will be printed only if the test fails or the\n    -test.v flag is set. For benchmarks, the text is always printed to avoid\n    having performance depend on the value of the -test.v flag. It is an error\n    to call Logf after a test or benchmark returns.\n\nfunc (b *B) Loop() bool\n    Loop returns true as long as the benchmark should continue running.\n\n    A typical benchmark is structured like:\n\n        func Benchmark(b *testing.B) {\n        \t... setup ...\n        \tfor b.Loop() {\n        \t\t... code to measure ...\n        \t}\n        \t... cleanup ...\n        }\n\n    Loop resets the benchmark timer the first time it is called in a benchmark,\n    so any setup performed prior to starting the benchmark loop does not count\n    toward the benchmark measurement. Likewise, when it returns false, it stops\n    the timer so cleanup code is not measured.\n\n    Within the body of a \"for b.Loop() { ... }\" loop, arguments to and results\n    from function calls within the loop are kept alive, preventing the compiler\n    from fully optimizing away the loop body. Currently, this is implemented by\n    disabling inlining of functions called in a b.Loop loop. This applies only\n    to calls syntactically between the curly braces of the loop, and the loop\n    condition must be written exactly as \"b.Loop()\". Optimizations are performed\n    as usual in any functions called by the loop.\n\n    After Loop returns false, b.N contains the total number of iterations that\n    ran, so the benchmark may use b.N to compute other average metrics.\n\n    Prior to the introduction of Loop, benchmarks were expected to contain an\n    explicit loop from 0 to b.N. Benchmarks should either use Loop or contain\n    a loop to b.N, but not both. Loop offers more automatic management of the\n    benchmark timer, and runs each benchmark function only once per measurement,\n    whereas b.N-based benchmarks must run the benchmark function (and any\n    associated setup and cleanup) several times.\n\nfunc (c *B) Name() string\n    Name returns the name of the running (sub-) test or benchmark.\n\n    The name will include the name of the test along with the names of any\n    nested sub-tests. If two sibling sub-tests have the same name, Name will\n    append a suffix to guarantee the returned name is unique.\n\nfunc (c *B) Output() io.Writer\n    Output returns a Writer that writes to the same test output stream as\n    TB.Log. The output is indented like TB.Log lines, but Output does not add\n    source locations or newlines. The output is internally line buffered, and\n    a call to TB.Log or the end of the test will implicitly flush the buffer,\n    followed by a newline. After a test function and all its parents return,\n    neither Output nor the Write method may be called.\n\nfunc (b *B) ReportAllocs()\n    ReportAllocs enables malloc statistics for this benchmark. It is equivalent\n    to setting -test.benchmem, but it only affects the benchmark function that\n    calls ReportAllocs.\n\nfunc (b *B) ReportMetric(n float64, unit string)\n    ReportMetric adds \"n unit\" to the reported benchmark results. If the metric\n    is per-iteration, the caller should divide by b.N, and by convention units\n    should end in \"/op\". ReportMetric overrides any previously reported value\n    for the same unit. ReportMetric panics if unit is the empty string or if\n    unit contains any whitespace. If unit is a unit normally reported by the\n    benchmark framework itself (such as \"allocs/op\"), ReportMetric will override\n    that metric. Setting \"ns/op\" to 0 will suppress that built-in metric.\n\nfunc (b *B) ResetTimer()\n    ResetTimer zeroes the elapsed benchmark time and memory allocation counters\n    and deletes user-reported metrics. It does not affect whether the timer is\n    running.\n\nfunc (b *B) Run(name string, f func(b *B)) bool\n    Run benchmarks f as a subbenchmark with the given name. It reports whether\n    there were any failures.\n\n    A subbenchmark is like any other benchmark. A benchmark that calls Run at\n    least once will not be measured itself and will be called once with N=1.\n\nfunc (b *B) RunParallel(body func(*PB))\n    RunParallel runs a benchmark in parallel. It creates multiple goroutines and\n    distributes b.N iterations among them. The number of goroutines defaults\n    to GOMAXPROCS. To increase parallelism for non-CPU-bound benchmarks,\n    call B.SetParallelism before RunParallel. RunParallel is usually used with\n    the go test -cpu flag.\n\n    The body function will be run in each goroutine. It should set up any\n    goroutine-local state and then iterate until pb.Next returns false.\n    It should not use the B.StartTimer, B.StopTimer, or B.ResetTimer functions,\n    because they have global effect. It should also not call B.Run.\n\n    RunParallel reports ns/op values as wall time for the benchmark as a whole,\n    not the sum of wall time or CPU time over each parallel goroutine.\n\nfunc (b *B) SetBytes(n int64)\n    SetBytes records the number of bytes processed in a single operation.\n    If this is called, the benchmark will report ns/op and MB/s.\n\nfunc (b *B) SetParallelism(p int)\n    SetParallelism sets the number of goroutines used by B.RunParallel to\n    p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound\n    benchmarks. If p is less than 1, this call will have no effect.\n\nfunc (c *B) Setenv(key, value string)\n    Setenv calls os.Setenv and uses Cleanup to restore the environment variable\n    to its original value after the test.\n\n    Because Setenv affects the whole process, it cannot be used in parallel\n    tests or tests with parallel ancestors.\n\nfunc (c *B) Skip(args ...any)\n    Skip is equivalent to Log followed by SkipNow.\n\nfunc (c *B) SkipNow()\n    SkipNow marks the test as having been skipped and stops its execution by\n    calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is\n    then skipped, it is still considered to have failed. Execution will continue\n    at the next test or benchmark. See also FailNow. SkipNow must be called from\n    the goroutine running the test, not from other goroutines created during the\n    test. Calling SkipNow does not stop those other goroutines.\n\nfunc (c *B) Skipf(format string, args ...any)\n    Skipf is equivalent to Logf followed by SkipNow.\n\nfunc (c *B) Skipped() bool\n    Skipped reports whether the test was skipped.\n\nfunc (b *B) StartTimer()\n    StartTimer starts timing a test. This function is called automatically\n    before a benchmark starts, but it can also be used to resume timing after a\n    call to B.StopTimer.\n\nfunc (b *B) StopTimer()\n    StopTimer stops timing a test. This can be used to pause the timer while\n    performing steps that you don't want to measure.\n\nfunc (c *B) TempDir() string\n    TempDir returns a temporary directory for the test to use. The directory\n    is automatically removed when the test and all its subtests complete.\n    Each subsequent call to TempDir returns a unique directory; if the directory\n    creation fails, TempDir terminates the test by calling Fatal.\n\ntype BenchmarkResult struct {\n\tN         int           // The number of iterations.\n\tT         time.Duration // The total time taken.\n\tBytes     int64         // Bytes processed in one iteration.\n\tMemAllocs uint64        // The total number of memory allocations.\n\tMemBytes  uint64        // The total number of bytes allocated.\n\n\t// Extra records additional metrics reported by ReportMetric.\n\tExtra map[string]float64\n}\n    BenchmarkResult contains the results of a benchmark run.\n\nfunc Benchmark(f func(b *B)) BenchmarkResult\n    Benchmark benchmarks a single function. It is useful for creating custom\n    benchmarks that do not use the \"go test\" command.\n\n    If f depends on testing flags, then Init must be used to register those\n    flags before calling Benchmark and before calling flag.Parse.\n\n    If f calls Run, the result will be an estimate of running all its\n    subbenchmarks that don't call Run in sequence in a single benchmark.\n\nfunc (r BenchmarkResult) AllocedBytesPerOp() int64\n    AllocedBytesPerOp returns the \"B/op\" metric, which is calculated as\n    r.MemBytes / r.N.\n\nfunc (r BenchmarkResult) AllocsPerOp() int64\n    AllocsPerOp returns the \"allocs/op\" metric, which is calculated as\n    r.MemAllocs / r.N.\n\nfunc (r BenchmarkResult) MemString() string\n    MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format\n    as 'go test'.\n\nfunc (r BenchmarkResult) NsPerOp() int64\n    NsPerOp returns the \"ns/op\" metric.\n\nfunc (r BenchmarkResult) String() string\n    String returns a summary of the benchmark results. It follows the benchmark\n    result line format from https://golang.org/design/14313-benchmark-format,\n    not including the benchmark name. Extra metrics override built-in metrics\n    of the same name. String does not include allocs/op or B/op, since those are\n    reported by BenchmarkResult.MemString.\n\ntype Cover struct {\n\tMode            string\n\tCounters        map[string][]uint32\n\tBlocks          map[string][]CoverBlock\n\tCoveredPackages string\n}\n    Cover records information about test coverage checking. NOTE: This struct\n    is internal to the testing infrastructure and may change. It is not covered\n    (yet) by the Go 1 compatibility guidelines.\n\ntype CoverBlock struct {\n\tLine0 uint32 // Line number for block start.\n\tCol0  uint16 // Column number for block start.\n\tLine1 uint32 // Line number for block end.\n\tCol1  uint16 // Column number for block end.\n\tStmts uint16 // Number of statements included in this block.\n}\n    CoverBlock records the coverage data for a single basic block. The fields\n    are 1-indexed, as in an editor: The opening line of the file is number 1,\n    for example. Columns are measured in bytes. NOTE: This struct is internal to\n    the testing infrastructure and may change. It is not covered (yet) by the Go\n    1 compatibility guidelines.\n\ntype F struct {\n\t// Has unexported fields.\n}\n    F is a type passed to fuzz tests.\n\n    Fuzz tests run generated inputs against a provided fuzz target, which can\n    find and report potential bugs in the code being tested.\n\n    A fuzz test runs the seed corpus by default, which includes entries provided\n    by F.Add and entries in the testdata/fuzz/<FuzzTestName> directory.\n    After any necessary setup and calls to F.Add, the fuzz test must then call\n    F.Fuzz to provide the fuzz target. See the testing package documentation for\n    an example, and see the F.Fuzz and F.Add method documentation for details.\n\n    *F methods can only be called before F.Fuzz. Once the test is executing\n    the fuzz target, only *T methods can be used. The only *F methods that are\n    allowed in the F.Fuzz function are F.Failed and F.Name.\n\nfunc (f *F) Add(args ...any)\n    Add will add the arguments to the seed corpus for the fuzz test. This will\n    be a no-op if called after or within the fuzz target, and args must match\n    the arguments for the fuzz target.\n\nfunc (c *F) Attr(key, value string)\n    Attr emits a test attribute associated with this test.\n\n    The key must not contain whitespace. The value must not contain newlines or\n    carriage returns.\n\n    The meaning of different attribute keys is left up to continuous integration\n    systems and test frameworks.\n\n    Test attributes are emitted immediately in the test log, but they are\n    intended to be treated as unordered.\n\nfunc (c *F) Chdir(dir string)\n    Chdir calls os.Chdir and uses Cleanup to restore the current working\n    directory to its original value after the test. On Unix, it also sets PWD\n    environment variable for the duration of the test.\n\n    Because Chdir affects the whole process, it cannot be used in parallel tests\n    or tests with parallel ancestors.\n\nfunc (c *F) Cleanup(f func())\n    Cleanup registers a function to be called when the test (or subtest) and\n    all its subtests complete. Cleanup functions will be called in last added,\n    first called order.\n\nfunc (c *F) Context() context.Context\n    Context returns a context that is canceled just before Cleanup-registered\n    functions are called.\n\n    Cleanup functions can wait for any resources that shut down on\n    context.Context.Done before the test or benchmark completes.\n\nfunc (c *F) Error(args ...any)\n    Error is equivalent to Log followed by Fail.\n\nfunc (c *F) Errorf(format string, args ...any)\n    Errorf is equivalent to Logf followed by Fail.\n\nfunc (f *F) Fail()\n    Fail marks the function as having failed but continues execution.\n\nfunc (c *F) FailNow()\n    FailNow marks the function as having failed and stops its execution by\n    calling runtime.Goexit (which then runs all deferred calls in the current\n    goroutine). Execution will continue at the next test or benchmark. FailNow\n    must be called from the goroutine running the test or benchmark function,\n    not from other goroutines created during the test. Calling FailNow does not\n    stop those other goroutines.\n\nfunc (c *F) Failed() bool\n    Failed reports whether the function has failed.\n\nfunc (c *F) Fatal(args ...any)\n    Fatal is equivalent to Log followed by FailNow.\n\nfunc (c *F) Fatalf(format string, args ...any)\n    Fatalf is equivalent to Logf followed by FailNow.\n\nfunc (f *F) Fuzz(ff any)\n    Fuzz runs the fuzz function, ff, for fuzz testing. If ff fails for a set of\n    arguments, those arguments will be added to the seed corpus.\n\n    ff must be a function with no return value whose first argument is *T and\n    whose remaining arguments are the types to be fuzzed. For example:\n\n        f.Fuzz(func(t *testing.T, b []byte, i int) { ... })\n\n    The following types are allowed: []byte, string, bool, byte, rune, float32,\n    float64, int, int8, int16, int32, int64, uint, uint8, uint16, uint32,\n    uint64. More types may be supported in the future.\n\n    ff must not call any *F methods, e.g. F.Log, F.Error, F.Skip. Use the\n    corresponding *T method instead. The only *F methods that are allowed in the\n    F.Fuzz function are F.Failed and F.Name.\n\n    This function should be fast and deterministic, and its behavior should not\n    depend on shared state. No mutable input arguments, or pointers to them,\n    should be retained between executions of the fuzz function, as the memory\n    backing them may be mutated during a subsequent invocation. ff must not\n    modify the underlying data of the arguments provided by the fuzzing engine.\n\n    When fuzzing, F.Fuzz does not return until a problem is found, time runs out\n    (set with -fuzztime), or the test process is interrupted by a signal. F.Fuzz\n    should be called exactly once, unless F.Skip or F.Fail is called beforehand.\n\nfunc (f *F) Helper()\n    Helper marks the calling function as a test helper function. When printing\n    file and line information, that function will be skipped. Helper may be\n    called simultaneously from multiple goroutines.\n\nfunc (c *F) Log(args ...any)\n    Log formats its arguments using default formatting, analogous to\n    fmt.Println, and records the text in the error log. For tests, the text\n    will be printed only if the test fails or the -test.v flag is set. For\n    benchmarks, the text is always printed to avoid having performance depend\n    on the value of the -test.v flag. It is an error to call Log after a test or\n    benchmark returns.\n\nfunc (c *F) Logf(format string, args ...any)\n    Logf formats its arguments according to the format, analogous to fmt.Printf,\n    and records the text in the error log. A final newline is added if not\n    provided. For tests, the text will be printed only if the test fails or the\n    -test.v flag is set. For benchmarks, the text is always printed to avoid\n    having performance depend on the value of the -test.v flag. It is an error\n    to call Logf after a test or benchmark returns.\n\nfunc (c *F) Name() string\n    Name returns the name of the running (sub-) test or benchmark.\n\n    The name will include the name of the test along with the names of any\n    nested sub-tests. If two sibling sub-tests have the same name, Name will\n    append a suffix to guarantee the returned name is unique.\n\nfunc (c *F) Output() io.Writer\n    Output returns a Writer that writes to the same test output stream as\n    TB.Log. The output is indented like TB.Log lines, but Output does not add\n    source locations or newlines. The output is internally line buffered, and\n    a call to TB.Log or the end of the test will implicitly flush the buffer,\n    followed by a newline. After a test function and all its parents return,\n    neither Output nor the Write method may be called.\n\nfunc (c *F) Setenv(key, value string)\n    Setenv calls os.Setenv and uses Cleanup to restore the environment variable\n    to its original value after the test.\n\n    Because Setenv affects the whole process, it cannot be used in parallel\n    tests or tests with parallel ancestors.\n\nfunc (c *F) Skip(args ...any)\n    Skip is equivalent to Log followed by SkipNow.\n\nfunc (c *F) SkipNow()\n    SkipNow marks the test as having been skipped and stops its execution by\n    calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is\n    then skipped, it is still considered to have failed. Execution will continue\n    at the next test or benchmark. See also FailNow. SkipNow must be called from\n    the goroutine running the test, not from other goroutines created during the\n    test. Calling SkipNow does not stop those other goroutines.\n\nfunc (c *F) Skipf(format string, args ...any)\n    Skipf is equivalent to Logf followed by SkipNow.\n\nfunc (f *F) Skipped() bool\n    Skipped reports whether the test was skipped.\n\nfunc (c *F) TempDir() string\n    TempDir returns a temporary directory for the test to use. The directory\n    is automatically removed when the test and all its subtests complete.\n    Each subsequent call to TempDir returns a unique directory; if the directory\n    creation fails, TempDir terminates the test by calling Fatal.\n\ntype InternalBenchmark struct {\n\tName string\n\tF    func(b *B)\n}\n    InternalBenchmark is an internal type but exported because it is\n    cross-package; it is part of the implementation of the \"go test\" command.\n\ntype InternalExample struct {\n\tName      string\n\tF         func()\n\tOutput    string\n\tUnordered bool\n}\n\ntype InternalFuzzTarget struct {\n\tName string\n\tFn   func(f *F)\n}\n    InternalFuzzTarget is an internal type but exported because it is\n    cross-package; it is part of the implementation of the \"go test\" command.\n\ntype InternalTest struct {\n\tName string\n\tF    func(*T)\n}\n    InternalTest is an internal type but exported because it is cross-package;\n    it is part of the implementation of the \"go test\" command.\n\ntype M struct {\n\t// Has unexported fields.\n}\n    M is a type passed to a TestMain function to run the actual tests.\n\nfunc MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, fuzzTargets []InternalFuzzTarget, examples []InternalExample) *M\n    MainStart is meant for use by tests generated by 'go test'. It is not meant\n    to be called directly and is not subject to the Go 1 compatibility document.\n    It may change signature from release to release.\n\nfunc (m *M) Run() (code int)\n    Run runs the tests. It returns an exit code to pass to os.Exit. The exit\n    code is zero when all tests pass, and non-zero for any kind of failure.\n    For machine readable test results, parse the output of 'go test -json'.\n\ntype PB struct {\n\t// Has unexported fields.\n}\n    A PB is used by RunParallel for running parallel benchmarks.\n\nfunc (pb *PB) Next() bool\n    Next reports whether there are more iterations to execute.\n\ntype T struct {\n\t// Has unexported fields.\n}\n    T is a type passed to Test functions to manage test state and support\n    formatted test logs.\n\n    A test ends when its Test function returns or calls any of the methods\n    T.FailNow, T.Fatal, T.Fatalf, T.SkipNow, T.Skip, or T.Skipf. Those methods,\n    as well as the T.Parallel method, must be called only from the goroutine\n    running the Test function.\n\n    The other reporting methods, such as the variations of T.Log and T.Error,\n    may be called simultaneously from multiple goroutines.\n\nfunc (c *T) Attr(key, value string)\n    Attr emits a test attribute associated with this test.\n\n    The key must not contain whitespace. The value must not contain newlines or\n    carriage returns.\n\n    The meaning of different attribute keys is left up to continuous integration\n    systems and test frameworks.\n\n    Test attributes are emitted immediately in the test log, but they are\n    intended to be treated as unordered.\n\nfunc (t *T) Chdir(dir string)\n    Chdir calls os.Chdir and uses Cleanup to restore the current working\n    directory to its original value after the test. On Unix, it also sets PWD\n    environment variable for the duration of the test.\n\n    Because Chdir affects the whole process, it cannot be used in parallel tests\n    or tests with parallel ancestors.\n\nfunc (c *T) Cleanup(f func())\n    Cleanup registers a function to be called when the test (or subtest) and\n    all its subtests complete. Cleanup functions will be called in last added,\n    first called order.\n\nfunc (c *T) Context() context.Context\n    Context returns a context that is canceled just before Cleanup-registered\n    functions are called.\n\n    Cleanup functions can wait for any resources that shut down on\n    context.Context.Done before the test or benchmark completes.\n\nfunc (t *T) Deadline() (deadline time.Time, ok bool)\n    Deadline reports the time at which the test binary will have exceeded the\n    timeout specified by the -timeout flag.\n\n    The ok result is false if the -timeout flag indicates \u201cno timeout\u201d (0).\n\nfunc (c *T) Error(args ...any)\n    Error is equivalent to Log followed by Fail.\n\nfunc (c *T) Errorf(format string, args ...any)\n    Errorf is equivalent to Logf followed by Fail.\n\nfunc (c *T) Fail()\n    Fail marks the function as having failed but continues execution.\n\nfunc (c *T) FailNow()\n    FailNow marks the function as having failed and stops its execution by\n    calling runtime.Goexit (which then runs all deferred calls in the current\n    goroutine). Execution will continue at the next test or benchmark. FailNow\n    must be called from the goroutine running the test or benchmark function,\n    not from other goroutines created during the test. Calling FailNow does not\n    stop those other goroutines.\n\nfunc (c *T) Failed() bool\n    Failed reports whether the function has failed.\n\nfunc (c *T) Fatal(args ...any)\n    Fatal is equivalent to Log followed by FailNow.\n\nfunc (c *T) Fatalf(format string, args ...any)\n    Fatalf is equivalent to Logf followed by FailNow.\n\nfunc (c *T) Helper()\n    Helper marks the calling function as a test helper function. When printing\n    file and line information, that function will be skipped. Helper may be\n    called simultaneously from multiple goroutines.\n\nfunc (c *T) Log(args ...any)\n    Log formats its arguments using default formatting, analogous to\n    fmt.Println, and records the text in the error log. For tests, the text\n    will be printed only if the test fails or the -test.v flag is set. For\n    benchmarks, the text is always printed to avoid having performance depend\n    on the value of the -test.v flag. It is an error to call Log after a test or\n    benchmark returns.\n\nfunc (c *T) Logf(format string, args ...any)\n    Logf formats its arguments according to the format, analogous to fmt.Printf,\n    and records the text in the error log. A final newline is added if not\n    provided. For tests, the text will be printed only if the test fails or the\n    -test.v flag is set. For benchmarks, the text is always printed to avoid\n    having performance depend on the value of the -test.v flag. It is an error\n    to call Logf after a test or benchmark returns.\n\nfunc (c *T) Name() string\n    Name returns the name of the running (sub-) test or benchmark.\n\n    The name will include the name of the test along with the names of any\n    nested sub-tests. If two sibling sub-tests have the same name, Name will\n    append a suffix to guarantee the returned name is unique.\n\nfunc (c *T) Output() io.Writer\n    Output returns a Writer that writes to the same test output stream as\n    TB.Log. The output is indented like TB.Log lines, but Output does not add\n    source locations or newlines. The output is internally line buffered, and\n    a call to TB.Log or the end of the test will implicitly flush the buffer,\n    followed by a newline. After a test function and all its parents return,\n    neither Output nor the Write method may be called.\n\nfunc (t *T) Parallel()\n    Parallel signals that this test is to be run in parallel with (and only\n    with) other parallel tests. When a test is run multiple times due to use of\n    -test.count or -test.cpu, multiple instances of a single test never run in\n    parallel with each other.\n\nfunc (t *T) Run(name string, f func(t *T)) bool\n    Run runs f as a subtest of t called name. It runs f in a separate goroutine\n    and blocks until f returns or calls t.Parallel to become a parallel test.\n    Run reports whether f succeeded (or at least did not fail before calling\n    t.Parallel).\n\n    Run may be called simultaneously from multiple goroutines, but all such\n    calls must return before the outer test function for t returns.\n\nfunc (t *T) Setenv(key, value string)\n    Setenv calls os.Setenv(key, value) and uses Cleanup to restore the\n    environment variable to its original value after the test.\n\n    Because Setenv affects the whole process, it cannot be used in parallel\n    tests or tests with parallel ancestors.\n\nfunc (c *T) Skip(args ...any)\n    Skip is equivalent to Log followed by SkipNow.\n\nfunc (c *T) SkipNow()\n    SkipNow marks the test as having been skipped and stops its execution by\n    calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is\n    then skipped, it is still considered to have failed. Execution will continue\n    at the next test or benchmark. See also FailNow. SkipNow must be called from\n    the goroutine running the test, not from other goroutines created during the\n    test. Calling SkipNow does not stop those other goroutines.\n\nfunc (c *T) Skipf(format string, args ...any)\n    Skipf is equivalent to Logf followed by SkipNow.\n\nfunc (c *T) Skipped() bool\n    Skipped reports whether the test was skipped.\n\nfunc (c *T) TempDir() string\n    TempDir returns a temporary directory for the test to use. The directory\n    is automatically removed when the test and all its subtests complete.\n    Each subsequent call to TempDir returns a unique directory; if the directory\n    creation fails, TempDir terminates the test by calling Fatal.\n\ntype TB interface {\n\tAttr(key, value string)\n\tCleanup(func())\n\tError(args ...any)\n\tErrorf(format string, args ...any)\n\tFail()\n\tFailNow()\n\tFailed() bool\n\tFatal(args ...any)\n\tFatalf(format string, args ...any)\n\tHelper()\n\tLog(args ...any)\n\tLogf(format string, args ...any)\n\tName() string\n\tSetenv(key, value string)\n\tChdir(dir string)\n\tSkip(args ...any)\n\tSkipNow()\n\tSkipf(format string, args ...any)\n\tSkipped() bool\n\tTempDir() string\n\tContext() context.Context\n\tOutput() io.Writer\n\n\t// Has unexported methods.\n}\n    TB is the interface common to T, B, and F.\n\n"}, {"path": "stdlib/internal-coverage-pods.md", "category": "stdlib", "name": "stdlib/internal-coverage-pods", "content": "package pods // import \"internal/coverage/pods\"\n\n\nTYPES\n\ntype Pod struct {\n\tMetaFile         string\n\tCounterDataFiles []string\n\tOrigins          []int\n\tProcessIDs       []int\n}\n    Pod encapsulates a set of files emitted during the executions of a\n    coverage-instrumented binary. Each pod contains a single meta-data file,\n    and then 0 or more counter data files that refer to that meta-data file.\n    Pods are intended to simplify processing of coverage output files in the\n    case where we have several coverage output directories containing output\n    files derived from more than one instrumented executable. In the case where\n    the files that make up a pod are spread out across multiple directories,\n    each element of the \"Origins\" field below will be populated with the index\n    of the originating directory for the corresponding counter data file (within\n    the slice of input dirs handed to CollectPods). The ProcessIDs field will\n    be populated with the process ID of each data file in the CounterDataFiles\n    slice.\n\nfunc CollectPods(dirs []string, warn bool) ([]Pod, error)\n    CollectPods visits the files contained within the directories in the list\n    'dirs', collects any coverage-related files, partitions them into pods, and\n    returns a list of the pods to the caller, along with an error if something\n    went wrong during directory/file reading.\n\n    CollectPods skips over any file that is not related to coverage (e.g. avoids\n    looking at things that are not meta-data files or counter-data files).\n    CollectPods also skips over 'orphaned' counter data files (e.g. counter\n    data files for which we can't find the corresponding meta-data file). If\n    \"warn\" is true, CollectPods will issue warnings to stderr when it encounters\n    non-fatal problems (for orphans or a directory with no meta-data files).\n\nfunc CollectPodsFromFiles(files []string, warn bool) []Pod\n    CollectPodsFromFiles functions the same as \"CollectPods\" but operates on an\n    explicit list of files instead of a directory.\n\n"}, {"path": "stdlib/crypto-internal-boring-bbig.md", "category": "stdlib", "name": "stdlib/crypto-internal-boring-bbig", "content": "package bbig // import \"crypto/internal/boring/bbig\"\n\n\nFUNCTIONS\n\nfunc Dec(b boring.BigInt) *big.Int\nfunc Enc(b *big.Int) boring.BigInt\n"}, {"path": "stdlib/image-color-palette.md", "category": "stdlib", "name": "stdlib/image-color-palette", "content": "package palette // import \"image/color/palette\"\n\nPackage palette provides standard color palettes.\n\nVARIABLES\n\nvar Plan9 = []color.Color{\n\tcolor.RGBA{0x00, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0x44, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0x88, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0xcc, 0xff},\n\tcolor.RGBA{0x00, 0x44, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0x44, 0x44, 0xff},\n\tcolor.RGBA{0x00, 0x44, 0x88, 0xff},\n\tcolor.RGBA{0x00, 0x44, 0xcc, 0xff},\n\tcolor.RGBA{0x00, 0x88, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0x88, 0x44, 0xff},\n\tcolor.RGBA{0x00, 0x88, 0x88, 0xff},\n\tcolor.RGBA{0x00, 0x88, 0xcc, 0xff},\n\tcolor.RGBA{0x00, 0xcc, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0xcc, 0x44, 0xff},\n\tcolor.RGBA{0x00, 0xcc, 0x88, 0xff},\n\tcolor.RGBA{0x00, 0xcc, 0xcc, 0xff},\n\tcolor.RGBA{0x00, 0xdd, 0xdd, 0xff},\n\tcolor.RGBA{0x11, 0x11, 0x11, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0x55, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0x99, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0xdd, 0xff},\n\tcolor.RGBA{0x00, 0x55, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0x55, 0x55, 0xff},\n\tcolor.RGBA{0x00, 0x4c, 0x99, 0xff},\n\tcolor.RGBA{0x00, 0x49, 0xdd, 0xff},\n\tcolor.RGBA{0x00, 0x99, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0x99, 0x4c, 0xff},\n\tcolor.RGBA{0x00, 0x99, 0x99, 0xff},\n\tcolor.RGBA{0x00, 0x93, 0xdd, 0xff},\n\tcolor.RGBA{0x00, 0xdd, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0xdd, 0x49, 0xff},\n\tcolor.RGBA{0x00, 0xdd, 0x93, 0xff},\n\tcolor.RGBA{0x00, 0xee, 0x9e, 0xff},\n\tcolor.RGBA{0x00, 0xee, 0xee, 0xff},\n\tcolor.RGBA{0x22, 0x22, 0x22, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0x66, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0xaa, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0xee, 0xff},\n\tcolor.RGBA{0x00, 0x66, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0x66, 0x66, 0xff},\n\tcolor.RGBA{0x00, 0x55, 0xaa, 0xff},\n\tcolor.RGBA{0x00, 0x4f, 0xee, 0xff},\n\tcolor.RGBA{0x00, 0xaa, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0xaa, 0x55, 0xff},\n\tcolor.RGBA{0x00, 0xaa, 0xaa, 0xff},\n\tcolor.RGBA{0x00, 0x9e, 0xee, 0xff},\n\tcolor.RGBA{0x00, 0xee, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0xee, 0x4f, 0xff},\n\tcolor.RGBA{0x00, 0xff, 0x55, 0xff},\n\tcolor.RGBA{0x00, 0xff, 0xaa, 0xff},\n\tcolor.RGBA{0x00, 0xff, 0xff, 0xff},\n\tcolor.RGBA{0x33, 0x33, 0x33, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0x77, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0xbb, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0xff, 0xff},\n\tcolor.RGBA{0x00, 0x77, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0x77, 0x77, 0xff},\n\tcolor.RGBA{0x00, 0x5d, 0xbb, 0xff},\n\tcolor.RGBA{0x00, 0x55, 0xff, 0xff},\n\tcolor.RGBA{0x00, 0xbb, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0xbb, 0x5d, 0xff},\n\tcolor.RGBA{0x00, 0xbb, 0xbb, 0xff},\n\tcolor.RGBA{0x00, 0xaa, 0xff, 0xff},\n\tcolor.RGBA{0x00, 0xff, 0x00, 0xff},\n\tcolor.RGBA{0x44, 0x00, 0x44, 0xff},\n\tcolor.RGBA{0x44, 0x00, 0x88, 0xff},\n\tcolor.RGBA{0x44, 0x00, 0xcc, 0xff},\n\tcolor.RGBA{0x44, 0x44, 0x00, 0xff},\n\tcolor.RGBA{0x44, 0x44, 0x44, 0xff},\n\tcolor.RGBA{0x44, 0x44, 0x88, 0xff},\n\tcolor.RGBA{0x44, 0x44, 0xcc, 0xff},\n\tcolor.RGBA{0x44, 0x88, 0x00, 0xff},\n\tcolor.RGBA{0x44, 0x88, 0x44, 0xff},\n\tcolor.RGBA{0x44, 0x88, 0x88, 0xff},\n\tcolor.RGBA{0x44, 0x88, 0xcc, 0xff},\n\tcolor.RGBA{0x44, 0xcc, 0x00, 0xff},\n\tcolor.RGBA{0x44, 0xcc, 0x44, 0xff},\n\tcolor.RGBA{0x44, 0xcc, 0x88, 0xff},\n\tcolor.RGBA{0x44, 0xcc, 0xcc, 0xff},\n\tcolor.RGBA{0x44, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0x55, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0x55, 0x00, 0x55, 0xff},\n\tcolor.RGBA{0x4c, 0x00, 0x99, 0xff},\n\tcolor.RGBA{0x49, 0x00, 0xdd, 0xff},\n\tcolor.RGBA{0x55, 0x55, 0x00, 0xff},\n\tcolor.RGBA{0x55, 0x55, 0x55, 0xff},\n\tcolor.RGBA{0x4c, 0x4c, 0x99, 0xff},\n\tcolor.RGBA{0x49, 0x49, 0xdd, 0xff},\n\tcolor.RGBA{0x4c, 0x99, 0x00, 0xff},\n\tcolor.RGBA{0x4c, 0x99, 0x4c, 0xff},\n\tcolor.RGBA{0x4c, 0x99, 0x99, 0xff},\n\tcolor.RGBA{0x49, 0x93, 0xdd, 0xff},\n\tcolor.RGBA{0x49, 0xdd, 0x00, 0xff},\n\tcolor.RGBA{0x49, 0xdd, 0x49, 0xff},\n\tcolor.RGBA{0x49, 0xdd, 0x93, 0xff},\n\tcolor.RGBA{0x49, 0xdd, 0xdd, 0xff},\n\tcolor.RGBA{0x4f, 0xee, 0xee, 0xff},\n\tcolor.RGBA{0x66, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0x66, 0x00, 0x66, 0xff},\n\tcolor.RGBA{0x55, 0x00, 0xaa, 0xff},\n\tcolor.RGBA{0x4f, 0x00, 0xee, 0xff},\n\tcolor.RGBA{0x66, 0x66, 0x00, 0xff},\n\tcolor.RGBA{0x66, 0x66, 0x66, 0xff},\n\tcolor.RGBA{0x55, 0x55, 0xaa, 0xff},\n\tcolor.RGBA{0x4f, 0x4f, 0xee, 0xff},\n\tcolor.RGBA{0x55, 0xaa, 0x00, 0xff},\n\tcolor.RGBA{0x55, 0xaa, 0x55, 0xff},\n\tcolor.RGBA{0x55, 0xaa, 0xaa, 0xff},\n\tcolor.RGBA{0x4f, 0x9e, 0xee, 0xff},\n\tcolor.RGBA{0x4f, 0xee, 0x00, 0xff},\n\tcolor.RGBA{0x4f, 0xee, 0x4f, 0xff},\n\tcolor.RGBA{0x4f, 0xee, 0x9e, 0xff},\n\tcolor.RGBA{0x55, 0xff, 0xaa, 0xff},\n\tcolor.RGBA{0x55, 0xff, 0xff, 0xff},\n\tcolor.RGBA{0x77, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0x77, 0x00, 0x77, 0xff},\n\tcolor.RGBA{0x5d, 0x00, 0xbb, 0xff},\n\tcolor.RGBA{0x55, 0x00, 0xff, 0xff},\n\tcolor.RGBA{0x77, 0x77, 0x00, 0xff},\n\tcolor.RGBA{0x77, 0x77, 0x77, 0xff},\n\tcolor.RGBA{0x5d, 0x5d, 0xbb, 0xff},\n\tcolor.RGBA{0x55, 0x55, 0xff, 0xff},\n\tcolor.RGBA{0x5d, 0xbb, 0x00, 0xff},\n\tcolor.RGBA{0x5d, 0xbb, 0x5d, 0xff},\n\tcolor.RGBA{0x5d, 0xbb, 0xbb, 0xff},\n\tcolor.RGBA{0x55, 0xaa, 0xff, 0xff},\n\tcolor.RGBA{0x55, 0xff, 0x00, 0xff},\n\tcolor.RGBA{0x55, 0xff, 0x55, 0xff},\n\tcolor.RGBA{0x88, 0x00, 0x88, 0xff},\n\tcolor.RGBA{0x88, 0x00, 0xcc, 0xff},\n\tcolor.RGBA{0x88, 0x44, 0x00, 0xff},\n\tcolor.RGBA{0x88, 0x44, 0x44, 0xff},\n\tcolor.RGBA{0x88, 0x44, 0x88, 0xff},\n\tcolor.RGBA{0x88, 0x44, 0xcc, 0xff},\n\tcolor.RGBA{0x88, 0x88, 0x00, 0xff},\n\tcolor.RGBA{0x88, 0x88, 0x44, 0xff},\n\tcolor.RGBA{0x88, 0x88, 0x88, 0xff},\n\tcolor.RGBA{0x88, 0x88, 0xcc, 0xff},\n\tcolor.RGBA{0x88, 0xcc, 0x00, 0xff},\n\tcolor.RGBA{0x88, 0xcc, 0x44, 0xff},\n\tcolor.RGBA{0x88, 0xcc, 0x88, 0xff},\n\tcolor.RGBA{0x88, 0xcc, 0xcc, 0xff},\n\tcolor.RGBA{0x88, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0x88, 0x00, 0x44, 0xff},\n\tcolor.RGBA{0x99, 0x00, 0x4c, 0xff},\n\tcolor.RGBA{0x99, 0x00, 0x99, 0xff},\n\tcolor.RGBA{0x93, 0x00, 0xdd, 0xff},\n\tcolor.RGBA{0x99, 0x4c, 0x00, 0xff},\n\tcolor.RGBA{0x99, 0x4c, 0x4c, 0xff},\n\tcolor.RGBA{0x99, 0x4c, 0x99, 0xff},\n\tcolor.RGBA{0x93, 0x49, 0xdd, 0xff},\n\tcolor.RGBA{0x99, 0x99, 0x00, 0xff},\n\tcolor.RGBA{0x99, 0x99, 0x4c, 0xff},\n\tcolor.RGBA{0x99, 0x99, 0x99, 0xff},\n\tcolor.RGBA{0x93, 0x93, 0xdd, 0xff},\n\tcolor.RGBA{0x93, 0xdd, 0x00, 0xff},\n\tcolor.RGBA{0x93, 0xdd, 0x49, 0xff},\n\tcolor.RGBA{0x93, 0xdd, 0x93, 0xff},\n\tcolor.RGBA{0x93, 0xdd, 0xdd, 0xff},\n\tcolor.RGBA{0x99, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0xaa, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0xaa, 0x00, 0x55, 0xff},\n\tcolor.RGBA{0xaa, 0x00, 0xaa, 0xff},\n\tcolor.RGBA{0x9e, 0x00, 0xee, 0xff},\n\tcolor.RGBA{0xaa, 0x55, 0x00, 0xff},\n\tcolor.RGBA{0xaa, 0x55, 0x55, 0xff},\n\tcolor.RGBA{0xaa, 0x55, 0xaa, 0xff},\n\tcolor.RGBA{0x9e, 0x4f, 0xee, 0xff},\n\tcolor.RGBA{0xaa, 0xaa, 0x00, 0xff},\n\tcolor.RGBA{0xaa, 0xaa, 0x55, 0xff},\n\tcolor.RGBA{0xaa, 0xaa, 0xaa, 0xff},\n\tcolor.RGBA{0x9e, 0x9e, 0xee, 0xff},\n\tcolor.RGBA{0x9e, 0xee, 0x00, 0xff},\n\tcolor.RGBA{0x9e, 0xee, 0x4f, 0xff},\n\tcolor.RGBA{0x9e, 0xee, 0x9e, 0xff},\n\tcolor.RGBA{0x9e, 0xee, 0xee, 0xff},\n\tcolor.RGBA{0xaa, 0xff, 0xff, 0xff},\n\tcolor.RGBA{0xbb, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0xbb, 0x00, 0x5d, 0xff},\n\tcolor.RGBA{0xbb, 0x00, 0xbb, 0xff},\n\tcolor.RGBA{0xaa, 0x00, 0xff, 0xff},\n\tcolor.RGBA{0xbb, 0x5d, 0x00, 0xff},\n\tcolor.RGBA{0xbb, 0x5d, 0x5d, 0xff},\n\tcolor.RGBA{0xbb, 0x5d, 0xbb, 0xff},\n\tcolor.RGBA{0xaa, 0x55, 0xff, 0xff},\n\tcolor.RGBA{0xbb, 0xbb, 0x00, 0xff},\n\tcolor.RGBA{0xbb, 0xbb, 0x5d, 0xff},\n\tcolor.RGBA{0xbb, 0xbb, 0xbb, 0xff},\n\tcolor.RGBA{0xaa, 0xaa, 0xff, 0xff},\n\tcolor.RGBA{0xaa, 0xff, 0x00, 0xff},\n\tcolor.RGBA{0xaa, 0xff, 0x55, 0xff},\n\tcolor.RGBA{0xaa, 0xff, 0xaa, 0xff},\n\tcolor.RGBA{0xcc, 0x00, 0xcc, 0xff},\n\tcolor.RGBA{0xcc, 0x44, 0x00, 0xff},\n\tcolor.RGBA{0xcc, 0x44, 0x44, 0xff},\n\tcolor.RGBA{0xcc, 0x44, 0x88, 0xff},\n\tcolor.RGBA{0xcc, 0x44, 0xcc, 0xff},\n\tcolor.RGBA{0xcc, 0x88, 0x00, 0xff},\n\tcolor.RGBA{0xcc, 0x88, 0x44, 0xff},\n\tcolor.RGBA{0xcc, 0x88, 0x88, 0xff},\n\tcolor.RGBA{0xcc, 0x88, 0xcc, 0xff},\n\tcolor.RGBA{0xcc, 0xcc, 0x00, 0xff},\n\tcolor.RGBA{0xcc, 0xcc, 0x44, 0xff},\n\tcolor.RGBA{0xcc, 0xcc, 0x88, 0xff},\n\tcolor.RGBA{0xcc, 0xcc, 0xcc, 0xff},\n\tcolor.RGBA{0xcc, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0xcc, 0x00, 0x44, 0xff},\n\tcolor.RGBA{0xcc, 0x00, 0x88, 0xff},\n\tcolor.RGBA{0xdd, 0x00, 0x93, 0xff},\n\tcolor.RGBA{0xdd, 0x00, 0xdd, 0xff},\n\tcolor.RGBA{0xdd, 0x49, 0x00, 0xff},\n\tcolor.RGBA{0xdd, 0x49, 0x49, 0xff},\n\tcolor.RGBA{0xdd, 0x49, 0x93, 0xff},\n\tcolor.RGBA{0xdd, 0x49, 0xdd, 0xff},\n\tcolor.RGBA{0xdd, 0x93, 0x00, 0xff},\n\tcolor.RGBA{0xdd, 0x93, 0x49, 0xff},\n\tcolor.RGBA{0xdd, 0x93, 0x93, 0xff},\n\tcolor.RGBA{0xdd, 0x93, 0xdd, 0xff},\n\tcolor.RGBA{0xdd, 0xdd, 0x00, 0xff},\n\tcolor.RGBA{0xdd, 0xdd, 0x49, 0xff},\n\tcolor.RGBA{0xdd, 0xdd, 0x93, 0xff},\n\tcolor.RGBA{0xdd, 0xdd, 0xdd, 0xff},\n\tcolor.RGBA{0xdd, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0xdd, 0x00, 0x49, 0xff},\n\tcolor.RGBA{0xee, 0x00, 0x4f, 0xff},\n\tcolor.RGBA{0xee, 0x00, 0x9e, 0xff},\n\tcolor.RGBA{0xee, 0x00, 0xee, 0xff},\n\tcolor.RGBA{0xee, 0x4f, 0x00, 0xff},\n\tcolor.RGBA{0xee, 0x4f, 0x4f, 0xff},\n\tcolor.RGBA{0xee, 0x4f, 0x9e, 0xff},\n\tcolor.RGBA{0xee, 0x4f, 0xee, 0xff},\n\tcolor.RGBA{0xee, 0x9e, 0x00, 0xff},\n\tcolor.RGBA{0xee, 0x9e, 0x4f, 0xff},\n\tcolor.RGBA{0xee, 0x9e, 0x9e, 0xff},\n\tcolor.RGBA{0xee, 0x9e, 0xee, 0xff},\n\tcolor.RGBA{0xee, 0xee, 0x00, 0xff},\n\tcolor.RGBA{0xee, 0xee, 0x4f, 0xff},\n\tcolor.RGBA{0xee, 0xee, 0x9e, 0xff},\n\tcolor.RGBA{0xee, 0xee, 0xee, 0xff},\n\tcolor.RGBA{0xee, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0xff, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0xff, 0x00, 0x55, 0xff},\n\tcolor.RGBA{0xff, 0x00, 0xaa, 0xff},\n\tcolor.RGBA{0xff, 0x00, 0xff, 0xff},\n\tcolor.RGBA{0xff, 0x55, 0x00, 0xff},\n\tcolor.RGBA{0xff, 0x55, 0x55, 0xff},\n\tcolor.RGBA{0xff, 0x55, 0xaa, 0xff},\n\tcolor.RGBA{0xff, 0x55, 0xff, 0xff},\n\tcolor.RGBA{0xff, 0xaa, 0x00, 0xff},\n\tcolor.RGBA{0xff, 0xaa, 0x55, 0xff},\n\tcolor.RGBA{0xff, 0xaa, 0xaa, 0xff},\n\tcolor.RGBA{0xff, 0xaa, 0xff, 0xff},\n\tcolor.RGBA{0xff, 0xff, 0x00, 0xff},\n\tcolor.RGBA{0xff, 0xff, 0x55, 0xff},\n\tcolor.RGBA{0xff, 0xff, 0xaa, 0xff},\n\tcolor.RGBA{0xff, 0xff, 0xff, 0xff},\n}\n    Plan9 is a 256-color palette that partitions the 24-bit RGB space into 4\u00d74\u00d74\n    subdivision, with 4 shades in each subcube. Compared to the WebSafe, the\n    idea is to reduce the color resolution by dicing the color cube into fewer\n    cells, and to use the extra space to increase the intensity resolution.\n    This results in 16 gray shades (4 gray subcubes with 4 samples in each),\n    13 shades of each primary and secondary color (3 subcubes with 4 samples\n    plus black) and a reasonable selection of colors covering the rest of the\n    color cube. The advantage is better representation of continuous tones.\n\n    This palette was used in the Plan 9 Operating System, described at\n    https://9p.io/magic/man2html/6/color\n\nvar WebSafe = []color.Color{\n\tcolor.RGBA{0x00, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0x33, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0x66, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0x99, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0xcc, 0xff},\n\tcolor.RGBA{0x00, 0x00, 0xff, 0xff},\n\tcolor.RGBA{0x00, 0x33, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0x33, 0x33, 0xff},\n\tcolor.RGBA{0x00, 0x33, 0x66, 0xff},\n\tcolor.RGBA{0x00, 0x33, 0x99, 0xff},\n\tcolor.RGBA{0x00, 0x33, 0xcc, 0xff},\n\tcolor.RGBA{0x00, 0x33, 0xff, 0xff},\n\tcolor.RGBA{0x00, 0x66, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0x66, 0x33, 0xff},\n\tcolor.RGBA{0x00, 0x66, 0x66, 0xff},\n\tcolor.RGBA{0x00, 0x66, 0x99, 0xff},\n\tcolor.RGBA{0x00, 0x66, 0xcc, 0xff},\n\tcolor.RGBA{0x00, 0x66, 0xff, 0xff},\n\tcolor.RGBA{0x00, 0x99, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0x99, 0x33, 0xff},\n\tcolor.RGBA{0x00, 0x99, 0x66, 0xff},\n\tcolor.RGBA{0x00, 0x99, 0x99, 0xff},\n\tcolor.RGBA{0x00, 0x99, 0xcc, 0xff},\n\tcolor.RGBA{0x00, 0x99, 0xff, 0xff},\n\tcolor.RGBA{0x00, 0xcc, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0xcc, 0x33, 0xff},\n\tcolor.RGBA{0x00, 0xcc, 0x66, 0xff},\n\tcolor.RGBA{0x00, 0xcc, 0x99, 0xff},\n\tcolor.RGBA{0x00, 0xcc, 0xcc, 0xff},\n\tcolor.RGBA{0x00, 0xcc, 0xff, 0xff},\n\tcolor.RGBA{0x00, 0xff, 0x00, 0xff},\n\tcolor.RGBA{0x00, 0xff, 0x33, 0xff},\n\tcolor.RGBA{0x00, 0xff, 0x66, 0xff},\n\tcolor.RGBA{0x00, 0xff, 0x99, 0xff},\n\tcolor.RGBA{0x00, 0xff, 0xcc, 0xff},\n\tcolor.RGBA{0x00, 0xff, 0xff, 0xff},\n\tcolor.RGBA{0x33, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0x33, 0x00, 0x33, 0xff},\n\tcolor.RGBA{0x33, 0x00, 0x66, 0xff},\n\tcolor.RGBA{0x33, 0x00, 0x99, 0xff},\n\tcolor.RGBA{0x33, 0x00, 0xcc, 0xff},\n\tcolor.RGBA{0x33, 0x00, 0xff, 0xff},\n\tcolor.RGBA{0x33, 0x33, 0x00, 0xff},\n\tcolor.RGBA{0x33, 0x33, 0x33, 0xff},\n\tcolor.RGBA{0x33, 0x33, 0x66, 0xff},\n\tcolor.RGBA{0x33, 0x33, 0x99, 0xff},\n\tcolor.RGBA{0x33, 0x33, 0xcc, 0xff},\n\tcolor.RGBA{0x33, 0x33, 0xff, 0xff},\n\tcolor.RGBA{0x33, 0x66, 0x00, 0xff},\n\tcolor.RGBA{0x33, 0x66, 0x33, 0xff},\n\tcolor.RGBA{0x33, 0x66, 0x66, 0xff},\n\tcolor.RGBA{0x33, 0x66, 0x99, 0xff},\n\tcolor.RGBA{0x33, 0x66, 0xcc, 0xff},\n\tcolor.RGBA{0x33, 0x66, 0xff, 0xff},\n\tcolor.RGBA{0x33, 0x99, 0x00, 0xff},\n\tcolor.RGBA{0x33, 0x99, 0x33, 0xff},\n\tcolor.RGBA{0x33, 0x99, 0x66, 0xff},\n\tcolor.RGBA{0x33, 0x99, 0x99, 0xff},\n\tcolor.RGBA{0x33, 0x99, 0xcc, 0xff},\n\tcolor.RGBA{0x33, 0x99, 0xff, 0xff},\n\tcolor.RGBA{0x33, 0xcc, 0x00, 0xff},\n\tcolor.RGBA{0x33, 0xcc, 0x33, 0xff},\n\tcolor.RGBA{0x33, 0xcc, 0x66, 0xff},\n\tcolor.RGBA{0x33, 0xcc, 0x99, 0xff},\n\tcolor.RGBA{0x33, 0xcc, 0xcc, 0xff},\n\tcolor.RGBA{0x33, 0xcc, 0xff, 0xff},\n\tcolor.RGBA{0x33, 0xff, 0x00, 0xff},\n\tcolor.RGBA{0x33, 0xff, 0x33, 0xff},\n\tcolor.RGBA{0x33, 0xff, 0x66, 0xff},\n\tcolor.RGBA{0x33, 0xff, 0x99, 0xff},\n\tcolor.RGBA{0x33, 0xff, 0xcc, 0xff},\n\tcolor.RGBA{0x33, 0xff, 0xff, 0xff},\n\tcolor.RGBA{0x66, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0x66, 0x00, 0x33, 0xff},\n\tcolor.RGBA{0x66, 0x00, 0x66, 0xff},\n\tcolor.RGBA{0x66, 0x00, 0x99, 0xff},\n\tcolor.RGBA{0x66, 0x00, 0xcc, 0xff},\n\tcolor.RGBA{0x66, 0x00, 0xff, 0xff},\n\tcolor.RGBA{0x66, 0x33, 0x00, 0xff},\n\tcolor.RGBA{0x66, 0x33, 0x33, 0xff},\n\tcolor.RGBA{0x66, 0x33, 0x66, 0xff},\n\tcolor.RGBA{0x66, 0x33, 0x99, 0xff},\n\tcolor.RGBA{0x66, 0x33, 0xcc, 0xff},\n\tcolor.RGBA{0x66, 0x33, 0xff, 0xff},\n\tcolor.RGBA{0x66, 0x66, 0x00, 0xff},\n\tcolor.RGBA{0x66, 0x66, 0x33, 0xff},\n\tcolor.RGBA{0x66, 0x66, 0x66, 0xff},\n\tcolor.RGBA{0x66, 0x66, 0x99, 0xff},\n\tcolor.RGBA{0x66, 0x66, 0xcc, 0xff},\n\tcolor.RGBA{0x66, 0x66, 0xff, 0xff},\n\tcolor.RGBA{0x66, 0x99, 0x00, 0xff},\n\tcolor.RGBA{0x66, 0x99, 0x33, 0xff},\n\tcolor.RGBA{0x66, 0x99, 0x66, 0xff},\n\tcolor.RGBA{0x66, 0x99, 0x99, 0xff},\n\tcolor.RGBA{0x66, 0x99, 0xcc, 0xff},\n\tcolor.RGBA{0x66, 0x99, 0xff, 0xff},\n\tcolor.RGBA{0x66, 0xcc, 0x00, 0xff},\n\tcolor.RGBA{0x66, 0xcc, 0x33, 0xff},\n\tcolor.RGBA{0x66, 0xcc, 0x66, 0xff},\n\tcolor.RGBA{0x66, 0xcc, 0x99, 0xff},\n\tcolor.RGBA{0x66, 0xcc, 0xcc, 0xff},\n\tcolor.RGBA{0x66, 0xcc, 0xff, 0xff},\n\tcolor.RGBA{0x66, 0xff, 0x00, 0xff},\n\tcolor.RGBA{0x66, 0xff, 0x33, 0xff},\n\tcolor.RGBA{0x66, 0xff, 0x66, 0xff},\n\tcolor.RGBA{0x66, 0xff, 0x99, 0xff},\n\tcolor.RGBA{0x66, 0xff, 0xcc, 0xff},\n\tcolor.RGBA{0x66, 0xff, 0xff, 0xff},\n\tcolor.RGBA{0x99, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0x99, 0x00, 0x33, 0xff},\n\tcolor.RGBA{0x99, 0x00, 0x66, 0xff},\n\tcolor.RGBA{0x99, 0x00, 0x99, 0xff},\n\tcolor.RGBA{0x99, 0x00, 0xcc, 0xff},\n\tcolor.RGBA{0x99, 0x00, 0xff, 0xff},\n\tcolor.RGBA{0x99, 0x33, 0x00, 0xff},\n\tcolor.RGBA{0x99, 0x33, 0x33, 0xff},\n\tcolor.RGBA{0x99, 0x33, 0x66, 0xff},\n\tcolor.RGBA{0x99, 0x33, 0x99, 0xff},\n\tcolor.RGBA{0x99, 0x33, 0xcc, 0xff},\n\tcolor.RGBA{0x99, 0x33, 0xff, 0xff},\n\tcolor.RGBA{0x99, 0x66, 0x00, 0xff},\n\tcolor.RGBA{0x99, 0x66, 0x33, 0xff},\n\tcolor.RGBA{0x99, 0x66, 0x66, 0xff},\n\tcolor.RGBA{0x99, 0x66, 0x99, 0xff},\n\tcolor.RGBA{0x99, 0x66, 0xcc, 0xff},\n\tcolor.RGBA{0x99, 0x66, 0xff, 0xff},\n\tcolor.RGBA{0x99, 0x99, 0x00, 0xff},\n\tcolor.RGBA{0x99, 0x99, 0x33, 0xff},\n\tcolor.RGBA{0x99, 0x99, 0x66, 0xff},\n\tcolor.RGBA{0x99, 0x99, 0x99, 0xff},\n\tcolor.RGBA{0x99, 0x99, 0xcc, 0xff},\n\tcolor.RGBA{0x99, 0x99, 0xff, 0xff},\n\tcolor.RGBA{0x99, 0xcc, 0x00, 0xff},\n\tcolor.RGBA{0x99, 0xcc, 0x33, 0xff},\n\tcolor.RGBA{0x99, 0xcc, 0x66, 0xff},\n\tcolor.RGBA{0x99, 0xcc, 0x99, 0xff},\n\tcolor.RGBA{0x99, 0xcc, 0xcc, 0xff},\n\tcolor.RGBA{0x99, 0xcc, 0xff, 0xff},\n\tcolor.RGBA{0x99, 0xff, 0x00, 0xff},\n\tcolor.RGBA{0x99, 0xff, 0x33, 0xff},\n\tcolor.RGBA{0x99, 0xff, 0x66, 0xff},\n\tcolor.RGBA{0x99, 0xff, 0x99, 0xff},\n\tcolor.RGBA{0x99, 0xff, 0xcc, 0xff},\n\tcolor.RGBA{0x99, 0xff, 0xff, 0xff},\n\tcolor.RGBA{0xcc, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0xcc, 0x00, 0x33, 0xff},\n\tcolor.RGBA{0xcc, 0x00, 0x66, 0xff},\n\tcolor.RGBA{0xcc, 0x00, 0x99, 0xff},\n\tcolor.RGBA{0xcc, 0x00, 0xcc, 0xff},\n\tcolor.RGBA{0xcc, 0x00, 0xff, 0xff},\n\tcolor.RGBA{0xcc, 0x33, 0x00, 0xff},\n\tcolor.RGBA{0xcc, 0x33, 0x33, 0xff},\n\tcolor.RGBA{0xcc, 0x33, 0x66, 0xff},\n\tcolor.RGBA{0xcc, 0x33, 0x99, 0xff},\n\tcolor.RGBA{0xcc, 0x33, 0xcc, 0xff},\n\tcolor.RGBA{0xcc, 0x33, 0xff, 0xff},\n\tcolor.RGBA{0xcc, 0x66, 0x00, 0xff},\n\tcolor.RGBA{0xcc, 0x66, 0x33, 0xff},\n\tcolor.RGBA{0xcc, 0x66, 0x66, 0xff},\n\tcolor.RGBA{0xcc, 0x66, 0x99, 0xff},\n\tcolor.RGBA{0xcc, 0x66, 0xcc, 0xff},\n\tcolor.RGBA{0xcc, 0x66, 0xff, 0xff},\n\tcolor.RGBA{0xcc, 0x99, 0x00, 0xff},\n\tcolor.RGBA{0xcc, 0x99, 0x33, 0xff},\n\tcolor.RGBA{0xcc, 0x99, 0x66, 0xff},\n\tcolor.RGBA{0xcc, 0x99, 0x99, 0xff},\n\tcolor.RGBA{0xcc, 0x99, 0xcc, 0xff},\n\tcolor.RGBA{0xcc, 0x99, 0xff, 0xff},\n\tcolor.RGBA{0xcc, 0xcc, 0x00, 0xff},\n\tcolor.RGBA{0xcc, 0xcc, 0x33, 0xff},\n\tcolor.RGBA{0xcc, 0xcc, 0x66, 0xff},\n\tcolor.RGBA{0xcc, 0xcc, 0x99, 0xff},\n\tcolor.RGBA{0xcc, 0xcc, 0xcc, 0xff},\n\tcolor.RGBA{0xcc, 0xcc, 0xff, 0xff},\n\tcolor.RGBA{0xcc, 0xff, 0x00, 0xff},\n\tcolor.RGBA{0xcc, 0xff, 0x33, 0xff},\n\tcolor.RGBA{0xcc, 0xff, 0x66, 0xff},\n\tcolor.RGBA{0xcc, 0xff, 0x99, 0xff},\n\tcolor.RGBA{0xcc, 0xff, 0xcc, 0xff},\n\tcolor.RGBA{0xcc, 0xff, 0xff, 0xff},\n\tcolor.RGBA{0xff, 0x00, 0x00, 0xff},\n\tcolor.RGBA{0xff, 0x00, 0x33, 0xff},\n\tcolor.RGBA{0xff, 0x00, 0x66, 0xff},\n\tcolor.RGBA{0xff, 0x00, 0x99, 0xff},\n\tcolor.RGBA{0xff, 0x00, 0xcc, 0xff},\n\tcolor.RGBA{0xff, 0x00, 0xff, 0xff},\n\tcolor.RGBA{0xff, 0x33, 0x00, 0xff},\n\tcolor.RGBA{0xff, 0x33, 0x33, 0xff},\n\tcolor.RGBA{0xff, 0x33, 0x66, 0xff},\n\tcolor.RGBA{0xff, 0x33, 0x99, 0xff},\n\tcolor.RGBA{0xff, 0x33, 0xcc, 0xff},\n\tcolor.RGBA{0xff, 0x33, 0xff, 0xff},\n\tcolor.RGBA{0xff, 0x66, 0x00, 0xff},\n\tcolor.RGBA{0xff, 0x66, 0x33, 0xff},\n\tcolor.RGBA{0xff, 0x66, 0x66, 0xff},\n\tcolor.RGBA{0xff, 0x66, 0x99, 0xff},\n\tcolor.RGBA{0xff, 0x66, 0xcc, 0xff},\n\tcolor.RGBA{0xff, 0x66, 0xff, 0xff},\n\tcolor.RGBA{0xff, 0x99, 0x00, 0xff},\n\tcolor.RGBA{0xff, 0x99, 0x33, 0xff},\n\tcolor.RGBA{0xff, 0x99, 0x66, 0xff},\n\tcolor.RGBA{0xff, 0x99, 0x99, 0xff},\n\tcolor.RGBA{0xff, 0x99, 0xcc, 0xff},\n\tcolor.RGBA{0xff, 0x99, 0xff, 0xff},\n\tcolor.RGBA{0xff, 0xcc, 0x00, 0xff},\n\tcolor.RGBA{0xff, 0xcc, 0x33, 0xff},\n\tcolor.RGBA{0xff, 0xcc, 0x66, 0xff},\n\tcolor.RGBA{0xff, 0xcc, 0x99, 0xff},\n\tcolor.RGBA{0xff, 0xcc, 0xcc, 0xff},\n\tcolor.RGBA{0xff, 0xcc, 0xff, 0xff},\n\tcolor.RGBA{0xff, 0xff, 0x00, 0xff},\n\tcolor.RGBA{0xff, 0xff, 0x33, 0xff},\n\tcolor.RGBA{0xff, 0xff, 0x66, 0xff},\n\tcolor.RGBA{0xff, 0xff, 0x99, 0xff},\n\tcolor.RGBA{0xff, 0xff, 0xcc, 0xff},\n\tcolor.RGBA{0xff, 0xff, 0xff, 0xff},\n}\n    WebSafe is a 216-color palette that was popularized by early versions of\n    Netscape Navigator. It is also known as the Netscape Color Cube.\n\n    See https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors for details.\n\n"}, {"path": "stdlib/internal-sysinfo.md", "category": "stdlib", "name": "stdlib/internal-sysinfo", "content": "package sysinfo // import \"internal/sysinfo\"\n\nPackage sysinfo implements high level hardware information gathering that can be\nused for debugging or information purposes.\n\nVARIABLES\n\nvar CPUName = sync.OnceValue(func() string {\n\tif name := cpu.Name(); name != \"\" {\n\t\treturn name\n\t}\n\n\tif name := osCPUInfoName(); name != \"\" {\n\t\treturn name\n\t}\n\n\treturn \"\"\n})\n"}, {"path": "stdlib/crypto-internal-impl.md", "category": "stdlib", "name": "stdlib/crypto-internal-impl", "content": "package impl // import \"crypto/internal/impl\"\n\nPackage impl is a registry of alternative implementations of cryptographic\nprimitives, to allow selecting them for testing.\n\nFUNCTIONS\n\nfunc List(pkg string) []string\n    List returns the names of all alternative implementations registered for the\n    given package, whether available or not. The implicit base implementation is\n    not included.\n\nfunc Packages() []string\n    Packages returns the list of all packages for which alternative\n    implementations are registered.\n\nfunc Register(pkg, name string, available *bool)\n    Register records an alternative implementation of a cryptographic primitive.\n    The implementation might be available or not based on CPU support.\n    If available is false, the implementation is unavailable and can't be tested\n    on this machine. If available is true, it can be set to false to disable the\n    implementation. If all alternative implementations but one are disabled,\n    the remaining one must be used (i.e. disabling one implementation must\n    not implicitly disable any other). Each package has an implicit base\n    implementation that is selected when all alternatives are unavailable\n    or disabled. pkg must be the package name, not path (e.g. \"aes\" not\n    \"crypto/aes\").\n\nfunc Reset(pkg string)\nfunc Select(pkg, name string) bool\n    Select disables all implementations for the given package except the one\n    with the given name. If name is empty, the base implementation is selected.\n    It returns whether the selected implementation is available.\n\n"}, {"path": "stdlib/crypto-internal-sysrand.md", "category": "stdlib", "name": "stdlib/crypto-internal-sysrand", "content": "package sysrand // import \"crypto/internal/sysrand\"\n\nPackage rand provides cryptographically secure random bytes from the operating\nsystem.\n\nFUNCTIONS\n\nfunc Read(b []byte)\n    Read fills b with cryptographically secure random bytes from the operating\n    system. It always fills b entirely and crashes the program irrecoverably if\n    an error is encountered. The operating system APIs are documented to never\n    return an error on all but legacy Linux systems.\n\n"}, {"path": "stdlib/crypto-internal-fips140-ed25519.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-ed25519", "content": "package ed25519 // import \"crypto/internal/fips140/ed25519\"\n\n\nFUNCTIONS\n\nfunc Sign(priv *PrivateKey, message []byte) []byte\nfunc SignCtx(priv *PrivateKey, message []byte, context string) ([]byte, error)\nfunc SignPH(priv *PrivateKey, message []byte, context string) ([]byte, error)\nfunc Verify(pub *PublicKey, message, sig []byte) error\nfunc VerifyCtx(pub *PublicKey, message []byte, sig []byte, context string) error\nfunc VerifyPH(pub *PublicKey, message []byte, sig []byte, context string) error\n\nTYPES\n\ntype PrivateKey struct {\n\t// Has unexported fields.\n}\n\nfunc GenerateKey() (*PrivateKey, error)\n    GenerateKey generates a new Ed25519 private key pair.\n\nfunc NewPrivateKey(priv []byte) (*PrivateKey, error)\n\nfunc NewPrivateKeyFromSeed(seed []byte) (*PrivateKey, error)\n\nfunc (priv *PrivateKey) Bytes() []byte\n\nfunc (priv *PrivateKey) PublicKey() []byte\n\nfunc (priv *PrivateKey) Seed() []byte\n\ntype PublicKey struct {\n\t// Has unexported fields.\n}\n\nfunc NewPublicKey(pub []byte) (*PublicKey, error)\n\nfunc (pub *PublicKey) Bytes() []byte\n\n"}, {"path": "stdlib/internal-runtime-cgroup.md", "category": "stdlib", "name": "stdlib/internal-runtime-cgroup", "content": "package cgroup // import \"internal/runtime/cgroup\"\n\n"}, {"path": "stdlib/net-rpc.md", "category": "stdlib", "name": "stdlib/net-rpc", "content": "package rpc // import \"net/rpc\"\n\nPackage rpc provides access to the exported methods of an object across a\nnetwork or other I/O connection.\n\nThe net/rpc package is frozen and is not accepting new features.\n\nA server registers an object, making it visible as a service with the name of\nthe type of the object. After registration, exported methods of the object will\nbe accessible remotely. A server may register multiple objects (services) of\ndifferent types but it is an error to register multiple objects of the same\ntype.\n\nOnly methods that satisfy these criteria will be made available for remote\naccess; other methods will be ignored:\n\n  - the method's type is exported.\n  - the method is exported.\n  - the method has two arguments, both exported (or builtin) types.\n  - the method's second argument is a pointer.\n  - the method has return type error.\n\nIn effect, the method must look schematically like\n\n    func (t *T) MethodName(argType T1, replyType *T2) error\n\nwhere T1 and T2 can be marshaled by encoding/gob. These requirements apply even\nif a different codec is used. (In the future, these requirements may soften for\ncustom codecs.)\n\nThe method's first argument represents the arguments provided by the caller;\nthe second argument represents the result parameters to be returned to the\ncaller. The method's return value, if non-nil, is passed back as a string that\nthe client sees as if created by errors.New. If an error is returned, the reply\nparameter will not be sent back to the client.\n\nThe server may handle requests on a single connection by calling ServeConn.\nMore typically it will create a network listener and call Accept or, for an HTTP\nlistener, HandleHTTP and http.Serve.\n\nA client wishing to use the service establishes a connection and then invokes\nNewClient on the connection. The convenience function Dial (DialHTTP) performs\nboth steps for a raw network connection (an HTTP connection). The resulting\nClient object has two methods, Call and Go, that specify the service and method\nto call, a pointer containing the arguments, and a pointer to receive the result\nparameters.\n\nThe Call method waits for the remote call to complete while the Go method\nlaunches the call asynchronously and signals completion using the Call\nstructure's Done channel.\n\nUnless an explicit codec is set up, package encoding/gob is used to transport\nthe data.\n\nHere is a simple example. A server wishes to export an object of type Arith:\n\n    package server\n\n    import \"errors\"\n\n    type Args struct {\n    \tA, B int\n    }\n\n    type Quotient struct {\n    \tQuo, Rem int\n    }\n\n    type Arith int\n\n    func (t *Arith) Multiply(args *Args, reply *int) error {\n    \t*reply = args.A * args.B\n    \treturn nil\n    }\n\n    func (t *Arith) Divide(args *Args, quo *Quotient) error {\n    \tif args.B == 0 {\n    \t\treturn errors.New(\"divide by zero\")\n    \t}\n    \tquo.Quo = args.A / args.B\n    \tquo.Rem = args.A % args.B\n    \treturn nil\n    }\n\nThe server calls (for HTTP service):\n\n    arith := new(Arith)\n    rpc.Register(arith)\n    rpc.HandleHTTP()\n    l, err := net.Listen(\"tcp\", \":1234\")\n    if err != nil {\n    \tlog.Fatal(\"listen error:\", err)\n    }\n    go http.Serve(l, nil)\n\nAt this point, clients can see a service \"Arith\" with methods \"Arith.Multiply\"\nand \"Arith.Divide\". To invoke one, a client first dials the server:\n\n    client, err := rpc.DialHTTP(\"tcp\", serverAddress + \":1234\")\n    if err != nil {\n    \tlog.Fatal(\"dialing:\", err)\n    }\n\nThen it can make a remote call:\n\n    // Synchronous call\n    args := &server.Args{7,8}\n    var reply int\n    err = client.Call(\"Arith.Multiply\", args, &reply)\n    if err != nil {\n    \tlog.Fatal(\"arith error:\", err)\n    }\n    fmt.Printf(\"Arith: %d*%d=%d\", args.A, args.B, reply)\n\nor\n\n    // Asynchronous call\n    quotient := new(Quotient)\n    divCall := client.Go(\"Arith.Divide\", args, quotient, nil)\n    replyCall := <-divCall.Done\t// will be equal to divCall\n    // check errors, print, etc.\n\nA server implementation will often provide a simple, type-safe wrapper for the\nclient.\n\nCONSTANTS\n\nconst (\n\t// Defaults used by HandleHTTP\n\tDefaultRPCPath   = \"/_goRPC_\"\n\tDefaultDebugPath = \"/debug/rpc\"\n)\n\nVARIABLES\n\nvar DefaultServer = NewServer()\n    DefaultServer is the default instance of *Server.\n\nvar ErrShutdown = errors.New(\"connection is shut down\")\n\nFUNCTIONS\n\nfunc Accept(lis net.Listener)\n    Accept accepts connections on the listener and serves requests to\n    DefaultServer for each incoming connection. Accept blocks; the caller\n    typically invokes it in a go statement.\n\nfunc HandleHTTP()\n    HandleHTTP registers an HTTP handler for RPC messages to DefaultServer on\n    DefaultRPCPath and a debugging handler on DefaultDebugPath. It is still\n    necessary to invoke http.Serve(), typically in a go statement.\n\nfunc Register(rcvr any) error\n    Register publishes the receiver's methods in the DefaultServer.\n\nfunc RegisterName(name string, rcvr any) error\n    RegisterName is like Register but uses the provided name for the type\n    instead of the receiver's concrete type.\n\nfunc ServeCodec(codec ServerCodec)\n    ServeCodec is like ServeConn but uses the specified codec to decode requests\n    and encode responses.\n\nfunc ServeConn(conn io.ReadWriteCloser)\n    ServeConn runs the DefaultServer on a single connection. ServeConn blocks,\n    serving the connection until the client hangs up. The caller typically\n    invokes ServeConn in a go statement. ServeConn uses the gob wire format (see\n    package gob) on the connection. To use an alternate codec, use ServeCodec.\n    See NewClient's comment for information about concurrent access.\n\nfunc ServeRequest(codec ServerCodec) error\n    ServeRequest is like ServeCodec but synchronously serves a single request.\n    It does not close the codec upon completion.\n\n\nTYPES\n\ntype Call struct {\n\tServiceMethod string     // The name of the service and method to call.\n\tArgs          any        // The argument to the function (*struct).\n\tReply         any        // The reply from the function (*struct).\n\tError         error      // After completion, the error status.\n\tDone          chan *Call // Receives *Call when Go is complete.\n}\n    Call represents an active RPC.\n\ntype Client struct {\n\t// Has unexported fields.\n}\n    Client represents an RPC Client. There may be multiple outstanding Calls\n    associated with a single Client, and a Client may be used by multiple\n    goroutines simultaneously.\n\nfunc Dial(network, address string) (*Client, error)\n    Dial connects to an RPC server at the specified network address.\n\nfunc DialHTTP(network, address string) (*Client, error)\n    DialHTTP connects to an HTTP RPC server at the specified network address\n    listening on the default HTTP RPC path.\n\nfunc DialHTTPPath(network, address, path string) (*Client, error)\n    DialHTTPPath connects to an HTTP RPC server at the specified network address\n    and path.\n\nfunc NewClient(conn io.ReadWriteCloser) *Client\n    NewClient returns a new Client to handle requests to the set of services at\n    the other end of the connection. It adds a buffer to the write side of the\n    connection so the header and payload are sent as a unit.\n\n    The read and write halves of the connection are serialized independently, so\n    no interlocking is required. However each half may be accessed concurrently\n    so the implementation of conn should protect against concurrent reads or\n    concurrent writes.\n\nfunc NewClientWithCodec(codec ClientCodec) *Client\n    NewClientWithCodec is like NewClient but uses the specified codec to encode\n    requests and decode responses.\n\nfunc (client *Client) Call(serviceMethod string, args any, reply any) error\n    Call invokes the named function, waits for it to complete, and returns its\n    error status.\n\nfunc (client *Client) Close() error\n    Close calls the underlying codec's Close method. If the connection is\n    already shutting down, ErrShutdown is returned.\n\nfunc (client *Client) Go(serviceMethod string, args any, reply any, done chan *Call) *Call\n    Go invokes the function asynchronously. It returns the Call structure\n    representing the invocation. The done channel will signal when the call is\n    complete by returning the same Call object. If done is nil, Go will allocate\n    a new channel. If non-nil, done must be buffered or Go will deliberately\n    crash.\n\ntype ClientCodec interface {\n\tWriteRequest(*Request, any) error\n\tReadResponseHeader(*Response) error\n\tReadResponseBody(any) error\n\n\tClose() error\n}\n    A ClientCodec implements writing of RPC requests and reading of RPC\n    responses for the client side of an RPC session. The client calls\n    [ClientCodec.WriteRequest] to write a request to the connection and calls\n    [ClientCodec.ReadResponseHeader] and [ClientCodec.ReadResponseBody] in pairs\n    to read responses. The client calls [ClientCodec.Close] when finished with\n    the connection. ReadResponseBody may be called with a nil argument to force\n    the body of the response to be read and then discarded. See NewClient's\n    comment for information about concurrent access.\n\ntype Request struct {\n\tServiceMethod string // format: \"Service.Method\"\n\tSeq           uint64 // sequence number chosen by client\n\t// Has unexported fields.\n}\n    Request is a header written before every RPC call. It is used internally\n    but documented here as an aid to debugging, such as when analyzing network\n    traffic.\n\ntype Response struct {\n\tServiceMethod string // echoes that of the Request\n\tSeq           uint64 // echoes that of the request\n\tError         string // error, if any.\n\t// Has unexported fields.\n}\n    Response is a header written before every RPC return. It is used internally\n    but documented here as an aid to debugging, such as when analyzing network\n    traffic.\n\ntype Server struct {\n\t// Has unexported fields.\n}\n    Server represents an RPC Server.\n\nfunc NewServer() *Server\n    NewServer returns a new Server.\n\nfunc (server *Server) Accept(lis net.Listener)\n    Accept accepts connections on the listener and serves requests for each\n    incoming connection. Accept blocks until the listener returns a non-nil\n    error. The caller typically invokes Accept in a go statement.\n\nfunc (server *Server) HandleHTTP(rpcPath, debugPath string)\n    HandleHTTP registers an HTTP handler for RPC messages on rpcPath,\n    and a debugging handler on debugPath. It is still necessary to invoke\n    http.Serve(), typically in a go statement.\n\nfunc (server *Server) Register(rcvr any) error\n    Register publishes in the server the set of methods of the receiver value\n    that satisfy the following conditions:\n      - exported method of exported type\n      - two arguments, both of exported type\n      - the second argument is a pointer\n      - one return value, of type error\n\n    It returns an error if the receiver is not an exported type or has no\n    suitable methods. It also logs the error using package log. The client\n    accesses each method using a string of the form \"Type.Method\", where Type is\n    the receiver's concrete type.\n\nfunc (server *Server) RegisterName(name string, rcvr any) error\n    RegisterName is like Register but uses the provided name for the type\n    instead of the receiver's concrete type.\n\nfunc (server *Server) ServeCodec(codec ServerCodec)\n    ServeCodec is like ServeConn but uses the specified codec to decode requests\n    and encode responses.\n\nfunc (server *Server) ServeConn(conn io.ReadWriteCloser)\n    ServeConn runs the server on a single connection. ServeConn blocks,\n    serving the connection until the client hangs up. The caller typically\n    invokes ServeConn in a go statement. ServeConn uses the gob wire format (see\n    package gob) on the connection. To use an alternate codec, use ServeCodec.\n    See NewClient's comment for information about concurrent access.\n\nfunc (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request)\n    ServeHTTP implements an http.Handler that answers RPC requests.\n\nfunc (server *Server) ServeRequest(codec ServerCodec) error\n    ServeRequest is like ServeCodec but synchronously serves a single request.\n    It does not close the codec upon completion.\n\ntype ServerCodec interface {\n\tReadRequestHeader(*Request) error\n\tReadRequestBody(any) error\n\tWriteResponse(*Response, any) error\n\n\t// Close can be called multiple times and must be idempotent.\n\tClose() error\n}\n    A ServerCodec implements reading of RPC requests and writing of RPC\n    responses for the server side of an RPC session. The server calls\n    [ServerCodec.ReadRequestHeader] and [ServerCodec.ReadRequestBody]\n    in pairs to read requests from the connection, and it calls\n    [ServerCodec.WriteResponse] to write a response back. The server calls\n    [ServerCodec.Close] when finished with the connection. ReadRequestBody may\n    be called with a nil argument to force the body of the request to be read\n    and discarded. See NewClient's comment for information about concurrent\n    access.\n\ntype ServerError string\n    ServerError represents an error that has been returned from the remote side\n    of the RPC connection.\n\nfunc (e ServerError) Error() string\n\n"}, {"path": "stdlib/internal-coverage.md", "category": "stdlib", "name": "stdlib/internal-coverage", "content": "package coverage // import \"internal/coverage\"\n\n\nCONSTANTS\n\nconst CounterFilePref = \"covcounters\"\n    CounterFilePref is the file prefix used when emitting coverage data\n    output files. CounterFileTemplate describes the format of the file name:\n    prefix followed by meta-file hash followed by process ID followed by emit\n    UnixNanoTime.\n\nconst CounterFileRegexp = `^%s\\.(\\S+)\\.(\\d+)\\.(\\d+)+$`\nconst CounterFileTempl = \"%s.%x.%d.%d\"\nconst CounterFileVersion = 1\n    CounterFileVersion stores the most recent counter data file version.\n\nconst CovMetaHeaderSize = 16 + 4 + 4 + 4 + 4 + 4 + 4 + 4 // keep in sync with above\nconst FirstCtrOffset = 3\nconst FuncIdOffset = 2\nconst MetaFilePref = \"covmeta\"\n    MetaFilePref is a prefix used when emitting meta-data files; these files are\n    of the form \"covmeta.<hash>\", where hash is a hash computed from the hashes\n    of all the package meta-data symbols in the program.\n\nconst MetaFileVersion = 1\n    MetaFileVersion contains the current (most recent) meta-data file version.\n\nconst MetaFilesFileName = \"metafiles.txt\"\n    Name of file within the \"go test -cover\" temp coverdir directory containing\n    a list of meta-data files for packages being tested in a \"go test\n    -coverpkg=... ...\" run. This constant is shared by the Go command and by the\n    coverage runtime.\n\nconst NotHardCoded = -1\n    NotHardCoded is a package pseudo-ID indicating that a given package is not\n    part of the runtime and doesn't require a hard-coded ID.\n\nconst NumCtrsOffset = 0\nconst PkgIdOffset = 1\n\nVARIABLES\n\nvar CovCounterMagic = [4]byte{'\\x00', '\\x63', '\\x77', '\\x6d'}\n    CovCounterMagic holds the magic string for a coverage counter-data file.\n\nvar CovMetaMagic = [4]byte{'\\x00', '\\x63', '\\x76', '\\x6d'}\n    CovMetaMagic holds the magic string for a meta-data file.\n\n\nFUNCTIONS\n\nfunc HardCodedPkgID(pkgpath string) int\n    HardCodedPkgID returns the hard-coded ID for the specified package path,\n    or -1 if we don't use a hard-coded ID. Hard-coded IDs start at -2 and\n    decrease as we go down the list.\n\nfunc Round4(x int) int\n\nTYPES\n\ntype CounterFileFooter struct {\n\tMagic [4]byte\n\n\tNumSegments uint32\n\t// Has unexported fields.\n}\n    CounterFileFooter appears at the tail end of a counter data file, and stores\n    the number of segments it contains.\n\ntype CounterFileHeader struct {\n\tMagic     [4]byte\n\tVersion   uint32\n\tMetaHash  [16]byte\n\tCFlavor   CounterFlavor\n\tBigEndian bool\n\t// Has unexported fields.\n}\n    CounterFileHeader stores files header information for a counter-data file.\n\ntype CounterFlavor uint8\n    CounterFlavor describes how function and counters are stored/represented in\n    the counter section of the file.\n\nconst (\n\t// \"Raw\" representation: all values (pkg ID, func ID, num counters,\n\t// and counters themselves) are stored as uint32's.\n\tCtrRaw CounterFlavor = iota + 1\n\n\t// \"ULeb\" representation: all values (pkg ID, func ID, num counters,\n\t// and counters themselves) are stored with ULEB128 encoding.\n\tCtrULeb128\n)\ntype CounterGranularity uint8\n    CounterGranularity tracks the granularity of the coverage counters being\n    used in a given coverage-instrumented program.\n\nconst (\n\tCtrGranularityInvalid CounterGranularity = iota\n\tCtrGranularityPerBlock\n\tCtrGranularityPerFunc\n)\nfunc (cm CounterGranularity) String() string\n\ntype CounterMode uint8\n    CounterMode tracks the \"flavor\" of the coverage counters being used in a\n    given coverage-instrumented program.\n\nconst (\n\tCtrModeInvalid  CounterMode = iota\n\tCtrModeSet                  // \"set\" mode\n\tCtrModeCount                // \"count\" mode\n\tCtrModeAtomic               // \"atomic\" mode\n\tCtrModeRegOnly              // registration-only pseudo-mode\n\tCtrModeTestMain             // testmain pseudo-mode\n)\nfunc ParseCounterMode(mode string) CounterMode\n\nfunc (cm CounterMode) String() string\n\ntype CounterSegmentHeader struct {\n\tFcnEntries uint64\n\tStrTabLen  uint32\n\tArgsLen    uint32\n}\n    CounterSegmentHeader encapsulates information about a specific segment in a\n    counter data file, which at the moment contains counters data from a single\n    execution of a coverage-instrumented program. Following the segment header\n    will be the string table and args table, and then (possibly) padding bytes\n    to bring the byte size of the preamble up to a multiple of 4. Immediately\n    following that will be the counter payloads.\n\n    The \"args\" section of a segment is used to store annotations describing\n    where the counter data came from; this section is basically a series of\n    key-value pairs (can be thought of as an encoded 'map[string]string').\n    At the moment we only write os.Args() data to this section, using pairs of\n    the form \"argc=<integer>\", \"argv0=<os.Args[0]>\", \"argv1=<os.Args[1]>\", and\n    so on. In the future the args table may also include things like GOOS/GOARCH\n    values, and/or tags indicating which tests were run to generate the counter\n    data.\n\ntype CoverableUnit struct {\n\tStLine, StCol uint32\n\tEnLine, EnCol uint32\n\tNxStmts       uint32\n\tParent        uint32\n}\n    CoverableUnit describes the source characteristics of a single program\n    unit for which we want to gather coverage info. Coverable units are either\n    \"simple\" or \"intraline\"; a \"simple\" coverable unit corresponds to a basic\n    block (region of straight-line code with no jumps or control transfers).\n    An \"intraline\" unit corresponds to a logical clause nested within some other\n    simple unit. A simple unit will have a zero Parent value; for an intraline\n    unit NxStmts will be zero and Parent will be set to 1 plus the index of the\n    containing simple statement. Example:\n\n        L7:   q := 1\n        L8:   x := (y == 101 || launch() == false)\n        L9:   r := x * 2\n\n    For the code above we would have three simple units (one for each line),\n    then an intraline unit describing the \"launch() == false\" clause in line 8,\n    with Parent pointing to the index of the line 8 unit in the units array.\n\n    Note: in the initial version of the coverage revamp, only simple units will\n    be in use.\n\ntype FuncDesc struct {\n\tFuncname string\n\tSrcfile  string\n\tUnits    []CoverableUnit\n\tLit      bool // true if this is a function literal\n}\n    FuncDesc encapsulates the meta-data definitions for a single Go function.\n    This version assumes that we're looking at a function before inlining;\n    if we want to capture a post-inlining view of the world, the representations\n    of source positions would need to be a good deal more complicated.\n\ntype MetaFileCollection struct {\n\tImportPaths       []string\n\tMetaFileFragments []string\n}\n    MetaFileCollection contains information generated by the Go command and\n    the read in by coverage test support functions within an executing \"go test\n    -cover\" binary.\n\ntype MetaFileHeader struct {\n\tMagic        [4]byte\n\tVersion      uint32\n\tTotalLength  uint64\n\tEntries      uint64\n\tMetaFileHash [16]byte\n\tStrTabOffset uint32\n\tStrTabLength uint32\n\tCMode        CounterMode\n\tCGranularity CounterGranularity\n\t// Has unexported fields.\n}\n    MetaFileHeader stores file header information for a meta-data file.\n\ntype MetaSymbolHeader struct {\n\tLength     uint32 // size of meta-symbol payload in bytes\n\tPkgName    uint32 // string table index\n\tPkgPath    uint32 // string table index\n\tModulePath uint32 // string table index\n\tMetaHash   [16]byte\n\n\tNumFiles uint32\n\tNumFuncs uint32\n\t// Has unexported fields.\n}\n    MetaSymbolHeader stores header information for a single meta-data blob, e.g.\n    the coverage meta-data payload computed for a given Go package.\n\n"}, {"path": "stdlib/bytes.md", "category": "stdlib", "name": "stdlib/bytes", "content": "package bytes // import \"bytes\"\n\nPackage bytes implements functions for the manipulation of byte slices. It is\nanalogous to the facilities of the strings package.\n\nCONSTANTS\n\nconst MinRead = 512\n    MinRead is the minimum slice size passed to a Buffer.Read call by\n    Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond\n    what is required to hold the contents of r, Buffer.ReadFrom will not grow\n    the underlying buffer.\n\n\nVARIABLES\n\nvar ErrTooLarge = errors.New(\"bytes.Buffer: too large\")\n    ErrTooLarge is passed to panic if memory cannot be allocated to store data\n    in a buffer.\n\n\nFUNCTIONS\n\nfunc Clone(b []byte) []byte\n    Clone returns a copy of b[:len(b)]. The result may have additional unused\n    capacity. Clone(nil) returns nil.\n\nfunc Compare(a, b []byte) int\n    Compare returns an integer comparing two byte slices lexicographically.\n    The result will be 0 if a == b, -1 if a < b, and +1 if a > b. A nil argument\n    is equivalent to an empty slice.\n\nfunc Contains(b, subslice []byte) bool\n    Contains reports whether subslice is within b.\n\nfunc ContainsAny(b []byte, chars string) bool\n    ContainsAny reports whether any of the UTF-8-encoded code points in chars\n    are within b.\n\nfunc ContainsFunc(b []byte, f func(rune) bool) bool\n    ContainsFunc reports whether any of the UTF-8-encoded code points r within b\n    satisfy f(r).\n\nfunc ContainsRune(b []byte, r rune) bool\n    ContainsRune reports whether the rune is contained in the UTF-8-encoded byte\n    slice b.\n\nfunc Count(s, sep []byte) int\n    Count counts the number of non-overlapping instances of sep in s. If sep is\n    an empty slice, Count returns 1 + the number of UTF-8-encoded code points in\n    s.\n\nfunc Cut(s, sep []byte) (before, after []byte, found bool)\n    Cut slices s around the first instance of sep, returning the text before and\n    after sep. The found result reports whether sep appears in s. If sep does\n    not appear in s, cut returns s, nil, false.\n\n    Cut returns slices of the original slice s, not copies.\n\nfunc CutPrefix(s, prefix []byte) (after []byte, found bool)\n    CutPrefix returns s without the provided leading prefix byte slice and\n    reports whether it found the prefix. If s doesn't start with prefix,\n    CutPrefix returns s, false. If prefix is the empty byte slice, CutPrefix\n    returns s, true.\n\n    CutPrefix returns slices of the original slice s, not copies.\n\nfunc CutSuffix(s, suffix []byte) (before []byte, found bool)\n    CutSuffix returns s without the provided ending suffix byte slice and\n    reports whether it found the suffix. If s doesn't end with suffix, CutSuffix\n    returns s, false. If suffix is the empty byte slice, CutSuffix returns s,\n    true.\n\n    CutSuffix returns slices of the original slice s, not copies.\n\nfunc Equal(a, b []byte) bool\n    Equal reports whether a and b are the same length and contain the same\n    bytes. A nil argument is equivalent to an empty slice.\n\nfunc EqualFold(s, t []byte) bool\n    EqualFold reports whether s and t, interpreted as UTF-8 strings,\n    are equal under simple Unicode case-folding, which is a more general form of\n    case-insensitivity.\n\nfunc Fields(s []byte) [][]byte\n    Fields interprets s as a sequence of UTF-8-encoded code points. It splits\n    the slice s around each instance of one or more consecutive white space\n    characters, as defined by unicode.IsSpace, returning a slice of subslices\n    of s or an empty slice if s contains only white space. Every element of\n    the returned slice is non-empty. Unlike Split, leading and trailing runs of\n    white space characters are discarded.\n\nfunc FieldsFunc(s []byte, f func(rune) bool) [][]byte\n    FieldsFunc interprets s as a sequence of UTF-8-encoded code points.\n    It splits the slice s at each run of code points c satisfying f(c) and\n    returns a slice of subslices of s. If all code points in s satisfy f(c),\n    or len(s) == 0, an empty slice is returned. Every element of the returned\n    slice is non-empty. Unlike [SplitFunc], leading and trailing runs of code\n    points satisfying f(c) are discarded.\n\n    FieldsFunc makes no guarantees about the order in which it calls f(c) and\n    assumes that f always returns the same value for a given c.\n\nfunc FieldsFuncSeq(s []byte, f func(rune) bool) iter.Seq[[]byte]\n    FieldsFuncSeq returns an iterator over subslices of s split around runs of\n    Unicode code points satisfying f(c). The iterator yields the same subslices\n    that would be returned by FieldsFunc(s), but without constructing a new\n    slice containing the subslices.\n\nfunc FieldsSeq(s []byte) iter.Seq[[]byte]\n    FieldsSeq returns an iterator over subslices of s split around runs of\n    whitespace characters, as defined by unicode.IsSpace. The iterator yields\n    the same subslices that would be returned by Fields(s), but without\n    constructing a new slice containing the subslices.\n\nfunc HasPrefix(s, prefix []byte) bool\n    HasPrefix reports whether the byte slice s begins with prefix.\n\nfunc HasSuffix(s, suffix []byte) bool\n    HasSuffix reports whether the byte slice s ends with suffix.\n\nfunc Index(s, sep []byte) int\n    Index returns the index of the first instance of sep in s, or -1 if sep is\n    not present in s.\n\nfunc IndexAny(s []byte, chars string) int\n    IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.\n    It returns the byte index of the first occurrence in s of any of the Unicode\n    code points in chars. It returns -1 if chars is empty or if there is no code\n    point in common.\n\nfunc IndexByte(b []byte, c byte) int\n    IndexByte returns the index of the first instance of c in b, or -1 if c is\n    not present in b.\n\nfunc IndexFunc(s []byte, f func(r rune) bool) int\n    IndexFunc interprets s as a sequence of UTF-8-encoded code points. It\n    returns the byte index in s of the first Unicode code point satisfying f(c),\n    or -1 if none do.\n\nfunc IndexRune(s []byte, r rune) int\n    IndexRune interprets s as a sequence of UTF-8-encoded code points.\n    It returns the byte index of the first occurrence in s of the given rune.\n    It returns -1 if rune is not present in s. If r is utf8.RuneError,\n    it returns the first instance of any invalid UTF-8 byte sequence.\n\nfunc Join(s [][]byte, sep []byte) []byte\n    Join concatenates the elements of s to create a new byte slice. The\n    separator sep is placed between elements in the resulting slice.\n\nfunc LastIndex(s, sep []byte) int\n    LastIndex returns the index of the last instance of sep in s, or -1 if sep\n    is not present in s.\n\nfunc LastIndexAny(s []byte, chars string) int\n    LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code\n    points. It returns the byte index of the last occurrence in s of any of the\n    Unicode code points in chars. It returns -1 if chars is empty or if there is\n    no code point in common.\n\nfunc LastIndexByte(s []byte, c byte) int\n    LastIndexByte returns the index of the last instance of c in s, or -1 if c\n    is not present in s.\n\nfunc LastIndexFunc(s []byte, f func(r rune) bool) int\n    LastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It\n    returns the byte index in s of the last Unicode code point satisfying f(c),\n    or -1 if none do.\n\nfunc Lines(s []byte) iter.Seq[[]byte]\n    Lines returns an iterator over the newline-terminated lines in the byte\n    slice s. The lines yielded by the iterator include their terminating\n    newlines. If s is empty, the iterator yields no lines at all. If s does\n    not end in a newline, the final yielded line will not end in a newline.\n    It returns a single-use iterator.\n\nfunc Map(mapping func(r rune) rune, s []byte) []byte\n    Map returns a copy of the byte slice s with all its characters modified\n    according to the mapping function. If mapping returns a negative value, the\n    character is dropped from the byte slice with no replacement. The characters\n    in s and the output are interpreted as UTF-8-encoded code points.\n\nfunc Repeat(b []byte, count int) []byte\n    Repeat returns a new byte slice consisting of count copies of b.\n\n    It panics if count is negative or if the result of (len(b) * count)\n    overflows.\n\nfunc Replace(s, old, new []byte, n int) []byte\n    Replace returns a copy of the slice s with the first n non-overlapping\n    instances of old replaced by new. If old is empty, it matches at the\n    beginning of the slice and after each UTF-8 sequence, yielding up to k+1\n    replacements for a k-rune slice. If n < 0, there is no limit on the number\n    of replacements.\n\nfunc ReplaceAll(s, old, new []byte) []byte\n    ReplaceAll returns a copy of the slice s with all non-overlapping instances\n    of old replaced by new. If old is empty, it matches at the beginning of the\n    slice and after each UTF-8 sequence, yielding up to k+1 replacements for a\n    k-rune slice.\n\nfunc Runes(s []byte) []rune\n    Runes interprets s as a sequence of UTF-8-encoded code points. It returns a\n    slice of runes (Unicode code points) equivalent to s.\n\nfunc Split(s, sep []byte) [][]byte\n    Split slices s into all subslices separated by sep and returns a slice of\n    the subslices between those separators. If sep is empty, Split splits after\n    each UTF-8 sequence. It is equivalent to SplitN with a count of -1.\n\n    To split around the first instance of a separator, see Cut.\n\nfunc SplitAfter(s, sep []byte) [][]byte\n    SplitAfter slices s into all subslices after each instance of sep and\n    returns a slice of those subslices. If sep is empty, SplitAfter splits after\n    each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1.\n\nfunc SplitAfterN(s, sep []byte, n int) [][]byte\n    SplitAfterN slices s into subslices after each instance of sep and returns\n    a slice of those subslices. If sep is empty, SplitAfterN splits after each\n    UTF-8 sequence. The count determines the number of subslices to return:\n      - n > 0: at most n subslices; the last subslice will be the unsplit\n        remainder;\n      - n == 0: the result is nil (zero subslices);\n      - n < 0: all subslices.\n\nfunc SplitAfterSeq(s, sep []byte) iter.Seq[[]byte]\n    SplitAfterSeq returns an iterator over subslices of s split after each\n    instance of sep. The iterator yields the same subslices that would be\n    returned by SplitAfter(s, sep), but without constructing a new slice\n    containing the subslices. It returns a single-use iterator.\n\nfunc SplitN(s, sep []byte, n int) [][]byte\n    SplitN slices s into subslices separated by sep and returns a slice of the\n    subslices between those separators. If sep is empty, SplitN splits after\n    each UTF-8 sequence. The count determines the number of subslices to return:\n      - n > 0: at most n subslices; the last subslice will be the unsplit\n        remainder;\n      - n == 0: the result is nil (zero subslices);\n      - n < 0: all subslices.\n\n    To split around the first instance of a separator, see Cut.\n\nfunc SplitSeq(s, sep []byte) iter.Seq[[]byte]\n    SplitSeq returns an iterator over all subslices of s separated by sep.\n    The iterator yields the same subslices that would be returned by Split(s,\n    sep), but without constructing a new slice containing the subslices.\n    It returns a single-use iterator.\n\nfunc Title(s []byte) []byte\n    Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode\n    letters that begin words mapped to their title case.\n\n    Deprecated: The rule Title uses for word boundaries does not handle Unicode\n    punctuation properly. Use golang.org/x/text/cases instead.\n\nfunc ToLower(s []byte) []byte\n    ToLower returns a copy of the byte slice s with all Unicode letters mapped\n    to their lower case.\n\nfunc ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte\n    ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with\n    all the Unicode letters mapped to their lower case, giving priority to the\n    special casing rules.\n\nfunc ToTitle(s []byte) []byte\n    ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the\n    Unicode letters mapped to their title case.\n\nfunc ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte\n    ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with\n    all the Unicode letters mapped to their title case, giving priority to the\n    special casing rules.\n\nfunc ToUpper(s []byte) []byte\n    ToUpper returns a copy of the byte slice s with all Unicode letters mapped\n    to their upper case.\n\nfunc ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte\n    ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with\n    all the Unicode letters mapped to their upper case, giving priority to the\n    special casing rules.\n\nfunc ToValidUTF8(s, replacement []byte) []byte\n    ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run\n    of bytes representing invalid UTF-8 replaced with the bytes in replacement,\n    which may be empty.\n\nfunc Trim(s []byte, cutset string) []byte\n    Trim returns a subslice of s by slicing off all leading and trailing\n    UTF-8-encoded code points contained in cutset.\n\nfunc TrimFunc(s []byte, f func(r rune) bool) []byte\n    TrimFunc returns a subslice of s by slicing off all leading and trailing\n    UTF-8-encoded code points c that satisfy f(c).\n\nfunc TrimLeft(s []byte, cutset string) []byte\n    TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded\n    code points contained in cutset.\n\nfunc TrimLeftFunc(s []byte, f func(r rune) bool) []byte\n    TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by\n    slicing off all leading UTF-8-encoded code points c that satisfy f(c).\n\nfunc TrimPrefix(s, prefix []byte) []byte\n    TrimPrefix returns s without the provided leading prefix string. If s\n    doesn't start with prefix, s is returned unchanged.\n\nfunc TrimRight(s []byte, cutset string) []byte\n    TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded\n    code points that are contained in cutset.\n\nfunc TrimRightFunc(s []byte, f func(r rune) bool) []byte\n    TrimRightFunc returns a subslice of s by slicing off all trailing\n    UTF-8-encoded code points c that satisfy f(c).\n\nfunc TrimSpace(s []byte) []byte\n    TrimSpace returns a subslice of s by slicing off all leading and trailing\n    white space, as defined by Unicode.\n\nfunc TrimSuffix(s, suffix []byte) []byte\n    TrimSuffix returns s without the provided trailing suffix string. If s\n    doesn't end with suffix, s is returned unchanged.\n\n\nTYPES\n\ntype Buffer struct {\n\t// Has unexported fields.\n}\n    A Buffer is a variable-sized buffer of bytes with Buffer.Read and\n    Buffer.Write methods. The zero value for Buffer is an empty buffer ready to\n    use.\n\nfunc NewBuffer(buf []byte) *Buffer\n    NewBuffer creates and initializes a new Buffer using buf as its initial\n    contents. The new Buffer takes ownership of buf, and the caller should not\n    use buf after this call. NewBuffer is intended to prepare a Buffer to read\n    existing data. It can also be used to set the initial size of the internal\n    buffer for writing. To do that, buf should have the desired capacity but a\n    length of zero.\n\n    In most cases, new(Buffer) (or just declaring a Buffer variable) is\n    sufficient to initialize a Buffer.\n\nfunc NewBufferString(s string) *Buffer\n    NewBufferString creates and initializes a new Buffer using string s as its\n    initial contents. It is intended to prepare a buffer to read an existing\n    string.\n\n    In most cases, new(Buffer) (or just declaring a Buffer variable) is\n    sufficient to initialize a Buffer.\n\nfunc (b *Buffer) Available() int\n    Available returns how many bytes are unused in the buffer.\n\nfunc (b *Buffer) AvailableBuffer() []byte\n    AvailableBuffer returns an empty buffer with b.Available() capacity. This\n    buffer is intended to be appended to and passed to an immediately succeeding\n    Buffer.Write call. The buffer is only valid until the next write operation\n    on b.\n\nfunc (b *Buffer) Bytes() []byte\n    Bytes returns a slice of length b.Len() holding the unread portion of the\n    buffer. The slice is valid for use only until the next buffer modification\n    (that is, only until the next call to a method like Buffer.Read,\n    Buffer.Write, Buffer.Reset, or Buffer.Truncate). The slice aliases the\n    buffer content at least until the next buffer modification, so immediate\n    changes to the slice will affect the result of future reads.\n\nfunc (b *Buffer) Cap() int\n    Cap returns the capacity of the buffer's underlying byte slice, that is,\n    the total space allocated for the buffer's data.\n\nfunc (b *Buffer) Grow(n int)\n    Grow grows the buffer's capacity, if necessary, to guarantee space for\n    another n bytes. After Grow(n), at least n bytes can be written to the\n    buffer without another allocation. If n is negative, Grow will panic.\n    If the buffer can't grow it will panic with ErrTooLarge.\n\nfunc (b *Buffer) Len() int\n    Len returns the number of bytes of the unread portion of the buffer; b.Len()\n    == len(b.Bytes()).\n\nfunc (b *Buffer) Next(n int) []byte\n    Next returns a slice containing the next n bytes from the buffer,\n    advancing the buffer as if the bytes had been returned by Buffer.Read. If\n    there are fewer than n bytes in the buffer, Next returns the entire buffer.\n    The slice is only valid until the next call to a read or write method.\n\nfunc (b *Buffer) Read(p []byte) (n int, err error)\n    Read reads the next len(p) bytes from the buffer or until the buffer is\n    drained. The return value n is the number of bytes read. If the buffer has\n    no data to return, err is io.EOF (unless len(p) is zero); otherwise it is\n    nil.\n\nfunc (b *Buffer) ReadByte() (byte, error)\n    ReadByte reads and returns the next byte from the buffer. If no byte is\n    available, it returns error io.EOF.\n\nfunc (b *Buffer) ReadBytes(delim byte) (line []byte, err error)\n    ReadBytes reads until the first occurrence of delim in the input,\n    returning a slice containing the data up to and including the delimiter.\n    If ReadBytes encounters an error before finding a delimiter, it returns the\n    data read before the error and the error itself (often io.EOF). ReadBytes\n    returns err != nil if and only if the returned data does not end in delim.\n\nfunc (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)\n    ReadFrom reads data from r until EOF and appends it to the buffer, growing\n    the buffer as needed. The return value n is the number of bytes read.\n    Any error except io.EOF encountered during the read is also returned.\n    If the buffer becomes too large, ReadFrom will panic with ErrTooLarge.\n\nfunc (b *Buffer) ReadRune() (r rune, size int, err error)\n    ReadRune reads and returns the next UTF-8-encoded Unicode code point from\n    the buffer. If no bytes are available, the error returned is io.EOF. If the\n    bytes are an erroneous UTF-8 encoding, it consumes one byte and returns\n    U+FFFD, 1.\n\nfunc (b *Buffer) ReadString(delim byte) (line string, err error)\n    ReadString reads until the first occurrence of delim in the input,\n    returning a string containing the data up to and including the delimiter.\n    If ReadString encounters an error before finding a delimiter, it returns the\n    data read before the error and the error itself (often io.EOF). ReadString\n    returns err != nil if and only if the returned data does not end in delim.\n\nfunc (b *Buffer) Reset()\n    Reset resets the buffer to be empty, but it retains the underlying storage\n    for use by future writes. Reset is the same as Buffer.Truncate(0).\n\nfunc (b *Buffer) String() string\n    String returns the contents of the unread portion of the buffer as a string.\n    If the Buffer is a nil pointer, it returns \"<nil>\".\n\n    To build strings more efficiently, see the strings.Builder type.\n\nfunc (b *Buffer) Truncate(n int)\n    Truncate discards all but the first n unread bytes from the buffer but\n    continues to use the same allocated storage. It panics if n is negative or\n    greater than the length of the buffer.\n\nfunc (b *Buffer) UnreadByte() error\n    UnreadByte unreads the last byte returned by the most recent successful\n    read operation that read at least one byte. If a write has happened since\n    the last read, if the last read returned an error, or if the read read zero\n    bytes, UnreadByte returns an error.\n\nfunc (b *Buffer) UnreadRune() error\n    UnreadRune unreads the last rune returned by Buffer.ReadRune. If the\n    most recent read or write operation on the buffer was not a successful\n    Buffer.ReadRune, UnreadRune returns an error. (In this regard it is stricter\n    than Buffer.UnreadByte, which will unread the last byte from any read\n    operation.)\n\nfunc (b *Buffer) Write(p []byte) (n int, err error)\n    Write appends the contents of p to the buffer, growing the buffer as needed.\n    The return value n is the length of p; err is always nil. If the buffer\n    becomes too large, Write will panic with ErrTooLarge.\n\nfunc (b *Buffer) WriteByte(c byte) error\n    WriteByte appends the byte c to the buffer, growing the buffer as needed.\n    The returned error is always nil, but is included to match bufio.Writer's\n    WriteByte. If the buffer becomes too large, WriteByte will panic with\n    ErrTooLarge.\n\nfunc (b *Buffer) WriteRune(r rune) (n int, err error)\n    WriteRune appends the UTF-8 encoding of Unicode code point r to the buffer,\n    returning its length and an error, which is always nil but is included to\n    match bufio.Writer's WriteRune. The buffer is grown as needed; if it becomes\n    too large, WriteRune will panic with ErrTooLarge.\n\nfunc (b *Buffer) WriteString(s string) (n int, err error)\n    WriteString appends the contents of s to the buffer, growing the buffer as\n    needed. The return value n is the length of s; err is always nil. If the\n    buffer becomes too large, WriteString will panic with ErrTooLarge.\n\nfunc (b *Buffer) WriteTo(w io.Writer) (n int64, err error)\n    WriteTo writes data to w until the buffer is drained or an error occurs. The\n    return value n is the number of bytes written; it always fits into an int,\n    but it is int64 to match the io.WriterTo interface. Any error encountered\n    during the write is also returned.\n\ntype Reader struct {\n\t// Has unexported fields.\n}\n    A Reader implements the io.Reader, io.ReaderAt, io.WriterTo, io.Seeker,\n    io.ByteScanner, and io.RuneScanner interfaces by reading from a byte slice.\n    Unlike a Buffer, a Reader is read-only and supports seeking. The zero value\n    for Reader operates like a Reader of an empty slice.\n\nfunc NewReader(b []byte) *Reader\n    NewReader returns a new Reader reading from b.\n\nfunc (r *Reader) Len() int\n    Len returns the number of bytes of the unread portion of the slice.\n\nfunc (r *Reader) Read(b []byte) (n int, err error)\n    Read implements the io.Reader interface.\n\nfunc (r *Reader) ReadAt(b []byte, off int64) (n int, err error)\n    ReadAt implements the io.ReaderAt interface.\n\nfunc (r *Reader) ReadByte() (byte, error)\n    ReadByte implements the io.ByteReader interface.\n\nfunc (r *Reader) ReadRune() (ch rune, size int, err error)\n    ReadRune implements the io.RuneReader interface.\n\nfunc (r *Reader) Reset(b []byte)\n    Reset resets the Reader to be reading from b.\n\nfunc (r *Reader) Seek(offset int64, whence int) (int64, error)\n    Seek implements the io.Seeker interface.\n\nfunc (r *Reader) Size() int64\n    Size returns the original length of the underlying byte slice. Size is\n    the number of bytes available for reading via Reader.ReadAt. The result is\n    unaffected by any method calls except Reader.Reset.\n\nfunc (r *Reader) UnreadByte() error\n    UnreadByte complements Reader.ReadByte in implementing the io.ByteScanner\n    interface.\n\nfunc (r *Reader) UnreadRune() error\n    UnreadRune complements Reader.ReadRune in implementing the io.RuneScanner\n    interface.\n\nfunc (r *Reader) WriteTo(w io.Writer) (n int64, err error)\n    WriteTo implements the io.WriterTo interface.\n\n"}, {"path": "stdlib/slices.md", "category": "stdlib", "name": "stdlib/slices", "content": "package slices // import \"slices\"\n\nPackage slices defines various functions useful with slices of any type.\n\nFUNCTIONS\n\nfunc All[Slice ~[]E, E any](s Slice) iter.Seq2[int, E]\n    All returns an iterator over index-value pairs in the slice in the usual\n    order.\n\nfunc AppendSeq[Slice ~[]E, E any](s Slice, seq iter.Seq[E]) Slice\n    AppendSeq appends the values from seq to the slice and returns the extended\n    slice. If seq is empty, the result preserves the nilness of s.\n\nfunc Backward[Slice ~[]E, E any](s Slice) iter.Seq2[int, E]\n    Backward returns an iterator over index-value pairs in the slice, traversing\n    it backward with descending indices.\n\nfunc BinarySearch[S ~[]E, E cmp.Ordered](x S, target E) (int, bool)\n    BinarySearch searches for target in a sorted slice and returns the earliest\n    position where target is found, or the position where target would appear in\n    the sort order; it also returns a bool saying whether the target is really\n    found in the slice. The slice must be sorted in increasing order.\n\nfunc BinarySearchFunc[S ~[]E, E, T any](x S, target T, cmp func(E, T) int) (int, bool)\n    BinarySearchFunc works like BinarySearch, but uses a custom comparison\n    function. The slice must be sorted in increasing order, where \"increasing\"\n    is defined by cmp. cmp should return 0 if the slice element matches the\n    target, a negative number if the slice element precedes the target, or a\n    positive number if the slice element follows the target. cmp must implement\n    the same ordering as the slice, such that if cmp(a, t) < 0 and cmp(b,\n    t) >= 0, then a must precede b in the slice.\n\nfunc Chunk[Slice ~[]E, E any](s Slice, n int) iter.Seq[Slice]\n    Chunk returns an iterator over consecutive sub-slices of up to n elements of\n    s. All but the last sub-slice will have size n. All sub-slices are clipped\n    to have no capacity beyond the length. If s is empty, the sequence is empty:\n    there is no empty slice in the sequence. Chunk panics if n is less than 1.\n\nfunc Clip[S ~[]E, E any](s S) S\n    Clip removes unused capacity from the slice, returning s[:len(s):len(s)].\n    The result preserves the nilness of s.\n\nfunc Clone[S ~[]E, E any](s S) S\n    Clone returns a copy of the slice. The elements are copied using assignment,\n    so this is a shallow clone. The result may have additional unused capacity.\n    The result preserves the nilness of s.\n\nfunc Collect[E any](seq iter.Seq[E]) []E\n    Collect collects values from seq into a new slice and returns it. If seq is\n    empty, the result is nil.\n\nfunc Compact[S ~[]E, E comparable](s S) S\n    Compact replaces consecutive runs of equal elements with a single copy. This\n    is like the uniq command found on Unix. Compact modifies the contents of the\n    slice s and returns the modified slice, which may have a smaller length.\n    Compact zeroes the elements between the new length and the original length.\n    The result preserves the nilness of s.\n\nfunc CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S\n    CompactFunc is like Compact but uses an equality function to compare\n    elements. For runs of elements that compare equal, CompactFunc keeps the\n    first one. CompactFunc zeroes the elements between the new length and the\n    original length. The result preserves the nilness of s.\n\nfunc Compare[S ~[]E, E cmp.Ordered](s1, s2 S) int\n    Compare compares the elements of s1 and s2, using cmp.Compare on each pair\n    of elements. The elements are compared sequentially, starting at index 0,\n    until one element is not equal to the other. The result of comparing the\n    first non-matching elements is returned. If both slices are equal until one\n    of them ends, the shorter slice is considered less than the longer one.\n    The result is 0 if s1 == s2, -1 if s1 < s2, and +1 if s1 > s2.\n\nfunc CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int\n    CompareFunc is like Compare but uses a custom comparison function on\n    each pair of elements. The result is the first non-zero result of cmp;\n    if cmp always returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1)\n    < len(s2), and +1 if len(s1) > len(s2).\n\nfunc Concat[S ~[]E, E any](slices ...S) S\n    Concat returns a new slice concatenating the passed in slices. If the\n    concatenation is empty, the result is nil.\n\nfunc Contains[S ~[]E, E comparable](s S, v E) bool\n    Contains reports whether v is present in s.\n\nfunc ContainsFunc[S ~[]E, E any](s S, f func(E) bool) bool\n    ContainsFunc reports whether at least one element e of s satisfies f(e).\n\nfunc Delete[S ~[]E, E any](s S, i, j int) S\n    Delete removes the elements s[i:j] from s, returning the modified slice.\n    Delete panics if j > len(s) or s[i:j] is not a valid slice of s. Delete\n    is O(len(s)-i), so if many items must be deleted, it is better to make\n    a single call deleting them all together than to delete one at a time.\n    Delete zeroes the elements s[len(s)-(j-i):len(s)]. If the result is empty,\n    it has the same nilness as s.\n\nfunc DeleteFunc[S ~[]E, E any](s S, del func(E) bool) S\n    DeleteFunc removes any elements from s for which del returns true, returning\n    the modified slice. DeleteFunc zeroes the elements between the new length\n    and the original length. If the result is empty, it has the same nilness as\n    s.\n\nfunc Equal[S ~[]E, E comparable](s1, s2 S) bool\n    Equal reports whether two slices are equal: the same length and all elements\n    equal. If the lengths are different, Equal returns false. Otherwise,\n    the elements are compared in increasing index order, and the comparison\n    stops at the first unequal pair. Empty and nil slices are considered equal.\n    Floating point NaNs are not considered equal.\n\nfunc EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool\n    EqualFunc reports whether two slices are equal using an equality function\n    on each pair of elements. If the lengths are different, EqualFunc returns\n    false. Otherwise, the elements are compared in increasing index order,\n    and the comparison stops at the first index for which eq returns false.\n\nfunc Grow[S ~[]E, E any](s S, n int) S\n    Grow increases the slice's capacity, if necessary, to guarantee space for\n    another n elements. After Grow(n), at least n elements can be appended\n    to the slice without another allocation. If n is negative or too large to\n    allocate the memory, Grow panics. The result preserves the nilness of s.\n\nfunc Index[S ~[]E, E comparable](s S, v E) int\n    Index returns the index of the first occurrence of v in s, or -1 if not\n    present.\n\nfunc IndexFunc[S ~[]E, E any](s S, f func(E) bool) int\n    IndexFunc returns the first index i satisfying f(s[i]), or -1 if none do.\n\nfunc Insert[S ~[]E, E any](s S, i int, v ...E) S\n    Insert inserts the values v... into s at index i, returning the modified\n    slice. The elements at s[i:] are shifted up to make room. In the returned\n    slice r, r[i] == v[0], and, if i < len(s), r[i+len(v)] == value originally\n    at r[i]. Insert panics if i > len(s). This function is O(len(s) + len(v)).\n    If the result is empty, it has the same nilness as s.\n\nfunc IsSorted[S ~[]E, E cmp.Ordered](x S) bool\n    IsSorted reports whether x is sorted in ascending order.\n\nfunc IsSortedFunc[S ~[]E, E any](x S, cmp func(a, b E) int) bool\n    IsSortedFunc reports whether x is sorted in ascending order, with cmp as the\n    comparison function as defined by SortFunc.\n\nfunc Max[S ~[]E, E cmp.Ordered](x S) E\n    Max returns the maximal value in x. It panics if x is empty. For\n    floating-point E, Max propagates NaNs (any NaN value in x forces the output\n    to be NaN).\n\nfunc MaxFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E\n    MaxFunc returns the maximal value in x, using cmp to compare elements.\n    It panics if x is empty. If there is more than one maximal element according\n    to the cmp function, MaxFunc returns the first one.\n\nfunc Min[S ~[]E, E cmp.Ordered](x S) E\n    Min returns the minimal value in x. It panics if x is empty. For\n    floating-point numbers, Min propagates NaNs (any NaN value in x forces the\n    output to be NaN).\n\nfunc MinFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E\n    MinFunc returns the minimal value in x, using cmp to compare elements.\n    It panics if x is empty. If there is more than one minimal element according\n    to the cmp function, MinFunc returns the first one.\n\nfunc Repeat[S ~[]E, E any](x S, count int) S\n    Repeat returns a new slice that repeats the provided slice the given number\n    of times. The result has length and capacity (len(x) * count). The result is\n    never nil. Repeat panics if count is negative or if the result of (len(x) *\n    count) overflows.\n\nfunc Replace[S ~[]E, E any](s S, i, j int, v ...E) S\n    Replace replaces the elements s[i:j] by the given v, and returns the\n    modified slice. Replace panics if j > len(s) or s[i:j] is not a valid slice\n    of s. When len(v) < (j-i), Replace zeroes the elements between the new\n    length and the original length. If the result is empty, it has the same\n    nilness as s.\n\nfunc Reverse[S ~[]E, E any](s S)\n    Reverse reverses the elements of the slice in place.\n\nfunc Sort[S ~[]E, E cmp.Ordered](x S)\n    Sort sorts a slice of any ordered type in ascending order. When sorting\n    floating-point numbers, NaNs are ordered before other values.\n\nfunc SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int)\n    SortFunc sorts the slice x in ascending order as determined by the cmp\n    function. This sort is not guaranteed to be stable. cmp(a, b) should return\n    a negative number when a < b, a positive number when a > b and zero when a\n    == b or a and b are incomparable in the sense of a strict weak ordering.\n\n    SortFunc requires that cmp is a strict weak ordering. See\n    https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings.\n    The function should return 0 for incomparable items.\n\nfunc SortStableFunc[S ~[]E, E any](x S, cmp func(a, b E) int)\n    SortStableFunc sorts the slice x while keeping the original order of equal\n    elements, using cmp to compare elements in the same way as SortFunc.\n\nfunc Sorted[E cmp.Ordered](seq iter.Seq[E]) []E\n    Sorted collects values from seq into a new slice, sorts the slice, and\n    returns it. If seq is empty, the result is nil.\n\nfunc SortedFunc[E any](seq iter.Seq[E], cmp func(E, E) int) []E\n    SortedFunc collects values from seq into a new slice, sorts the slice using\n    the comparison function, and returns it. If seq is empty, the result is nil.\n\nfunc SortedStableFunc[E any](seq iter.Seq[E], cmp func(E, E) int) []E\n    SortedStableFunc collects values from seq into a new slice. It then sorts\n    the slice while keeping the original order of equal elements, using the\n    comparison function to compare elements. It returns the new slice. If seq is\n    empty, the result is nil.\n\nfunc Values[Slice ~[]E, E any](s Slice) iter.Seq[E]\n    Values returns an iterator that yields the slice elements in order.\n\n"}, {"path": "stdlib/runtime-metrics.md", "category": "stdlib", "name": "stdlib/runtime-metrics", "content": "package metrics // import \"runtime/metrics\"\n\nPackage metrics provides a stable interface to access implementation-defined\nmetrics exported by the Go runtime. This package is similar to existing\nfunctions like runtime.ReadMemStats and runtime/debug.ReadGCStats, but\nsignificantly more general.\n\nThe set of metrics defined by this package may evolve as the runtime itself\nevolves, and also enables variation across Go implementations, whose relevant\nmetric sets may not intersect.\n\n# Interface\n\nMetrics are designated by a string key, rather than, for example, a field name\nin a struct. The full list of supported metrics is always available in the\nslice of Descriptions returned by All. Each Description also includes useful\ninformation about the metric.\n\nThus, users of this API are encouraged to sample supported metrics defined by\nthe slice returned by All to remain compatible across Go versions. Of course,\nsituations arise where reading specific metrics is critical. For these cases,\nusers are encouraged to use build tags, and although metrics may be deprecated\nand removed, users should consider this to be an exceptional and rare event,\ncoinciding with a very large change in a particular Go implementation.\n\nEach metric key also has a \"kind\" (see ValueKind) that describes the format\nof the metric's value. In the interest of not breaking users of this package,\nthe \"kind\" for a given metric is guaranteed not to change. If it must change,\nthen a new metric will be introduced with a new key and a new \"kind.\"\n\n# Metric key format\n\nAs mentioned earlier, metric keys are strings. Their format is simple and\nwell-defined, designed to be both human and machine readable. It is split into\ntwo components, separated by a colon: a rooted path and a unit. The choice to\ninclude the unit in the key is motivated by compatibility: if a metric's unit\nchanges, its semantics likely did also, and a new key should be introduced.\n\nFor more details on the precise definition of the metric key's path and unit\nformats, see the documentation of the Name field of the Description struct.\n\n# A note about floats\n\nThis package supports metrics whose values have a floating-point representation.\nIn order to improve ease-of-use, this package promises to never produce the\nfollowing classes of floating-point values: NaN, infinity.\n\n# Supported metrics\n\nBelow is the full list of supported metrics, ordered lexicographically.\n\n    /cgo/go-to-c-calls:calls\n    \tCount of calls made from Go to C by the current process.\n\n    /cpu/classes/gc/mark/assist:cpu-seconds\n    \tEstimated total CPU time goroutines spent performing GC\n    \ttasks to assist the GC and prevent it from falling behind the\n    \tapplication. This metric is an overestimate, and not directly\n    \tcomparable to system CPU time measurements. Compare only with\n    \tother /cpu/classes metrics.\n\n    /cpu/classes/gc/mark/dedicated:cpu-seconds\n    \tEstimated total CPU time spent performing GC tasks on processors\n    \t(as defined by GOMAXPROCS) dedicated to those tasks. This metric\n    \tis an overestimate, and not directly comparable to system CPU\n    \ttime measurements. Compare only with other /cpu/classes metrics.\n\n    /cpu/classes/gc/mark/idle:cpu-seconds\n    \tEstimated total CPU time spent performing GC tasks on spare CPU\n    \tresources that the Go scheduler could not otherwise find a use\n    \tfor. This should be subtracted from the total GC CPU time to\n    \tobtain a measure of compulsory GC CPU time. This metric is an\n    \toverestimate, and not directly comparable to system CPU time\n    \tmeasurements. Compare only with other /cpu/classes metrics.\n\n    /cpu/classes/gc/pause:cpu-seconds\n    \tEstimated total CPU time spent with the application paused by\n    \tthe GC. Even if only one thread is running during the pause,\n    \tthis is computed as GOMAXPROCS times the pause latency because\n    \tnothing else can be executing. This is the exact sum of samples\n    \tin /sched/pauses/total/gc:seconds if each sample is multiplied\n    \tby GOMAXPROCS at the time it is taken. This metric is an\n    \toverestimate, and not directly comparable to system CPU time\n    \tmeasurements. Compare only with other /cpu/classes metrics.\n\n    /cpu/classes/gc/total:cpu-seconds\n    \tEstimated total CPU time spent performing GC tasks. This metric\n    \tis an overestimate, and not directly comparable to system CPU\n    \ttime measurements. Compare only with other /cpu/classes metrics.\n    \tSum of all metrics in /cpu/classes/gc.\n\n    /cpu/classes/idle:cpu-seconds\n    \tEstimated total available CPU time not spent executing\n    \tany Go or Go runtime code. In other words, the part of\n    \t/cpu/classes/total:cpu-seconds that was unused. This metric is\n    \tan overestimate, and not directly comparable to system CPU time\n    \tmeasurements. Compare only with other /cpu/classes metrics.\n\n    /cpu/classes/scavenge/assist:cpu-seconds\n    \tEstimated total CPU time spent returning unused memory to the\n    \tunderlying platform in response eagerly in response to memory\n    \tpressure. This metric is an overestimate, and not directly\n    \tcomparable to system CPU time measurements. Compare only with\n    \tother /cpu/classes metrics.\n\n    /cpu/classes/scavenge/background:cpu-seconds\n    \tEstimated total CPU time spent performing background tasks to\n    \treturn unused memory to the underlying platform. This metric is\n    \tan overestimate, and not directly comparable to system CPU time\n    \tmeasurements. Compare only with other /cpu/classes metrics.\n\n    /cpu/classes/scavenge/total:cpu-seconds\n    \tEstimated total CPU time spent performing tasks that return\n    \tunused memory to the underlying platform. This metric is an\n    \toverestimate, and not directly comparable to system CPU time\n    \tmeasurements. Compare only with other /cpu/classes metrics.\n    \tSum of all metrics in /cpu/classes/scavenge.\n\n    /cpu/classes/total:cpu-seconds\n    \tEstimated total available CPU time for user Go code or the Go\n    \truntime, as defined by GOMAXPROCS. In other words, GOMAXPROCS\n    \tintegrated over the wall-clock duration this process has been\n    \texecuting for. This metric is an overestimate, and not directly\n    \tcomparable to system CPU time measurements. Compare only with\n    \tother /cpu/classes metrics. Sum of all metrics in /cpu/classes.\n\n    /cpu/classes/user:cpu-seconds\n    \tEstimated total CPU time spent running user Go code. This may\n    \talso include some small amount of time spent in the Go runtime.\n    \tThis metric is an overestimate, and not directly comparable\n    \tto system CPU time measurements. Compare only with other\n    \t/cpu/classes metrics.\n\n    /gc/cycles/automatic:gc-cycles\n    \tCount of completed GC cycles generated by the Go runtime.\n\n    /gc/cycles/forced:gc-cycles\n    \tCount of completed GC cycles forced by the application.\n\n    /gc/cycles/total:gc-cycles\n    \tCount of all completed GC cycles.\n\n    /gc/gogc:percent\n    \tHeap size target percentage configured by the user, otherwise\n    \t100. This value is set by the GOGC environment variable, and the\n    \truntime/debug.SetGCPercent function.\n\n    /gc/gomemlimit:bytes\n    \tGo runtime memory limit configured by the user, otherwise\n    \tmath.MaxInt64. This value is set by the GOMEMLIMIT environment\n    \tvariable, and the runtime/debug.SetMemoryLimit function.\n\n    /gc/heap/allocs-by-size:bytes\n    \tDistribution of heap allocations by approximate size.\n    \tBucket counts increase monotonically. Note that this does not\n    \tinclude tiny objects as defined by /gc/heap/tiny/allocs:objects,\n    \tonly tiny blocks.\n\n    /gc/heap/allocs:bytes\n    \tCumulative sum of memory allocated to the heap by the\n    \tapplication.\n\n    /gc/heap/allocs:objects\n    \tCumulative count of heap allocations triggered by the\n    \tapplication. Note that this does not include tiny objects as\n    \tdefined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n\n    /gc/heap/frees-by-size:bytes\n    \tDistribution of freed heap allocations by approximate size.\n    \tBucket counts increase monotonically. Note that this does not\n    \tinclude tiny objects as defined by /gc/heap/tiny/allocs:objects,\n    \tonly tiny blocks.\n\n    /gc/heap/frees:bytes\n    \tCumulative sum of heap memory freed by the garbage collector.\n\n    /gc/heap/frees:objects\n    \tCumulative count of heap allocations whose storage was freed\n    \tby the garbage collector. Note that this does not include tiny\n    \tobjects as defined by /gc/heap/tiny/allocs:objects, only tiny\n    \tblocks.\n\n    /gc/heap/goal:bytes\n    \tHeap size target for the end of the GC cycle.\n\n    /gc/heap/live:bytes\n    \tHeap memory occupied by live objects that were marked by the\n    \tprevious GC.\n\n    /gc/heap/objects:objects\n    \tNumber of objects, live or unswept, occupying heap memory.\n\n    /gc/heap/tiny/allocs:objects\n    \tCount of small allocations that are packed together into blocks.\n    \tThese allocations are counted separately from other allocations\n    \tbecause each individual allocation is not tracked by the\n    \truntime, only their block. Each block is already accounted for\n    \tin allocs-by-size and frees-by-size.\n\n    /gc/limiter/last-enabled:gc-cycle\n    \tGC cycle the last time the GC CPU limiter was enabled.\n    \tThis metric is useful for diagnosing the root cause of an\n    \tout-of-memory error, because the limiter trades memory for CPU\n    \ttime when the GC's CPU time gets too high. This is most likely\n    \tto occur with use of SetMemoryLimit. The first GC cycle is cycle\n    \t1, so a value of 0 indicates that it was never enabled.\n\n    /gc/pauses:seconds\n    \tDeprecated. Prefer the identical /sched/pauses/total/gc:seconds.\n\n    /gc/scan/globals:bytes\n    \tThe total amount of global variable space that is scannable.\n\n    /gc/scan/heap:bytes\n    \tThe total amount of heap space that is scannable.\n\n    /gc/scan/stack:bytes\n    \tThe number of bytes of stack that were scanned last GC cycle.\n\n    /gc/scan/total:bytes\n    \tThe total amount space that is scannable. Sum of all metrics in\n    \t/gc/scan.\n\n    /gc/stack/starting-size:bytes\n    \tThe stack size of new goroutines.\n\n    /godebug/non-default-behavior/allowmultiplevcs:events\n    \tThe number of non-default behaviors executed by the cmd/go\n    \tpackage due to a non-default GODEBUG=allowmultiplevcs=...\n    \tsetting.\n\n    /godebug/non-default-behavior/asynctimerchan:events\n    \tThe number of non-default behaviors executed by the time package\n    \tdue to a non-default GODEBUG=asynctimerchan=... setting.\n\n    /godebug/non-default-behavior/containermaxprocs:events\n    \tThe number of non-default behaviors executed by the runtime\n    \tpackage due to a non-default GODEBUG=containermaxprocs=...\n    \tsetting.\n\n    /godebug/non-default-behavior/embedfollowsymlinks:events\n    \tThe number of non-default behaviors executed by the cmd/go\n    \tpackage due to a non-default GODEBUG=embedfollowsymlinks=...\n    \tsetting.\n\n    /godebug/non-default-behavior/execerrdot:events\n    \tThe number of non-default behaviors executed by the os/exec\n    \tpackage due to a non-default GODEBUG=execerrdot=... setting.\n\n    /godebug/non-default-behavior/gocachehash:events\n    \tThe number of non-default behaviors executed by the cmd/go\n    \tpackage due to a non-default GODEBUG=gocachehash=... setting.\n\n    /godebug/non-default-behavior/gocachetest:events\n    \tThe number of non-default behaviors executed by the cmd/go\n    \tpackage due to a non-default GODEBUG=gocachetest=... setting.\n\n    /godebug/non-default-behavior/gocacheverify:events\n    \tThe number of non-default behaviors executed by the cmd/go\n    \tpackage due to a non-default GODEBUG=gocacheverify=... setting.\n\n    /godebug/non-default-behavior/gotestjsonbuildtext:events\n    \tThe number of non-default behaviors executed by the cmd/go\n    \tpackage due to a non-default GODEBUG=gotestjsonbuildtext=...\n    \tsetting.\n\n    /godebug/non-default-behavior/gotypesalias:events\n    \tThe number of non-default behaviors executed by the go/types\n    \tpackage due to a non-default GODEBUG=gotypesalias=... setting.\n\n    /godebug/non-default-behavior/http2client:events\n    \tThe number of non-default behaviors executed by the net/http\n    \tpackage due to a non-default GODEBUG=http2client=... setting.\n\n    /godebug/non-default-behavior/http2server:events\n    \tThe number of non-default behaviors executed by the net/http\n    \tpackage due to a non-default GODEBUG=http2server=... setting.\n\n    /godebug/non-default-behavior/httpcookiemaxnum:events\n    \tThe number of non-default behaviors executed by the net/http\n    \tpackage due to a non-default GODEBUG=httpcookiemaxnum=...\n    \tsetting.\n\n    /godebug/non-default-behavior/httplaxcontentlength:events\n    \tThe number of non-default behaviors executed by the net/http\n    \tpackage due to a non-default GODEBUG=httplaxcontentlength=...\n    \tsetting.\n\n    /godebug/non-default-behavior/httpmuxgo121:events\n    \tThe number of non-default behaviors executed by the net/http\n    \tpackage due to a non-default GODEBUG=httpmuxgo121=... setting.\n\n    /godebug/non-default-behavior/httpservecontentkeepheaders:events\n    \tThe number of non-default behaviors executed\n    \tby the net/http package due to a non-default\n    \tGODEBUG=httpservecontentkeepheaders=... setting.\n\n    /godebug/non-default-behavior/installgoroot:events\n    \tThe number of non-default behaviors executed by the go/build\n    \tpackage due to a non-default GODEBUG=installgoroot=... setting.\n\n    /godebug/non-default-behavior/multipartmaxheaders:events\n    \tThe number of non-default behaviors executed by\n    \tthe mime/multipart package due to a non-default\n    \tGODEBUG=multipartmaxheaders=... setting.\n\n    /godebug/non-default-behavior/multipartmaxparts:events\n    \tThe number of non-default behaviors executed by\n    \tthe mime/multipart package due to a non-default\n    \tGODEBUG=multipartmaxparts=... setting.\n\n    /godebug/non-default-behavior/multipathtcp:events\n    \tThe number of non-default behaviors executed by the net package\n    \tdue to a non-default GODEBUG=multipathtcp=... setting.\n\n    /godebug/non-default-behavior/netedns0:events\n    \tThe number of non-default behaviors executed by the net package\n    \tdue to a non-default GODEBUG=netedns0=... setting.\n\n    /godebug/non-default-behavior/panicnil:events\n    \tThe number of non-default behaviors executed by the runtime\n    \tpackage due to a non-default GODEBUG=panicnil=... setting.\n\n    /godebug/non-default-behavior/randautoseed:events\n    \tThe number of non-default behaviors executed by the math/rand\n    \tpackage due to a non-default GODEBUG=randautoseed=... setting.\n\n    /godebug/non-default-behavior/randseednop:events\n    \tThe number of non-default behaviors executed by the math/rand\n    \tpackage due to a non-default GODEBUG=randseednop=... setting.\n\n    /godebug/non-default-behavior/rsa1024min:events\n    \tThe number of non-default behaviors executed by the crypto/rsa\n    \tpackage due to a non-default GODEBUG=rsa1024min=... setting.\n\n    /godebug/non-default-behavior/tarinsecurepath:events\n    \tThe number of non-default behaviors executed by the archive/tar\n    \tpackage due to a non-default GODEBUG=tarinsecurepath=...\n    \tsetting.\n\n    /godebug/non-default-behavior/tls10server:events\n    \tThe number of non-default behaviors executed by the crypto/tls\n    \tpackage due to a non-default GODEBUG=tls10server=... setting.\n\n    /godebug/non-default-behavior/tls3des:events\n    \tThe number of non-default behaviors executed by the crypto/tls\n    \tpackage due to a non-default GODEBUG=tls3des=... setting.\n\n    /godebug/non-default-behavior/tlsmaxrsasize:events\n    \tThe number of non-default behaviors executed by the crypto/tls\n    \tpackage due to a non-default GODEBUG=tlsmaxrsasize=... setting.\n\n    /godebug/non-default-behavior/tlsrsakex:events\n    \tThe number of non-default behaviors executed by the crypto/tls\n    \tpackage due to a non-default GODEBUG=tlsrsakex=... setting.\n\n    /godebug/non-default-behavior/tlssha1:events\n    \tThe number of non-default behaviors executed by the crypto/tls\n    \tpackage due to a non-default GODEBUG=tlssha1=... setting.\n\n    /godebug/non-default-behavior/tlsunsafeekm:events\n    \tThe number of non-default behaviors executed by the crypto/tls\n    \tpackage due to a non-default GODEBUG=tlsunsafeekm=... setting.\n\n    /godebug/non-default-behavior/updatemaxprocs:events\n    \tThe number of non-default behaviors executed by the runtime\n    \tpackage due to a non-default GODEBUG=updatemaxprocs=... setting.\n\n    /godebug/non-default-behavior/winreadlinkvolume:events\n    \tThe number of non-default behaviors executed by the os package\n    \tdue to a non-default GODEBUG=winreadlinkvolume=... setting.\n\n    /godebug/non-default-behavior/winsymlink:events\n    \tThe number of non-default behaviors executed by the os package\n    \tdue to a non-default GODEBUG=winsymlink=... setting.\n\n    /godebug/non-default-behavior/x509keypairleaf:events\n    \tThe number of non-default behaviors executed by the crypto/tls\n    \tpackage due to a non-default GODEBUG=x509keypairleaf=...\n    \tsetting.\n\n    /godebug/non-default-behavior/x509negativeserial:events\n    \tThe number of non-default behaviors executed by the crypto/x509\n    \tpackage due to a non-default GODEBUG=x509negativeserial=...\n    \tsetting.\n\n    /godebug/non-default-behavior/x509rsacrt:events\n    \tThe number of non-default behaviors executed by the crypto/x509\n    \tpackage due to a non-default GODEBUG=x509rsacrt=... setting.\n\n    /godebug/non-default-behavior/x509sha256skid:events\n    \tThe number of non-default behaviors executed by the crypto/x509\n    \tpackage due to a non-default GODEBUG=x509sha256skid=... setting.\n\n    /godebug/non-default-behavior/x509usefallbackroots:events\n    \tThe number of non-default behaviors executed by the crypto/x509\n    \tpackage due to a non-default GODEBUG=x509usefallbackroots=...\n    \tsetting.\n\n    /godebug/non-default-behavior/x509usepolicies:events\n    \tThe number of non-default behaviors executed by the crypto/x509\n    \tpackage due to a non-default GODEBUG=x509usepolicies=...\n    \tsetting.\n\n    /godebug/non-default-behavior/zipinsecurepath:events\n    \tThe number of non-default behaviors executed by the archive/zip\n    \tpackage due to a non-default GODEBUG=zipinsecurepath=...\n    \tsetting.\n\n    /memory/classes/heap/free:bytes\n    \tMemory that is completely free and eligible to be returned to\n    \tthe underlying system, but has not been. This metric is the\n    \truntime's estimate of free address space that is backed by\n    \tphysical memory.\n\n    /memory/classes/heap/objects:bytes\n    \tMemory occupied by live objects and dead objects that have not\n    \tyet been marked free by the garbage collector.\n\n    /memory/classes/heap/released:bytes\n    \tMemory that is completely free and has been returned to the\n    \tunderlying system. This metric is the runtime's estimate of free\n    \taddress space that is still mapped into the process, but is not\n    \tbacked by physical memory.\n\n    /memory/classes/heap/stacks:bytes\n    \tMemory allocated from the heap that is reserved for stack space,\n    \twhether or not it is currently in-use. Currently, this\n    \trepresents all stack memory for goroutines. It also includes all\n    \tOS thread stacks in non-cgo programs. Note that stacks may be\n    \tallocated differently in the future, and this may change.\n\n    /memory/classes/heap/unused:bytes\n    \tMemory that is reserved for heap objects but is not currently\n    \tused to hold heap objects.\n\n    /memory/classes/metadata/mcache/free:bytes\n    \tMemory that is reserved for runtime mcache structures, but not\n    \tin-use.\n\n    /memory/classes/metadata/mcache/inuse:bytes\n    \tMemory that is occupied by runtime mcache structures that are\n    \tcurrently being used.\n\n    /memory/classes/metadata/mspan/free:bytes\n    \tMemory that is reserved for runtime mspan structures, but not\n    \tin-use.\n\n    /memory/classes/metadata/mspan/inuse:bytes\n    \tMemory that is occupied by runtime mspan structures that are\n    \tcurrently being used.\n\n    /memory/classes/metadata/other:bytes\n    \tMemory that is reserved for or used to hold runtime metadata.\n\n    /memory/classes/os-stacks:bytes\n    \tStack memory allocated by the underlying operating system.\n    \tIn non-cgo programs this metric is currently zero. This may\n    \tchange in the future.In cgo programs this metric includes\n    \tOS thread stacks allocated directly from the OS. Currently,\n    \tthis only accounts for one stack in c-shared and c-archive build\n    \tmodes, and other sources of stacks from the OS are not measured.\n    \tThis too may change in the future.\n\n    /memory/classes/other:bytes\n    \tMemory used by execution trace buffers, structures for debugging\n    \tthe runtime, finalizer and profiler specials, and more.\n\n    /memory/classes/profiling/buckets:bytes\n    \tMemory that is used by the stack trace hash map used for\n    \tprofiling.\n\n    /memory/classes/total:bytes\n    \tAll memory mapped by the Go runtime into the current process\n    \tas read-write. Note that this does not include memory mapped\n    \tby code called via cgo or via the syscall package. Sum of all\n    \tmetrics in /memory/classes.\n\n    /sched/gomaxprocs:threads\n    \tThe current runtime.GOMAXPROCS setting, or the number of\n    \toperating system threads that can execute user-level Go code\n    \tsimultaneously.\n\n    /sched/goroutines:goroutines\n    \tCount of live goroutines.\n\n    /sched/latencies:seconds\n    \tDistribution of the time goroutines have spent in the scheduler\n    \tin a runnable state before actually running. Bucket counts\n    \tincrease monotonically.\n\n    /sched/pauses/stopping/gc:seconds\n    \tDistribution of individual GC-related stop-the-world stopping\n    \tlatencies. This is the time it takes from deciding to stop the\n    \tworld until all Ps are stopped. This is a subset of the total\n    \tGC-related stop-the-world time (/sched/pauses/total/gc:seconds).\n    \tDuring this time, some threads may be executing. Bucket counts\n    \tincrease monotonically.\n\n    /sched/pauses/stopping/other:seconds\n    \tDistribution of individual non-GC-related stop-the-world\n    \tstopping latencies. This is the time it takes from deciding\n    \tto stop the world until all Ps are stopped. This is a\n    \tsubset of the total non-GC-related stop-the-world time\n    \t(/sched/pauses/total/other:seconds). During this time, some\n    \tthreads may be executing. Bucket counts increase monotonically.\n\n    /sched/pauses/total/gc:seconds\n    \tDistribution of individual GC-related stop-the-world pause\n    \tlatencies. This is the time from deciding to stop the world\n    \tuntil the world is started again. Some of this time is spent\n    \tgetting all threads to stop (this is measured directly in\n    \t/sched/pauses/stopping/gc:seconds), during which some threads\n    \tmay still be running. Bucket counts increase monotonically.\n\n    /sched/pauses/total/other:seconds\n    \tDistribution of individual non-GC-related stop-the-world\n    \tpause latencies. This is the time from deciding to stop the\n    \tworld until the world is started again. Some of this time\n    \tis spent getting all threads to stop (measured directly in\n    \t/sched/pauses/stopping/other:seconds). Bucket counts increase\n    \tmonotonically.\n\n    /sync/mutex/wait/total:seconds\n    \tApproximate cumulative time goroutines have spent blocked on a\n    \tsync.Mutex, sync.RWMutex, or runtime-internal lock. This metric\n    \tis useful for identifying global changes in lock contention.\n    \tCollect a mutex or block profile using the runtime/pprof package\n    \tfor more detailed contention data.\n\nFUNCTIONS\n\nfunc Read(m []Sample)\n    Read populates each Value field in the given slice of metric samples.\n\n    Desired metrics should be present in the slice with the appropriate name.\n    The user of this API is encouraged to re-use the same slice between calls\n    for efficiency, but is not required to do so.\n\n    Note that re-use has some caveats. Notably, Values should not be read\n    or manipulated while a Read with that value is outstanding; that is a\n    data race. This property includes pointer-typed Values (for example,\n    Float64Histogram) whose underlying storage will be reused by Read when\n    possible. To safely use such values in a concurrent setting, all data must\n    be deep-copied.\n\n    It is safe to execute multiple Read calls concurrently, but their arguments\n    must share no underlying memory. When in doubt, create a new []Sample from\n    scratch, which is always safe, though may be inefficient.\n\n    Sample values with names not appearing in All will have their Value\n    populated as KindBad to indicate that the name is unknown.\n\n\nTYPES\n\ntype Description struct {\n\t// Name is the full name of the metric which includes the unit.\n\t//\n\t// The format of the metric may be described by the following regular expression.\n\t//\n\t//\t^(?P<name>/[^:]+):(?P<unit>[^:*/]+(?:[*/][^:*/]+)*)$\n\t//\n\t// The format splits the name into two components, separated by a colon: a path which always\n\t// starts with a /, and a machine-parseable unit. The name may contain any valid Unicode\n\t// codepoint in between / characters, but by convention will try to stick to lowercase\n\t// characters and hyphens. An example of such a path might be \"/memory/heap/free\".\n\t//\n\t// The unit is by convention a series of lowercase English unit names (singular or plural)\n\t// without prefixes delimited by '*' or '/'. The unit names may contain any valid Unicode\n\t// codepoint that is not a delimiter.\n\t// Examples of units might be \"seconds\", \"bytes\", \"bytes/second\", \"cpu-seconds\",\n\t// \"byte*cpu-seconds\", and \"bytes/second/second\".\n\t//\n\t// For histograms, multiple units may apply. For instance, the units of the buckets and\n\t// the count. By convention, for histograms, the units of the count are always \"samples\"\n\t// with the type of sample evident by the metric's name, while the unit in the name\n\t// specifies the buckets' unit.\n\t//\n\t// A complete name might look like \"/memory/heap/free:bytes\".\n\tName string\n\n\t// Description is an English language sentence describing the metric.\n\tDescription string\n\n\t// Kind is the kind of value for this metric.\n\t//\n\t// The purpose of this field is to allow users to filter out metrics whose values are\n\t// types which their application may not understand.\n\tKind ValueKind\n\n\t// Cumulative is whether or not the metric is cumulative. If a cumulative metric is just\n\t// a single number, then it increases monotonically. If the metric is a distribution,\n\t// then each bucket count increases monotonically.\n\t//\n\t// This flag thus indicates whether or not it's useful to compute a rate from this value.\n\tCumulative bool\n}\n    Description describes a runtime metric.\n\nfunc All() []Description\n    All returns a slice of containing metric descriptions for all supported\n    metrics.\n\ntype Float64Histogram struct {\n\t// Counts contains the weights for each histogram bucket.\n\t//\n\t// Given N buckets, Count[n] is the weight of the range\n\t// [bucket[n], bucket[n+1]), for 0 <= n < N.\n\tCounts []uint64\n\n\t// Buckets contains the boundaries of the histogram buckets, in increasing order.\n\t//\n\t// Buckets[0] is the inclusive lower bound of the minimum bucket while\n\t// Buckets[len(Buckets)-1] is the exclusive upper bound of the maximum bucket.\n\t// Hence, there are len(Buckets)-1 counts. Furthermore, len(Buckets) != 1, always,\n\t// since at least two boundaries are required to describe one bucket (and 0\n\t// boundaries are used to describe 0 buckets).\n\t//\n\t// Buckets[0] is permitted to have value -Inf and Buckets[len(Buckets)-1] is\n\t// permitted to have value Inf.\n\t//\n\t// For a given metric name, the value of Buckets is guaranteed not to change\n\t// between calls until program exit.\n\t//\n\t// This slice value is permitted to alias with other Float64Histograms' Buckets\n\t// fields, so the values within should only ever be read. If they need to be\n\t// modified, the user must make a copy.\n\tBuckets []float64\n}\n    Float64Histogram represents a distribution of float64 values.\n\ntype Sample struct {\n\t// Name is the name of the metric sampled.\n\t//\n\t// It must correspond to a name in one of the metric descriptions\n\t// returned by All.\n\tName string\n\n\t// Value is the value of the metric sample.\n\tValue Value\n}\n    Sample captures a single metric sample.\n\ntype Value struct {\n\t// Has unexported fields.\n}\n    Value represents a metric value returned by the runtime.\n\nfunc (v Value) Float64() float64\n    Float64 returns the internal float64 value for the metric.\n\n    If v.Kind() != KindFloat64, this method panics.\n\nfunc (v Value) Float64Histogram() *Float64Histogram\n    Float64Histogram returns the internal *Float64Histogram value for the\n    metric.\n\n    If v.Kind() != KindFloat64Histogram, this method panics.\n\nfunc (v Value) Kind() ValueKind\n    Kind returns the tag representing the kind of value this is.\n\nfunc (v Value) Uint64() uint64\n    Uint64 returns the internal uint64 value for the metric.\n\n    If v.Kind() != KindUint64, this method panics.\n\ntype ValueKind int\n    ValueKind is a tag for a metric Value which indicates its type.\n\nconst (\n\t// KindBad indicates that the Value has no type and should not be used.\n\tKindBad ValueKind = iota\n\n\t// KindUint64 indicates that the type of the Value is a uint64.\n\tKindUint64\n\n\t// KindFloat64 indicates that the type of the Value is a float64.\n\tKindFloat64\n\n\t// KindFloat64Histogram indicates that the type of the Value is a *Float64Histogram.\n\tKindFloat64Histogram\n)\n"}, {"path": "stdlib/hash-crc64.md", "category": "stdlib", "name": "stdlib/hash-crc64", "content": "package crc64 // import \"hash/crc64\"\n\nPackage crc64 implements the 64-bit cyclic redundancy check, or CRC-64,\nchecksum. See https://en.wikipedia.org/wiki/Cyclic_redundancy_check for\ninformation.\n\nCONSTANTS\n\nconst (\n\t// The ISO polynomial, defined in ISO 3309 and used in HDLC.\n\tISO = 0xD800000000000000\n\n\t// The ECMA polynomial, defined in ECMA 182.\n\tECMA = 0xC96C5795D7870F42\n)\n    Predefined polynomials.\n\nconst Size = 8\n    The size of a CRC-64 checksum in bytes.\n\n\nFUNCTIONS\n\nfunc Checksum(data []byte, tab *Table) uint64\n    Checksum returns the CRC-64 checksum of data using the polynomial\n    represented by the Table.\n\nfunc New(tab *Table) hash.Hash64\n    New creates a new hash.Hash64 computing the CRC-64 checksum using the\n    polynomial represented by the Table. Its Sum method will lay the value\n    out in big-endian byte order. The returned Hash64 also implements\n    encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and\n    unmarshal the internal state of the hash.\n\nfunc Update(crc uint64, tab *Table, p []byte) uint64\n    Update returns the result of adding the bytes in p to the crc.\n\n\nTYPES\n\ntype Table [256]uint64\n    Table is a 256-word table representing the polynomial for efficient\n    processing.\n\nfunc MakeTable(poly uint64) *Table\n    MakeTable returns a Table constructed from the specified polynomial.\n    The contents of this Table must not be modified.\n\n"}, {"path": "stdlib/crypto-ed25519.md", "category": "stdlib", "name": "stdlib/crypto-ed25519", "content": "package ed25519 // import \"crypto/ed25519\"\n\nPackage ed25519 implements the Ed25519 signature algorithm. See\nhttps://ed25519.cr.yp.to/.\n\nThese functions are also compatible with the \u201cEd25519\u201d function defined in\nRFC 8032. However, unlike RFC 8032's formulation, this package's private key\nrepresentation includes a public key suffix to make multiple signing operations\nwith the same key more efficient. This package refers to the RFC 8032 private\nkey as the \u201cseed\u201d.\n\nOperations involving private keys are implemented using constant-time\nalgorithms.\n\nCONSTANTS\n\nconst (\n\t// PublicKeySize is the size, in bytes, of public keys as used in this package.\n\tPublicKeySize = 32\n\t// PrivateKeySize is the size, in bytes, of private keys as used in this package.\n\tPrivateKeySize = 64\n\t// SignatureSize is the size, in bytes, of signatures generated and verified by this package.\n\tSignatureSize = 64\n\t// SeedSize is the size, in bytes, of private key seeds. These are the private key representations used by RFC 8032.\n\tSeedSize = 32\n)\n\nFUNCTIONS\n\nfunc GenerateKey(rand io.Reader) (PublicKey, PrivateKey, error)\n    GenerateKey generates a public/private key pair using entropy from rand.\n    If rand is nil, crypto/rand.Reader will be used.\n\n    The output of this function is deterministic, and equivalent to reading\n    SeedSize bytes from rand, and passing them to NewKeyFromSeed.\n\nfunc Sign(privateKey PrivateKey, message []byte) []byte\n    Sign signs the message with privateKey and returns a signature. It will\n    panic if len(privateKey) is not PrivateKeySize.\n\nfunc Verify(publicKey PublicKey, message, sig []byte) bool\n    Verify reports whether sig is a valid signature of message by publicKey.\n    It will panic if len(publicKey) is not PublicKeySize.\n\n    The inputs are not considered confidential, and may leak through timing side\n    channels, or if an attacker has control of part of the inputs.\n\nfunc VerifyWithOptions(publicKey PublicKey, message, sig []byte, opts *Options) error\n    VerifyWithOptions reports whether sig is a valid signature of message by\n    publicKey. A valid signature is indicated by returning a nil error. It will\n    panic if len(publicKey) is not PublicKeySize.\n\n    If opts.Hash is crypto.SHA512, the pre-hashed variant Ed25519ph is used\n    and message is expected to be a SHA-512 hash, otherwise opts.Hash must be\n    crypto.Hash(0) and the message must not be hashed, as Ed25519 performs two\n    passes over messages to be signed.\n\n    The inputs are not considered confidential, and may leak through timing side\n    channels, or if an attacker has control of part of the inputs.\n\n\nTYPES\n\ntype Options struct {\n\t// Hash can be zero for regular Ed25519, or crypto.SHA512 for Ed25519ph.\n\tHash crypto.Hash\n\n\t// Context, if not empty, selects Ed25519ctx or provides the context string\n\t// for Ed25519ph. It can be at most 255 bytes in length.\n\tContext string\n}\n    Options can be used with PrivateKey.Sign or VerifyWithOptions to select\n    Ed25519 variants.\n\nfunc (o *Options) HashFunc() crypto.Hash\n    HashFunc returns o.Hash.\n\ntype PrivateKey []byte\n    PrivateKey is the type of Ed25519 private keys. It implements crypto.Signer.\n\nfunc NewKeyFromSeed(seed []byte) PrivateKey\n    NewKeyFromSeed calculates a private key from a seed. It will panic if\n    len(seed) is not SeedSize. This function is provided for interoperability\n    with RFC 8032. RFC 8032's private keys correspond to seeds in this package.\n\nfunc (priv PrivateKey) Equal(x crypto.PrivateKey) bool\n    Equal reports whether priv and x have the same value.\n\nfunc (priv PrivateKey) Public() crypto.PublicKey\n    Public returns the PublicKey corresponding to priv.\n\nfunc (priv PrivateKey) Seed() []byte\n    Seed returns the private key seed corresponding to priv. It is provided for\n    interoperability with RFC 8032. RFC 8032's private keys correspond to seeds\n    in this package.\n\nfunc (priv PrivateKey) Sign(rand io.Reader, message []byte, opts crypto.SignerOpts) (signature []byte, err error)\n    Sign signs the given message with priv. rand is ignored and can be nil.\n\n    If opts.HashFunc() is crypto.SHA512, the pre-hashed variant Ed25519ph is\n    used and message is expected to be a SHA-512 hash, otherwise opts.HashFunc()\n    must be crypto.Hash(0) and the message must not be hashed, as Ed25519\n    performs two passes over messages to be signed.\n\n    A value of type Options can be used as opts, or crypto.Hash(0) or\n    crypto.SHA512 directly to select plain Ed25519 or Ed25519ph, respectively.\n\ntype PublicKey []byte\n    PublicKey is the type of Ed25519 public keys.\n\nfunc (pub PublicKey) Equal(x crypto.PublicKey) bool\n    Equal reports whether pub and x have the same value.\n\n"}, {"path": "stdlib/crypto-fips140.md", "category": "stdlib", "name": "stdlib/crypto-fips140", "content": "package fips140 // import \"crypto/fips140\"\n\n\nFUNCTIONS\n\nfunc Enabled() bool\n    Enabled reports whether the cryptography libraries are operating in FIPS\n    140-3 mode.\n\n    It can be controlled at runtime using the GODEBUG setting \"fips140\".\n    If set to \"on\", FIPS 140-3 mode is enabled. If set to \"only\", non-approved\n    cryptography functions will additionally return errors or panic.\n\n    This can't be changed after the program has started.\n\n"}, {"path": "stdlib/crypto-internal-fips140-rsa.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-rsa", "content": "package rsa // import \"crypto/internal/fips140/rsa\"\n\n\nVARIABLES\n\nvar ErrDecryption = errors.New(\"crypto/rsa: decryption error\")\nvar ErrMessageTooLong = errors.New(\"crypto/rsa: message too long for RSA key size\")\nvar ErrVerification = errors.New(\"crypto/rsa: verification error\")\n\nFUNCTIONS\n\nfunc DecryptOAEP(hash, mgfHash hash.Hash, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)\n    DecryptOAEP decrypts ciphertext using RSAES-OAEP.\n\nfunc DecryptWithCheck(priv *PrivateKey, ciphertext []byte) ([]byte, error)\n    DecryptWithCheck performs the RSA private key operation and checks the\n    result to defend against errors in the CRT computation.\n\nfunc DecryptWithoutCheck(priv *PrivateKey, ciphertext []byte) ([]byte, error)\n    DecryptWithoutCheck performs the RSA private key operation.\n\nfunc Encrypt(pub *PublicKey, plaintext []byte) ([]byte, error)\n    Encrypt performs the RSA public key operation.\n\nfunc EncryptOAEP(hash, mgfHash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error)\n    EncryptOAEP encrypts the given message with RSAES-OAEP.\n\nfunc PSSMaxSaltLength(pub *PublicKey, hash hash.Hash) (int, error)\n    PSSMaxSaltLength returns the maximum salt length for a given public key and\n    hash function.\n\nfunc SignPKCS1v15(priv *PrivateKey, hash string, hashed []byte) ([]byte, error)\n    SignPKCS1v15 calculates an RSASSA-PKCS1-v1.5 signature.\n\n    hash is the name of the hash function as returned by crypto.Hash.String or\n    the empty string to indicate that the message is signed directly.\n\nfunc SignPSS(rand io.Reader, priv *PrivateKey, hash hash.Hash, hashed []byte, saltLength int) ([]byte, error)\n    SignPSS calculates the signature of hashed using RSASSA-PSS.\n\nfunc VerifyPKCS1v15(pub *PublicKey, hash string, hashed []byte, sig []byte) error\n    VerifyPKCS1v15 verifies an RSASSA-PKCS1-v1.5 signature.\n\n    hash is the name of the hash function as returned by crypto.Hash.String or\n    the empty string to indicate that the message is signed directly.\n\nfunc VerifyPSS(pub *PublicKey, hash hash.Hash, digest []byte, sig []byte) error\n    VerifyPSS verifies sig with RSASSA-PSS automatically detecting the salt\n    length.\n\nfunc VerifyPSSWithSaltLength(pub *PublicKey, hash hash.Hash, digest []byte, sig []byte, saltLength int) error\n    VerifyPSS verifies sig with RSASSA-PSS and an expected salt length.\n\n\nTYPES\n\ntype PrivateKey struct {\n\t// Has unexported fields.\n}\n\nfunc GenerateKey(rand io.Reader, bits int) (*PrivateKey, error)\n    GenerateKey generates a new RSA key pair of the given bit size. bits must be\n    at least 32.\n\nfunc NewPrivateKey(N []byte, e int, d, P, Q []byte) (*PrivateKey, error)\n    NewPrivateKey creates a new RSA private key from the given parameters.\n\n    All values are in big-endian byte slice format, and may have leading zeros\n    or be shorter if leading zeroes were trimmed.\n\nfunc NewPrivateKeyWithPrecomputation(N []byte, e int, d, P, Q, dP, dQ, qInv []byte) (*PrivateKey, error)\n    NewPrivateKeyWithPrecomputation creates a new RSA private key from the given\n    parameters, which include precomputed CRT values.\n\nfunc NewPrivateKeyWithoutCRT(N []byte, e int, d []byte) (*PrivateKey, error)\n    NewPrivateKeyWithoutCRT creates a new RSA private key from the given\n    parameters.\n\n    This is meant for deprecated multi-prime keys, and is not FIPS 140\n    compliant.\n\nfunc (priv *PrivateKey) Export() (N []byte, e int, d, P, Q, dP, dQ, qInv []byte)\n    Export returns the key parameters in big-endian byte slice format.\n\n    P, Q, dP, dQ, and qInv may be nil if the key was created with\n    NewPrivateKeyWithoutCRT.\n\nfunc (priv *PrivateKey) PublicKey() *PublicKey\n\ntype PublicKey struct {\n\tN *bigmod.Modulus\n\tE int\n}\n\nfunc (pub *PublicKey) Size() int\n    Size returns the modulus size in bytes. Raw signatures and ciphertexts for\n    or by this public key will have the same size.\n\n"}, {"path": "stdlib/debug-dwarf.md", "category": "stdlib", "name": "stdlib/debug-dwarf", "content": "package dwarf // import \"debug/dwarf\"\n\nPackage dwarf provides access to DWARF debugging information loaded\nfrom executable files, as defined in the DWARF 2.0 Standard at\nhttp://dwarfstd.org/doc/dwarf-2.0.0.pdf.\n\n# Security\n\nThis package is not designed to be hardened against adversarial inputs,\nand is outside the scope of https://go.dev/security/policy. In particular,\nonly basic validation is done when parsing object files. As such, care should\nbe taken when parsing untrusted inputs, as parsing malformed files may consume\nsignificant resources, or cause panics.\n\nVARIABLES\n\nvar ErrUnknownPC = errors.New(\"ErrUnknownPC\")\n    ErrUnknownPC is the error returned by LineReader.ScanPC when the seek PC is\n    not covered by any entry in the line table.\n\n\nTYPES\n\ntype AddrType struct {\n\tBasicType\n}\n    An AddrType represents a machine address type.\n\ntype ArrayType struct {\n\tCommonType\n\tType          Type\n\tStrideBitSize int64 // if > 0, number of bits to hold each element\n\tCount         int64 // if == -1, an incomplete array, like char x[].\n}\n    An ArrayType represents a fixed size array type.\n\nfunc (t *ArrayType) Size() int64\n\nfunc (t *ArrayType) String() string\n\ntype Attr uint32\n    An Attr identifies the attribute type in a DWARF [Entry.Field].\n\nconst (\n\tAttrSibling        Attr = 0x01\n\tAttrLocation       Attr = 0x02\n\tAttrName           Attr = 0x03\n\tAttrOrdering       Attr = 0x09\n\tAttrByteSize       Attr = 0x0B\n\tAttrBitOffset      Attr = 0x0C\n\tAttrBitSize        Attr = 0x0D\n\tAttrStmtList       Attr = 0x10\n\tAttrLowpc          Attr = 0x11\n\tAttrHighpc         Attr = 0x12\n\tAttrLanguage       Attr = 0x13\n\tAttrDiscr          Attr = 0x15\n\tAttrDiscrValue     Attr = 0x16\n\tAttrVisibility     Attr = 0x17\n\tAttrImport         Attr = 0x18\n\tAttrStringLength   Attr = 0x19\n\tAttrCommonRef      Attr = 0x1A\n\tAttrCompDir        Attr = 0x1B\n\tAttrConstValue     Attr = 0x1C\n\tAttrContainingType Attr = 0x1D\n\tAttrDefaultValue   Attr = 0x1E\n\tAttrInline         Attr = 0x20\n\tAttrIsOptional     Attr = 0x21\n\tAttrLowerBound     Attr = 0x22\n\tAttrProducer       Attr = 0x25\n\tAttrPrototyped     Attr = 0x27\n\tAttrReturnAddr     Attr = 0x2A\n\tAttrStartScope     Attr = 0x2C\n\tAttrStrideSize     Attr = 0x2E\n\tAttrUpperBound     Attr = 0x2F\n\tAttrAbstractOrigin Attr = 0x31\n\tAttrAccessibility  Attr = 0x32\n\tAttrAddrClass      Attr = 0x33\n\tAttrArtificial     Attr = 0x34\n\tAttrBaseTypes      Attr = 0x35\n\tAttrCalling        Attr = 0x36\n\tAttrCount          Attr = 0x37\n\tAttrDataMemberLoc  Attr = 0x38\n\tAttrDeclColumn     Attr = 0x39\n\tAttrDeclFile       Attr = 0x3A\n\tAttrDeclLine       Attr = 0x3B\n\tAttrDeclaration    Attr = 0x3C\n\tAttrDiscrList      Attr = 0x3D\n\tAttrEncoding       Attr = 0x3E\n\tAttrExternal       Attr = 0x3F\n\tAttrFrameBase      Attr = 0x40\n\tAttrFriend         Attr = 0x41\n\tAttrIdentifierCase Attr = 0x42\n\tAttrMacroInfo      Attr = 0x43\n\tAttrNamelistItem   Attr = 0x44\n\tAttrPriority       Attr = 0x45\n\tAttrSegment        Attr = 0x46\n\tAttrSpecification  Attr = 0x47\n\tAttrStaticLink     Attr = 0x48\n\tAttrType           Attr = 0x49\n\tAttrUseLocation    Attr = 0x4A\n\tAttrVarParam       Attr = 0x4B\n\tAttrVirtuality     Attr = 0x4C\n\tAttrVtableElemLoc  Attr = 0x4D\n\t// The following are new in DWARF 3.\n\tAttrAllocated     Attr = 0x4E\n\tAttrAssociated    Attr = 0x4F\n\tAttrDataLocation  Attr = 0x50\n\tAttrStride        Attr = 0x51\n\tAttrEntrypc       Attr = 0x52\n\tAttrUseUTF8       Attr = 0x53\n\tAttrExtension     Attr = 0x54\n\tAttrRanges        Attr = 0x55\n\tAttrTrampoline    Attr = 0x56\n\tAttrCallColumn    Attr = 0x57\n\tAttrCallFile      Attr = 0x58\n\tAttrCallLine      Attr = 0x59\n\tAttrDescription   Attr = 0x5A\n\tAttrBinaryScale   Attr = 0x5B\n\tAttrDecimalScale  Attr = 0x5C\n\tAttrSmall         Attr = 0x5D\n\tAttrDecimalSign   Attr = 0x5E\n\tAttrDigitCount    Attr = 0x5F\n\tAttrPictureString Attr = 0x60\n\tAttrMutable       Attr = 0x61\n\tAttrThreadsScaled Attr = 0x62\n\tAttrExplicit      Attr = 0x63\n\tAttrObjectPointer Attr = 0x64\n\tAttrEndianity     Attr = 0x65\n\tAttrElemental     Attr = 0x66\n\tAttrPure          Attr = 0x67\n\tAttrRecursive     Attr = 0x68\n\t// The following are new in DWARF 4.\n\tAttrSignature      Attr = 0x69\n\tAttrMainSubprogram Attr = 0x6A\n\tAttrDataBitOffset  Attr = 0x6B\n\tAttrConstExpr      Attr = 0x6C\n\tAttrEnumClass      Attr = 0x6D\n\tAttrLinkageName    Attr = 0x6E\n\t// The following are new in DWARF 5.\n\tAttrStringLengthBitSize  Attr = 0x6F\n\tAttrStringLengthByteSize Attr = 0x70\n\tAttrRank                 Attr = 0x71\n\tAttrStrOffsetsBase       Attr = 0x72\n\tAttrAddrBase             Attr = 0x73\n\tAttrRnglistsBase         Attr = 0x74\n\tAttrDwoName              Attr = 0x76\n\tAttrReference            Attr = 0x77\n\tAttrRvalueReference      Attr = 0x78\n\tAttrMacros               Attr = 0x79\n\tAttrCallAllCalls         Attr = 0x7A\n\tAttrCallAllSourceCalls   Attr = 0x7B\n\tAttrCallAllTailCalls     Attr = 0x7C\n\tAttrCallReturnPC         Attr = 0x7D\n\tAttrCallValue            Attr = 0x7E\n\tAttrCallOrigin           Attr = 0x7F\n\tAttrCallParameter        Attr = 0x80\n\tAttrCallPC               Attr = 0x81\n\tAttrCallTailCall         Attr = 0x82\n\tAttrCallTarget           Attr = 0x83\n\tAttrCallTargetClobbered  Attr = 0x84\n\tAttrCallDataLocation     Attr = 0x85\n\tAttrCallDataValue        Attr = 0x86\n\tAttrNoreturn             Attr = 0x87\n\tAttrAlignment            Attr = 0x88\n\tAttrExportSymbols        Attr = 0x89\n\tAttrDeleted              Attr = 0x8A\n\tAttrDefaulted            Attr = 0x8B\n\tAttrLoclistsBase         Attr = 0x8C\n)\nfunc (a Attr) GoString() string\n\nfunc (i Attr) String() string\n\ntype BasicType struct {\n\tCommonType\n\tBitSize       int64\n\tBitOffset     int64\n\tDataBitOffset int64\n}\n    A BasicType holds fields common to all basic types.\n\n    See the documentation for StructField for more info on the interpretation of\n    the BitSize/BitOffset/DataBitOffset fields.\n\nfunc (b *BasicType) Basic() *BasicType\n\nfunc (t *BasicType) String() string\n\ntype BoolType struct {\n\tBasicType\n}\n    A BoolType represents a boolean type.\n\ntype CharType struct {\n\tBasicType\n}\n    A CharType represents a signed character type.\n\ntype Class int\n    A Class is the DWARF 4 class of an attribute value.\n\n    In general, a given attribute's value may take on one of several possible\n    classes defined by DWARF, each of which leads to a slightly different\n    interpretation of the attribute.\n\n    DWARF version 4 distinguishes attribute value classes more finely than\n    previous versions of DWARF. The reader will disambiguate coarser classes\n    from earlier versions of DWARF into the appropriate DWARF 4 class.\n    For example, DWARF 2 uses \"constant\" for constants as well as all types\n    of section offsets, but the reader will canonicalize attributes in DWARF\n    2 files that refer to section offsets to one of the Class*Ptr classes,\n    even though these classes were only defined in DWARF 3.\n\nconst (\n\t// ClassUnknown represents values of unknown DWARF class.\n\tClassUnknown Class = iota\n\n\t// ClassAddress represents values of type uint64 that are\n\t// addresses on the target machine.\n\tClassAddress\n\n\t// ClassBlock represents values of type []byte whose\n\t// interpretation depends on the attribute.\n\tClassBlock\n\n\t// ClassConstant represents values of type int64 that are\n\t// constants. The interpretation of this constant depends on\n\t// the attribute.\n\tClassConstant\n\n\t// ClassExprLoc represents values of type []byte that contain\n\t// an encoded DWARF expression or location description.\n\tClassExprLoc\n\n\t// ClassFlag represents values of type bool.\n\tClassFlag\n\n\t// ClassLinePtr represents values that are an int64 offset\n\t// into the \"line\" section.\n\tClassLinePtr\n\n\t// ClassLocListPtr represents values that are an int64 offset\n\t// into the \"loclist\" section.\n\tClassLocListPtr\n\n\t// ClassMacPtr represents values that are an int64 offset into\n\t// the \"mac\" section.\n\tClassMacPtr\n\n\t// ClassRangeListPtr represents values that are an int64 offset into\n\t// the \"rangelist\" section.\n\tClassRangeListPtr\n\n\t// ClassReference represents values that are an Offset offset\n\t// of an Entry in the info section (for use with Reader.Seek).\n\t// The DWARF specification combines ClassReference and\n\t// ClassReferenceSig into class \"reference\".\n\tClassReference\n\n\t// ClassReferenceSig represents values that are a uint64 type\n\t// signature referencing a type Entry.\n\tClassReferenceSig\n\n\t// ClassString represents values that are strings. If the\n\t// compilation unit specifies the AttrUseUTF8 flag (strongly\n\t// recommended), the string value will be encoded in UTF-8.\n\t// Otherwise, the encoding is unspecified.\n\tClassString\n\n\t// ClassReferenceAlt represents values of type int64 that are\n\t// an offset into the DWARF \"info\" section of an alternate\n\t// object file.\n\tClassReferenceAlt\n\n\t// ClassStringAlt represents values of type int64 that are an\n\t// offset into the DWARF string section of an alternate object\n\t// file.\n\tClassStringAlt\n\n\t// ClassAddrPtr represents values that are an int64 offset\n\t// into the \"addr\" section.\n\tClassAddrPtr\n\n\t// ClassLocList represents values that are an int64 offset\n\t// into the \"loclists\" section.\n\tClassLocList\n\n\t// ClassRngList represents values that are a uint64 offset\n\t// from the base of the \"rnglists\" section.\n\tClassRngList\n\n\t// ClassRngListsPtr represents values that are an int64 offset\n\t// into the \"rnglists\" section. These are used as the base for\n\t// ClassRngList values.\n\tClassRngListsPtr\n\n\t// ClassStrOffsetsPtr represents values that are an int64\n\t// offset into the \"str_offsets\" section.\n\tClassStrOffsetsPtr\n)\nfunc (i Class) GoString() string\n\nfunc (i Class) String() string\n\ntype CommonType struct {\n\tByteSize int64  // size of value of this type, in bytes\n\tName     string // name that can be used to refer to type\n}\n    A CommonType holds fields common to multiple types. If a field is not known\n    or not applicable for a given type, the zero value is used.\n\nfunc (c *CommonType) Common() *CommonType\n\nfunc (c *CommonType) Size() int64\n\ntype ComplexType struct {\n\tBasicType\n}\n    A ComplexType represents a complex floating point type.\n\ntype Data struct {\n\t// Has unexported fields.\n}\n    Data represents the DWARF debugging information loaded from an executable\n    file (for example, an ELF or Mach-O executable).\n\nfunc New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Data, error)\n    New returns a new Data object initialized from the given parameters. Rather\n    than calling this function directly, clients should typically use the DWARF\n    method of the File type of the appropriate package debug/elf, debug/macho,\n    or debug/pe.\n\n    The []byte arguments are the data from the corresponding debug section in\n    the object file; for example, for an ELF object, abbrev is the contents of\n    the \".debug_abbrev\" section.\n\nfunc (d *Data) AddSection(name string, contents []byte) error\n    AddSection adds another DWARF section by name. The name should be a DWARF\n    section name such as \".debug_addr\", \".debug_str_offsets\", and so forth.\n    This approach is used for new DWARF sections added in DWARF 5 and later.\n\nfunc (d *Data) AddTypes(name string, types []byte) error\n    AddTypes will add one .debug_types section to the DWARF data. A typical\n    object with DWARF version 4 debug info will have multiple .debug_types\n    sections. The name is used for error reporting only, and serves to\n    distinguish one .debug_types section from another.\n\nfunc (d *Data) LineReader(cu *Entry) (*LineReader, error)\n    LineReader returns a new reader for the line table of compilation unit cu,\n    which must be an Entry with tag TagCompileUnit.\n\n    If this compilation unit has no line table, it returns nil, nil.\n\nfunc (d *Data) Ranges(e *Entry) ([][2]uint64, error)\n    Ranges returns the PC ranges covered by e, a slice of [low,high) pairs. Only\n    some entry types, such as TagCompileUnit or TagSubprogram, have PC ranges;\n    for others, this will return nil with no error.\n\nfunc (d *Data) Reader() *Reader\n    Reader returns a new Reader for Data. The reader is positioned at byte\n    offset 0 in the DWARF \u201cinfo\u201d section.\n\nfunc (d *Data) Type(off Offset) (Type, error)\n    Type reads the type at off in the DWARF \u201cinfo\u201d section.\n\ntype DecodeError struct {\n\tName   string\n\tOffset Offset\n\tErr    string\n}\n\nfunc (e DecodeError) Error() string\n\ntype DotDotDotType struct {\n\tCommonType\n}\n    A DotDotDotType represents the variadic ... function parameter.\n\nfunc (t *DotDotDotType) String() string\n\ntype Entry struct {\n\tOffset   Offset // offset of Entry in DWARF info\n\tTag      Tag    // tag (kind of Entry)\n\tChildren bool   // whether Entry is followed by children\n\tField    []Field\n}\n    An entry is a sequence of attribute/value pairs.\n\nfunc (e *Entry) AttrField(a Attr) *Field\n    AttrField returns the Field associated with attribute Attr in Entry,\n    or nil if there is no such attribute.\n\nfunc (e *Entry) Val(a Attr) any\n    Val returns the value associated with attribute Attr in Entry, or nil if\n    there is no such attribute.\n\n    A common idiom is to merge the check for nil return with the check that the\n    value has the expected dynamic type, as in:\n\n        v, ok := e.Val(AttrSibling).(int64)\n\ntype EnumType struct {\n\tCommonType\n\tEnumName string\n\tVal      []*EnumValue\n}\n    An EnumType represents an enumerated type. The only indication of its native\n    integer type is its ByteSize (inside CommonType).\n\nfunc (t *EnumType) String() string\n\ntype EnumValue struct {\n\tName string\n\tVal  int64\n}\n    An EnumValue represents a single enumeration value.\n\ntype Field struct {\n\tAttr  Attr\n\tVal   any\n\tClass Class\n}\n    A Field is a single attribute/value pair in an Entry.\n\n    A value can be one of several \"attribute classes\" defined by DWARF. The Go\n    types corresponding to each class are:\n\n        DWARF class       Go type        Class\n        -----------       -------        -----\n        address           uint64         ClassAddress\n        block             []byte         ClassBlock\n        constant          int64          ClassConstant\n        flag              bool           ClassFlag\n        reference\n          to info         dwarf.Offset   ClassReference\n          to type unit    uint64         ClassReferenceSig\n        string            string         ClassString\n        exprloc           []byte         ClassExprLoc\n        lineptr           int64          ClassLinePtr\n        loclistptr        int64          ClassLocListPtr\n        macptr            int64          ClassMacPtr\n        rangelistptr      int64          ClassRangeListPtr\n\n    For unrecognized or vendor-defined attributes, Class may be ClassUnknown.\n\ntype FloatType struct {\n\tBasicType\n}\n    A FloatType represents a floating point type.\n\ntype FuncType struct {\n\tCommonType\n\tReturnType Type\n\tParamType  []Type\n}\n    A FuncType represents a function type.\n\nfunc (t *FuncType) String() string\n\ntype IntType struct {\n\tBasicType\n}\n    An IntType represents a signed integer type.\n\ntype LineEntry struct {\n\t// Address is the program-counter value of a machine\n\t// instruction generated by the compiler. This LineEntry\n\t// applies to each instruction from Address to just before the\n\t// Address of the next LineEntry.\n\tAddress uint64\n\n\t// OpIndex is the index of an operation within a VLIW\n\t// instruction. The index of the first operation is 0. For\n\t// non-VLIW architectures, it will always be 0. Address and\n\t// OpIndex together form an operation pointer that can\n\t// reference any individual operation within the instruction\n\t// stream.\n\tOpIndex int\n\n\t// File is the source file corresponding to these\n\t// instructions.\n\tFile *LineFile\n\n\t// Line is the source code line number corresponding to these\n\t// instructions. Lines are numbered beginning at 1. It may be\n\t// 0 if these instructions cannot be attributed to any source\n\t// line.\n\tLine int\n\n\t// Column is the column number within the source line of these\n\t// instructions. Columns are numbered beginning at 1. It may\n\t// be 0 to indicate the \"left edge\" of the line.\n\tColumn int\n\n\t// IsStmt indicates that Address is a recommended breakpoint\n\t// location, such as the beginning of a line, statement, or a\n\t// distinct subpart of a statement.\n\tIsStmt bool\n\n\t// BasicBlock indicates that Address is the beginning of a\n\t// basic block.\n\tBasicBlock bool\n\n\t// PrologueEnd indicates that Address is one (of possibly\n\t// many) PCs where execution should be suspended for a\n\t// breakpoint on entry to the containing function.\n\t//\n\t// Added in DWARF 3.\n\tPrologueEnd bool\n\n\t// EpilogueBegin indicates that Address is one (of possibly\n\t// many) PCs where execution should be suspended for a\n\t// breakpoint on exit from this function.\n\t//\n\t// Added in DWARF 3.\n\tEpilogueBegin bool\n\n\t// ISA is the instruction set architecture for these\n\t// instructions. Possible ISA values should be defined by the\n\t// applicable ABI specification.\n\t//\n\t// Added in DWARF 3.\n\tISA int\n\n\t// Discriminator is an arbitrary integer indicating the block\n\t// to which these instructions belong. It serves to\n\t// distinguish among multiple blocks that may all have with\n\t// the same source file, line, and column. Where only one\n\t// block exists for a given source position, it should be 0.\n\t//\n\t// Added in DWARF 3.\n\tDiscriminator int\n\n\t// EndSequence indicates that Address is the first byte after\n\t// the end of a sequence of target machine instructions. If it\n\t// is set, only this and the Address field are meaningful. A\n\t// line number table may contain information for multiple\n\t// potentially disjoint instruction sequences. The last entry\n\t// in a line table should always have EndSequence set.\n\tEndSequence bool\n}\n    A LineEntry is a row in a DWARF line table.\n\ntype LineFile struct {\n\tName   string\n\tMtime  uint64 // Implementation defined modification time, or 0 if unknown\n\tLength int    // File length, or 0 if unknown\n}\n    A LineFile is a source file referenced by a DWARF line table entry.\n\ntype LineReader struct {\n\t// Has unexported fields.\n}\n    A LineReader reads a sequence of LineEntry structures from a DWARF \"line\"\n    section for a single compilation unit. LineEntries occur in order of\n    increasing PC and each LineEntry gives metadata for the instructions from\n    that LineEntry's PC to just before the next LineEntry's PC. The last entry\n    will have the [LineEntry.EndSequence] field set.\n\nfunc (r *LineReader) Files() []*LineFile\n    Files returns the file name table of this compilation unit as of the current\n    position in the line table. The file name table may be referenced from\n    attributes in this compilation unit such as AttrDeclFile.\n\n    Entry 0 is always nil, since file index 0 represents \"no file\".\n\n    The file name table of a compilation unit is not fixed. Files returns the\n    file table as of the current position in the line table. This may contain\n    more entries than the file table at an earlier position in the line table,\n    though existing entries never change.\n\nfunc (r *LineReader) Next(entry *LineEntry) error\n    Next sets *entry to the next row in this line table and moves to the next\n    row. If there are no more entries and the line table is properly terminated,\n    it returns io.EOF.\n\n    Rows are always in order of increasing entry.Address, but entry.Line may go\n    forward or backward.\n\nfunc (r *LineReader) Reset()\n    Reset repositions the line table reader at the beginning of the line table.\n\nfunc (r *LineReader) Seek(pos LineReaderPos)\n    Seek restores the line table reader to a position returned by\n    LineReader.Tell.\n\n    The argument pos must have been returned by a call to LineReader.Tell on\n    this line table.\n\nfunc (r *LineReader) SeekPC(pc uint64, entry *LineEntry) error\n    SeekPC sets *entry to the LineEntry that includes pc and positions the\n    reader on the next entry in the line table. If necessary, this will seek\n    backwards to find pc.\n\n    If pc is not covered by any entry in this line table, SeekPC returns\n    ErrUnknownPC. In this case, *entry and the final seek position are\n    unspecified.\n\n    Note that DWARF line tables only permit sequential, forward scans. Hence,\n    in the worst case, this takes time linear in the size of the line table.\n    If the caller wishes to do repeated fast PC lookups, it should build an\n    appropriate index of the line table.\n\nfunc (r *LineReader) Tell() LineReaderPos\n    Tell returns the current position in the line table.\n\ntype LineReaderPos struct {\n\t// Has unexported fields.\n}\n    A LineReaderPos represents a position in a line table.\n\ntype Offset uint32\n    An Offset represents the location of an Entry within the DWARF info.\n    (See Reader.Seek.)\n\ntype PtrType struct {\n\tCommonType\n\tType Type\n}\n    A PtrType represents a pointer type.\n\nfunc (t *PtrType) String() string\n\ntype QualType struct {\n\tCommonType\n\tQual string\n\tType Type\n}\n    A QualType represents a type that has the C/C++ \"const\", \"restrict\",\n    or \"volatile\" qualifier.\n\nfunc (t *QualType) Size() int64\n\nfunc (t *QualType) String() string\n\ntype Reader struct {\n\t// Has unexported fields.\n}\n    A Reader allows reading Entry structures from a DWARF \u201cinfo\u201d section.\n    The Entry structures are arranged in a tree. The Reader.Next function return\n    successive entries from a pre-order traversal of the tree. If an entry\n    has children, its Children field will be true, and the children follow,\n    terminated by an Entry with Tag 0.\n\nfunc (r *Reader) AddressSize() int\n    AddressSize returns the size in bytes of addresses in the current\n    compilation unit.\n\nfunc (r *Reader) ByteOrder() binary.ByteOrder\n    ByteOrder returns the byte order in the current compilation unit.\n\nfunc (r *Reader) Next() (*Entry, error)\n    Next reads the next entry from the encoded entry stream. It returns nil,\n    nil when it reaches the end of the section. It returns an error if the\n    current offset is invalid or the data at the offset cannot be decoded as a\n    valid Entry.\n\nfunc (r *Reader) Seek(off Offset)\n    Seek positions the Reader at offset off in the encoded entry stream.\n    Offset 0 can be used to denote the first entry.\n\nfunc (r *Reader) SeekPC(pc uint64) (*Entry, error)\n    SeekPC returns the Entry for the compilation unit that includes pc, and\n    positions the reader to read the children of that unit. If pc is not covered\n    by any unit, SeekPC returns ErrUnknownPC and the position of the reader is\n    undefined.\n\n    Because compilation units can describe multiple regions of the executable,\n    in the worst case SeekPC must search through all the ranges in all the\n    compilation units. Each call to SeekPC starts the search at the compilation\n    unit of the last call, so in general looking up a series of PCs will be\n    faster if they are sorted. If the caller wishes to do repeated fast PC\n    lookups, it should build an appropriate index using the Ranges method.\n\nfunc (r *Reader) SkipChildren()\n    SkipChildren skips over the child entries associated with the last Entry\n    returned by Reader.Next. If that Entry did not have children or Reader.Next\n    has not been called, SkipChildren is a no-op.\n\ntype StructField struct {\n\tName          string\n\tType          Type\n\tByteOffset    int64\n\tByteSize      int64 // usually zero; use Type.Size() for normal fields\n\tBitOffset     int64\n\tDataBitOffset int64\n\tBitSize       int64 // zero if not a bit field\n}\n    A StructField represents a field in a struct, union, or C++ class type.\n\n    # Bit Fields\n\n    The BitSize, BitOffset, and DataBitOffset fields describe the bit size and\n    offset of data members declared as bit fields in C/C++ struct/union/class\n    types.\n\n    BitSize is the number of bits in the bit field.\n\n    DataBitOffset, if non-zero, is the number of bits from the start of the\n    enclosing entity (e.g. containing struct/class/union) to the start of the\n    bit field. This corresponds to the DW_AT_data_bit_offset DWARF attribute\n    that was introduced in DWARF 4.\n\n    BitOffset, if non-zero, is the number of bits between the most significant\n    bit of the storage unit holding the bit field to the most significant\n    bit of the bit field. Here \"storage unit\" is the type name before the\n    bit field (for a field \"unsigned x:17\", the storage unit is \"unsigned\").\n    BitOffset values can vary depending on the endianness of the system.\n    BitOffset corresponds to the DW_AT_bit_offset DWARF attribute that was\n    deprecated in DWARF 4 and removed in DWARF 5.\n\n    At most one of DataBitOffset and BitOffset will be non-zero;\n    DataBitOffset/BitOffset will only be non-zero if BitSize is non-zero.\n    Whether a C compiler uses one or the other will depend on compiler vintage\n    and command line options.\n\n    Here is an example of C/C++ bit field use, along with what to expect in\n    terms of DWARF bit offset info. Consider this code:\n\n        struct S {\n        \tint q;\n        \tint j:5;\n        \tint k:6;\n        \tint m:5;\n        \tint n:8;\n        } s;\n\n    For the code above, one would expect to see the following for\n    DW_AT_bit_offset values (using GCC 8):\n\n               Little   |     Big\n               Endian   |    Endian\n                        |\n        \"j\":     27     |     0\n        \"k\":     21     |     5\n        \"m\":     16     |     11\n        \"n\":     8      |     16\n\n    Note that in the above the offsets are purely with respect to the containing\n    storage unit for j/k/m/n -- these values won't vary based on the size of\n    prior data members in the containing struct.\n\n    If the compiler emits DW_AT_data_bit_offset, the expected values would be:\n\n        \"j\":     32\n        \"k\":     37\n        \"m\":     43\n        \"n\":     48\n\n    Here the value 32 for \"j\" reflects the fact that the bit field is preceded\n    by other data members (recall that DW_AT_data_bit_offset values are relative\n    to the start of the containing struct). Hence DW_AT_data_bit_offset values\n    can be quite large for structs with many fields.\n\n    DWARF also allow for the possibility of base types that have non-zero bit\n    size and bit offset, so this information is also captured for base types,\n    but it is worth noting that it is not possible to trigger this behavior\n    using mainstream languages.\n\ntype StructType struct {\n\tCommonType\n\tStructName string\n\tKind       string // \"struct\", \"union\", or \"class\".\n\tField      []*StructField\n\tIncomplete bool // if true, struct, union, class is declared but not defined\n}\n    A StructType represents a struct, union, or C++ class type.\n\nfunc (t *StructType) Defn() string\n\nfunc (t *StructType) String() string\n\ntype Tag uint32\n    A Tag is the classification (the type) of an Entry.\n\nconst (\n\tTagArrayType              Tag = 0x01\n\tTagClassType              Tag = 0x02\n\tTagEntryPoint             Tag = 0x03\n\tTagEnumerationType        Tag = 0x04\n\tTagFormalParameter        Tag = 0x05\n\tTagImportedDeclaration    Tag = 0x08\n\tTagLabel                  Tag = 0x0A\n\tTagLexDwarfBlock          Tag = 0x0B\n\tTagMember                 Tag = 0x0D\n\tTagPointerType            Tag = 0x0F\n\tTagReferenceType          Tag = 0x10\n\tTagCompileUnit            Tag = 0x11\n\tTagStringType             Tag = 0x12\n\tTagStructType             Tag = 0x13\n\tTagSubroutineType         Tag = 0x15\n\tTagTypedef                Tag = 0x16\n\tTagUnionType              Tag = 0x17\n\tTagUnspecifiedParameters  Tag = 0x18\n\tTagVariant                Tag = 0x19\n\tTagCommonDwarfBlock       Tag = 0x1A\n\tTagCommonInclusion        Tag = 0x1B\n\tTagInheritance            Tag = 0x1C\n\tTagInlinedSubroutine      Tag = 0x1D\n\tTagModule                 Tag = 0x1E\n\tTagPtrToMemberType        Tag = 0x1F\n\tTagSetType                Tag = 0x20\n\tTagSubrangeType           Tag = 0x21\n\tTagWithStmt               Tag = 0x22\n\tTagAccessDeclaration      Tag = 0x23\n\tTagBaseType               Tag = 0x24\n\tTagCatchDwarfBlock        Tag = 0x25\n\tTagConstType              Tag = 0x26\n\tTagConstant               Tag = 0x27\n\tTagEnumerator             Tag = 0x28\n\tTagFileType               Tag = 0x29\n\tTagFriend                 Tag = 0x2A\n\tTagNamelist               Tag = 0x2B\n\tTagNamelistItem           Tag = 0x2C\n\tTagPackedType             Tag = 0x2D\n\tTagSubprogram             Tag = 0x2E\n\tTagTemplateTypeParameter  Tag = 0x2F\n\tTagTemplateValueParameter Tag = 0x30\n\tTagThrownType             Tag = 0x31\n\tTagTryDwarfBlock          Tag = 0x32\n\tTagVariantPart            Tag = 0x33\n\tTagVariable               Tag = 0x34\n\tTagVolatileType           Tag = 0x35\n\t// The following are new in DWARF 3.\n\tTagDwarfProcedure  Tag = 0x36\n\tTagRestrictType    Tag = 0x37\n\tTagInterfaceType   Tag = 0x38\n\tTagNamespace       Tag = 0x39\n\tTagImportedModule  Tag = 0x3A\n\tTagUnspecifiedType Tag = 0x3B\n\tTagPartialUnit     Tag = 0x3C\n\tTagImportedUnit    Tag = 0x3D\n\tTagMutableType     Tag = 0x3E // Later removed from DWARF.\n\tTagCondition       Tag = 0x3F\n\tTagSharedType      Tag = 0x40\n\t// The following are new in DWARF 4.\n\tTagTypeUnit            Tag = 0x41\n\tTagRvalueReferenceType Tag = 0x42\n\tTagTemplateAlias       Tag = 0x43\n\t// The following are new in DWARF 5.\n\tTagCoarrayType       Tag = 0x44\n\tTagGenericSubrange   Tag = 0x45\n\tTagDynamicType       Tag = 0x46\n\tTagAtomicType        Tag = 0x47\n\tTagCallSite          Tag = 0x48\n\tTagCallSiteParameter Tag = 0x49\n\tTagSkeletonUnit      Tag = 0x4A\n\tTagImmutableType     Tag = 0x4B\n)\nfunc (t Tag) GoString() string\n\nfunc (i Tag) String() string\n\ntype Type interface {\n\tCommon() *CommonType\n\tString() string\n\tSize() int64\n}\n    A Type conventionally represents a pointer to any of the specific Type\n    structures (CharType, StructType, etc.).\n\ntype TypedefType struct {\n\tCommonType\n\tType Type\n}\n    A TypedefType represents a named type.\n\nfunc (t *TypedefType) Size() int64\n\nfunc (t *TypedefType) String() string\n\ntype UcharType struct {\n\tBasicType\n}\n    A UcharType represents an unsigned character type.\n\ntype UintType struct {\n\tBasicType\n}\n    A UintType represents an unsigned integer type.\n\ntype UnspecifiedType struct {\n\tBasicType\n}\n    An UnspecifiedType represents an implicit, unknown, ambiguous or nonexistent\n    type.\n\ntype UnsupportedType struct {\n\tCommonType\n\tTag Tag\n}\n    An UnsupportedType is a placeholder returned in situations where we\n    encounter a type that isn't supported.\n\nfunc (t *UnsupportedType) String() string\n\ntype VoidType struct {\n\tCommonType\n}\n    A VoidType represents the C void type.\n\nfunc (t *VoidType) String() string\n\n"}, {"path": "stdlib/encoding.md", "category": "stdlib", "name": "stdlib/encoding", "content": "package encoding // import \"encoding\"\n\nPackage encoding defines interfaces shared by other packages that convert\ndata to and from byte-level and textual representations. Packages that check\nfor these interfaces include encoding/gob, encoding/json, and encoding/xml.\nAs a result, implementing an interface once can make a type useful in multiple\nencodings. Standard types that implement these interfaces include time.Time and\nnet.IP. The interfaces come in pairs that produce and consume encoded data.\n\nAdding encoding/decoding methods to existing types may constitute a breaking\nchange, as they can be used for serialization in communicating with programs\nwritten with different library versions. The policy for packages maintained\nby the Go project is to only allow the addition of marshaling functions if no\nexisting, reasonable marshaling exists.\n\nTYPES\n\ntype BinaryAppender interface {\n\t// AppendBinary appends the binary representation of itself to the end of b\n\t// (allocating a larger slice if necessary) and returns the updated slice.\n\t//\n\t// Implementations must not retain b, nor mutate any bytes within b[:len(b)].\n\tAppendBinary(b []byte) ([]byte, error)\n}\n    BinaryAppender is the interface implemented by an object that can append the\n    binary representation of itself. If a type implements both BinaryAppender\n    and BinaryMarshaler, then v.MarshalBinary() must be semantically identical\n    to v.AppendBinary(nil).\n\ntype BinaryMarshaler interface {\n\tMarshalBinary() (data []byte, err error)\n}\n    BinaryMarshaler is the interface implemented by an object that can marshal\n    itself into a binary form.\n\n    MarshalBinary encodes the receiver into a binary form and returns the\n    result.\n\ntype BinaryUnmarshaler interface {\n\tUnmarshalBinary(data []byte) error\n}\n    BinaryUnmarshaler is the interface implemented by an object that can\n    unmarshal a binary representation of itself.\n\n    UnmarshalBinary must be able to decode the form generated by MarshalBinary.\n    UnmarshalBinary must copy the data if it wishes to retain the data after\n    returning.\n\ntype TextAppender interface {\n\t// AppendText appends the textual representation of itself to the end of b\n\t// (allocating a larger slice if necessary) and returns the updated slice.\n\t//\n\t// Implementations must not retain b, nor mutate any bytes within b[:len(b)].\n\tAppendText(b []byte) ([]byte, error)\n}\n    TextAppender is the interface implemented by an object that can append the\n    textual representation of itself. If a type implements both TextAppender\n    and TextMarshaler, then v.MarshalText() must be semantically identical to\n    v.AppendText(nil).\n\ntype TextMarshaler interface {\n\tMarshalText() (text []byte, err error)\n}\n    TextMarshaler is the interface implemented by an object that can marshal\n    itself into a textual form.\n\n    MarshalText encodes the receiver into UTF-8-encoded text and returns the\n    result.\n\ntype TextUnmarshaler interface {\n\tUnmarshalText(text []byte) error\n}\n    TextUnmarshaler is the interface implemented by an object that can unmarshal\n    a textual representation of itself.\n\n    UnmarshalText must be able to decode the form generated by MarshalText.\n    UnmarshalText must copy the text if it wishes to retain the text after\n    returning.\n\n"}, {"path": "stdlib/runtime-coverage.md", "category": "stdlib", "name": "stdlib/runtime-coverage", "content": "package coverage // import \"runtime/coverage\"\n\nPackage coverage contains APIs for writing coverage profile data at runtime from\nlong-running and/or server programs that do not terminate via os.Exit.\n\nFUNCTIONS\n\nfunc ClearCounters() error\n    ClearCounters clears/resets all coverage counter variables in the currently\n    running program. It returns an error if the program in question was not\n    built with the \"-cover\" flag. Clearing of coverage counters is also not\n    supported for programs not using atomic counter mode (see more detailed\n    comments below for the rationale here).\n\nfunc WriteCounters(w io.Writer) error\n    WriteCounters writes coverage counter-data content for the currently running\n    program to the writer 'w'. An error will be returned if the operation can't\n    be completed successfully (for example, if the currently running program was\n    not built with \"-cover\", or if a write fails). The counter data written will\n    be a snapshot taken at the point of the invocation.\n\nfunc WriteCountersDir(dir string) error\n    WriteCountersDir writes a coverage counter-data file for the currently\n    running program to the directory specified in 'dir'. An error will be\n    returned if the operation can't be completed successfully (for example,\n    if the currently running program was not built with \"-cover\", or if the\n    directory does not exist). The counter data written will be a snapshot taken\n    at the point of the call.\n\nfunc WriteMeta(w io.Writer) error\n    WriteMeta writes the meta-data content (the payload that would normally\n    be emitted to a meta-data file) for the currently running program to the\n    writer 'w'. An error will be returned if the operation can't be completed\n    successfully (for example, if the currently running program was not built\n    with \"-cover\", or if a write fails).\n\nfunc WriteMetaDir(dir string) error\n    WriteMetaDir writes a coverage meta-data file for the currently running\n    program to the directory specified in 'dir'. An error will be returned if\n    the operation can't be completed successfully (for example, if the currently\n    running program was not built with \"-cover\", or if the directory does not\n    exist).\n\n"}, {"path": "stdlib/crypto-pbkdf2.md", "category": "stdlib", "name": "stdlib/crypto-pbkdf2", "content": "package pbkdf2 // import \"crypto/pbkdf2\"\n\nPackage pbkdf2 implements the key derivation function PBKDF2 as defined in RFC\n8018 (PKCS #5 v2.1).\n\nA key derivation function is useful when encrypting data based on a password\nor any other not-fully-random data. It uses a pseudorandom function to derive a\nsecure encryption key based on the password.\n\nFUNCTIONS\n\nfunc Key[Hash hash.Hash](h func() Hash, password string, salt []byte, iter, keyLength int) ([]byte, error)\n    Key derives a key from the password, salt and iteration count, returning a\n    []byte of length keyLength that can be used as cryptographic key. The key is\n    derived based on the method described as PBKDF2 with the HMAC variant using\n    the supplied hash function.\n\n    For example, to use a HMAC-SHA-1 based PBKDF2 key derivation function, you\n    can get a derived key for e.g. AES-256 (which needs a 32-byte key) by doing:\n\n        dk := pbkdf2.Key(sha1.New, \"some password\", salt, 4096, 32)\n\n    Remember to get a good random salt. At least 8 bytes is recommended by the\n    RFC.\n\n    Using a higher iteration count will increase the cost of an exhaustive\n    search but will also make derivation proportionally slower.\n\n    keyLength must be a positive integer between 1 and (2^32 - 1) * h.Size().\n    Setting keyLength to a value outside of this range will result in an error.\n\n"}, {"path": "stdlib/net-internal-socktest.md", "category": "stdlib", "name": "stdlib/net-internal-socktest", "content": "package socktest // import \"net/internal/socktest\"\n\nPackage socktest provides utilities for socket testing.\n\nTYPES\n\ntype AfterFilter func(*Status) error\n    An AfterFilter represents a socket system call filter after an execution of\n    a system call.\n\n    It will only be executed after a system call for a socket that has an entry\n    in internal table. If the filter returns a non-nil error, the system call\n    function returns the non-nil error.\n\ntype Cookie uint64\n    A Cookie represents a 3-tuple of a socket; address family, socket type and\n    protocol number.\n\nfunc (c Cookie) Family() int\n    Family returns an address family.\n\nfunc (c Cookie) Protocol() int\n    Protocol returns a protocol number.\n\nfunc (c Cookie) Type() int\n    Type returns a socket type.\n\ntype Filter func(*Status) (AfterFilter, error)\n    A Filter represents a socket system call filter.\n\n    It will only be executed before a system call for a socket that has an entry\n    in internal table. If the filter returns a non-nil error, the execution\n    of system call will be canceled and the system call function returns the\n    non-nil error. It can return a non-nil AfterFilter for filtering after the\n    execution of the system call.\n\ntype FilterType int\n    A FilterType represents a filter type.\n\nconst (\n\tFilterSocket        FilterType = iota // for Socket\n\tFilterConnect                         // for Connect or ConnectEx\n\tFilterListen                          // for Listen\n\tFilterAccept                          // for Accept, Accept4 or AcceptEx\n\tFilterGetsockoptInt                   // for GetsockoptInt\n\tFilterClose                           // for Close or Closesocket\n)\ntype Sockets map[int]Status\n    Sockets maps a socket descriptor to the status of socket.\n\ntype Stat struct {\n\tFamily   int // address family\n\tType     int // socket type\n\tProtocol int // protocol number\n\n\tOpened    uint64 // number of sockets opened\n\tConnected uint64 // number of sockets connected\n\tListened  uint64 // number of sockets listened\n\tAccepted  uint64 // number of sockets accepted\n\tClosed    uint64 // number of sockets closed\n\n\tOpenFailed    uint64 // number of sockets open failed\n\tConnectFailed uint64 // number of sockets connect failed\n\tListenFailed  uint64 // number of sockets listen failed\n\tAcceptFailed  uint64 // number of sockets accept failed\n\tCloseFailed   uint64 // number of sockets close failed\n}\n    A Stat represents a per-cookie socket statistics.\n\nfunc (st Stat) String() string\n\ntype Status struct {\n\tCookie    Cookie\n\tErr       error // error status of socket system call\n\tSocketErr error // error status of socket by SO_ERROR\n}\n    A Status represents the status of a socket.\n\nfunc (so Status) String() string\n\ntype Switch struct {\n\t// Has unexported fields.\n}\n    A Switch represents a callpath point switch for socket system calls.\n\nfunc (sw *Switch) Accept(s int) (ns int, sa syscall.Sockaddr, err error)\n    Accept wraps syscall.Accept.\n\nfunc (sw *Switch) Close(s int) (err error)\n    Close wraps syscall.Close.\n\nfunc (sw *Switch) Connect(s int, sa syscall.Sockaddr) (err error)\n    Connect wraps syscall.Connect.\n\nfunc (sw *Switch) GetsockoptInt(s, level, opt int) (soerr int, err error)\n    GetsockoptInt wraps syscall.GetsockoptInt.\n\nfunc (sw *Switch) Listen(s, backlog int) (err error)\n    Listen wraps syscall.Listen.\n\nfunc (sw *Switch) Set(t FilterType, f Filter)\n    Set deploys the socket system call filter f for the filter type t.\n\nfunc (sw *Switch) Socket(family, sotype, proto int) (s int, err error)\n    Socket wraps syscall.Socket.\n\nfunc (sw *Switch) Sockets() Sockets\n    Sockets returns mappings of socket descriptor to socket status.\n\nfunc (sw *Switch) Stats() []Stat\n    Stats returns a list of per-cookie socket statistics.\n\n"}, {"path": "stdlib/internal-runtime-sys.md", "category": "stdlib", "name": "stdlib/internal-runtime-sys", "content": "package sys // import \"internal/runtime/sys\"\n\npackage sys contains system- and configuration- and architecture-specific\nconstants used by the runtime.\n\nCONSTANTS\n\nconst DefaultPhysPageSize = goarch.DefaultPhysPageSize\n    DefaultPhysPageSize is the default physical page size.\n\nconst Int64Align = goarch.PtrSize\n    Int64Align is the required alignment for a 64-bit integer (4 on 32-bit\n    systems, 8 on 64-bit).\n\nconst MinFrameSize = goarch.MinFrameSize\n    MinFrameSize is the size of the system-reserved words at the bottom of\n    a frame (just above the architectural stack pointer). It is zero on x86\n    and PtrSize on most non-x86 (LR-based) systems. On PowerPC it is larger,\n    to cover three more reserved words: the compiler word, the link editor word,\n    and the TOC save word.\n\nconst PCQuantum = goarch.PCQuantum\n    PCQuantum is the minimal unit for a program counter (1 on x86, 4 on most\n    other systems). The various PC tables record PC deltas pre-divided by\n    PCQuantum.\n\nconst StackAlign = goarch.StackAlign\n    StackAlign is the required alignment of the SP register. The stack must be\n    at least word aligned, but some architectures require more.\n\nconst StackGuardMultiplier = 1 + goos.IsAix + goos.IsOpenbsd + isRace\n    AIX and OpenBSD require a larger stack for syscalls. The race build also\n    needs more stack. See issue 54291. This arithmetic must match that in\n    cmd/internal/objabi/stack.go:stackGuardMultiplier.\n\n\nVARIABLES\n\nvar DITSupported = cpu.ARM64.HasDIT\n\nFUNCTIONS\n\nfunc Bswap32(x uint32) uint32\n    Bswap32 returns its input with byte order reversed 0x01020304 -> 0x04030201\n\nfunc Bswap64(x uint64) uint64\n    Bswap64 returns its input with byte order reversed 0x0102030405060708 ->\n    0x0807060504030201\n\nfunc DITEnabled() bool\nfunc DisableDIT()\nfunc EnableDIT() bool\nfunc GetCallerPC() uintptr\nfunc GetCallerSP() uintptr\nfunc GetClosurePtr() uintptr\n    GetClosurePtr returns the pointer to the current closure. GetClosurePtr\n    can only be used in an assignment statement at the entry of a function.\n    Moreover, go:nosplit directive must be specified at the declaration of\n    caller function, so that the function prolog does not clobber the closure\n    register. for example:\n\n        //go:nosplit\n        func f(arg1, arg2, arg3 int) {\n        \tdx := GetClosurePtr()\n        }\n\n    The compiler rewrites calls to this function into instructions that fetch\n    the pointer from a well-known register (DX on x86 architecture, etc.)\n    directly.\n\n    WARNING: PGO-based devirtualization cannot detect that\n    caller of GetClosurePtr requires closure context,\n    and thus must maintain a list of these functions, which is in\n    cmd/compile/internal/devirtualize/pgo.maybeDevirtualizeFunctionCall.\n\nfunc LeadingZeros64(x uint64) int\n    LeadingZeros64 returns the number of leading zero bits in x; the result is\n    64 for x == 0.\n\nfunc LeadingZeros8(x uint8) int\n    LeadingZeros8 returns the number of leading zero bits in x; the result is 8\n    for x == 0.\n\nfunc Len64(x uint64) (n int)\n    Len64 returns the minimum number of bits required to represent x; the result\n    is 0 for x == 0.\n\n    nosplit because this is used in src/runtime/histogram.go, which make run in\n    sensitive contexts.\n\nfunc Len8(x uint8) int\n    Len8 returns the minimum number of bits required to represent x; the result\n    is 0 for x == 0.\n\nfunc OnesCount64(x uint64) int\n    OnesCount64 returns the number of one bits (\"population count\") in x.\n\nfunc Prefetch(addr uintptr)\n    Prefetch prefetches data from memory addr to cache\n\n    AMD64: Produce PREFETCHT0 instruction\n\n    ARM64: Produce PRFM instruction with PLDL1KEEP option\n\nfunc PrefetchStreamed(addr uintptr)\n    PrefetchStreamed prefetches data from memory addr, with a hint that this\n    data is being streamed. That is, it is likely to be accessed very soon,\n    but only once. If possible, this will avoid polluting the cache.\n\n    AMD64: Produce PREFETCHNTA instruction\n\n    ARM64: Produce PRFM instruction with PLDL1STRM option\n\nfunc TrailingZeros32(x uint32) int\n    TrailingZeros32 returns the number of trailing zero bits in x; the result is\n    32 for x == 0.\n\nfunc TrailingZeros64(x uint64) int\n    TrailingZeros64 returns the number of trailing zero bits in x; the result is\n    64 for x == 0.\n\nfunc TrailingZeros8(x uint8) int\n    TrailingZeros8 returns the number of trailing zero bits in x; the result is\n    8 for x == 0.\n\n\nTYPES\n\ntype NotInHeap struct {\n\t// Has unexported fields.\n}\n    NotInHeap is a type must never be allocated from the GC'd heap or on the\n    stack, and is called not-in-heap.\n\n    Other types can embed NotInHeap to make it not-in-heap. Specifically,\n    pointers to these types must always fail the `runtime.inheap` check.\n    The type may be used for global variables, or for objects in unmanaged\n    memory (e.g., allocated with `sysAlloc`, `persistentalloc`, `fixalloc`,\n    or from a manually-managed span).\n\n    Specifically:\n\n    1. `new(T)`, `make([]T)`, `append([]T, ...)` and implicit heap allocation of\n    T are disallowed. (Though implicit allocations are disallowed in the runtime\n    anyway.)\n\n    2. A pointer to a regular type (other than `unsafe.Pointer`) cannot be\n    converted to a pointer to a not-in-heap type, even if they have the same\n    underlying type.\n\n    3. Any type that containing a not-in-heap type is itself considered as\n    not-in-heap.\n\n    - Structs and arrays are not-in-heap if their elements are not-in-heap.\n    - Maps and channels contains no-in-heap types are disallowed.\n\n    4. Write barriers on pointers to not-in-heap types can be omitted.\n\n    The last point is the real benefit of NotInHeap. The runtime uses it for\n    low-level internal structures to avoid memory barriers in the scheduler\n    and the memory allocator where they are illegal or simply inefficient.\n    This mechanism is reasonably safe and does not compromise the readability of\n    the runtime.\n\n"}, {"path": "stdlib/internal-syscall-unix.md", "category": "stdlib", "name": "stdlib/internal-syscall-unix", "content": "package unix // import \"internal/syscall/unix\"\n\n\nCONSTANTS\n\nconst (\n\tAT_EACCESS          = 0x10\n\tAT_FDCWD            = -0x2\n\tAT_REMOVEDIR        = 0x80\n\tAT_SYMLINK_NOFOLLOW = 0x0020\n\n\tUTIME_OMIT = -0x2\n)\nconst (\n\tR_OK = 0x4\n\tW_OK = 0x2\n\tX_OK = 0x1\n\n\t// NoFollowErrno is the error returned from open/openat called with\n\t// O_NOFOLLOW flag, when the trailing component (basename) of the path\n\t// is a symbolic link.\n\tNoFollowErrno = noFollowErrno\n)\nconst (\n\tAI_CANONNAME = 0x2\n\tAI_ALL       = 0x100\n\tAI_V4MAPPED  = 0x800\n\tAI_MASK      = 0x1407\n\n\tEAI_ADDRFAMILY = 1\n\tEAI_AGAIN      = 2\n\tEAI_NODATA     = 7\n\tEAI_NONAME     = 8\n\tEAI_SERVICE    = 9\n\tEAI_SYSTEM     = 11\n\tEAI_OVERFLOW   = 14\n\n\tNI_NAMEREQD = 4\n)\nconst (\n\tSC_GETGR_R_SIZE_MAX = 0x46\n\tSC_GETPW_R_SIZE_MAX = 0x47\n)\n\nFUNCTIONS\n\nfunc ARC4Random(p []byte)\n    ARC4Random calls the macOS arc4random_buf(3) function.\n\nfunc Eaccess(path string, mode uint32) error\nfunc Fchmodat(dirfd int, path string, mode uint32, flags int) error\nfunc Fchownat(dirfd int, path string, uid, gid int, flags int) error\nfunc Fcntl(fd int, cmd int, arg int) (int, error)\nfunc Freeaddrinfo(ai *Addrinfo)\nfunc Fstatat(dirfd int, path string, stat *syscall.Stat_t, flags int) error\nfunc GaiStrerror(ecode int) string\nfunc Getaddrinfo(hostname, servname *byte, hints *Addrinfo, res **Addrinfo) (int, error)\nfunc Getgrgid(gid uint32, grp *Group, buf *byte, size uintptr, result **Group) syscall.Errno\nfunc Getgrnam(name *byte, grp *Group, buf *byte, size uintptr, result **Group) syscall.Errno\nfunc Getgrouplist(name *byte, gid uint32, gids *uint32, n *int32) error\nfunc Getnameinfo(sa *syscall.RawSockaddr, salen int, host *byte, hostlen int, serv *byte, servlen int, flags int) (int, error)\nfunc Getpwnam(name *byte, pwd *Passwd, buf *byte, size uintptr, result **Passwd) syscall.Errno\nfunc Getpwuid(uid uint32, pwd *Passwd, buf *byte, size uintptr, result **Passwd) syscall.Errno\nfunc GoString(p *byte) string\nfunc Grantpt(fd int) error\nfunc HasNonblockFlag(flag int) bool\nfunc IsNonblock(fd int) (nonblocking bool, err error)\nfunc KernelVersion() (major int, minor int)\nfunc Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flag int) error\nfunc Mkdirat(dirfd int, path string, mode uint32) error\nfunc Openat(dirfd int, path string, flags int, perm uint32) (int, error)\nfunc PosixOpenpt(flag int) (fd int, err error)\nfunc Ptsname(fd int) (string, error)\nfunc Readlinkat(dirfd int, path string, buf []byte) (int, error)\nfunc RecvfromInet4(fd int, p []byte, flags int, from *syscall.SockaddrInet4) (int, error)\nfunc RecvfromInet6(fd int, p []byte, flags int, from *syscall.SockaddrInet6) (n int, err error)\nfunc RecvmsgInet4(fd int, p, oob []byte, flags int, from *syscall.SockaddrInet4) (n, oobn int, recvflags int, err error)\nfunc RecvmsgInet6(fd int, p, oob []byte, flags int, from *syscall.SockaddrInet6) (n, oobn int, recvflags int, err error)\nfunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) error\nfunc ResNclose(state *ResState)\nfunc ResNinit(state *ResState) error\nfunc ResNsearch(state *ResState, dname *byte, class, typ int, ans *byte, anslen int) (int, error)\nfunc SendmsgNInet4(fd int, p, oob []byte, to *syscall.SockaddrInet4, flags int) (n int, err error)\nfunc SendmsgNInet6(fd int, p, oob []byte, to *syscall.SockaddrInet6, flags int) (n int, err error)\nfunc SendtoInet4(fd int, p []byte, flags int, to *syscall.SockaddrInet4) (err error)\nfunc SendtoInet6(fd int, p []byte, flags int, to *syscall.SockaddrInet6) (err error)\nfunc Symlinkat(oldpath string, newdirfd int, newpath string) error\nfunc Sysconf(key int32) int64\nfunc Tcsetpgrp(fd int, pgid int32) (err error)\nfunc Unlinkat(dirfd int, path string, flags int) error\nfunc Unlockpt(fd int) error\nfunc Utimensat(dirfd int, path string, times *[2]syscall.Timespec, flag int) error\n\nTYPES\n\ntype Addrinfo struct {\n\tFlags     int32\n\tFamily    int32\n\tSocktype  int32\n\tProtocol  int32\n\tAddrlen   uint32\n\tCanonname *byte\n\tAddr      *syscall.RawSockaddr\n\tNext      *Addrinfo\n}\n\ntype Group struct {\n\tName   *byte\n\tPasswd *byte\n\tGid    uint32 // gid_t\n\tMem    **byte\n}\n\ntype Passwd struct {\n\tName   *byte\n\tPasswd *byte\n\tUid    uint32 // uid_t\n\tGid    uint32 // gid_t\n\tChange int64  // time_t\n\tClass  *byte\n\tGecos  *byte\n\tDir    *byte\n\tShell  *byte\n\tExpire int64 // time_t\n}\n\ntype ResState struct {\n\t// Has unexported fields.\n}\n\n"}, {"path": "stdlib/internal-syslist.md", "category": "stdlib", "name": "stdlib/internal-syslist", "content": "package syslist // import \"internal/syslist\"\n\n\nVARIABLES\n\nvar KnownArch = map[string]bool{\n\t\"386\":         true,\n\t\"amd64\":       true,\n\t\"amd64p32\":    true,\n\t\"arm\":         true,\n\t\"armbe\":       true,\n\t\"arm64\":       true,\n\t\"arm64be\":     true,\n\t\"loong64\":     true,\n\t\"mips\":        true,\n\t\"mipsle\":      true,\n\t\"mips64\":      true,\n\t\"mips64le\":    true,\n\t\"mips64p32\":   true,\n\t\"mips64p32le\": true,\n\t\"ppc\":         true,\n\t\"ppc64\":       true,\n\t\"ppc64le\":     true,\n\t\"riscv\":       true,\n\t\"riscv64\":     true,\n\t\"s390\":        true,\n\t\"s390x\":       true,\n\t\"sparc\":       true,\n\t\"sparc64\":     true,\n\t\"wasm\":        true,\n}\n    KnownArch is the list of past, present, and future known GOARCH values.\n    Do not remove from this list, as it is used for filename matching.\n\nvar KnownOS = map[string]bool{\n\t\"aix\":       true,\n\t\"android\":   true,\n\t\"darwin\":    true,\n\t\"dragonfly\": true,\n\t\"freebsd\":   true,\n\t\"hurd\":      true,\n\t\"illumos\":   true,\n\t\"ios\":       true,\n\t\"js\":        true,\n\t\"linux\":     true,\n\t\"nacl\":      true,\n\t\"netbsd\":    true,\n\t\"openbsd\":   true,\n\t\"plan9\":     true,\n\t\"solaris\":   true,\n\t\"wasip1\":    true,\n\t\"windows\":   true,\n\t\"zos\":       true,\n}\n    KnownOS is the list of past, present, and future known GOOS values. Do not\n    remove from this list, as it is used for filename matching. If you add an\n    entry to this list, look at UnixOS, below.\n\nvar UnixOS = map[string]bool{\n\t\"aix\":       true,\n\t\"android\":   true,\n\t\"darwin\":    true,\n\t\"dragonfly\": true,\n\t\"freebsd\":   true,\n\t\"hurd\":      true,\n\t\"illumos\":   true,\n\t\"ios\":       true,\n\t\"linux\":     true,\n\t\"netbsd\":    true,\n\t\"openbsd\":   true,\n\t\"solaris\":   true,\n}\n    UnixOS is the set of GOOS values matched by the \"unix\" build tag. This is\n    not used for filename matching. This list also appears in cmd/dist/build.go.\n\n"}, {"path": "stdlib/log-slog-internal-buffer.md", "category": "stdlib", "name": "stdlib/log-slog-internal-buffer", "content": "package buffer // import \"log/slog/internal/buffer\"\n\nPackage buffer provides a pool-allocated byte buffer.\n\nTYPES\n\ntype Buffer []byte\n    Buffer is a byte buffer.\n\n    This implementation is adapted from the unexported type buffer in\n    go/src/fmt/print.go.\n\nfunc New() *Buffer\n\nfunc (b *Buffer) Free()\n\nfunc (b *Buffer) Len() int\n\nfunc (b *Buffer) Reset()\n\nfunc (b *Buffer) SetLen(n int)\n\nfunc (b *Buffer) String() string\n\nfunc (b *Buffer) Write(p []byte) (int, error)\n\nfunc (b *Buffer) WriteByte(c byte) error\n\nfunc (b *Buffer) WriteString(s string) (int, error)\n\n"}, {"path": "stdlib/crypto-cipher.md", "category": "stdlib", "name": "stdlib/crypto-cipher", "content": "package cipher // import \"crypto/cipher\"\n\nPackage cipher implements standard block cipher modes that can\nbe wrapped around low-level block cipher implementations. See\nhttps://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html and NIST Special\nPublication 800-38A.\n\nTYPES\n\ntype AEAD interface {\n\t// NonceSize returns the size of the nonce that must be passed to Seal\n\t// and Open.\n\tNonceSize() int\n\n\t// Overhead returns the maximum difference between the lengths of a\n\t// plaintext and its ciphertext.\n\tOverhead() int\n\n\t// Seal encrypts and authenticates plaintext, authenticates the\n\t// additional data and appends the result to dst, returning the updated\n\t// slice. The nonce must be NonceSize() bytes long and unique for all\n\t// time, for a given key.\n\t//\n\t// To reuse plaintext's storage for the encrypted output, use plaintext[:0]\n\t// as dst. Otherwise, the remaining capacity of dst must not overlap plaintext.\n\t// dst and additionalData may not overlap.\n\tSeal(dst, nonce, plaintext, additionalData []byte) []byte\n\n\t// Open decrypts and authenticates ciphertext, authenticates the\n\t// additional data and, if successful, appends the resulting plaintext\n\t// to dst, returning the updated slice. The nonce must be NonceSize()\n\t// bytes long and both it and the additional data must match the\n\t// value passed to Seal.\n\t//\n\t// To reuse ciphertext's storage for the decrypted output, use ciphertext[:0]\n\t// as dst. Otherwise, the remaining capacity of dst must not overlap ciphertext.\n\t// dst and additionalData may not overlap.\n\t//\n\t// Even if the function fails, the contents of dst, up to its capacity,\n\t// may be overwritten.\n\tOpen(dst, nonce, ciphertext, additionalData []byte) ([]byte, error)\n}\n    AEAD is a cipher mode providing authenticated encryption with\n    associated data. For a description of the methodology, see\n    https://en.wikipedia.org/wiki/Authenticated_encryption.\n\nfunc NewGCM(cipher Block) (AEAD, error)\n    NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter\n    Mode with the standard nonce length.\n\n    In general, the GHASH operation performed by this implementation of GCM is\n    not constant-time. An exception is when the underlying Block was created by\n    aes.NewCipher on systems with hardware support for AES. See the crypto/aes\n    package documentation for details.\n\nfunc NewGCMWithNonceSize(cipher Block, size int) (AEAD, error)\n    NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in\n    Galois Counter Mode, which accepts nonces of the given length. The length\n    must not be zero.\n\n    Only use this function if you require compatibility with an existing\n    cryptosystem that uses non-standard nonce lengths. All other users should\n    use NewGCM, which is faster and more resistant to misuse.\n\nfunc NewGCMWithRandomNonce(cipher Block) (AEAD, error)\n    NewGCMWithRandomNonce returns the given cipher wrapped in Galois Counter\n    Mode, with randomly-generated nonces. The cipher must have been created by\n    crypto/aes.NewCipher.\n\n    It generates a random 96-bit nonce, which is prepended to the ciphertext\n    by Seal, and is extracted from the ciphertext by Open. The NonceSize of the\n    AEAD is zero, while the Overhead is 28 bytes (the combination of nonce size\n    and tag size).\n\n    A given key MUST NOT be used to encrypt more than 2^32 messages, to limit\n    the risk of a random nonce collision to negligible levels.\n\nfunc NewGCMWithTagSize(cipher Block, tagSize int) (AEAD, error)\n    NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois\n    Counter Mode, which generates tags with the given length.\n\n    Tag sizes between 12 and 16 bytes are allowed.\n\n    Only use this function if you require compatibility with an existing\n    cryptosystem that uses non-standard tag lengths. All other users should use\n    NewGCM, which is more resistant to misuse.\n\ntype Block interface {\n\t// BlockSize returns the cipher's block size.\n\tBlockSize() int\n\n\t// Encrypt encrypts the first block in src into dst.\n\t// Dst and src must overlap entirely or not at all.\n\tEncrypt(dst, src []byte)\n\n\t// Decrypt decrypts the first block in src into dst.\n\t// Dst and src must overlap entirely or not at all.\n\tDecrypt(dst, src []byte)\n}\n    A Block represents an implementation of block cipher using a given key.\n    It provides the capability to encrypt or decrypt individual blocks. The mode\n    implementations extend that capability to streams of blocks.\n\ntype BlockMode interface {\n\t// BlockSize returns the mode's block size.\n\tBlockSize() int\n\n\t// CryptBlocks encrypts or decrypts a number of blocks. The length of\n\t// src must be a multiple of the block size. Dst and src must overlap\n\t// entirely or not at all.\n\t//\n\t// If len(dst) < len(src), CryptBlocks should panic. It is acceptable\n\t// to pass a dst bigger than src, and in that case, CryptBlocks will\n\t// only update dst[:len(src)] and will not touch the rest of dst.\n\t//\n\t// Multiple calls to CryptBlocks behave as if the concatenation of\n\t// the src buffers was passed in a single run. That is, BlockMode\n\t// maintains state and does not reset at each CryptBlocks call.\n\tCryptBlocks(dst, src []byte)\n}\n    A BlockMode represents a block cipher running in a block-based mode (CBC,\n    ECB etc).\n\nfunc NewCBCDecrypter(b Block, iv []byte) BlockMode\n    NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\n    mode, using the given Block. The length of iv must be the same as the\n    Block's block size and must match the iv used to encrypt the data.\n\nfunc NewCBCEncrypter(b Block, iv []byte) BlockMode\n    NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining\n    mode, using the given Block. The length of iv must be the same as the\n    Block's block size.\n\ntype Stream interface {\n\t// XORKeyStream XORs each byte in the given slice with a byte from the\n\t// cipher's key stream. Dst and src must overlap entirely or not at all.\n\t//\n\t// If len(dst) < len(src), XORKeyStream should panic. It is acceptable\n\t// to pass a dst bigger than src, and in that case, XORKeyStream will\n\t// only update dst[:len(src)] and will not touch the rest of dst.\n\t//\n\t// Multiple calls to XORKeyStream behave as if the concatenation of\n\t// the src buffers was passed in a single run. That is, Stream\n\t// maintains state and does not reset at each XORKeyStream call.\n\tXORKeyStream(dst, src []byte)\n}\n    A Stream represents a stream cipher.\n\nfunc NewCFBDecrypter(block Block, iv []byte) Stream\n    NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,\n    using the given Block. The iv must be the same length as the Block's block\n    size.\n\n    Deprecated: CFB mode is not authenticated, which generally enables active\n    attacks to manipulate and recover the plaintext. It is recommended that\n    applications use AEAD modes instead. The standard library implementation of\n    CFB is also unoptimized and not validated as part of the FIPS 140-3 module.\n    If an unauthenticated Stream mode is required, use NewCTR instead.\n\nfunc NewCFBEncrypter(block Block, iv []byte) Stream\n    NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode,\n    using the given Block. The iv must be the same length as the Block's block\n    size.\n\n    Deprecated: CFB mode is not authenticated, which generally enables active\n    attacks to manipulate and recover the plaintext. It is recommended that\n    applications use AEAD modes instead. The standard library implementation of\n    CFB is also unoptimized and not validated as part of the FIPS 140-3 module.\n    If an unauthenticated Stream mode is required, use NewCTR instead.\n\nfunc NewCTR(block Block, iv []byte) Stream\n    NewCTR returns a Stream which encrypts/decrypts using the given Block in\n    counter mode. The length of iv must be the same as the Block's block size.\n\nfunc NewOFB(b Block, iv []byte) Stream\n    NewOFB returns a Stream that encrypts or decrypts using the block cipher b\n    in output feedback mode. The initialization vector iv's length must be equal\n    to b's block size.\n\n    Deprecated: OFB mode is not authenticated, which generally enables active\n    attacks to manipulate and recover the plaintext. It is recommended that\n    applications use AEAD modes instead. The standard library implementation of\n    OFB is also unoptimized and not validated as part of the FIPS 140-3 module.\n    If an unauthenticated Stream mode is required, use NewCTR instead.\n\ntype StreamReader struct {\n\tS Stream\n\tR io.Reader\n}\n    StreamReader wraps a Stream into an io.Reader. It calls XORKeyStream to\n    process each slice of data which passes through.\n\nfunc (r StreamReader) Read(dst []byte) (n int, err error)\n\ntype StreamWriter struct {\n\tS   Stream\n\tW   io.Writer\n\tErr error // unused\n}\n    StreamWriter wraps a Stream into an io.Writer. It calls XORKeyStream to\n    process each slice of data which passes through. If any StreamWriter.Write\n    call returns short then the StreamWriter is out of sync and must be\n    discarded. A StreamWriter has no internal buffering; StreamWriter.Close does\n    not need to be called to flush write data.\n\nfunc (w StreamWriter) Close() error\n    Close closes the underlying Writer and returns its Close return value,\n    if the Writer is also an io.Closer. Otherwise it returns nil.\n\nfunc (w StreamWriter) Write(src []byte) (n int, err error)\n\n"}, {"path": "stdlib/hash-fnv.md", "category": "stdlib", "name": "stdlib/hash-fnv", "content": "package fnv // import \"hash/fnv\"\n\nPackage fnv implements FNV-1 and FNV-1a, non-cryptographic hash\nfunctions created by Glenn Fowler, Landon Curt Noll, and Phong Vo. See\nhttps://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function.\n\nAll the hash.Hash implementations returned by this package also implement\nencoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal\nthe internal state of the hash.\n\nFUNCTIONS\n\nfunc New128() hash.Hash\n    New128 returns a new 128-bit FNV-1 hash.Hash. Its Sum method will lay the\n    value out in big-endian byte order.\n\nfunc New128a() hash.Hash\n    New128a returns a new 128-bit FNV-1a hash.Hash. Its Sum method will lay the\n    value out in big-endian byte order.\n\nfunc New32() hash.Hash32\n    New32 returns a new 32-bit FNV-1 hash.Hash. Its Sum method will lay the\n    value out in big-endian byte order.\n\nfunc New32a() hash.Hash32\n    New32a returns a new 32-bit FNV-1a hash.Hash. Its Sum method will lay the\n    value out in big-endian byte order.\n\nfunc New64() hash.Hash64\n    New64 returns a new 64-bit FNV-1 hash.Hash. Its Sum method will lay the\n    value out in big-endian byte order.\n\nfunc New64a() hash.Hash64\n    New64a returns a new 64-bit FNV-1a hash.Hash. Its Sum method will lay the\n    value out in big-endian byte order.\n\n"}, {"path": "stdlib/crypto-internal-fips140-nistec-fiat.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-nistec-fiat", "content": "package fiat // import \"crypto/internal/fips140/nistec/fiat\"\n\n\nTYPES\n\ntype P224Element struct {\n\t// Has unexported fields.\n}\n    P224Element is an integer modulo 2^224 - 2^96 + 1.\n\n    The zero value is a valid zero element.\n\nfunc (e *P224Element) Add(t1, t2 *P224Element) *P224Element\n    Add sets e = t1 + t2, and returns e.\n\nfunc (e *P224Element) Bytes() []byte\n    Bytes returns the 28-byte big-endian encoding of e.\n\nfunc (e *P224Element) Equal(t *P224Element) int\n    Equal returns 1 if e == t, and zero otherwise.\n\nfunc (e *P224Element) Invert(x *P224Element) *P224Element\n    Invert sets e = 1/x, and returns e.\n\n    If x == 0, Invert returns e = 0.\n\nfunc (e *P224Element) IsZero() int\n    IsZero returns 1 if e == 0, and zero otherwise.\n\nfunc (e *P224Element) Mul(t1, t2 *P224Element) *P224Element\n    Mul sets e = t1 * t2, and returns e.\n\nfunc (e *P224Element) One() *P224Element\n    One sets e = 1, and returns e.\n\nfunc (v *P224Element) Select(a, b *P224Element, cond int) *P224Element\n    Select sets v to a if cond == 1, and to b if cond == 0.\n\nfunc (e *P224Element) Set(t *P224Element) *P224Element\n    Set sets e = t, and returns e.\n\nfunc (e *P224Element) SetBytes(v []byte) (*P224Element, error)\n    SetBytes sets e = v, where v is a big-endian 28-byte encoding, and returns\n    e. If v is not 28 bytes or it encodes a value higher than 2^224 - 2^96 + 1,\n    SetBytes returns nil and an error, and e is unchanged.\n\nfunc (e *P224Element) Square(t *P224Element) *P224Element\n    Square sets e = t * t, and returns e.\n\nfunc (e *P224Element) Sub(t1, t2 *P224Element) *P224Element\n    Sub sets e = t1 - t2, and returns e.\n\ntype P256Element struct {\n\t// Has unexported fields.\n}\n    P256Element is an integer modulo 2^256 - 2^224 + 2^192 + 2^96 - 1.\n\n    The zero value is a valid zero element.\n\nfunc (e *P256Element) Add(t1, t2 *P256Element) *P256Element\n    Add sets e = t1 + t2, and returns e.\n\nfunc (e *P256Element) Bytes() []byte\n    Bytes returns the 32-byte big-endian encoding of e.\n\nfunc (e *P256Element) Equal(t *P256Element) int\n    Equal returns 1 if e == t, and zero otherwise.\n\nfunc (e *P256Element) Invert(x *P256Element) *P256Element\n    Invert sets e = 1/x, and returns e.\n\n    If x == 0, Invert returns e = 0.\n\nfunc (e *P256Element) IsZero() int\n    IsZero returns 1 if e == 0, and zero otherwise.\n\nfunc (e *P256Element) Mul(t1, t2 *P256Element) *P256Element\n    Mul sets e = t1 * t2, and returns e.\n\nfunc (e *P256Element) One() *P256Element\n    One sets e = 1, and returns e.\n\nfunc (v *P256Element) Select(a, b *P256Element, cond int) *P256Element\n    Select sets v to a if cond == 1, and to b if cond == 0.\n\nfunc (e *P256Element) Set(t *P256Element) *P256Element\n    Set sets e = t, and returns e.\n\nfunc (e *P256Element) SetBytes(v []byte) (*P256Element, error)\n    SetBytes sets e = v, where v is a big-endian 32-byte encoding, and returns\n    e. If v is not 32 bytes or it encodes a value higher than 2^256 - 2^224 +\n    2^192 + 2^96 - 1, SetBytes returns nil and an error, and e is unchanged.\n\nfunc (e *P256Element) Square(t *P256Element) *P256Element\n    Square sets e = t * t, and returns e.\n\nfunc (e *P256Element) Sub(t1, t2 *P256Element) *P256Element\n    Sub sets e = t1 - t2, and returns e.\n\ntype P384Element struct {\n\t// Has unexported fields.\n}\n    P384Element is an integer modulo 2^384 - 2^128 - 2^96 + 2^32 - 1.\n\n    The zero value is a valid zero element.\n\nfunc (e *P384Element) Add(t1, t2 *P384Element) *P384Element\n    Add sets e = t1 + t2, and returns e.\n\nfunc (e *P384Element) Bytes() []byte\n    Bytes returns the 48-byte big-endian encoding of e.\n\nfunc (e *P384Element) Equal(t *P384Element) int\n    Equal returns 1 if e == t, and zero otherwise.\n\nfunc (e *P384Element) Invert(x *P384Element) *P384Element\n    Invert sets e = 1/x, and returns e.\n\n    If x == 0, Invert returns e = 0.\n\nfunc (e *P384Element) IsZero() int\n    IsZero returns 1 if e == 0, and zero otherwise.\n\nfunc (e *P384Element) Mul(t1, t2 *P384Element) *P384Element\n    Mul sets e = t1 * t2, and returns e.\n\nfunc (e *P384Element) One() *P384Element\n    One sets e = 1, and returns e.\n\nfunc (v *P384Element) Select(a, b *P384Element, cond int) *P384Element\n    Select sets v to a if cond == 1, and to b if cond == 0.\n\nfunc (e *P384Element) Set(t *P384Element) *P384Element\n    Set sets e = t, and returns e.\n\nfunc (e *P384Element) SetBytes(v []byte) (*P384Element, error)\n    SetBytes sets e = v, where v is a big-endian 48-byte encoding, and returns\n    e. If v is not 48 bytes or it encodes a value higher than 2^384 - 2^128 -\n    2^96 + 2^32 - 1, SetBytes returns nil and an error, and e is unchanged.\n\nfunc (e *P384Element) Square(t *P384Element) *P384Element\n    Square sets e = t * t, and returns e.\n\nfunc (e *P384Element) Sub(t1, t2 *P384Element) *P384Element\n    Sub sets e = t1 - t2, and returns e.\n\ntype P521Element struct {\n\t// Has unexported fields.\n}\n    P521Element is an integer modulo 2^521 - 1.\n\n    The zero value is a valid zero element.\n\nfunc (e *P521Element) Add(t1, t2 *P521Element) *P521Element\n    Add sets e = t1 + t2, and returns e.\n\nfunc (e *P521Element) Bytes() []byte\n    Bytes returns the 66-byte big-endian encoding of e.\n\nfunc (e *P521Element) Equal(t *P521Element) int\n    Equal returns 1 if e == t, and zero otherwise.\n\nfunc (e *P521Element) Invert(x *P521Element) *P521Element\n    Invert sets e = 1/x, and returns e.\n\n    If x == 0, Invert returns e = 0.\n\nfunc (e *P521Element) IsZero() int\n    IsZero returns 1 if e == 0, and zero otherwise.\n\nfunc (e *P521Element) Mul(t1, t2 *P521Element) *P521Element\n    Mul sets e = t1 * t2, and returns e.\n\nfunc (e *P521Element) One() *P521Element\n    One sets e = 1, and returns e.\n\nfunc (v *P521Element) Select(a, b *P521Element, cond int) *P521Element\n    Select sets v to a if cond == 1, and to b if cond == 0.\n\nfunc (e *P521Element) Set(t *P521Element) *P521Element\n    Set sets e = t, and returns e.\n\nfunc (e *P521Element) SetBytes(v []byte) (*P521Element, error)\n    SetBytes sets e = v, where v is a big-endian 66-byte encoding, and returns\n    e. If v is not 66 bytes or it encodes a value higher than 2^521 - 1,\n    SetBytes returns nil and an error, and e is unchanged.\n\nfunc (e *P521Element) Square(t *P521Element) *P521Element\n    Square sets e = t * t, and returns e.\n\nfunc (e *P521Element) Sub(t1, t2 *P521Element) *P521Element\n    Sub sets e = t1 - t2, and returns e.\n\n"}, {"path": "stdlib/hash-crc32.md", "category": "stdlib", "name": "stdlib/hash-crc32", "content": "package crc32 // import \"hash/crc32\"\n\nPackage crc32 implements the 32-bit cyclic redundancy check, or CRC-32,\nchecksum. See https://en.wikipedia.org/wiki/Cyclic_redundancy_check for\ninformation.\n\nPolynomials are represented in LSB-first form also known as reversed\nrepresentation.\n\nSee\nhttps://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials\nfor information.\n\nCONSTANTS\n\nconst (\n\t// IEEE is by far and away the most common CRC-32 polynomial.\n\t// Used by ethernet (IEEE 802.3), v.42, fddi, gzip, zip, png, ...\n\tIEEE = 0xedb88320\n\n\t// Castagnoli's polynomial, used in iSCSI.\n\t// Has better error detection characteristics than IEEE.\n\t// https://dx.doi.org/10.1109/26.231911\n\tCastagnoli = 0x82f63b78\n\n\t// Koopman's polynomial.\n\t// Also has better error detection characteristics than IEEE.\n\t// https://dx.doi.org/10.1109/DSN.2002.1028931\n\tKoopman = 0xeb31d82e\n)\n    Predefined polynomials.\n\nconst Size = 4\n    The size of a CRC-32 checksum in bytes.\n\n\nVARIABLES\n\nvar IEEETable = simpleMakeTable(IEEE)\n    IEEETable is the table for the IEEE polynomial.\n\n\nFUNCTIONS\n\nfunc Checksum(data []byte, tab *Table) uint32\n    Checksum returns the CRC-32 checksum of data using the polynomial\n    represented by the Table.\n\nfunc ChecksumIEEE(data []byte) uint32\n    ChecksumIEEE returns the CRC-32 checksum of data using the IEEE polynomial.\n\nfunc New(tab *Table) hash.Hash32\n    New creates a new hash.Hash32 computing the CRC-32 checksum using the\n    polynomial represented by the Table. Its Sum method will lay the value\n    out in big-endian byte order. The returned Hash32 also implements\n    encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and\n    unmarshal the internal state of the hash.\n\nfunc NewIEEE() hash.Hash32\n    NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using the\n    IEEE polynomial. Its Sum method will lay the value out in big-endian byte\n    order. The returned Hash32 also implements encoding.BinaryMarshaler and\n    encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of\n    the hash.\n\nfunc Update(crc uint32, tab *Table, p []byte) uint32\n    Update returns the result of adding the bytes in p to the crc.\n\n\nTYPES\n\ntype Table [256]uint32\n    Table is a 256-word table representing the polynomial for efficient\n    processing.\n\nfunc MakeTable(poly uint32) *Table\n    MakeTable returns a Table constructed from the specified polynomial.\n    The contents of this Table must not be modified.\n\n"}, {"path": "stdlib/image-internal-imageutil.md", "category": "stdlib", "name": "stdlib/image-internal-imageutil", "content": "package imageutil // import \"image/internal/imageutil\"\n\nPackage imageutil contains code shared by image-related packages.\n\nFUNCTIONS\n\nfunc DrawYCbCr(dst *image.RGBA, r image.Rectangle, src *image.YCbCr, sp image.Point) (ok bool)\n    DrawYCbCr draws the YCbCr source image on the RGBA destination image\n    with r.Min in dst aligned with sp in src. It reports whether the draw was\n    successful. If it returns false, no dst pixels were changed.\n\n    This function assumes that r is entirely within dst's bounds and the\n    translation of r from dst coordinate space to src coordinate space is\n    entirely within src's bounds.\n\n"}, {"path": "stdlib/internal-synctest.md", "category": "stdlib", "name": "stdlib/internal-synctest", "content": "package synctest // import \"internal/synctest\"\n\nPackage synctest provides support for testing concurrent code.\n\nSee the testing/synctest package for function documentation.\n\nCONSTANTS\n\nconst (\n\tUnbubbled     = Association(iota) // not associated with any bubble\n\tCurrentBubble                     // associated with the current bubble\n\tOtherBubble                       // associated with a different bubble\n)\n\nFUNCTIONS\n\nfunc Disassociate[T any](p *T)\n    Disassociate disassociates p from any bubble.\n\nfunc IsAssociated[T any](p *T) bool\n    IsAssociated reports whether p is associated with the current bubble.\n\nfunc IsInBubble() bool\n    IsInBubble reports whether the current goroutine is in a bubble.\n\nfunc Run(f func())\nfunc Wait()\n\nTYPES\n\ntype Association int\n    Association is the state of a pointer's bubble association.\n\nfunc Associate[T any](p *T) Association\n    Associate attempts to associate p with the current bubble. It returns the\n    new association status of p.\n\ntype Bubble struct {\n\t// Has unexported fields.\n}\n    A Bubble is a synctest bubble.\n\n    Not a public API. Used by syscall/js to propagate bubble membership through\n    syscalls.\n\nfunc Acquire() *Bubble\n    Acquire returns a reference to the current goroutine's bubble. The bubble\n    will not become idle until Release is called.\n\nfunc (b *Bubble) Release()\n    Release releases the reference to the bubble, allowing it to become idle\n    again.\n\nfunc (b *Bubble) Run(f func())\n    Run executes f in the bubble. The current goroutine must not be part of a\n    bubble.\n\n"}, {"path": "stdlib/internal-poll.md", "category": "stdlib", "name": "stdlib/internal-poll", "content": "package poll // import \"internal/poll\"\n\nPackage poll supports non-blocking I/O on file descriptors with polling.\nThis supports I/O operations that block only a goroutine, not a thread. This\nis used by the net and os packages. It uses a poller built into the runtime,\nwith support from the runtime scheduler.\n\nVARIABLES\n\nvar AcceptFunc func(int) (int, syscall.Sockaddr, error) = syscall.Accept\n    AcceptFunc is used to hook the accept call.\n\nvar CloseFunc func(int) error = syscall.Close\n    CloseFunc is used to hook the close call.\n\nvar ErrDeadlineExceeded error = &DeadlineExceededError{}\n    ErrDeadlineExceeded is returned for an expired deadline. This is exported by\n    the os package as os.ErrDeadlineExceeded.\n\nvar ErrFileClosing = errors.New(\"use of closed file\")\n    ErrFileClosing is returned when a file descriptor is used after it has been\n    closed.\n\nvar ErrNetClosing = errNetClosing{}\n    ErrNetClosing is returned when a network descriptor is used after it has\n    been closed.\n\nvar ErrNoDeadline = errors.New(\"file type does not support deadline\")\n    ErrNoDeadline is returned when a request is made to set a deadline on a file\n    type that does not use the poller.\n\nvar ErrNotPollable = errors.New(\"not pollable\")\n    ErrNotPollable is returned when the file or socket is not suitable for event\n    notification.\n\nvar TestHookDidSendFile = func(dstFD *FD, src uintptr, written int64, err error, handled bool) {}\nvar TestHookDidWritev = func(wrote int) {}\n    TestHookDidWritev is a hook for testing writev.\n\n\nFUNCTIONS\n\nfunc DupCloseOnExec(fd int) (int, string, error)\n    DupCloseOnExec dups fd and marks it close-on-exec.\n\nfunc IsPollDescriptor(fd uintptr) bool\n    IsPollDescriptor reports whether fd is the descriptor being used by the\n    poller. This is only used for testing.\n\n    IsPollDescriptor should be an internal detail, but widely used packages\n    access it using linkname. Notable members of the hall of shame include:\n      - github.com/opencontainers/runc\n\n    Do not remove or change the type signature. See go.dev/issue/67401.\n\nfunc SendFile(dstFD *FD, src uintptr, size int64) (n int64, err error, handled bool)\n    SendFile wraps the sendfile system call.\n\n    It copies data from src (a file descriptor) to dstFD, starting at the\n    current position of src. It updates the current position of src to after the\n    copied data.\n\n    If size is zero, it copies the rest of src. Otherwise, it copies up to size\n    bytes.\n\n    The handled return parameter indicates whether SendFile was able to handle\n    some or all of the operation. If handled is false, sendfile was unable to\n    perform the copy, has not modified the source or destination, and the caller\n    should perform the copy using a fallback implementation.\n\n\nTYPES\n\ntype DeadlineExceededError struct{}\n    DeadlineExceededError is returned for an expired deadline.\n\nfunc (e *DeadlineExceededError) Error() string\n    Implement the net.Error interface. The string is \"i/o timeout\" because that\n    is what was returned by earlier Go versions. Changing it may break programs\n    that match on error strings.\n\nfunc (e *DeadlineExceededError) Temporary() bool\n\nfunc (e *DeadlineExceededError) Timeout() bool\n\ntype FD struct {\n\n\t// System file descriptor. Immutable until Close.\n\tSysfd int\n\n\t// Platform dependent state of the file descriptor.\n\tSysFile\n\n\t// Whether this is a streaming descriptor, as opposed to a\n\t// packet-based descriptor like a UDP socket. Immutable.\n\tIsStream bool\n\n\t// Whether a zero byte read indicates EOF. This is false for a\n\t// message based socket connection.\n\tZeroReadIsEOF bool\n\n\t// Has unexported fields.\n}\n    FD is a file descriptor. The net and os packages use this type as a field of\n    a larger type representing a network connection or OS file.\n\nfunc (fd *FD) Accept() (int, syscall.Sockaddr, string, error)\n    Accept wraps the accept network call.\n\nfunc (fd *FD) Close() error\n    Close closes the FD. The underlying file descriptor is closed by the destroy\n    method when there are no remaining references.\n\nfunc (fd *FD) Dup() (int, string, error)\n    Dup duplicates the file descriptor.\n\nfunc (fd *FD) Fchdir() error\n    Fchdir wraps syscall.Fchdir.\n\nfunc (fd *FD) Fchmod(mode uint32) error\n    Fchmod wraps syscall.Fchmod.\n\nfunc (fd *FD) Fchown(uid, gid int) error\n    Fchown wraps syscall.Fchown.\n\nfunc (fd *FD) Fstat(s *syscall.Stat_t) error\n    Fstat wraps syscall.Fstat\n\nfunc (fd *FD) Fsync() error\n    Fsync invokes SYS_FCNTL with SYS_FULLFSYNC because on OS X, SYS_FSYNC\n    doesn't fully flush contents to disk. See Issue #26650 as well as the man\n    page for fsync on OS X.\n\nfunc (fd *FD) Ftruncate(size int64) error\n    Ftruncate wraps syscall.Ftruncate.\n\nfunc (fd *FD) GetsockoptInt(level, name int) (int, error)\n    GetsockoptInt wraps the getsockopt network call with an int argument.\n\nfunc (fd *FD) Init(net string, pollable bool) error\n    Init initializes the FD. The Sysfd field should already be set. This can\n    be called multiple times on a single FD. The net argument is a network name\n    from the net package (e.g., \"tcp\"), or \"file\". Set pollable to true if fd\n    should be managed by runtime netpoll.\n\nfunc (fd *FD) OpenDir() (uintptr, string, error)\n    OpenDir returns a pointer to a DIR structure suitable for ReadDir.\n    In case of an error, the name of the failed syscall is returned along with a\n    syscall.Errno.\n\nfunc (fd *FD) Pread(p []byte, off int64) (int, error)\n    Pread wraps the pread system call.\n\nfunc (fd *FD) Pwrite(p []byte, off int64) (int, error)\n    Pwrite wraps the pwrite system call.\n\nfunc (fd *FD) RawControl(f func(uintptr)) error\n    RawControl invokes the user-defined function f for a non-IO operation.\n\nfunc (fd *FD) RawRead(f func(uintptr) bool) error\n    RawRead invokes the user-defined function f for a read operation.\n\nfunc (fd *FD) RawWrite(f func(uintptr) bool) error\n    RawWrite invokes the user-defined function f for a write operation.\n\nfunc (fd *FD) Read(p []byte) (int, error)\n    Read implements io.Reader.\n\nfunc (fd *FD) ReadDirent(buf []byte) (int, error)\n    ReadDirent wraps syscall.ReadDirent. We treat this like an ordinary system\n    call rather than a call that tries to fill the buffer.\n\nfunc (fd *FD) ReadFrom(p []byte) (int, syscall.Sockaddr, error)\n    ReadFrom wraps the recvfrom network call.\n\nfunc (fd *FD) ReadFromInet4(p []byte, from *syscall.SockaddrInet4) (int, error)\n    ReadFromInet4 wraps the recvfrom network call for IPv4.\n\nfunc (fd *FD) ReadFromInet6(p []byte, from *syscall.SockaddrInet6) (int, error)\n    ReadFromInet6 wraps the recvfrom network call for IPv6.\n\nfunc (fd *FD) ReadMsg(p []byte, oob []byte, flags int) (int, int, int, syscall.Sockaddr, error)\n    ReadMsg wraps the recvmsg network call.\n\nfunc (fd *FD) ReadMsgInet4(p []byte, oob []byte, flags int, sa4 *syscall.SockaddrInet4) (int, int, int, error)\n    ReadMsgInet4 is ReadMsg, but specialized for syscall.SockaddrInet4.\n\nfunc (fd *FD) ReadMsgInet6(p []byte, oob []byte, flags int, sa6 *syscall.SockaddrInet6) (int, int, int, error)\n    ReadMsgInet6 is ReadMsg, but specialized for syscall.SockaddrInet6.\n\nfunc (fd *FD) Seek(offset int64, whence int) (int64, error)\n    Seek wraps syscall.Seek.\n\nfunc (fd *FD) SetBlocking() error\n    SetBlocking puts the file into blocking mode.\n\nfunc (fd *FD) SetDeadline(t time.Time) error\n    SetDeadline sets the read and write deadlines associated with fd.\n\nfunc (fd *FD) SetReadDeadline(t time.Time) error\n    SetReadDeadline sets the read deadline associated with fd.\n\nfunc (fd *FD) SetWriteDeadline(t time.Time) error\n    SetWriteDeadline sets the write deadline associated with fd.\n\nfunc (fd *FD) SetsockoptByte(level, name int, arg byte) error\n    SetsockoptByte wraps the setsockopt network call with a byte argument.\n\nfunc (fd *FD) SetsockoptIPMreq(level, name int, mreq *syscall.IPMreq) error\n    SetsockoptIPMreq wraps the setsockopt network call with an IPMreq argument.\n\nfunc (fd *FD) SetsockoptIPv6Mreq(level, name int, mreq *syscall.IPv6Mreq) error\n    SetsockoptIPv6Mreq wraps the setsockopt network call with an IPv6Mreq\n    argument.\n\nfunc (fd *FD) SetsockoptInet4Addr(level, name int, arg [4]byte) error\n    SetsockoptInet4Addr wraps the setsockopt network call with an IPv4 address.\n\nfunc (fd *FD) SetsockoptInt(level, name, arg int) error\n    SetsockoptInt wraps the setsockopt network call with an int argument.\n\nfunc (fd *FD) SetsockoptLinger(level, name int, l *syscall.Linger) error\n    SetsockoptLinger wraps the setsockopt network call with a Linger argument.\n\nfunc (fd *FD) Shutdown(how int) error\n    Shutdown wraps syscall.Shutdown.\n\nfunc (fd *FD) WaitWrite() error\n    WaitWrite waits until data can be written to fd.\n\nfunc (fd *FD) Write(p []byte) (int, error)\n    Write implements io.Writer.\n\nfunc (fd *FD) WriteMsg(p []byte, oob []byte, sa syscall.Sockaddr) (int, int, error)\n    WriteMsg wraps the sendmsg network call.\n\nfunc (fd *FD) WriteMsgInet4(p []byte, oob []byte, sa *syscall.SockaddrInet4) (int, int, error)\n    WriteMsgInet4 is WriteMsg specialized for syscall.SockaddrInet4.\n\nfunc (fd *FD) WriteMsgInet6(p []byte, oob []byte, sa *syscall.SockaddrInet6) (int, int, error)\n    WriteMsgInet6 is WriteMsg specialized for syscall.SockaddrInet6.\n\nfunc (fd *FD) WriteOnce(p []byte) (int, error)\n    WriteOnce is for testing only. It makes a single write call.\n\nfunc (fd *FD) WriteTo(p []byte, sa syscall.Sockaddr) (int, error)\n    WriteTo wraps the sendto network call.\n\nfunc (fd *FD) WriteToInet4(p []byte, sa *syscall.SockaddrInet4) (int, error)\n    WriteToInet4 wraps the sendto network call for IPv4 addresses.\n\nfunc (fd *FD) WriteToInet6(p []byte, sa *syscall.SockaddrInet6) (int, error)\n    WriteToInet6 wraps the sendto network call for IPv6 addresses.\n\nfunc (fd *FD) Writev(v *[][]byte) (int64, error)\n    Writev wraps the writev system call.\n\ntype String string\n    String is an internal string definition for methods/functions that is not\n    intended for use outside the standard libraries.\n\n    Other packages in std that import internal/poll and have some exported APIs\n    (now we've got some in net.rawConn) which are only used internally and are\n    not intended to be used outside the standard libraries, Therefore, we make\n    those APIs use internal types like poll.FD or poll.String in their function\n    signatures to disable the usability of these APIs from external codebase.\n\ntype SysFile struct {\n\t// Has unexported fields.\n}\n\n"}, {"path": "stdlib/go-format.md", "category": "stdlib", "name": "stdlib/go-format", "content": "package format // import \"go/format\"\n\nPackage format implements standard formatting of Go source.\n\nNote that formatting of Go source code changes over time, so tools relying on\nconsistent formatting should execute a specific version of the gofmt binary\ninstead of using this package. That way, the formatting will be stable, and the\ntools won't need to be recompiled each time gofmt changes.\n\nFor example, pre-submit checks that use this package directly would behave\ndifferently depending on what Go version each developer uses, causing the check\nto be inherently fragile.\n\nFUNCTIONS\n\nfunc Node(dst io.Writer, fset *token.FileSet, node any) error\n    Node formats node in canonical gofmt style and writes the result to dst.\n\n    The node type must be *ast.File, *printer.CommentedNode, []ast.Decl,\n    []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec,\n    or ast.Stmt. Node does not modify node. Imports are not sorted for nodes\n    representing partial source files (for instance, if the node is not an\n    *ast.File or a *printer.CommentedNode not wrapping an *ast.File).\n\n    The function may return early (before the entire result is written) and\n    return a formatting error, for instance due to an incorrect AST.\n\nfunc Source(src []byte) ([]byte, error)\n    Source formats src in canonical gofmt style and returns the result or an\n    (I/O or syntax) error. src is expected to be a syntactically correct Go\n    source file, or a list of Go declarations or statements.\n\n    If src is a partial source file, the leading and trailing space of src is\n    applied to the result (such that it has the same leading and trailing space\n    as src), and the result is indented by the same amount as the first line of\n    src containing code. Imports are not sorted for partial source files.\n\n"}, {"path": "stdlib/crypto-internal-fips140cache.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140cache", "content": "package fips140cache // import \"crypto/internal/fips140cache\"\n\nPackage fips140cache provides a weak map that associates the lifetime of values\nwith the lifetime of keys.\n\nIt can be used to associate a precomputed value (such as an internal/fips140\nPrivateKey value, which in FIPS 140-3 mode may have required an expensive\npairwise consistency test) with a type that doesn't have private fields (such\nas an ed25519.PrivateKey), or that can't be safely modified because it may be\nconcurrently copied (such as an ecdsa.PrivateKey).\n\nTYPES\n\ntype Cache[K, V any] struct {\n\t// Has unexported fields.\n}\n\nfunc (c *Cache[K, V]) Get(k *K, new func() (*V, error), check func(*V) bool) (*V, error)\n    Get returns the result of new, for an associated key k.\n\n    If Get was called with k before and didn't return an error, Get may return\n    the same value it returned from the previous call if check returns true on\n    it. If check returns false, Get will call new again and return the result.\n\n    The cache is evicted some time after k becomes unreachable.\n\n"}, {"path": "stdlib/internal-platform.md", "category": "stdlib", "name": "stdlib/internal-platform", "content": "package platform // import \"internal/platform\"\n\n\nVARIABLES\n\nvar List = []OSArch{\n\t{\"aix\", \"ppc64\"},\n\t{\"android\", \"386\"},\n\t{\"android\", \"amd64\"},\n\t{\"android\", \"arm\"},\n\t{\"android\", \"arm64\"},\n\t{\"darwin\", \"amd64\"},\n\t{\"darwin\", \"arm64\"},\n\t{\"dragonfly\", \"amd64\"},\n\t{\"freebsd\", \"386\"},\n\t{\"freebsd\", \"amd64\"},\n\t{\"freebsd\", \"arm\"},\n\t{\"freebsd\", \"arm64\"},\n\t{\"freebsd\", \"riscv64\"},\n\t{\"illumos\", \"amd64\"},\n\t{\"ios\", \"amd64\"},\n\t{\"ios\", \"arm64\"},\n\t{\"js\", \"wasm\"},\n\t{\"linux\", \"386\"},\n\t{\"linux\", \"amd64\"},\n\t{\"linux\", \"arm\"},\n\t{\"linux\", \"arm64\"},\n\t{\"linux\", \"loong64\"},\n\t{\"linux\", \"mips\"},\n\t{\"linux\", \"mips64\"},\n\t{\"linux\", \"mips64le\"},\n\t{\"linux\", \"mipsle\"},\n\t{\"linux\", \"ppc64\"},\n\t{\"linux\", \"ppc64le\"},\n\t{\"linux\", \"riscv64\"},\n\t{\"linux\", \"s390x\"},\n\t{\"linux\", \"sparc64\"},\n\t{\"netbsd\", \"386\"},\n\t{\"netbsd\", \"amd64\"},\n\t{\"netbsd\", \"arm\"},\n\t{\"netbsd\", \"arm64\"},\n\t{\"openbsd\", \"386\"},\n\t{\"openbsd\", \"amd64\"},\n\t{\"openbsd\", \"arm\"},\n\t{\"openbsd\", \"arm64\"},\n\t{\"openbsd\", \"mips64\"},\n\t{\"openbsd\", \"ppc64\"},\n\t{\"openbsd\", \"riscv64\"},\n\t{\"plan9\", \"386\"},\n\t{\"plan9\", \"amd64\"},\n\t{\"plan9\", \"arm\"},\n\t{\"solaris\", \"amd64\"},\n\t{\"wasip1\", \"wasm\"},\n\t{\"windows\", \"386\"},\n\t{\"windows\", \"amd64\"},\n\t{\"windows\", \"arm\"},\n\t{\"windows\", \"arm64\"},\n}\n    List is the list of all valid GOOS/GOARCH combinations, including\n    known-broken ports.\n\n\nFUNCTIONS\n\nfunc ASanSupported(goos, goarch string) bool\n    ASanSupported reports whether goos/goarch supports the address sanitizer\n    option.\n\nfunc Broken(goos, goarch string) bool\n    Broken reports whether goos/goarch is considered a broken port. (See\n    https://go.dev/wiki/PortingPolicy#broken-ports.)\n\nfunc BuildModeSupported(compiler, buildmode, goos, goarch string) bool\n    BuildModeSupported reports whether goos/goarch supports the given build\n    mode using the given compiler. There is a copy of this function in\n    cmd/dist/test.go.\n\nfunc CgoSupported(goos, goarch string) bool\n    CgoSupported reports whether goos/goarch supports cgo.\n\nfunc DefaultPIE(goos, goarch string, isRace bool) bool\n    DefaultPIE reports whether goos/goarch produces a PIE binary when using\n    the \"default\" buildmode. On Windows this is affected by -race, so force the\n    caller to pass that in to centralize that choice.\n\nfunc ExecutableHasDWARF(goos, goarch string) bool\n    ExecutableHasDWARF reports whether the linked executable includes DWARF\n    symbols on goos/goarch.\n\nfunc FirstClass(goos, goarch string) bool\n    FirstClass reports whether goos/goarch is considered a \u201cfirst class\u201d port.\n    (See https://go.dev/wiki/PortingPolicy#first-class-ports.)\n\nfunc FuzzInstrumented(goos, goarch string) bool\n    FuzzInstrumented reports whether fuzzing on goos/goarch uses coverage\n    instrumentation. (FuzzInstrumented implies FuzzSupported.)\n\nfunc FuzzSupported(goos, goarch string) bool\n    FuzzSupported reports whether goos/goarch supports fuzzing ('go test\n    -fuzz=.').\n\nfunc InternalLinkPIESupported(goos, goarch string) bool\nfunc MSanSupported(goos, goarch string) bool\n    MSanSupported reports whether goos/goarch supports the memory sanitizer\n    option.\n\nfunc MustLinkExternal(goos, goarch string, withCgo bool) bool\n    MustLinkExternal reports whether goos/goarch requires external linking with\n    or without cgo dependencies.\n\nfunc RaceDetectorSupported(goos, goarch string) bool\n    RaceDetectorSupported reports whether goos/goarch supports the race\n    detector. There is a copy of this function in cmd/dist/test.go. Race\n    detector only supports 48-bit VMA on arm64. But it will always return true\n    for arm64, because we don't have VMA size information during the compile\n    time.\n\n\nTYPES\n\ntype OSArch struct {\n\tGOOS, GOARCH string\n}\n    An OSArch is a pair of GOOS and GOARCH values indicating a platform.\n\nfunc (p OSArch) String() string\n\n"}, {"path": "stdlib/internal-goversion.md", "category": "stdlib", "name": "stdlib/internal-goversion", "content": "package goversion // import \"internal/goversion\"\n\n\nCONSTANTS\n\nconst Version = 25\n    Version is the Go 1.x version which is currently in development and will\n    eventually get released.\n\n    It should be updated at the start of each development cycle to be the\n    version of the next Go 1.x release. See go.dev/issue/40705.\n\n"}, {"path": "stdlib/log.md", "category": "stdlib", "name": "stdlib/log", "content": "package log // import \"log\"\n\nPackage log implements a simple logging package. It defines a type, Logger,\nwith methods for formatting output. It also has a predefined 'standard' Logger\naccessible through helper functions Print[f|ln], Fatal[f|ln], and Panic[f|ln],\nwhich are easier to use than creating a Logger manually. That logger writes to\nstandard error and prints the date and time of each logged message. Every log\nmessage is output on a separate line: if the message being printed does not end\nin a newline, the logger will add one. The Fatal functions call os.Exit(1) after\nwriting the log message. The Panic functions call panic after writing the log\nmessage.\n\nCONSTANTS\n\nconst (\n\tLdate         = 1 << iota     // the date in the local time zone: 2009/01/23\n\tLtime                         // the time in the local time zone: 01:23:23\n\tLmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.\n\tLlongfile                     // full file name and line number: /a/b/c/d.go:23\n\tLshortfile                    // final file name element and line number: d.go:23. overrides Llongfile\n\tLUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone\n\tLmsgprefix                    // move the \"prefix\" from the beginning of the line to before the message\n\tLstdFlags     = Ldate | Ltime // initial values for the standard logger\n)\n    These flags define which text to prefix to each log entry generated by\n    the Logger. Bits are or'ed together to control what's printed. With the\n    exception of the Lmsgprefix flag, there is no control over the order they\n    appear (the order listed here) or the format they present (as described\n    in the comments). The prefix is followed by a colon only when Llongfile or\n    Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags)\n    produce,\n\n        2009/01/23 01:23:23 message\n\n    while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,\n\n        2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message\n\n\nFUNCTIONS\n\nfunc Fatal(v ...any)\n    Fatal is equivalent to Print followed by a call to os.Exit(1).\n\nfunc Fatalf(format string, v ...any)\n    Fatalf is equivalent to Printf followed by a call to os.Exit(1).\n\nfunc Fatalln(v ...any)\n    Fatalln is equivalent to Println followed by a call to os.Exit(1).\n\nfunc Flags() int\n    Flags returns the output flags for the standard logger. The flag bits are\n    Ldate, Ltime, and so on.\n\nfunc Output(calldepth int, s string) error\n    Output writes the output for a logging event. The string s contains the\n    text to print after the prefix specified by the flags of the Logger.\n    A newline is appended if the last character of s is not already a newline.\n    Calldepth is the count of the number of frames to skip when computing the\n    file name and line number if Llongfile or Lshortfile is set; a value of 1\n    will print the details for the caller of Output.\n\nfunc Panic(v ...any)\n    Panic is equivalent to Print followed by a call to panic().\n\nfunc Panicf(format string, v ...any)\n    Panicf is equivalent to Printf followed by a call to panic().\n\nfunc Panicln(v ...any)\n    Panicln is equivalent to Println followed by a call to panic().\n\nfunc Prefix() string\n    Prefix returns the output prefix for the standard logger.\n\nfunc Print(v ...any)\n    Print calls Output to print to the standard logger. Arguments are handled in\n    the manner of fmt.Print.\n\nfunc Printf(format string, v ...any)\n    Printf calls Output to print to the standard logger. Arguments are handled\n    in the manner of fmt.Printf.\n\nfunc Println(v ...any)\n    Println calls Output to print to the standard logger. Arguments are handled\n    in the manner of fmt.Println.\n\nfunc SetFlags(flag int)\n    SetFlags sets the output flags for the standard logger. The flag bits are\n    Ldate, Ltime, and so on.\n\nfunc SetOutput(w io.Writer)\n    SetOutput sets the output destination for the standard logger.\n\nfunc SetPrefix(prefix string)\n    SetPrefix sets the output prefix for the standard logger.\n\nfunc Writer() io.Writer\n    Writer returns the output destination for the standard logger.\n\n\nTYPES\n\ntype Logger struct {\n\t// Has unexported fields.\n}\n    A Logger represents an active logging object that generates lines of output\n    to an io.Writer. Each logging operation makes a single call to the Writer's\n    Write method. A Logger can be used simultaneously from multiple goroutines;\n    it guarantees to serialize access to the Writer.\n\nfunc Default() *Logger\n    Default returns the standard logger used by the package-level output\n    functions.\n\nfunc New(out io.Writer, prefix string, flag int) *Logger\n    New creates a new Logger. The out variable sets the destination to which log\n    data will be written. The prefix appears at the beginning of each generated\n    log line, or after the log header if the Lmsgprefix flag is provided.\n    The flag argument defines the logging properties.\n\nfunc (l *Logger) Fatal(v ...any)\n    Fatal is equivalent to l.Print() followed by a call to os.Exit(1).\n\nfunc (l *Logger) Fatalf(format string, v ...any)\n    Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).\n\nfunc (l *Logger) Fatalln(v ...any)\n    Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).\n\nfunc (l *Logger) Flags() int\n    Flags returns the output flags for the logger. The flag bits are Ldate,\n    Ltime, and so on.\n\nfunc (l *Logger) Output(calldepth int, s string) error\n    Output writes the output for a logging event. The string s contains the\n    text to print after the prefix specified by the flags of the Logger.\n    A newline is appended if the last character of s is not already a newline.\n    Calldepth is used to recover the PC and is provided for generality, although\n    at the moment on all pre-defined paths it will be 2.\n\nfunc (l *Logger) Panic(v ...any)\n    Panic is equivalent to l.Print() followed by a call to panic().\n\nfunc (l *Logger) Panicf(format string, v ...any)\n    Panicf is equivalent to l.Printf() followed by a call to panic().\n\nfunc (l *Logger) Panicln(v ...any)\n    Panicln is equivalent to l.Println() followed by a call to panic().\n\nfunc (l *Logger) Prefix() string\n    Prefix returns the output prefix for the logger.\n\nfunc (l *Logger) Print(v ...any)\n    Print calls l.Output to print to the logger. Arguments are handled in the\n    manner of fmt.Print.\n\nfunc (l *Logger) Printf(format string, v ...any)\n    Printf calls l.Output to print to the logger. Arguments are handled in the\n    manner of fmt.Printf.\n\nfunc (l *Logger) Println(v ...any)\n    Println calls l.Output to print to the logger. Arguments are handled in the\n    manner of fmt.Println.\n\nfunc (l *Logger) SetFlags(flag int)\n    SetFlags sets the output flags for the logger. The flag bits are Ldate,\n    Ltime, and so on.\n\nfunc (l *Logger) SetOutput(w io.Writer)\n    SetOutput sets the output destination for the logger.\n\nfunc (l *Logger) SetPrefix(prefix string)\n    SetPrefix sets the output prefix for the logger.\n\nfunc (l *Logger) Writer() io.Writer\n    Writer returns the output destination for the logger.\n\n"}, {"path": "stdlib/runtime-pprof.md", "category": "stdlib", "name": "stdlib/runtime-pprof", "content": "package pprof // import \"runtime/pprof\"\n\nPackage pprof writes runtime profiling data in the format expected by the pprof\nvisualization tool.\n\n# Profiling a Go program\n\nThe first step to profiling a Go program is to enable profiling. Support for\nprofiling benchmarks built with the standard testing package is built into\ngo test. For example, the following command runs benchmarks in the current\ndirectory and writes the CPU and memory profiles to cpu.prof and mem.prof:\n\n    go test -cpuprofile cpu.prof -memprofile mem.prof -bench .\n\nTo add equivalent profiling support to a standalone program, add code like the\nfollowing to your main function:\n\n    var cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to `file`\")\n    var memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to `file`\")\n\n    func main() {\n        flag.Parse()\n        if *cpuprofile != \"\" {\n            f, err := os.Create(*cpuprofile)\n            if err != nil {\n                log.Fatal(\"could not create CPU profile: \", err)\n            }\n            defer f.Close() // error handling omitted for example\n            if err := pprof.StartCPUProfile(f); err != nil {\n                log.Fatal(\"could not start CPU profile: \", err)\n            }\n            defer pprof.StopCPUProfile()\n        }\n\n        // ... rest of the program ...\n\n        if *memprofile != \"\" {\n            f, err := os.Create(*memprofile)\n            if err != nil {\n                log.Fatal(\"could not create memory profile: \", err)\n            }\n            defer f.Close() // error handling omitted for example\n            runtime.GC() // get up-to-date statistics\n            // Lookup(\"allocs\") creates a profile similar to go test -memprofile.\n            // Alternatively, use Lookup(\"heap\") for a profile\n            // that has inuse_space as the default index.\n            if err := pprof.Lookup(\"allocs\").WriteTo(f, 0); err != nil {\n                log.Fatal(\"could not write memory profile: \", err)\n            }\n        }\n    }\n\nThere is also a standard HTTP interface to profiling data. Adding the following\nline will install handlers under the /debug/pprof/ URL to download live\nprofiles:\n\n    import _ \"net/http/pprof\"\n\nSee the net/http/pprof package for more details.\n\nProfiles can then be visualized with the pprof tool:\n\n    go tool pprof cpu.prof\n\nThere are many commands available from the pprof command line. Commonly used\ncommands include \"top\", which prints a summary of the top program hot-spots,\nand \"web\", which opens an interactive graph of hot-spots and their call graphs.\nUse \"help\" for information on all pprof commands.\n\nFor more information about pprof, see\nhttps://github.com/google/pprof/blob/main/doc/README.md.\n\nFUNCTIONS\n\nfunc Do(ctx context.Context, labels LabelSet, f func(context.Context))\n    Do calls f with a copy of the parent context with the given labels added to\n    the parent's label map. Goroutines spawned while executing f will inherit\n    the augmented label-set. Each key/value pair in labels is inserted into the\n    label map in the order provided, overriding any previous value for the same\n    key. The augmented label map will be set for the duration of the call to f\n    and restored once f returns.\n\nfunc ForLabels(ctx context.Context, f func(key, value string) bool)\n    ForLabels invokes f with each label set on the context. The function f\n    should return true to continue iteration or false to stop iteration early.\n\nfunc Label(ctx context.Context, key string) (string, bool)\n    Label returns the value of the label with the given key on ctx, and a\n    boolean indicating whether that label exists.\n\nfunc SetGoroutineLabels(ctx context.Context)\n    SetGoroutineLabels sets the current goroutine's labels to match ctx.\n    A new goroutine inherits the labels of the goroutine that created it. This\n    is a lower-level API than Do, which should be used instead when possible.\n\nfunc StartCPUProfile(w io.Writer) error\n    StartCPUProfile enables CPU profiling for the current process. While\n    profiling, the profile will be buffered and written to w. StartCPUProfile\n    returns an error if profiling is already enabled.\n\n    On Unix-like systems, StartCPUProfile does not work by default for Go code\n    built with -buildmode=c-archive or -buildmode=c-shared. StartCPUProfile\n    relies on the SIGPROF signal, but that signal will be delivered to the\n    main program's SIGPROF signal handler (if any) not to the one used by Go.\n    To make it work, call os/signal.Notify for syscall.SIGPROF, but note that\n    doing so may break any profiling being done by the main program.\n\nfunc StopCPUProfile()\n    StopCPUProfile stops the current CPU profile, if any. StopCPUProfile only\n    returns after all the writes for the profile have completed.\n\nfunc WithLabels(ctx context.Context, labels LabelSet) context.Context\n    WithLabels returns a new context.Context with the given labels added.\n    A label overwrites a prior label with the same key.\n\nfunc WriteHeapProfile(w io.Writer) error\n    WriteHeapProfile is shorthand for Lookup(\"heap\").WriteTo(w, 0). It is\n    preserved for backwards compatibility.\n\n\nTYPES\n\ntype LabelSet struct {\n\t// Has unexported fields.\n}\n    LabelSet is a set of labels.\n\nfunc Labels(args ...string) LabelSet\n    Labels takes an even number of strings representing key-value pairs and\n    makes a LabelSet containing them. A label overwrites a prior label with the\n    same key. Currently only the CPU and goroutine profiles utilize any labels\n    information. See https://golang.org/issue/23458 for details.\n\ntype Profile struct {\n\t// Has unexported fields.\n}\n    A Profile is a collection of stack traces showing the call sequences that\n    led to instances of a particular event, such as allocation. Packages\n    can create and maintain their own profiles; the most common use is for\n    tracking resources that must be explicitly closed, such as files or network\n    connections.\n\n    A Profile's methods can be called from multiple goroutines simultaneously.\n\n    Each Profile has a unique name. A few profiles are predefined:\n\n        goroutine    - stack traces of all current goroutines\n        heap         - a sampling of memory allocations of live objects\n        allocs       - a sampling of all past memory allocations\n        threadcreate - stack traces that led to the creation of new OS threads\n        block        - stack traces that led to blocking on synchronization primitives\n        mutex        - stack traces of holders of contended mutexes\n\n    These predefined profiles maintain themselves and panic on an explicit\n    Profile.Add or Profile.Remove method call.\n\n    The CPU profile is not available as a Profile. It has a special API,\n    the StartCPUProfile and StopCPUProfile functions, because it streams output\n    to a writer during profiling.\n\n    # Heap profile\n\n    The heap profile reports statistics as of the most recently completed\n    garbage collection; it elides more recent allocation to avoid skewing\n    the profile away from live data and toward garbage. If there has been no\n    garbage collection at all, the heap profile reports all known allocations.\n    This exception helps mainly in programs running without garbage collection\n    enabled, usually for debugging purposes.\n\n    The heap profile tracks both the allocation sites for all live objects\n    in the application memory and for all objects allocated since the\n    program start. Pprof's -inuse_space, -inuse_objects, -alloc_space,\n    and -alloc_objects flags select which to display, defaulting to -inuse_space\n    (live objects, scaled by size).\n\n    # Allocs profile\n\n    The allocs profile is the same as the heap profile but changes the default\n    pprof display to -alloc_space, the total number of bytes allocated since the\n    program began (including garbage-collected bytes).\n\n    # Block profile\n\n    The block profile tracks time spent blocked on synchronization primitives,\n    such as sync.Mutex, sync.RWMutex, sync.WaitGroup, sync.Cond, and channel\n    send/receive/select.\n\n    Stack traces correspond to the location that blocked (for example,\n    sync.Mutex.Lock).\n\n    Sample values correspond to cumulative time spent blocked at\n    that stack trace, subject to time-based sampling specified by\n    runtime.SetBlockProfileRate.\n\n    # Mutex profile\n\n    The mutex profile tracks contention on mutexes, such as sync.Mutex,\n    sync.RWMutex, and runtime-internal locks.\n\n    Stack traces correspond to the end of the critical section causing\n    contention. For example, a lock held for a long time while other goroutines\n    are waiting to acquire the lock will report contention when the lock is\n    finally unlocked (that is, at sync.Mutex.Unlock).\n\n    Sample values correspond to the approximate cumulative time other goroutines\n    spent blocked waiting for the lock, subject to event-based sampling\n    specified by runtime.SetMutexProfileFraction. For example, if a caller holds\n    a lock for 1s while 5 other goroutines are waiting for the entire second to\n    acquire the lock, its unlock call stack will report 5s of contention.\n\nfunc Lookup(name string) *Profile\n    Lookup returns the profile with the given name, or nil if no such profile\n    exists.\n\nfunc NewProfile(name string) *Profile\n    NewProfile creates a new profile with the given name. If a profile with\n    that name already exists, NewProfile panics. The convention is to use a\n    'import/path.' prefix to create separate name spaces for each package.\n    For compatibility with various tools that read pprof data, profile names\n    should not contain spaces.\n\nfunc Profiles() []*Profile\n    Profiles returns a slice of all the known profiles, sorted by name.\n\nfunc (p *Profile) Add(value any, skip int)\n    Add adds the current execution stack to the profile, associated with value.\n    Add stores value in an internal map, so value must be suitable for use as\n    a map key and will not be garbage collected until the corresponding call\n    to Profile.Remove. Add panics if the profile already contains a stack for\n    value.\n\n    The skip parameter has the same meaning as runtime.Caller's skip and\n    controls where the stack trace begins. Passing skip=0 begins the trace in\n    the function calling Add. For example, given this execution stack:\n\n        Add\n        called from rpc.NewClient\n        called from mypkg.Run\n        called from main.main\n\n    Passing skip=0 begins the stack trace at the call to Add inside\n    rpc.NewClient. Passing skip=1 begins the stack trace at the call to\n    NewClient inside mypkg.Run.\n\nfunc (p *Profile) Count() int\n    Count returns the number of execution stacks currently in the profile.\n\nfunc (p *Profile) Name() string\n    Name returns this profile's name, which can be passed to Lookup to reobtain\n    the profile.\n\nfunc (p *Profile) Remove(value any)\n    Remove removes the execution stack associated with value from the profile.\n    It is a no-op if the value is not in the profile.\n\nfunc (p *Profile) WriteTo(w io.Writer, debug int) error\n    WriteTo writes a pprof-formatted snapshot of the profile to w. If a write to\n    w returns an error, WriteTo returns that error. Otherwise, WriteTo returns\n    nil.\n\n    The debug parameter enables additional output. Passing debug=0\n    writes the gzip-compressed protocol buffer described in\n    https://github.com/google/pprof/tree/main/proto#overview. Passing debug=1\n    writes the legacy text format with comments translating addresses to\n    function names and line numbers, so that a programmer can read the profile\n    without tools.\n\n    The predefined profiles may assign meaning to other debug values; for\n    example, when printing the \"goroutine\" profile, debug=2 means to print the\n    goroutine stacks in the same form that a Go program uses when dying due to\n    an unrecovered panic.\n\n\nBUG: Profiles are only as good as the kernel support used to generate them.\nSee https://golang.org/issue/13841 for details about known problems.\n\n"}, {"path": "stdlib/internal-stringslite.md", "category": "stdlib", "name": "stdlib/internal-stringslite", "content": "package stringslite // import \"internal/stringslite\"\n\nPackage stringslite implements a subset of strings, only using packages that may\nbe imported by \"os\".\n\nTests for these functions are in the strings package.\n\nFUNCTIONS\n\nfunc Clone(s string) string\nfunc Cut(s, sep string) (before, after string, found bool)\nfunc CutPrefix(s, prefix string) (after string, found bool)\nfunc CutSuffix(s, suffix string) (before string, found bool)\nfunc HasPrefix(s, prefix string) bool\nfunc HasSuffix(s, suffix string) bool\nfunc Index(s, substr string) int\nfunc IndexByte(s string, c byte) int\nfunc TrimPrefix(s, prefix string) string\nfunc TrimSuffix(s, suffix string) string\n"}, {"path": "stdlib/unicode.md", "category": "stdlib", "name": "stdlib/unicode", "content": "package unicode // import \"unicode\"\n\nPackage unicode provides data and functions to test some properties of Unicode\ncode points.\n\nCONSTANTS\n\nconst (\n\tMaxRune         = '\\U0010FFFF' // Maximum valid Unicode code point.\n\tReplacementChar = '\\uFFFD'     // Represents invalid code points.\n\tMaxASCII        = '\\u007F'     // maximum ASCII value.\n\tMaxLatin1       = '\\u00FF'     // maximum Latin-1 value.\n)\nconst (\n\tUpperCase = iota\n\tLowerCase\n\tTitleCase\n\tMaxCase\n)\n    Indices into the Delta arrays inside CaseRanges for case mapping.\n\nconst (\n\tUpperLower = MaxRune + 1 // (Cannot be a valid delta.)\n)\n    If the Delta field of a CaseRange is UpperLower, it means this CaseRange\n    represents a sequence of the form (say) Upper Lower Upper Lower.\n\nconst Version = \"15.0.0\"\n    Version is the Unicode edition from which the tables are derived.\n\n\nVARIABLES\n\nvar (\n\tCc     = _Cc // Cc is the set of Unicode characters in category Cc (Other, control).\n\tCf     = _Cf // Cf is the set of Unicode characters in category Cf (Other, format).\n\tCn     = _Cn // Cn is the set of Unicode characters in category Cn (Other, not assigned).\n\tCo     = _Co // Co is the set of Unicode characters in category Co (Other, private use).\n\tCs     = _Cs // Cs is the set of Unicode characters in category Cs (Other, surrogate).\n\tDigit  = _Nd // Digit is the set of Unicode characters with the \"decimal digit\" property.\n\tNd     = _Nd // Nd is the set of Unicode characters in category Nd (Number, decimal digit).\n\tLC     = _LC // LC is the set of Unicode characters in category LC (Letter, cased: Ll | Lt | Lu).\n\tLetter = _L  // Letter/L is the set of Unicode letters, category L.\n\tL      = _L\n\tLm     = _Lm // Lm is the set of Unicode characters in category Lm (Letter, modifier).\n\tLo     = _Lo // Lo is the set of Unicode characters in category Lo (Letter, other).\n\tLower  = _Ll // Lower is the set of Unicode lower case letters.\n\tLl     = _Ll // Ll is the set of Unicode characters in category Ll (Letter, lowercase).\n\tMark   = _M  // Mark/M is the set of Unicode mark characters, category M.\n\tM      = _M\n\tMc     = _Mc // Mc is the set of Unicode characters in category Mc (Mark, spacing combining).\n\tMe     = _Me // Me is the set of Unicode characters in category Me (Mark, enclosing).\n\tMn     = _Mn // Mn is the set of Unicode characters in category Mn (Mark, nonspacing).\n\tNl     = _Nl // Nl is the set of Unicode characters in category Nl (Number, letter).\n\tNo     = _No // No is the set of Unicode characters in category No (Number, other).\n\tNumber = _N  // Number/N is the set of Unicode number characters, category N.\n\tN      = _N\n\tOther  = _C // Other/C is the set of Unicode control, special, and unassigned code points, category C.\n\tC      = _C\n\tPc     = _Pc // Pc is the set of Unicode characters in category Pc (Punctuation, connector).\n\tPd     = _Pd // Pd is the set of Unicode characters in category Pd (Punctuation, dash).\n\tPe     = _Pe // Pe is the set of Unicode characters in category Pe (Punctuation, close).\n\tPf     = _Pf // Pf is the set of Unicode characters in category Pf (Punctuation, final quote).\n\tPi     = _Pi // Pi is the set of Unicode characters in category Pi (Punctuation, initial quote).\n\tPo     = _Po // Po is the set of Unicode characters in category Po (Punctuation, other).\n\tPs     = _Ps // Ps is the set of Unicode characters in category Ps (Punctuation, open).\n\tPunct  = _P  // Punct/P is the set of Unicode punctuation characters, category P.\n\tP      = _P\n\tSc     = _Sc // Sc is the set of Unicode characters in category Sc (Symbol, currency).\n\tSk     = _Sk // Sk is the set of Unicode characters in category Sk (Symbol, modifier).\n\tSm     = _Sm // Sm is the set of Unicode characters in category Sm (Symbol, math).\n\tSo     = _So // So is the set of Unicode characters in category So (Symbol, other).\n\tSpace  = _Z  // Space/Z is the set of Unicode space characters, category Z.\n\tZ      = _Z\n\tSymbol = _S // Symbol/S is the set of Unicode symbol characters, category S.\n\tS      = _S\n\tTitle  = _Lt // Title is the set of Unicode title case letters.\n\tLt     = _Lt // Lt is the set of Unicode characters in category Lt (Letter, titlecase).\n\tUpper  = _Lu // Upper is the set of Unicode upper case letters.\n\tLu     = _Lu // Lu is the set of Unicode characters in category Lu (Letter, uppercase).\n\tZl     = _Zl // Zl is the set of Unicode characters in category Zl (Separator, line).\n\tZp     = _Zp // Zp is the set of Unicode characters in category Zp (Separator, paragraph).\n\tZs     = _Zs // Zs is the set of Unicode characters in category Zs (Separator, space).\n)\n    These variables have type *RangeTable.\n\nvar (\n\tAdlam                  = _Adlam                  // Adlam is the set of Unicode characters in script Adlam.\n\tAhom                   = _Ahom                   // Ahom is the set of Unicode characters in script Ahom.\n\tAnatolian_Hieroglyphs  = _Anatolian_Hieroglyphs  // Anatolian_Hieroglyphs is the set of Unicode characters in script Anatolian_Hieroglyphs.\n\tArabic                 = _Arabic                 // Arabic is the set of Unicode characters in script Arabic.\n\tArmenian               = _Armenian               // Armenian is the set of Unicode characters in script Armenian.\n\tAvestan                = _Avestan                // Avestan is the set of Unicode characters in script Avestan.\n\tBalinese               = _Balinese               // Balinese is the set of Unicode characters in script Balinese.\n\tBamum                  = _Bamum                  // Bamum is the set of Unicode characters in script Bamum.\n\tBassa_Vah              = _Bassa_Vah              // Bassa_Vah is the set of Unicode characters in script Bassa_Vah.\n\tBatak                  = _Batak                  // Batak is the set of Unicode characters in script Batak.\n\tBengali                = _Bengali                // Bengali is the set of Unicode characters in script Bengali.\n\tBhaiksuki              = _Bhaiksuki              // Bhaiksuki is the set of Unicode characters in script Bhaiksuki.\n\tBopomofo               = _Bopomofo               // Bopomofo is the set of Unicode characters in script Bopomofo.\n\tBrahmi                 = _Brahmi                 // Brahmi is the set of Unicode characters in script Brahmi.\n\tBraille                = _Braille                // Braille is the set of Unicode characters in script Braille.\n\tBuginese               = _Buginese               // Buginese is the set of Unicode characters in script Buginese.\n\tBuhid                  = _Buhid                  // Buhid is the set of Unicode characters in script Buhid.\n\tCanadian_Aboriginal    = _Canadian_Aboriginal    // Canadian_Aboriginal is the set of Unicode characters in script Canadian_Aboriginal.\n\tCarian                 = _Carian                 // Carian is the set of Unicode characters in script Carian.\n\tCaucasian_Albanian     = _Caucasian_Albanian     // Caucasian_Albanian is the set of Unicode characters in script Caucasian_Albanian.\n\tChakma                 = _Chakma                 // Chakma is the set of Unicode characters in script Chakma.\n\tCham                   = _Cham                   // Cham is the set of Unicode characters in script Cham.\n\tCherokee               = _Cherokee               // Cherokee is the set of Unicode characters in script Cherokee.\n\tChorasmian             = _Chorasmian             // Chorasmian is the set of Unicode characters in script Chorasmian.\n\tCommon                 = _Common                 // Common is the set of Unicode characters in script Common.\n\tCoptic                 = _Coptic                 // Coptic is the set of Unicode characters in script Coptic.\n\tCuneiform              = _Cuneiform              // Cuneiform is the set of Unicode characters in script Cuneiform.\n\tCypriot                = _Cypriot                // Cypriot is the set of Unicode characters in script Cypriot.\n\tCypro_Minoan           = _Cypro_Minoan           // Cypro_Minoan is the set of Unicode characters in script Cypro_Minoan.\n\tCyrillic               = _Cyrillic               // Cyrillic is the set of Unicode characters in script Cyrillic.\n\tDeseret                = _Deseret                // Deseret is the set of Unicode characters in script Deseret.\n\tDevanagari             = _Devanagari             // Devanagari is the set of Unicode characters in script Devanagari.\n\tDives_Akuru            = _Dives_Akuru            // Dives_Akuru is the set of Unicode characters in script Dives_Akuru.\n\tDogra                  = _Dogra                  // Dogra is the set of Unicode characters in script Dogra.\n\tDuployan               = _Duployan               // Duployan is the set of Unicode characters in script Duployan.\n\tEgyptian_Hieroglyphs   = _Egyptian_Hieroglyphs   // Egyptian_Hieroglyphs is the set of Unicode characters in script Egyptian_Hieroglyphs.\n\tElbasan                = _Elbasan                // Elbasan is the set of Unicode characters in script Elbasan.\n\tElymaic                = _Elymaic                // Elymaic is the set of Unicode characters in script Elymaic.\n\tEthiopic               = _Ethiopic               // Ethiopic is the set of Unicode characters in script Ethiopic.\n\tGeorgian               = _Georgian               // Georgian is the set of Unicode characters in script Georgian.\n\tGlagolitic             = _Glagolitic             // Glagolitic is the set of Unicode characters in script Glagolitic.\n\tGothic                 = _Gothic                 // Gothic is the set of Unicode characters in script Gothic.\n\tGrantha                = _Grantha                // Grantha is the set of Unicode characters in script Grantha.\n\tGreek                  = _Greek                  // Greek is the set of Unicode characters in script Greek.\n\tGujarati               = _Gujarati               // Gujarati is the set of Unicode characters in script Gujarati.\n\tGunjala_Gondi          = _Gunjala_Gondi          // Gunjala_Gondi is the set of Unicode characters in script Gunjala_Gondi.\n\tGurmukhi               = _Gurmukhi               // Gurmukhi is the set of Unicode characters in script Gurmukhi.\n\tHan                    = _Han                    // Han is the set of Unicode characters in script Han.\n\tHangul                 = _Hangul                 // Hangul is the set of Unicode characters in script Hangul.\n\tHanifi_Rohingya        = _Hanifi_Rohingya        // Hanifi_Rohingya is the set of Unicode characters in script Hanifi_Rohingya.\n\tHanunoo                = _Hanunoo                // Hanunoo is the set of Unicode characters in script Hanunoo.\n\tHatran                 = _Hatran                 // Hatran is the set of Unicode characters in script Hatran.\n\tHebrew                 = _Hebrew                 // Hebrew is the set of Unicode characters in script Hebrew.\n\tHiragana               = _Hiragana               // Hiragana is the set of Unicode characters in script Hiragana.\n\tImperial_Aramaic       = _Imperial_Aramaic       // Imperial_Aramaic is the set of Unicode characters in script Imperial_Aramaic.\n\tInherited              = _Inherited              // Inherited is the set of Unicode characters in script Inherited.\n\tInscriptional_Pahlavi  = _Inscriptional_Pahlavi  // Inscriptional_Pahlavi is the set of Unicode characters in script Inscriptional_Pahlavi.\n\tInscriptional_Parthian = _Inscriptional_Parthian // Inscriptional_Parthian is the set of Unicode characters in script Inscriptional_Parthian.\n\tJavanese               = _Javanese               // Javanese is the set of Unicode characters in script Javanese.\n\tKaithi                 = _Kaithi                 // Kaithi is the set of Unicode characters in script Kaithi.\n\tKannada                = _Kannada                // Kannada is the set of Unicode characters in script Kannada.\n\tKatakana               = _Katakana               // Katakana is the set of Unicode characters in script Katakana.\n\tKawi                   = _Kawi                   // Kawi is the set of Unicode characters in script Kawi.\n\tKayah_Li               = _Kayah_Li               // Kayah_Li is the set of Unicode characters in script Kayah_Li.\n\tKharoshthi             = _Kharoshthi             // Kharoshthi is the set of Unicode characters in script Kharoshthi.\n\tKhitan_Small_Script    = _Khitan_Small_Script    // Khitan_Small_Script is the set of Unicode characters in script Khitan_Small_Script.\n\tKhmer                  = _Khmer                  // Khmer is the set of Unicode characters in script Khmer.\n\tKhojki                 = _Khojki                 // Khojki is the set of Unicode characters in script Khojki.\n\tKhudawadi              = _Khudawadi              // Khudawadi is the set of Unicode characters in script Khudawadi.\n\tLao                    = _Lao                    // Lao is the set of Unicode characters in script Lao.\n\tLatin                  = _Latin                  // Latin is the set of Unicode characters in script Latin.\n\tLepcha                 = _Lepcha                 // Lepcha is the set of Unicode characters in script Lepcha.\n\tLimbu                  = _Limbu                  // Limbu is the set of Unicode characters in script Limbu.\n\tLinear_A               = _Linear_A               // Linear_A is the set of Unicode characters in script Linear_A.\n\tLinear_B               = _Linear_B               // Linear_B is the set of Unicode characters in script Linear_B.\n\tLisu                   = _Lisu                   // Lisu is the set of Unicode characters in script Lisu.\n\tLycian                 = _Lycian                 // Lycian is the set of Unicode characters in script Lycian.\n\tLydian                 = _Lydian                 // Lydian is the set of Unicode characters in script Lydian.\n\tMahajani               = _Mahajani               // Mahajani is the set of Unicode characters in script Mahajani.\n\tMakasar                = _Makasar                // Makasar is the set of Unicode characters in script Makasar.\n\tMalayalam              = _Malayalam              // Malayalam is the set of Unicode characters in script Malayalam.\n\tMandaic                = _Mandaic                // Mandaic is the set of Unicode characters in script Mandaic.\n\tManichaean             = _Manichaean             // Manichaean is the set of Unicode characters in script Manichaean.\n\tMarchen                = _Marchen                // Marchen is the set of Unicode characters in script Marchen.\n\tMasaram_Gondi          = _Masaram_Gondi          // Masaram_Gondi is the set of Unicode characters in script Masaram_Gondi.\n\tMedefaidrin            = _Medefaidrin            // Medefaidrin is the set of Unicode characters in script Medefaidrin.\n\tMeetei_Mayek           = _Meetei_Mayek           // Meetei_Mayek is the set of Unicode characters in script Meetei_Mayek.\n\tMende_Kikakui          = _Mende_Kikakui          // Mende_Kikakui is the set of Unicode characters in script Mende_Kikakui.\n\tMeroitic_Cursive       = _Meroitic_Cursive       // Meroitic_Cursive is the set of Unicode characters in script Meroitic_Cursive.\n\tMeroitic_Hieroglyphs   = _Meroitic_Hieroglyphs   // Meroitic_Hieroglyphs is the set of Unicode characters in script Meroitic_Hieroglyphs.\n\tMiao                   = _Miao                   // Miao is the set of Unicode characters in script Miao.\n\tModi                   = _Modi                   // Modi is the set of Unicode characters in script Modi.\n\tMongolian              = _Mongolian              // Mongolian is the set of Unicode characters in script Mongolian.\n\tMro                    = _Mro                    // Mro is the set of Unicode characters in script Mro.\n\tMultani                = _Multani                // Multani is the set of Unicode characters in script Multani.\n\tMyanmar                = _Myanmar                // Myanmar is the set of Unicode characters in script Myanmar.\n\tNabataean              = _Nabataean              // Nabataean is the set of Unicode characters in script Nabataean.\n\tNag_Mundari            = _Nag_Mundari            // Nag_Mundari is the set of Unicode characters in script Nag_Mundari.\n\tNandinagari            = _Nandinagari            // Nandinagari is the set of Unicode characters in script Nandinagari.\n\tNew_Tai_Lue            = _New_Tai_Lue            // New_Tai_Lue is the set of Unicode characters in script New_Tai_Lue.\n\tNewa                   = _Newa                   // Newa is the set of Unicode characters in script Newa.\n\tNko                    = _Nko                    // Nko is the set of Unicode characters in script Nko.\n\tNushu                  = _Nushu                  // Nushu is the set of Unicode characters in script Nushu.\n\tNyiakeng_Puachue_Hmong = _Nyiakeng_Puachue_Hmong // Nyiakeng_Puachue_Hmong is the set of Unicode characters in script Nyiakeng_Puachue_Hmong.\n\tOgham                  = _Ogham                  // Ogham is the set of Unicode characters in script Ogham.\n\tOl_Chiki               = _Ol_Chiki               // Ol_Chiki is the set of Unicode characters in script Ol_Chiki.\n\tOld_Hungarian          = _Old_Hungarian          // Old_Hungarian is the set of Unicode characters in script Old_Hungarian.\n\tOld_Italic             = _Old_Italic             // Old_Italic is the set of Unicode characters in script Old_Italic.\n\tOld_North_Arabian      = _Old_North_Arabian      // Old_North_Arabian is the set of Unicode characters in script Old_North_Arabian.\n\tOld_Permic             = _Old_Permic             // Old_Permic is the set of Unicode characters in script Old_Permic.\n\tOld_Persian            = _Old_Persian            // Old_Persian is the set of Unicode characters in script Old_Persian.\n\tOld_Sogdian            = _Old_Sogdian            // Old_Sogdian is the set of Unicode characters in script Old_Sogdian.\n\tOld_South_Arabian      = _Old_South_Arabian      // Old_South_Arabian is the set of Unicode characters in script Old_South_Arabian.\n\tOld_Turkic             = _Old_Turkic             // Old_Turkic is the set of Unicode characters in script Old_Turkic.\n\tOld_Uyghur             = _Old_Uyghur             // Old_Uyghur is the set of Unicode characters in script Old_Uyghur.\n\tOriya                  = _Oriya                  // Oriya is the set of Unicode characters in script Oriya.\n\tOsage                  = _Osage                  // Osage is the set of Unicode characters in script Osage.\n\tOsmanya                = _Osmanya                // Osmanya is the set of Unicode characters in script Osmanya.\n\tPahawh_Hmong           = _Pahawh_Hmong           // Pahawh_Hmong is the set of Unicode characters in script Pahawh_Hmong.\n\tPalmyrene              = _Palmyrene              // Palmyrene is the set of Unicode characters in script Palmyrene.\n\tPau_Cin_Hau            = _Pau_Cin_Hau            // Pau_Cin_Hau is the set of Unicode characters in script Pau_Cin_Hau.\n\tPhags_Pa               = _Phags_Pa               // Phags_Pa is the set of Unicode characters in script Phags_Pa.\n\tPhoenician             = _Phoenician             // Phoenician is the set of Unicode characters in script Phoenician.\n\tPsalter_Pahlavi        = _Psalter_Pahlavi        // Psalter_Pahlavi is the set of Unicode characters in script Psalter_Pahlavi.\n\tRejang                 = _Rejang                 // Rejang is the set of Unicode characters in script Rejang.\n\tRunic                  = _Runic                  // Runic is the set of Unicode characters in script Runic.\n\tSamaritan              = _Samaritan              // Samaritan is the set of Unicode characters in script Samaritan.\n\tSaurashtra             = _Saurashtra             // Saurashtra is the set of Unicode characters in script Saurashtra.\n\tSharada                = _Sharada                // Sharada is the set of Unicode characters in script Sharada.\n\tShavian                = _Shavian                // Shavian is the set of Unicode characters in script Shavian.\n\tSiddham                = _Siddham                // Siddham is the set of Unicode characters in script Siddham.\n\tSignWriting            = _SignWriting            // SignWriting is the set of Unicode characters in script SignWriting.\n\tSinhala                = _Sinhala                // Sinhala is the set of Unicode characters in script Sinhala.\n\tSogdian                = _Sogdian                // Sogdian is the set of Unicode characters in script Sogdian.\n\tSora_Sompeng           = _Sora_Sompeng           // Sora_Sompeng is the set of Unicode characters in script Sora_Sompeng.\n\tSoyombo                = _Soyombo                // Soyombo is the set of Unicode characters in script Soyombo.\n\tSundanese              = _Sundanese              // Sundanese is the set of Unicode characters in script Sundanese.\n\tSyloti_Nagri           = _Syloti_Nagri           // Syloti_Nagri is the set of Unicode characters in script Syloti_Nagri.\n\tSyriac                 = _Syriac                 // Syriac is the set of Unicode characters in script Syriac.\n\tTagalog                = _Tagalog                // Tagalog is the set of Unicode characters in script Tagalog.\n\tTagbanwa               = _Tagbanwa               // Tagbanwa is the set of Unicode characters in script Tagbanwa.\n\tTai_Le                 = _Tai_Le                 // Tai_Le is the set of Unicode characters in script Tai_Le.\n\tTai_Tham               = _Tai_Tham               // Tai_Tham is the set of Unicode characters in script Tai_Tham.\n\tTai_Viet               = _Tai_Viet               // Tai_Viet is the set of Unicode characters in script Tai_Viet.\n\tTakri                  = _Takri                  // Takri is the set of Unicode characters in script Takri.\n\tTamil                  = _Tamil                  // Tamil is the set of Unicode characters in script Tamil.\n\tTangsa                 = _Tangsa                 // Tangsa is the set of Unicode characters in script Tangsa.\n\tTangut                 = _Tangut                 // Tangut is the set of Unicode characters in script Tangut.\n\tTelugu                 = _Telugu                 // Telugu is the set of Unicode characters in script Telugu.\n\tThaana                 = _Thaana                 // Thaana is the set of Unicode characters in script Thaana.\n\tThai                   = _Thai                   // Thai is the set of Unicode characters in script Thai.\n\tTibetan                = _Tibetan                // Tibetan is the set of Unicode characters in script Tibetan.\n\tTifinagh               = _Tifinagh               // Tifinagh is the set of Unicode characters in script Tifinagh.\n\tTirhuta                = _Tirhuta                // Tirhuta is the set of Unicode characters in script Tirhuta.\n\tToto                   = _Toto                   // Toto is the set of Unicode characters in script Toto.\n\tUgaritic               = _Ugaritic               // Ugaritic is the set of Unicode characters in script Ugaritic.\n\tVai                    = _Vai                    // Vai is the set of Unicode characters in script Vai.\n\tVithkuqi               = _Vithkuqi               // Vithkuqi is the set of Unicode characters in script Vithkuqi.\n\tWancho                 = _Wancho                 // Wancho is the set of Unicode characters in script Wancho.\n\tWarang_Citi            = _Warang_Citi            // Warang_Citi is the set of Unicode characters in script Warang_Citi.\n\tYezidi                 = _Yezidi                 // Yezidi is the set of Unicode characters in script Yezidi.\n\tYi                     = _Yi                     // Yi is the set of Unicode characters in script Yi.\n\tZanabazar_Square       = _Zanabazar_Square       // Zanabazar_Square is the set of Unicode characters in script Zanabazar_Square.\n)\n    These variables have type *RangeTable.\n\nvar (\n\tASCII_Hex_Digit                    = _ASCII_Hex_Digit                    // ASCII_Hex_Digit is the set of Unicode characters with property ASCII_Hex_Digit.\n\tBidi_Control                       = _Bidi_Control                       // Bidi_Control is the set of Unicode characters with property Bidi_Control.\n\tDash                               = _Dash                               // Dash is the set of Unicode characters with property Dash.\n\tDeprecated                         = _Deprecated                         // Deprecated is the set of Unicode characters with property Deprecated.\n\tDiacritic                          = _Diacritic                          // Diacritic is the set of Unicode characters with property Diacritic.\n\tExtender                           = _Extender                           // Extender is the set of Unicode characters with property Extender.\n\tHex_Digit                          = _Hex_Digit                          // Hex_Digit is the set of Unicode characters with property Hex_Digit.\n\tHyphen                             = _Hyphen                             // Hyphen is the set of Unicode characters with property Hyphen.\n\tIDS_Binary_Operator                = _IDS_Binary_Operator                // IDS_Binary_Operator is the set of Unicode characters with property IDS_Binary_Operator.\n\tIDS_Trinary_Operator               = _IDS_Trinary_Operator               // IDS_Trinary_Operator is the set of Unicode characters with property IDS_Trinary_Operator.\n\tIdeographic                        = _Ideographic                        // Ideographic is the set of Unicode characters with property Ideographic.\n\tJoin_Control                       = _Join_Control                       // Join_Control is the set of Unicode characters with property Join_Control.\n\tLogical_Order_Exception            = _Logical_Order_Exception            // Logical_Order_Exception is the set of Unicode characters with property Logical_Order_Exception.\n\tNoncharacter_Code_Point            = _Noncharacter_Code_Point            // Noncharacter_Code_Point is the set of Unicode characters with property Noncharacter_Code_Point.\n\tOther_Alphabetic                   = _Other_Alphabetic                   // Other_Alphabetic is the set of Unicode characters with property Other_Alphabetic.\n\tOther_Default_Ignorable_Code_Point = _Other_Default_Ignorable_Code_Point // Other_Default_Ignorable_Code_Point is the set of Unicode characters with property Other_Default_Ignorable_Code_Point.\n\tOther_Grapheme_Extend              = _Other_Grapheme_Extend              // Other_Grapheme_Extend is the set of Unicode characters with property Other_Grapheme_Extend.\n\tOther_ID_Continue                  = _Other_ID_Continue                  // Other_ID_Continue is the set of Unicode characters with property Other_ID_Continue.\n\tOther_ID_Start                     = _Other_ID_Start                     // Other_ID_Start is the set of Unicode characters with property Other_ID_Start.\n\tOther_Lowercase                    = _Other_Lowercase                    // Other_Lowercase is the set of Unicode characters with property Other_Lowercase.\n\tOther_Math                         = _Other_Math                         // Other_Math is the set of Unicode characters with property Other_Math.\n\tOther_Uppercase                    = _Other_Uppercase                    // Other_Uppercase is the set of Unicode characters with property Other_Uppercase.\n\tPattern_Syntax                     = _Pattern_Syntax                     // Pattern_Syntax is the set of Unicode characters with property Pattern_Syntax.\n\tPattern_White_Space                = _Pattern_White_Space                // Pattern_White_Space is the set of Unicode characters with property Pattern_White_Space.\n\tPrepended_Concatenation_Mark       = _Prepended_Concatenation_Mark       // Prepended_Concatenation_Mark is the set of Unicode characters with property Prepended_Concatenation_Mark.\n\tQuotation_Mark                     = _Quotation_Mark                     // Quotation_Mark is the set of Unicode characters with property Quotation_Mark.\n\tRadical                            = _Radical                            // Radical is the set of Unicode characters with property Radical.\n\tRegional_Indicator                 = _Regional_Indicator                 // Regional_Indicator is the set of Unicode characters with property Regional_Indicator.\n\tSTerm                              = _Sentence_Terminal                  // STerm is an alias for Sentence_Terminal.\n\tSentence_Terminal                  = _Sentence_Terminal                  // Sentence_Terminal is the set of Unicode characters with property Sentence_Terminal.\n\tSoft_Dotted                        = _Soft_Dotted                        // Soft_Dotted is the set of Unicode characters with property Soft_Dotted.\n\tTerminal_Punctuation               = _Terminal_Punctuation               // Terminal_Punctuation is the set of Unicode characters with property Terminal_Punctuation.\n\tUnified_Ideograph                  = _Unified_Ideograph                  // Unified_Ideograph is the set of Unicode characters with property Unified_Ideograph.\n\tVariation_Selector                 = _Variation_Selector                 // Variation_Selector is the set of Unicode characters with property Variation_Selector.\n\tWhite_Space                        = _White_Space                        // White_Space is the set of Unicode characters with property White_Space.\n)\n    These variables have type *RangeTable.\n\nvar CaseRanges = _CaseRanges\n    CaseRanges is the table describing case mappings for all letters with\n    non-self mappings.\n\nvar Categories = map[string]*RangeTable{\n\t\"C\":  C,\n\t\"Cc\": Cc,\n\t\"Cf\": Cf,\n\t\"Cn\": Cn,\n\t\"Co\": Co,\n\t\"Cs\": Cs,\n\t\"L\":  L,\n\t\"LC\": LC,\n\t\"Ll\": Ll,\n\t\"Lm\": Lm,\n\t\"Lo\": Lo,\n\t\"Lt\": Lt,\n\t\"Lu\": Lu,\n\t\"M\":  M,\n\t\"Mc\": Mc,\n\t\"Me\": Me,\n\t\"Mn\": Mn,\n\t\"N\":  N,\n\t\"Nd\": Nd,\n\t\"Nl\": Nl,\n\t\"No\": No,\n\t\"P\":  P,\n\t\"Pc\": Pc,\n\t\"Pd\": Pd,\n\t\"Pe\": Pe,\n\t\"Pf\": Pf,\n\t\"Pi\": Pi,\n\t\"Po\": Po,\n\t\"Ps\": Ps,\n\t\"S\":  S,\n\t\"Sc\": Sc,\n\t\"Sk\": Sk,\n\t\"Sm\": Sm,\n\t\"So\": So,\n\t\"Z\":  Z,\n\t\"Zl\": Zl,\n\t\"Zp\": Zp,\n\t\"Zs\": Zs,\n}\n    Categories is the set of Unicode category tables.\n\nvar CategoryAliases = map[string]string{\n\t\"Cased_Letter\":          \"LC\",\n\t\"Close_Punctuation\":     \"Pe\",\n\t\"Combining_Mark\":        \"M\",\n\t\"Connector_Punctuation\": \"Pc\",\n\t\"Control\":               \"Cc\",\n\t\"Currency_Symbol\":       \"Sc\",\n\t\"Dash_Punctuation\":      \"Pd\",\n\t\"Decimal_Number\":        \"Nd\",\n\t\"Enclosing_Mark\":        \"Me\",\n\t\"Final_Punctuation\":     \"Pf\",\n\t\"Format\":                \"Cf\",\n\t\"Initial_Punctuation\":   \"Pi\",\n\t\"Letter\":                \"L\",\n\t\"Letter_Number\":         \"Nl\",\n\t\"Line_Separator\":        \"Zl\",\n\t\"Lowercase_Letter\":      \"Ll\",\n\t\"Mark\":                  \"M\",\n\t\"Math_Symbol\":           \"Sm\",\n\t\"Modifier_Letter\":       \"Lm\",\n\t\"Modifier_Symbol\":       \"Sk\",\n\t\"Nonspacing_Mark\":       \"Mn\",\n\t\"Number\":                \"N\",\n\t\"Open_Punctuation\":      \"Ps\",\n\t\"Other\":                 \"C\",\n\t\"Other_Letter\":          \"Lo\",\n\t\"Other_Number\":          \"No\",\n\t\"Other_Punctuation\":     \"Po\",\n\t\"Other_Symbol\":          \"So\",\n\t\"Paragraph_Separator\":   \"Zp\",\n\t\"Private_Use\":           \"Co\",\n\t\"Punctuation\":           \"P\",\n\t\"Separator\":             \"Z\",\n\t\"Space_Separator\":       \"Zs\",\n\t\"Spacing_Mark\":          \"Mc\",\n\t\"Surrogate\":             \"Cs\",\n\t\"Symbol\":                \"S\",\n\t\"Titlecase_Letter\":      \"Lt\",\n\t\"Unassigned\":            \"Cn\",\n\t\"Uppercase_Letter\":      \"Lu\",\n\t\"cntrl\":                 \"Cc\",\n\t\"digit\":                 \"Nd\",\n\t\"punct\":                 \"P\",\n}\n    CategoryAliases maps category aliases to standard category names.\n\nvar FoldCategory = map[string]*RangeTable{\n\t\"L\":  foldL,\n\t\"Ll\": foldLl,\n\t\"Lt\": foldLt,\n\t\"Lu\": foldLu,\n\t\"M\":  foldM,\n\t\"Mn\": foldMn,\n}\n    FoldCategory maps a category name to a table of code points outside the\n    category that are equivalent under simple case folding to code points inside\n    the category. If there is no entry for a category name, there are no such\n    points.\n\nvar FoldScript = map[string]*RangeTable{\n\t\"Common\":    foldCommon,\n\t\"Greek\":     foldGreek,\n\t\"Inherited\": foldInherited,\n}\n    FoldScript maps a script name to a table of code points outside the script\n    that are equivalent under simple case folding to code points inside the\n    script. If there is no entry for a script name, there are no such points.\n\nvar GraphicRanges = []*RangeTable{\n\tL, M, N, P, S, Zs,\n}\n    GraphicRanges defines the set of graphic characters according to Unicode.\n\nvar PrintRanges = []*RangeTable{\n\tL, M, N, P, S,\n}\n    PrintRanges defines the set of printable characters according to Go.\n    ASCII space, U+0020, is handled separately.\n\nvar Properties = map[string]*RangeTable{\n\t\"ASCII_Hex_Digit\":                    ASCII_Hex_Digit,\n\t\"Bidi_Control\":                       Bidi_Control,\n\t\"Dash\":                               Dash,\n\t\"Deprecated\":                         Deprecated,\n\t\"Diacritic\":                          Diacritic,\n\t\"Extender\":                           Extender,\n\t\"Hex_Digit\":                          Hex_Digit,\n\t\"Hyphen\":                             Hyphen,\n\t\"IDS_Binary_Operator\":                IDS_Binary_Operator,\n\t\"IDS_Trinary_Operator\":               IDS_Trinary_Operator,\n\t\"Ideographic\":                        Ideographic,\n\t\"Join_Control\":                       Join_Control,\n\t\"Logical_Order_Exception\":            Logical_Order_Exception,\n\t\"Noncharacter_Code_Point\":            Noncharacter_Code_Point,\n\t\"Other_Alphabetic\":                   Other_Alphabetic,\n\t\"Other_Default_Ignorable_Code_Point\": Other_Default_Ignorable_Code_Point,\n\t\"Other_Grapheme_Extend\":              Other_Grapheme_Extend,\n\t\"Other_ID_Continue\":                  Other_ID_Continue,\n\t\"Other_ID_Start\":                     Other_ID_Start,\n\t\"Other_Lowercase\":                    Other_Lowercase,\n\t\"Other_Math\":                         Other_Math,\n\t\"Other_Uppercase\":                    Other_Uppercase,\n\t\"Pattern_Syntax\":                     Pattern_Syntax,\n\t\"Pattern_White_Space\":                Pattern_White_Space,\n\t\"Prepended_Concatenation_Mark\":       Prepended_Concatenation_Mark,\n\t\"Quotation_Mark\":                     Quotation_Mark,\n\t\"Radical\":                            Radical,\n\t\"Regional_Indicator\":                 Regional_Indicator,\n\t\"Sentence_Terminal\":                  Sentence_Terminal,\n\t\"STerm\":                              Sentence_Terminal,\n\t\"Soft_Dotted\":                        Soft_Dotted,\n\t\"Terminal_Punctuation\":               Terminal_Punctuation,\n\t\"Unified_Ideograph\":                  Unified_Ideograph,\n\t\"Variation_Selector\":                 Variation_Selector,\n\t\"White_Space\":                        White_Space,\n}\n    Properties is the set of Unicode property tables.\n\nvar Scripts = map[string]*RangeTable{\n\t\"Adlam\":                  Adlam,\n\t\"Ahom\":                   Ahom,\n\t\"Anatolian_Hieroglyphs\":  Anatolian_Hieroglyphs,\n\t\"Arabic\":                 Arabic,\n\t\"Armenian\":               Armenian,\n\t\"Avestan\":                Avestan,\n\t\"Balinese\":               Balinese,\n\t\"Bamum\":                  Bamum,\n\t\"Bassa_Vah\":              Bassa_Vah,\n\t\"Batak\":                  Batak,\n\t\"Bengali\":                Bengali,\n\t\"Bhaiksuki\":              Bhaiksuki,\n\t\"Bopomofo\":               Bopomofo,\n\t\"Brahmi\":                 Brahmi,\n\t\"Braille\":                Braille,\n\t\"Buginese\":               Buginese,\n\t\"Buhid\":                  Buhid,\n\t\"Canadian_Aboriginal\":    Canadian_Aboriginal,\n\t\"Carian\":                 Carian,\n\t\"Caucasian_Albanian\":     Caucasian_Albanian,\n\t\"Chakma\":                 Chakma,\n\t\"Cham\":                   Cham,\n\t\"Cherokee\":               Cherokee,\n\t\"Chorasmian\":             Chorasmian,\n\t\"Common\":                 Common,\n\t\"Coptic\":                 Coptic,\n\t\"Cuneiform\":              Cuneiform,\n\t\"Cypriot\":                Cypriot,\n\t\"Cypro_Minoan\":           Cypro_Minoan,\n\t\"Cyrillic\":               Cyrillic,\n\t\"Deseret\":                Deseret,\n\t\"Devanagari\":             Devanagari,\n\t\"Dives_Akuru\":            Dives_Akuru,\n\t\"Dogra\":                  Dogra,\n\t\"Duployan\":               Duployan,\n\t\"Egyptian_Hieroglyphs\":   Egyptian_Hieroglyphs,\n\t\"Elbasan\":                Elbasan,\n\t\"Elymaic\":                Elymaic,\n\t\"Ethiopic\":               Ethiopic,\n\t\"Georgian\":               Georgian,\n\t\"Glagolitic\":             Glagolitic,\n\t\"Gothic\":                 Gothic,\n\t\"Grantha\":                Grantha,\n\t\"Greek\":                  Greek,\n\t\"Gujarati\":               Gujarati,\n\t\"Gunjala_Gondi\":          Gunjala_Gondi,\n\t\"Gurmukhi\":               Gurmukhi,\n\t\"Han\":                    Han,\n\t\"Hangul\":                 Hangul,\n\t\"Hanifi_Rohingya\":        Hanifi_Rohingya,\n\t\"Hanunoo\":                Hanunoo,\n\t\"Hatran\":                 Hatran,\n\t\"Hebrew\":                 Hebrew,\n\t\"Hiragana\":               Hiragana,\n\t\"Imperial_Aramaic\":       Imperial_Aramaic,\n\t\"Inherited\":              Inherited,\n\t\"Inscriptional_Pahlavi\":  Inscriptional_Pahlavi,\n\t\"Inscriptional_Parthian\": Inscriptional_Parthian,\n\t\"Javanese\":               Javanese,\n\t\"Kaithi\":                 Kaithi,\n\t\"Kannada\":                Kannada,\n\t\"Katakana\":               Katakana,\n\t\"Kawi\":                   Kawi,\n\t\"Kayah_Li\":               Kayah_Li,\n\t\"Kharoshthi\":             Kharoshthi,\n\t\"Khitan_Small_Script\":    Khitan_Small_Script,\n\t\"Khmer\":                  Khmer,\n\t\"Khojki\":                 Khojki,\n\t\"Khudawadi\":              Khudawadi,\n\t\"Lao\":                    Lao,\n\t\"Latin\":                  Latin,\n\t\"Lepcha\":                 Lepcha,\n\t\"Limbu\":                  Limbu,\n\t\"Linear_A\":               Linear_A,\n\t\"Linear_B\":               Linear_B,\n\t\"Lisu\":                   Lisu,\n\t\"Lycian\":                 Lycian,\n\t\"Lydian\":                 Lydian,\n\t\"Mahajani\":               Mahajani,\n\t\"Makasar\":                Makasar,\n\t\"Malayalam\":              Malayalam,\n\t\"Mandaic\":                Mandaic,\n\t\"Manichaean\":             Manichaean,\n\t\"Marchen\":                Marchen,\n\t\"Masaram_Gondi\":          Masaram_Gondi,\n\t\"Medefaidrin\":            Medefaidrin,\n\t\"Meetei_Mayek\":           Meetei_Mayek,\n\t\"Mende_Kikakui\":          Mende_Kikakui,\n\t\"Meroitic_Cursive\":       Meroitic_Cursive,\n\t\"Meroitic_Hieroglyphs\":   Meroitic_Hieroglyphs,\n\t\"Miao\":                   Miao,\n\t\"Modi\":                   Modi,\n\t\"Mongolian\":              Mongolian,\n\t\"Mro\":                    Mro,\n\t\"Multani\":                Multani,\n\t\"Myanmar\":                Myanmar,\n\t\"Nabataean\":              Nabataean,\n\t\"Nag_Mundari\":            Nag_Mundari,\n\t\"Nandinagari\":            Nandinagari,\n\t\"New_Tai_Lue\":            New_Tai_Lue,\n\t\"Newa\":                   Newa,\n\t\"Nko\":                    Nko,\n\t\"Nushu\":                  Nushu,\n\t\"Nyiakeng_Puachue_Hmong\": Nyiakeng_Puachue_Hmong,\n\t\"Ogham\":                  Ogham,\n\t\"Ol_Chiki\":               Ol_Chiki,\n\t\"Old_Hungarian\":          Old_Hungarian,\n\t\"Old_Italic\":             Old_Italic,\n\t\"Old_North_Arabian\":      Old_North_Arabian,\n\t\"Old_Permic\":             Old_Permic,\n\t\"Old_Persian\":            Old_Persian,\n\t\"Old_Sogdian\":            Old_Sogdian,\n\t\"Old_South_Arabian\":      Old_South_Arabian,\n\t\"Old_Turkic\":             Old_Turkic,\n\t\"Old_Uyghur\":             Old_Uyghur,\n\t\"Oriya\":                  Oriya,\n\t\"Osage\":                  Osage,\n\t\"Osmanya\":                Osmanya,\n\t\"Pahawh_Hmong\":           Pahawh_Hmong,\n\t\"Palmyrene\":              Palmyrene,\n\t\"Pau_Cin_Hau\":            Pau_Cin_Hau,\n\t\"Phags_Pa\":               Phags_Pa,\n\t\"Phoenician\":             Phoenician,\n\t\"Psalter_Pahlavi\":        Psalter_Pahlavi,\n\t\"Rejang\":                 Rejang,\n\t\"Runic\":                  Runic,\n\t\"Samaritan\":              Samaritan,\n\t\"Saurashtra\":             Saurashtra,\n\t\"Sharada\":                Sharada,\n\t\"Shavian\":                Shavian,\n\t\"Siddham\":                Siddham,\n\t\"SignWriting\":            SignWriting,\n\t\"Sinhala\":                Sinhala,\n\t\"Sogdian\":                Sogdian,\n\t\"Sora_Sompeng\":           Sora_Sompeng,\n\t\"Soyombo\":                Soyombo,\n\t\"Sundanese\":              Sundanese,\n\t\"Syloti_Nagri\":           Syloti_Nagri,\n\t\"Syriac\":                 Syriac,\n\t\"Tagalog\":                Tagalog,\n\t\"Tagbanwa\":               Tagbanwa,\n\t\"Tai_Le\":                 Tai_Le,\n\t\"Tai_Tham\":               Tai_Tham,\n\t\"Tai_Viet\":               Tai_Viet,\n\t\"Takri\":                  Takri,\n\t\"Tamil\":                  Tamil,\n\t\"Tangsa\":                 Tangsa,\n\t\"Tangut\":                 Tangut,\n\t\"Telugu\":                 Telugu,\n\t\"Thaana\":                 Thaana,\n\t\"Thai\":                   Thai,\n\t\"Tibetan\":                Tibetan,\n\t\"Tifinagh\":               Tifinagh,\n\t\"Tirhuta\":                Tirhuta,\n\t\"Toto\":                   Toto,\n\t\"Ugaritic\":               Ugaritic,\n\t\"Vai\":                    Vai,\n\t\"Vithkuqi\":               Vithkuqi,\n\t\"Wancho\":                 Wancho,\n\t\"Warang_Citi\":            Warang_Citi,\n\t\"Yezidi\":                 Yezidi,\n\t\"Yi\":                     Yi,\n\t\"Zanabazar_Square\":       Zanabazar_Square,\n}\n    Scripts is the set of Unicode script tables.\n\n\nFUNCTIONS\n\nfunc In(r rune, ranges ...*RangeTable) bool\n    In reports whether the rune is a member of one of the ranges.\n\nfunc Is(rangeTab *RangeTable, r rune) bool\n    Is reports whether the rune is in the specified table of ranges.\n\nfunc IsControl(r rune) bool\n    IsControl reports whether the rune is a control character. The C (Other)\n    Unicode category includes more code points such as surrogates; use Is(C,\n    r) to test for them.\n\nfunc IsDigit(r rune) bool\n    IsDigit reports whether the rune is a decimal digit.\n\nfunc IsGraphic(r rune) bool\n    IsGraphic reports whether the rune is defined as a Graphic by Unicode.\n    Such characters include letters, marks, numbers, punctuation, symbols,\n    and spaces, from categories L, M, N, P, S, Zs.\n\nfunc IsLetter(r rune) bool\n    IsLetter reports whether the rune is a letter (category L).\n\nfunc IsLower(r rune) bool\n    IsLower reports whether the rune is a lower case letter.\n\nfunc IsMark(r rune) bool\n    IsMark reports whether the rune is a mark character (category M).\n\nfunc IsNumber(r rune) bool\n    IsNumber reports whether the rune is a number (category N).\n\nfunc IsOneOf(ranges []*RangeTable, r rune) bool\n    IsOneOf reports whether the rune is a member of one of the ranges. The\n    function \"In\" provides a nicer signature and should be used in preference to\n    IsOneOf.\n\nfunc IsPrint(r rune) bool\n    IsPrint reports whether the rune is defined as printable by Go. Such\n    characters include letters, marks, numbers, punctuation, symbols, and the\n    ASCII space character, from categories L, M, N, P, S and the ASCII space\n    character. This categorization is the same as IsGraphic except that the only\n    spacing character is ASCII space, U+0020.\n\nfunc IsPunct(r rune) bool\n    IsPunct reports whether the rune is a Unicode punctuation character\n    (category P).\n\nfunc IsSpace(r rune) bool\n    IsSpace reports whether the rune is a space character as defined by\n    Unicode's White Space property; in the Latin-1 space this is\n\n        '\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\n\n    Other definitions of spacing characters are set by category Z and property\n    Pattern_White_Space.\n\nfunc IsSymbol(r rune) bool\n    IsSymbol reports whether the rune is a symbolic character.\n\nfunc IsTitle(r rune) bool\n    IsTitle reports whether the rune is a title case letter.\n\nfunc IsUpper(r rune) bool\n    IsUpper reports whether the rune is an upper case letter.\n\nfunc SimpleFold(r rune) rune\n    SimpleFold iterates over Unicode code points equivalent under the\n    Unicode-defined simple case folding. Among the code points equivalent to\n    rune (including rune itself), SimpleFold returns the smallest rune > r if\n    one exists, or else the smallest rune >= 0. If r is not a valid Unicode code\n    point, SimpleFold(r) returns r.\n\n    For example:\n\n        SimpleFold('A') = 'a'\n        SimpleFold('a') = 'A'\n\n        SimpleFold('K') = 'k'\n        SimpleFold('k') = '\\u212A' (Kelvin symbol, \u212a)\n        SimpleFold('\\u212A') = 'K'\n\n        SimpleFold('1') = '1'\n\n        SimpleFold(-2) = -2\n\nfunc To(_case int, r rune) rune\n    To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.\n\nfunc ToLower(r rune) rune\n    ToLower maps the rune to lower case.\n\nfunc ToTitle(r rune) rune\n    ToTitle maps the rune to title case.\n\nfunc ToUpper(r rune) rune\n    ToUpper maps the rune to upper case.\n\n\nTYPES\n\ntype CaseRange struct {\n\tLo    uint32\n\tHi    uint32\n\tDelta d\n}\n    CaseRange represents a range of Unicode code points for simple (one code\n    point to one code point) case conversion. The range runs from Lo to Hi\n    inclusive, with a fixed stride of 1. Deltas are the number to add to the\n    code point to reach the code point for a different case for that character.\n    They may be negative. If zero, it means the character is in the\n    corresponding case. There is a special case representing sequences of\n    alternating corresponding Upper and Lower pairs. It appears with a fixed\n    Delta of\n\n        {UpperLower, UpperLower, UpperLower}\n\n    The constant UpperLower has an otherwise impossible delta value.\n\ntype Range16 struct {\n\tLo     uint16\n\tHi     uint16\n\tStride uint16\n}\n    Range16 represents of a range of 16-bit Unicode code points. The range runs\n    from Lo to Hi inclusive and has the specified stride.\n\ntype Range32 struct {\n\tLo     uint32\n\tHi     uint32\n\tStride uint32\n}\n    Range32 represents of a range of Unicode code points and is used when one\n    or more of the values will not fit in 16 bits. The range runs from Lo to Hi\n    inclusive and has the specified stride. Lo and Hi must always be >= 1<<16.\n\ntype RangeTable struct {\n\tR16         []Range16\n\tR32         []Range32\n\tLatinOffset int // number of entries in R16 with Hi <= MaxLatin1\n}\n    RangeTable defines a set of Unicode code points by listing the ranges of\n    code points within the set. The ranges are listed in two slices to save\n    space: a slice of 16-bit ranges and a slice of 32-bit ranges. The two slices\n    must be in sorted order and non-overlapping. Also, R32 should contain only\n    values >= 0x10000 (1<<16).\n\ntype SpecialCase []CaseRange\n    SpecialCase represents language-specific case mappings such as Turkish.\n    Methods of SpecialCase customize (by overriding) the standard mappings.\n\nvar AzeriCase SpecialCase = _TurkishCase\nvar TurkishCase SpecialCase = _TurkishCase\nfunc (special SpecialCase) ToLower(r rune) rune\n    ToLower maps the rune to lower case giving priority to the special mapping.\n\nfunc (special SpecialCase) ToTitle(r rune) rune\n    ToTitle maps the rune to title case giving priority to the special mapping.\n\nfunc (special SpecialCase) ToUpper(r rune) rune\n    ToUpper maps the rune to upper case giving priority to the special mapping.\n\n\nBUG: There is no mechanism for full case folding, that is, for\ncharacters that involve multiple runes in the input or output.\n\n"}, {"path": "stdlib/internal-saferio.md", "category": "stdlib", "name": "stdlib/internal-saferio", "content": "package saferio // import \"internal/saferio\"\n\nPackage saferio provides I/O functions that avoid allocating large amounts\nof memory unnecessarily. This is intended for packages that read data from an\nio.Reader where the size is part of the input data but the input may be corrupt,\nor may be provided by an untrustworthy attacker.\n\nFUNCTIONS\n\nfunc ReadData(r io.Reader, n uint64) ([]byte, error)\n    ReadData reads n bytes from the input stream, but avoids allocating all n\n    bytes if n is large. This avoids crashing the program by allocating all n\n    bytes in cases where n is incorrect.\n\n    The error is io.EOF only if no bytes were read. If an io.EOF happens after\n    reading some but not all the bytes, ReadData returns io.ErrUnexpectedEOF.\n\nfunc ReadDataAt(r io.ReaderAt, n uint64, off int64) ([]byte, error)\n    ReadDataAt reads n bytes from the input stream at off, but avoids allocating\n    all n bytes if n is large. This avoids crashing the program by allocating\n    all n bytes in cases where n is incorrect.\n\nfunc SliceCap[E any](c uint64) int\n    SliceCap is like SliceCapWithSize but using generics.\n\nfunc SliceCapWithSize(size, c uint64) int\n    SliceCapWithSize returns the capacity to use when allocating a slice. After\n    the slice is allocated with the capacity, it should be built using append.\n    This will avoid allocating too much memory if the capacity is large and\n    incorrect.\n\n    A negative result means that the value is always too big.\n\n"}, {"path": "stdlib/crypto-subtle.md", "category": "stdlib", "name": "stdlib/crypto-subtle", "content": "package subtle // import \"crypto/subtle\"\n\nPackage subtle implements functions that are often useful in cryptographic code\nbut require careful thought to use correctly.\n\nFUNCTIONS\n\nfunc ConstantTimeByteEq(x, y uint8) int\n    ConstantTimeByteEq returns 1 if x == y and 0 otherwise.\n\nfunc ConstantTimeCompare(x, y []byte) int\n    ConstantTimeCompare returns 1 if the two slices, x and y, have equal\n    contents and 0 otherwise. The time taken is a function of the length of the\n    slices and is independent of the contents. If the lengths of x and y do not\n    match it returns 0 immediately.\n\nfunc ConstantTimeCopy(v int, x, y []byte)\n    ConstantTimeCopy copies the contents of y into x (a slice of equal length)\n    if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v\n    takes any other value.\n\nfunc ConstantTimeEq(x, y int32) int\n    ConstantTimeEq returns 1 if x == y and 0 otherwise.\n\nfunc ConstantTimeLessOrEq(x, y int) int\n    ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise. Its behavior is\n    undefined if x or y are negative or > 2**31 - 1.\n\nfunc ConstantTimeSelect(v, x, y int) int\n    ConstantTimeSelect returns x if v == 1 and y if v == 0. Its behavior is\n    undefined if v takes any other value.\n\nfunc WithDataIndependentTiming(f func())\n    WithDataIndependentTiming enables architecture specific features which\n    ensure that the timing of specific instructions is independent of their\n    inputs before executing f. On f returning it disables these features.\n\n    WithDataIndependentTiming should only be used when f is written to make\n    use of constant-time operations. WithDataIndependentTiming does not make\n    variable-time code constant-time.\n\n    WithDataIndependentTiming may lock the current goroutine to the OS thread\n    for the duration of f. Calls to WithDataIndependentTiming may be nested.\n\n    On Arm64 processors with FEAT_DIT,\n    WithDataIndependentTiming enables PSTATE.DIT. See\n    https://developer.arm.com/documentation/ka005181/1-0/?lang=en.\n\n    Currently, on all other architectures WithDataIndependentTiming executes f\n    immediately with no other side-effects.\n\nfunc XORBytes(dst, x, y []byte) int\n    XORBytes sets dst[i] = x[i] ^ y[i] for all i < n = min(len(x), len(y)),\n    returning n, the number of bytes written to dst.\n\n    If dst does not have length at least n, XORBytes panics without writing\n    anything to dst.\n\n    dst and x or y may overlap exactly or not at all, otherwise XORBytes may\n    panic.\n\n"}, {"path": "stdlib/net-http-cgi.md", "category": "stdlib", "name": "stdlib/net-http-cgi", "content": "package cgi // import \"net/http/cgi\"\n\nPackage cgi implements CGI (Common Gateway Interface) as specified in RFC 3875.\n\nNote that using CGI means starting a new process to handle each request,\nwhich is typically less efficient than using a long-running server. This package\nis intended primarily for compatibility with existing systems.\n\nFUNCTIONS\n\nfunc Request() (*http.Request, error)\n    Request returns the HTTP request as represented in the current environment.\n    This assumes the current program is being run by a web server in a CGI\n    environment. The returned Request's Body is populated, if applicable.\n\nfunc RequestFromMap(params map[string]string) (*http.Request, error)\n    RequestFromMap creates an http.Request from CGI variables. The returned\n    Request's Body field is not populated.\n\nfunc Serve(handler http.Handler) error\n    Serve executes the provided Handler on the currently active CGI request,\n    if any. If there's no current CGI environment an error is returned.\n    The provided handler may be nil to use http.DefaultServeMux.\n\n\nTYPES\n\ntype Handler struct {\n\tPath string // path to the CGI executable\n\tRoot string // root URI prefix of handler or empty for \"/\"\n\n\t// Dir specifies the CGI executable's working directory.\n\t// If Dir is empty, the base directory of Path is used.\n\t// If Path has no base directory, the current working\n\t// directory is used.\n\tDir string\n\n\tEnv        []string    // extra environment variables to set, if any, as \"key=value\"\n\tInheritEnv []string    // environment variables to inherit from host, as \"key\"\n\tLogger     *log.Logger // optional log for errors or nil to use log.Print\n\tArgs       []string    // optional arguments to pass to child process\n\tStderr     io.Writer   // optional stderr for the child process; nil means os.Stderr\n\n\t// PathLocationHandler specifies the root http Handler that\n\t// should handle internal redirects when the CGI process\n\t// returns a Location header value starting with a \"/\", as\n\t// specified in RFC 3875 \u00a7 6.3.2. This will likely be\n\t// http.DefaultServeMux.\n\t//\n\t// If nil, a CGI response with a local URI path is instead sent\n\t// back to the client and not redirected internally.\n\tPathLocationHandler http.Handler\n}\n    Handler runs an executable in a subprocess with a CGI environment.\n\nfunc (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request)\n\n"}, {"path": "stdlib/html-template.md", "category": "stdlib", "name": "stdlib/html-template", "content": "package template // import \"html/template\"\n\nPackage template (html/template) implements data-driven templates for generating\nHTML output safe against code injection. It provides the same interface as\ntext/template and should be used instead of text/template whenever the output is\nHTML.\n\nThe documentation here focuses on the security features of the package. For\ninformation about how to program the templates themselves, see the documentation\nfor text/template.\n\n# Introduction\n\nThis package wraps text/template so you can share its template API to parse and\nexecute HTML templates safely.\n\n    tmpl, err := template.New(\"name\").Parse(...)\n    // Error checking elided\n    err = tmpl.Execute(out, data)\n\nIf successful, tmpl will now be injection-safe. Otherwise, err is an error\ndefined in the docs for ErrorCode.\n\nHTML templates treat data values as plain text which should be encoded so\nthey can be safely embedded in an HTML document. The escaping is contextual,\nso actions can appear within JavaScript, CSS, and URI contexts.\n\nComments are stripped from output, except for those passed in via the HTML, CSS,\nand JS types for their respective contexts.\n\nThe security model used by this package assumes that template authors are\ntrusted, while Execute's data parameter is not. More details are provided below.\n\nExample\n\n    import \"text/template\"\n    ...\n    t, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n    err = t.ExecuteTemplate(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n\nproduces\n\n    Hello, <script>alert('you have been pwned')</script>!\n\nbut the contextual autoescaping in html/template\n\n    import \"html/template\"\n    ...\n    t, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n    err = t.ExecuteTemplate(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n\nproduces safe, escaped HTML output\n\n    Hello, &lt;script&gt;alert(&#39;you have been pwned&#39;)&lt;/script&gt;!\n\n# Contexts\n\nThis package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing\nfunctions to each simple action pipeline, so given the excerpt\n\n    <a href=\"/search?q={{.}}\">{{.}}</a>\n\nAt parse time each {{.}} is overwritten to add escaping functions as necessary.\nIn this case it becomes\n\n    <a href=\"/search?q={{. | urlescaper | attrescaper}}\">{{. | htmlescaper}}</a>\n\nwhere urlescaper, attrescaper, and htmlescaper are aliases for internal escaping\nfunctions.\n\nFor these internal escaping functions, if an action pipeline evaluates to a nil\ninterface value, it is treated as though it were an empty string.\n\n# Namespaced and data- attributes\n\nAttributes with a namespace are treated as if they had no namespace. Given the\nexcerpt\n\n    <a my:href=\"{{.}}\"></a>\n\nAt parse time the attribute will be treated as if it were just \"href\". So at\nparse time the template becomes:\n\n    <a my:href=\"{{. | urlescaper | attrescaper}}\"></a>\n\nSimilarly to attributes with namespaces, attributes with a \"data-\" prefix are\ntreated as if they had no \"data-\" prefix. So given\n\n    <a data-href=\"{{.}}\"></a>\n\nAt parse time this becomes\n\n    <a data-href=\"{{. | urlescaper | attrescaper}}\"></a>\n\nIf an attribute has both a namespace and a \"data-\" prefix, only the namespace\nwill be removed when determining the context. For example\n\n    <a my:data-href=\"{{.}}\"></a>\n\nThis is handled as if \"my:data-href\" was just \"data-href\" and not \"href\" as it\nwould be if the \"data-\" prefix were to be ignored too. Thus at parse time this\nbecomes just\n\n    <a my:data-href=\"{{. | attrescaper}}\"></a>\n\nAs a special case, attributes with the namespace \"xmlns\" are always treated as\ncontaining URLs. Given the excerpts\n\n    <a xmlns:title=\"{{.}}\"></a>\n    <a xmlns:href=\"{{.}}\"></a>\n    <a xmlns:onclick=\"{{.}}\"></a>\n\nAt parse time they become:\n\n    <a xmlns:title=\"{{. | urlescaper | attrescaper}}\"></a>\n    <a xmlns:href=\"{{. | urlescaper | attrescaper}}\"></a>\n    <a xmlns:onclick=\"{{. | urlescaper | attrescaper}}\"></a>\n\n# Errors\n\nSee the documentation of ErrorCode for details.\n\n# A fuller picture\n\nThe rest of this package comment may be skipped on first reading; it includes\ndetails necessary to understand escaping contexts and error messages. Most users\nwill not need to understand these details.\n\n# Contexts\n\nAssuming {{.}} is `O'Reilly: How are <i>you</i>?`, the table below shows how\n{{.}} appears when used in the context to the left.\n\n    Context                          {{.}} After\n    {{.}}                            O'Reilly: How are &lt;i&gt;you&lt;/i&gt;?\n    <a title='{{.}}'>                O&#39;Reilly: How are you?\n    <a href=\"/{{.}}\">                O&#39;Reilly: How are %3ci%3eyou%3c/i%3e?\n    <a href=\"?q={{.}}\">              O&#39;Reilly%3a%20How%20are%3ci%3e...%3f\n    <a onx='f(\"{{.}}\")'>             O\\x27Reilly: How are \\x3ci\\x3eyou...?\n    <a onx='f({{.}})'>               \"O\\x27Reilly: How are \\x3ci\\x3eyou...?\"\n    <a onx='pattern = /{{.}}/;'>     O\\x27Reilly: How are \\x3ci\\x3eyou...\\x3f\n\nIf used in an unsafe context, then the value might be filtered out:\n\n    Context                          {{.}} After\n    <a href=\"{{.}}\">                 #ZgotmplZ\n\nsince \"O'Reilly:\" is not an allowed protocol like \"http:\".\n\nIf {{.}} is the innocuous word, `left`, then it can appear more widely,\n\n    Context                              {{.}} After\n    {{.}}                                left\n    <a title='{{.}}'>                    left\n    <a href='{{.}}'>                     left\n    <a href='/{{.}}'>                    left\n    <a href='?dir={{.}}'>                left\n    <a style=\"border-{{.}}: 4px\">        left\n    <a style=\"align: {{.}}\">             left\n    <a style=\"background: '{{.}}'>       left\n    <a style=\"background: url('{{.}}')>  left\n    <style>p.{{.}} {color:red}</style>   left\n\nNon-string values can be used in JavaScript contexts. If {{.}} is\n\n    struct{A,B string}{ \"foo\", \"bar\" }\n\nin the escaped template\n\n    <script>var pair = {{.}};</script>\n\nthen the template output is\n\n    <script>var pair = {\"A\": \"foo\", \"B\": \"bar\"};</script>\n\nSee package json to understand how non-string content is marshaled for embedding\nin JavaScript contexts.\n\n# Typed Strings\n\nBy default, this package assumes that all pipelines produce a plain text string.\nIt adds escaping pipeline stages necessary to correctly and safely embed that\nplain text string in the appropriate context.\n\nWhen a data value is not plain text, you can make sure it is not over-escaped by\nmarking it with its type.\n\nTypes HTML, JS, URL, and others from content.go can carry safe content that is\nexempted from escaping.\n\nThe template\n\n    Hello, {{.}}!\n\ncan be invoked with\n\n    tmpl.Execute(out, template.HTML(`<b>World</b>`))\n\nto produce\n\n    Hello, <b>World</b>!\n\ninstead of the\n\n    Hello, &lt;b&gt;World&lt;b&gt;!\n\nthat would have been produced if {{.}} was a regular string.\n\n# Security Model\n\nhttps://web.archive.org/web/20160501113828/http://js-quasis-libraries-and-repl.googlecode.com/svn/trunk/safetemplate.html#problem_definition\ndefines \"safe\" as used by this package.\n\nThis package assumes that template authors are trusted, that Execute's data\nparameter is not, and seeks to preserve the properties below in the face of\nuntrusted data:\n\nStructure Preservation Property: \"... when a template author writes an HTML tag\nin a safe templating language, the browser will interpret the corresponding\nportion of the output as a tag regardless of the values of untrusted data,\nand similarly for other structures such as attribute boundaries and JS and CSS\nstring boundaries.\"\n\nCode Effect Property: \"... only code specified by the template author should run\nas a result of injecting the template output into a page and all code specified\nby the template author should run as a result of the same.\"\n\nLeast Surprise Property: \"A developer (or code reviewer) familiar with HTML,\nCSS, and JavaScript, who knows that contextual autoescaping happens should be\nable to look at a {{.}} and correctly infer what sanitization happens.\"\n\nPreviously, ECMAScript 6 template literal were disabled by default,\nand could be enabled with the GODEBUG=jstmpllitinterp=1 environment variable.\nTemplate literals are now supported by default, and setting jstmpllitinterp has\nno effect.\n\nFUNCTIONS\n\nfunc HTMLEscape(w io.Writer, b []byte)\n    HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n\nfunc HTMLEscapeString(s string) string\n    HTMLEscapeString returns the escaped HTML equivalent of the plain text data\n    s.\n\nfunc HTMLEscaper(args ...any) string\n    HTMLEscaper returns the escaped HTML equivalent of the textual\n    representation of its arguments.\n\nfunc IsTrue(val any) (truth, ok bool)\n    IsTrue reports whether the value is 'true', in the sense of not the zero of\n    its type, and whether the value has a meaningful truth value. This is the\n    definition of truth used by if and other such actions.\n\nfunc JSEscape(w io.Writer, b []byte)\n    JSEscape writes to w the escaped JavaScript equivalent of the plain text\n    data b.\n\nfunc JSEscapeString(s string) string\n    JSEscapeString returns the escaped JavaScript equivalent of the plain text\n    data s.\n\nfunc JSEscaper(args ...any) string\n    JSEscaper returns the escaped JavaScript equivalent of the textual\n    representation of its arguments.\n\nfunc URLQueryEscaper(args ...any) string\n    URLQueryEscaper returns the escaped value of the textual representation of\n    its arguments in a form suitable for embedding in a URL query.\n\n\nTYPES\n\ntype CSS string\n    CSS encapsulates known safe content that matches any of:\n     1. The CSS3 stylesheet production, such as `p { color: purple }`.\n     2. The CSS3 rule production, such as `a[href=~\"https:\"].foo#bar`.\n     3. CSS3 declaration productions, such as `color: red; margin: 2px`.\n     4. The CSS3 value production, such as `rgba(0, 0, 255, 127)`.\n\n    See https://www.w3.org/TR/css3-syntax/#parsing and\n    https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style\n\n    Use of this type presents a security risk: the encapsulated content should\n    come from a trusted source, as it will be included verbatim in the template\n    output.\n\ntype Error struct {\n\t// ErrorCode describes the kind of error.\n\tErrorCode ErrorCode\n\t// Node is the node that caused the problem, if known.\n\t// If not nil, it overrides Name and Line.\n\tNode parse.Node\n\t// Name is the name of the template in which the error was encountered.\n\tName string\n\t// Line is the line number of the error in the template source or 0.\n\tLine int\n\t// Description is a human-readable description of the problem.\n\tDescription string\n}\n    Error describes a problem encountered during template Escaping.\n\nfunc (e *Error) Error() string\n\ntype ErrorCode int\n    ErrorCode is a code for a kind of error.\n\nconst (\n\t// OK indicates the lack of an error.\n\tOK ErrorCode = iota\n\n\t// ErrAmbigContext: \"... appears in an ambiguous context within a URL\"\n\t// Example:\n\t//   <a href=\"\n\t//      {{if .C}}\n\t//        /path/\n\t//      {{else}}\n\t//        /search?q=\n\t//      {{end}}\n\t//      {{.X}}\n\t//   \">\n\t// Discussion:\n\t//   {{.X}} is in an ambiguous URL context since, depending on {{.C}},\n\t//  it may be either a URL suffix or a query parameter.\n\t//   Moving {{.X}} into the condition removes the ambiguity:\n\t//   <a href=\"{{if .C}}/path/{{.X}}{{else}}/search?q={{.X}}\">\n\tErrAmbigContext\n\n\t// ErrBadHTML: \"expected space, attr name, or end of tag, but got ...\",\n\t//   \"... in unquoted attr\", \"... in attribute name\"\n\t// Example:\n\t//   <a href = /search?q=foo>\n\t//   <href=foo>\n\t//   <form na<e=...>\n\t//   <option selected<\n\t// Discussion:\n\t//   This is often due to a typo in an HTML element, but some runes\n\t//   are banned in tag names, attribute names, and unquoted attribute\n\t//   values because they can tickle parser ambiguities.\n\t//   Quoting all attributes is the best policy.\n\tErrBadHTML\n\n\t// ErrBranchEnd: \"{{if}} branches end in different contexts\"\n\t// Examples:\n\t//   {{if .C}}<a href=\"{{end}}{{.X}}\n\t//   <script {{with .T}}type=\"{{.}}\"{{end}}>\n\t// Discussion:\n\t//   Package html/template statically examines each path through an\n\t//   {{if}}, {{range}}, or {{with}} to escape any following pipelines.\n\t//   The first example is ambiguous since {{.X}} might be an HTML text node,\n\t//   or a URL prefix in an HTML attribute. The context of {{.X}} is\n\t//   used to figure out how to escape it, but that context depends on\n\t//   the run-time value of {{.C}} which is not statically known.\n\t//   The second example is ambiguous as the script type attribute\n\t//   can change the type of escaping needed for the script contents.\n\t//\n\t//   The problem is usually something like missing quotes or angle\n\t//   brackets, or can be avoided by refactoring to put the two contexts\n\t//   into different branches of an if, range or with. If the problem\n\t//   is in a {{range}} over a collection that should never be empty,\n\t//   adding a dummy {{else}} can help.\n\tErrBranchEnd\n\n\t// ErrEndContext: \"... ends in a non-text context: ...\"\n\t// Examples:\n\t//   <div\n\t//   <div title=\"no close quote>\n\t//   <script>f()\n\t// Discussion:\n\t//   Executed templates should produce a DocumentFragment of HTML.\n\t//   Templates that end without closing tags will trigger this error.\n\t//   Templates that should not be used in an HTML context or that\n\t//   produce incomplete Fragments should not be executed directly.\n\t//\n\t//   {{define \"main\"}} <script>{{template \"helper\"}}</script> {{end}}\n\t//   {{define \"helper\"}} document.write(' <div title=\" ') {{end}}\n\t//\n\t//   \"helper\" does not produce a valid document fragment, so should\n\t//   not be Executed directly.\n\tErrEndContext\n\n\t// ErrNoSuchTemplate: \"no such template ...\"\n\t// Examples:\n\t//   {{define \"main\"}}<div {{template \"attrs\"}}>{{end}}\n\t//   {{define \"attrs\"}}href=\"{{.URL}}\"{{end}}\n\t// Discussion:\n\t//   Package html/template looks through template calls to compute the\n\t//   context.\n\t//   Here the {{.URL}} in \"attrs\" must be treated as a URL when called\n\t//   from \"main\", but you will get this error if \"attrs\" is not defined\n\t//   when \"main\" is parsed.\n\tErrNoSuchTemplate\n\n\t// ErrOutputContext: \"cannot compute output context for template ...\"\n\t// Examples:\n\t//   {{define \"t\"}}{{if .T}}{{template \"t\" .T}}{{end}}{{.H}}\",{{end}}\n\t// Discussion:\n\t//   A recursive template does not end in the same context in which it\n\t//   starts, and a reliable output context cannot be computed.\n\t//   Look for typos in the named template.\n\t//   If the template should not be called in the named start context,\n\t//   look for calls to that template in unexpected contexts.\n\t//   Maybe refactor recursive templates to not be recursive.\n\tErrOutputContext\n\n\t// ErrPartialCharset: \"unfinished JS regexp charset in ...\"\n\t// Example:\n\t//     <script>var pattern = /foo[{{.Chars}}]/</script>\n\t// Discussion:\n\t//   Package html/template does not support interpolation into regular\n\t//   expression literal character sets.\n\tErrPartialCharset\n\n\t// ErrPartialEscape: \"unfinished escape sequence in ...\"\n\t// Example:\n\t//   <script>alert(\"\\{{.X}}\")</script>\n\t// Discussion:\n\t//   Package html/template does not support actions following a\n\t//   backslash.\n\t//   This is usually an error and there are better solutions; for\n\t//   example\n\t//     <script>alert(\"{{.X}}\")</script>\n\t//   should work, and if {{.X}} is a partial escape sequence such as\n\t//   \"xA0\", mark the whole sequence as safe content: JSStr(`\\xA0`)\n\tErrPartialEscape\n\n\t// ErrRangeLoopReentry: \"on range loop re-entry: ...\"\n\t// Example:\n\t//   <script>var x = [{{range .}}'{{.}},{{end}}]</script>\n\t// Discussion:\n\t//   If an iteration through a range would cause it to end in a\n\t//   different context than an earlier pass, there is no single context.\n\t//   In the example, there is missing a quote, so it is not clear\n\t//   whether {{.}} is meant to be inside a JS string or in a JS value\n\t//   context. The second iteration would produce something like\n\t//\n\t//     <script>var x = ['firstValue,'secondValue]</script>\n\tErrRangeLoopReentry\n\n\t// ErrSlashAmbig: '/' could start a division or regexp.\n\t// Example:\n\t//   <script>\n\t//     {{if .C}}var x = 1{{end}}\n\t//     /-{{.N}}/i.test(x) ? doThis : doThat();\n\t//   </script>\n\t// Discussion:\n\t//   The example above could produce `var x = 1/-2/i.test(s)...`\n\t//   in which the first '/' is a mathematical division operator or it\n\t//   could produce `/-2/i.test(s)` in which the first '/' starts a\n\t//   regexp literal.\n\t//   Look for missing semicolons inside branches, and maybe add\n\t//   parentheses to make it clear which interpretation you intend.\n\tErrSlashAmbig\n\n\t// ErrPredefinedEscaper: \"predefined escaper ... disallowed in template\"\n\t// Example:\n\t//   <div class={{. | html}}>Hello<div>\n\t// Discussion:\n\t//   Package html/template already contextually escapes all pipelines to\n\t//   produce HTML output safe against code injection. Manually escaping\n\t//   pipeline output using the predefined escapers \"html\" or \"urlquery\" is\n\t//   unnecessary, and may affect the correctness or safety of the escaped\n\t//   pipeline output in Go 1.8 and earlier.\n\t//\n\t//   In most cases, such as the given example, this error can be resolved by\n\t//   simply removing the predefined escaper from the pipeline and letting the\n\t//   contextual autoescaper handle the escaping of the pipeline. In other\n\t//   instances, where the predefined escaper occurs in the middle of a\n\t//   pipeline where subsequent commands expect escaped input, e.g.\n\t//     {{.X | html | makeALink}}\n\t//   where makeALink does\n\t//     return `<a href=\"`+input+`\">link</a>`\n\t//   consider refactoring the surrounding template to make use of the\n\t//   contextual autoescaper, i.e.\n\t//     <a href=\"{{.X}}\">link</a>\n\t//\n\t//   To ease migration to Go 1.9 and beyond, \"html\" and \"urlquery\" will\n\t//   continue to be allowed as the last command in a pipeline. However, if the\n\t//   pipeline occurs in an unquoted attribute value context, \"html\" is\n\t//   disallowed. Avoid using \"html\" and \"urlquery\" entirely in new templates.\n\tErrPredefinedEscaper\n\n\t// ErrJSTemplate: \"... appears in a JS template literal\"\n\t// Example:\n\t//     <script>var tmpl = `{{.Interp}}`</script>\n\t// Discussion:\n\t//   Package html/template does not support actions inside of JS template\n\t//   literals.\n\t//\n\t// Deprecated: ErrJSTemplate is no longer returned when an action is present\n\t// in a JS template literal. Actions inside of JS template literals are now\n\t// escaped as expected.\n\tErrJSTemplate\n)\n    We define codes for each error that manifests while escaping templates,\n    but escaped templates may also fail at runtime.\n\n    Output: \"ZgotmplZ\" Example:\n\n        <img src=\"{{.X}}\">\n        where {{.X}} evaluates to `javascript:...`\n\n    Discussion:\n\n        \"ZgotmplZ\" is a special value that indicates that unsafe content reached a\n        CSS or URL context at runtime. The output of the example will be\n          <img src=\"#ZgotmplZ\">\n        If the data comes from a trusted source, use content types to exempt it\n        from filtering: URL(`javascript:...`).\n\ntype FuncMap = template.FuncMap\n\ntype HTML string\n    HTML encapsulates a known safe HTML document fragment. It should not be\n    used for HTML from a third-party, or HTML with unclosed tags or comments.\n    The outputs of a sound HTML sanitizer and a template escaped by this package\n    are fine for use with HTML.\n\n    Use of this type presents a security risk: the encapsulated content should\n    come from a trusted source, as it will be included verbatim in the template\n    output.\n\ntype HTMLAttr string\n    HTMLAttr encapsulates an HTML attribute from a trusted source, for example,\n    ` dir=\"ltr\"`.\n\n    Use of this type presents a security risk: the encapsulated content should\n    come from a trusted source, as it will be included verbatim in the template\n    output.\n\ntype JS string\n    JS encapsulates a known safe EcmaScript5 Expression, for example,\n    `(x + y * z())`. Template authors are responsible for ensuring that typed\n    expressions do not break the intended precedence and that there is no\n    statement/expression ambiguity as when passing an expression like \"{ foo:\n    bar() }\\n['foo']()\", which is both a valid Expression and a valid Program\n    with a very different meaning.\n\n    Use of this type presents a security risk: the encapsulated content should\n    come from a trusted source, as it will be included verbatim in the template\n    output.\n\n    Using JS to include valid but untrusted JSON is not safe. A safe alternative\n    is to parse the JSON with json.Unmarshal and then pass the resultant\n    object into the template, where it will be converted to sanitized JSON when\n    presented in a JavaScript context.\n\ntype JSStr string\n    JSStr encapsulates a sequence of characters meant to be embedded between\n    quotes in a JavaScript expression. The string must match a series of\n    StringCharacters:\n\n        StringCharacter :: SourceCharacter but not `\\` or LineTerminator\n                         | EscapeSequence\n\n    Note that LineContinuations are not allowed. JSStr(\"foo\\\\nbar\") is fine,\n    but JSStr(\"foo\\\\\\nbar\") is not.\n\n    Use of this type presents a security risk: the encapsulated content should\n    come from a trusted source, as it will be included verbatim in the template\n    output.\n\ntype Srcset string\n    Srcset encapsulates a known safe srcset attribute (see\n    https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset).\n\n    Use of this type presents a security risk: the encapsulated content should\n    come from a trusted source, as it will be included verbatim in the template\n    output.\n\ntype Template struct {\n\n\t// The underlying template's parse tree, updated to be HTML-safe.\n\tTree *parse.Tree\n\t// Has unexported fields.\n}\n    Template is a specialized Template from \"text/template\" that produces a safe\n    HTML document fragment.\n\nfunc Must(t *Template, err error) *Template\n    Must is a helper that wraps a call to a function returning (*Template,\n    error) and panics if the error is non-nil. It is intended for use in\n    variable initializations such as\n\n        var t = template.Must(template.New(\"name\").Parse(\"html\"))\n\nfunc New(name string) *Template\n    New allocates a new HTML template with the given name.\n\nfunc ParseFS(fs fs.FS, patterns ...string) (*Template, error)\n    ParseFS is like ParseFiles or ParseGlob but reads from the file system fs\n    instead of the host operating system's file system. It accepts a list of\n    glob patterns. (Note that most file names serve as glob patterns matching\n    only themselves.)\n\nfunc ParseFiles(filenames ...string) (*Template, error)\n    ParseFiles creates a new Template and parses the template definitions from\n    the named files. The returned template's name will have the (base) name\n    and (parsed) contents of the first file. There must be at least one file.\n    If an error occurs, parsing stops and the returned *Template is nil.\n\n    When parsing multiple files with the same name in different directories,\n    the last one mentioned will be the one that results. For instance,\n    ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template named \"foo\",\n    while \"a/foo\" is unavailable.\n\nfunc ParseGlob(pattern string) (*Template, error)\n    ParseGlob creates a new Template and parses the template definitions from\n    the files identified by the pattern. The files are matched according to the\n    semantics of filepath.Match, and the pattern must match at least one file.\n    The returned template will have the (base) name and (parsed) contents of\n    the first file matched by the pattern. ParseGlob is equivalent to calling\n    ParseFiles with the list of files matched by the pattern.\n\n    When parsing multiple files with the same name in different directories,\n    the last one mentioned will be the one that results.\n\nfunc (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)\n    AddParseTree creates a new template with the name and parse tree and\n    associates it with t.\n\n    It returns an error if t or any associated template has already been\n    executed.\n\nfunc (t *Template) Clone() (*Template, error)\n    Clone returns a duplicate of the template, including all associated\n    templates. The actual representation is not copied, but the name space of\n    associated templates is, so further calls to Template.Parse in the copy will\n    add templates to the copy but not to the original. Template.Clone can be\n    used to prepare common templates and use them with variant definitions for\n    other templates by adding the variants after the clone is made.\n\n    It returns an error if t has already been executed.\n\nfunc (t *Template) DefinedTemplates() string\n    DefinedTemplates returns a string listing the defined templates, prefixed\n    by the string \"; defined templates are: \". If there are none, it returns the\n    empty string. Used to generate an error message.\n\nfunc (t *Template) Delims(left, right string) *Template\n    Delims sets the action delimiters to the specified strings, to be used\n    in subsequent calls to Template.Parse, ParseFiles, or ParseGlob. Nested\n    template definitions will inherit the settings. An empty delimiter stands\n    for the corresponding default: {{ or }}. The return value is the template,\n    so calls can be chained.\n\nfunc (t *Template) Execute(wr io.Writer, data any) error\n    Execute applies a parsed template to the specified data object, writing\n    the output to wr. If an error occurs executing the template or writing its\n    output, execution stops, but partial results may already have been written\n    to the output writer. A template may be executed safely in parallel,\n    although if parallel executions share a Writer the output may be\n    interleaved.\n\nfunc (t *Template) ExecuteTemplate(wr io.Writer, name string, data any) error\n    ExecuteTemplate applies the template associated with t that has the given\n    name to the specified data object and writes the output to wr. If an error\n    occurs executing the template or writing its output, execution stops,\n    but partial results may already have been written to the output writer. A\n    template may be executed safely in parallel, although if parallel executions\n    share a Writer the output may be interleaved.\n\nfunc (t *Template) Funcs(funcMap FuncMap) *Template\n    Funcs adds the elements of the argument map to the template's function map.\n    It must be called before the template is parsed. It panics if a value in\n    the map is not a function with appropriate return type. However, it is\n    legal to overwrite elements of the map. The return value is the template,\n    so calls can be chained.\n\nfunc (t *Template) Lookup(name string) *Template\n    Lookup returns the template with the given name that is associated with t,\n    or nil if there is no such template.\n\nfunc (t *Template) Name() string\n    Name returns the name of the template.\n\nfunc (t *Template) New(name string) *Template\n    New allocates a new HTML template associated with the given one and with the\n    same delimiters. The association, which is transitive, allows one template\n    to invoke another with a {{template}} action.\n\n    If a template with the given name already exists, the new HTML template will\n    replace it. The existing template will be reset and disassociated with t.\n\nfunc (t *Template) Option(opt ...string) *Template\n    Option sets options for the template. Options are described by strings,\n    either a simple string or \"key=value\". There can be at most one equals\n    sign in an option string. If the option string is unrecognized or otherwise\n    invalid, Option panics.\n\n    Known options:\n\n    missingkey: Control the behavior during execution if a map is indexed with a\n    key that is not present in the map.\n\n        \"missingkey=default\" or \"missingkey=invalid\"\n        \tThe default behavior: Do nothing and continue execution.\n        \tIf printed, the result of the index operation is the string\n        \t\"<no value>\".\n        \"missingkey=zero\"\n        \tThe operation returns the zero value for the map type's element.\n        \"missingkey=error\"\n        \tExecution stops immediately with an error.\n\nfunc (t *Template) Parse(text string) (*Template, error)\n    Parse parses text as a template body for t. Named template definitions\n    ({{define ...}} or {{block ...}} statements) in text define additional\n    templates associated with t and are removed from the definition of t itself.\n\n    Templates can be redefined in successive calls to Parse, before\n    the first use of Template.Execute on t or any associated template.\n    A template definition with a body containing only white space and comments\n    is considered empty and will not replace an existing template's body. This\n    allows using Parse to add new named template definitions without overwriting\n    the main template body.\n\nfunc (t *Template) ParseFS(fs fs.FS, patterns ...string) (*Template, error)\n    ParseFS is like Template.ParseFiles or Template.ParseGlob but reads from\n    the file system fs instead of the host operating system's file system.\n    It accepts a list of glob patterns. (Note that most file names serve as glob\n    patterns matching only themselves.)\n\nfunc (t *Template) ParseFiles(filenames ...string) (*Template, error)\n    ParseFiles parses the named files and associates the resulting templates\n    with t. If an error occurs, parsing stops and the returned template is nil;\n    otherwise it is t. There must be at least one file.\n\n    When parsing multiple files with the same name in different directories,\n    the last one mentioned will be the one that results.\n\n    ParseFiles returns an error if t or any associated template has already been\n    executed.\n\nfunc (t *Template) ParseGlob(pattern string) (*Template, error)\n    ParseGlob parses the template definitions in the files identified by the\n    pattern and associates the resulting templates with t. The files are matched\n    according to the semantics of filepath.Match, and the pattern must match\n    at least one file. ParseGlob is equivalent to calling t.ParseFiles with the\n    list of files matched by the pattern.\n\n    When parsing multiple files with the same name in different directories,\n    the last one mentioned will be the one that results.\n\n    ParseGlob returns an error if t or any associated template has already been\n    executed.\n\nfunc (t *Template) Templates() []*Template\n    Templates returns a slice of the templates associated with t, including t\n    itself.\n\ntype URL string\n    URL encapsulates a known safe URL or URL substring (see RFC 3986). A URL\n    like `javascript:checkThatFormNotEditedBeforeLeavingPage()` from a trusted\n    source should go in the page, but by default dynamic `javascript:` URLs are\n    filtered out since they are a frequently exploited injection vector.\n\n    Use of this type presents a security risk: the encapsulated content should\n    come from a trusted source, as it will be included verbatim in the template\n    output.\n\n"}, {"path": "stdlib/vendor-golang.org-x-text-unicode-norm.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-text-unicode-norm", "content": ""}, {"path": "stdlib/internal-profile.md", "category": "stdlib", "name": "stdlib/internal-profile", "content": "package profile // import \"internal/profile\"\n\nPackage profile represents a pprof profile as a directed graph.\n\nThis package is a simplified fork of github.com/google/pprof/internal/graph.\n\nPackage profile provides a representation of\ngithub.com/google/pprof/proto/profile.proto and methods to encode/decode/merge\nprofiles in this format.\n\nVARIABLES\n\nvar ErrNoData = fmt.Errorf(\"empty input file\")\n\nFUNCTIONS\n\nfunc CreateNodes(prof *Profile, o *Options) (Nodes, locationMap)\n    CreateNodes creates graph nodes for all locations in a profile.\n    It returns set of all nodes, plus a mapping of each location to the set of\n    corresponding nodes (one per location.Line).\n\n\nTYPES\n\ntype Demangler func(name []string) (map[string]string, error)\n    Demangler maps symbol names to a human-readable form. This may include C++\n    demangling and additional simplification. Names that are not demangled may\n    be missing from the resulting map.\n\ntype Edge struct {\n\tSrc, Dest *Node\n\t// The summary weight of the edge\n\tWeight, WeightDiv int64\n\n\t// residual edges connect nodes that were connected through a\n\t// separate node, which has been removed from the report.\n\tResidual bool\n\t// An inline edge represents a call that was inlined into the caller.\n\tInline bool\n}\n    Edge contains any attributes to be represented about edges in a graph.\n\nfunc (e *Edge) WeightValue() int64\n    WeightValue returns the weight value for this edge, normalizing if a divisor\n    is available.\n\ntype EdgeMap []*Edge\n    EdgeMap is used to represent the incoming/outgoing edges from a node.\n\nfunc (em *EdgeMap) Add(e *Edge)\n\nfunc (em *EdgeMap) Delete(e *Edge)\n\nfunc (em EdgeMap) FindTo(n *Node) *Edge\n\nfunc (em EdgeMap) Sort() []*Edge\n    Sort returns a slice of the edges in the map, in a consistent order.\n    The sort order is first based on the edge weight (higher-to-lower) and then\n    by the node names to avoid flakiness.\n\nfunc (em EdgeMap) Sum() int64\n    Sum returns the total weight for a set of nodes.\n\ntype Function struct {\n\tID         uint64\n\tName       string\n\tSystemName string\n\tFilename   string\n\tStartLine  int64\n\n\t// Has unexported fields.\n}\n    Function corresponds to Profile.Function\n\ntype Graph struct {\n\tNodes Nodes\n}\n    Graph summarizes a performance profile into a format that is suitable for\n    visualization.\n\nfunc NewGraph(prof *Profile, o *Options) *Graph\n    NewGraph computes a graph from a profile.\n\nfunc (g *Graph) String() string\n    String returns a text representation of a graph, for debugging purposes.\n\ntype Label struct {\n\t// Has unexported fields.\n}\n    Label corresponds to Profile.Label\n\ntype Line struct {\n\tFunction *Function\n\tLine     int64\n\n\t// Has unexported fields.\n}\n    Line corresponds to Profile.Line\n\ntype Location struct {\n\tID       uint64\n\tMapping  *Mapping\n\tAddress  uint64\n\tLine     []Line\n\tIsFolded bool\n\n\t// Has unexported fields.\n}\n    Location corresponds to Profile.Location\n\ntype Mapping struct {\n\tID              uint64\n\tStart           uint64\n\tLimit           uint64\n\tOffset          uint64\n\tFile            string\n\tBuildID         string\n\tHasFunctions    bool\n\tHasFilenames    bool\n\tHasLineNumbers  bool\n\tHasInlineFrames bool\n\n\t// Has unexported fields.\n}\n    Mapping corresponds to Profile.Mapping\n\ntype Node struct {\n\t// Info describes the source location associated to this node.\n\tInfo NodeInfo\n\n\t// Function represents the function that this node belongs to. On\n\t// graphs with sub-function resolution (eg line number or\n\t// addresses), two nodes in a NodeMap that are part of the same\n\t// function have the same value of Node.Function. If the Node\n\t// represents the whole function, it points back to itself.\n\tFunction *Node\n\n\t// Values associated to this node. Flat is exclusive to this node,\n\t// Cum includes all descendents.\n\tFlat, FlatDiv, Cum, CumDiv int64\n\n\t// In and out Contains the nodes immediately reaching or reached by\n\t// this node.\n\tIn, Out EdgeMap\n}\n    Node is an entry on a profiling report. It represents a unique program\n    location.\n\nfunc (n *Node) AddToEdge(to *Node, v int64, residual, inline bool)\n    AddToEdge increases the weight of an edge between two nodes. If there isn't\n    such an edge one is created.\n\nfunc (n *Node) AddToEdgeDiv(to *Node, dv, v int64, residual, inline bool)\n    AddToEdgeDiv increases the weight of an edge between two nodes. If there\n    isn't such an edge one is created.\n\nfunc (n *Node) CumValue() int64\n    CumValue returns the inclusive value for this node, computing the mean if a\n    divisor is available.\n\nfunc (n *Node) FlatValue() int64\n    FlatValue returns the exclusive value for this node, computing the mean if a\n    divisor is available.\n\ntype NodeInfo struct {\n\tName              string\n\tAddress           uint64\n\tStartLine, Lineno int\n}\n    NodeInfo contains the attributes for a node.\n\nfunc (i *NodeInfo) NameComponents() []string\n    NameComponents returns the components of the printable name to be used for a\n    node.\n\nfunc (i *NodeInfo) PrintableName() string\n    PrintableName calls the Node's Formatter function with a single space\n    separator.\n\ntype NodeMap map[NodeInfo]*Node\n    NodeMap maps from a node info struct to a node. It is used to merge report\n    entries with the same info.\n\nfunc (nm NodeMap) FindOrInsertNode(info NodeInfo, kept NodeSet) *Node\n    FindOrInsertNode takes the info for a node and either returns a matching\n    node from the node map if one exists, or adds one to the map if one does\n    not. If kept is non-nil, nodes are only added if they can be located on it.\n\ntype NodePtrSet map[*Node]bool\n    NodePtrSet is a collection of nodes. Trimming a graph or tree requires\n    a set of objects which uniquely identify the nodes to keep. In a graph,\n    NodeInfo works as a unique identifier; however, in a tree multiple nodes may\n    share identical NodeInfos. A *Node does uniquely identify a node so we can\n    use that instead. Though a *Node also uniquely identifies a node in a graph,\n    currently, during trimming, graphs are rebuilt from scratch using only the\n    NodeSet, so there would not be the required context of the initial graph to\n    allow for the use of *Node.\n\ntype NodeSet map[NodeInfo]bool\n    NodeSet is a collection of node info structs.\n\ntype Nodes []*Node\n    Nodes is an ordered collection of graph nodes.\n\nfunc (ns Nodes) Sum() (flat int64, cum int64)\n    Sum adds the flat and cum values of a set of nodes.\n\ntype Options struct {\n\tSampleValue       func(s []int64) int64 // Function to compute the value of a sample\n\tSampleMeanDivisor func(s []int64) int64 // Function to compute the divisor for mean graphs, or nil\n\n\tDropNegative bool // Drop nodes with overall negative values\n\n\tKeptNodes NodeSet // If non-nil, only use nodes in this set\n}\n    Options encodes the options for constructing a graph\n\ntype Profile struct {\n\tSampleType        []*ValueType\n\tDefaultSampleType string\n\tSample            []*Sample\n\tMapping           []*Mapping\n\tLocation          []*Location\n\tFunction          []*Function\n\tComments          []string\n\n\tDropFrames string\n\tKeepFrames string\n\n\tTimeNanos     int64\n\tDurationNanos int64\n\tPeriodType    *ValueType\n\tPeriod        int64\n\n\t// Has unexported fields.\n}\n    Profile is an in-memory representation of profile.proto.\n\nfunc Merge(srcs []*Profile) (*Profile, error)\n    Merge merges all the profiles in profs into a single Profile. Returns a new\n    profile independent of the input profiles. The merged profile is compacted\n    to eliminate unused samples, locations, functions and mappings. Profiles\n    must have identical profile sample and period types or the merge will fail.\n    profile.Period of the resulting profile will be the maximum of all profiles,\n    and profile.TimeNanos will be the earliest nonzero one.\n\nfunc Parse(r io.Reader) (*Profile, error)\n    Parse parses a profile and checks for its validity. The input must be an\n    encoded pprof protobuf, which may optionally be gzip-compressed.\n\nfunc (p *Profile) Aggregate(inlineFrame, function, filename, linenumber, address bool) error\n    Aggregate merges the locations in the profile into equivalence classes\n    preserving the request attributes. It also updates the samples to point to\n    the merged locations.\n\nfunc (p *Profile) CheckValid() error\n    CheckValid tests whether the profile is valid. Checks include, but are not\n    limited to:\n      - len(Profile.Sample[n].value) == len(Profile.value_unit)\n      - Sample.id has a corresponding Profile.Location\n\nfunc (p *Profile) Compatible(pb *Profile) error\n    Compatible determines if two profiles can be compared/merged. returns nil\n    if the profiles are compatible; otherwise an error with details on the\n    incompatibility.\n\nfunc (p *Profile) Copy() *Profile\n    Copy makes a fully independent copy of a profile.\n\nfunc (p *Profile) Demangle(d Demangler) error\n    Demangle attempts to demangle and optionally simplify any function names\n    referenced in the profile. It works on a best-effort basis: it will silently\n    preserve the original names in case of any errors.\n\nfunc (p *Profile) Empty() bool\n    Empty reports whether the profile contains no samples.\n\nfunc (p *Profile) FilterSamplesByTag(focus, ignore TagMatch) (fm, im bool)\n    FilterSamplesByTag removes all samples from the profile, except those that\n    match focus and do not match the ignore regular expression.\n\nfunc (p *Profile) HasFileLines() bool\n    HasFileLines determines if all locations in this profile have symbolized\n    file and line number information.\n\nfunc (p *Profile) HasFunctions() bool\n    HasFunctions determines if all locations in this profile have symbolized\n    function information.\n\nfunc (p *Profile) Merge(pb *Profile, r float64) error\n    Merge adds profile p adjusted by ratio r into profile p. Profiles must be\n    compatible (same Type and SampleType). TODO(rsilvera): consider normalizing\n    the profiles based on the total samples collected.\n\nfunc (p *Profile) Normalize(pb *Profile) error\n    Normalize normalizes the source profile by multiplying each value in profile\n    by the ratio of the sum of the base profile's values of that sample type to\n    the sum of the source profile's value of that sample type.\n\nfunc (p *Profile) Prune(dropRx, keepRx *regexp.Regexp)\n    Prune removes all nodes beneath a node matching dropRx, and not matching\n    keepRx. If the root node of a Sample matches, the sample will have an empty\n    stack.\n\nfunc (p *Profile) RemoveUninteresting() error\n    RemoveUninteresting prunes and elides profiles using built-in tables of\n    uninteresting function names.\n\nfunc (p *Profile) Scale(ratio float64)\n    Scale multiplies all sample values in a profile by a constant.\n\nfunc (p *Profile) ScaleN(ratios []float64) error\n    ScaleN multiplies each sample values in a sample by a different amount.\n\nfunc (p *Profile) String() string\n    Print dumps a text representation of a profile. Intended mainly for\n    debugging purposes.\n\nfunc (p *Profile) Write(w io.Writer) error\n    Write writes the profile as a gzip-compressed marshaled protobuf.\n\ntype Sample struct {\n\tLocation []*Location\n\tValue    []int64\n\tLabel    map[string][]string\n\tNumLabel map[string][]int64\n\tNumUnit  map[string][]string\n\n\t// Has unexported fields.\n}\n    Sample corresponds to Profile.Sample\n\ntype TagMatch func(key, val string, nval int64) bool\n    TagMatch selects tags for filtering\n\ntype ValueType struct {\n\tType string // cpu, wall, inuse_space, etc\n\tUnit string // seconds, nanoseconds, bytes, etc\n\n\t// Has unexported fields.\n}\n    ValueType corresponds to Profile.ValueType\n\n"}, {"path": "stdlib/internal-cfg.md", "category": "stdlib", "name": "stdlib/internal-cfg", "content": "package cfg // import \"internal/cfg\"\n\nPackage cfg holds configuration shared by the Go command and internal/testenv.\nDefinitions that don't need to be exposed outside of cmd/go should be in\ncmd/go/internal/cfg instead of this package.\n\nCONSTANTS\n\nconst KnownEnv = `\n\tAR\n\tCC\n\tCGO_CFLAGS\n\tCGO_CFLAGS_ALLOW\n\tCGO_CFLAGS_DISALLOW\n\tCGO_CPPFLAGS\n\tCGO_CPPFLAGS_ALLOW\n\tCGO_CPPFLAGS_DISALLOW\n\tCGO_CXXFLAGS\n\tCGO_CXXFLAGS_ALLOW\n\tCGO_CXXFLAGS_DISALLOW\n\tCGO_ENABLED\n\tCGO_FFLAGS\n\tCGO_FFLAGS_ALLOW\n\tCGO_FFLAGS_DISALLOW\n\tCGO_LDFLAGS\n\tCGO_LDFLAGS_ALLOW\n\tCGO_LDFLAGS_DISALLOW\n\tCXX\n\tFC\n\tGCCGO\n\tGO111MODULE\n\tGO386\n\tGOAMD64\n\tGOARCH\n\tGOARM\n\tGOARM64\n\tGOAUTH\n\tGOBIN\n\tGOCACHE\n\tGOCACHEPROG\n\tGOENV\n\tGOEXE\n\tGOEXPERIMENT\n\tGOFIPS140\n\tGOFLAGS\n\tGOGCCFLAGS\n\tGOHOSTARCH\n\tGOHOSTOS\n\tGOINSECURE\n\tGOMIPS\n\tGOMIPS64\n\tGOMODCACHE\n\tGONOPROXY\n\tGONOSUMDB\n\tGOOS\n\tGOPATH\n\tGOPPC64\n\tGOPRIVATE\n\tGOPROXY\n\tGORISCV64\n\tGOROOT\n\tGOSUMDB\n\tGOTMPDIR\n\tGOTOOLCHAIN\n\tGOTOOLDIR\n\tGOVCS\n\tGOWASM\n\tGOWORK\n\tGO_EXTLINK_ENABLED\n\tPKG_CONFIG\n`\n    KnownEnv is a list of environment variables that affect the operation of the\n    Go command.\n\n"}, {"path": "stdlib/internal-pkgbits.md", "category": "stdlib", "name": "stdlib/internal-pkgbits", "content": "package pkgbits // import \"internal/pkgbits\"\n\nPackage pkgbits implements low-level coding abstractions for Unified IR's (UIR)\nbinary export data format.\n\nAt a low-level, the exported objects of a package are encoded as a byte\narray. This array contains byte representations of primitive, potentially\nvariable-length values, such as integers, booleans, strings, and constants.\n\nAdditionally, the array may contain values which denote indices in the byte\narray itself. These are termed \"relocations\" and allow for references.\n\nThe details of mapping high-level Go constructs to primitives are left to other\npackages.\n\nTYPES\n\ntype AbsElemIdx = uint32\n    An AbsElemIdx, or absolute element index, is an index into the elements that\n    is not relative to some other index.\n\ntype Code interface {\n\t// Marker returns the SyncMarker for the Code's dynamic type.\n\tMarker() SyncMarker\n\n\t// Value returns the Code's ordinal value.\n\tValue() int\n}\n    A Code is an enum value that can be encoded into bitstreams.\n\n    Code types are preferable for enum types, because they allow Decoder to\n    detect desyncs.\n\ntype CodeObj int\n    A CodeObj distinguishes among go/types.Object encodings.\n\nconst (\n\tObjAlias CodeObj = iota\n\tObjConst\n\tObjType\n\tObjFunc\n\tObjVar\n\tObjStub\n)\nfunc (c CodeObj) Marker() SyncMarker\n\nfunc (c CodeObj) Value() int\n\ntype CodeType int\n    A CodeType distinguishes among go/types.Type encodings.\n\nconst (\n\tTypeBasic CodeType = iota\n\tTypeNamed\n\tTypePointer\n\tTypeSlice\n\tTypeArray\n\tTypeChan\n\tTypeMap\n\tTypeSignature\n\tTypeStruct\n\tTypeInterface\n\tTypeUnion\n\tTypeTypeParam\n)\nfunc (c CodeType) Marker() SyncMarker\n\nfunc (c CodeType) Value() int\n\ntype CodeVal int\n    A CodeVal distinguishes among go/constant.Value encodings.\n\nconst (\n\tValBool CodeVal = iota\n\tValString\n\tValInt64\n\tValBigInt\n\tValBigRat\n\tValBigFloat\n)\nfunc (c CodeVal) Marker() SyncMarker\n\nfunc (c CodeVal) Value() int\n\ntype Decoder struct {\n\tRelocs []RefTableEntry\n\tData   strings.Reader\n\n\tIdx RelElemIdx\n\t// Has unexported fields.\n}\n    A Decoder provides methods for decoding an individual element's bitstream\n    data.\n\nfunc (r *Decoder) Bool() bool\n    Bool decodes and returns a bool value from the element bitstream.\n\nfunc (r *Decoder) Code(mark SyncMarker) int\n    Code decodes a Code value from the element bitstream and returns its\n    ordinal value. It's the caller's responsibility to convert the result to an\n    appropriate Code type.\n\n    TODO(mdempsky): Ideally this method would have signature \"Code[T Code] T\"\n    instead, but we don't allow generic methods and the compiler can't depend on\n    generics yet anyway.\n\nfunc (r *Decoder) Int() int\n    Int decodes and returns an int value from the element bitstream.\n\nfunc (r *Decoder) Int64() int64\n    Int64 decodes and returns an int64 value from the element bitstream.\n\nfunc (r *Decoder) Len() int\n    Len decodes and returns a non-negative int value from the element bitstream.\n\nfunc (r *Decoder) Reloc(k SectionKind) RelElemIdx\n    Reloc decodes a relocation of expected section k from the element bitstream\n    and returns an index to the referenced element.\n\nfunc (r *Decoder) String() string\n    String decodes and returns a string value from the element bitstream.\n\nfunc (r *Decoder) Strings() []string\n    Strings decodes and returns a variable-length slice of strings from the\n    element bitstream.\n\nfunc (r *Decoder) Sync(mWant SyncMarker)\n    Sync decodes a sync marker from the element bitstream and asserts that it\n    matches the expected marker.\n\n    If EnableSync is false, then Sync is a no-op.\n\nfunc (r *Decoder) Uint() uint\n    Uint decodes and returns a uint value from the element bitstream.\n\nfunc (r *Decoder) Uint64() uint64\n    Uint64 decodes and returns a uint64 value from the element bitstream.\n\nfunc (r *Decoder) Value() constant.Value\n    Value decodes and returns a constant.Value from the element bitstream.\n\nfunc (w *Decoder) Version() Version\n    Version reports the version of the bitstream.\n\ntype Encoder struct {\n\tRelocs   []RefTableEntry\n\tRelocMap map[RefTableEntry]uint32\n\tData     bytes.Buffer // accumulated element bitstream data\n\n\tIdx RelElemIdx // index within relocation section\n\t// Has unexported fields.\n}\n    An Encoder provides methods for encoding an individual element's bitstream\n    data.\n\nfunc (w *Encoder) Bool(b bool) bool\n    Bool encodes and writes a bool value into the element bitstream, and then\n    returns the bool value.\n\n    For simple, 2-alternative encodings, the idiomatic way to call Bool is\n    something like:\n\n        if w.Bool(x != 0) {\n        \t// alternative #1\n        } else {\n        \t// alternative #2\n        }\n\n    For multi-alternative encodings, use Code instead.\n\nfunc (w *Encoder) Code(c Code)\n    Code encodes and writes a Code value into the element bitstream.\n\nfunc (w *Encoder) Flush() RelElemIdx\n    Flush finalizes the element's bitstream and returns its RelElemIdx.\n\nfunc (w *Encoder) Int(x int)\n    Int encodes and writes an int value into the element bitstream.\n\nfunc (w *Encoder) Int64(x int64)\n    Int64 encodes and writes an int64 value into the element bitstream.\n\nfunc (w *Encoder) Len(x int)\n    Len encodes and writes a non-negative int value into the element bitstream.\n\nfunc (w *Encoder) Reloc(k SectionKind, idx RelElemIdx)\n    Reloc encodes and writes a relocation for the given (section, index) pair\n    into the element bitstream.\n\n    Note: Only the index is formally written into the element bitstream,\n    so bitstream decoders must know from context which section an encoded\n    relocation refers to.\n\nfunc (w *Encoder) String(s string)\n    String encodes and writes a string value into the element bitstream.\n\n    Internally, strings are deduplicated by adding them to the strings section\n    (if not already present), and then writing a relocation into the element\n    bitstream.\n\nfunc (w *Encoder) StringRef(idx RelElemIdx)\n    StringRef writes a reference to the given index, which must be a previously\n    encoded string value.\n\nfunc (w *Encoder) Strings(ss []string)\n    Strings encodes and writes a variable-length slice of strings into the\n    element bitstream.\n\nfunc (w *Encoder) Sync(m SyncMarker)\n\nfunc (w *Encoder) Uint(x uint)\n    Uint encodes and writes a uint value into the element bitstream.\n\nfunc (w *Encoder) Uint64(x uint64)\n    Uint64 encodes and writes a uint64 value into the element bitstream.\n\nfunc (w *Encoder) Value(val constant.Value)\n    Value encodes and writes a constant.Value into the element bitstream.\n\nfunc (w *Encoder) Version() Version\n    Version reports the version of the bitstream.\n\ntype Field int\n    Field denotes a unit of data in the serialized unified IR bitstream.\n    It is conceptually a like field in a structure.\n\n    We only really need Fields when the data may or may not be present in a\n    stream based on the Version of the bitstream.\n\n    Unlike much of pkgbits, Fields are not serialized and can change values as\n    needed.\n\nconst (\n\t// Flags in a uint32 in the header of a bitstream\n\t// that is used to indicate whether optional features are enabled.\n\tFlags Field = iota\n\n\t// Deprecated: HasInit was a bool indicating whether a package\n\t// has any init functions.\n\tHasInit\n\n\t// Deprecated: DerivedFuncInstance was a bool indicating\n\t// whether an object was a function instance.\n\tDerivedFuncInstance\n\n\t// ObjAlias has a list of TypeParamNames.\n\tAliasTypeParamNames\n\n\t// Deprecated: DerivedInfoNeeded was a bool indicating\n\t// whether a type was a derived type.\n\tDerivedInfoNeeded\n)\ntype Index int32\n    An Index represents a bitstream element index *within* (i.e., relative to) a\n    particular section.\n\ntype PkgDecoder struct {\n\t// Has unexported fields.\n}\n    A PkgDecoder provides methods for decoding a package's Unified IR export\n    data.\n\nfunc NewPkgDecoder(pkgPath, input string) PkgDecoder\n    NewPkgDecoder returns a PkgDecoder initialized to read the Unified IR export\n    data from input. pkgPath is the package path for the compilation unit that\n    produced the export data.\n\nfunc (pr *PkgDecoder) AbsIdx(k SectionKind, idx RelElemIdx) int\n    AbsIdx returns the absolute index for the given (section, index) pair.\n\nfunc (pr *PkgDecoder) DataIdx(k SectionKind, idx RelElemIdx) string\n    DataIdx returns the raw element bitstream for the given (section, index)\n    pair.\n\nfunc (pr *PkgDecoder) Fingerprint() [8]byte\n    Fingerprint returns the package fingerprint.\n\nfunc (pr *PkgDecoder) NewDecoder(k SectionKind, idx RelElemIdx, marker SyncMarker) Decoder\n    NewDecoder returns a Decoder for the given (section, index) pair, and\n    decodes the given SyncMarker from the element bitstream.\n\nfunc (pr *PkgDecoder) NewDecoderRaw(k SectionKind, idx RelElemIdx) Decoder\n    NewDecoderRaw returns a Decoder for the given (section, index) pair.\n\n    Most callers should use NewDecoder instead.\n\nfunc (pr *PkgDecoder) NumElems(k SectionKind) int\n    NumElems returns the number of elements in section k.\n\nfunc (pr *PkgDecoder) PeekObj(idx RelElemIdx) (string, string, CodeObj)\n    PeekObj returns the package path, object name, and CodeObj for the specified\n    object index.\n\nfunc (pr *PkgDecoder) PeekPkgPath(idx RelElemIdx) string\n    PeekPkgPath returns the package path for the specified package index.\n\nfunc (pr *PkgDecoder) PkgPath() string\n    PkgPath returns the package path for the package\n\n    TODO(mdempsky): Remove; unneeded since CL 391014.\n\nfunc (pr *PkgDecoder) RetireDecoder(d *Decoder)\n\nfunc (pr *PkgDecoder) StringIdx(idx RelElemIdx) string\n    StringIdx returns the string value for the given string index.\n\nfunc (pr *PkgDecoder) SyncMarkers() bool\n    SyncMarkers reports whether pr uses sync markers.\n\nfunc (pr *PkgDecoder) TempDecoder(k SectionKind, idx RelElemIdx, marker SyncMarker) Decoder\n    TempDecoder returns a Decoder for the given (section, index) pair,\n    and decodes the given SyncMarker from the element bitstream. If possible\n    the Decoder should be RetireDecoder'd when it is no longer needed, this will\n    avoid heap allocations.\n\nfunc (pr *PkgDecoder) TempDecoderRaw(k SectionKind, idx RelElemIdx) Decoder\n\nfunc (pr *PkgDecoder) TotalElems() int\n    TotalElems returns the total number of elements across all sections.\n\ntype PkgEncoder struct {\n\t// Has unexported fields.\n}\n    A PkgEncoder provides methods for encoding a package's Unified IR export\n    data.\n\nfunc NewPkgEncoder(version Version, syncFrames int) PkgEncoder\n    NewPkgEncoder returns an initialized PkgEncoder.\n\n    syncFrames is the number of caller frames that should be serialized at\n    Sync points. Serializing additional frames results in larger export data\n    files, but can help diagnosing desync errors in higher-level Unified IR\n    reader/writer code. If syncFrames is negative, then sync markers are omitted\n    entirely.\n\nfunc (pw *PkgEncoder) DumpTo(out0 io.Writer) (fingerprint [8]byte)\n    DumpTo writes the package's encoded data to out0 and returns the package\n    fingerprint.\n\nfunc (pw *PkgEncoder) NewEncoder(k SectionKind, marker SyncMarker) *Encoder\n    NewEncoder returns an Encoder for a new element within the given section,\n    and encodes the given SyncMarker as the start of the element bitstream.\n\nfunc (pw *PkgEncoder) NewEncoderRaw(k SectionKind) *Encoder\n    NewEncoderRaw returns an Encoder for a new element within the given section.\n\n    Most callers should use NewEncoder instead.\n\nfunc (pw *PkgEncoder) StringIdx(s string) RelElemIdx\n    StringIdx adds a string value to the strings section, if not already\n    present, and returns its index.\n\nfunc (pw *PkgEncoder) SyncMarkers() bool\n    SyncMarkers reports whether pw uses sync markers.\n\ntype RefTableEntry struct {\n\tKind SectionKind\n\tIdx  RelElemIdx\n}\n    A RefTableEntry is an entry in an element's reference table. All elements\n    are preceded by a reference table which provides locations for referenced\n    elements.\n\ntype RelElemIdx = Index\n    TODO(markfreeman): Make this its own type. A RelElemIdx, or relative element\n    index, is an index into the elements relative to some other index, such as\n    the start of a section.\n\nconst (\n\tPublicRootIdx  RelElemIdx = 0\n\tPrivateRootIdx RelElemIdx = 1\n)\n    Reserved indices within the SectionMeta section.\n\ntype SectionKind int32 // TODO(markfreeman): Replace with uint8.\n    A SectionKind indicates a section, as well as the ordering of sections\n    within unified export data. Any object given a dedicated section can be\n    referred to via a section / index pair (and thus dereferenced) in other\n    sections.\n\nconst (\n\tSectionString SectionKind = iota\n\tSectionMeta\n\tSectionPosBase\n\tSectionPkg\n\tSectionName\n\tSectionType\n\tSectionObj\n\tSectionObjExt\n\tSectionObjDict\n\tSectionBody\n)\ntype SyncMarker int\n    SyncMarker is an enum type that represents markers that may be written to\n    export data to ensure the reader and writer stay synchronized.\n\nconst (\n\n\t// Low-level coding markers.\n\tSyncEOF SyncMarker\n\tSyncBool\n\tSyncInt64\n\tSyncUint64\n\tSyncString\n\tSyncValue\n\tSyncVal\n\tSyncRelocs\n\tSyncReloc\n\tSyncUseReloc\n\n\t// Higher-level object and type markers.\n\tSyncPublic\n\tSyncPos\n\tSyncPosBase\n\tSyncObject\n\tSyncObject1\n\tSyncPkg\n\tSyncPkgDef\n\tSyncMethod\n\tSyncType\n\tSyncTypeIdx\n\tSyncTypeParamNames\n\tSyncSignature\n\tSyncParams\n\tSyncParam\n\tSyncCodeObj\n\tSyncSym\n\tSyncLocalIdent\n\tSyncSelector\n\n\t// Private markers (only known to cmd/compile).\n\tSyncPrivate\n\n\tSyncFuncExt\n\tSyncVarExt\n\tSyncTypeExt\n\tSyncPragma\n\n\tSyncExprList\n\tSyncExprs\n\tSyncExpr\n\tSyncExprType\n\tSyncAssign\n\tSyncOp\n\tSyncFuncLit\n\tSyncCompLit\n\n\tSyncDecl\n\tSyncFuncBody\n\tSyncOpenScope\n\tSyncCloseScope\n\tSyncCloseAnotherScope\n\tSyncDeclNames\n\tSyncDeclName\n\n\tSyncStmts\n\tSyncBlockStmt\n\tSyncIfStmt\n\tSyncForStmt\n\tSyncSwitchStmt\n\tSyncRangeStmt\n\tSyncCaseClause\n\tSyncCommClause\n\tSyncSelectStmt\n\tSyncDecls\n\tSyncLabeledStmt\n\tSyncUseObjLocal\n\tSyncAddLocal\n\tSyncLinkname\n\tSyncStmt1\n\tSyncStmtsEnd\n\tSyncLabel\n\tSyncOptLabel\n\n\tSyncMultiExpr\n\tSyncRType\n\tSyncConvRTTI\n)\nfunc (i SyncMarker) String() string\n\ntype Version uint32\n    Version indicates a version of a unified IR bitstream. Each Version\n    indicates the addition, removal, or change of new data in the bitstream.\n\n    These are serialized to disk and the interpretation remains fixed.\n\nconst (\n\t// V0: initial prototype.\n\t//\n\t// All data that is not assigned a Field is in version V0\n\t// and has not been deprecated.\n\tV0 Version = iota\n\n\t// V1: adds the Flags uint32 word\n\tV1\n\n\t// V2: removes unused legacy fields and supports type parameters for aliases.\n\t// - remove the legacy \"has init\" bool from the public root\n\t// - remove obj's \"derived func instance\" bool\n\t// - add a TypeParamNames field to ObjAlias\n\t// - remove derived info \"needed\" bool\n\tV2\n)\nfunc (v Version) Has(f Field) bool\n    Has reports whether field f is present in a bitstream at version v.\n\n"}, {"path": "stdlib/internal-goroot.md", "category": "stdlib", "name": "stdlib/internal-goroot", "content": "package goroot // import \"internal/goroot\"\n\n\nFUNCTIONS\n\nfunc IsStandardPackage(goroot, compiler, path string) bool\n    IsStandardPackage reports whether path is a standard package, given goroot\n    and compiler.\n\n"}, {"path": "stdlib/image-color.md", "category": "stdlib", "name": "stdlib/image-color", "content": "package color // import \"image/color\"\n\nPackage color implements a basic color library.\n\nVARIABLES\n\nvar (\n\tBlack       = Gray16{0}\n\tWhite       = Gray16{0xffff}\n\tTransparent = Alpha16{0}\n\tOpaque      = Alpha16{0xffff}\n)\n    Standard colors.\n\n\nFUNCTIONS\n\nfunc CMYKToRGB(c, m, y, k uint8) (uint8, uint8, uint8)\n    CMYKToRGB converts a CMYK quadruple to an RGB triple.\n\nfunc RGBToCMYK(r, g, b uint8) (uint8, uint8, uint8, uint8)\n    RGBToCMYK converts an RGB triple to a CMYK quadruple.\n\nfunc RGBToYCbCr(r, g, b uint8) (uint8, uint8, uint8)\n    RGBToYCbCr converts an RGB triple to a Y'CbCr triple.\n\nfunc YCbCrToRGB(y, cb, cr uint8) (uint8, uint8, uint8)\n    YCbCrToRGB converts a Y'CbCr triple to an RGB triple.\n\n\nTYPES\n\ntype Alpha struct {\n\tA uint8\n}\n    Alpha represents an 8-bit alpha color.\n\nfunc (c Alpha) RGBA() (r, g, b, a uint32)\n\ntype Alpha16 struct {\n\tA uint16\n}\n    Alpha16 represents a 16-bit alpha color.\n\nfunc (c Alpha16) RGBA() (r, g, b, a uint32)\n\ntype CMYK struct {\n\tC, M, Y, K uint8\n}\n    CMYK represents a fully opaque CMYK color, having 8 bits for each of cyan,\n    magenta, yellow and black.\n\n    It is not associated with any particular color profile.\n\nfunc (c CMYK) RGBA() (uint32, uint32, uint32, uint32)\n\ntype Color interface {\n\t// RGBA returns the alpha-premultiplied red, green, blue and alpha values\n\t// for the color. Each value ranges within [0, 0xffff], but is represented\n\t// by a uint32 so that multiplying by a blend factor up to 0xffff will not\n\t// overflow.\n\t//\n\t// An alpha-premultiplied color component c has been scaled by alpha (a),\n\t// so has valid values 0 <= c <= a.\n\tRGBA() (r, g, b, a uint32)\n}\n    Color can convert itself to alpha-premultiplied 16-bits per channel RGBA.\n    The conversion may be lossy.\n\ntype Gray struct {\n\tY uint8\n}\n    Gray represents an 8-bit grayscale color.\n\nfunc (c Gray) RGBA() (r, g, b, a uint32)\n\ntype Gray16 struct {\n\tY uint16\n}\n    Gray16 represents a 16-bit grayscale color.\n\nfunc (c Gray16) RGBA() (r, g, b, a uint32)\n\ntype Model interface {\n\tConvert(c Color) Color\n}\n    Model can convert any Color to one from its own color model. The conversion\n    may be lossy.\n\nvar (\n\tRGBAModel    Model = ModelFunc(rgbaModel)\n\tRGBA64Model  Model = ModelFunc(rgba64Model)\n\tNRGBAModel   Model = ModelFunc(nrgbaModel)\n\tNRGBA64Model Model = ModelFunc(nrgba64Model)\n\tAlphaModel   Model = ModelFunc(alphaModel)\n\tAlpha16Model Model = ModelFunc(alpha16Model)\n\tGrayModel    Model = ModelFunc(grayModel)\n\tGray16Model  Model = ModelFunc(gray16Model)\n)\n    Models for the standard color types.\n\nvar CMYKModel Model = ModelFunc(cmykModel)\n    CMYKModel is the Model for CMYK colors.\n\nvar NYCbCrAModel Model = ModelFunc(nYCbCrAModel)\n    NYCbCrAModel is the Model for non-alpha-premultiplied Y'CbCr-with-alpha\n    colors.\n\nvar YCbCrModel Model = ModelFunc(yCbCrModel)\n    YCbCrModel is the Model for Y'CbCr colors.\n\nfunc ModelFunc(f func(Color) Color) Model\n    ModelFunc returns a Model that invokes f to implement the conversion.\n\ntype NRGBA struct {\n\tR, G, B, A uint8\n}\n    NRGBA represents a non-alpha-premultiplied 32-bit color.\n\nfunc (c NRGBA) RGBA() (r, g, b, a uint32)\n\ntype NRGBA64 struct {\n\tR, G, B, A uint16\n}\n    NRGBA64 represents a non-alpha-premultiplied 64-bit color, having 16 bits\n    for each of red, green, blue and alpha.\n\nfunc (c NRGBA64) RGBA() (r, g, b, a uint32)\n\ntype NYCbCrA struct {\n\tYCbCr\n\tA uint8\n}\n    NYCbCrA represents a non-alpha-premultiplied Y'CbCr-with-alpha color,\n    having 8 bits each for one luma, two chroma and one alpha component.\n\nfunc (c NYCbCrA) RGBA() (uint32, uint32, uint32, uint32)\n\ntype Palette []Color\n    Palette is a palette of colors.\n\nfunc (p Palette) Convert(c Color) Color\n    Convert returns the palette color closest to c in Euclidean R,G,B space.\n\nfunc (p Palette) Index(c Color) int\n    Index returns the index of the palette color closest to c in Euclidean\n    R,G,B,A space.\n\ntype RGBA struct {\n\tR, G, B, A uint8\n}\n    RGBA represents a traditional 32-bit alpha-premultiplied color, having 8\n    bits for each of red, green, blue and alpha.\n\n    An alpha-premultiplied color component C has been scaled by alpha (A),\n    so has valid values 0 <= C <= A.\n\nfunc (c RGBA) RGBA() (r, g, b, a uint32)\n\ntype RGBA64 struct {\n\tR, G, B, A uint16\n}\n    RGBA64 represents a 64-bit alpha-premultiplied color, having 16 bits for\n    each of red, green, blue and alpha.\n\n    An alpha-premultiplied color component C has been scaled by alpha (A),\n    so has valid values 0 <= C <= A.\n\nfunc (c RGBA64) RGBA() (r, g, b, a uint32)\n\ntype YCbCr struct {\n\tY, Cb, Cr uint8\n}\n    YCbCr represents a fully opaque 24-bit Y'CbCr color, having 8 bits each for\n    one luma and two chroma components.\n\n    JPEG, VP8, the MPEG family and other codecs use this color model.\n    Such codecs often use the terms YUV and Y'CbCr interchangeably, but strictly\n    speaking, the term YUV applies only to analog video signals, and Y' (luma)\n    is Y (luminance) after applying gamma correction.\n\n    Conversion between RGB and Y'CbCr is lossy and there are multiple, slightly\n    different formulae for converting between the two. This package follows the\n    JFIF specification at https://www.w3.org/Graphics/JPEG/jfif3.pdf.\n\nfunc (c YCbCr) RGBA() (uint32, uint32, uint32, uint32)\n\n"}, {"path": "stdlib/crypto-internal-fips140-ecdh.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-ecdh", "content": "package ecdh // import \"crypto/internal/fips140/ecdh\"\n\n\nFUNCTIONS\n\nfunc ECDH[P Point[P]](c *Curve[P], k *PrivateKey, peer *PublicKey) ([]byte, error)\n\nTYPES\n\ntype Curve[P Point[P]] struct {\n\tN []byte\n\t// Has unexported fields.\n}\n\nfunc P224() *Curve[*nistec.P224Point]\n\nfunc P256() *Curve[*nistec.P256Point]\n\nfunc P384() *Curve[*nistec.P384Point]\n\nfunc P521() *Curve[*nistec.P521Point]\n\ntype Point[P any] interface {\n\t*nistec.P224Point | *nistec.P256Point | *nistec.P384Point | *nistec.P521Point\n\tBytes() []byte\n\tBytesX() ([]byte, error)\n\tSetBytes([]byte) (P, error)\n\tScalarMult(P, []byte) (P, error)\n\tScalarBaseMult([]byte) (P, error)\n}\n    Point is a generic constraint for the nistec Point types.\n\ntype PrivateKey struct {\n\t// Has unexported fields.\n}\n\nfunc GenerateKey[P Point[P]](c *Curve[P], rand io.Reader) (*PrivateKey, error)\n    GenerateKey generates a new ECDSA private key pair for the specified curve.\n\nfunc NewPrivateKey[P Point[P]](c *Curve[P], key []byte) (*PrivateKey, error)\n\nfunc (priv *PrivateKey) Bytes() []byte\n\nfunc (priv *PrivateKey) PublicKey() *PublicKey\n\ntype PublicKey struct {\n\t// Has unexported fields.\n}\n\nfunc NewPublicKey[P Point[P]](c *Curve[P], key []byte) (*PublicKey, error)\n\nfunc (pub *PublicKey) Bytes() []byte\n\n"}, {"path": "stdlib/container-heap.md", "category": "stdlib", "name": "stdlib/container-heap", "content": "package heap // import \"container/heap\"\n\nPackage heap provides heap operations for any type that implements\nheap.Interface. A heap is a tree with the property that each node is the\nminimum-valued node in its subtree.\n\nThe minimum element in the tree is the root, at index 0.\n\nA heap is a common way to implement a priority queue. To build a priority queue,\nimplement the Heap interface with the (negative) priority as the ordering for\nthe Less method, so Push adds items while Pop removes the highest-priority\nitem from the queue. The Examples include such an implementation; the file\nexample_pq_test.go has the complete source.\n\nFUNCTIONS\n\nfunc Fix(h Interface, i int)\n    Fix re-establishes the heap ordering after the element at index i has\n    changed its value. Changing the value of the element at index i and then\n    calling Fix is equivalent to, but less expensive than, calling Remove(h,\n    i) followed by a Push of the new value. The complexity is O(log n) where n =\n    h.Len().\n\nfunc Init(h Interface)\n    Init establishes the heap invariants required by the other routines in\n    this package. Init is idempotent with respect to the heap invariants and\n    may be called whenever the heap invariants may have been invalidated.\n    The complexity is O(n) where n = h.Len().\n\nfunc Pop(h Interface) any\n    Pop removes and returns the minimum element (according to Less) from the\n    heap. The complexity is O(log n) where n = h.Len(). Pop is equivalent to\n    Remove(h, 0).\n\nfunc Push(h Interface, x any)\n    Push pushes the element x onto the heap. The complexity is O(log n) where n\n    = h.Len().\n\nfunc Remove(h Interface, i int) any\n    Remove removes and returns the element at index i from the heap. The\n    complexity is O(log n) where n = h.Len().\n\n\nTYPES\n\ntype Interface interface {\n\tsort.Interface\n\tPush(x any) // add x as element Len()\n\tPop() any   // remove and return element Len() - 1.\n}\n    The Interface type describes the requirements for a type using the routines\n    in this package. Any type that implements it may be used as a min-heap with\n    the following invariants (established after Init has been called or if the\n    data is empty or sorted):\n\n        !h.Less(j, i) for 0 <= i < h.Len() and 2*i+1 <= j <= 2*i+2 and j < h.Len()\n\n    Note that Push and Pop in this interface are for package heap's\n    implementation to call. To add and remove things from the heap, use\n    heap.Push and heap.Pop.\n\n"}, {"path": "stdlib/crypto-internal-sysrand-internal-seccomp.md", "category": "stdlib", "name": "stdlib/crypto-internal-sysrand-internal-seccomp", "content": "package seccomp // import \"crypto/internal/sysrand/internal/seccomp\"\n\n\nFUNCTIONS\n\nfunc DisableGetrandom() error\n"}, {"path": "stdlib/go-doc-comment.md", "category": "stdlib", "name": "stdlib/go-doc-comment", "content": "package comment // import \"go/doc/comment\"\n\nPackage comment implements parsing and reformatting of Go doc comments,\n(documentation comments), which are comments that immediately precede a\ntop-level declaration of a package, const, func, type, or var.\n\nGo doc comment syntax is a simplified subset of Markdown that supports links,\nheadings, paragraphs, lists (without nesting), and preformatted text blocks.\nThe details of the syntax are documented at https://go.dev/doc/comment.\n\nTo parse the text associated with a doc comment (after removing comment\nmarkers), use a Parser:\n\n    var p comment.Parser\n    doc := p.Parse(text)\n\nThe result is a *Doc. To reformat it as a doc comment, HTML, Markdown, or plain\ntext, use a Printer:\n\n    var pr comment.Printer\n    os.Stdout.Write(pr.Text(doc))\n\nThe Parser and Printer types are structs whose fields can be modified to\ncustomize the operations. For details, see the documentation for those types.\n\nUse cases that need additional control over reformatting can implement their\nown logic by inspecting the parsed syntax itself. See the documentation for Doc,\nBlock, Text for an overview and links to additional types.\n\nFUNCTIONS\n\nfunc DefaultLookupPackage(name string) (importPath string, ok bool)\n    DefaultLookupPackage is the default package lookup function, used when\n    [Parser.LookupPackage] is nil. It recognizes names of the packages from the\n    standard library with single-element import paths, such as math, which would\n    otherwise be impossible to name.\n\n    Note that the go/doc package provides a more sophisticated lookup based on\n    the imports used in the current package.\n\n\nTYPES\n\ntype Block interface {\n\t// Has unexported methods.\n}\n    A Block is block-level content in a doc comment, one of *Code, *Heading,\n    *List, or *Paragraph.\n\ntype Code struct {\n\t// Text is the preformatted text, ending with a newline character.\n\t// It may be multiple lines, each of which ends with a newline character.\n\t// It is never empty, nor does it start or end with a blank line.\n\tText string\n}\n    A Code is a preformatted code block.\n\ntype Doc struct {\n\t// Content is the sequence of content blocks in the comment.\n\tContent []Block\n\n\t// Links is the link definitions in the comment.\n\tLinks []*LinkDef\n}\n    A Doc is a parsed Go doc comment.\n\ntype DocLink struct {\n\tText []Text // text of link\n\n\t// ImportPath, Recv, and Name identify the Go package or symbol\n\t// that is the link target. The potential combinations of\n\t// non-empty fields are:\n\t//  - ImportPath: a link to another package\n\t//  - ImportPath, Name: a link to a const, func, type, or var in another package\n\t//  - ImportPath, Recv, Name: a link to a method in another package\n\t//  - Name: a link to a const, func, type, or var in this package\n\t//  - Recv, Name: a link to a method in this package\n\tImportPath string // import path\n\tRecv       string // receiver type, without any pointer star, for methods\n\tName       string // const, func, type, var, or method name\n}\n    A DocLink is a link to documentation for a Go package or symbol.\n\nfunc (l *DocLink) DefaultURL(baseURL string) string\n    DefaultURL constructs and returns the documentation URL for l, using baseURL\n    as a prefix for links to other packages.\n\n    The possible forms returned by DefaultURL are:\n      - baseURL/ImportPath, for a link to another package\n      - baseURL/ImportPath#Name, for a link to a const, func, type, or var in\n        another package\n      - baseURL/ImportPath#Recv.Name, for a link to a method in another package\n      - #Name, for a link to a const, func, type, or var in this package\n      - #Recv.Name, for a link to a method in this package\n\n    If baseURL ends in a trailing slash, then DefaultURL inserts a slash between\n    ImportPath and # in the anchored forms. For example, here are some baseURL\n    values and URLs they can generate:\n\n        \"/pkg/\" \u2192 \"/pkg/math/#Sqrt\"\n        \"/pkg\"  \u2192 \"/pkg/math#Sqrt\"\n        \"/\"     \u2192 \"/math/#Sqrt\"\n        \"\"      \u2192 \"/math#Sqrt\"\n\ntype Heading struct {\n\tText []Text // the heading text\n}\n    A Heading is a doc comment heading.\n\nfunc (h *Heading) DefaultID() string\n    DefaultID returns the default anchor ID for the heading h.\n\n    The default anchor ID is constructed by converting every rune that is not\n    alphanumeric ASCII to an underscore and then adding the prefix \u201chdr-\u201d.\n    For example, if the heading text is \u201cGo Doc Comments\u201d, the default ID is\n    \u201chdr-Go_Doc_Comments\u201d.\n\ntype Italic string\n    An Italic is a string rendered as italicized text.\n\ntype Link struct {\n\tAuto bool   // is this an automatic (implicit) link of a literal URL?\n\tText []Text // text of link\n\tURL  string // target URL of link\n}\n    A Link is a link to a specific URL.\n\ntype LinkDef struct {\n\tText string // the link text\n\tURL  string // the link URL\n\tUsed bool   // whether the comment uses the definition\n}\n    A LinkDef is a single link definition.\n\ntype List struct {\n\t// Items is the list items.\n\tItems []*ListItem\n\n\t// ForceBlankBefore indicates that the list must be\n\t// preceded by a blank line when reformatting the comment,\n\t// overriding the usual conditions. See the BlankBefore method.\n\t//\n\t// The comment parser sets ForceBlankBefore for any list\n\t// that is preceded by a blank line, to make sure\n\t// the blank line is preserved when printing.\n\tForceBlankBefore bool\n\n\t// ForceBlankBetween indicates that list items must be\n\t// separated by blank lines when reformatting the comment,\n\t// overriding the usual conditions. See the BlankBetween method.\n\t//\n\t// The comment parser sets ForceBlankBetween for any list\n\t// that has a blank line between any two of its items, to make sure\n\t// the blank lines are preserved when printing.\n\tForceBlankBetween bool\n}\n    A List is a numbered or bullet list. Lists are always non-empty: len(Items)\n    > 0. In a numbered list, every Items[i].Number is a non-empty string.\n    In a bullet list, every Items[i].Number is an empty string.\n\nfunc (l *List) BlankBefore() bool\n    BlankBefore reports whether a reformatting of the comment should include\n    a blank line before the list. The default rule is the same as for\n    [BlankBetween]: if the list item content contains any blank lines (meaning\n    at least one item has multiple paragraphs) then the list itself must be\n    preceded by a blank line. A preceding blank line can be forced by setting\n    List.ForceBlankBefore.\n\nfunc (l *List) BlankBetween() bool\n    BlankBetween reports whether a reformatting of the comment should include\n    a blank line between each pair of list items. The default rule is that\n    if the list item content contains any blank lines (meaning at least\n    one item has multiple paragraphs) then list items must themselves be\n    separated by blank lines. Blank line separators can be forced by setting\n    List.ForceBlankBetween.\n\ntype ListItem struct {\n\t// Number is a decimal string in a numbered list\n\t// or an empty string in a bullet list.\n\tNumber string // \"1\", \"2\", ...; \"\" for bullet list\n\n\t// Content is the list content.\n\t// Currently, restrictions in the parser and printer\n\t// require every element of Content to be a *Paragraph.\n\tContent []Block // Content of this item.\n}\n    A ListItem is a single item in a numbered or bullet list.\n\ntype Paragraph struct {\n\tText []Text\n}\n    A Paragraph is a paragraph of text.\n\ntype Parser struct {\n\t// Words is a map of Go identifier words that\n\t// should be italicized and potentially linked.\n\t// If Words[w] is the empty string, then the word w\n\t// is only italicized. Otherwise it is linked, using\n\t// Words[w] as the link target.\n\t// Words corresponds to the [go/doc.ToHTML] words parameter.\n\tWords map[string]string\n\n\t// LookupPackage resolves a package name to an import path.\n\t//\n\t// If LookupPackage(name) returns ok == true, then [name]\n\t// (or [name.Sym] or [name.Sym.Method])\n\t// is considered a documentation link to importPath's package docs.\n\t// It is valid to return \"\", true, in which case name is considered\n\t// to refer to the current package.\n\t//\n\t// If LookupPackage(name) returns ok == false,\n\t// then [name] (or [name.Sym] or [name.Sym.Method])\n\t// will not be considered a documentation link,\n\t// except in the case where name is the full (but single-element) import path\n\t// of a package in the standard library, such as in [math] or [io.Reader].\n\t// LookupPackage is still called for such names,\n\t// in order to permit references to imports of other packages\n\t// with the same package names.\n\t//\n\t// Setting LookupPackage to nil is equivalent to setting it to\n\t// a function that always returns \"\", false.\n\tLookupPackage func(name string) (importPath string, ok bool)\n\n\t// LookupSym reports whether a symbol name or method name\n\t// exists in the current package.\n\t//\n\t// If LookupSym(\"\", \"Name\") returns true, then [Name]\n\t// is considered a documentation link for a const, func, type, or var.\n\t//\n\t// Similarly, if LookupSym(\"Recv\", \"Name\") returns true,\n\t// then [Recv.Name] is considered a documentation link for\n\t// type Recv's method Name.\n\t//\n\t// Setting LookupSym to nil is equivalent to setting it to a function\n\t// that always returns false.\n\tLookupSym func(recv, name string) (ok bool)\n}\n    A Parser is a doc comment parser. The fields in the struct can be filled in\n    before calling Parser.Parse in order to customize the details of the parsing\n    process.\n\nfunc (p *Parser) Parse(text string) *Doc\n    Parse parses the doc comment text and returns the *Doc form. Comment markers\n    (/* // and */) in the text must have already been removed.\n\ntype Plain string\n    A Plain is a string rendered as plain text (not italicized).\n\ntype Printer struct {\n\t// HeadingLevel is the nesting level used for\n\t// HTML and Markdown headings.\n\t// If HeadingLevel is zero, it defaults to level 3,\n\t// meaning to use <h3> and ###.\n\tHeadingLevel int\n\n\t// HeadingID is a function that computes the heading ID\n\t// (anchor tag) to use for the heading h when generating\n\t// HTML and Markdown. If HeadingID returns an empty string,\n\t// then the heading ID is omitted.\n\t// If HeadingID is nil, h.DefaultID is used.\n\tHeadingID func(h *Heading) string\n\n\t// DocLinkURL is a function that computes the URL for the given DocLink.\n\t// If DocLinkURL is nil, then link.DefaultURL(p.DocLinkBaseURL) is used.\n\tDocLinkURL func(link *DocLink) string\n\n\t// DocLinkBaseURL is used when DocLinkURL is nil,\n\t// passed to [DocLink.DefaultURL] to construct a DocLink's URL.\n\t// See that method's documentation for details.\n\tDocLinkBaseURL string\n\n\t// TextPrefix is a prefix to print at the start of every line\n\t// when generating text output using the Text method.\n\tTextPrefix string\n\n\t// TextCodePrefix is the prefix to print at the start of each\n\t// preformatted (code block) line when generating text output,\n\t// instead of (not in addition to) TextPrefix.\n\t// If TextCodePrefix is the empty string, it defaults to TextPrefix+\"\\t\".\n\tTextCodePrefix string\n\n\t// TextWidth is the maximum width text line to generate,\n\t// measured in Unicode code points,\n\t// excluding TextPrefix and the newline character.\n\t// If TextWidth is zero, it defaults to 80 minus the number of code points in TextPrefix.\n\t// If TextWidth is negative, there is no limit.\n\tTextWidth int\n}\n    A Printer is a doc comment printer. The fields in the struct can be filled\n    in before calling any of the printing methods in order to customize the\n    details of the printing process.\n\nfunc (p *Printer) Comment(d *Doc) []byte\n    Comment returns the standard Go formatting of the Doc, without any comment\n    markers.\n\nfunc (p *Printer) HTML(d *Doc) []byte\n    HTML returns an HTML formatting of the Doc. See the Printer documentation\n    for ways to customize the HTML output.\n\nfunc (p *Printer) Markdown(d *Doc) []byte\n    Markdown returns a Markdown formatting of the Doc. See the Printer\n    documentation for ways to customize the Markdown output.\n\nfunc (p *Printer) Text(d *Doc) []byte\n    Text returns a textual formatting of the Doc. See the Printer documentation\n    for ways to customize the text output.\n\ntype Text interface {\n\t// Has unexported methods.\n}\n    A Text is text-level content in a doc comment, one of Plain, Italic, *Link,\n    or *DocLink.\n\n"}, {"path": "stdlib/crypto-internal-fips140-aes.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-aes", "content": "package aes // import \"crypto/internal/fips140/aes\"\n\n\nCONSTANTS\n\nconst BlockSize = 16\n    BlockSize is the AES block size in bytes.\n\n\nFUNCTIONS\n\nfunc EncryptBlockInternal(c *Block, dst, src []byte)\n    EncryptBlockInternal applies the AES encryption function to one block.\n\n    It is an internal function meant only for the gcm package.\n\nfunc EncryptionKeySchedule(c *Block) []uint32\n    EncryptionKeySchedule is used from the GCM implementation to access the\n    precomputed AES key schedule, to pass to the assembly implementation.\n\nfunc RoundToBlock(c *CTR)\n    RoundToBlock is used by CTR_DRBG, which discards the rightmost unused bits\n    at each request. It rounds the offset up to the next block boundary.\n\n\nTYPES\n\ntype Block struct {\n\t// Has unexported fields.\n}\n    A Block is an instance of AES using a particular key. It is safe for\n    concurrent use.\n\nfunc New(key []byte) (*Block, error)\n    New creates and returns a new [cipher.Block] implementation. The key\n    argument should be the AES key, either 16, 24, or 32 bytes to select\n    AES-128, AES-192, or AES-256.\n\nfunc (c *Block) BlockSize() int\n\nfunc (c *Block) Decrypt(dst, src []byte)\n\nfunc (c *Block) Encrypt(dst, src []byte)\n\ntype CBCDecrypter struct {\n\t// Has unexported fields.\n}\n\nfunc NewCBCDecrypter(b *Block, iv [BlockSize]byte) *CBCDecrypter\n    NewCBCDecrypter returns a [cipher.BlockMode] which decrypts in cipher block\n    chaining mode, using the given Block.\n\nfunc (c *CBCDecrypter) BlockSize() int\n\nfunc (c *CBCDecrypter) CryptBlocks(dst, src []byte)\n\nfunc (x *CBCDecrypter) SetIV(iv []byte)\n\ntype CBCEncrypter struct {\n\t// Has unexported fields.\n}\n\nfunc NewCBCEncrypter(b *Block, iv [BlockSize]byte) *CBCEncrypter\n    NewCBCEncrypter returns a [cipher.BlockMode] which encrypts in cipher block\n    chaining mode, using the given Block.\n\nfunc (c *CBCEncrypter) BlockSize() int\n\nfunc (c *CBCEncrypter) CryptBlocks(dst, src []byte)\n\nfunc (x *CBCEncrypter) SetIV(iv []byte)\n\ntype CTR struct {\n\t// Has unexported fields.\n}\n\nfunc NewCTR(b *Block, iv []byte) *CTR\n\nfunc (c *CTR) XORKeyStream(dst, src []byte)\n\nfunc (c *CTR) XORKeyStreamAt(dst, src []byte, offset uint64)\n    XORKeyStreamAt behaves like XORKeyStream but keeps no state, and instead\n    seeks into the keystream by the given bytes offset from the start (ignoring\n    any XORKetStream calls). This allows for random access into the keystream,\n    up to 16 EiB from the start.\n\ntype KeySizeError int\n\nfunc (k KeySizeError) Error() string\n\n"}, {"path": "stdlib/vendor-golang.org-x-net-nettest.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-net-nettest", "content": ""}, {"path": "stdlib/text-tabwriter.md", "category": "stdlib", "name": "stdlib/text-tabwriter", "content": "package tabwriter // import \"text/tabwriter\"\n\nPackage tabwriter implements a write filter (tabwriter.Writer) that translates\ntabbed columns in input into properly aligned text.\n\nThe package is using the Elastic Tabstops algorithm described at\nhttp://nickgravgaard.com/elastictabstops/index.html.\n\nThe text/tabwriter package is frozen and is not accepting new features.\n\nCONSTANTS\n\nconst (\n\t// Ignore html tags and treat entities (starting with '&'\n\t// and ending in ';') as single characters (width = 1).\n\tFilterHTML uint = 1 << iota\n\n\t// Strip Escape characters bracketing escaped text segments\n\t// instead of passing them through unchanged with the text.\n\tStripEscape\n\n\t// Force right-alignment of cell content.\n\t// Default is left-alignment.\n\tAlignRight\n\n\t// Handle empty columns as if they were not present in\n\t// the input in the first place.\n\tDiscardEmptyColumns\n\n\t// Always use tabs for indentation columns (i.e., padding of\n\t// leading empty cells on the left) independent of padchar.\n\tTabIndent\n\n\t// Print a vertical bar ('|') between columns (after formatting).\n\t// Discarded columns appear as zero-width columns (\"||\").\n\tDebug\n)\n    Formatting can be controlled with these flags.\n\nconst Escape = '\\xff'\n    To escape a text segment, bracket it with Escape characters. For instance,\n    the tab in this string \"Ignore this tab: \\xff\\t\\xff\" does not terminate\n    a cell and constitutes a single character of width one for formatting\n    purposes.\n\n    The value 0xff was chosen because it cannot appear in a valid UTF-8\n    sequence.\n\n\nTYPES\n\ntype Writer struct {\n\t// Has unexported fields.\n}\n    A Writer is a filter that inserts padding around tab-delimited columns in\n    its input to align them in the output.\n\n    The Writer treats incoming bytes as UTF-8-encoded text consisting of cells\n    terminated by horizontal ('\\t') or vertical ('\\v') tabs, and newline ('\\n')\n    or formfeed ('\\f') characters; both newline and formfeed act as line breaks.\n\n    Tab-terminated cells in contiguous lines constitute a column. The Writer\n    inserts padding as needed to make all cells in a column have the same width,\n    effectively aligning the columns. It assumes that all characters have\n    the same width, except for tabs for which a tabwidth must be specified.\n    Column cells must be tab-terminated, not tab-separated: non-tab terminated\n    trailing text at the end of a line forms a cell but that cell is not part\n    of an aligned column. For instance, in this example (where | stands for a\n    horizontal tab):\n\n        aaaa|bbb|d\n        aa  |b  |dd\n        a   |\n        aa  |cccc|eee\n\n    the b and c are in distinct columns (the b column is not contiguous all the\n    way). The d and e are not in a column at all (there's no terminating tab,\n    nor would the column be contiguous).\n\n    The Writer assumes that all Unicode code points have the same width;\n    this may not be true in some fonts or if the string contains combining\n    characters.\n\n    If DiscardEmptyColumns is set, empty columns that are terminated entirely\n    by vertical (or \"soft\") tabs are discarded. Columns terminated by horizontal\n    (or \"hard\") tabs are not affected by this flag.\n\n    If a Writer is configured to filter HTML, HTML tags and entities are passed\n    through. The widths of tags and entities are assumed to be zero (tags) and\n    one (entities) for formatting purposes.\n\n    A segment of text may be escaped by bracketing it with Escape characters.\n    The tabwriter passes escaped text segments through unchanged. In particular,\n    it does not interpret any tabs or line breaks within the segment. If the\n    StripEscape flag is set, the Escape characters are stripped from the output;\n    otherwise they are passed through as well. For the purpose of formatting,\n    the width of the escaped text is always computed excluding the Escape\n    characters.\n\n    The formfeed character acts like a newline but it also terminates all\n    columns in the current line (effectively calling Writer.Flush). Tab-\n    terminated cells in the next line start new columns. Unless found inside an\n    HTML tag or inside an escaped text segment, formfeed characters appear as\n    newlines in the output.\n\n    The Writer must buffer input internally, because proper spacing of one line\n    may depend on the cells in future lines. Clients must call Flush when done\n    calling Writer.Write.\n\nfunc NewWriter(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer\n    NewWriter allocates and initializes a new Writer. The parameters are the\n    same as for the Init function.\n\nfunc (b *Writer) Flush() error\n    Flush should be called after the last call to Writer.Write to ensure that\n    any data buffered in the Writer is written to output. Any incomplete escape\n    sequence at the end is considered complete for formatting purposes.\n\nfunc (b *Writer) Init(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer\n    A Writer must be initialized with a call to Init. The first parameter\n    (output) specifies the filter output. The remaining parameters control the\n    formatting:\n\n        minwidth\tminimal cell width including any padding\n        tabwidth\twidth of tab characters (equivalent number of spaces)\n        padding\t\tpadding added to a cell before computing its width\n        padchar\t\tASCII char used for padding\n        \t\tif padchar == '\\t', the Writer will assume that the\n        \t\twidth of a '\\t' in the formatted output is tabwidth,\n        \t\tand cells are left-aligned independent of align_left\n        \t\t(for correct-looking results, tabwidth must correspond\n        \t\tto the tab width in the viewer displaying the result)\n        flags\t\tformatting control\n\nfunc (b *Writer) Write(buf []byte) (n int, err error)\n    Write writes buf to the writer b. The only errors returned are ones\n    encountered while writing to the underlying output stream.\n\n"}, {"path": "stdlib/internal-runtime-atomic.md", "category": "stdlib", "name": "stdlib/internal-runtime-atomic", "content": "package atomic // import \"internal/runtime/atomic\"\n\nPackage atomic provides atomic operations, independent of sync/atomic, to the\nruntime.\n\nOn most platforms, the compiler is aware of the functions defined in this\npackage, and they're replaced with platform-specific intrinsics. On other\nplatforms, generic implementations are made available.\n\nUnless otherwise noted, operations defined in this package are sequentially\nconsistent across threads with respect to the values they manipulate.\nMore specifically, operations that happen in a specific order on one thread,\nwill always be observed to happen in exactly that order by another thread.\n\nFUNCTIONS\n\nfunc And(ptr *uint32, val uint32)\nfunc And32(ptr *uint32, val uint32) uint32\nfunc And64(ptr *uint64, val uint64) uint64\nfunc And8(ptr *uint8, val uint8)\nfunc Anduintptr(ptr *uintptr, val uintptr) uintptr\nfunc Cas(ptr *uint32, old, new uint32) bool\nfunc Cas64(ptr *uint64, old, new uint64) bool\nfunc CasRel(ptr *uint32, old, new uint32) bool\nfunc Casint32(ptr *int32, old, new int32) bool\nfunc Casint64(ptr *int64, old, new int64) bool\nfunc Casp1(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool\n    NO go:noescape annotation; see atomic_pointer.go.\n\nfunc Casuintptr(ptr *uintptr, old, new uintptr) bool\nfunc Load(ptr *uint32) uint32\nfunc Load64(ptr *uint64) uint64\nfunc Load8(ptr *uint8) uint8\nfunc LoadAcq(addr *uint32) uint32\nfunc LoadAcq64(ptr *uint64) uint64\nfunc LoadAcquintptr(ptr *uintptr) uintptr\nfunc Loadint32(ptr *int32) int32\nfunc Loadint64(ptr *int64) int64\nfunc Loadp(ptr unsafe.Pointer) unsafe.Pointer\n    NO go:noescape annotation; *ptr escapes if result escapes (#31525)\n\nfunc Loaduint(ptr *uint) uint\nfunc Loaduintptr(ptr *uintptr) uintptr\nfunc Or(ptr *uint32, val uint32)\nfunc Or32(ptr *uint32, val uint32) uint32\nfunc Or64(ptr *uint64, val uint64) uint64\nfunc Or8(ptr *uint8, val uint8)\nfunc Oruintptr(ptr *uintptr, val uintptr) uintptr\nfunc Store(ptr *uint32, val uint32)\nfunc Store64(ptr *uint64, val uint64)\nfunc Store8(ptr *uint8, val uint8)\nfunc StoreRel(ptr *uint32, val uint32)\nfunc StoreRel64(ptr *uint64, val uint64)\nfunc StoreReluintptr(ptr *uintptr, val uintptr)\nfunc Storeint32(ptr *int32, new int32)\nfunc Storeint64(ptr *int64, new int64)\nfunc StorepNoWB(ptr unsafe.Pointer, val unsafe.Pointer)\n    NO go:noescape annotation; see atomic_pointer.go.\n\nfunc Storeuintptr(ptr *uintptr, new uintptr)\nfunc Xadd(ptr *uint32, delta int32) uint32\nfunc Xadd64(ptr *uint64, delta int64) uint64\nfunc Xaddint32(ptr *int32, delta int32) int32\nfunc Xaddint64(ptr *int64, delta int64) int64\nfunc Xadduintptr(ptr *uintptr, delta uintptr) uintptr\nfunc Xchg(ptr *uint32, new uint32) uint32\nfunc Xchg64(ptr *uint64, new uint64) uint64\nfunc Xchg8(ptr *uint8, new uint8) uint8\nfunc Xchgint32(ptr *int32, new int32) int32\nfunc Xchgint64(ptr *int64, new int64) int64\nfunc Xchguintptr(ptr *uintptr, new uintptr) uintptr\n\nTYPES\n\ntype Bool struct {\n\t// Has unexported fields.\n}\n    Bool is an atomically accessed bool value.\n\n    A Bool must not be copied.\n\nfunc (b *Bool) Load() bool\n    Load accesses and returns the value atomically.\n\nfunc (b *Bool) Store(value bool)\n    Store updates the value atomically.\n\ntype Float64 struct {\n\t// Has unexported fields.\n}\n    Float64 is an atomically accessed float64 value.\n\n    8-byte aligned on all platforms, unlike a regular float64.\n\n    A Float64 must not be copied.\n\nfunc (f *Float64) Load() float64\n    Load accesses and returns the value atomically.\n\nfunc (f *Float64) Store(value float64)\n    Store updates the value atomically.\n\ntype Int32 struct {\n\t// Has unexported fields.\n}\n    Int32 is an atomically accessed int32 value.\n\n    An Int32 must not be copied.\n\nfunc (i *Int32) Add(delta int32) int32\n    Add adds delta to i atomically, returning the new updated value.\n\n    This operation wraps around in the usual two's-complement way.\n\nfunc (i *Int32) CompareAndSwap(old, new int32) bool\n    CompareAndSwap atomically compares i's value with old, and if they're equal,\n    swaps i's value with new. It reports whether the swap ran.\n\nfunc (i *Int32) Load() int32\n    Load accesses and returns the value atomically.\n\nfunc (i *Int32) Store(value int32)\n    Store updates the value atomically.\n\nfunc (i *Int32) Swap(new int32) int32\n    Swap replaces i's value with new, returning i's value before the\n    replacement.\n\ntype Int64 struct {\n\t// Has unexported fields.\n}\n    Int64 is an atomically accessed int64 value.\n\n    8-byte aligned on all platforms, unlike a regular int64.\n\n    An Int64 must not be copied.\n\nfunc (i *Int64) Add(delta int64) int64\n    Add adds delta to i atomically, returning the new updated value.\n\n    This operation wraps around in the usual two's-complement way.\n\nfunc (i *Int64) CompareAndSwap(old, new int64) bool\n    CompareAndSwap atomically compares i's value with old, and if they're equal,\n    swaps i's value with new. It reports whether the swap ran.\n\nfunc (i *Int64) Load() int64\n    Load accesses and returns the value atomically.\n\nfunc (i *Int64) Store(value int64)\n    Store updates the value atomically.\n\nfunc (i *Int64) Swap(new int64) int64\n    Swap replaces i's value with new, returning i's value before the\n    replacement.\n\ntype Pointer[T any] struct {\n\t// Has unexported fields.\n}\n    Pointer is an atomic pointer of type *T.\n\nfunc (p *Pointer[T]) CompareAndSwap(old, new *T) bool\n    CompareAndSwap atomically (with respect to other methods) compares u's value\n    with old, and if they're equal, swaps u's value with new. It reports whether\n    the swap ran.\n\nfunc (p *Pointer[T]) CompareAndSwapNoWB(old, new *T) bool\n    CompareAndSwapNoWB atomically (with respect to other methods) compares u's\n    value with old, and if they're equal, swaps u's value with new. It reports\n    whether the swap ran.\n\n    WARNING: As the name implies this operation does *not* perform a write\n    barrier on value, and so this operation may hide pointers from the GC.\n    Use with care and sparingly. It is safe to use with values not found in the\n    Go heap. Prefer CompareAndSwap instead.\n\nfunc (p *Pointer[T]) Load() *T\n    Load accesses and returns the value atomically.\n\nfunc (p *Pointer[T]) Store(value *T)\n    Store updates the value atomically.\n\nfunc (p *Pointer[T]) StoreNoWB(value *T)\n    StoreNoWB updates the value atomically.\n\n    WARNING: As the name implies this operation does *not* perform a write\n    barrier on value, and so this operation may hide pointers from the GC.\n    Use with care and sparingly. It is safe to use with values not found in the\n    Go heap. Prefer Store instead.\n\ntype Uint32 struct {\n\t// Has unexported fields.\n}\n    Uint32 is an atomically accessed uint32 value.\n\n    A Uint32 must not be copied.\n\nfunc (u *Uint32) Add(delta int32) uint32\n    Add adds delta to u atomically, returning the new updated value.\n\n    This operation wraps around in the usual two's-complement way.\n\nfunc (u *Uint32) And(value uint32)\n    And takes value and performs a bit-wise \"and\" operation with the value of u,\n    storing the result into u.\n\n    The full process is performed atomically.\n\nfunc (u *Uint32) CompareAndSwap(old, new uint32) bool\n    CompareAndSwap atomically compares u's value with old, and if they're equal,\n    swaps u's value with new. It reports whether the swap ran.\n\nfunc (u *Uint32) CompareAndSwapRelease(old, new uint32) bool\n    CompareAndSwapRelease is a partially unsynchronized version of Cas that\n    relaxes ordering constraints. Other threads may observe operations that\n    occur after this operation to precede it, but no operation that precedes\n    it on this thread can be observed to occur after it. It reports whether the\n    swap ran.\n\n    WARNING: Use sparingly and with great care.\n\nfunc (u *Uint32) Load() uint32\n    Load accesses and returns the value atomically.\n\nfunc (u *Uint32) LoadAcquire() uint32\n    LoadAcquire is a partially unsynchronized version of Load that relaxes\n    ordering constraints. Other threads may observe operations that precede this\n    operation to occur after it, but no operation that occurs after it on this\n    thread can be observed to occur before it.\n\n    WARNING: Use sparingly and with great care.\n\nfunc (u *Uint32) Or(value uint32)\n    Or takes value and performs a bit-wise \"or\" operation with the value of u,\n    storing the result into u.\n\n    The full process is performed atomically.\n\nfunc (u *Uint32) Store(value uint32)\n    Store updates the value atomically.\n\nfunc (u *Uint32) StoreRelease(value uint32)\n    StoreRelease is a partially unsynchronized version of Store that relaxes\n    ordering constraints. Other threads may observe operations that occur after\n    this operation to precede it, but no operation that precedes it on this\n    thread can be observed to occur after it.\n\n    WARNING: Use sparingly and with great care.\n\nfunc (u *Uint32) Swap(value uint32) uint32\n    Swap replaces u's value with new, returning u's value before the\n    replacement.\n\ntype Uint64 struct {\n\t// Has unexported fields.\n}\n    Uint64 is an atomically accessed uint64 value.\n\n    8-byte aligned on all platforms, unlike a regular uint64.\n\n    A Uint64 must not be copied.\n\nfunc (u *Uint64) Add(delta int64) uint64\n    Add adds delta to u atomically, returning the new updated value.\n\n    This operation wraps around in the usual two's-complement way.\n\nfunc (u *Uint64) CompareAndSwap(old, new uint64) bool\n    CompareAndSwap atomically compares u's value with old, and if they're equal,\n    swaps u's value with new. It reports whether the swap ran.\n\nfunc (u *Uint64) Load() uint64\n    Load accesses and returns the value atomically.\n\nfunc (u *Uint64) LoadAcquire() uint64\n    LoadAcquire is a partially unsynchronized version of Load that relaxes\n    ordering constraints. Other threads may observe operations that precede this\n    operation to occur after it, but no operation that occurs after it on this\n    thread can be observed to occur before it.\n\n    WARNING: Use sparingly and with great care.\n\nfunc (u *Uint64) Store(value uint64)\n    Store updates the value atomically.\n\nfunc (u *Uint64) StoreRelease(value uint64)\n    StoreRelease is a partially unsynchronized version of Store that relaxes\n    ordering constraints. Other threads may observe operations that occur after\n    this operation to precede it, but no operation that precedes it on this\n    thread can be observed to occur after it.\n\n    WARNING: Use sparingly and with great care.\n\nfunc (u *Uint64) Swap(value uint64) uint64\n    Swap replaces u's value with new, returning u's value before the\n    replacement.\n\ntype Uint8 struct {\n\t// Has unexported fields.\n}\n    Uint8 is an atomically accessed uint8 value.\n\n    A Uint8 must not be copied.\n\nfunc (u *Uint8) And(value uint8)\n    And takes value and performs a bit-wise \"and\" operation with the value of u,\n    storing the result into u.\n\n    The full process is performed atomically.\n\nfunc (u *Uint8) Load() uint8\n    Load accesses and returns the value atomically.\n\nfunc (u *Uint8) Or(value uint8)\n    Or takes value and performs a bit-wise \"or\" operation with the value of u,\n    storing the result into u.\n\n    The full process is performed atomically.\n\nfunc (u *Uint8) Store(value uint8)\n    Store updates the value atomically.\n\ntype Uintptr struct {\n\t// Has unexported fields.\n}\n    Uintptr is an atomically accessed uintptr value.\n\n    A Uintptr must not be copied.\n\nfunc (u *Uintptr) Add(delta uintptr) uintptr\n    Add adds delta to u atomically, returning the new updated value.\n\n    This operation wraps around in the usual two's-complement way.\n\nfunc (u *Uintptr) CompareAndSwap(old, new uintptr) bool\n    CompareAndSwap atomically compares u's value with old, and if they're equal,\n    swaps u's value with new. It reports whether the swap ran.\n\nfunc (u *Uintptr) Load() uintptr\n    Load accesses and returns the value atomically.\n\nfunc (u *Uintptr) LoadAcquire() uintptr\n    LoadAcquire is a partially unsynchronized version of Load that relaxes\n    ordering constraints. Other threads may observe operations that precede this\n    operation to occur after it, but no operation that occurs after it on this\n    thread can be observed to occur before it.\n\n    WARNING: Use sparingly and with great care.\n\nfunc (u *Uintptr) Store(value uintptr)\n    Store updates the value atomically.\n\nfunc (u *Uintptr) StoreRelease(value uintptr)\n    StoreRelease is a partially unsynchronized version of Store that relaxes\n    ordering constraints. Other threads may observe operations that occur after\n    this operation to precede it, but no operation that precedes it on this\n    thread can be observed to occur after it.\n\n    WARNING: Use sparingly and with great care.\n\nfunc (u *Uintptr) Swap(value uintptr) uintptr\n    Swap replaces u's value with new, returning u's value before the\n    replacement.\n\ntype UnsafePointer struct {\n\t// Has unexported fields.\n}\n    UnsafePointer is an atomically accessed unsafe.Pointer value.\n\n    Note that because of the atomicity guarantees, stores to values of this type\n    never trigger a write barrier, and the relevant methods are suffixed with\n    \"NoWB\" to indicate that explicitly. As a result, this type should be used\n    carefully, and sparingly, mostly with values that do not live in the Go heap\n    anyway.\n\n    An UnsafePointer must not be copied.\n\nfunc (u *UnsafePointer) CompareAndSwap(old, new unsafe.Pointer) bool\n    CompareAndSwap atomically compares u's value with old, and if they're equal,\n    swaps u's value with new. It reports whether the swap ran.\n\nfunc (u *UnsafePointer) CompareAndSwapNoWB(old, new unsafe.Pointer) bool\n    CompareAndSwapNoWB atomically (with respect to other methods) compares u's\n    value with old, and if they're equal, swaps u's value with new. It reports\n    whether the swap ran.\n\n    WARNING: As the name implies this operation does *not* perform a write\n    barrier on value, and so this operation may hide pointers from the GC.\n    Use with care and sparingly. It is safe to use with values not found in the\n    Go heap. Prefer CompareAndSwap instead.\n\nfunc (u *UnsafePointer) Load() unsafe.Pointer\n    Load accesses and returns the value atomically.\n\nfunc (u *UnsafePointer) Store(value unsafe.Pointer)\n    Store updates the value atomically.\n\nfunc (u *UnsafePointer) StoreNoWB(value unsafe.Pointer)\n    StoreNoWB updates the value atomically.\n\n    WARNING: As the name implies this operation does *not* perform a write\n    barrier on value, and so this operation may hide pointers from the GC.\n    Use with care and sparingly. It is safe to use with values not found in the\n    Go heap. Prefer Store instead.\n\n"}, {"path": "stdlib/vendor-golang.org-x-crypto-internal-poly1305.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-crypto-internal-poly1305", "content": ""}, {"path": "stdlib/crypto-ecdh.md", "category": "stdlib", "name": "stdlib/crypto-ecdh", "content": "package ecdh // import \"crypto/ecdh\"\n\nPackage ecdh implements Elliptic Curve Diffie-Hellman over NIST curves and\nCurve25519.\n\nTYPES\n\ntype Curve interface {\n\t// GenerateKey generates a random PrivateKey.\n\t//\n\t// Most applications should use [crypto/rand.Reader] as rand. Note that the\n\t// returned key does not depend deterministically on the bytes read from rand,\n\t// and may change between calls and/or between versions.\n\tGenerateKey(rand io.Reader) (*PrivateKey, error)\n\n\t// NewPrivateKey checks that key is valid and returns a PrivateKey.\n\t//\n\t// For NIST curves, this follows SEC 1, Version 2.0, Section 2.3.6, which\n\t// amounts to decoding the bytes as a fixed length big endian integer and\n\t// checking that the result is lower than the order of the curve. The zero\n\t// private key is also rejected, as the encoding of the corresponding public\n\t// key would be irregular.\n\t//\n\t// For X25519, this only checks the scalar length.\n\tNewPrivateKey(key []byte) (*PrivateKey, error)\n\n\t// NewPublicKey checks that key is valid and returns a PublicKey.\n\t//\n\t// For NIST curves, this decodes an uncompressed point according to SEC 1,\n\t// Version 2.0, Section 2.3.4. Compressed encodings and the point at\n\t// infinity are rejected.\n\t//\n\t// For X25519, this only checks the u-coordinate length. Adversarially\n\t// selected public keys can cause ECDH to return an error.\n\tNewPublicKey(key []byte) (*PublicKey, error)\n\n\t// Has unexported methods.\n}\n\nfunc P256() Curve\n    P256 returns a Curve which implements NIST P-256 (FIPS 186-3, section\n    D.2.3), also known as secp256r1 or prime256v1.\n\n    Multiple invocations of this function will return the same value, which can\n    be used for equality checks and switch statements.\n\nfunc P384() Curve\n    P384 returns a Curve which implements NIST P-384 (FIPS 186-3, section\n    D.2.4), also known as secp384r1.\n\n    Multiple invocations of this function will return the same value, which can\n    be used for equality checks and switch statements.\n\nfunc P521() Curve\n    P521 returns a Curve which implements NIST P-521 (FIPS 186-3, section\n    D.2.5), also known as secp521r1.\n\n    Multiple invocations of this function will return the same value, which can\n    be used for equality checks and switch statements.\n\nfunc X25519() Curve\n    X25519 returns a Curve which implements the X25519 function over Curve25519\n    (RFC 7748, Section 5).\n\n    Multiple invocations of this function will return the same value, so it can\n    be used for equality checks and switch statements.\n\ntype PrivateKey struct {\n\t// Has unexported fields.\n}\n    PrivateKey is an ECDH private key, usually kept secret.\n\n    These keys can be parsed with crypto/x509.ParsePKCS8PrivateKey and encoded\n    with crypto/x509.MarshalPKCS8PrivateKey. For NIST curves, they then need to\n    be converted with crypto/ecdsa.PrivateKey.ECDH after parsing.\n\nfunc (k *PrivateKey) Bytes() []byte\n    Bytes returns a copy of the encoding of the private key.\n\nfunc (k *PrivateKey) Curve() Curve\n\nfunc (k *PrivateKey) ECDH(remote *PublicKey) ([]byte, error)\n    ECDH performs an ECDH exchange and returns the shared secret. The PrivateKey\n    and PublicKey must use the same curve.\n\n    For NIST curves, this performs ECDH as specified in SEC 1, Version 2.0,\n    Section 3.3.1, and returns the x-coordinate encoded according to SEC 1,\n    Version 2.0, Section 2.3.5. The result is never the point at infinity.\n    This is also known as the Shared Secret Computation of the Ephemeral Unified\n    Model scheme specified in NIST SP 800-56A Rev. 3, Section 6.1.2.2.\n\n    For X25519, this performs ECDH as specified in RFC 7748, Section 6.1.\n    If the result is the all-zero value, ECDH returns an error.\n\nfunc (k *PrivateKey) Equal(x crypto.PrivateKey) bool\n    Equal returns whether x represents the same private key as k.\n\n    Note that there can be equivalent private keys with different encodings\n    which would return false from this check but behave the same way as inputs\n    to [ECDH].\n\n    This check is performed in constant time as long as the key types and their\n    curve match.\n\nfunc (k *PrivateKey) Public() crypto.PublicKey\n    Public implements the implicit interface of all standard library private\n    keys. See the docs of crypto.PrivateKey.\n\nfunc (k *PrivateKey) PublicKey() *PublicKey\n\ntype PublicKey struct {\n\t// Has unexported fields.\n}\n    PublicKey is an ECDH public key, usually a peer's ECDH share sent over the\n    wire.\n\n    These keys can be parsed with crypto/x509.ParsePKIXPublicKey and encoded\n    with crypto/x509.MarshalPKIXPublicKey. For NIST curves, they then need to be\n    converted with crypto/ecdsa.PublicKey.ECDH after parsing.\n\nfunc (k *PublicKey) Bytes() []byte\n    Bytes returns a copy of the encoding of the public key.\n\nfunc (k *PublicKey) Curve() Curve\n\nfunc (k *PublicKey) Equal(x crypto.PublicKey) bool\n    Equal returns whether x represents the same public key as k.\n\n    Note that there can be equivalent public keys with different encodings which\n    would return false from this check but behave the same way as inputs to\n    ECDH.\n\n    This check is performed in constant time as long as the key types and their\n    curve match.\n\n"}, {"path": "stdlib/crypto-internal-fips140-mlkem.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-mlkem", "content": "package mlkem // import \"crypto/internal/fips140/mlkem\"\n\nPackage mlkem implements the quantum-resistant key encapsulation method ML-KEM\n(formerly known as Kyber), as specified in NIST FIPS 203.\n\n[NIST FIPS 203]: https://doi.org/10.6028/NIST.FIPS.203\n\nCONSTANTS\n\nconst (\n\tSharedKeySize = 32\n\tSeedSize      = 32 + 32\n)\nconst (\n\tCiphertextSize768       = k*encodingSize10 + encodingSize4\n\tEncapsulationKeySize768 = k*encodingSize12 + 32\n)\n    ML-KEM-768 parameters.\n\nconst (\n\tCiphertextSize1024       = k1024*encodingSize11 + encodingSize5\n\tEncapsulationKeySize1024 = k1024*encodingSize12 + 32\n)\n    ML-KEM-1024 parameters.\n\n\nFUNCTIONS\n\nfunc TestingOnlyExpandedBytes1024(dk *DecapsulationKey1024) []byte\n    TestingOnlyExpandedBytes1024 returns the decapsulation key as a byte slice\n    using the full expanded NIST encoding.\n\n    This should only be used for ACVP testing. For all other purposes prefer the\n    Bytes method that returns the (much smaller) seed.\n\nfunc TestingOnlyExpandedBytes768(dk *DecapsulationKey768) []byte\n    TestingOnlyExpandedBytes768 returns the decapsulation key as a byte slice\n    using the full expanded NIST encoding.\n\n    This should only be used for ACVP testing. For all other purposes prefer the\n    Bytes method that returns the (much smaller) seed.\n\n\nTYPES\n\ntype DecapsulationKey1024 struct {\n\t// Has unexported fields.\n}\n    A DecapsulationKey1024 is the secret key used to decapsulate a shared key\n    from a ciphertext. It includes various precomputed values.\n\nfunc GenerateKey1024() (*DecapsulationKey1024, error)\n    GenerateKey1024 generates a new decapsulation key, drawing random bytes from\n    a DRBG. The decapsulation key must be kept secret.\n\nfunc GenerateKeyInternal1024(d, z *[32]byte) *DecapsulationKey1024\n    GenerateKeyInternal1024 is a derandomized version of GenerateKey1024,\n    exclusively for use in tests.\n\nfunc NewDecapsulationKey1024(seed []byte) (*DecapsulationKey1024, error)\n    NewDecapsulationKey1024 parses a decapsulation key from a 64-byte seed in\n    the \"d || z\" form. The seed must be uniformly random.\n\nfunc TestingOnlyNewDecapsulationKey1024(b []byte) (*DecapsulationKey1024, error)\n    TestingOnlyNewDecapsulationKey1024 parses a decapsulation key from its\n    expanded NIST format.\n\n    Bytes() must not be called on the returned key, as it will not produce the\n    original seed.\n\n    This function should only be used for ACVP testing. Prefer\n    NewDecapsulationKey1024 for all other purposes.\n\nfunc (dk *DecapsulationKey1024) Bytes() []byte\n    Bytes returns the decapsulation key as a 64-byte seed in the \"d || z\" form.\n\n    The decapsulation key must be kept secret.\n\nfunc (dk *DecapsulationKey1024) Decapsulate(ciphertext []byte) (sharedKey []byte, err error)\n    Decapsulate generates a shared key from a ciphertext and a decapsulation\n    key. If the ciphertext is not valid, Decapsulate returns an error.\n\n    The shared key must be kept secret.\n\nfunc (dk *DecapsulationKey1024) EncapsulationKey() *EncapsulationKey1024\n    EncapsulationKey returns the public encapsulation key necessary to produce\n    ciphertexts.\n\ntype DecapsulationKey768 struct {\n\t// Has unexported fields.\n}\n    A DecapsulationKey768 is the secret key used to decapsulate a shared key\n    from a ciphertext. It includes various precomputed values.\n\nfunc GenerateKey768() (*DecapsulationKey768, error)\n    GenerateKey768 generates a new decapsulation key, drawing random bytes from\n    a DRBG. The decapsulation key must be kept secret.\n\nfunc GenerateKeyInternal768(d, z *[32]byte) *DecapsulationKey768\n    GenerateKeyInternal768 is a derandomized version of GenerateKey768,\n    exclusively for use in tests.\n\nfunc NewDecapsulationKey768(seed []byte) (*DecapsulationKey768, error)\n    NewDecapsulationKey768 parses a decapsulation key from a 64-byte seed in the\n    \"d || z\" form. The seed must be uniformly random.\n\nfunc TestingOnlyNewDecapsulationKey768(b []byte) (*DecapsulationKey768, error)\n    TestingOnlyNewDecapsulationKey768 parses a decapsulation key from its\n    expanded NIST format.\n\n    Bytes() must not be called on the returned key, as it will not produce the\n    original seed.\n\n    This function should only be used for ACVP testing. Prefer\n    NewDecapsulationKey768 for all other purposes.\n\nfunc (dk *DecapsulationKey768) Bytes() []byte\n    Bytes returns the decapsulation key as a 64-byte seed in the \"d || z\" form.\n\n    The decapsulation key must be kept secret.\n\nfunc (dk *DecapsulationKey768) Decapsulate(ciphertext []byte) (sharedKey []byte, err error)\n    Decapsulate generates a shared key from a ciphertext and a decapsulation\n    key. If the ciphertext is not valid, Decapsulate returns an error.\n\n    The shared key must be kept secret.\n\nfunc (dk *DecapsulationKey768) EncapsulationKey() *EncapsulationKey768\n    EncapsulationKey returns the public encapsulation key necessary to produce\n    ciphertexts.\n\ntype EncapsulationKey1024 struct {\n\t// Has unexported fields.\n}\n    An EncapsulationKey1024 is the public key used to produce ciphertexts to be\n    decapsulated by the corresponding DecapsulationKey1024.\n\nfunc NewEncapsulationKey1024(encapsulationKey []byte) (*EncapsulationKey1024, error)\n    NewEncapsulationKey1024 parses an encapsulation key from its encoded form.\n    If the encapsulation key is not valid, NewEncapsulationKey1024 returns an\n    error.\n\nfunc (ek *EncapsulationKey1024) Bytes() []byte\n    Bytes returns the encapsulation key as a byte slice.\n\nfunc (ek *EncapsulationKey1024) Encapsulate() (sharedKey, ciphertext []byte)\n    Encapsulate generates a shared key and an associated ciphertext from an\n    encapsulation key, drawing random bytes from a DRBG.\n\n    The shared key must be kept secret.\n\nfunc (ek *EncapsulationKey1024) EncapsulateInternal(m *[32]byte) (sharedKey, ciphertext []byte)\n    EncapsulateInternal is a derandomized version of Encapsulate, exclusively\n    for use in tests.\n\ntype EncapsulationKey768 struct {\n\t// Has unexported fields.\n}\n    An EncapsulationKey768 is the public key used to produce ciphertexts to be\n    decapsulated by the corresponding DecapsulationKey768.\n\nfunc NewEncapsulationKey768(encapsulationKey []byte) (*EncapsulationKey768, error)\n    NewEncapsulationKey768 parses an encapsulation key from its encoded form. If\n    the encapsulation key is not valid, NewEncapsulationKey768 returns an error.\n\nfunc (ek *EncapsulationKey768) Bytes() []byte\n    Bytes returns the encapsulation key as a byte slice.\n\nfunc (ek *EncapsulationKey768) Encapsulate() (sharedKey, ciphertext []byte)\n    Encapsulate generates a shared key and an associated ciphertext from an\n    encapsulation key, drawing random bytes from a DRBG.\n\n    The shared key must be kept secret.\n\nfunc (ek *EncapsulationKey768) EncapsulateInternal(m *[32]byte) (sharedKey, ciphertext []byte)\n    EncapsulateInternal is a derandomized version of Encapsulate, exclusively\n    for use in tests.\n\n"}, {"path": "stdlib/encoding-csv.md", "category": "stdlib", "name": "stdlib/encoding-csv", "content": "package csv // import \"encoding/csv\"\n\nPackage csv reads and writes comma-separated values (CSV) files. There are many\nkinds of CSV files; this package supports the format described in RFC 4180,\nexcept that Writer uses LF instead of CRLF as newline character by default.\n\nA csv file contains zero or more records of one or more fields per record. Each\nrecord is separated by the newline character. The final record may optionally be\nfollowed by a newline character.\n\n    field1,field2,field3\n\nWhite space is considered part of a field.\n\nCarriage returns before newline characters are silently removed.\n\nBlank lines are ignored. A line with only whitespace characters (excluding the\nending newline character) is not considered a blank line.\n\nFields which start and stop with the quote character \" are called quoted-fields.\nThe beginning and ending quote are not part of the field.\n\nThe source:\n\n    normal string,\"quoted-field\"\n\nresults in the fields\n\n    {`normal string`, `quoted-field`}\n\nWithin a quoted-field a quote character followed by a second quote character is\nconsidered a single quote.\n\n    \"the \"\"word\"\" is true\",\"a \"\"quoted-field\"\"\"\n\nresults in\n\n    {`the \"word\" is true`, `a \"quoted-field\"`}\n\nNewlines and commas may be included in a quoted-field\n\n    \"Multi-line\n    field\",\"comma is ,\"\n\nresults in\n\n    {`Multi-line\n    field`, `comma is ,`}\n\nVARIABLES\n\nvar (\n\tErrBareQuote  = errors.New(\"bare \\\" in non-quoted-field\")\n\tErrQuote      = errors.New(\"extraneous or missing \\\" in quoted-field\")\n\tErrFieldCount = errors.New(\"wrong number of fields\")\n\n\t// Deprecated: ErrTrailingComma is no longer used.\n\tErrTrailingComma = errors.New(\"extra delimiter at end of line\")\n)\n    These are the errors that can be returned in [ParseError.Err].\n\n\nTYPES\n\ntype ParseError struct {\n\tStartLine int   // Line where the record starts\n\tLine      int   // Line where the error occurred\n\tColumn    int   // Column (1-based byte index) where the error occurred\n\tErr       error // The actual error\n}\n    A ParseError is returned for parsing errors. Line and column numbers are\n    1-indexed.\n\nfunc (e *ParseError) Error() string\n\nfunc (e *ParseError) Unwrap() error\n\ntype Reader struct {\n\t// Comma is the field delimiter.\n\t// It is set to comma (',') by NewReader.\n\t// Comma must be a valid rune and must not be \\r, \\n,\n\t// or the Unicode replacement character (0xFFFD).\n\tComma rune\n\n\t// Comment, if not 0, is the comment character. Lines beginning with the\n\t// Comment character without preceding whitespace are ignored.\n\t// With leading whitespace the Comment character becomes part of the\n\t// field, even if TrimLeadingSpace is true.\n\t// Comment must be a valid rune and must not be \\r, \\n,\n\t// or the Unicode replacement character (0xFFFD).\n\t// It must also not be equal to Comma.\n\tComment rune\n\n\t// FieldsPerRecord is the number of expected fields per record.\n\t// If FieldsPerRecord is positive, Read requires each record to\n\t// have the given number of fields. If FieldsPerRecord is 0, Read sets it to\n\t// the number of fields in the first record, so that future records must\n\t// have the same field count. If FieldsPerRecord is negative, no check is\n\t// made and records may have a variable number of fields.\n\tFieldsPerRecord int\n\n\t// If LazyQuotes is true, a quote may appear in an unquoted field and a\n\t// non-doubled quote may appear in a quoted field.\n\tLazyQuotes bool\n\n\t// If TrimLeadingSpace is true, leading white space in a field is ignored.\n\t// This is done even if the field delimiter, Comma, is white space.\n\tTrimLeadingSpace bool\n\n\t// ReuseRecord controls whether calls to Read may return a slice sharing\n\t// the backing array of the previous call's returned slice for performance.\n\t// By default, each call to Read returns newly allocated memory owned by the caller.\n\tReuseRecord bool\n\n\t// Deprecated: TrailingComma is no longer used.\n\tTrailingComma bool\n\n\t// Has unexported fields.\n}\n    A Reader reads records from a CSV-encoded file.\n\n    As returned by NewReader, a Reader expects input conforming to RFC 4180.\n    The exported fields can be changed to customize the details before the first\n    call to Reader.Read or Reader.ReadAll.\n\n    The Reader converts all \\r\\n sequences in its input to plain \\n, including\n    in multiline field values, so that the returned data does not depend on\n    which line-ending convention an input file uses.\n\nfunc NewReader(r io.Reader) *Reader\n    NewReader returns a new Reader that reads from r.\n\nfunc (r *Reader) FieldPos(field int) (line, column int)\n    FieldPos returns the line and column corresponding to the start of the field\n    with the given index in the slice most recently returned by Reader.Read.\n    Numbering of lines and columns starts at 1; columns are counted in bytes,\n    not runes.\n\n    If this is called with an out-of-bounds index, it panics.\n\nfunc (r *Reader) InputOffset() int64\n    InputOffset returns the input stream byte offset of the current reader\n    position. The offset gives the location of the end of the most recently read\n    row and the beginning of the next row.\n\nfunc (r *Reader) Read() (record []string, err error)\n    Read reads one record (a slice of fields) from r. If the record has an\n    unexpected number of fields, Read returns the record along with the error\n    ErrFieldCount. If the record contains a field that cannot be parsed,\n    Read returns a partial record along with the parse error. The partial\n    record contains all fields read before the error. If there is no data left\n    to be read, Read returns nil, io.EOF. If [Reader.ReuseRecord] is true,\n    the returned slice may be shared between multiple calls to Read.\n\nfunc (r *Reader) ReadAll() (records [][]string, err error)\n    ReadAll reads all the remaining records from r. Each record is a slice of\n    fields. A successful call returns err == nil, not err == io.EOF. Because\n    ReadAll is defined to read until EOF, it does not treat end of file as an\n    error to be reported.\n\ntype Writer struct {\n\tComma   rune // Field delimiter (set to ',' by NewWriter)\n\tUseCRLF bool // True to use \\r\\n as the line terminator\n\t// Has unexported fields.\n}\n    A Writer writes records using CSV encoding.\n\n    As returned by NewWriter, a Writer writes records terminated by a\n    newline and uses ',' as the field delimiter. The exported fields can be\n    changed to customize the details before the first call to Writer.Write or\n    Writer.WriteAll.\n\n    [Writer.Comma] is the field delimiter.\n\n    If [Writer.UseCRLF] is true, the Writer ends each output line with \\r\\n\n    instead of \\n.\n\n    The writes of individual records are buffered. After all data has been\n    written, the client should call the Writer.Flush method to guarantee\n    all data has been forwarded to the underlying io.Writer. Any errors that\n    occurred should be checked by calling the Writer.Error method.\n\nfunc NewWriter(w io.Writer) *Writer\n    NewWriter returns a new Writer that writes to w.\n\nfunc (w *Writer) Error() error\n    Error reports any error that has occurred during a previous Writer.Write or\n    Writer.Flush.\n\nfunc (w *Writer) Flush()\n    Flush writes any buffered data to the underlying io.Writer. To check if an\n    error occurred during Flush, call Writer.Error.\n\nfunc (w *Writer) Write(record []string) error\n    Write writes a single CSV record to w along with any necessary quoting.\n    A record is a slice of strings with each string being one field. Writes\n    are buffered, so Writer.Flush must eventually be called to ensure that the\n    record is written to the underlying io.Writer.\n\nfunc (w *Writer) WriteAll(records [][]string) error\n    WriteAll writes multiple CSV records to w using Writer.Write and then calls\n    Writer.Flush, returning any error from the Flush.\n\n"}, {"path": "stdlib/crypto-internal-fips140-tls13.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-tls13", "content": "package tls13 // import \"crypto/internal/fips140/tls13\"\n\nPackage tls13 implements the TLS 1.3 Key Schedule as specified in RFC 8446,\nSection 7.1 and allowed by FIPS 140-3 IG 2.4.B Resolution 7.\n\nFUNCTIONS\n\nfunc ExpandLabel[H hash.Hash](hash func() H, secret []byte, label string, context []byte, length int) []byte\n    ExpandLabel implements HKDF-Expand-Label from RFC 8446, Section 7.1.\n\nfunc TestingOnlyExporterSecret(s *ExporterMasterSecret) []byte\n\nTYPES\n\ntype EarlySecret struct {\n\t// Has unexported fields.\n}\n\nfunc NewEarlySecret[H hash.Hash](h func() H, psk []byte) *EarlySecret\n\nfunc (s *EarlySecret) ClientEarlyTrafficSecret(transcript hash.Hash) []byte\n    ClientEarlyTrafficSecret derives the client_early_traffic_secret from the\n    early secret and the transcript up to the ClientHello.\n\nfunc (s *EarlySecret) EarlyExporterMasterSecret(transcript hash.Hash) *ExporterMasterSecret\n    EarlyExporterMasterSecret derives the exporter_master_secret from the early\n    secret and the transcript up to the ClientHello.\n\nfunc (s *EarlySecret) HandshakeSecret(sharedSecret []byte) *HandshakeSecret\n\nfunc (s *EarlySecret) ResumptionBinderKey() []byte\n\ntype ExporterMasterSecret struct {\n\t// Has unexported fields.\n}\n\nfunc (s *ExporterMasterSecret) Exporter(label string, context []byte, length int) []byte\n\ntype HandshakeSecret struct {\n\t// Has unexported fields.\n}\n\nfunc (s *HandshakeSecret) ClientHandshakeTrafficSecret(transcript hash.Hash) []byte\n    ClientHandshakeTrafficSecret derives the client_handshake_traffic_secret\n    from the handshake secret and the transcript up to the ServerHello.\n\nfunc (s *HandshakeSecret) MasterSecret() *MasterSecret\n\nfunc (s *HandshakeSecret) ServerHandshakeTrafficSecret(transcript hash.Hash) []byte\n    ServerHandshakeTrafficSecret derives the server_handshake_traffic_secret\n    from the handshake secret and the transcript up to the ServerHello.\n\ntype MasterSecret struct {\n\t// Has unexported fields.\n}\n\nfunc (s *MasterSecret) ClientApplicationTrafficSecret(transcript hash.Hash) []byte\n    ClientApplicationTrafficSecret derives the\n    client_application_traffic_secret_0 from the master secret and the\n    transcript up to the server Finished.\n\nfunc (s *MasterSecret) ExporterMasterSecret(transcript hash.Hash) *ExporterMasterSecret\n    ExporterMasterSecret derives the exporter_master_secret from the master\n    secret and the transcript up to the server Finished.\n\nfunc (s *MasterSecret) ResumptionMasterSecret(transcript hash.Hash) []byte\n    ResumptionMasterSecret derives the resumption_master_secret from the master\n    secret and the transcript up to the client Finished.\n\nfunc (s *MasterSecret) ServerApplicationTrafficSecret(transcript hash.Hash) []byte\n    ServerApplicationTrafficSecret derives the\n    server_application_traffic_secret_0 from the master secret and the\n    transcript up to the server Finished.\n\n"}, {"path": "stdlib/internal-zstd.md", "category": "stdlib", "name": "stdlib/internal-zstd", "content": "package zstd // import \"internal/zstd\"\n\nPackage zstd provides a decompressor for zstd streams, described in RFC 8878.\nIt does not support dictionaries.\n\nTYPES\n\ntype Reader struct {\n\t// Has unexported fields.\n}\n    Reader implements io.Reader to read a zstd compressed stream.\n\nfunc NewReader(input io.Reader) *Reader\n    NewReader creates a new Reader that decompresses data from the given reader.\n\nfunc (r *Reader) Read(p []byte) (int, error)\n    Read implements io.Reader.\n\nfunc (r *Reader) ReadByte() (byte, error)\n    ReadByte implements io.ByteReader.\n\nfunc (r *Reader) Reset(input io.Reader)\n    Reset discards the current state and starts reading a new stream from r.\n    This permits reusing a Reader rather than allocating a new one.\n\n"}, {"path": "stdlib/internal-coverage-encodecounter.md", "category": "stdlib", "name": "stdlib/internal-coverage-encodecounter", "content": "package encodecounter // import \"internal/coverage/encodecounter\"\n\n\nTYPES\n\ntype CounterVisitor interface {\n\tVisitFuncs(f CounterVisitorFn) error\n}\n    CounterVisitor describes a helper object used during counter file writing;\n    when writing counter data files, clients pass a CounterVisitor to the\n    write/emit routines, then the expectation is that the VisitFuncs method\n    will then invoke the callback \"f\" with data for each function to emit to the\n    file.\n\ntype CounterVisitorFn func(pkid uint32, funcid uint32, counters []uint32) error\n    CounterVisitorFn describes a callback function invoked when writing coverage\n    counter data.\n\ntype CoverageDataWriter struct {\n\t// Has unexported fields.\n}\n\nfunc NewCoverageDataWriter(w io.Writer, flav coverage.CounterFlavor) *CoverageDataWriter\n\nfunc (cfw *CoverageDataWriter) AppendSegment(args map[string]string, visitor CounterVisitor) error\n    AppendSegment appends a new segment to a counter data, with a new args\n    section followed by a payload of counter data clauses.\n\nfunc (cfw *CoverageDataWriter) Write(metaFileHash [16]byte, args map[string]string, visitor CounterVisitor) error\n    Write writes the contents of the count-data file to the writer previously\n    supplied to NewCoverageDataWriter. Returns an error if something went wrong\n    somewhere with the write.\n\n"}, {"path": "stdlib/container-list.md", "category": "stdlib", "name": "stdlib/container-list", "content": "package list // import \"container/list\"\n\nPackage list implements a doubly linked list.\n\nTo iterate over a list (where l is a *List):\n\n    for e := l.Front(); e != nil; e = e.Next() {\n    \t// do something with e.Value\n    }\n\nTYPES\n\ntype Element struct {\n\n\t// The value stored with this element.\n\tValue any\n\t// Has unexported fields.\n}\n    Element is an element of a linked list.\n\nfunc (e *Element) Next() *Element\n    Next returns the next list element or nil.\n\nfunc (e *Element) Prev() *Element\n    Prev returns the previous list element or nil.\n\ntype List struct {\n\t// Has unexported fields.\n}\n    List represents a doubly linked list. The zero value for List is an empty\n    list ready to use.\n\nfunc New() *List\n    New returns an initialized list.\n\nfunc (l *List) Back() *Element\n    Back returns the last element of list l or nil if the list is empty.\n\nfunc (l *List) Front() *Element\n    Front returns the first element of list l or nil if the list is empty.\n\nfunc (l *List) Init() *List\n    Init initializes or clears list l.\n\nfunc (l *List) InsertAfter(v any, mark *Element) *Element\n    InsertAfter inserts a new element e with value v immediately after mark\n    and returns e. If mark is not an element of l, the list is not modified.\n    The mark must not be nil.\n\nfunc (l *List) InsertBefore(v any, mark *Element) *Element\n    InsertBefore inserts a new element e with value v immediately before mark\n    and returns e. If mark is not an element of l, the list is not modified.\n    The mark must not be nil.\n\nfunc (l *List) Len() int\n    Len returns the number of elements of list l. The complexity is O(1).\n\nfunc (l *List) MoveAfter(e, mark *Element)\n    MoveAfter moves element e to its new position after mark. If e or mark is\n    not an element of l, or e == mark, the list is not modified. The element and\n    mark must not be nil.\n\nfunc (l *List) MoveBefore(e, mark *Element)\n    MoveBefore moves element e to its new position before mark. If e or mark is\n    not an element of l, or e == mark, the list is not modified. The element and\n    mark must not be nil.\n\nfunc (l *List) MoveToBack(e *Element)\n    MoveToBack moves element e to the back of list l. If e is not an element of\n    l, the list is not modified. The element must not be nil.\n\nfunc (l *List) MoveToFront(e *Element)\n    MoveToFront moves element e to the front of list l. If e is not an element\n    of l, the list is not modified. The element must not be nil.\n\nfunc (l *List) PushBack(v any) *Element\n    PushBack inserts a new element e with value v at the back of list l and\n    returns e.\n\nfunc (l *List) PushBackList(other *List)\n    PushBackList inserts a copy of another list at the back of list l. The lists\n    l and other may be the same. They must not be nil.\n\nfunc (l *List) PushFront(v any) *Element\n    PushFront inserts a new element e with value v at the front of list l and\n    returns e.\n\nfunc (l *List) PushFrontList(other *List)\n    PushFrontList inserts a copy of another list at the front of list l.\n    The lists l and other may be the same. They must not be nil.\n\nfunc (l *List) Remove(e *Element) any\n    Remove removes e from l if e is an element of list l. It returns the element\n    value e.Value. The element must not be nil.\n\n"}, {"path": "stdlib/embed.md", "category": "stdlib", "name": "stdlib/embed", "content": "package embed // import \"embed\"\n\nPackage embed provides access to files embedded in the running Go program.\n\nGo source files that import \"embed\" can use the //go:embed directive to\ninitialize a variable of type string, []byte, or FS with the contents of files\nread from the package directory or subdirectories at compile time.\n\nFor example, here are three ways to embed a file named hello.txt and then print\nits contents at run time.\n\nEmbedding one file into a string:\n\n    import _ \"embed\"\n\n    //go:embed hello.txt\n    var s string\n    print(s)\n\nEmbedding one file into a slice of bytes:\n\n    import _ \"embed\"\n\n    //go:embed hello.txt\n    var b []byte\n    print(string(b))\n\nEmbedded one or more files into a file system:\n\n    import \"embed\"\n\n    //go:embed hello.txt\n    var f embed.FS\n    data, _ := f.ReadFile(\"hello.txt\")\n    print(string(data))\n\n# Directives\n\nA //go:embed directive above a variable declaration specifies which files to\nembed, using one or more path.Match patterns.\n\nThe directive must immediately precede a line containing the declaration of a\nsingle variable. Only blank lines and \u2018//\u2019 line comments are permitted between\nthe directive and the declaration.\n\nThe type of the variable must be a string type, or a slice of a byte type,\nor FS (or an alias of FS).\n\nFor example:\n\n    package server\n\n    import \"embed\"\n\n    // content holds our static web server content.\n    //go:embed image/* template/*\n    //go:embed html/index.html\n    var content embed.FS\n\nThe Go build system will recognize the directives and arrange for the declared\nvariable (in the example above, content) to be populated with the matching files\nfrom the file system.\n\nThe //go:embed directive accepts multiple space-separated patterns for brevity,\nbut it can also be repeated, to avoid very long lines when there are many\npatterns. The patterns are interpreted relative to the package directory\ncontaining the source file. The path separator is a forward slash, even on\nWindows systems. Patterns may not contain \u2018.\u2019 or \u2018..\u2019 or empty path elements,\nnor may they begin or end with a slash. To match everything in the current\ndirectory, use \u2018*\u2019 instead of \u2018.\u2019. To allow for naming files with spaces in\ntheir names, patterns can be written as Go double-quoted or back-quoted string\nliterals.\n\nIf a pattern names a directory, all files in the subtree rooted at that\ndirectory are embedded (recursively), except that files with names beginning\nwith \u2018.\u2019 or \u2018_\u2019 are excluded. So the variable in the above example is almost\nequivalent to:\n\n    // content is our static web server content.\n    //go:embed image template html/index.html\n    var content embed.FS\n\nThe difference is that \u2018image/*\u2019 embeds \u2018image/.tempfile\u2019 while \u2018image\u2019 does\nnot. Neither embeds \u2018image/dir/.tempfile\u2019.\n\nIf a pattern begins with the prefix \u2018all:\u2019, then the rule for walking\ndirectories is changed to include those files beginning with \u2018.\u2019 or \u2018_\u2019. For\nexample, \u2018all:image\u2019 embeds both \u2018image/.tempfile\u2019 and \u2018image/dir/.tempfile\u2019.\n\nThe //go:embed directive can be used with both exported and unexported\nvariables, depending on whether the package wants to make the data available to\nother packages. It can only be used with variables at package scope, not with\nlocal variables.\n\nPatterns must not match files outside the package's module, such as \u2018.git/*\u2019,\nsymbolic links, 'vendor/', or any directories containing go.mod (these are\nseparate modules). Patterns must not match files whose names include the special\npunctuation characters \" * < > ? ` ' | / \\ and :. Matches for empty directories\nare ignored. After that, each pattern in a //go:embed line must match at least\none file or non-empty directory.\n\nIf any patterns are invalid or have invalid matches, the build will fail.\n\n# Strings and Bytes\n\nThe //go:embed line for a variable of type string or []byte can have only a\nsingle pattern, and that pattern can match only a single file. The string or\n[]byte is initialized with the contents of that file.\n\nThe //go:embed directive requires importing \"embed\", even when using a string or\n[]byte. In source files that don't refer to embed.FS, use a blank import (import\n_ \"embed\").\n\n# File Systems\n\nFor embedding a single file, a variable of type string or []byte is often best.\nThe FS type enables embedding a tree of files, such as a directory of static web\nserver content, as in the example above.\n\nFS implements the io/fs package's FS interface, so it can be used with any\npackage that understands file systems, including net/http, text/template,\nand html/template.\n\nFor example, given the content variable in the example above, we can write:\n\n    http.Handle(\"/static/\", http.StripPrefix(\"/static/\", http.FileServer(http.FS(content))))\n\n    template.ParseFS(content, \"*.tmpl\")\n\n# Tools\n\nTo support tools that analyze Go packages, the patterns found in\n//go:embed lines are available in \u201cgo list\u201d output. See the EmbedPatterns,\nTestEmbedPatterns, and XTestEmbedPatterns fields in the \u201cgo help list\u201d output.\n\nTYPES\n\ntype FS struct {\n\t// Has unexported fields.\n}\n    An FS is a read-only collection of files, usually initialized with a\n    //go:embed directive. When declared without a //go:embed directive, an FS is\n    an empty file system.\n\n    An FS is a read-only value, so it is safe to use from multiple goroutines\n    simultaneously and also safe to assign values of type FS to each other.\n\n    FS implements fs.FS, so it can be used with any package that understands\n    file system interfaces, including net/http, text/template, and\n    html/template.\n\n    See the package documentation for more details about initializing an FS.\n\nfunc (f FS) Open(name string) (fs.File, error)\n    Open opens the named file for reading and returns it as an fs.File.\n\n    The returned file implements io.Seeker and io.ReaderAt when the file is not\n    a directory.\n\nfunc (f FS) ReadDir(name string) ([]fs.DirEntry, error)\n    ReadDir reads and returns the entire named directory.\n\nfunc (f FS) ReadFile(name string) ([]byte, error)\n    ReadFile reads and returns the content of the named file.\n\n"}, {"path": "stdlib/internal-fuzz.md", "category": "stdlib", "name": "stdlib/internal-fuzz", "content": "package fuzz // import \"internal/fuzz\"\n\nPackage fuzz provides common fuzzing functionality for tests built with \"go\ntest\" and for programs that use fuzzing functionality in the testing package.\n\nFUNCTIONS\n\nfunc CheckCorpus(vals []any, types []reflect.Type) error\n    CheckCorpus verifies that the types in vals match the expected types\n    provided.\n\nfunc CoordinateFuzzing(ctx context.Context, opts CoordinateFuzzingOpts) (err error)\n    CoordinateFuzzing creates several worker processes and communicates with\n    them to test random inputs that could trigger crashes and expose bugs.\n    The worker processes run the same binary in the same directory with the same\n    environment variables as the coordinator process. Workers also run with the\n    same arguments as the coordinator, except with the -test.fuzzworker flag\n    prepended to the argument list.\n\n    If a crash occurs, the function will return an error containing information\n    about the crash, which can be reported to the user.\n\nfunc ResetCoverage()\n    ResetCoverage sets all of the counters for each edge of the instrumented\n    source code to 0.\n\nfunc RunFuzzWorker(ctx context.Context, fn func(CorpusEntry) error) error\n    RunFuzzWorker is called in a worker process to communicate with the\n    coordinator process in order to fuzz random inputs. RunFuzzWorker loops\n    until the coordinator tells it to stop.\n\n    fn is a wrapper on the fuzz function. It may return an error to indicate\n    a given input \"crashed\". The coordinator will also record a crasher if the\n    function times out or terminates the process.\n\n    RunFuzzWorker returns an error if it could not communicate with the\n    coordinator process.\n\nfunc SnapshotCoverage()\n    SnapshotCoverage copies the current counter values into coverageSnapshot,\n    preserving them for later inspection. SnapshotCoverage also rounds each\n    counter down to the nearest power of two. This lets the coordinator store\n    multiple values for each counter by OR'ing them together.\n\n\nTYPES\n\ntype CoordinateFuzzingOpts struct {\n\t// Log is a writer for logging progress messages and warnings.\n\t// If nil, io.Discard will be used instead.\n\tLog io.Writer\n\n\t// Timeout is the amount of wall clock time to spend fuzzing after the corpus\n\t// has loaded. If zero, there will be no time limit.\n\tTimeout time.Duration\n\n\t// Limit is the number of random values to generate and test. If zero,\n\t// there will be no limit on the number of generated values.\n\tLimit int64\n\n\t// MinimizeTimeout is the amount of wall clock time to spend minimizing\n\t// after discovering a crasher. If zero, there will be no time limit. If\n\t// MinimizeTimeout and MinimizeLimit are both zero, then minimization will\n\t// be disabled.\n\tMinimizeTimeout time.Duration\n\n\t// MinimizeLimit is the maximum number of calls to the fuzz function to be\n\t// made while minimizing after finding a crash. If zero, there will be no\n\t// limit. Calls to the fuzz function made when minimizing also count toward\n\t// Limit. If MinimizeTimeout and MinimizeLimit are both zero, then\n\t// minimization will be disabled.\n\tMinimizeLimit int64\n\n\t// parallel is the number of worker processes to run in parallel. If zero,\n\t// CoordinateFuzzing will run GOMAXPROCS workers.\n\tParallel int\n\n\t// Seed is a list of seed values added by the fuzz target with testing.F.Add\n\t// and in testdata.\n\tSeed []CorpusEntry\n\n\t// Types is the list of types which make up a corpus entry.\n\t// Types must be set and must match values in Seed.\n\tTypes []reflect.Type\n\n\t// CorpusDir is a directory where files containing values that crash the\n\t// code being tested may be written. CorpusDir must be set.\n\tCorpusDir string\n\n\t// CacheDir is a directory containing additional \"interesting\" values.\n\t// The fuzzer may derive new values from these, and may write new values here.\n\tCacheDir string\n}\n    CoordinateFuzzingOpts is a set of arguments for CoordinateFuzzing. The zero\n    value is valid for each field unless specified otherwise.\n\ntype CorpusEntry = struct {\n\tParent string\n\n\t// Path is the path of the corpus file, if the entry was loaded from disk.\n\t// For other entries, including seed values provided by f.Add, Path is the\n\t// name of the test, e.g. seed#0 or its hash.\n\tPath string\n\n\t// Data is the raw input data. Data should only be populated for seed\n\t// values. For on-disk corpus files, Data will be nil, as it will be loaded\n\t// from disk using Path.\n\tData []byte\n\n\t// Values is the unmarshaled values from a corpus file.\n\tValues []any\n\n\tGeneration int\n\n\t// IsSeed indicates whether this entry is part of the seed corpus.\n\tIsSeed bool\n}\n    CorpusEntry represents an individual input for fuzzing.\n\n    We must use an equivalent type in the testing and testing/internal/testdeps\n    packages, but testing can't import this package directly, and we don't want\n    to export this type from testing. Instead, we use the same struct type and\n    use a type alias (not a defined type) for convenience.\n\nfunc ReadCorpus(dir string, types []reflect.Type) ([]CorpusEntry, error)\n    ReadCorpus reads the corpus from the provided dir. The returned corpus\n    entries are guaranteed to match the given types. Any malformed files will\n    be saved in a MalformedCorpusError and returned, along with the most recent\n    error.\n\ntype MalformedCorpusError struct {\n\t// Has unexported fields.\n}\n    MalformedCorpusError is an error found while reading the corpus from the\n    filesystem. All of the errors are stored in the errs list. The testing\n    framework uses this to report malformed files in testdata.\n\nfunc (e *MalformedCorpusError) Error() string\n\n"}, {"path": "stdlib/internal-goos.md", "category": "stdlib", "name": "stdlib/internal-goos", "content": "package goos // import \"internal/goos\"\n\npackage goos contains GOOS-specific constants.\n\nCONSTANTS\n\nconst GOOS = `darwin`\nconst IsAix = 0\nconst IsAndroid = 0\nconst IsDarwin = 1\nconst IsDragonfly = 0\nconst IsFreebsd = 0\nconst IsHurd = 0\nconst IsIllumos = 0\nconst IsIos = 0\nconst IsJs = 0\nconst IsLinux = 0\nconst IsNacl = 0\nconst IsNetbsd = 0\nconst IsOpenbsd = 0\nconst IsPlan9 = 0\nconst IsSolaris = 0\nconst IsUnix = true\nconst IsWasip1 = 0\nconst IsWindows = 0\nconst IsZos = 0\n"}, {"path": "stdlib/internal-byteorder.md", "category": "stdlib", "name": "stdlib/internal-byteorder", "content": "package byteorder // import \"internal/byteorder\"\n\nPackage byteorder provides functions for decoding and encoding little and big\nendian integer types from/to byte slices.\n\nFUNCTIONS\n\nfunc BEAppendUint16(b []byte, v uint16) []byte\nfunc BEAppendUint32(b []byte, v uint32) []byte\nfunc BEAppendUint64(b []byte, v uint64) []byte\nfunc BEPutUint16(b []byte, v uint16)\nfunc BEPutUint32(b []byte, v uint32)\nfunc BEPutUint64(b []byte, v uint64)\nfunc BEUint16(b []byte) uint16\nfunc BEUint32(b []byte) uint32\nfunc BEUint64(b []byte) uint64\nfunc LEAppendUint16(b []byte, v uint16) []byte\nfunc LEAppendUint32(b []byte, v uint32) []byte\nfunc LEAppendUint64(b []byte, v uint64) []byte\nfunc LEPutUint16(b []byte, v uint16)\nfunc LEPutUint32(b []byte, v uint32)\nfunc LEPutUint64(b []byte, v uint64)\nfunc LEUint16(b []byte) uint16\nfunc LEUint32(b []byte) uint32\nfunc LEUint64(b []byte) uint64\n"}, {"path": "stdlib/net-textproto.md", "category": "stdlib", "name": "stdlib/net-textproto", "content": "package textproto // import \"net/textproto\"\n\nPackage textproto implements generic support for text-based request/response\nprotocols in the style of HTTP, NNTP, and SMTP.\n\nThis package enforces the HTTP/1.1 character set defined by RFC 9112 for header\nkeys and values.\n\nThe package provides:\n\nError, which represents a numeric error response from a server.\n\nPipeline, to manage pipelined requests and responses in a client.\n\nReader, to read numeric response code lines, key: value headers, lines wrapped\nwith leading spaces on continuation lines, and whole text blocks ending with a\ndot on a line by itself.\n\nWriter, to write dot-encoded text blocks.\n\nConn, a convenient packaging of Reader, Writer, and Pipeline for use with a\nsingle network connection.\n\nFUNCTIONS\n\nfunc CanonicalMIMEHeaderKey(s string) string\n    CanonicalMIMEHeaderKey returns the canonical format of the MIME header key\n    s. The canonicalization converts the first letter and any letter following\n    a hyphen to upper case; the rest are converted to lowercase. For example,\n    the canonical key for \"accept-encoding\" is \"Accept-Encoding\". MIME header\n    keys are assumed to be ASCII only. If s contains a space or invalid header\n    field bytes as defined by RFC 9112, it is returned without modifications.\n\nfunc TrimBytes(b []byte) []byte\n    TrimBytes returns b without leading and trailing ASCII space.\n\nfunc TrimString(s string) string\n    TrimString returns s without leading and trailing ASCII space.\n\n\nTYPES\n\ntype Conn struct {\n\tReader\n\tWriter\n\tPipeline\n\t// Has unexported fields.\n}\n    A Conn represents a textual network protocol connection. It consists of\n    a Reader and Writer to manage I/O and a Pipeline to sequence concurrent\n    requests on the connection. These embedded types carry methods with them;\n    see the documentation of those types for details.\n\nfunc Dial(network, addr string) (*Conn, error)\n    Dial connects to the given address on the given network using net.Dial and\n    then returns a new Conn for the connection.\n\nfunc NewConn(conn io.ReadWriteCloser) *Conn\n    NewConn returns a new Conn using conn for I/O.\n\nfunc (c *Conn) Close() error\n    Close closes the connection.\n\nfunc (c *Conn) Cmd(format string, args ...any) (id uint, err error)\n    Cmd is a convenience method that sends a command after waiting its turn\n    in the pipeline. The command text is the result of formatting format with\n    args and appending \\r\\n. Cmd returns the id of the command, for use with\n    StartResponse and EndResponse.\n\n    For example, a client might run a HELP command that returns a dot-body by\n    using:\n\n        id, err := c.Cmd(\"HELP\")\n        if err != nil {\n        \treturn nil, err\n        }\n\n        c.StartResponse(id)\n        defer c.EndResponse(id)\n\n        if _, _, err = c.ReadCodeLine(110); err != nil {\n        \treturn nil, err\n        }\n        text, err := c.ReadDotBytes()\n        if err != nil {\n        \treturn nil, err\n        }\n        return c.ReadCodeLine(250)\n\ntype Error struct {\n\tCode int\n\tMsg  string\n}\n    An Error represents a numeric error response from a server.\n\nfunc (e *Error) Error() string\n\ntype MIMEHeader map[string][]string\n    A MIMEHeader represents a MIME-style header mapping keys to sets of values.\n\nfunc (h MIMEHeader) Add(key, value string)\n    Add adds the key, value pair to the header. It appends to any existing\n    values associated with key.\n\nfunc (h MIMEHeader) Del(key string)\n    Del deletes the values associated with key.\n\nfunc (h MIMEHeader) Get(key string) string\n    Get gets the first value associated with the given key. It is case\n    insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided\n    key. If there are no values associated with the key, Get returns \"\".\n    To use non-canonical keys, access the map directly.\n\nfunc (h MIMEHeader) Set(key, value string)\n    Set sets the header entries associated with key to the single element value.\n    It replaces any existing values associated with key.\n\nfunc (h MIMEHeader) Values(key string) []string\n    Values returns all values associated with the given key. It is case\n    insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided\n    key. To use non-canonical keys, access the map directly. The returned slice\n    is not a copy.\n\ntype Pipeline struct {\n\t// Has unexported fields.\n}\n    A Pipeline manages a pipelined in-order request/response sequence.\n\n    To use a Pipeline p to manage multiple clients on a connection, each client\n    should run:\n\n        id := p.Next()\t// take a number\n\n        p.StartRequest(id)\t// wait for turn to send request\n        \u00absend request\u00bb\n        p.EndRequest(id)\t// notify Pipeline that request is sent\n\n        p.StartResponse(id)\t// wait for turn to read response\n        \u00abread response\u00bb\n        p.EndResponse(id)\t// notify Pipeline that response is read\n\n    A pipelined server can use the same calls to ensure that responses computed\n    in parallel are written in the correct order.\n\nfunc (p *Pipeline) EndRequest(id uint)\n    EndRequest notifies p that the request with the given id has been sent (or,\n    if this is a server, received).\n\nfunc (p *Pipeline) EndResponse(id uint)\n    EndResponse notifies p that the response with the given id has been received\n    (or, if this is a server, sent).\n\nfunc (p *Pipeline) Next() uint\n    Next returns the next id for a request/response pair.\n\nfunc (p *Pipeline) StartRequest(id uint)\n    StartRequest blocks until it is time to send (or, if this is a server,\n    receive) the request with the given id.\n\nfunc (p *Pipeline) StartResponse(id uint)\n    StartResponse blocks until it is time to receive (or, if this is a server,\n    send) the request with the given id.\n\ntype ProtocolError string\n    A ProtocolError describes a protocol violation such as an invalid response\n    or a hung-up connection.\n\nfunc (p ProtocolError) Error() string\n\ntype Reader struct {\n\tR *bufio.Reader\n\n\t// Has unexported fields.\n}\n    A Reader implements convenience methods for reading requests or responses\n    from a text protocol network connection.\n\nfunc NewReader(r *bufio.Reader) *Reader\n    NewReader returns a new Reader reading from r.\n\n    To avoid denial of service attacks, the provided bufio.Reader should be\n    reading from an io.LimitReader or similar Reader to bound the size of\n    responses.\n\nfunc (r *Reader) DotReader() io.Reader\n    DotReader returns a new Reader that satisfies Reads using the decoded text\n    of a dot-encoded block read from r. The returned Reader is only valid until\n    the next call to a method on r.\n\n    Dot encoding is a common framing used for data blocks in text protocols such\n    as SMTP. The data consists of a sequence of lines, each of which ends in\n    \"\\r\\n\". The sequence itself ends at a line containing just a dot: \".\\r\\n\".\n    Lines beginning with a dot are escaped with an additional dot to avoid\n    looking like the end of the sequence.\n\n    The decoded form returned by the Reader's Read method rewrites the \"\\r\\n\"\n    line endings into the simpler \"\\n\", removes leading dot escapes if present,\n    and stops with error io.EOF after consuming (and discarding) the\n    end-of-sequence line.\n\nfunc (r *Reader) ReadCodeLine(expectCode int) (code int, message string, err error)\n    ReadCodeLine reads a response code line of the form\n\n        code message\n\n    where code is a three-digit status code and the message extends to the rest\n    of the line. An example of such a line is:\n\n        220 plan9.bell-labs.com ESMTP\n\n    If the prefix of the status does not match the digits in expectCode,\n    ReadCodeLine returns with err set to &Error{code, message}. For example,\n    if expectCode is 31, an error will be returned if the status is not in the\n    range [310,319].\n\n    If the response is multi-line, ReadCodeLine returns an error.\n\n    An expectCode <= 0 disables the check of the status code.\n\nfunc (r *Reader) ReadContinuedLine() (string, error)\n    ReadContinuedLine reads a possibly continued line from r, eliding the\n    final trailing ASCII white space. Lines after the first are considered\n    continuations if they begin with a space or tab character. In the returned\n    data, continuation lines are separated from the previous line only by a\n    single space: the newline and leading white space are removed.\n\n    For example, consider this input:\n\n        Line 1\n          continued...\n        Line 2\n\n    The first call to ReadContinuedLine will return \"Line 1 continued...\" and\n    the second will return \"Line 2\".\n\n    Empty lines are never continued.\n\nfunc (r *Reader) ReadContinuedLineBytes() ([]byte, error)\n    ReadContinuedLineBytes is like Reader.ReadContinuedLine but returns a []byte\n    instead of a string.\n\nfunc (r *Reader) ReadDotBytes() ([]byte, error)\n    ReadDotBytes reads a dot-encoding and returns the decoded data.\n\n    See the documentation for the Reader.DotReader method for details about\n    dot-encoding.\n\nfunc (r *Reader) ReadDotLines() ([]string, error)\n    ReadDotLines reads a dot-encoding and returns a slice containing the decoded\n    lines, with the final \\r\\n or \\n elided from each.\n\n    See the documentation for the Reader.DotReader method for details about\n    dot-encoding.\n\nfunc (r *Reader) ReadLine() (string, error)\n    ReadLine reads a single line from r, eliding the final \\n or \\r\\n from the\n    returned string.\n\nfunc (r *Reader) ReadLineBytes() ([]byte, error)\n    ReadLineBytes is like Reader.ReadLine but returns a []byte instead of a\n    string.\n\nfunc (r *Reader) ReadMIMEHeader() (MIMEHeader, error)\n    ReadMIMEHeader reads a MIME-style header from r. The header is a sequence of\n    possibly continued Key: Value lines ending in a blank line. The returned map\n    m maps CanonicalMIMEHeaderKey(key) to a sequence of values in the same order\n    encountered in the input.\n\n    For example, consider this input:\n\n        My-Key: Value 1\n        Long-Key: Even\n               Longer Value\n        My-Key: Value 2\n\n    Given that input, ReadMIMEHeader returns the map:\n\n        map[string][]string{\n        \t\"My-Key\": {\"Value 1\", \"Value 2\"},\n        \t\"Long-Key\": {\"Even Longer Value\"},\n        }\n\nfunc (r *Reader) ReadResponse(expectCode int) (code int, message string, err error)\n    ReadResponse reads a multi-line response of the form:\n\n        code-message line 1\n        code-message line 2\n        ...\n        code message line n\n\n    where code is a three-digit status code. The first line starts with the code\n    and a hyphen. The response is terminated by a line that starts with the same\n    code followed by a space. Each line in message is separated by a newline\n    (\\n).\n\n    See page 36 of RFC 959 (https://www.ietf.org/rfc/rfc959.txt) for details of\n    another form of response accepted:\n\n        code-message line 1\n        message line 2\n        ...\n        code message line n\n\n    If the prefix of the status does not match the digits in expectCode,\n    ReadResponse returns with err set to &Error{code, message}. For example,\n    if expectCode is 31, an error will be returned if the status is not in the\n    range [310,319].\n\n    An expectCode <= 0 disables the check of the status code.\n\ntype Writer struct {\n\tW *bufio.Writer\n\t// Has unexported fields.\n}\n    A Writer implements convenience methods for writing requests or responses to\n    a text protocol network connection.\n\nfunc NewWriter(w *bufio.Writer) *Writer\n    NewWriter returns a new Writer writing to w.\n\nfunc (w *Writer) DotWriter() io.WriteCloser\n    DotWriter returns a writer that can be used to write a dot-encoding to w. It\n    takes care of inserting leading dots when necessary, translating line-ending\n    \\n into \\r\\n, and adding the final .\\r\\n line when the DotWriter is closed.\n    The caller should close the DotWriter before the next call to a method on w.\n\n    See the documentation for the Reader.DotReader method for details about\n    dot-encoding.\n\nfunc (w *Writer) PrintfLine(format string, args ...any) error\n    PrintfLine writes the formatted output followed by \\r\\n.\n\n"}, {"path": "stdlib/compress-lzw.md", "category": "stdlib", "name": "stdlib/compress-lzw", "content": "package lzw // import \"compress/lzw\"\n\nPackage lzw implements the Lempel-Ziv-Welch compressed data format, described\nin T. A. Welch, \u201cA Technique for High-Performance Data Compression\u201d, Computer,\n17(6) (June 1984), pp 8-19.\n\nIn particular, it implements LZW as used by the GIF and PDF file formats, which\nmeans variable-width codes up to 12 bits and the first two non-literal codes are\na clear code and an EOF code.\n\nThe TIFF file format uses a similar but incompatible version of the LZW\nalgorithm. See the golang.org/x/image/tiff/lzw package for an implementation.\n\nFUNCTIONS\n\nfunc NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser\n    NewReader creates a new io.ReadCloser. Reads from the returned io.ReadCloser\n    read and decompress data from r. If r does not also implement io.ByteReader,\n    the decompressor may read more data than necessary from r. It is the\n    caller's responsibility to call Close on the ReadCloser when finished\n    reading. The number of bits to use for literal codes, litWidth, must be in\n    the range [2,8] and is typically 8. It must equal the litWidth used during\n    compression.\n\n    It is guaranteed that the underlying type of the returned io.ReadCloser is a\n    *Reader.\n\nfunc NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser\n    NewWriter creates a new io.WriteCloser. Writes to the returned\n    io.WriteCloser are compressed and written to w. It is the caller's\n    responsibility to call Close on the WriteCloser when finished writing.\n    The number of bits to use for literal codes, litWidth, must be in the range\n    [2,8] and is typically 8. Input bytes must be less than 1<<litWidth.\n\n    It is guaranteed that the underlying type of the returned io.WriteCloser is\n    a *Writer.\n\n\nTYPES\n\ntype Order int\n    Order specifies the bit ordering in an LZW data stream.\n\nconst (\n\t// LSB means Least Significant Bits first, as used in the GIF file format.\n\tLSB Order = iota\n\t// MSB means Most Significant Bits first, as used in the TIFF and PDF\n\t// file formats.\n\tMSB\n)\ntype Reader struct {\n\t// Has unexported fields.\n}\n    Reader is an io.Reader which can be used to read compressed data in the LZW\n    format.\n\nfunc (r *Reader) Close() error\n    Close closes the Reader and returns an error for any future read operation.\n    It does not close the underlying io.Reader.\n\nfunc (r *Reader) Read(b []byte) (int, error)\n    Read implements io.Reader, reading uncompressed bytes from its underlying\n    reader.\n\nfunc (r *Reader) Reset(src io.Reader, order Order, litWidth int)\n    Reset clears the Reader's state and allows it to be reused again as a new\n    Reader.\n\ntype Writer struct {\n\t// Has unexported fields.\n}\n    Writer is an LZW compressor. It writes the compressed form of the data to an\n    underlying writer (see NewWriter).\n\nfunc (w *Writer) Close() error\n    Close closes the Writer, flushing any pending output. It does not close w's\n    underlying writer.\n\nfunc (w *Writer) Reset(dst io.Writer, order Order, litWidth int)\n    Reset clears the Writer's state and allows it to be reused again as a new\n    Writer.\n\nfunc (w *Writer) Write(p []byte) (n int, err error)\n    Write writes a compressed representation of p to w's underlying writer.\n\n"}, {"path": "stdlib/index-suffixarray.md", "category": "stdlib", "name": "stdlib/index-suffixarray", "content": "package suffixarray // import \"index/suffixarray\"\n\nPackage suffixarray implements substring search in logarithmic time using an\nin-memory suffix array.\n\nExample use:\n\n    // create index for some data\n    index := suffixarray.New(data)\n\n    // lookup byte slice s\n    offsets1 := index.Lookup(s, -1) // the list of all indices where s occurs in data\n    offsets2 := index.Lookup(s, 3)  // the list of at most 3 indices where s occurs in data\n\nTYPES\n\ntype Index struct {\n\t// Has unexported fields.\n}\n    Index implements a suffix array for fast substring search.\n\nfunc New(data []byte) *Index\n    New creates a new Index for data. Index creation time is O(N) for N =\n    len(data).\n\nfunc (x *Index) Bytes() []byte\n    Bytes returns the data over which the index was created. It must not be\n    modified.\n\nfunc (x *Index) FindAllIndex(r *regexp.Regexp, n int) (result [][]int)\n    FindAllIndex returns a sorted list of non-overlapping matches of the regular\n    expression r, where a match is a pair of indices specifying the matched\n    slice of x.Bytes(). If n < 0, all matches are returned in successive order.\n    Otherwise, at most n matches are returned and they may not be successive.\n    The result is nil if there are no matches, or if n == 0.\n\nfunc (x *Index) Lookup(s []byte, n int) (result []int)\n    Lookup returns an unsorted list of at most n indices where the byte string\n    s occurs in the indexed data. If n < 0, all occurrences are returned.\n    The result is nil if s is empty, s is not found, or n == 0. Lookup time is\n    O(log(N)*len(s) + len(result)) where N is the size of the indexed data.\n\nfunc (x *Index) Read(r io.Reader) error\n    Read reads the index from r into x; x must not be nil.\n\nfunc (x *Index) Write(w io.Writer) error\n    Write writes the index x to w.\n\n"}, {"path": "stdlib/iter.md", "category": "stdlib", "name": "stdlib/iter", "content": "package iter // import \"iter\"\n\nPackage iter provides basic definitions and operations related to iterators over\nsequences.\n\n# Iterators\n\nAn iterator is a function that passes successive elements of a sequence to a\ncallback function, conventionally named yield. The function stops either when\nthe sequence is finished or when yield returns false, indicating to stop the\niteration early. This package defines Seq and Seq2 (pronounced like seek\u2014the\nfirst syllable of sequence) as shorthands for iterators that pass 1 or 2 values\nper sequence element to yield:\n\n    type (\n    \tSeq[V any]     func(yield func(V) bool)\n    \tSeq2[K, V any] func(yield func(K, V) bool)\n    )\n\nSeq2 represents a sequence of paired values, conventionally key-value or\nindex-value pairs.\n\nYield returns true if the iterator should continue with the next element in the\nsequence, false if it should stop.\n\nFor instance, maps.Keys returns an iterator that produces the sequence of keys\nof the map m, implemented as follows:\n\n    func Keys[Map ~map[K]V, K comparable, V any](m Map) iter.Seq[K] {\n    \treturn func(yield func(K) bool) {\n    \t\tfor k := range m {\n    \t\t\tif !yield(k) {\n    \t\t\t\treturn\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n\nFurther examples can be found in The Go Blog: Range Over Function Types.\n\nIterator functions are most often called by a range loop, as in:\n\n    func PrintAll[V any](seq iter.Seq[V]) {\n    \tfor v := range seq {\n    \t\tfmt.Println(v)\n    \t}\n    }\n\n# Naming Conventions\n\nIterator functions and methods are named for the sequence being walked:\n\n    // All returns an iterator over all elements in s.\n    func (s *Set[V]) All() iter.Seq[V]\n\nThe iterator method on a collection type is conventionally named All, because it\niterates a sequence of all the values in the collection.\n\nFor a type containing multiple possible sequences, the iterator's name can\nindicate which sequence is being provided:\n\n    // Cities returns an iterator over the major cities in the country.\n    func (c *Country) Cities() iter.Seq[*City]\n\n    // Languages returns an iterator over the official spoken languages of the country.\n    func (c *Country) Languages() iter.Seq[string]\n\nIf an iterator requires additional configuration, the constructor function can\ntake additional configuration arguments:\n\n    // Scan returns an iterator over key-value pairs with min \u2264 key \u2264 max.\n    func (m *Map[K, V]) Scan(min, max K) iter.Seq2[K, V]\n\n    // Split returns an iterator over the (possibly-empty) substrings of s\n    // separated by sep.\n    func Split(s, sep string) iter.Seq[string]\n\nWhen there are multiple possible iteration orders, the method name may indicate\nthat order:\n\n    // All returns an iterator over the list from head to tail.\n    func (l *List[V]) All() iter.Seq[V]\n\n    // Backward returns an iterator over the list from tail to head.\n    func (l *List[V]) Backward() iter.Seq[V]\n\n    // Preorder returns an iterator over all nodes of the syntax tree\n    // beneath (and including) the specified root, in depth-first preorder,\n    // visiting a parent node before its children.\n    func Preorder(root Node) iter.Seq[Node]\n\n# Single-Use Iterators\n\nMost iterators provide the ability to walk an entire sequence: when called,\nthe iterator does any setup necessary to start the sequence, then calls yield\non successive elements of the sequence, and then cleans up before returning.\nCalling the iterator again walks the sequence again.\n\nSome iterators break that convention, providing the ability to walk a sequence\nonly once. These \u201csingle-use iterators\u201d typically report values from a data\nstream that cannot be rewound to start over. Calling the iterator again after\nstopping early may continue the stream, but calling it again after the sequence\nis finished will yield no values at all. Doc comments for functions or methods\nthat return single-use iterators should document this fact:\n\n    // Lines returns an iterator over lines read from r.\n    // It returns a single-use iterator.\n    func (r *Reader) Lines() iter.Seq[string]\n\n# Pulling Values\n\nFunctions and methods that accept or return iterators should use the standard\nSeq or Seq2 types, to ensure compatibility with range loops and other iterator\nadapters. The standard iterators can be thought of as \u201cpush iterators\u201d, which\npush values to the yield function.\n\nSometimes a range loop is not the most natural way to consume values of the\nsequence. In this case, Pull converts a standard push iterator to a \u201cpull\niterator\u201d, which can be called to pull one value at a time from the sequence.\nPull starts an iterator and returns a pair of functions\u2014next and stop\u2014which\nreturn the next value from the iterator and stop it, respectively.\n\nFor example:\n\n    // Pairs returns an iterator over successive pairs of values from seq.\n    func Pairs[V any](seq iter.Seq[V]) iter.Seq2[V, V] {\n    \treturn func(yield func(V, V) bool) {\n    \t\tnext, stop := iter.Pull(seq)\n    \t\tdefer stop()\n    \t\tfor {\n    \t\t\tv1, ok1 := next()\n    \t\t\tif !ok1 {\n    \t\t\t\treturn\n    \t\t\t}\n    \t\t\tv2, ok2 := next()\n    \t\t\t// If ok2 is false, v2 should be the\n    \t\t\t// zero value; yield one last pair.\n    \t\t\tif !yield(v1, v2) {\n    \t\t\t\treturn\n    \t\t\t}\n    \t\t\tif !ok2 {\n    \t\t\t\treturn\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n\nIf clients do not consume the sequence to completion, they must call stop, which\nallows the iterator function to finish and return. As shown in the example,\nthe conventional way to ensure this is to use defer.\n\n# Standard Library Usage\n\nA few packages in the standard library provide iterator-based APIs, most notably\nthe maps and slices packages. For example, maps.Keys returns an iterator over\nthe keys of a map, while slices.Sorted collects the values of an iterator into a\nslice, sorts them, and returns the slice, so to iterate over the sorted keys of\na map:\n\n    for _, key := range slices.Sorted(maps.Keys(m)) {\n    \t...\n    }\n\n# Mutation\n\nIterators provide only the values of the sequence, not any direct way to modify\nit. If an iterator wishes to provide a mechanism for modifying a sequence\nduring iteration, the usual approach is to define a position type with the extra\noperations and then provide an iterator over positions.\n\nFor example, a tree implementation might provide:\n\n    // Positions returns an iterator over positions in the sequence.\n    func (t *Tree[V]) Positions() iter.Seq[*Pos[V]]\n\n    // A Pos represents a position in the sequence.\n    // It is only valid during the yield call it is passed to.\n    type Pos[V any] struct { ... }\n\n    // Pos returns the value at the cursor.\n    func (p *Pos[V]) Value() V\n\n    // Delete deletes the value at this point in the iteration.\n    func (p *Pos[V]) Delete()\n\n    // Set changes the value v at the cursor.\n    func (p *Pos[V]) Set(v V)\n\nAnd then a client could delete boring values from the tree using:\n\n    for p := range t.Positions() {\n    \tif boring(p.Value()) {\n    \t\tp.Delete()\n    \t}\n    }\n\n[The Go Blog: Range Over Function Types]: https://go.dev/blog/range-functions\n[range loop]: https://go.dev/ref/spec#For_range\n\nFUNCTIONS\n\nfunc Pull[V any](seq Seq[V]) (next func() (V, bool), stop func())\n    Pull converts the \u201cpush-style\u201d iterator sequence seq into a \u201cpull-style\u201d\n    iterator accessed by the two functions next and stop.\n\n    Next returns the next value in the sequence and a boolean indicating whether\n    the value is valid. When the sequence is over, next returns the zero V and\n    false. It is valid to call next after reaching the end of the sequence\n    or after calling stop. These calls will continue to return the zero V and\n    false.\n\n    Stop ends the iteration. It must be called when the caller is no longer\n    interested in next values and next has not yet signaled that the sequence is\n    over (with a false boolean return). It is valid to call stop multiple times\n    and when next has already returned false. Typically, callers should \u201cdefer\n    stop()\u201d.\n\n    It is an error to call next or stop from multiple goroutines simultaneously.\n\n    If the iterator panics during a call to next (or stop), then next (or stop)\n    itself panics with the same value.\n\nfunc Pull2[K, V any](seq Seq2[K, V]) (next func() (K, V, bool), stop func())\n    Pull2 converts the \u201cpush-style\u201d iterator sequence seq into a \u201cpull-style\u201d\n    iterator accessed by the two functions next and stop.\n\n    Next returns the next pair in the sequence and a boolean indicating whether\n    the pair is valid. When the sequence is over, next returns a pair of zero\n    values and false. It is valid to call next after reaching the end of the\n    sequence or after calling stop. These calls will continue to return a pair\n    of zero values and false.\n\n    Stop ends the iteration. It must be called when the caller is no longer\n    interested in next values and next has not yet signaled that the sequence is\n    over (with a false boolean return). It is valid to call stop multiple times\n    and when next has already returned false. Typically, callers should \u201cdefer\n    stop()\u201d.\n\n    It is an error to call next or stop from multiple goroutines simultaneously.\n\n    If the iterator panics during a call to next (or stop), then next (or stop)\n    itself panics with the same value.\n\n\nTYPES\n\ntype Seq[V any] func(yield func(V) bool)\n    Seq is an iterator over sequences of individual values. When called as\n    seq(yield), seq calls yield(v) for each value v in the sequence, stopping\n    early if yield returns false. See the iter package documentation for more\n    details.\n\ntype Seq2[K, V any] func(yield func(K, V) bool)\n    Seq2 is an iterator over sequences of pairs of values, most commonly\n    key-value pairs. When called as seq(yield), seq calls yield(k, v) for\n    each pair (k, v) in the sequence, stopping early if yield returns false.\n    See the iter package documentation for more details.\n\n"}, {"path": "stdlib/internal-godebugs.md", "category": "stdlib", "name": "stdlib/internal-godebugs", "content": "package godebugs // import \"internal/godebugs\"\n\nPackage godebugs provides a table of known GODEBUG settings, for use by a\nvariety of other packages, including internal/godebug, runtime, runtime/metrics,\nand cmd/go/internal/load.\n\nVARIABLES\n\nvar All = []Info{\n\t{Name: \"allowmultiplevcs\", Package: \"cmd/go\"},\n\t{Name: \"asynctimerchan\", Package: \"time\", Changed: 23, Old: \"1\"},\n\t{Name: \"containermaxprocs\", Package: \"runtime\", Changed: 25, Old: \"0\"},\n\t{Name: \"dataindependenttiming\", Package: \"crypto/subtle\", Opaque: true},\n\t{Name: \"decoratemappings\", Package: \"runtime\", Opaque: true, Changed: 25, Old: \"0\"},\n\t{Name: \"embedfollowsymlinks\", Package: \"cmd/go\"},\n\t{Name: \"execerrdot\", Package: \"os/exec\"},\n\t{Name: \"fips140\", Package: \"crypto/fips140\", Opaque: true, Immutable: true},\n\t{Name: \"gocachehash\", Package: \"cmd/go\"},\n\t{Name: \"gocachetest\", Package: \"cmd/go\"},\n\t{Name: \"gocacheverify\", Package: \"cmd/go\"},\n\t{Name: \"gotestjsonbuildtext\", Package: \"cmd/go\", Changed: 24, Old: \"1\"},\n\t{Name: \"gotypesalias\", Package: \"go/types\", Changed: 23, Old: \"0\"},\n\t{Name: \"http2client\", Package: \"net/http\"},\n\t{Name: \"http2debug\", Package: \"net/http\", Opaque: true},\n\t{Name: \"http2server\", Package: \"net/http\"},\n\t{Name: \"httpcookiemaxnum\", Package: \"net/http\", Changed: 24, Old: \"0\"},\n\t{Name: \"httplaxcontentlength\", Package: \"net/http\", Changed: 22, Old: \"1\"},\n\t{Name: \"httpmuxgo121\", Package: \"net/http\", Changed: 22, Old: \"1\"},\n\t{Name: \"httpservecontentkeepheaders\", Package: \"net/http\", Changed: 23, Old: \"1\"},\n\t{Name: \"installgoroot\", Package: \"go/build\"},\n\t{Name: \"jstmpllitinterp\", Package: \"html/template\", Opaque: true},\n\n\t{Name: \"multipartmaxheaders\", Package: \"mime/multipart\"},\n\t{Name: \"multipartmaxparts\", Package: \"mime/multipart\"},\n\t{Name: \"multipathtcp\", Package: \"net\", Changed: 24, Old: \"0\"},\n\t{Name: \"netdns\", Package: \"net\", Opaque: true},\n\t{Name: \"netedns0\", Package: \"net\", Changed: 19, Old: \"0\"},\n\t{Name: \"panicnil\", Package: \"runtime\", Changed: 21, Old: \"1\"},\n\t{Name: \"randautoseed\", Package: \"math/rand\"},\n\t{Name: \"randseednop\", Package: \"math/rand\", Changed: 24, Old: \"0\"},\n\t{Name: \"rsa1024min\", Package: \"crypto/rsa\", Changed: 24, Old: \"0\"},\n\t{Name: \"tarinsecurepath\", Package: \"archive/tar\"},\n\t{Name: \"tls10server\", Package: \"crypto/tls\", Changed: 22, Old: \"1\"},\n\t{Name: \"tls3des\", Package: \"crypto/tls\", Changed: 23, Old: \"1\"},\n\t{Name: \"tlsmaxrsasize\", Package: \"crypto/tls\"},\n\t{Name: \"tlsmlkem\", Package: \"crypto/tls\", Changed: 24, Old: \"0\", Opaque: true},\n\t{Name: \"tlsrsakex\", Package: \"crypto/tls\", Changed: 22, Old: \"1\"},\n\t{Name: \"tlssha1\", Package: \"crypto/tls\", Changed: 25, Old: \"1\"},\n\t{Name: \"tlsunsafeekm\", Package: \"crypto/tls\", Changed: 22, Old: \"1\"},\n\t{Name: \"updatemaxprocs\", Package: \"runtime\", Changed: 25, Old: \"0\"},\n\t{Name: \"winreadlinkvolume\", Package: \"os\", Changed: 23, Old: \"0\"},\n\t{Name: \"winsymlink\", Package: \"os\", Changed: 23, Old: \"0\"},\n\t{Name: \"x509keypairleaf\", Package: \"crypto/tls\", Changed: 23, Old: \"0\"},\n\t{Name: \"x509negativeserial\", Package: \"crypto/x509\", Changed: 23, Old: \"1\"},\n\t{Name: \"x509rsacrt\", Package: \"crypto/x509\", Changed: 24, Old: \"0\"},\n\t{Name: \"x509sha256skid\", Package: \"crypto/x509\", Changed: 25, Old: \"0\"},\n\t{Name: \"x509usefallbackroots\", Package: \"crypto/x509\"},\n\t{Name: \"x509usepolicies\", Package: \"crypto/x509\", Changed: 24, Old: \"0\"},\n\t{Name: \"zipinsecurepath\", Package: \"archive/zip\"},\n}\n    All is the table of known settings, sorted by Name.\n\n    Note: After adding entries to this table, run 'go generate runtime/metrics'\n    to update the runtime/metrics doc comment. (Otherwise the runtime/metrics\n    test will fail.)\n\n    Note: After adding entries to this table, update the list in doc/godebug.md\n    as well. (Otherwise the test in this package will fail.)\n\n\nTYPES\n\ntype Info struct {\n\tName      string // name of the setting (\"panicnil\")\n\tPackage   string // package that uses the setting (\"runtime\")\n\tChanged   int    // minor version when default changed, if any; 21 means Go 1.21\n\tOld       string // value that restores behavior prior to Changed\n\tOpaque    bool   // setting does not export information to runtime/metrics using [internal/godebug.Setting.IncNonDefault]\n\tImmutable bool   // setting cannot be changed after program start\n}\n    An Info describes a single known GODEBUG setting.\n\nfunc Lookup(name string) *Info\n    Lookup returns the Info with the given name.\n\n"}, {"path": "stdlib/internal-runtime-maps.md", "category": "stdlib", "name": "stdlib/internal-runtime-maps", "content": "package maps // import \"internal/runtime/maps\"\n\nPackage maps implements Go's builtin map type.\n\nPackage maps implements Go's builtin map type.\n\nPackage maps implements Go's builtin map type.\n\nFUNCTIONS\n\nfunc OldMapKeyError(t *abi.OldMapType, p unsafe.Pointer) error\n\nTYPES\n\ntype Iter struct {\n\t// Has unexported fields.\n}\n\nfunc (it *Iter) Elem() unsafe.Pointer\n    Key returns a pointer to the current element. nil indicates end of\n    iteration.\n\n    Must not be called prior to Next.\n\nfunc (it *Iter) Init(typ *abi.SwissMapType, m *Map)\n    Init initializes Iter for iteration.\n\nfunc (it *Iter) Initialized() bool\n\nfunc (it *Iter) Key() unsafe.Pointer\n    Key returns a pointer to the current key. nil indicates end of iteration.\n\n    Must not be called prior to Next.\n\nfunc (it *Iter) Map() *Map\n    Map returns the map this iterator is iterating over.\n\nfunc (it *Iter) Next()\n    Next proceeds to the next element in iteration, which can be accessed via\n    the Key and Elem methods.\n\n    The table can be mutated during iteration, though there is no guarantee that\n    the mutations will be visible to the iteration.\n\n    Init must be called prior to Next.\n\ntype Map struct {\n\t// Has unexported fields.\n}\n    Note: changes here must be reflected in\n    cmd/compile/internal/reflectdata/map_swiss.go:SwissMapType.\n\nfunc NewEmptyMap() *Map\n\nfunc NewMap(mt *abi.SwissMapType, hint uintptr, m *Map, maxAlloc uintptr) *Map\n    If m is non-nil, it should be used rather than allocating.\n\n    maxAlloc should be runtime.maxAlloc.\n\n    TODO(prattmic): Put maxAlloc somewhere accessible.\n\nfunc (m *Map) Clear(typ *abi.SwissMapType)\n    Clear deletes all entries from the map resulting in an empty map.\n\nfunc (m *Map) Clone(typ *abi.SwissMapType) *Map\n\nfunc (m *Map) Delete(typ *abi.SwissMapType, key unsafe.Pointer)\n\nfunc (m *Map) Get(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, bool)\n    Get performs a lookup of the key that key points to. It returns a pointer to\n    the element, or false if the key doesn't exist.\n\nfunc (m *Map) Put(typ *abi.SwissMapType, key, elem unsafe.Pointer)\n\nfunc (m *Map) PutSlot(typ *abi.SwissMapType, key unsafe.Pointer) unsafe.Pointer\n    PutSlot returns a pointer to the element slot where an inserted element\n    should be written.\n\n    PutSlot never returns nil.\n\nfunc (m *Map) Used() uint64\n\n"}, {"path": "stdlib/time.md", "category": "stdlib", "name": "stdlib/time", "content": "package time // import \"time\"\n\nPackage time provides functionality for measuring and displaying time.\n\nThe calendrical calculations always assume a Gregorian calendar, with no leap\nseconds.\n\n# Monotonic Clocks\n\nOperating systems provide both a \u201cwall clock,\u201d which is subject to changes\nfor clock synchronization, and a \u201cmonotonic clock,\u201d which is not. The general\nrule is that the wall clock is for telling time and the monotonic clock is for\nmeasuring time. Rather than split the API, in this package the Time returned by\ntime.Now contains both a wall clock reading and a monotonic clock reading; later\ntime-telling operations use the wall clock reading, but later time-measuring\noperations, specifically comparisons and subtractions, use the monotonic clock\nreading.\n\nFor example, this code always computes a positive elapsed time of approximately\n20 milliseconds, even if the wall clock is changed during the operation being\ntimed:\n\n    start := time.Now()\n    ... operation that takes 20 milliseconds ...\n    t := time.Now()\n    elapsed := t.Sub(start)\n\nOther idioms, such as time.Since(start), time.Until(deadline), and\ntime.Now().Before(deadline), are similarly robust against wall clock resets.\n\nThe rest of this section gives the precise details of how operations use\nmonotonic clocks, but understanding those details is not required to use this\npackage.\n\nThe Time returned by time.Now contains a monotonic clock reading. If Time t\nhas a monotonic clock reading, t.Add adds the same duration to both the wall\nclock and monotonic clock readings to compute the result. Because t.AddDate(y,\nm, d), t.Round(d), and t.Truncate(d) are wall time computations, they always\nstrip any monotonic clock reading from their results. Because t.In, t.Local,\nand t.UTC are used for their effect on the interpretation of the wall time,\nthey also strip any monotonic clock reading from their results. The canonical\nway to strip a monotonic clock reading is to use t = t.Round(0).\n\nIf Times t and u both contain monotonic clock readings, the operations\nt.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out\nusing the monotonic clock readings alone, ignoring the wall clock readings.\nIf either t or u contains no monotonic clock reading, these operations fall back\nto using the wall clock readings.\n\nOn some systems the monotonic clock will stop if the computer goes to sleep.\nOn such a system, t.Sub(u) may not accurately reflect the actual time that\npassed between t and u. The same applies to other functions and methods that\nsubtract times, such as Since, Until, Time.Before, Time.After, Time.Add,\nTime.Equal and Time.Compare. In some cases, you may need to strip the monotonic\nclock to get accurate results.\n\nBecause the monotonic clock reading has no meaning outside the current process,\nthe serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON,\nand t.MarshalText omit the monotonic clock reading, and t.Format provides\nno format for it. Similarly, the constructors time.Date, time.Parse,\ntime.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode,\nt.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with\nno monotonic clock reading.\n\nThe monotonic clock reading exists only in Time values. It is not a part of\nDuration values or the Unix times returned by t.Unix and friends.\n\nNote that the Go == operator compares not just the time instant but also the\nLocation and the monotonic clock reading. See the documentation for the Time\ntype for a discussion of equality testing for Time values.\n\nFor debugging, the result of t.String does include the monotonic clock\nreading if present. If t != u because of different monotonic clock readings,\nthat difference will be visible when printing t.String() and u.String().\n\n# Timer Resolution\n\nTimer resolution varies depending on the Go runtime, the operating system\nand the underlying hardware. On Unix, the resolution is ~1ms. On Windows\nversion 1803 and newer, the resolution is ~0.5ms. On older Windows versions,\nthe default resolution is ~16ms, but a higher resolution may be requested using\ngolang.org/x/sys/windows.TimeBeginPeriod.\n\nCONSTANTS\n\nconst (\n\tLayout      = \"01/02 03:04:05PM '06 -0700\" // The reference time, in numerical order.\n\tANSIC       = \"Mon Jan _2 15:04:05 2006\"\n\tUnixDate    = \"Mon Jan _2 15:04:05 MST 2006\"\n\tRubyDate    = \"Mon Jan 02 15:04:05 -0700 2006\"\n\tRFC822      = \"02 Jan 06 15:04 MST\"\n\tRFC822Z     = \"02 Jan 06 15:04 -0700\" // RFC822 with numeric zone\n\tRFC850      = \"Monday, 02-Jan-06 15:04:05 MST\"\n\tRFC1123     = \"Mon, 02 Jan 2006 15:04:05 MST\"\n\tRFC1123Z    = \"Mon, 02 Jan 2006 15:04:05 -0700\" // RFC1123 with numeric zone\n\tRFC3339     = \"2006-01-02T15:04:05Z07:00\"\n\tRFC3339Nano = \"2006-01-02T15:04:05.999999999Z07:00\"\n\tKitchen     = \"3:04PM\"\n\t// Handy time stamps.\n\tStamp      = \"Jan _2 15:04:05\"\n\tStampMilli = \"Jan _2 15:04:05.000\"\n\tStampMicro = \"Jan _2 15:04:05.000000\"\n\tStampNano  = \"Jan _2 15:04:05.000000000\"\n\tDateTime   = \"2006-01-02 15:04:05\"\n\tDateOnly   = \"2006-01-02\"\n\tTimeOnly   = \"15:04:05\"\n)\n    These are predefined layouts for use in Time.Format and time.Parse.\n    The reference time used in these layouts is the specific time stamp:\n\n        01/02 03:04:05PM '06 -0700\n\n    (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).\n    That value is recorded as the constant named Layout, listed below. As a\n    Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be\n    printed by the Unix date command as:\n\n        Mon Jan 2 15:04:05 MST 2006\n\n    It is a regrettable historic error that the date uses the American\n    convention of putting the numerical month before the day.\n\n    The example for Time.Format demonstrates the working of the layout string in\n    detail and is a good reference.\n\n    Note that the RFC822, RFC850, and RFC1123 formats should be applied only\n    to local times. Applying them to UTC times will use \"UTC\" as the time zone\n    abbreviation, while strictly speaking those RFCs require the use of \"GMT\"\n    in that case. When using the RFC1123 or RFC1123Z formats for parsing,\n    note that these formats define a leading zero for the day-in-month portion,\n    which is not strictly allowed by RFC 1123. This will result in an error\n    when parsing date strings that occur in the first 9 days of a given month.\n    In general RFC1123Z should be used instead of RFC1123 for servers that\n    insist on that format, and RFC3339 should be preferred for new protocols.\n    RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\n    when used with time.Parse they do not accept all the time formats permitted\n    by the RFCs and they do accept time formats not formally defined. The\n    RFC3339Nano format removes trailing zeros from the seconds field and thus\n    may not sort correctly once formatted.\n\n    Most programs can use one of the defined constants as the layout passed\n    to Format or Parse. The rest of this comment can be ignored unless you are\n    creating a custom layout string.\n\n    To define your own format, write down what the reference time would look\n    like formatted your way; see the values of constants like ANSIC, StampMicro\n    or Kitchen for examples. The model is to demonstrate what the reference\n    time looks like so that the Format and Parse methods can apply the same\n    transformation to a general time value.\n\n    Here is a summary of the components of a layout string. Each element shows\n    by example the formatting of an element of the reference time. Only these\n    values are recognized. Text in the layout string that is not recognized as\n    part of the reference time is echoed verbatim during Format and expected to\n    appear verbatim in the input to Parse.\n\n        Year: \"2006\" \"06\"\n        Month: \"Jan\" \"January\" \"01\" \"1\"\n        Day of the week: \"Mon\" \"Monday\"\n        Day of the month: \"2\" \"_2\" \"02\"\n        Day of the year: \"__2\" \"002\"\n        Hour: \"15\" \"3\" \"03\" (PM or AM)\n        Minute: \"4\" \"04\"\n        Second: \"5\" \"05\"\n        AM/PM mark: \"PM\"\n\n    Numeric time zone offsets format as follows:\n\n        \"-0700\"     \u00b1hhmm\n        \"-07:00\"    \u00b1hh:mm\n        \"-07\"       \u00b1hh\n        \"-070000\"   \u00b1hhmmss\n        \"-07:00:00\" \u00b1hh:mm:ss\n\n    Replacing the sign in the format with a Z triggers the ISO 8601 behavior of\n    printing Z instead of an offset for the UTC zone. Thus:\n\n        \"Z0700\"      Z or \u00b1hhmm\n        \"Z07:00\"     Z or \u00b1hh:mm\n        \"Z07\"        Z or \u00b1hh\n        \"Z070000\"    Z or \u00b1hhmmss\n        \"Z07:00:00\"  Z or \u00b1hh:mm:ss\n\n    Within the format string, the underscores in \"_2\" and \"__2\" represent spaces\n    that may be replaced by digits if the following number has multiple digits,\n    for compatibility with fixed-width Unix time formats. A leading zero\n    represents a zero-padded value.\n\n    The formats __2 and 002 are space-padded and zero-padded three-character day\n    of year; there is no unpadded day of year format.\n\n    A comma or decimal point followed by one or more zeros represents a\n    fractional second, printed to the given number of decimal places. A comma or\n    decimal point followed by one or more nines represents a fractional second,\n    printed to the given number of decimal places, with trailing zeros removed.\n    For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with\n    millisecond precision.\n\n    Some valid layouts are invalid time values for time.Parse, due to formats\n    such as _ for space padding and Z for zone information.\n\nconst (\n\tNanosecond  Duration = 1\n\tMicrosecond          = 1000 * Nanosecond\n\tMillisecond          = 1000 * Microsecond\n\tSecond               = 1000 * Millisecond\n\tMinute               = 60 * Second\n\tHour                 = 60 * Minute\n)\n    Common durations. There is no definition for units of Day or larger to avoid\n    confusion across daylight savings time zone transitions.\n\n    To count the number of units in a Duration, divide:\n\n        second := time.Second\n        fmt.Print(int64(second/time.Millisecond)) // prints 1000\n\n    To convert an integer number of units to a Duration, multiply:\n\n        seconds := 10\n        fmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n\n\nFUNCTIONS\n\nfunc After(d Duration) <-chan Time\n    After waits for the duration to elapse and then sends the current time on\n    the returned channel. It is equivalent to NewTimer(d).C.\n\n    Before Go 1.23, this documentation warned that the underlying Timer\n    would not be recovered by the garbage collector until the timer fired,\n    and that if efficiency was a concern, code should use NewTimer instead and\n    call Timer.Stop if the timer is no longer needed. As of Go 1.23, the garbage\n    collector can recover unreferenced, unstopped timers. There is no reason to\n    prefer NewTimer when After will do.\n\nfunc Sleep(d Duration)\n    Sleep pauses the current goroutine for at least the duration d. A negative\n    or zero duration causes Sleep to return immediately.\n\nfunc Tick(d Duration) <-chan Time\n    Tick is a convenience wrapper for NewTicker providing access to the ticking\n    channel only. Unlike NewTicker, Tick will return nil if d <= 0.\n\n    Before Go 1.23, this documentation warned that the underlying Ticker would\n    never be recovered by the garbage collector, and that if efficiency was a\n    concern, code should use NewTicker instead and call Ticker.Stop when the\n    ticker is no longer needed. As of Go 1.23, the garbage collector can recover\n    unreferenced tickers, even if they haven't been stopped. The Stop method is\n    no longer necessary to help the garbage collector. There is no longer any\n    reason to prefer NewTicker when Tick will do.\n\n\nTYPES\n\ntype Duration int64\n    A Duration represents the elapsed time between two instants as an int64\n    nanosecond count. The representation limits the largest representable\n    duration to approximately 290 years.\n\nfunc ParseDuration(s string) (Duration, error)\n    ParseDuration parses a duration string. A duration string is a possibly\n    signed sequence of decimal numbers, each with optional fraction and a unit\n    suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\",\n    \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\", \"h\".\n\nfunc Since(t Time) Duration\n    Since returns the time elapsed since t. It is shorthand for\n    time.Now().Sub(t).\n\nfunc Until(t Time) Duration\n    Until returns the duration until t. It is shorthand for t.Sub(time.Now()).\n\nfunc (d Duration) Abs() Duration\n    Abs returns the absolute value of d. As a special case,\n    Duration(math.MinInt64) is converted to Duration(math.MaxInt64), reducing\n    its magnitude by 1 nanosecond.\n\nfunc (d Duration) Hours() float64\n    Hours returns the duration as a floating point number of hours.\n\nfunc (d Duration) Microseconds() int64\n    Microseconds returns the duration as an integer microsecond count.\n\nfunc (d Duration) Milliseconds() int64\n    Milliseconds returns the duration as an integer millisecond count.\n\nfunc (d Duration) Minutes() float64\n    Minutes returns the duration as a floating point number of minutes.\n\nfunc (d Duration) Nanoseconds() int64\n    Nanoseconds returns the duration as an integer nanosecond count.\n\nfunc (d Duration) Round(m Duration) Duration\n    Round returns the result of rounding d to the nearest multiple of m.\n    The rounding behavior for halfway values is to round away from zero.\n    If the result exceeds the maximum (or minimum) value that can be stored\n    in a Duration, Round returns the maximum (or minimum) duration. If m <= 0,\n    Round returns d unchanged.\n\nfunc (d Duration) Seconds() float64\n    Seconds returns the duration as a floating point number of seconds.\n\nfunc (d Duration) String() string\n    String returns a string representing the duration in the form \"72h3m0.5s\".\n    Leading zero units are omitted. As a special case, durations less than one\n    second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure\n    that the leading digit is non-zero. The zero duration formats as 0s.\n\nfunc (d Duration) Truncate(m Duration) Duration\n    Truncate returns the result of rounding d toward zero to a multiple of m.\n    If m <= 0, Truncate returns d unchanged.\n\ntype Location struct {\n\t// Has unexported fields.\n}\n    A Location maps time instants to the zone in use at that time. Typically,\n    the Location represents the collection of time offsets in use in a\n    geographical area. For many Locations the time offset varies depending on\n    whether daylight savings time is in use at the time instant.\n\n    Location is used to provide a time zone in a printed Time value and for\n    calculations involving intervals that may cross daylight savings time\n    boundaries.\n\nvar Local *Location = &localLoc\n    Local represents the system's local time zone. On Unix systems,\n    Local consults the TZ environment variable to find the time zone to use.\n    No TZ means use the system default /etc/localtime. TZ=\"\" means use UTC.\n    TZ=\"foo\" means use file foo in the system timezone directory.\n\nvar UTC *Location = &utcLoc\n    UTC represents Universal Coordinated Time (UTC).\n\nfunc FixedZone(name string, offset int) *Location\n    FixedZone returns a Location that always uses the given zone name and offset\n    (seconds east of UTC).\n\nfunc LoadLocation(name string) (*Location, error)\n    LoadLocation returns the Location with the given name.\n\n    If the name is \"\" or \"UTC\", LoadLocation returns UTC. If the name is\n    \"Local\", LoadLocation returns Local.\n\n    Otherwise, the name is taken to be a location name corresponding to a file\n    in the IANA Time Zone database, such as \"America/New_York\".\n\n    LoadLocation looks for the IANA Time Zone database in the following\n    locations in order:\n\n      - the directory or uncompressed zip file named by the ZONEINFO environment\n        variable\n      - on a Unix system, the system standard installation location\n      - $GOROOT/lib/time/zoneinfo.zip\n      - the time/tzdata package, if it was imported\n\nfunc LoadLocationFromTZData(name string, data []byte) (*Location, error)\n    LoadLocationFromTZData returns a Location with the given name initialized\n    from the IANA Time Zone database-formatted data. The data should be in\n    the format of a standard IANA time zone file (for example, the content of\n    /etc/localtime on Unix systems).\n\nfunc (l *Location) String() string\n    String returns a descriptive name for the time zone information,\n    corresponding to the name argument to LoadLocation or FixedZone.\n\ntype Month int\n    A Month specifies a month of the year (January = 1, ...).\n\nconst (\n\tJanuary Month = 1 + iota\n\tFebruary\n\tMarch\n\tApril\n\tMay\n\tJune\n\tJuly\n\tAugust\n\tSeptember\n\tOctober\n\tNovember\n\tDecember\n)\nfunc (m Month) String() string\n    String returns the English name of the month (\"January\", \"February\", ...).\n\ntype ParseError struct {\n\tLayout     string\n\tValue      string\n\tLayoutElem string\n\tValueElem  string\n\tMessage    string\n}\n    ParseError describes a problem parsing a time string.\n\nfunc (e *ParseError) Error() string\n    Error returns the string representation of a ParseError.\n\ntype Ticker struct {\n\tC <-chan Time // The channel on which the ticks are delivered.\n\t// Has unexported fields.\n}\n    A Ticker holds a channel that delivers \u201cticks\u201d of a clock at intervals.\n\nfunc NewTicker(d Duration) *Ticker\n    NewTicker returns a new Ticker containing a channel that will send the\n    current time on the channel after each tick. The period of the ticks is\n    specified by the duration argument. The ticker will adjust the time interval\n    or drop ticks to make up for slow receivers. The duration d must be greater\n    than zero; if not, NewTicker will panic.\n\n    Before Go 1.23, the garbage collector did not recover tickers that had not\n    yet expired or been stopped, so code often immediately deferred t.Stop\n    after calling NewTicker, to make the ticker recoverable when it was no\n    longer needed. As of Go 1.23, the garbage collector can recover unreferenced\n    tickers, even if they haven't been stopped. The Stop method is no longer\n    necessary to help the garbage collector. (Code may of course still want to\n    call Stop to stop the ticker for other reasons.)\n\nfunc (t *Ticker) Reset(d Duration)\n    Reset stops a ticker and resets its period to the specified duration.\n    The next tick will arrive after the new period elapses. The duration d must\n    be greater than zero; if not, Reset will panic.\n\nfunc (t *Ticker) Stop()\n    Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does\n    not close the channel, to prevent a concurrent goroutine reading from the\n    channel from seeing an erroneous \"tick\".\n\ntype Time struct {\n\t// Has unexported fields.\n}\n    A Time represents an instant in time with nanosecond precision.\n\n    Programs using times should typically store and pass them as values,\n    not pointers. That is, time variables and struct fields should be of type\n    time.Time, not *time.Time.\n\n    A Time value can be used by multiple goroutines simultaneously except that\n    the methods Time.GobDecode, Time.UnmarshalBinary, Time.UnmarshalJSON and\n    Time.UnmarshalText are not concurrency-safe.\n\n    Time instants can be compared using the Time.Before, Time.After, and\n    Time.Equal methods. The Time.Sub method subtracts two instants, producing a\n    Duration. The Time.Add method adds a Time and a Duration, producing a Time.\n\n    The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As\n    this time is unlikely to come up in practice, the Time.IsZero method gives a\n    simple way of detecting a time that has not been initialized explicitly.\n\n    Each time has an associated Location. The methods Time.Local, Time.UTC,\n    and Time.In return a Time with a specific Location. Changing the Location\n    of a Time value with these methods does not change the actual instant it\n    represents, only the time zone in which to interpret it.\n\n    Representations of a Time value saved by the Time.GobEncode,\n    Time.MarshalBinary, Time.AppendBinary, Time.MarshalJSON, Time.MarshalText\n    and Time.AppendText methods store the Time.Location's offset, but not the\n    location name. They therefore lose information about Daylight Saving Time.\n\n    In addition to the required \u201cwall clock\u201d reading, a Time may contain an\n    optional reading of the current process's monotonic clock, to provide\n    additional precision for comparison or subtraction. See the \u201cMonotonic\n    Clocks\u201d section in the package documentation for details.\n\n    Note that the Go == operator compares not just the time instant but also\n    the Location and the monotonic clock reading. Therefore, Time values should\n    not be used as map or database keys without first guaranteeing that the\n    identical Location has been set for all values, which can be achieved\n    through use of the UTC or Local method, and that the monotonic clock reading\n    has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)\n    to t == u, since t.Equal uses the most accurate comparison available and\n    correctly handles the case when only one of its arguments has a monotonic\n    clock reading.\n\nfunc Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time\n    Date returns the Time corresponding to\n\n        yyyy-mm-dd hh:mm:ss + nsec nanoseconds\n\n    in the appropriate zone for that time in the given location.\n\n    The month, day, hour, min, sec, and nsec values may be outside their usual\n    ranges and will be normalized during the conversion. For example, October 32\n    converts to November 1.\n\n    A daylight savings time transition skips or repeats times. For example,\n    in the United States, March 13, 2011 2:15am never occurred, while November\n    6, 2011 1:15am occurred twice. In such cases, the choice of time zone,\n    and therefore the time, is not well-defined. Date returns a time that is\n    correct in one of the two zones involved in the transition, but it does not\n    guarantee which.\n\n    Date panics if loc is nil.\n\nfunc Now() Time\n    Now returns the current local time.\n\nfunc Parse(layout, value string) (Time, error)\n    Parse parses a formatted string and returns the time value it represents.\n    See the documentation for the constant called Layout to see how to represent\n    the format. The second argument must be parseable using the format string\n    (layout) provided as the first argument.\n\n    The example for Time.Format demonstrates the working of the layout string in\n    detail and is a good reference.\n\n    When parsing (only), the input may contain a fractional second field\n    immediately after the seconds field, even if the layout does not signify\n    its presence. In that case either a comma or a decimal point followed by\n    a maximal series of digits is parsed as a fractional second. Fractional\n    seconds are truncated to nanosecond precision.\n\n    Elements omitted from the layout are assumed to be zero or, when zero is\n    impossible, one, so parsing \"3:04pm\" returns the time corresponding to\n    Jan 1, year 0, 15:04:00 UTC (note that because the year is 0, this time is\n    before the zero Time). Years must be in the range 0000..9999. The day of the\n    week is checked for syntax but it is otherwise ignored.\n\n    For layouts specifying the two-digit year 06, a value NN >= 69 will be\n    treated as 19NN and a value NN < 69 will be treated as 20NN.\n\n    The remainder of this comment describes the handling of time zones.\n\n    In the absence of a time zone indicator, Parse returns a time in UTC.\n\n    When parsing a time with a zone offset like -0700, if the offset corresponds\n    to a time zone used by the current location (Local), then Parse uses that\n    location and zone in the returned time. Otherwise it records the time as\n    being in a fabricated location with time fixed at the given zone offset.\n\n    When parsing a time with a zone abbreviation like MST, if the\n    zone abbreviation has a defined offset in the current location,\n    then that offset is used. The zone abbreviation \"UTC\" is recognized\n    as UTC regardless of location. If the zone abbreviation is unknown,\n    Parse records the time as being in a fabricated location with the given\n    zone abbreviation and a zero offset. This choice means that such a time can\n    be parsed and reformatted with the same layout losslessly, but the exact\n    instant used in the representation will differ by the actual zone offset.\n    To avoid such problems, prefer time layouts that use a numeric zone offset,\n    or use ParseInLocation.\n\nfunc ParseInLocation(layout, value string, loc *Location) (Time, error)\n    ParseInLocation is like Parse but differs in two important ways. First,\n    in the absence of time zone information, Parse interprets a time as UTC;\n    ParseInLocation interprets the time as in the given location. Second,\n    when given a zone offset or abbreviation, Parse tries to match it against\n    the Local location; ParseInLocation uses the given location.\n\nfunc Unix(sec int64, nsec int64) Time\n    Unix returns the local Time corresponding to the given Unix time,\n    sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid\n    to pass nsec outside the range [0, 999999999]. Not all sec values have\n    a corresponding time value. One such value is 1<<63-1 (the largest int64\n    value).\n\nfunc UnixMicro(usec int64) Time\n    UnixMicro returns the local Time corresponding to the given Unix time,\n    usec microseconds since January 1, 1970 UTC.\n\nfunc UnixMilli(msec int64) Time\n    UnixMilli returns the local Time corresponding to the given Unix time,\n    msec milliseconds since January 1, 1970 UTC.\n\nfunc (t Time) Add(d Duration) Time\n    Add returns the time t+d.\n\nfunc (t Time) AddDate(years int, months int, days int) Time\n    AddDate returns the time corresponding to adding the given number of years,\n    months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1,\n    2011 returns March 4, 2010.\n\n    Note that dates are fundamentally coupled to timezones, and calendrical\n    periods like days don't have fixed durations. AddDate uses the Location\n    of the Time value to determine these durations. That means that the same\n    AddDate arguments can produce a different shift in absolute time depending\n    on the base Time value and its Location. For example, AddDate(0, 0,\n    1) applied to 12:00 on March 27 always returns 12:00 on March 28. At some\n    locations and in some years this is a 24 hour shift. In others it's a 23\n    hour shift due to daylight savings time transitions.\n\n    AddDate normalizes its result in the same way that Date does, so, for\n    example, adding one month to October 31 yields December 1, the normalized\n    form for November 31.\n\nfunc (t Time) After(u Time) bool\n    After reports whether the time instant t is after u.\n\nfunc (t Time) AppendBinary(b []byte) ([]byte, error)\n    AppendBinary implements the encoding.BinaryAppender interface.\n\nfunc (t Time) AppendFormat(b []byte, layout string) []byte\n    AppendFormat is like Time.Format but appends the textual representation to b\n    and returns the extended buffer.\n\nfunc (t Time) AppendText(b []byte) ([]byte, error)\n    AppendText implements the encoding.TextAppender interface. The time is\n    formatted in RFC 3339 format with sub-second precision. If the timestamp\n    cannot be represented as valid RFC 3339 (e.g., the year is out of range),\n    then an error is returned.\n\nfunc (t Time) Before(u Time) bool\n    Before reports whether the time instant t is before u.\n\nfunc (t Time) Clock() (hour, min, sec int)\n    Clock returns the hour, minute, and second within the day specified by t.\n\nfunc (t Time) Compare(u Time) int\n    Compare compares the time instant t with u. If t is before u, it returns -1;\n    if t is after u, it returns +1; if they're the same, it returns 0.\n\nfunc (t Time) Date() (year int, month Month, day int)\n    Date returns the year, month, and day in which t occurs.\n\nfunc (t Time) Day() int\n    Day returns the day of the month specified by t.\n\nfunc (t Time) Equal(u Time) bool\n    Equal reports whether t and u represent the same time instant. Two times\n    can be equal even if they are in different locations. For example, 6:00\n    +0200 and 4:00 UTC are Equal. See the documentation on the Time type for the\n    pitfalls of using == with Time values; most code should use Equal instead.\n\nfunc (t Time) Format(layout string) string\n    Format returns a textual representation of the time value formatted\n    according to the layout defined by the argument. See the documentation for\n    the constant called Layout to see how to represent the layout format.\n\n    The executable example for Time.Format demonstrates the working of the\n    layout string in detail and is a good reference.\n\nfunc (t Time) GoString() string\n    GoString implements fmt.GoStringer and formats t to be printed in Go source\n    code.\n\nfunc (t *Time) GobDecode(data []byte) error\n    GobDecode implements the gob.GobDecoder interface.\n\nfunc (t Time) GobEncode() ([]byte, error)\n    GobEncode implements the gob.GobEncoder interface.\n\nfunc (t Time) Hour() int\n    Hour returns the hour within the day specified by t, in the range [0, 23].\n\nfunc (t Time) ISOWeek() (year, week int)\n    ISOWeek returns the ISO 8601 year and week number in which t occurs.\n    Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52\n    or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1.\n\nfunc (t Time) In(loc *Location) Time\n    In returns a copy of t representing the same time instant, but with the\n    copy's location information set to loc for display purposes.\n\n    In panics if loc is nil.\n\nfunc (t Time) IsDST() bool\n    IsDST reports whether the time in the configured location is in Daylight\n    Savings Time.\n\nfunc (t Time) IsZero() bool\n    IsZero reports whether t represents the zero time instant, January 1,\n    year 1, 00:00:00 UTC.\n\nfunc (t Time) Local() Time\n    Local returns t with the location set to local time.\n\nfunc (t Time) Location() *Location\n    Location returns the time zone information associated with t.\n\nfunc (t Time) MarshalBinary() ([]byte, error)\n    MarshalBinary implements the encoding.BinaryMarshaler interface.\n\nfunc (t Time) MarshalJSON() ([]byte, error)\n    MarshalJSON implements the encoding/json.Marshaler interface. The time is\n    a quoted string in the RFC 3339 format with sub-second precision. If the\n    timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of\n    range), then an error is reported.\n\nfunc (t Time) MarshalText() ([]byte, error)\n    MarshalText implements the encoding.TextMarshaler interface. The output\n    matches that of calling the Time.AppendText method.\n\n    See Time.AppendText for more information.\n\nfunc (t Time) Minute() int\n    Minute returns the minute offset within the hour specified by t, in the\n    range [0, 59].\n\nfunc (t Time) Month() Month\n    Month returns the month of the year specified by t.\n\nfunc (t Time) Nanosecond() int\n    Nanosecond returns the nanosecond offset within the second specified by t,\n    in the range [0, 999999999].\n\nfunc (t Time) Round(d Duration) Time\n    Round returns the result of rounding t to the nearest multiple of d (since\n    the zero time). The rounding behavior for halfway values is to round up.\n    If d <= 0, Round returns t stripped of any monotonic clock reading but\n    otherwise unchanged.\n\n    Round operates on the time as an absolute duration since the zero time;\n    it does not operate on the presentation form of the time. Thus, Round(Hour)\n    may return a time with a non-zero minute, depending on the time's Location.\n\nfunc (t Time) Second() int\n    Second returns the second offset within the minute specified by t, in the\n    range [0, 59].\n\nfunc (t Time) String() string\n    String returns the time formatted using the format string\n\n        \"2006-01-02 15:04:05.999999999 -0700 MST\"\n\n    If the time has a monotonic clock reading, the returned string includes\n    a final field \"m=\u00b1<value>\", where value is the monotonic clock reading\n    formatted as a decimal number of seconds.\n\n    The returned string is meant for debugging; for a stable serialized\n    representation, use t.MarshalText, t.MarshalBinary, or t.Format with an\n    explicit format string.\n\nfunc (t Time) Sub(u Time) Duration\n    Sub returns the duration t-u. If the result exceeds the maximum (or minimum)\n    value that can be stored in a Duration, the maximum (or minimum) duration\n    will be returned. To compute t-d for a duration d, use t.Add(-d).\n\nfunc (t Time) Truncate(d Duration) Time\n    Truncate returns the result of rounding t down to a multiple of d (since the\n    zero time). If d <= 0, Truncate returns t stripped of any monotonic clock\n    reading but otherwise unchanged.\n\n    Truncate operates on the time as an absolute duration since the zero time;\n    it does not operate on the presentation form of the time. Thus,\n    Truncate(Hour) may return a time with a non-zero minute, depending on the\n    time's Location.\n\nfunc (t Time) UTC() Time\n    UTC returns t with the location set to UTC.\n\nfunc (t Time) Unix() int64\n    Unix returns t as a Unix time, the number of seconds elapsed since January\n    1, 1970 UTC. The result does not depend on the location associated with t.\n    Unix-like operating systems often record time as a 32-bit count of seconds,\n    but since the method here returns a 64-bit value it is valid for billions of\n    years into the past or future.\n\nfunc (t Time) UnixMicro() int64\n    UnixMicro returns t as a Unix time, the number of microseconds elapsed\n    since January 1, 1970 UTC. The result is undefined if the Unix time in\n    microseconds cannot be represented by an int64 (a date before year -290307\n    or after year 294246). The result does not depend on the location associated\n    with t.\n\nfunc (t Time) UnixMilli() int64\n    UnixMilli returns t as a Unix time, the number of milliseconds elapsed\n    since January 1, 1970 UTC. The result is undefined if the Unix time in\n    milliseconds cannot be represented by an int64 (a date more than 292 million\n    years before or after 1970). The result does not depend on the location\n    associated with t.\n\nfunc (t Time) UnixNano() int64\n    UnixNano returns t as a Unix time, the number of nanoseconds elapsed since\n    January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds\n    cannot be represented by an int64 (a date before the year 1678 or after\n    2262). Note that this means the result of calling UnixNano on the zero Time\n    is undefined. The result does not depend on the location associated with t.\n\nfunc (t *Time) UnmarshalBinary(data []byte) error\n    UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\n\nfunc (t *Time) UnmarshalJSON(data []byte) error\n    UnmarshalJSON implements the encoding/json.Unmarshaler interface. The time\n    must be a quoted string in the RFC 3339 format.\n\nfunc (t *Time) UnmarshalText(data []byte) error\n    UnmarshalText implements the encoding.TextUnmarshaler interface. The time\n    must be in the RFC 3339 format.\n\nfunc (t Time) Weekday() Weekday\n    Weekday returns the day of the week specified by t.\n\nfunc (t Time) Year() int\n    Year returns the year in which t occurs.\n\nfunc (t Time) YearDay() int\n    YearDay returns the day of the year specified by t, in the range [1,365] for\n    non-leap years, and [1,366] in leap years.\n\nfunc (t Time) Zone() (name string, offset int)\n    Zone computes the time zone in effect at time t, returning the abbreviated\n    name of the zone (such as \"CET\") and its offset in seconds east of UTC.\n\nfunc (t Time) ZoneBounds() (start, end Time)\n    ZoneBounds returns the bounds of the time zone in effect at time t.\n    The zone begins at start and the next zone begins at end. If the zone begins\n    at the beginning of time, start will be returned as a zero Time. If the zone\n    goes on forever, end will be returned as a zero Time. The Location of the\n    returned times will be the same as t.\n\ntype Timer struct {\n\tC <-chan Time\n\t// Has unexported fields.\n}\n    The Timer type represents a single event. When the Timer expires, the\n    current time will be sent on C, unless the Timer was created by AfterFunc.\n    A Timer must be created with NewTimer or AfterFunc.\n\nfunc AfterFunc(d Duration, f func()) *Timer\n    AfterFunc waits for the duration to elapse and then calls f in its own\n    goroutine. It returns a Timer that can be used to cancel the call using its\n    Stop method. The returned Timer's C field is not used and will be nil.\n\nfunc NewTimer(d Duration) *Timer\n    NewTimer creates a new Timer that will send the current time on its channel\n    after at least duration d.\n\n    Before Go 1.23, the garbage collector did not recover timers that had not\n    yet expired or been stopped, so code often immediately deferred t.Stop\n    after calling NewTimer, to make the timer recoverable when it was no longer\n    needed. As of Go 1.23, the garbage collector can recover unreferenced\n    timers, even if they haven't expired or been stopped. The Stop method is no\n    longer necessary to help the garbage collector. (Code may of course still\n    want to call Stop to stop the timer for other reasons.)\n\n    Before Go 1.23, the channel associated with a Timer was asynchronous\n    (buffered, capacity 1), which meant that stale time values could be received\n    even after Timer.Stop or Timer.Reset returned. As of Go 1.23, the channel is\n    synchronous (unbuffered, capacity 0), eliminating the possibility of those\n    stale values.\n\n    The GODEBUG setting asynctimerchan=1 restores both pre-Go 1.23 behaviors:\n    when set, unexpired timers won't be garbage collected, and channels will\n    have buffered capacity. This setting may be removed in Go 1.27 or later.\n\nfunc (t *Timer) Reset(d Duration) bool\n    Reset changes the timer to expire after duration d. It returns true if the\n    timer had been active, false if the timer had expired or been stopped.\n\n    For a func-based timer created with AfterFunc(d, f), Reset either\n    reschedules when f will run, in which case Reset returns true, or schedules\n    f to run again, in which case it returns false. When Reset returns false,\n    Reset neither waits for the prior f to complete before returning nor does it\n    guarantee that the subsequent goroutine running f does not run concurrently\n    with the prior one. If the caller needs to know whether the prior execution\n    of f is completed, it must coordinate with f explicitly.\n\n    For a chan-based timer created with NewTimer, as of Go 1.23, any receive\n    from t.C after Reset has returned is guaranteed not to receive a time\n    value corresponding to the previous timer settings; if the program has not\n    received from t.C already and the timer is running, Reset is guaranteed\n    to return true. Before Go 1.23, the only safe way to use Reset was to\n    call Timer.Stop and explicitly drain the timer first. See the NewTimer\n    documentation for more details.\n\nfunc (t *Timer) Stop() bool\n    Stop prevents the Timer from firing. It returns true if the call stops the\n    timer, false if the timer has already expired or been stopped.\n\n    For a func-based timer created with AfterFunc(d, f), if t.Stop returns\n    false, then the timer has already expired and the function f has been\n    started in its own goroutine; Stop does not wait for f to complete before\n    returning. If the caller needs to know whether f is completed, it must\n    coordinate with f explicitly.\n\n    For a chan-based timer created with NewTimer(d), as of Go 1.23, any receive\n    from t.C after Stop has returned is guaranteed to block rather than receive\n    a stale time value from before the Stop; if the program has not received\n    from t.C already and the timer is running, Stop is guaranteed to return\n    true. Before Go 1.23, the only safe way to use Stop was insert an extra\n    <-t.C if Stop returned false to drain a potential stale value. See the\n    NewTimer documentation for more details.\n\ntype Weekday int\n    A Weekday specifies a day of the week (Sunday = 0, ...).\n\nconst (\n\tSunday Weekday = iota\n\tMonday\n\tTuesday\n\tWednesday\n\tThursday\n\tFriday\n\tSaturday\n)\nfunc (d Weekday) String() string\n    String returns the English name of the day (\"Sunday\", \"Monday\", ...).\n\n"}, {"path": "stdlib/crypto-internal-fips140-alias.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-alias", "content": "package alias // import \"crypto/internal/fips140/alias\"\n\nPackage alias implements memory aliasing tests. This code also exists as\ngolang.org/x/crypto/internal/alias.\n\nFUNCTIONS\n\nfunc AnyOverlap(x, y []byte) bool\n    AnyOverlap reports whether x and y share memory at any (not necessarily\n    corresponding) index. The memory beyond the slice length is ignored.\n\nfunc InexactOverlap(x, y []byte) bool\n    InexactOverlap reports whether x and y share memory at any non-corresponding\n    index. The memory beyond the slice length is ignored. Note that x and y can\n    have different lengths and still not have any inexact overlap.\n\n    InexactOverlap can be used to implement the requirements of the\n    crypto/cipher AEAD, Block, BlockMode and Stream interfaces.\n\n"}, {"path": "stdlib/vendor-golang.org-x-net-http-httpproxy.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-net-http-httpproxy", "content": ""}, {"path": "stdlib/internal-testenv.md", "category": "stdlib", "name": "stdlib/internal-testenv", "content": "package testenv // import \"internal/testenv\"\n\nPackage testenv provides information about what functionality is available in\ndifferent testing environments run by the Go team.\n\nIt is an internal package because these details are specific to the Go team's\ntest setup (on build.golang.org) and not fundamental to tests in general.\n\nVARIABLES\n\nvar Sigquit = syscall.SIGQUIT\n    Sigquit is the signal to send to kill a hanging subprocess. Send SIGQUIT to\n    get a stack trace.\n\n\nFUNCTIONS\n\nfunc Builder() string\n    Builder reports the name of the builder running this test (for example,\n    \"linux-amd64\" or \"windows-386-gce\"). If the test is not running on the build\n    infrastructure, Builder returns the empty string.\n\nfunc CPUIsSlow() bool\n    CPUIsSlow reports whether the CPU running the test is suspected to be slow.\n\nfunc CPUProfilingBroken() bool\n    CPUProfilingBroken returns true if CPU profiling has known issues on this\n    platform.\n\nfunc CanInternalLink(withCgo bool) bool\n    CanInternalLink reports whether the current system can link programs with\n    internal linking.\n\nfunc CleanCmdEnv(cmd *exec.Cmd) *exec.Cmd\n    CleanCmdEnv will fill cmd.Env with the environment, excluding certain\n    variables that could modify the behavior of the Go tools such as GODEBUG and\n    GOTRACEBACK.\n\n    If the caller wants to set cmd.Dir, set it before calling this function,\n    so PWD will be set correctly in the environment.\n\nfunc Command(t testing.TB, name string, args ...string) *exec.Cmd\n    Command is like exec.Command, but applies the same changes as\n    testenv.CommandContext (with a default Context).\n\nfunc CommandContext(t testing.TB, ctx context.Context, name string, args ...string) *exec.Cmd\n    CommandContext is like exec.CommandContext, but:\n      - skips t if the platform does not support os/exec,\n      - sends SIGQUIT (if supported by the platform) instead of SIGKILL in its\n        Cancel function\n      - if the test has a deadline, adds a Context timeout and WaitDelay for an\n        arbitrary grace period before the test's deadline expires,\n      - fails the test if the command does not complete before the test's\n        deadline, and\n      - sets a Cleanup function that verifies that the test did not leak a\n        subprocess.\n\nfunc Executable(t testing.TB) string\n    Executable is a wrapper around MustHaveExec and os.Executable. It returns\n    the path name for the executable that started the current process, or skips\n    the test if the current system can't start new processes, or fails the test\n    if the path can not be obtained.\n\nfunc GOROOT(t testing.TB) string\n    GOROOT reports the path to the directory containing the root of the Go\n    project source tree. This is normally equivalent to runtime.GOROOT,\n    but works even if the test binary was built with -trimpath and cannot exec\n    'go env GOROOT'.\n\n    If GOROOT cannot be found, GOROOT skips t if t is non-nil, or panics\n    otherwise.\n\nfunc GoTool() (string, error)\n    GoTool reports the path to the Go tool.\n\nfunc GoToolPath(t testing.TB) string\n    GoToolPath reports the path to the Go tool. It is a convenience wrapper\n    around GoTool. If the tool is unavailable GoToolPath calls t.Skip. If the\n    tool should be available and isn't, GoToolPath calls t.Fatal.\n\nfunc HasCGO() bool\n    HasCGO reports whether the current system can use cgo.\n\nfunc HasExternalNetwork() bool\n    HasExternalNetwork reports whether the current system can use external\n    (non-localhost) networks.\n\nfunc HasGoBuild() bool\n    HasGoBuild reports whether the current system can build programs with \u201cgo\n    build\u201d and then run them with os.StartProcess or exec.Command.\n\nfunc HasGoRun() bool\n    HasGoRun reports whether the current system can run programs with \u201cgo run\u201d.\n\nfunc HasLink() bool\n    HasLink reports whether the current system can use os.Link.\n\nfunc HasParallelism() bool\n    HasParallelism reports whether the current system can execute multiple\n    threads in parallel. There is a copy of this function in cmd/dist/test.go.\n\nfunc HasSymlink() bool\n    HasSymlink reports whether the current system can use os.Symlink.\n\nfunc MustHaveBuildMode(t testing.TB, buildmode string)\n    MustHaveBuildMode reports whether the current system can build programs\n    in the given build mode. If not, MustHaveBuildMode calls t.Skip with an\n    explanation.\n\nfunc MustHaveCGO(t testing.TB)\n    MustHaveCGO calls t.Skip if cgo is not available.\n\nfunc MustHaveExec(t testing.TB)\n    MustHaveExec checks that the current system can start new processes using\n    os.StartProcess or (more commonly) exec.Command. If not, MustHaveExec calls\n    t.Skip with an explanation.\n\n    On some platforms MustHaveExec checks for exec support by re-executing\n    the current executable, which must be a binary built by 'go test'.\n    We intentionally do not provide a HasExec function because of the risk of\n    inappropriate recursion in TestMain functions.\n\n    To check for exec support outside of a test, just try to exec the command.\n    If exec is not supported, testenv.SyscallIsNotSupported will return true for\n    the resulting error.\n\nfunc MustHaveExecPath(t testing.TB, path string)\n    MustHaveExecPath checks that the current system can start the named\n    executable using os.StartProcess or (more commonly) exec.Command. If not,\n    MustHaveExecPath calls t.Skip with an explanation.\n\nfunc MustHaveExternalNetwork(t testing.TB)\n    MustHaveExternalNetwork checks that the current system can use external\n    (non-localhost) networks. If not, MustHaveExternalNetwork calls t.Skip with\n    an explanation.\n\nfunc MustHaveGoBuild(t testing.TB)\n    MustHaveGoBuild checks that the current system can build programs with\n    \u201cgo build\u201d and then run them with os.StartProcess or exec.Command. If not,\n    MustHaveGoBuild calls t.Skip with an explanation.\n\nfunc MustHaveGoRun(t testing.TB)\n    MustHaveGoRun checks that the current system can run programs with \u201cgo run\u201d.\n    If not, MustHaveGoRun calls t.Skip with an explanation.\n\nfunc MustHaveLink(t testing.TB)\n    MustHaveLink reports whether the current system can use os.Link. If not,\n    MustHaveLink calls t.Skip with an explanation.\n\nfunc MustHaveParallelism(t testing.TB)\n    MustHaveParallelism checks that the current system can execute multiple\n    threads in parallel. If not, MustHaveParallelism calls t.Skip with an\n    explanation.\n\nfunc MustHaveSource(t testing.TB)\n    MustHaveSource checks that the entire source tree is available under GOROOT.\n    If not, it calls t.Skip with an explanation.\n\nfunc MustHaveSymlink(t testing.TB)\n    MustHaveSymlink reports whether the current system can use os.Symlink.\n    If not, MustHaveSymlink calls t.Skip with an explanation.\n\nfunc MustInternalLink(t testing.TB, with SpecialBuildTypes)\n    MustInternalLink checks that the current system can link programs with\n    internal linking. If not, MustInternalLink calls t.Skip with an explanation.\n\nfunc MustInternalLinkPIE(t testing.TB)\n    MustInternalLinkPIE checks whether the current system can link PIE binary\n    using internal linking. If not, MustInternalLinkPIE calls t.Skip with an\n    explanation.\n\nfunc OptimizationOff() bool\n    OptimizationOff reports whether optimization is disabled.\n\nfunc ParallelOn64Bit(t *testing.T)\n    ParallelOn64Bit calls t.Parallel() unless there is a case that cannot\n    be parallel. This function should be used when it is necessary to avoid\n    t.Parallel on 32-bit machines, typically because the test uses lots of\n    memory.\n\nfunc SkipFlaky(t testing.TB, issue int)\nfunc SkipFlakyNet(t testing.TB)\nfunc SkipIfOptimizationOff(t testing.TB)\n    SkipIfOptimizationOff skips t if optimization is disabled.\n\nfunc SkipIfShortAndSlow(t testing.TB)\n    SkipIfShortAndSlow skips t if -short is set and the CPU running the test is\n    suspected to be slow.\n\n    (This is useful for CPU-intensive tests that otherwise complete quickly.)\n\nfunc SyscallIsNotSupported(err error) bool\n    SyscallIsNotSupported reports whether err may indicate that a system call is\n    not supported by the current platform or execution environment.\n\nfunc WriteImportcfg(t testing.TB, dstPath string, packageFiles map[string]string, pkgs ...string)\n    WriteImportcfg writes an importcfg file used by the compiler or linker to\n    dstPath containing entries for the file mappings in packageFiles, as well as\n    for the packages transitively imported by the package(s) in pkgs.\n\n    pkgs may include any package pattern that is valid to pass to 'go list',\n    so it may also be a list of Go source files all in the same directory.\n\n\nTYPES\n\ntype SpecialBuildTypes struct {\n\tCgo  bool\n\tAsan bool\n\tMsan bool\n\tRace bool\n}\n    SpecialBuildTypes are interesting build types that may affect linking.\n\nvar NoSpecialBuildTypes SpecialBuildTypes\n    NoSpecialBuildTypes indicates a standard, no cgo go build.\n\n"}, {"path": "stdlib/crypto-internal-fips140-hmac.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-hmac", "content": "package hmac // import \"crypto/internal/fips140/hmac\"\n\nPackage hmac implements HMAC according to FIPS 198-1.\n\n[FIPS 198-1]: https://doi.org/10.6028/NIST.FIPS.198-1\n\nFUNCTIONS\n\nfunc MarkAsUsedInKDF(h *HMAC)\n    MarkAsUsedInKDF records that this HMAC instance is used as part of a KDF.\n\n\nTYPES\n\ntype HMAC struct {\n\t// Has unexported fields.\n}\n\nfunc New[H hash.Hash](h func() H, key []byte) *HMAC\n    New returns a new HMAC hash using the given hash.Hash type and key.\n\nfunc (h *HMAC) BlockSize() int\n\nfunc (h *HMAC) Clone() (hash.Cloner, error)\n    Clone implements hash.Cloner if the underlying hash does. Otherwise,\n    it returns an error wrapping errors.ErrUnsupported.\n\nfunc (h *HMAC) Reset()\n\nfunc (h *HMAC) Size() int\n\nfunc (h *HMAC) Sum(in []byte) []byte\n\nfunc (h *HMAC) Write(p []byte) (n int, err error)\n\n"}, {"path": "stdlib/vendor-golang.org-x-net-idna.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-net-idna", "content": ""}, {"path": "stdlib/testing-quick.md", "category": "stdlib", "name": "stdlib/testing-quick", "content": "package quick // import \"testing/quick\"\n\nPackage quick implements utility functions to help with black box testing.\n\nThe testing/quick package is frozen and is not accepting new features.\n\nFUNCTIONS\n\nfunc Check(f any, config *Config) error\n    Check looks for an input to f, any function that returns bool, such that\n    f returns false. It calls f repeatedly, with arbitrary values for each\n    argument. If f returns false on a given input, Check returns that input as a\n    *CheckError. For example:\n\n        func TestOddMultipleOfThree(t *testing.T) {\n        \tf := func(x int) bool {\n        \t\ty := OddMultipleOfThree(x)\n        \t\treturn y%2 == 1 && y%3 == 0\n        \t}\n        \tif err := quick.Check(f, nil); err != nil {\n        \t\tt.Error(err)\n        \t}\n        }\n\nfunc CheckEqual(f, g any, config *Config) error\n    CheckEqual looks for an input on which f and g return different results.\n    It calls f and g repeatedly with arbitrary values for each argument.\n    If f and g return different answers, CheckEqual returns a *CheckEqualError\n    describing the input and the outputs.\n\nfunc Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool)\n    Value returns an arbitrary value of the given type. If the type implements\n    the Generator interface, that will be used. Note: To create arbitrary values\n    for structs, all the fields must be exported.\n\n\nTYPES\n\ntype CheckEqualError struct {\n\tCheckError\n\tOut1 []any\n\tOut2 []any\n}\n    A CheckEqualError is the result CheckEqual finding an error.\n\nfunc (s *CheckEqualError) Error() string\n\ntype CheckError struct {\n\tCount int\n\tIn    []any\n}\n    A CheckError is the result of Check finding an error.\n\nfunc (s *CheckError) Error() string\n\ntype Config struct {\n\t// MaxCount sets the maximum number of iterations.\n\t// If zero, MaxCountScale is used.\n\tMaxCount int\n\t// MaxCountScale is a non-negative scale factor applied to the\n\t// default maximum.\n\t// A count of zero implies the default, which is usually 100\n\t// but can be set by the -quickchecks flag.\n\tMaxCountScale float64\n\t// Rand specifies a source of random numbers.\n\t// If nil, a default pseudo-random source will be used.\n\tRand *rand.Rand\n\t// Values specifies a function to generate a slice of\n\t// arbitrary reflect.Values that are congruent with the\n\t// arguments to the function being tested.\n\t// If nil, the top-level Value function is used to generate them.\n\tValues func([]reflect.Value, *rand.Rand)\n}\n    A Config structure contains options for running a test.\n\ntype Generator interface {\n\t// Generate returns a random instance of the type on which it is a\n\t// method using the size as a size hint.\n\tGenerate(rand *rand.Rand, size int) reflect.Value\n}\n    A Generator can generate random values of its own type.\n\ntype SetupError string\n    A SetupError is the result of an error in the way that check is being used,\n    independent of the functions being tested.\n\nfunc (s SetupError) Error() string\n\n"}, {"path": "stdlib/crypto-internal-fips140-edwards25519.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-edwards25519", "content": "package edwards25519 // import \"crypto/internal/fips140/edwards25519\"\n\nPackage edwards25519 implements group logic for the twisted Edwards curve\n\n    -x^2 + y^2 = 1 + -(121665/121666)*x^2*y^2\n\nThis is better known as the Edwards curve equivalent to Curve25519, and is the\ncurve used by the Ed25519 signature scheme.\n\nMost users don't need this package, and should instead use crypto/ed25519\nfor signatures, golang.org/x/crypto/curve25519 for Diffie-Hellman, or\ngithub.com/gtank/ristretto255 for prime order group logic.\n\nHowever, developers who do need to interact with low-level edwards25519\noperations can use filippo.io/edwards25519, an extended version of this package\nrepackaged as an importable module.\n\n(Note that filippo.io/edwards25519 and github.com/gtank/ristretto255 are\nnot maintained by the Go team and are not covered by the Go 1 Compatibility\nPromise.)\n\nTYPES\n\ntype Point struct {\n\t// Has unexported fields.\n}\n    Point represents a point on the edwards25519 curve.\n\n    This type works similarly to math/big.Int, and all arguments and receivers\n    are allowed to alias.\n\n    The zero value is NOT valid, and it may be used only as a receiver.\n\nfunc NewGeneratorPoint() *Point\n    NewGeneratorPoint returns a new Point set to the canonical generator.\n\nfunc NewIdentityPoint() *Point\n    NewIdentityPoint returns a new Point set to the identity.\n\nfunc (v *Point) Add(p, q *Point) *Point\n    Add sets v = p + q, and returns v.\n\nfunc (v *Point) Bytes() []byte\n    Bytes returns the canonical 32-byte encoding of v, according to RFC 8032,\n    Section 5.1.2.\n\nfunc (v *Point) Equal(u *Point) int\n    Equal returns 1 if v is equivalent to u, and 0 otherwise.\n\nfunc (v *Point) Negate(p *Point) *Point\n    Negate sets v = -p, and returns v.\n\nfunc (v *Point) ScalarBaseMult(x *Scalar) *Point\n    ScalarBaseMult sets v = x * B, where B is the canonical generator, and\n    returns v.\n\n    The scalar multiplication is done in constant time.\n\nfunc (v *Point) ScalarMult(x *Scalar, q *Point) *Point\n    ScalarMult sets v = x * q, and returns v.\n\n    The scalar multiplication is done in constant time.\n\nfunc (v *Point) Set(u *Point) *Point\n    Set sets v = u, and returns v.\n\nfunc (v *Point) SetBytes(x []byte) (*Point, error)\n    SetBytes sets v = x, where x is a 32-byte encoding of v. If x does not\n    represent a valid point on the curve, SetBytes returns nil and an error and\n    the receiver is unchanged. Otherwise, SetBytes returns v.\n\n    Note that SetBytes accepts all non-canonical encodings of valid points.\n    That is, it follows decoding rules that match most implementations in the\n    ecosystem rather than RFC 8032.\n\nfunc (v *Point) Subtract(p, q *Point) *Point\n    Subtract sets v = p - q, and returns v.\n\nfunc (v *Point) VarTimeDoubleScalarBaseMult(a *Scalar, A *Point, b *Scalar) *Point\n    VarTimeDoubleScalarBaseMult sets v = a * A + b * B, where B is the canonical\n    generator, and returns v.\n\n    Execution time depends on the inputs.\n\ntype Scalar struct {\n\t// Has unexported fields.\n}\n    A Scalar is an integer modulo\n\n        l = 2^252 + 27742317777372353535851937790883648493\n\n    which is the prime order of the edwards25519 group.\n\n    This type works similarly to math/big.Int, and all arguments and receivers\n    are allowed to alias.\n\n    The zero value is a valid zero element.\n\nfunc NewScalar() *Scalar\n    NewScalar returns a new zero Scalar.\n\nfunc (s *Scalar) Add(x, y *Scalar) *Scalar\n    Add sets s = x + y mod l, and returns s.\n\nfunc (s *Scalar) Bytes() []byte\n    Bytes returns the canonical 32-byte little-endian encoding of s.\n\nfunc (s *Scalar) Equal(t *Scalar) int\n    Equal returns 1 if s and t are equal, and 0 otherwise.\n\nfunc (s *Scalar) Multiply(x, y *Scalar) *Scalar\n    Multiply sets s = x * y mod l, and returns s.\n\nfunc (s *Scalar) MultiplyAdd(x, y, z *Scalar) *Scalar\n    MultiplyAdd sets s = x * y + z mod l, and returns s. It is equivalent to\n    using Multiply and then Add.\n\nfunc (s *Scalar) Negate(x *Scalar) *Scalar\n    Negate sets s = -x mod l, and returns s.\n\nfunc (s *Scalar) Set(x *Scalar) *Scalar\n    Set sets s = x, and returns s.\n\nfunc (s *Scalar) SetBytesWithClamping(x []byte) (*Scalar, error)\n    SetBytesWithClamping applies the buffer pruning described in RFC 8032,\n    Section 5.1.5 (also known as clamping) and sets s to the result. The input\n    must be 32 bytes, and it is not modified. If x is not of the right length,\n    SetBytesWithClamping returns nil and an error, and the receiver is\n    unchanged.\n\n    Note that since Scalar values are always reduced modulo the prime\n    order of the curve, the resulting value will not preserve any of the\n    cofactor-clearing properties that clamping is meant to provide. It will\n    however work as expected as long as it is applied to points on the prime\n    order subgroup, like in Ed25519. In fact, it is lost to history why RFC\n    8032 adopted the irrelevant RFC 7748 clamping, but it is now required for\n    compatibility.\n\nfunc (s *Scalar) SetCanonicalBytes(x []byte) (*Scalar, error)\n    SetCanonicalBytes sets s = x, where x is a 32-byte little-endian encoding of\n    s, and returns s. If x is not a canonical encoding of s, SetCanonicalBytes\n    returns nil and an error, and the receiver is unchanged.\n\nfunc (s *Scalar) SetUniformBytes(x []byte) (*Scalar, error)\n    SetUniformBytes sets s = x mod l, where x is a 64-byte little-endian\n    integer. If x is not of the right length, SetUniformBytes returns nil and an\n    error, and the receiver is unchanged.\n\n    SetUniformBytes can be used to set s to a uniformly distributed value given\n    64 uniformly distributed random bytes.\n\nfunc (s *Scalar) Subtract(x, y *Scalar) *Scalar\n    Subtract sets s = x - y mod l, and returns s.\n\n"}, {"path": "stdlib/crypto-hmac.md", "category": "stdlib", "name": "stdlib/crypto-hmac", "content": "package hmac // import \"crypto/hmac\"\n\nPackage hmac implements the Keyed-Hash Message Authentication Code (HMAC) as\ndefined in U.S. Federal Information Processing Standards Publication 198.\nAn HMAC is a cryptographic hash that uses a key to sign a message. The receiver\nverifies the hash by recomputing it using the same key.\n\nReceivers should be careful to use Equal to compare MACs in order to avoid\ntiming side-channels:\n\n    // ValidMAC reports whether messageMAC is a valid HMAC tag for message.\n    func ValidMAC(message, messageMAC, key []byte) bool {\n    \tmac := hmac.New(sha256.New, key)\n    \tmac.Write(message)\n    \texpectedMAC := mac.Sum(nil)\n    \treturn hmac.Equal(messageMAC, expectedMAC)\n    }\n\nFUNCTIONS\n\nfunc Equal(mac1, mac2 []byte) bool\n    Equal compares two MACs for equality without leaking timing information.\n\nfunc New(h func() hash.Hash, key []byte) hash.Hash\n    New returns a new HMAC hash using the given hash.Hash type and key.\n    New functions like crypto/sha256.New can be used as h. h must return a new\n    Hash every time it is called. Note that unlike other hash implementations\n    in the standard library, the returned Hash does not implement\n    encoding.BinaryMarshaler or encoding.BinaryUnmarshaler.\n\n"}, {"path": "stdlib/compress-gzip.md", "category": "stdlib", "name": "stdlib/compress-gzip", "content": "package gzip // import \"compress/gzip\"\n\nPackage gzip implements reading and writing of gzip format compressed files,\nas specified in RFC 1952.\n\nCONSTANTS\n\nconst (\n\tNoCompression      = flate.NoCompression\n\tBestSpeed          = flate.BestSpeed\n\tBestCompression    = flate.BestCompression\n\tDefaultCompression = flate.DefaultCompression\n\tHuffmanOnly        = flate.HuffmanOnly\n)\n    These constants are copied from the flate package, so that code that imports\n    compress/gzip does not also have to import compress/flate.\n\n\nVARIABLES\n\nvar (\n\t// ErrChecksum is returned when reading GZIP data that has an invalid checksum.\n\tErrChecksum = errors.New(\"gzip: invalid checksum\")\n\t// ErrHeader is returned when reading GZIP data that has an invalid header.\n\tErrHeader = errors.New(\"gzip: invalid header\")\n)\n\nTYPES\n\ntype Header struct {\n\tComment string    // comment\n\tExtra   []byte    // \"extra data\"\n\tModTime time.Time // modification time\n\tName    string    // file name\n\tOS      byte      // operating system type\n}\n    The gzip file stores a header giving metadata about the compressed file.\n    That header is exposed as the fields of the Writer and Reader structs.\n\n    Strings must be UTF-8 encoded and may only contain Unicode code points\n    U+0001 through U+00FF, due to limitations of the GZIP file format.\n\ntype Reader struct {\n\tHeader // valid after NewReader or Reader.Reset\n\n\t// Has unexported fields.\n}\n    A Reader is an io.Reader that can be read to retrieve uncompressed data from\n    a gzip-format compressed file.\n\n    In general, a gzip file can be a concatenation of gzip files, each with\n    its own header. Reads from the Reader return the concatenation of the\n    uncompressed data of each. Only the first header is recorded in the Reader\n    fields.\n\n    Gzip files store a length and checksum of the uncompressed data.\n    The Reader will return an ErrChecksum when Reader.Read reaches the end of\n    the uncompressed data if it does not have the expected length or checksum.\n    Clients should treat data returned by Reader.Read as tentative until they\n    receive the io.EOF marking the end of the data.\n\nfunc NewReader(r io.Reader) (*Reader, error)\n    NewReader creates a new Reader reading the given reader. If r does not also\n    implement io.ByteReader, the decompressor may read more data than necessary\n    from r.\n\n    It is the caller's responsibility to call Reader.Close when done.\n\n    The Reader.Header fields will be valid in the Reader returned.\n\nfunc (z *Reader) Close() error\n    Close closes the Reader. It does not close the underlying reader. In order\n    for the GZIP checksum to be verified, the reader must be fully consumed\n    until the io.EOF.\n\nfunc (z *Reader) Multistream(ok bool)\n    Multistream controls whether the reader supports multistream files.\n\n    If enabled (the default), the Reader expects the input to be a sequence of\n    individually gzipped data streams, each with its own header and trailer,\n    ending at EOF. The effect is that the concatenation of a sequence of gzipped\n    files is treated as equivalent to the gzip of the concatenation of the\n    sequence. This is standard behavior for gzip readers.\n\n    Calling Multistream(false) disables this behavior; disabling the behavior\n    can be useful when reading file formats that distinguish individual gzip\n    data streams or mix gzip data streams with other data streams. In this mode,\n    when the Reader reaches the end of the data stream, Reader.Read returns\n    io.EOF. The underlying reader must implement io.ByteReader in order to be\n    left positioned just after the gzip stream. To start the next stream, call\n    z.Reset(r) followed by z.Multistream(false). If there is no next stream,\n    z.Reset(r) will return io.EOF.\n\nfunc (z *Reader) Read(p []byte) (n int, err error)\n    Read implements io.Reader, reading uncompressed bytes from its underlying\n    reader.\n\nfunc (z *Reader) Reset(r io.Reader) error\n    Reset discards the Reader z's state and makes it equivalent to the result of\n    its original state from NewReader, but reading from r instead. This permits\n    reusing a Reader rather than allocating a new one.\n\ntype Writer struct {\n\tHeader // written at first call to Write, Flush, or Close\n\n\t// Has unexported fields.\n}\n    A Writer is an io.WriteCloser. Writes to a Writer are compressed and written\n    to w.\n\nfunc NewWriter(w io.Writer) *Writer\n    NewWriter returns a new Writer. Writes to the returned writer are compressed\n    and written to w.\n\n    It is the caller's responsibility to call Close on the Writer when done.\n    Writes may be buffered and not flushed until Close.\n\n    Callers that wish to set the fields in Writer.Header must do so before the\n    first call to Write, Flush, or Close.\n\nfunc NewWriterLevel(w io.Writer, level int) (*Writer, error)\n    NewWriterLevel is like NewWriter but specifies the compression level instead\n    of assuming DefaultCompression.\n\n    The compression level can be DefaultCompression, NoCompression, HuffmanOnly\n    or any integer value between BestSpeed and BestCompression inclusive.\n    The error returned will be nil if the level is valid.\n\nfunc (z *Writer) Close() error\n    Close closes the Writer by flushing any unwritten data to the underlying\n    io.Writer and writing the GZIP footer. It does not close the underlying\n    io.Writer.\n\nfunc (z *Writer) Flush() error\n    Flush flushes any pending compressed data to the underlying writer.\n\n    It is useful mainly in compressed network protocols, to ensure that a remote\n    reader has enough data to reconstruct a packet. Flush does not return until\n    the data has been written. If the underlying writer returns an error,\n    Flush returns that error.\n\n    In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.\n\nfunc (z *Writer) Reset(w io.Writer)\n    Reset discards the Writer z's state and makes it equivalent to the result\n    of its original state from NewWriter or NewWriterLevel, but writing to w\n    instead. This permits reusing a Writer rather than allocating a new one.\n\nfunc (z *Writer) Write(p []byte) (int, error)\n    Write writes a compressed form of p to the underlying io.Writer. The\n    compressed bytes are not necessarily flushed until the Writer is closed.\n\n"}, {"path": "stdlib/archive-zip.md", "category": "stdlib", "name": "stdlib/archive-zip", "content": "package zip // import \"archive/zip\"\n\nPackage zip provides support for reading and writing ZIP archives.\n\nSee the ZIP specification for details.\n\nThis package does not support disk spanning.\n\nA note about ZIP64:\n\nTo be backwards compatible the FileHeader has both 32 and 64 bit Size fields.\nThe 64 bit fields will always contain the correct value and for normal archives\nboth fields will be the same. For files requiring the ZIP64 format the 32 bit\nfields will be 0xffffffff and the 64 bit fields must be used instead.\n\n[ZIP specification]: https://support.pkware.com/pkzip/appnote\n\nCONSTANTS\n\nconst (\n\tStore   uint16 = 0 // no compression\n\tDeflate uint16 = 8 // DEFLATE compressed\n)\n    Compression methods.\n\n\nVARIABLES\n\nvar (\n\tErrFormat       = errors.New(\"zip: not a valid zip file\")\n\tErrAlgorithm    = errors.New(\"zip: unsupported compression algorithm\")\n\tErrChecksum     = errors.New(\"zip: checksum error\")\n\tErrInsecurePath = errors.New(\"zip: insecure file path\")\n)\n\nFUNCTIONS\n\nfunc RegisterCompressor(method uint16, comp Compressor)\n    RegisterCompressor registers custom compressors for a specified method ID.\n    The common methods Store and Deflate are built in.\n\nfunc RegisterDecompressor(method uint16, dcomp Decompressor)\n    RegisterDecompressor allows custom decompressors for a specified method ID.\n    The common methods Store and Deflate are built in.\n\n\nTYPES\n\ntype Compressor func(w io.Writer) (io.WriteCloser, error)\n    A Compressor returns a new compressing writer, writing to w.\n    The WriteCloser's Close method must be used to flush pending data to w.\n    The Compressor itself must be safe to invoke from multiple goroutines\n    simultaneously, but each returned writer will be used only by one goroutine\n    at a time.\n\ntype Decompressor func(r io.Reader) io.ReadCloser\n    A Decompressor returns a new decompressing reader, reading from r. The\n    io.ReadCloser's Close method must be used to release associated resources.\n    The Decompressor itself must be safe to invoke from multiple goroutines\n    simultaneously, but each returned reader will be used only by one goroutine\n    at a time.\n\ntype File struct {\n\tFileHeader\n\n\t// Has unexported fields.\n}\n    A File is a single file in a ZIP archive. The file information is in the\n    embedded FileHeader. The file content can be accessed by calling File.Open.\n\nfunc (f *File) DataOffset() (offset int64, err error)\n    DataOffset returns the offset of the file's possibly-compressed data,\n    relative to the beginning of the zip file.\n\n    Most callers should instead use File.Open, which transparently decompresses\n    data and verifies checksums.\n\nfunc (f *File) Open() (io.ReadCloser, error)\n    Open returns a ReadCloser that provides access to the File's contents.\n    Multiple files may be read concurrently.\n\nfunc (f *File) OpenRaw() (io.Reader, error)\n    OpenRaw returns a Reader that provides access to the File's contents without\n    decompression.\n\ntype FileHeader struct {\n\t// Name is the name of the file.\n\t//\n\t// It must be a relative path, not start with a drive letter (such as \"C:\"),\n\t// and must use forward slashes instead of back slashes. A trailing slash\n\t// indicates that this file is a directory and should have no data.\n\tName string\n\n\t// Comment is any arbitrary user-defined string shorter than 64KiB.\n\tComment string\n\n\t// NonUTF8 indicates that Name and Comment are not encoded in UTF-8.\n\t//\n\t// By specification, the only other encoding permitted should be CP-437,\n\t// but historically many ZIP readers interpret Name and Comment as whatever\n\t// the system's local character encoding happens to be.\n\t//\n\t// This flag should only be set if the user intends to encode a non-portable\n\t// ZIP file for a specific localized region. Otherwise, the Writer\n\t// automatically sets the ZIP format's UTF-8 flag for valid UTF-8 strings.\n\tNonUTF8 bool\n\n\tCreatorVersion uint16\n\tReaderVersion  uint16\n\tFlags          uint16\n\n\t// Method is the compression method. If zero, Store is used.\n\tMethod uint16\n\n\t// Modified is the modified time of the file.\n\t//\n\t// When reading, an extended timestamp is preferred over the legacy MS-DOS\n\t// date field, and the offset between the times is used as the timezone.\n\t// If only the MS-DOS date is present, the timezone is assumed to be UTC.\n\t//\n\t// When writing, an extended timestamp (which is timezone-agnostic) is\n\t// always emitted. The legacy MS-DOS date field is encoded according to the\n\t// location of the Modified time.\n\tModified time.Time\n\n\t// ModifiedTime is an MS-DOS-encoded time.\n\t//\n\t// Deprecated: Use Modified instead.\n\tModifiedTime uint16\n\n\t// ModifiedDate is an MS-DOS-encoded date.\n\t//\n\t// Deprecated: Use Modified instead.\n\tModifiedDate uint16\n\n\t// CRC32 is the CRC32 checksum of the file content.\n\tCRC32 uint32\n\n\t// CompressedSize is the compressed size of the file in bytes.\n\t// If either the uncompressed or compressed size of the file\n\t// does not fit in 32 bits, CompressedSize is set to ^uint32(0).\n\t//\n\t// Deprecated: Use CompressedSize64 instead.\n\tCompressedSize uint32\n\n\t// UncompressedSize is the uncompressed size of the file in bytes.\n\t// If either the uncompressed or compressed size of the file\n\t// does not fit in 32 bits, UncompressedSize is set to ^uint32(0).\n\t//\n\t// Deprecated: Use UncompressedSize64 instead.\n\tUncompressedSize uint32\n\n\t// CompressedSize64 is the compressed size of the file in bytes.\n\tCompressedSize64 uint64\n\n\t// UncompressedSize64 is the uncompressed size of the file in bytes.\n\tUncompressedSize64 uint64\n\n\tExtra         []byte\n\tExternalAttrs uint32 // Meaning depends on CreatorVersion\n}\n    FileHeader describes a file within a ZIP file. See the ZIP specification for\n    details.\n\n[ZIP specification]: https://support.pkware.com/pkzip/appnote\n\nfunc FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)\n    FileInfoHeader creates a partially-populated FileHeader from an fs.FileInfo.\n    Because fs.FileInfo's Name method returns only the base name of the file\n    it describes, it may be necessary to modify the Name field of the returned\n    header to provide the full path name of the file. If compression is desired,\n    callers should set the FileHeader.Method field; it is unset by default.\n\nfunc (h *FileHeader) FileInfo() fs.FileInfo\n    FileInfo returns an fs.FileInfo for the FileHeader.\n\nfunc (h *FileHeader) ModTime() time.Time\n    ModTime returns the modification time in UTC using the legacy [ModifiedDate]\n    and [ModifiedTime] fields.\n\n    Deprecated: Use [Modified] instead.\n\nfunc (h *FileHeader) Mode() (mode fs.FileMode)\n    Mode returns the permission and mode bits for the FileHeader.\n\nfunc (h *FileHeader) SetModTime(t time.Time)\n    SetModTime sets the [Modified], [ModifiedTime], and [ModifiedDate] fields to\n    the given time in UTC.\n\n    Deprecated: Use [Modified] instead.\n\nfunc (h *FileHeader) SetMode(mode fs.FileMode)\n    SetMode changes the permission and mode bits for the FileHeader.\n\ntype ReadCloser struct {\n\tReader\n\t// Has unexported fields.\n}\n    A ReadCloser is a Reader that must be closed when no longer needed.\n\nfunc OpenReader(name string) (*ReadCloser, error)\n    OpenReader will open the Zip file specified by name and return a ReadCloser.\n\n    If any file inside the archive uses a non-local name (as defined by\n    filepath.IsLocal) or a name containing backslashes and the GODEBUG\n    environment variable contains `zipinsecurepath=0`, OpenReader returns the\n    reader with an ErrInsecurePath error. A future version of Go may introduce\n    this behavior by default. Programs that want to accept non-local names can\n    ignore the ErrInsecurePath error and use the returned reader.\n\nfunc (rc *ReadCloser) Close() error\n    Close closes the Zip file, rendering it unusable for I/O.\n\ntype Reader struct {\n\tFile    []*File\n\tComment string\n\n\t// Has unexported fields.\n}\n    A Reader serves content from a ZIP archive.\n\nfunc NewReader(r io.ReaderAt, size int64) (*Reader, error)\n    NewReader returns a new Reader reading from r, which is assumed to have the\n    given size in bytes.\n\n    If any file inside the archive uses a non-local name (as defined by\n    filepath.IsLocal) or a name containing backslashes and the GODEBUG\n    environment variable contains `zipinsecurepath=0`, NewReader returns the\n    reader with an ErrInsecurePath error. A future version of Go may introduce\n    this behavior by default. Programs that want to accept non-local names can\n    ignore the ErrInsecurePath error and use the returned reader.\n\nfunc (r *Reader) Open(name string) (fs.File, error)\n    Open opens the named file in the ZIP archive, using the semantics of\n    fs.FS.Open: paths are always slash separated, with no leading / or ../\n    elements.\n\nfunc (r *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)\n    RegisterDecompressor registers or overrides a custom decompressor for a\n    specific method ID. If a decompressor for a given method is not found,\n    Reader will default to looking up the decompressor at the package level.\n\ntype Writer struct {\n\t// Has unexported fields.\n}\n    Writer implements a zip file writer.\n\nfunc NewWriter(w io.Writer) *Writer\n    NewWriter returns a new Writer writing a zip file to w.\n\nfunc (w *Writer) AddFS(fsys fs.FS) error\n    AddFS adds the files from fs.FS to the archive. It walks the directory tree\n    starting at the root of the filesystem adding each file to the zip using\n    deflate while maintaining the directory structure.\n\nfunc (w *Writer) Close() error\n    Close finishes writing the zip file by writing the central directory.\n    It does not close the underlying writer.\n\nfunc (w *Writer) Copy(f *File) error\n    Copy copies the file f (obtained from a Reader) into w. It copies the raw\n    form directly bypassing decompression, compression, and validation.\n\nfunc (w *Writer) Create(name string) (io.Writer, error)\n    Create adds a file to the zip file using the provided name. It returns a\n    Writer to which the file contents should be written. The file contents will\n    be compressed using the Deflate method. The name must be a relative path:\n    it must not start with a drive letter (e.g. C:) or leading slash, and only\n    forward slashes are allowed. To create a directory instead of a file,\n    add a trailing slash to the name. Duplicate names will not overwrite\n    previous entries and are appended to the zip file. The file's contents\n    must be written to the io.Writer before the next call to Writer.Create,\n    Writer.CreateHeader, or Writer.Close.\n\nfunc (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)\n    CreateHeader adds a file to the zip archive using the provided FileHeader\n    for the file metadata. Writer takes ownership of fh and may mutate its\n    fields. The caller must not modify fh after calling Writer.CreateHeader.\n\n    This returns a Writer to which the file contents should be written.\n    The file's contents must be written to the io.Writer before the next call to\n    Writer.Create, Writer.CreateHeader, Writer.CreateRaw, or Writer.Close.\n\nfunc (w *Writer) CreateRaw(fh *FileHeader) (io.Writer, error)\n    CreateRaw adds a file to the zip archive using the provided FileHeader\n    and returns a Writer to which the file contents should be written.\n    The file's contents must be written to the io.Writer before the next call to\n    Writer.Create, Writer.CreateHeader, Writer.CreateRaw, or Writer.Close.\n\n    In contrast to Writer.CreateHeader, the bytes passed to Writer are not\n    compressed.\n\n    CreateRaw's argument is stored in w. If the argument is a pointer to the\n    embedded FileHeader in a File obtained from a Reader created from in-memory\n    data, then w will refer to all of that memory.\n\nfunc (w *Writer) Flush() error\n    Flush flushes any buffered data to the underlying writer. Calling Flush is\n    not normally necessary; calling Close is sufficient.\n\nfunc (w *Writer) RegisterCompressor(method uint16, comp Compressor)\n    RegisterCompressor registers or overrides a custom compressor for a specific\n    method ID. If a compressor for a given method is not found, Writer will\n    default to looking up the compressor at the package level.\n\nfunc (w *Writer) SetComment(comment string) error\n    SetComment sets the end-of-central-directory comment field. It can only be\n    called before Writer.Close.\n\nfunc (w *Writer) SetOffset(n int64)\n    SetOffset sets the offset of the beginning of the zip data within the\n    underlying writer. It should be used when the zip data is appended to an\n    existing file, such as a binary executable. It must be called before any\n    data is written.\n\n"}, {"path": "stdlib/crypto-internal-fips140-tls12.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-tls12", "content": "package tls12 // import \"crypto/internal/fips140/tls12\"\n\n\nFUNCTIONS\n\nfunc MasterSecret[H hash.Hash](hash func() H, preMasterSecret, transcript []byte) []byte\n    MasterSecret implements the TLS 1.2 extended master secret derivation,\n    as defined in RFC 7627 and allowed by SP 800-135, Revision 1, Section 4.2.2.\n\nfunc PRF[H hash.Hash](hash func() H, secret []byte, label string, seed []byte, keyLen int) []byte\n    PRF implements the TLS 1.2 pseudo-random function, as defined in RFC 5246,\n    Section 5 and allowed by SP 800-135, Revision 1, Section 4.2.2.\n\n"}, {"path": "stdlib/sync.md", "category": "stdlib", "name": "stdlib/sync", "content": "package sync // import \"sync\"\n\nPackage sync provides basic synchronization primitives such as mutual exclusion\nlocks. Other than the Once and WaitGroup types, most are intended for use by\nlow-level library routines. Higher-level synchronization is better done via\nchannels and communication.\n\nValues containing the types defined in this package should not be copied.\n\nFUNCTIONS\n\nfunc OnceFunc(f func()) func()\n    OnceFunc returns a function that invokes f only once. The returned function\n    may be called concurrently.\n\n    If f panics, the returned function will panic with the same value on every\n    call.\n\nfunc OnceValue[T any](f func() T) func() T\n    OnceValue returns a function that invokes f only once and returns the value\n    returned by f. The returned function may be called concurrently.\n\n    If f panics, the returned function will panic with the same value on every\n    call.\n\nfunc OnceValues[T1, T2 any](f func() (T1, T2)) func() (T1, T2)\n    OnceValues returns a function that invokes f only once and returns the\n    values returned by f. The returned function may be called concurrently.\n\n    If f panics, the returned function will panic with the same value on every\n    call.\n\n\nTYPES\n\ntype Cond struct {\n\n\t// L is held while observing or changing the condition\n\tL Locker\n\n\t// Has unexported fields.\n}\n    Cond implements a condition variable, a rendezvous point for goroutines\n    waiting for or announcing the occurrence of an event.\n\n    Each Cond has an associated Locker L (often a *Mutex or *RWMutex), which\n    must be held when changing the condition and when calling the Cond.Wait\n    method.\n\n    A Cond must not be copied after first use.\n\n    In the terminology of the Go memory model, Cond arranges that a call to\n    Cond.Broadcast or Cond.Signal \u201csynchronizes before\u201d any Wait call that it\n    unblocks.\n\n    For many simple use cases, users will be better off using channels than a\n    Cond (Broadcast corresponds to closing a channel, and Signal corresponds to\n    sending on a channel).\n\n    For more on replacements for sync.Cond, see Roberto Clapis's series on\n    advanced concurrency patterns, as well as Bryan Mills's talk on concurrency\n    patterns.\n\n[the Go memory model]: https://go.dev/ref/mem\n[Roberto Clapis's series on advanced concurrency patterns]: https://blogtitle.github.io/categories/concurrency/\n[Bryan Mills's talk on concurrency patterns]: https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view\n\nfunc NewCond(l Locker) *Cond\n    NewCond returns a new Cond with Locker l.\n\nfunc (c *Cond) Broadcast()\n    Broadcast wakes all goroutines waiting on c.\n\n    It is allowed but not required for the caller to hold c.L during the call.\n\nfunc (c *Cond) Signal()\n    Signal wakes one goroutine waiting on c, if there is any.\n\n    It is allowed but not required for the caller to hold c.L during the call.\n\n    Signal() does not affect goroutine scheduling priority; if other goroutines\n    are attempting to lock c.L, they may be awoken before a \"waiting\" goroutine.\n\nfunc (c *Cond) Wait()\n    Wait atomically unlocks c.L and suspends execution of the calling goroutine.\n    After later resuming execution, Wait locks c.L before returning. Unlike\n    in other systems, Wait cannot return unless awoken by Cond.Broadcast or\n    Cond.Signal.\n\n    Because c.L is not locked while Wait is waiting, the caller typically cannot\n    assume that the condition is true when Wait returns. Instead, the caller\n    should Wait in a loop:\n\n        c.L.Lock()\n        for !condition() {\n            c.Wait()\n        }\n        ... make use of condition ...\n        c.L.Unlock()\n\ntype Locker interface {\n\tLock()\n\tUnlock()\n}\n    A Locker represents an object that can be locked and unlocked.\n\ntype Map struct {\n\t// Has unexported fields.\n}\n    Map is like a Go map[any]any but is safe for concurrent use by multiple\n    goroutines without additional locking or coordination. Loads, stores,\n    and deletes run in amortized constant time.\n\n    The Map type is specialized. Most code should use a plain Go map instead,\n    with separate locking or coordination, for better type safety and to make it\n    easier to maintain other invariants along with the map content.\n\n    The Map type is optimized for two common use cases: (1) when the entry for\n    a given key is only ever written once but read many times, as in caches\n    that only grow, or (2) when multiple goroutines read, write, and overwrite\n    entries for disjoint sets of keys. In these two cases, use of a Map may\n    significantly reduce lock contention compared to a Go map paired with a\n    separate Mutex or RWMutex.\n\n    The zero Map is empty and ready for use. A Map must not be copied after\n    first use.\n\n    In the terminology of the Go memory model, Map arranges that a write\n    operation \u201csynchronizes before\u201d any read operation that observes the effect\n    of the write, where read and write operations are defined as follows.\n    Map.Load, Map.LoadAndDelete, Map.LoadOrStore, Map.Swap, Map.CompareAndSwap,\n    and Map.CompareAndDelete are read operations; Map.Delete, Map.LoadAndDelete,\n    Map.Store, and Map.Swap are write operations; Map.LoadOrStore is a write\n    operation when it returns loaded set to false; Map.CompareAndSwap is a write\n    operation when it returns swapped set to true; and Map.CompareAndDelete is a\n    write operation when it returns deleted set to true.\n\n[the Go memory model]: https://go.dev/ref/mem\n\nfunc (m *Map) Clear()\n    Clear deletes all the entries, resulting in an empty Map.\n\nfunc (m *Map) CompareAndDelete(key, old any) (deleted bool)\n    CompareAndDelete deletes the entry for key if its value is equal to old.\n    The old value must be of a comparable type.\n\n    If there is no current value for key in the map, CompareAndDelete returns\n    false (even if the old value is the nil interface value).\n\nfunc (m *Map) CompareAndSwap(key, old, new any) (swapped bool)\n    CompareAndSwap swaps the old and new values for key if the value stored in\n    the map is equal to old. The old value must be of a comparable type.\n\nfunc (m *Map) Delete(key any)\n    Delete deletes the value for a key. If the key is not in the map, Delete\n    does nothing.\n\nfunc (m *Map) Load(key any) (value any, ok bool)\n    Load returns the value stored in the map for a key, or nil if no value is\n    present. The ok result indicates whether value was found in the map.\n\nfunc (m *Map) LoadAndDelete(key any) (value any, loaded bool)\n    LoadAndDelete deletes the value for a key, returning the previous value if\n    any. The loaded result reports whether the key was present.\n\nfunc (m *Map) LoadOrStore(key, value any) (actual any, loaded bool)\n    LoadOrStore returns the existing value for the key if present. Otherwise,\n    it stores and returns the given value. The loaded result is true if the\n    value was loaded, false if stored.\n\nfunc (m *Map) Range(f func(key, value any) bool)\n    Range calls f sequentially for each key and value present in the map.\n    If f returns false, range stops the iteration.\n\n    Range does not necessarily correspond to any consistent snapshot of the\n    Map's contents: no key will be visited more than once, but if the value\n    for any key is stored or deleted concurrently (including by f), Range may\n    reflect any mapping for that key from any point during the Range call.\n    Range does not block other methods on the receiver; even f itself may call\n    any method on m.\n\n    Range may be O(N) with the number of elements in the map even if f returns\n    false after a constant number of calls.\n\nfunc (m *Map) Store(key, value any)\n    Store sets the value for a key.\n\nfunc (m *Map) Swap(key, value any) (previous any, loaded bool)\n    Swap swaps the value for a key and returns the previous value if any.\n    The loaded result reports whether the key was present.\n\ntype Mutex struct {\n\t// Has unexported fields.\n}\n    A Mutex is a mutual exclusion lock. The zero value for a Mutex is an\n    unlocked mutex.\n\n    A Mutex must not be copied after first use.\n\n    In the terminology of the Go memory model, the n'th call to Mutex.Unlock\n    \u201csynchronizes before\u201d the m'th call to Mutex.Lock for any n < m.\n    A successful call to Mutex.TryLock is equivalent to a call to Lock. A failed\n    call to TryLock does not establish any \u201csynchronizes before\u201d relation at\n    all.\n\n[the Go memory model]: https://go.dev/ref/mem\n\nfunc (m *Mutex) Lock()\n    Lock locks m. If the lock is already in use, the calling goroutine blocks\n    until the mutex is available.\n\nfunc (m *Mutex) TryLock() bool\n    TryLock tries to lock m and reports whether it succeeded.\n\n    Note that while correct uses of TryLock do exist, they are rare, and use of\n    TryLock is often a sign of a deeper problem in a particular use of mutexes.\n\nfunc (m *Mutex) Unlock()\n    Unlock unlocks m. It is a run-time error if m is not locked on entry to\n    Unlock.\n\n    A locked Mutex is not associated with a particular goroutine. It is allowed\n    for one goroutine to lock a Mutex and then arrange for another goroutine to\n    unlock it.\n\ntype Once struct {\n\t// Has unexported fields.\n}\n    Once is an object that will perform exactly one action.\n\n    A Once must not be copied after first use.\n\n    In the terminology of the Go memory model, the return from f \u201csynchronizes\n    before\u201d the return from any call of once.Do(f).\n\n[the Go memory model]: https://go.dev/ref/mem\n\nfunc (o *Once) Do(f func())\n    Do calls the function f if and only if Do is being called for the first time\n    for this instance of Once. In other words, given\n\n        var once Once\n\n    if once.Do(f) is called multiple times, only the first call will invoke f,\n    even if f has a different value in each invocation. A new instance of Once\n    is required for each function to execute.\n\n    Do is intended for initialization that must be run exactly once. Since f\n    is niladic, it may be necessary to use a function literal to capture the\n    arguments to a function to be invoked by Do:\n\n        config.once.Do(func() { config.init(filename) })\n\n    Because no call to Do returns until the one call to f returns, if f causes\n    Do to be called, it will deadlock.\n\n    If f panics, Do considers it to have returned; future calls of Do return\n    without calling f.\n\ntype Pool struct {\n\n\t// New optionally specifies a function to generate\n\t// a value when Get would otherwise return nil.\n\t// It may not be changed concurrently with calls to Get.\n\tNew func() any\n\t// Has unexported fields.\n}\n    A Pool is a set of temporary objects that may be individually saved and\n    retrieved.\n\n    Any item stored in the Pool may be removed automatically at any time without\n    notification. If the Pool holds the only reference when this happens,\n    the item might be deallocated.\n\n    A Pool is safe for use by multiple goroutines simultaneously.\n\n    Pool's purpose is to cache allocated but unused items for later reuse,\n    relieving pressure on the garbage collector. That is, it makes it easy to\n    build efficient, thread-safe free lists. However, it is not suitable for all\n    free lists.\n\n    An appropriate use of a Pool is to manage a group of temporary items\n    silently shared among and potentially reused by concurrent independent\n    clients of a package. Pool provides a way to amortize allocation overhead\n    across many clients.\n\n    An example of good use of a Pool is in the fmt package, which maintains\n    a dynamically-sized store of temporary output buffers. The store scales\n    under load (when many goroutines are actively printing) and shrinks when\n    quiescent.\n\n    On the other hand, a free list maintained as part of a short-lived object is\n    not a suitable use for a Pool, since the overhead does not amortize well in\n    that scenario. It is more efficient to have such objects implement their own\n    free list.\n\n    A Pool must not be copied after first use.\n\n    In the terminology of the Go memory model, a call to Put(x) \u201csynchronizes\n    before\u201d a call to Pool.Get returning that same value x. Similarly, a call\n    to New returning x \u201csynchronizes before\u201d a call to Get returning that same\n    value x.\n\n[the Go memory model]: https://go.dev/ref/mem\n\nfunc (p *Pool) Get() any\n    Get selects an arbitrary item from the Pool, removes it from the Pool,\n    and returns it to the caller. Get may choose to ignore the pool and treat\n    it as empty. Callers should not assume any relation between values passed to\n    Pool.Put and the values returned by Get.\n\n    If Get would otherwise return nil and p.New is non-nil, Get returns the\n    result of calling p.New.\n\nfunc (p *Pool) Put(x any)\n    Put adds x to the pool.\n\ntype RWMutex struct {\n\t// Has unexported fields.\n}\n    A RWMutex is a reader/writer mutual exclusion lock. The lock can be held\n    by an arbitrary number of readers or a single writer. The zero value for a\n    RWMutex is an unlocked mutex.\n\n    A RWMutex must not be copied after first use.\n\n    If any goroutine calls RWMutex.Lock while the lock is already held by one or\n    more readers, concurrent calls to RWMutex.RLock will block until the writer\n    has acquired (and released) the lock, to ensure that the lock eventually\n    becomes available to the writer. Note that this prohibits recursive\n    read-locking. A RWMutex.RLock cannot be upgraded into a RWMutex.Lock,\n    nor can a RWMutex.Lock be downgraded into a RWMutex.RLock.\n\n    In the terminology of the Go memory model, the n'th call to RWMutex.Unlock\n    \u201csynchronizes before\u201d the m'th call to Lock for any n < m, just as for\n    Mutex. For any call to RLock, there exists an n such that the n'th call to\n    Unlock \u201csynchronizes before\u201d that call to RLock, and the corresponding call\n    to RWMutex.RUnlock \u201csynchronizes before\u201d the n+1'th call to Lock.\n\n[the Go memory model]: https://go.dev/ref/mem\n\nfunc (rw *RWMutex) Lock()\n    Lock locks rw for writing. If the lock is already locked for reading or\n    writing, Lock blocks until the lock is available.\n\nfunc (rw *RWMutex) RLock()\n    RLock locks rw for reading.\n\n    It should not be used for recursive read locking; a blocked Lock call\n    excludes new readers from acquiring the lock. See the documentation on the\n    RWMutex type.\n\nfunc (rw *RWMutex) RLocker() Locker\n    RLocker returns a Locker interface that implements the [Locker.Lock] and\n    [Locker.Unlock] methods by calling rw.RLock and rw.RUnlock.\n\nfunc (rw *RWMutex) RUnlock()\n    RUnlock undoes a single RWMutex.RLock call; it does not affect other\n    simultaneous readers. It is a run-time error if rw is not locked for reading\n    on entry to RUnlock.\n\nfunc (rw *RWMutex) TryLock() bool\n    TryLock tries to lock rw for writing and reports whether it succeeded.\n\n    Note that while correct uses of TryLock do exist, they are rare, and use of\n    TryLock is often a sign of a deeper problem in a particular use of mutexes.\n\nfunc (rw *RWMutex) TryRLock() bool\n    TryRLock tries to lock rw for reading and reports whether it succeeded.\n\n    Note that while correct uses of TryRLock do exist, they are rare, and use of\n    TryRLock is often a sign of a deeper problem in a particular use of mutexes.\n\nfunc (rw *RWMutex) Unlock()\n    Unlock unlocks rw for writing. It is a run-time error if rw is not locked\n    for writing on entry to Unlock.\n\n    As with Mutexes, a locked RWMutex is not associated with a particular\n    goroutine. One goroutine may RWMutex.RLock (RWMutex.Lock) a RWMutex and then\n    arrange for another goroutine to RWMutex.RUnlock (RWMutex.Unlock) it.\n\ntype WaitGroup struct {\n\t// Has unexported fields.\n}\n    A WaitGroup is a counting semaphore typically used to wait for a group of\n    goroutines or tasks to finish.\n\n    Typically, a main goroutine will start tasks, each in a new goroutine,\n    by calling WaitGroup.Go and then wait for all tasks to complete by calling\n    WaitGroup.Wait. For example:\n\n        var wg sync.WaitGroup\n        wg.Go(task1)\n        wg.Go(task2)\n        wg.Wait()\n\n    A WaitGroup may also be used for tracking tasks without using Go to start\n    new goroutines by using WaitGroup.Add and WaitGroup.Done.\n\n    The previous example can be rewritten using explicitly created goroutines\n    along with Add and Done:\n\n        var wg sync.WaitGroup\n        wg.Add(1)\n        go func() {\n        \tdefer wg.Done()\n        \ttask1()\n        }()\n        wg.Add(1)\n        go func() {\n        \tdefer wg.Done()\n        \ttask2()\n        }()\n        wg.Wait()\n\n    This pattern is common in code that predates WaitGroup.Go.\n\n    A WaitGroup must not be copied after first use.\n\nfunc (wg *WaitGroup) Add(delta int)\n    Add adds delta, which may be negative, to the WaitGroup task counter. If the\n    counter becomes zero, all goroutines blocked on WaitGroup.Wait are released.\n    If the counter goes negative, Add panics.\n\n    Callers should prefer WaitGroup.Go.\n\n    Note that calls with a positive delta that occur when the counter is\n    zero must happen before a Wait. Calls with a negative delta, or calls\n    with a positive delta that start when the counter is greater than zero,\n    may happen at any time. Typically this means the calls to Add should execute\n    before the statement creating the goroutine or other event to be waited for.\n    If a WaitGroup is reused to wait for several independent sets of events,\n    new Add calls must happen after all previous Wait calls have returned.\n    See the WaitGroup example.\n\nfunc (wg *WaitGroup) Done()\n    Done decrements the WaitGroup task counter by one. It is equivalent to\n    Add(-1).\n\n    Callers should prefer WaitGroup.Go.\n\n    In the terminology of the Go memory model, a call to Done \"synchronizes\n    before\" the return of any Wait call that it unblocks.\n\n[the Go memory model]: https://go.dev/ref/mem\n\nfunc (wg *WaitGroup) Go(f func())\n    Go calls f in a new goroutine and adds that task to the WaitGroup. When f\n    returns, the task is removed from the WaitGroup.\n\n    The function f must not panic.\n\n    If the WaitGroup is empty, Go must happen before a WaitGroup.Wait.\n    Typically, this simply means Go is called to start tasks before Wait is\n    called. If the WaitGroup is not empty, Go may happen at any time. This means\n    a goroutine started by Go may itself call Go. If a WaitGroup is reused to\n    wait for several independent sets of tasks, new Go calls must happen after\n    all previous Wait calls have returned.\n\n    In the terminology of the Go memory model, the return from f \"synchronizes\n    before\" the return of any Wait call that it unblocks.\n\n[the Go memory model]: https://go.dev/ref/mem\n\nfunc (wg *WaitGroup) Wait()\n    Wait blocks until the WaitGroup task counter is zero.\n\n"}, {"path": "stdlib/crypto-internal-fips140-check.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-check", "content": "package check // import \"crypto/internal/fips140/check\"\n\nPackage check implements the FIPS 140 load-time code+data verification.\nEvery FIPS package providing cryptographic functionality except hmac and sha256\nmust import crypto/internal/fips140/check, so that the verification happens\nbefore initialization of package global variables. The hmac and sha256 packages\nare used by this package, so they cannot import it. Instead, those packages\nmust be careful not to change global variables during init. (If necessary,\nwe could have check call a PostCheck function in those packages after the check\nhas completed.)\n\nVARIABLES\n\nvar Linkinfo struct {\n\tMagic [16]byte\n\tSum   [32]byte\n\tSelf  uintptr\n\tSects [4]struct {\n\t\t// Note: These must be unsafe.Pointer, not uintptr,\n\t\t// or else checkptr panics about turning uintptrs\n\t\t// into pointers into the data segment during\n\t\t// go test -race.\n\t\tStart unsafe.Pointer\n\t\tEnd   unsafe.Pointer\n\t}\n}\n    Linkinfo holds the go:fipsinfo symbol prepared by the linker. See\n    cmd/link/internal/ld/fips.go for details.\n\nvar Verified bool\n    Verified is set when verification succeeded. It can be expected to always be\n    true when fips140.Enabled is true, or init would have panicked.\n\n"}, {"path": "stdlib/internal-txtar.md", "category": "stdlib", "name": "stdlib/internal-txtar", "content": "package txtar // import \"internal/txtar\"\n\nPackage txtar implements a trivial text-based file archive format.\n\nThe goals for the format are:\n\n  - be trivial enough to create and edit by hand.\n  - be able to store trees of text files describing go command test cases.\n  - diff nicely in git history and code reviews.\n\nNon-goals include being a completely general archive format, storing binary\ndata, storing file modes, storing special files like symbolic links, and so on.\n\n# Txtar format\n\nA txtar archive is zero or more comment lines and then a sequence of file\nentries. Each file entry begins with a file marker line of the form \"-- FILENAME\n--\" and is followed by zero or more file content lines making up the file data.\nThe comment or file content ends at the next file marker line. The file marker\nline must begin with the three-byte sequence \"-- \" and end with the three-byte\nsequence \" --\", but the enclosed file name can be surrounding by additional\nwhite space, all of which is stripped.\n\nIf the txtar file is missing a trailing newline on the final line, parsers\nshould consider a final newline to be present anyway.\n\nThere are no possible syntax errors in a txtar archive.\n\nFUNCTIONS\n\nfunc Format(a *Archive) []byte\n    Format returns the serialized form of an Archive. It is assumed that the\n    Archive data structure is well-formed: a.Comment and all a.File[i].Data\n    contain no file marker lines, and all a.File[i].Name is non-empty.\n\n\nTYPES\n\ntype Archive struct {\n\tComment []byte\n\tFiles   []File\n}\n    An Archive is a collection of files.\n\nfunc Parse(data []byte) *Archive\n    Parse parses the serialized form of an Archive. The returned Archive holds\n    slices of data.\n\nfunc ParseFile(file string) (*Archive, error)\n    ParseFile parses the named file as an archive.\n\ntype File struct {\n\tName string // name of file (\"foo/bar.txt\")\n\tData []byte // text content of file\n}\n    A File is a single file in an archive.\n\n"}, {"path": "stdlib/debug-gosym.md", "category": "stdlib", "name": "stdlib/debug-gosym", "content": "package gosym // import \"debug/gosym\"\n\nPackage gosym implements access to the Go symbol and line number tables embedded\nin Go binaries generated by the gc compilers.\n\nTYPES\n\ntype DecodingError struct {\n\t// Has unexported fields.\n}\n    DecodingError represents an error during the decoding of the symbol table.\n\nfunc (e *DecodingError) Error() string\n\ntype Func struct {\n\tEntry uint64\n\t*Sym\n\tEnd       uint64\n\tParams    []*Sym // nil for Go 1.3 and later binaries\n\tLocals    []*Sym // nil for Go 1.3 and later binaries\n\tFrameSize int\n\tLineTable *LineTable\n\tObj       *Obj\n}\n    A Func collects information about a single function.\n\ntype LineTable struct {\n\tData []byte\n\tPC   uint64\n\tLine int\n\n\t// Has unexported fields.\n}\n    A LineTable is a data structure mapping program counters to line numbers.\n\n    In Go 1.1 and earlier, each function (represented by a Func) had its own\n    LineTable, and the line number corresponded to a numbering of all source\n    lines in the program, across all files. That absolute line number would then\n    have to be converted separately to a file name and line number within the\n    file.\n\n    In Go 1.2, the format of the data changed so that there is a single\n    LineTable for the entire program, shared by all Funcs, and there are no\n    absolute line numbers, just line numbers within specific files.\n\n    For the most part, LineTable's methods should be treated as an internal\n    detail of the package; callers should use the methods on Table instead.\n\nfunc NewLineTable(data []byte, text uint64) *LineTable\n    NewLineTable returns a new PC/line table corresponding to the encoded data.\n    Text must be the start address of the corresponding text segment, with the\n    exact value stored in the 'runtime.text' symbol. This value may differ from\n    the start address of the text segment if binary was built with cgo enabled.\n\nfunc (t *LineTable) LineToPC(line int, maxpc uint64) uint64\n    LineToPC returns the program counter for the given line number, considering\n    only program counters before maxpc.\n\n    Deprecated: Use Table's LineToPC method instead.\n\nfunc (t *LineTable) PCToLine(pc uint64) int\n    PCToLine returns the line number for the given program counter.\n\n    Deprecated: Use Table's PCToLine method instead.\n\ntype Obj struct {\n\t// Funcs is a list of functions in the Obj.\n\tFuncs []Func\n\n\t// In Go 1.1 and earlier, Paths is a list of symbols corresponding\n\t// to the source file names that produced the Obj.\n\t// In Go 1.2, Paths is nil.\n\t// Use the keys of Table.Files to obtain a list of source files.\n\tPaths []Sym // meta\n}\n    An Obj represents a collection of functions in a symbol table.\n\n    The exact method of division of a binary into separate Objs is an internal\n    detail of the symbol table format.\n\n    In early versions of Go each source file became a different Obj.\n\n    In Go 1 and Go 1.1, each package produced one Obj for all Go sources and one\n    Obj per C source file.\n\n    In Go 1.2, there is a single Obj for the entire program.\n\ntype Sym struct {\n\tValue  uint64\n\tType   byte\n\tName   string\n\tGoType uint64\n\t// If this symbol is a function symbol, the corresponding Func\n\tFunc *Func\n\n\t// Has unexported fields.\n}\n    A Sym represents a single symbol table entry.\n\nfunc (s *Sym) BaseName() string\n    BaseName returns the symbol name without the package or receiver name.\n\nfunc (s *Sym) PackageName() string\n    PackageName returns the package part of the symbol name, or the empty string\n    if there is none.\n\nfunc (s *Sym) ReceiverName() string\n    ReceiverName returns the receiver type name of this symbol, or the empty\n    string if there is none. A receiver name is only detected in the case that\n    s.Name is fully-specified with a package name.\n\nfunc (s *Sym) Static() bool\n    Static reports whether this symbol is static (not visible outside its file).\n\ntype Table struct {\n\tSyms  []Sym // nil for Go 1.3 and later binaries\n\tFuncs []Func\n\tFiles map[string]*Obj // for Go 1.2 and later all files map to one Obj\n\tObjs  []Obj           // for Go 1.2 and later only one Obj in slice\n\n\t// Has unexported fields.\n}\n    Table represents a Go symbol table. It stores all of the symbols decoded\n    from the program and provides methods to translate between symbols, names,\n    and addresses.\n\nfunc NewTable(symtab []byte, pcln *LineTable) (*Table, error)\n    NewTable decodes the Go symbol table (the \".gosymtab\" section in ELF),\n    returning an in-memory representation. Starting with Go 1.3, the Go symbol\n    table no longer includes symbol data.\n\nfunc (t *Table) LineToPC(file string, line int) (pc uint64, fn *Func, err error)\n    LineToPC looks up the first program counter on the given line in the named\n    file. It returns UnknownFileError or UnknownLineError if there is an error\n    looking up this line.\n\nfunc (t *Table) LookupFunc(name string) *Func\n    LookupFunc returns the text, data, or bss symbol with the given name,\n    or nil if no such symbol is found.\n\nfunc (t *Table) LookupSym(name string) *Sym\n    LookupSym returns the text, data, or bss symbol with the given name,\n    or nil if no such symbol is found.\n\nfunc (t *Table) PCToFunc(pc uint64) *Func\n    PCToFunc returns the function containing the program counter pc, or nil if\n    there is no such function.\n\nfunc (t *Table) PCToLine(pc uint64) (file string, line int, fn *Func)\n    PCToLine looks up line number information for a program counter. If there is\n    no information, it returns fn == nil.\n\nfunc (t *Table) SymByAddr(addr uint64) *Sym\n    SymByAddr returns the text, data, or bss symbol starting at the given\n    address.\n\ntype UnknownFileError string\n    UnknownFileError represents a failure to find the specific file in the\n    symbol table.\n\nfunc (e UnknownFileError) Error() string\n\ntype UnknownLineError struct {\n\tFile string\n\tLine int\n}\n    UnknownLineError represents a failure to map a line to a program counter,\n    either because the line is beyond the bounds of the file or because there is\n    no code on the given line.\n\nfunc (e *UnknownLineError) Error() string\n\n"}, {"path": "stdlib/go-build-constraint.md", "category": "stdlib", "name": "stdlib/go-build-constraint", "content": "package constraint // import \"go/build/constraint\"\n\nPackage constraint implements parsing and evaluation of build constraint lines.\nSee https://golang.org/cmd/go/#hdr-Build_constraints for documentation about\nbuild constraints themselves.\n\nThis package parses both the original \u201c// +build\u201d syntax and the \u201c//go:build\u201d\nsyntax that was added in Go 1.17. See https://golang.org/design/draft-gobuild\nfor details about the \u201c//go:build\u201d syntax.\n\nFUNCTIONS\n\nfunc GoVersion(x Expr) string\n    GoVersion returns the minimum Go version implied by a given build\n    expression. If the expression can be satisfied without any Go version tags,\n    GoVersion returns an empty string.\n\n    For example:\n\n        GoVersion(linux && go1.22) = \"go1.22\"\n        GoVersion((linux && go1.22) || (windows && go1.20)) = \"go1.20\" => go1.20\n        GoVersion(linux) = \"\"\n        GoVersion(linux || (windows && go1.22)) = \"\"\n        GoVersion(!go1.22) = \"\"\n\n    GoVersion assumes that any tag or negated tag may independently be true,\n    so that its analysis can be purely structural, without SAT solving.\n    \u201cImpossible\u201d subexpressions may therefore affect the result.\n\n    For example:\n\n        GoVersion((linux && !linux && go1.20) || go1.21) = \"go1.20\"\n\nfunc IsGoBuild(line string) bool\n    IsGoBuild reports whether the line of text is a \u201c//go:build\u201d constraint. It\n    only checks the prefix of the text, not that the expression itself parses.\n\nfunc IsPlusBuild(line string) bool\n    IsPlusBuild reports whether the line of text is a \u201c// +build\u201d constraint. It\n    only checks the prefix of the text, not that the expression itself parses.\n\nfunc PlusBuildLines(x Expr) ([]string, error)\n    PlusBuildLines returns a sequence of \u201c// +build\u201d lines that evaluate to the\n    build expression x. If the expression is too complex to convert directly to\n    \u201c// +build\u201d lines, PlusBuildLines returns an error.\n\n\nTYPES\n\ntype AndExpr struct {\n\tX, Y Expr\n}\n    An AndExpr represents the expression X && Y.\n\nfunc (x *AndExpr) Eval(ok func(tag string) bool) bool\n\nfunc (x *AndExpr) String() string\n\ntype Expr interface {\n\t// String returns the string form of the expression,\n\t// using the boolean syntax used in //go:build lines.\n\tString() string\n\n\t// Eval reports whether the expression evaluates to true.\n\t// It calls ok(tag) as needed to find out whether a given build tag\n\t// is satisfied by the current build configuration.\n\tEval(ok func(tag string) bool) bool\n\n\t// Has unexported methods.\n}\n    An Expr is a build tag constraint expression. The underlying concrete type\n    is *AndExpr, *OrExpr, *NotExpr, or *TagExpr.\n\nfunc Parse(line string) (Expr, error)\n    Parse parses a single build constraint line of the form \u201c//go:build ...\u201d or\n    \u201c// +build ...\u201d and returns the corresponding boolean expression.\n\ntype NotExpr struct {\n\tX Expr\n}\n    A NotExpr represents the expression !X (the negation of X).\n\nfunc (x *NotExpr) Eval(ok func(tag string) bool) bool\n\nfunc (x *NotExpr) String() string\n\ntype OrExpr struct {\n\tX, Y Expr\n}\n    An OrExpr represents the expression X || Y.\n\nfunc (x *OrExpr) Eval(ok func(tag string) bool) bool\n\nfunc (x *OrExpr) String() string\n\ntype SyntaxError struct {\n\tOffset int    // byte offset in input where error was detected\n\tErr    string // description of error\n}\n    A SyntaxError reports a syntax error in a parsed build expression.\n\nfunc (e *SyntaxError) Error() string\n\ntype TagExpr struct {\n\tTag string // for example, \u201clinux\u201d or \u201ccgo\u201d\n}\n    A TagExpr is an Expr for the single tag Tag.\n\nfunc (x *TagExpr) Eval(ok func(tag string) bool) bool\n\nfunc (x *TagExpr) String() string\n\n"}, {"path": "stdlib/compress-flate.md", "category": "stdlib", "name": "stdlib/compress-flate", "content": "package flate // import \"compress/flate\"\n\nPackage flate implements the DEFLATE compressed data format, described in\nRFC 1951. The compress/gzip and compress/zlib packages implement access to\nDEFLATE-based file formats.\n\nCONSTANTS\n\nconst (\n\tNoCompression      = 0\n\tBestSpeed          = 1\n\tBestCompression    = 9\n\tDefaultCompression = -1\n\n\t// HuffmanOnly disables Lempel-Ziv match searching and only performs Huffman\n\t// entropy encoding. This mode is useful in compressing data that has\n\t// already been compressed with an LZ style algorithm (e.g. Snappy or LZ4)\n\t// that lacks an entropy encoder. Compression gains are achieved when\n\t// certain bytes in the input stream occur more frequently than others.\n\t//\n\t// Note that HuffmanOnly produces a compressed output that is\n\t// RFC 1951 compliant. That is, any valid DEFLATE decompressor will\n\t// continue to be able to decompress this output.\n\tHuffmanOnly = -2\n)\n\nFUNCTIONS\n\nfunc NewReader(r io.Reader) io.ReadCloser\n    NewReader returns a new ReadCloser that can be used to read the uncompressed\n    version of r. If r does not also implement io.ByteReader, the decompressor\n    may read more data than necessary from r. The reader returns io.EOF after\n    the final block in the DEFLATE stream has been encountered. Any trailing\n    data after the final block is ignored.\n\n    The io.ReadCloser returned by NewReader also implements Resetter.\n\nfunc NewReaderDict(r io.Reader, dict []byte) io.ReadCloser\n    NewReaderDict is like NewReader but initializes the reader with a preset\n    dictionary. The returned reader behaves as if the uncompressed data\n    stream started with the given dictionary, which has already been read.\n    NewReaderDict is typically used to read data compressed by NewWriterDict.\n\n    The ReadCloser returned by NewReaderDict also implements Resetter.\n\n\nTYPES\n\ntype CorruptInputError int64\n    A CorruptInputError reports the presence of corrupt input at a given offset.\n\nfunc (e CorruptInputError) Error() string\n\ntype InternalError string\n    An InternalError reports an error in the flate code itself.\n\nfunc (e InternalError) Error() string\n\ntype ReadError struct {\n\tOffset int64 // byte offset where error occurred\n\tErr    error // error returned by underlying Read\n}\n    A ReadError reports an error encountered while reading input.\n\n    Deprecated: No longer returned.\n\nfunc (e *ReadError) Error() string\n\ntype Reader interface {\n\tio.Reader\n\tio.ByteReader\n}\n    The actual read interface needed by NewReader. If the passed in io.Reader\n    does not also have ReadByte, the NewReader will introduce its own buffering.\n\ntype Resetter interface {\n\t// Reset discards any buffered data and resets the Resetter as if it was\n\t// newly initialized with the given reader.\n\tReset(r io.Reader, dict []byte) error\n}\n    Resetter resets a ReadCloser returned by NewReader or NewReaderDict to\n    switch to a new underlying Reader. This permits reusing a ReadCloser instead\n    of allocating a new one.\n\ntype WriteError struct {\n\tOffset int64 // byte offset where error occurred\n\tErr    error // error returned by underlying Write\n}\n    A WriteError reports an error encountered while writing output.\n\n    Deprecated: No longer returned.\n\nfunc (e *WriteError) Error() string\n\ntype Writer struct {\n\t// Has unexported fields.\n}\n    A Writer takes data written to it and writes the compressed form of that\n    data to an underlying writer (see NewWriter).\n\nfunc NewWriter(w io.Writer, level int) (*Writer, error)\n    NewWriter returns a new Writer compressing data at the given level.\n    Following zlib, levels range from 1 (BestSpeed) to 9 (BestCompression);\n    higher levels typically run slower but compress more. Level 0\n    (NoCompression) does not attempt any compression; it only adds the necessary\n    DEFLATE framing. Level -1 (DefaultCompression) uses the default compression\n    level. Level -2 (HuffmanOnly) will use Huffman compression only, giving a\n    very fast compression for all types of input, but sacrificing considerable\n    compression efficiency.\n\n    If level is in the range [-2, 9] then the error returned will be nil.\n    Otherwise the error returned will be non-nil.\n\nfunc NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)\n    NewWriterDict is like NewWriter but initializes the new Writer with a\n    preset dictionary. The returned Writer behaves as if the dictionary had been\n    written to it without producing any compressed output. The compressed data\n    written to w can only be decompressed by a reader initialized with the same\n    dictionary (see NewReaderDict).\n\nfunc (w *Writer) Close() error\n    Close flushes and closes the writer.\n\nfunc (w *Writer) Flush() error\n    Flush flushes any pending data to the underlying writer. It is useful mainly\n    in compressed network protocols, to ensure that a remote reader has enough\n    data to reconstruct a packet. Flush does not return until the data has been\n    written. Calling Flush when there is no pending data still causes the Writer\n    to emit a sync marker of at least 4 bytes. If the underlying writer returns\n    an error, Flush returns that error.\n\n    In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.\n\nfunc (w *Writer) Reset(dst io.Writer)\n    Reset discards the writer's state and makes it equivalent to the result of\n    NewWriter or NewWriterDict called with dst and w's level and dictionary.\n\nfunc (w *Writer) Write(data []byte) (n int, err error)\n    Write writes data to w, which will eventually write the compressed form of\n    data to its underlying writer.\n\n"}, {"path": "stdlib/runtime-trace.md", "category": "stdlib", "name": "stdlib/runtime-trace", "content": "package trace // import \"runtime/trace\"\n\nPackage trace contains facilities for programs to generate traces for the Go\nexecution tracer.\n\n# Tracing runtime activities\n\nThe execution trace captures a wide range of execution events such as goroutine\ncreation/blocking/unblocking, syscall enter/exit/block, GC-related events,\nchanges of heap size, processor start/stop, etc. When CPU profiling is active,\nthe execution tracer makes an effort to include those samples as well. A precise\nnanosecond-precision timestamp and a stack trace is captured for most events.\nThe generated trace can be interpreted using `go tool trace`.\n\nSupport for tracing tests and benchmarks built with the standard testing package\nis built into `go test`. For example, the following command runs the test in the\ncurrent directory and writes the trace file (trace.out).\n\n    go test -trace=trace.out\n\nThis runtime/trace package provides APIs to add equivalent tracing support to\na standalone program. See the Example that demonstrates how to use this API to\nenable tracing.\n\nThere is also a standard HTTP interface to trace data. Adding the following\nline will install a handler under the /debug/pprof/trace URL to download a live\ntrace:\n\n    import _ \"net/http/pprof\"\n\nSee the net/http/pprof package for more details about all of the debug endpoints\ninstalled by this import.\n\n# User annotation\n\nPackage trace provides user annotation APIs that can be used to log interesting\nevents during execution.\n\nThere are three types of user annotations: log messages, regions, and tasks.\n\nLog emits a timestamped message to the execution trace along with additional\ninformation such as the category of the message and which goroutine called Log.\nThe execution tracer provides UIs to filter and group goroutines using the log\ncategory and the message supplied in Log.\n\nA region is for logging a time interval during a goroutine's execution.\nBy definition, a region starts and ends in the same goroutine. Regions can be\nnested to represent subintervals. For example, the following code records four\nregions in the execution trace to trace the durations of sequential steps in a\ncappuccino making operation.\n\n    trace.WithRegion(ctx, \"makeCappuccino\", func() {\n\n       // orderID allows to identify a specific order\n       // among many cappuccino order region records.\n       trace.Log(ctx, \"orderID\", orderID)\n\n       trace.WithRegion(ctx, \"steamMilk\", steamMilk)\n       trace.WithRegion(ctx, \"extractCoffee\", extractCoffee)\n       trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee)\n    })\n\nA task is a higher-level component that aids tracing of logical operations\nsuch as an RPC request, an HTTP request, or an interesting local operation\nwhich may require multiple goroutines working together. Since tasks can\ninvolve multiple goroutines, they are tracked via a context.Context object.\nNewTask creates a new task and embeds it in the returned context.Context object.\nLog messages and regions are attached to the task, if any, in the Context passed\nto Log and WithRegion.\n\nFor example, assume that we decided to froth milk, extract coffee, and mix milk\nand coffee in separate goroutines. With a task, the trace tool can identify the\ngoroutines involved in a specific cappuccino order.\n\n    ctx, task := trace.NewTask(ctx, \"makeCappuccino\")\n    trace.Log(ctx, \"orderID\", orderID)\n\n    milk := make(chan bool)\n    espresso := make(chan bool)\n\n    go func() {\n            trace.WithRegion(ctx, \"steamMilk\", steamMilk)\n            milk <- true\n    }()\n    go func() {\n            trace.WithRegion(ctx, \"extractCoffee\", extractCoffee)\n            espresso <- true\n    }()\n    go func() {\n            defer task.End() // When assemble is done, the order is complete.\n            <-espresso\n            <-milk\n            trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee)\n    }()\n\nThe trace tool computes the latency of a task by measuring the time between the\ntask creation and the task end and provides latency distributions for each task\ntype found in the trace.\n\nFUNCTIONS\n\nfunc IsEnabled() bool\n    IsEnabled reports whether tracing is enabled. The information is advisory\n    only. The tracing status may have changed by the time this function returns.\n\nfunc Log(ctx context.Context, category, message string)\n    Log emits a one-off event with the given category and message. Category can\n    be empty and the API assumes there are only a handful of unique categories\n    in the system.\n\nfunc Logf(ctx context.Context, category, format string, args ...any)\n    Logf is like Log, but the value is formatted using the specified format\n    spec.\n\nfunc Start(w io.Writer) error\n    Start enables tracing for the current program. While tracing, the trace will\n    be buffered and written to w. Start returns an error if tracing is already\n    enabled.\n\nfunc Stop()\n    Stop stops the current tracing, if any. Stop only returns after all the\n    writes for the trace have completed.\n\nfunc WithRegion(ctx context.Context, regionType string, fn func())\n    WithRegion starts a region associated with its calling goroutine, runs fn,\n    and then ends the region. If the context carries a task, the region\n    is associated with the task. Otherwise, the region is attached to the\n    background task.\n\n    The regionType is used to classify regions, so there should be only a\n    handful of unique region types.\n\n\nTYPES\n\ntype FlightRecorder struct {\n\t// Has unexported fields.\n}\n    FlightRecorder represents a single consumer of a Go execution trace.\n    It tracks a moving window over the execution trace produced by the runtime,\n    always containing the most recent trace data.\n\n    At most one flight recorder may be active at any given time, though flight\n    recording is allowed to be concurrently active with a trace consumer using\n    trace.Start. This restriction of only a single flight recorder may be\n    removed in the future.\n\nfunc NewFlightRecorder(cfg FlightRecorderConfig) *FlightRecorder\n    NewFlightRecorder creates a new flight recorder from the provided\n    configuration.\n\nfunc (fr *FlightRecorder) Enabled() bool\n    Enabled returns true if the flight recorder is active. Specifically,\n    it will return true if Start did not return an error, and Stop has not yet\n    been called. It is safe to call from multiple goroutines simultaneously.\n\nfunc (fr *FlightRecorder) Start() error\n    Start activates the flight recorder and begins recording trace data.\n    Only one call to trace.Start may be active at any given time. In addition,\n    currently only one flight recorder may be active in the program. Returns an\n    error if the flight recorder cannot be started or is already started.\n\nfunc (fr *FlightRecorder) Stop()\n    Stop ends recording of trace data. It blocks until any concurrent WriteTo\n    calls complete.\n\nfunc (fr *FlightRecorder) WriteTo(w io.Writer) (n int64, err error)\n    WriteTo snapshots the moving window tracked by the flight recorder. The\n    snapshot is expected to contain data that is up-to-date as of when WriteTo\n    is called, though this is not a hard guarantee. Only one goroutine may\n    execute WriteTo at a time. An error is returned upon failure to write to w,\n    if another WriteTo call is already in-progress, or if the flight recorder is\n    inactive.\n\ntype FlightRecorderConfig struct {\n\t// MinAge is a lower bound on the age of an event in the flight recorder's window.\n\t//\n\t// The flight recorder will strive to promptly discard events older than the minimum age,\n\t// but older events may appear in the window snapshot. The age setting will always be\n\t// overridden by MaxSize.\n\t//\n\t// If this is 0, the minimum age is implementation defined, but can be assumed to be on the order\n\t// of seconds.\n\tMinAge time.Duration\n\n\t// MaxBytes is an upper bound on the size of the window in bytes.\n\t//\n\t// This setting takes precedence over MinAge.\n\t// However, it does not make any guarantees on the size of the data WriteTo will write,\n\t// nor does it guarantee memory overheads will always stay below MaxBytes. Treat it\n\t// as a hint.\n\t//\n\t// If this is 0, the maximum size is implementation defined.\n\tMaxBytes uint64\n}\n\ntype Region struct {\n\t// Has unexported fields.\n}\n    Region is a region of code whose execution time interval is traced.\n\nfunc StartRegion(ctx context.Context, regionType string) *Region\n    StartRegion starts a region and returns it. The returned Region's Region.End\n    method must be called from the same goroutine where the region was started.\n    Within each goroutine, regions must nest. That is, regions started after\n    this region must be ended before this region can be ended. Recommended usage\n    is\n\n        defer trace.StartRegion(ctx, \"myTracedRegion\").End()\n\nfunc (r *Region) End()\n    End marks the end of the traced code region.\n\ntype Task struct {\n\t// Has unexported fields.\n}\n    Task is a data type for tracing a user-defined, logical operation.\n\nfunc NewTask(pctx context.Context, taskType string) (ctx context.Context, task *Task)\n    NewTask creates a task instance with the type taskType and returns it along\n    with a Context that carries the task. If the input context contains a task,\n    the new task is its subtask.\n\n    The taskType is used to classify task instances. Analysis tools like the Go\n    execution tracer may assume there are only a bounded number of unique task\n    types in the system.\n\n    The returned Task's Task.End method is used to mark the task's end.\n    The trace tool measures task latency as the time between task creation and\n    when the End method is called, and provides the latency distribution per\n    task type. If the End method is called multiple times, only the first call\n    is used in the latency measurement.\n\n        ctx, task := trace.NewTask(ctx, \"awesomeTask\")\n        trace.WithRegion(ctx, \"preparation\", prepWork)\n        // preparation of the task\n        go func() {  // continue processing the task in a separate goroutine.\n            defer task.End()\n            trace.WithRegion(ctx, \"remainingWork\", remainingWork)\n        }()\n\nfunc (t *Task) End()\n    End marks the end of the operation represented by the Task.\n\n"}, {"path": "stdlib/crypto-tls-internal-fips140tls.md", "category": "stdlib", "name": "stdlib/crypto-tls-internal-fips140tls", "content": "package fips140tls // import \"crypto/tls/internal/fips140tls\"\n\nPackage fips140tls controls whether crypto/tls requires FIPS-approved settings.\n\nFUNCTIONS\n\nfunc Force()\n    Force forces crypto/tls to restrict TLS configurations to FIPS-approved\n    settings. By design, this call is impossible to undo (except in tests).\n\nfunc Required() bool\n    Required reports whether FIPS-approved settings are required.\n\n    Required is true if FIPS 140-3 mode is enabled with GODEBUG=fips140=on, or\n    if the crypto/tls/fipsonly package is imported by a Go+BoringCrypto build.\n\nfunc TestingOnlyAbandon()\n"}, {"path": "stdlib/crypto-internal-fips140-check-checktest.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-check-checktest", "content": "package checktest // import \"crypto/internal/fips140/check/checktest\"\n\nPackage checktest defines some code and data for use in the\ncrypto/internal/fips140/check test.\n\nVARIABLES\n\nvar BSS *int\nvar DATA = struct {\n\tP *int\n\tX int\n}{&NOPTRDATA, 3}\n    DATA needs to have both a pointer and an int so that _some_ of it gets\n    initialized at link time, so it is treated as DATA and not BSS. The pointer\n    is deferred to init time.\n\nvar NOPTRBSS int\nvar NOPTRDATA int = 1\nvar RODATA int32 // set to 2 in asm.s\n    The linkname here disables asan registration of this global, because asan\n    gets mad about rodata globals.\n\n\nFUNCTIONS\n\nfunc PtrStaticData() *uint32\nfunc PtrStaticText() unsafe.Pointer\nfunc TEXT()\n"}, {"path": "stdlib/internal-trace-raw.md", "category": "stdlib", "name": "stdlib/internal-trace-raw", "content": "package raw // import \"internal/trace/raw\"\n\nPackage raw provides an interface to interpret and emit Go execution traces.\nIt can interpret and emit execution traces in its wire format as well as a\nbespoke but simple text format.\n\nThe readers and writers in this package perform no validation on or ordering\nof the input, and so are generally unsuitable for analysis. However,\nthey're very useful for testing and debugging the tracer in the runtime and more\nsophisticated trace parsers.\n\n# Text format specification\n\nThe trace text format produced and consumed by this package is a line-oriented\nformat.\n\nThe first line in each text trace is the header line.\n\n    Trace Go1.XX\n\nFollowing that is a series of event lines. Each event begins with an event name,\nfollowed by zero or more named unsigned integer arguments. Names are separated\nfrom their integer values by an '=' sign. Names can consist of any UTF-8\ncharacter except '='.\n\nFor example:\n\n    EventName arg1=23 arg2=55 arg3=53\n\nAny amount of whitespace is allowed to separate each token. Whitespace is\nidentified via unicode.IsSpace.\n\nSome events have additional data on following lines. There are two such special\ncases.\n\nThe first special case consists of events with trailing byte-oriented data.\nThe trailer begins on the following line from the event. That line consists of a\nsingle argument 'data' and a Go-quoted string representing the byte data within.\nNote: an explicit argument for the length is elided, because it's just the\nlength of the unquoted string.\n\nFor example:\n\n    String id=5\n    \tdata=\"hello world\\x00\"\n\nThese events are identified in their spec by the HasData flag.\n\nThe second special case consists of stack events. These events are identified\nby the IsStack flag. These events also have a trailing unsigned integer argument\ndescribing the number of stack frame descriptors that follow. Each stack frame\ndescriptor is on its own line following the event, consisting of four signed\ninteger arguments: the PC, an integer describing the function name, an integer\ndescribing the file name, and the line number in that file that function was at\nat the time the stack trace was taken.\n\nFor example:\n\n    Stack id=5 n=2\n    \tpc=1241251 func=3 file=6 line=124\n    \tpc=7534345 func=6 file=3 line=64\n\nTYPES\n\ntype Event struct {\n\tVersion version.Version\n\tEv      tracev2.EventType\n\tArgs    []uint64\n\tData    []byte\n}\n    Event is a simple representation of a trace event.\n\n    Note that this typically includes much more than just timestamped events,\n    and it also represents parts of the trace format's framing. (But not\n    interpreted.)\n\nfunc (e *Event) EncodedSize() int\n    EncodedSize returns the canonical encoded size of an event.\n\nfunc (e *Event) String() string\n    String returns the canonical string representation of the event.\n\n    This format is the same format that is parsed by the TextReader and emitted\n    by the TextWriter.\n\ntype Reader struct {\n\t// Has unexported fields.\n}\n    Reader parses trace bytes with only very basic validation into an event\n    stream.\n\nfunc NewReader(r io.Reader) (*Reader, error)\n    NewReader creates a new reader for the trace wire format.\n\nfunc (r *Reader) ReadEvent() (Event, error)\n    ReadEvent reads and returns the next trace event in the byte stream.\n\nfunc (r *Reader) Version() version.Version\n    Version returns the version of the trace that we're reading.\n\ntype TextReader struct {\n\t// Has unexported fields.\n}\n    TextReader parses a text format trace with only very basic validation into\n    an event stream.\n\nfunc NewTextReader(r io.Reader) (*TextReader, error)\n    NewTextReader creates a new reader for the trace text format.\n\nfunc (r *TextReader) ReadEvent() (Event, error)\n    ReadEvent reads and returns the next trace event in the text stream.\n\nfunc (r *TextReader) Version() version.Version\n    Version returns the version of the trace that we're reading.\n\ntype TextWriter struct {\n\t// Has unexported fields.\n}\n    TextWriter emits the text format of a trace.\n\nfunc NewTextWriter(w io.Writer, v version.Version) (*TextWriter, error)\n    NewTextWriter creates a new write for the trace text format.\n\nfunc (w *TextWriter) WriteEvent(e Event) error\n    WriteEvent writes a single event to the stream.\n\ntype Writer struct {\n\t// Has unexported fields.\n}\n    Writer emits the wire format of a trace.\n\n    It may not produce a byte-for-byte compatible trace from what is produced by\n    the runtime, because it may be missing extra padding in the LEB128 encoding\n    that the runtime adds but isn't necessary when you know the data up-front.\n\nfunc NewWriter(w io.Writer, v version.Version) (*Writer, error)\n    NewWriter creates a new byte format writer.\n\nfunc (w *Writer) WriteEvent(e Event) error\n    WriteEvent writes a single event to the trace wire format stream.\n\n"}, {"path": "stdlib/flag.md", "category": "stdlib", "name": "stdlib/flag", "content": "package flag // import \"flag\"\n\nPackage flag implements command-line flag parsing.\n\n# Usage\n\nDefine flags using flag.String, Bool, Int, etc.\n\nThis declares an integer flag, -n, stored in the pointer nFlag, with type *int:\n\n    import \"flag\"\n    var nFlag = flag.Int(\"n\", 1234, \"help message for flag n\")\n\nIf you like, you can bind the flag to a variable using the Var() functions.\n\n    var flagvar int\n    func init() {\n    \tflag.IntVar(&flagvar, \"flagname\", 1234, \"help message for flagname\")\n    }\n\nOr you can create custom flags that satisfy the Value interface (with pointer\nreceivers) and couple them to flag parsing by\n\n    flag.Var(&flagVal, \"name\", \"help message for flagname\")\n\nFor such flags, the default value is just the initial value of the variable.\n\nAfter all flags are defined, call\n\n    flag.Parse()\n\nto parse the command line into the defined flags.\n\nFlags may then be used directly. If you're using the flags themselves, they are\nall pointers; if you bind to variables, they're values.\n\n    fmt.Println(\"ip has value \", *ip)\n    fmt.Println(\"flagvar has value \", flagvar)\n\nAfter parsing, the arguments following the flags are available as the slice\nflag.Args or individually as flag.Arg(i). The arguments are indexed from 0\nthrough flag.NArg-1.\n\n# Command line flag syntax\n\nThe following forms are permitted:\n\n    -flag\n    --flag   // double dashes are also permitted\n    -flag=x\n    -flag x  // non-boolean flags only\n\nOne or two dashes may be used; they are equivalent. The last form is not\npermitted for boolean flags because the meaning of the command\n\n    cmd -x *\n\nwhere * is a Unix shell wildcard, will change if there is a file called 0,\nfalse, etc. You must use the -flag=false form to turn off a boolean flag.\n\nFlag parsing stops just before the first non-flag argument (\"-\" is a non-flag\nargument) or after the terminator \"--\".\n\nInteger flags accept 1234, 0664, 0x1234 and may be negative. Boolean flags may\nbe:\n\n    1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False\n\nDuration flags accept any input valid for time.ParseDuration.\n\nThe default set of command-line flags is controlled by top-level functions.\nThe FlagSet type allows one to define independent sets of flags, such as to\nimplement subcommands in a command-line interface. The methods of FlagSet are\nanalogous to the top-level functions for the command-line flag set.\n\nVARIABLES\n\nvar ErrHelp = errors.New(\"flag: help requested\")\n    ErrHelp is the error returned if the -help or -h flag is invoked but no such\n    flag is defined.\n\nvar Usage = func() {\n\tfmt.Fprintf(CommandLine.Output(), \"Usage of %s:\\n\", os.Args[0])\n\tPrintDefaults()\n}\n    Usage prints a usage message documenting all defined command-line flags to\n    CommandLine's output, which by default is os.Stderr. It is called when an\n    error occurs while parsing flags. The function is a variable that may be\n    changed to point to a custom function. By default it prints a simple header\n    and calls PrintDefaults; for details about the format of the output and\n    how to control it, see the documentation for PrintDefaults. Custom usage\n    functions may choose to exit the program; by default exiting happens anyway\n    as the command line's error handling strategy is set to ExitOnError.\n\n\nFUNCTIONS\n\nfunc Arg(i int) string\n    Arg returns the i'th command-line argument. Arg(0) is the first remaining\n    argument after flags have been processed. Arg returns an empty string if the\n    requested element does not exist.\n\nfunc Args() []string\n    Args returns the non-flag command-line arguments.\n\nfunc Bool(name string, value bool, usage string) *bool\n    Bool defines a bool flag with specified name, default value, and usage\n    string. The return value is the address of a bool variable that stores the\n    value of the flag.\n\nfunc BoolFunc(name, usage string, fn func(string) error)\n    BoolFunc defines a flag with the specified name and usage string without\n    requiring values. Each time the flag is seen, fn is called with the value of\n    the flag. If fn returns a non-nil error, it will be treated as a flag value\n    parsing error.\n\nfunc BoolVar(p *bool, name string, value bool, usage string)\n    BoolVar defines a bool flag with specified name, default value, and usage\n    string. The argument p points to a bool variable in which to store the value\n    of the flag.\n\nfunc Duration(name string, value time.Duration, usage string) *time.Duration\n    Duration defines a time.Duration flag with specified name, default value,\n    and usage string. The return value is the address of a time.Duration\n    variable that stores the value of the flag. The flag accepts a value\n    acceptable to time.ParseDuration.\n\nfunc DurationVar(p *time.Duration, name string, value time.Duration, usage string)\n    DurationVar defines a time.Duration flag with specified name, default value,\n    and usage string. The argument p points to a time.Duration variable in\n    which to store the value of the flag. The flag accepts a value acceptable to\n    time.ParseDuration.\n\nfunc Float64(name string, value float64, usage string) *float64\n    Float64 defines a float64 flag with specified name, default value, and usage\n    string. The return value is the address of a float64 variable that stores\n    the value of the flag.\n\nfunc Float64Var(p *float64, name string, value float64, usage string)\n    Float64Var defines a float64 flag with specified name, default value,\n    and usage string. The argument p points to a float64 variable in which to\n    store the value of the flag.\n\nfunc Func(name, usage string, fn func(string) error)\n    Func defines a flag with the specified name and usage string. Each time\n    the flag is seen, fn is called with the value of the flag. If fn returns a\n    non-nil error, it will be treated as a flag value parsing error.\n\nfunc Int(name string, value int, usage string) *int\n    Int defines an int flag with specified name, default value, and usage\n    string. The return value is the address of an int variable that stores the\n    value of the flag.\n\nfunc Int64(name string, value int64, usage string) *int64\n    Int64 defines an int64 flag with specified name, default value, and usage\n    string. The return value is the address of an int64 variable that stores the\n    value of the flag.\n\nfunc Int64Var(p *int64, name string, value int64, usage string)\n    Int64Var defines an int64 flag with specified name, default value, and usage\n    string. The argument p points to an int64 variable in which to store the\n    value of the flag.\n\nfunc IntVar(p *int, name string, value int, usage string)\n    IntVar defines an int flag with specified name, default value, and usage\n    string. The argument p points to an int variable in which to store the value\n    of the flag.\n\nfunc NArg() int\n    NArg is the number of arguments remaining after flags have been processed.\n\nfunc NFlag() int\n    NFlag returns the number of command-line flags that have been set.\n\nfunc Parse()\n    Parse parses the command-line flags from os.Args[1:]. Must be called after\n    all flags are defined and before flags are accessed by the program.\n\nfunc Parsed() bool\n    Parsed reports whether the command-line flags have been parsed.\n\nfunc PrintDefaults()\n    PrintDefaults prints, to standard error unless configured otherwise, a usage\n    message showing the default settings of all defined command-line flags.\n    For an integer valued flag x, the default output has the form\n\n        -x int\n        \tusage-message-for-x (default 7)\n\n    The usage message will appear on a separate line for anything but a bool\n    flag with a one-byte name. For bool flags, the type is omitted and if\n    the flag name is one byte the usage message appears on the same line.\n    The parenthetical default is omitted if the default is the zero value for\n    the type. The listed type, here int, can be changed by placing a back-quoted\n    name in the flag's usage string; the first such item in the message is\n    taken to be a parameter name to show in the message and the back quotes are\n    stripped from the message when displayed. For instance, given\n\n        flag.String(\"I\", \"\", \"search `directory` for include files\")\n\n    the output will be\n\n        -I directory\n        \tsearch directory for include files.\n\n    To change the destination for flag messages, call CommandLine.SetOutput.\n\nfunc Set(name, value string) error\n    Set sets the value of the named command-line flag.\n\nfunc String(name string, value string, usage string) *string\n    String defines a string flag with specified name, default value, and usage\n    string. The return value is the address of a string variable that stores the\n    value of the flag.\n\nfunc StringVar(p *string, name string, value string, usage string)\n    StringVar defines a string flag with specified name, default value, and\n    usage string. The argument p points to a string variable in which to store\n    the value of the flag.\n\nfunc TextVar(p encoding.TextUnmarshaler, name string, value encoding.TextMarshaler, usage string)\n    TextVar defines a flag with a specified name, default value, and usage\n    string. The argument p must be a pointer to a variable that will hold the\n    value of the flag, and p must implement encoding.TextUnmarshaler. If the\n    flag is used, the flag value will be passed to p's UnmarshalText method.\n    The type of the default value must be the same as the type of p.\n\nfunc Uint(name string, value uint, usage string) *uint\n    Uint defines a uint flag with specified name, default value, and usage\n    string. The return value is the address of a uint variable that stores the\n    value of the flag.\n\nfunc Uint64(name string, value uint64, usage string) *uint64\n    Uint64 defines a uint64 flag with specified name, default value, and usage\n    string. The return value is the address of a uint64 variable that stores the\n    value of the flag.\n\nfunc Uint64Var(p *uint64, name string, value uint64, usage string)\n    Uint64Var defines a uint64 flag with specified name, default value, and\n    usage string. The argument p points to a uint64 variable in which to store\n    the value of the flag.\n\nfunc UintVar(p *uint, name string, value uint, usage string)\n    UintVar defines a uint flag with specified name, default value, and usage\n    string. The argument p points to a uint variable in which to store the value\n    of the flag.\n\nfunc UnquoteUsage(flag *Flag) (name string, usage string)\n    UnquoteUsage extracts a back-quoted name from the usage string for a flag\n    and returns it and the un-quoted usage. Given \"a `name` to show\" it returns\n    (\"name\", \"a name to show\"). If there are no back quotes, the name is an\n    educated guess of the type of the flag's value, or the empty string if the\n    flag is boolean.\n\nfunc Var(value Value, name string, usage string)\n    Var defines a flag with the specified name and usage string. The type and\n    value of the flag are represented by the first argument, of type Value,\n    which typically holds a user-defined implementation of Value. For instance,\n    the caller could create a flag that turns a comma-separated string into a\n    slice of strings by giving the slice the methods of Value; in particular,\n    Set would decompose the comma-separated string into the slice.\n\nfunc Visit(fn func(*Flag))\n    Visit visits the command-line flags in lexicographical order, calling fn for\n    each. It visits only those flags that have been set.\n\nfunc VisitAll(fn func(*Flag))\n    VisitAll visits the command-line flags in lexicographical order, calling fn\n    for each. It visits all flags, even those not set.\n\n\nTYPES\n\ntype ErrorHandling int\n    ErrorHandling defines how FlagSet.Parse behaves if the parse fails.\n\nconst (\n\tContinueOnError ErrorHandling = iota // Return a descriptive error.\n\tExitOnError                          // Call os.Exit(2) or for -h/-help Exit(0).\n\tPanicOnError                         // Call panic with a descriptive error.\n)\n    These constants cause FlagSet.Parse to behave as described if the parse\n    fails.\n\ntype Flag struct {\n\tName     string // name as it appears on command line\n\tUsage    string // help message\n\tValue    Value  // value as set\n\tDefValue string // default value (as text); for usage message\n}\n    A Flag represents the state of a flag.\n\nfunc Lookup(name string) *Flag\n    Lookup returns the Flag structure of the named command-line flag, returning\n    nil if none exists.\n\ntype FlagSet struct {\n\t// Usage is the function called when an error occurs while parsing flags.\n\t// The field is a function (not a method) that may be changed to point to\n\t// a custom error handler. What happens after Usage is called depends\n\t// on the ErrorHandling setting; for the command line, this defaults\n\t// to ExitOnError, which exits the program after calling Usage.\n\tUsage func()\n\n\t// Has unexported fields.\n}\n    A FlagSet represents a set of defined flags. The zero value of a FlagSet has\n    no name and has ContinueOnError error handling.\n\n    Flag names must be unique within a FlagSet. An attempt to define a flag\n    whose name is already in use will cause a panic.\n\nvar CommandLine *FlagSet\n    CommandLine is the default set of command-line flags, parsed from os.Args.\n    The top-level functions such as BoolVar, Arg, and so on are wrappers for the\n    methods of CommandLine.\n\nfunc NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet\n    NewFlagSet returns a new, empty flag set with the specified name and error\n    handling property. If the name is not empty, it will be printed in the\n    default usage message and in error messages.\n\nfunc (f *FlagSet) Arg(i int) string\n    Arg returns the i'th argument. Arg(0) is the first remaining argument after\n    flags have been processed. Arg returns an empty string if the requested\n    element does not exist.\n\nfunc (f *FlagSet) Args() []string\n    Args returns the non-flag arguments.\n\nfunc (f *FlagSet) Bool(name string, value bool, usage string) *bool\n    Bool defines a bool flag with specified name, default value, and usage\n    string. The return value is the address of a bool variable that stores the\n    value of the flag.\n\nfunc (f *FlagSet) BoolFunc(name, usage string, fn func(string) error)\n    BoolFunc defines a flag with the specified name and usage string without\n    requiring values. Each time the flag is seen, fn is called with the value of\n    the flag. If fn returns a non-nil error, it will be treated as a flag value\n    parsing error.\n\nfunc (f *FlagSet) BoolVar(p *bool, name string, value bool, usage string)\n    BoolVar defines a bool flag with specified name, default value, and usage\n    string. The argument p points to a bool variable in which to store the value\n    of the flag.\n\nfunc (f *FlagSet) Duration(name string, value time.Duration, usage string) *time.Duration\n    Duration defines a time.Duration flag with specified name, default value,\n    and usage string. The return value is the address of a time.Duration\n    variable that stores the value of the flag. The flag accepts a value\n    acceptable to time.ParseDuration.\n\nfunc (f *FlagSet) DurationVar(p *time.Duration, name string, value time.Duration, usage string)\n    DurationVar defines a time.Duration flag with specified name, default value,\n    and usage string. The argument p points to a time.Duration variable in\n    which to store the value of the flag. The flag accepts a value acceptable to\n    time.ParseDuration.\n\nfunc (f *FlagSet) ErrorHandling() ErrorHandling\n    ErrorHandling returns the error handling behavior of the flag set.\n\nfunc (f *FlagSet) Float64(name string, value float64, usage string) *float64\n    Float64 defines a float64 flag with specified name, default value, and usage\n    string. The return value is the address of a float64 variable that stores\n    the value of the flag.\n\nfunc (f *FlagSet) Float64Var(p *float64, name string, value float64, usage string)\n    Float64Var defines a float64 flag with specified name, default value,\n    and usage string. The argument p points to a float64 variable in which to\n    store the value of the flag.\n\nfunc (f *FlagSet) Func(name, usage string, fn func(string) error)\n    Func defines a flag with the specified name and usage string. Each time\n    the flag is seen, fn is called with the value of the flag. If fn returns a\n    non-nil error, it will be treated as a flag value parsing error.\n\nfunc (f *FlagSet) Init(name string, errorHandling ErrorHandling)\n    Init sets the name and error handling property for a flag set. By default,\n    the zero FlagSet uses an empty name and the ContinueOnError error handling\n    policy.\n\nfunc (f *FlagSet) Int(name string, value int, usage string) *int\n    Int defines an int flag with specified name, default value, and usage\n    string. The return value is the address of an int variable that stores the\n    value of the flag.\n\nfunc (f *FlagSet) Int64(name string, value int64, usage string) *int64\n    Int64 defines an int64 flag with specified name, default value, and usage\n    string. The return value is the address of an int64 variable that stores the\n    value of the flag.\n\nfunc (f *FlagSet) Int64Var(p *int64, name string, value int64, usage string)\n    Int64Var defines an int64 flag with specified name, default value, and usage\n    string. The argument p points to an int64 variable in which to store the\n    value of the flag.\n\nfunc (f *FlagSet) IntVar(p *int, name string, value int, usage string)\n    IntVar defines an int flag with specified name, default value, and usage\n    string. The argument p points to an int variable in which to store the value\n    of the flag.\n\nfunc (f *FlagSet) Lookup(name string) *Flag\n    Lookup returns the Flag structure of the named flag, returning nil if none\n    exists.\n\nfunc (f *FlagSet) NArg() int\n    NArg is the number of arguments remaining after flags have been processed.\n\nfunc (f *FlagSet) NFlag() int\n    NFlag returns the number of flags that have been set.\n\nfunc (f *FlagSet) Name() string\n    Name returns the name of the flag set.\n\nfunc (f *FlagSet) Output() io.Writer\n    Output returns the destination for usage and error messages. os.Stderr is\n    returned if output was not set or was set to nil.\n\nfunc (f *FlagSet) Parse(arguments []string) error\n    Parse parses flag definitions from the argument list, which should not\n    include the command name. Must be called after all flags in the FlagSet are\n    defined and before flags are accessed by the program. The return value will\n    be ErrHelp if -help or -h were set but not defined.\n\nfunc (f *FlagSet) Parsed() bool\n    Parsed reports whether f.Parse has been called.\n\nfunc (f *FlagSet) PrintDefaults()\n    PrintDefaults prints, to standard error unless configured otherwise,\n    the default values of all defined command-line flags in the set. See the\n    documentation for the global function PrintDefaults for more information.\n\nfunc (f *FlagSet) Set(name, value string) error\n    Set sets the value of the named flag.\n\nfunc (f *FlagSet) SetOutput(output io.Writer)\n    SetOutput sets the destination for usage and error messages. If output is\n    nil, os.Stderr is used.\n\nfunc (f *FlagSet) String(name string, value string, usage string) *string\n    String defines a string flag with specified name, default value, and usage\n    string. The return value is the address of a string variable that stores the\n    value of the flag.\n\nfunc (f *FlagSet) StringVar(p *string, name string, value string, usage string)\n    StringVar defines a string flag with specified name, default value, and\n    usage string. The argument p points to a string variable in which to store\n    the value of the flag.\n\nfunc (f *FlagSet) TextVar(p encoding.TextUnmarshaler, name string, value encoding.TextMarshaler, usage string)\n    TextVar defines a flag with a specified name, default value, and usage\n    string. The argument p must be a pointer to a variable that will hold the\n    value of the flag, and p must implement encoding.TextUnmarshaler. If the\n    flag is used, the flag value will be passed to p's UnmarshalText method.\n    The type of the default value must be the same as the type of p.\n\nfunc (f *FlagSet) Uint(name string, value uint, usage string) *uint\n    Uint defines a uint flag with specified name, default value, and usage\n    string. The return value is the address of a uint variable that stores the\n    value of the flag.\n\nfunc (f *FlagSet) Uint64(name string, value uint64, usage string) *uint64\n    Uint64 defines a uint64 flag with specified name, default value, and usage\n    string. The return value is the address of a uint64 variable that stores the\n    value of the flag.\n\nfunc (f *FlagSet) Uint64Var(p *uint64, name string, value uint64, usage string)\n    Uint64Var defines a uint64 flag with specified name, default value, and\n    usage string. The argument p points to a uint64 variable in which to store\n    the value of the flag.\n\nfunc (f *FlagSet) UintVar(p *uint, name string, value uint, usage string)\n    UintVar defines a uint flag with specified name, default value, and usage\n    string. The argument p points to a uint variable in which to store the value\n    of the flag.\n\nfunc (f *FlagSet) Var(value Value, name string, usage string)\n    Var defines a flag with the specified name and usage string. The type and\n    value of the flag are represented by the first argument, of type Value,\n    which typically holds a user-defined implementation of Value. For instance,\n    the caller could create a flag that turns a comma-separated string into a\n    slice of strings by giving the slice the methods of Value; in particular,\n    Set would decompose the comma-separated string into the slice.\n\nfunc (f *FlagSet) Visit(fn func(*Flag))\n    Visit visits the flags in lexicographical order, calling fn for each.\n    It visits only those flags that have been set.\n\nfunc (f *FlagSet) VisitAll(fn func(*Flag))\n    VisitAll visits the flags in lexicographical order, calling fn for each.\n    It visits all flags, even those not set.\n\ntype Getter interface {\n\tValue\n\tGet() any\n}\n    Getter is an interface that allows the contents of a Value to be retrieved.\n    It wraps the Value interface, rather than being part of it, because it\n    appeared after Go 1 and its compatibility rules. All Value types provided by\n    this package satisfy the Getter interface, except the type used by Func.\n\ntype Value interface {\n\tString() string\n\tSet(string) error\n}\n    Value is the interface to the dynamic value stored in a flag. (The default\n    value is represented as a string.)\n\n    If a Value has an IsBoolFlag() bool method returning true, the command-line\n    parser makes -name equivalent to -name=true rather than using the next\n    command-line argument.\n\n    Set is called once, in command line order, for each flag present.\n    The flag package may call the String method with a zero-valued receiver,\n    such as a nil pointer.\n\n"}, {"path": "stdlib/internal-runtime-gc.md", "category": "stdlib", "name": "stdlib/internal-runtime-gc", "content": "package gc // import \"internal/runtime/gc\"\n\n\nCONSTANTS\n\nconst (\n\n\t// A malloc header is functionally a single type pointer, but\n\t// we need to use 8 here to ensure 8-byte alignment of allocations\n\t// on 32-bit platforms. It's wasteful, but a lot of code relies on\n\t// 8-byte alignment for 8-byte atomics.\n\tMallocHeaderSize = 8\n\n\t// The minimum object size that has a malloc header, exclusive.\n\t//\n\t// The size of this value controls overheads from the malloc header.\n\t// The minimum size is bound by writeHeapBitsSmall, which assumes that the\n\t// pointer bitmap for objects of a size smaller than this doesn't cross\n\t// more than one pointer-word boundary. This sets an upper-bound on this\n\t// value at the number of bits in a uintptr, multiplied by the pointer\n\t// size in bytes.\n\t//\n\t// We choose a value here that has a natural cutover point in terms of memory\n\t// overheads. This value just happens to be the maximum possible value this\n\t// can be.\n\t//\n\t// A span with heap bits in it will have 128 bytes of heap bits on 64-bit\n\t// platforms, and 256 bytes of heap bits on 32-bit platforms. The first size\n\t// class where malloc headers match this overhead for 64-bit platforms is\n\t// 512 bytes (8 KiB / 512 bytes * 8 bytes-per-header = 128 bytes of overhead).\n\t// On 32-bit platforms, this same point is the 256 byte size class\n\t// (8 KiB / 256 bytes * 8 bytes-per-header = 256 bytes of overhead).\n\t//\n\t// Guaranteed to be exactly at a size class boundary. The reason this value is\n\t// an exclusive minimum is subtle. Suppose we're allocating a 504-byte object\n\t// and its rounded up to 512 bytes for the size class. If minSizeForMallocHeader\n\t// is 512 and an inclusive minimum, then a comparison against minSizeForMallocHeader\n\t// by the two values would produce different results. In other words, the comparison\n\t// would not be invariant to size-class rounding. Eschewing this property means a\n\t// more complex check or possibly storing additional state to determine whether a\n\t// span has malloc headers.\n\tMinSizeForMallocHeader = goarch.PtrSize * ptrBits\n\n\t// PageSize is the increment in which spans are managed.\n\tPageSize = 1 << PageShift\n)\nconst (\n\tMinHeapAlign   = 8\n\tMaxSmallSize   = 32768\n\tSmallSizeDiv   = 8\n\tSmallSizeMax   = 1024\n\tLargeSizeDiv   = 128\n\tNumSizeClasses = 68\n\tPageShift      = 13\n\tMaxObjsPerSpan = 1024\n)\n\nVARIABLES\n\nvar SizeClassToDivMagic = [NumSizeClasses]uint32{0, ^uint32(0)/8 + 1, ^uint32(0)/16 + 1, ^uint32(0)/24 + 1, ^uint32(0)/32 + 1, ^uint32(0)/48 + 1, ^uint32(0)/64 + 1, ^uint32(0)/80 + 1, ^uint32(0)/96 + 1, ^uint32(0)/112 + 1, ^uint32(0)/128 + 1, ^uint32(0)/144 + 1, ^uint32(0)/160 + 1, ^uint32(0)/176 + 1, ^uint32(0)/192 + 1, ^uint32(0)/208 + 1, ^uint32(0)/224 + 1, ^uint32(0)/240 + 1, ^uint32(0)/256 + 1, ^uint32(0)/288 + 1, ^uint32(0)/320 + 1, ^uint32(0)/352 + 1, ^uint32(0)/384 + 1, ^uint32(0)/416 + 1, ^uint32(0)/448 + 1, ^uint32(0)/480 + 1, ^uint32(0)/512 + 1, ^uint32(0)/576 + 1, ^uint32(0)/640 + 1, ^uint32(0)/704 + 1, ^uint32(0)/768 + 1, ^uint32(0)/896 + 1, ^uint32(0)/1024 + 1, ^uint32(0)/1152 + 1, ^uint32(0)/1280 + 1, ^uint32(0)/1408 + 1, ^uint32(0)/1536 + 1, ^uint32(0)/1792 + 1, ^uint32(0)/2048 + 1, ^uint32(0)/2304 + 1, ^uint32(0)/2688 + 1, ^uint32(0)/3072 + 1, ^uint32(0)/3200 + 1, ^uint32(0)/3456 + 1, ^uint32(0)/4096 + 1, ^uint32(0)/4864 + 1, ^uint32(0)/5376 + 1, ^uint32(0)/6144 + 1, ^uint32(0)/6528 + 1, ^uint32(0)/6784 + 1, ^uint32(0)/6912 + 1, ^uint32(0)/8192 + 1, ^uint32(0)/9472 + 1, ^uint32(0)/9728 + 1, ^uint32(0)/10240 + 1, ^uint32(0)/10880 + 1, ^uint32(0)/12288 + 1, ^uint32(0)/13568 + 1, ^uint32(0)/14336 + 1, ^uint32(0)/16384 + 1, ^uint32(0)/18432 + 1, ^uint32(0)/19072 + 1, ^uint32(0)/20480 + 1, ^uint32(0)/21760 + 1, ^uint32(0)/24576 + 1, ^uint32(0)/27264 + 1, ^uint32(0)/28672 + 1, ^uint32(0)/32768 + 1}\nvar SizeClassToNPages = [NumSizeClasses]uint8{0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 3, 2, 3, 1, 3, 2, 3, 4, 5, 6, 1, 7, 6, 5, 4, 3, 5, 7, 2, 9, 7, 5, 8, 3, 10, 7, 4}\nvar SizeClassToSize = [NumSizeClasses]uint16{0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768}\nvar SizeToSizeClass128 = [(MaxSmallSize-SmallSizeMax)/LargeSizeDiv + 1]uint8{32, 33, 34, 35, 36, 37, 37, 38, 38, 39, 39, 40, 40, 40, 41, 41, 41, 42, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 48, 48, 48, 49, 49, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67}\nvar SizeToSizeClass8 = [SmallSizeMax/SmallSizeDiv + 1]uint8{0, 1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32}\n\nTYPES\n\ntype ObjMask [MaxObjsPerSpan / (goarch.PtrSize * 8)]uintptr\n    ObjMask is a bitmap where each bit corresponds to an object in a span.\n\n    It is sized to accomodate all size classes.\n\ntype PtrMask [PageSize / goarch.PtrSize / (goarch.PtrSize * 8)]uintptr\n    PtrMask is a bitmap where each bit represents a pointer-word in a single\n    runtime page.\n\n"}, {"path": "stdlib/net-http-httptrace.md", "category": "stdlib", "name": "stdlib/net-http-httptrace", "content": "package httptrace // import \"net/http/httptrace\"\n\nPackage httptrace provides mechanisms to trace the events within HTTP client\nrequests.\n\nFUNCTIONS\n\nfunc WithClientTrace(ctx context.Context, trace *ClientTrace) context.Context\n    WithClientTrace returns a new context based on the provided parent ctx.\n    HTTP client requests made with the returned context will use the provided\n    trace hooks, in addition to any previous hooks registered with ctx.\n    Any hooks defined in the provided trace will be called first.\n\n\nTYPES\n\ntype ClientTrace struct {\n\t// GetConn is called before a connection is created or\n\t// retrieved from an idle pool. The hostPort is the\n\t// \"host:port\" of the target or proxy. GetConn is called even\n\t// if there's already an idle cached connection available.\n\tGetConn func(hostPort string)\n\n\t// GotConn is called after a successful connection is\n\t// obtained. There is no hook for failure to obtain a\n\t// connection; instead, use the error from\n\t// Transport.RoundTrip.\n\tGotConn func(GotConnInfo)\n\n\t// PutIdleConn is called when the connection is returned to\n\t// the idle pool. If err is nil, the connection was\n\t// successfully returned to the idle pool. If err is non-nil,\n\t// it describes why not. PutIdleConn is not called if\n\t// connection reuse is disabled via Transport.DisableKeepAlives.\n\t// PutIdleConn is called before the caller's Response.Body.Close\n\t// call returns.\n\t// For HTTP/2, this hook is not currently used.\n\tPutIdleConn func(err error)\n\n\t// GotFirstResponseByte is called when the first byte of the response\n\t// headers is available.\n\tGotFirstResponseByte func()\n\n\t// Got100Continue is called if the server replies with a \"100\n\t// Continue\" response.\n\tGot100Continue func()\n\n\t// Got1xxResponse is called for each 1xx informational response header\n\t// returned before the final non-1xx response. Got1xxResponse is called\n\t// for \"100 Continue\" responses, even if Got100Continue is also defined.\n\t// If it returns an error, the client request is aborted with that error value.\n\tGot1xxResponse func(code int, header textproto.MIMEHeader) error\n\n\t// DNSStart is called when a DNS lookup begins.\n\tDNSStart func(DNSStartInfo)\n\n\t// DNSDone is called when a DNS lookup ends.\n\tDNSDone func(DNSDoneInfo)\n\n\t// ConnectStart is called when a new connection's Dial begins.\n\t// If net.Dialer.DualStack (IPv6 \"Happy Eyeballs\") support is\n\t// enabled, this may be called multiple times.\n\tConnectStart func(network, addr string)\n\n\t// ConnectDone is called when a new connection's Dial\n\t// completes. The provided err indicates whether the\n\t// connection completed successfully.\n\t// If net.Dialer.DualStack (\"Happy Eyeballs\") support is\n\t// enabled, this may be called multiple times.\n\tConnectDone func(network, addr string, err error)\n\n\t// TLSHandshakeStart is called when the TLS handshake is started. When\n\t// connecting to an HTTPS site via an HTTP proxy, the handshake happens\n\t// after the CONNECT request is processed by the proxy.\n\tTLSHandshakeStart func()\n\n\t// TLSHandshakeDone is called after the TLS handshake with either the\n\t// successful handshake's connection state, or a non-nil error on handshake\n\t// failure.\n\tTLSHandshakeDone func(tls.ConnectionState, error)\n\n\t// WroteHeaderField is called after the Transport has written\n\t// each request header. At the time of this call the values\n\t// might be buffered and not yet written to the network.\n\tWroteHeaderField func(key string, value []string)\n\n\t// WroteHeaders is called after the Transport has written\n\t// all request headers.\n\tWroteHeaders func()\n\n\t// Wait100Continue is called if the Request specified\n\t// \"Expect: 100-continue\" and the Transport has written the\n\t// request headers but is waiting for \"100 Continue\" from the\n\t// server before writing the request body.\n\tWait100Continue func()\n\n\t// WroteRequest is called with the result of writing the\n\t// request and any body. It may be called multiple times\n\t// in the case of retried requests.\n\tWroteRequest func(WroteRequestInfo)\n}\n    ClientTrace is a set of hooks to run at various stages of an outgoing\n    HTTP request. Any particular hook may be nil. Functions may be called\n    concurrently from different goroutines and some may be called after the\n    request has completed or failed.\n\n    ClientTrace currently traces a single HTTP request & response during\n    a single round trip and has no hooks that span a series of redirected\n    requests.\n\n    See https://blog.golang.org/http-tracing for more.\n\nfunc ContextClientTrace(ctx context.Context) *ClientTrace\n    ContextClientTrace returns the ClientTrace associated with the provided\n    context. If none, it returns nil.\n\ntype DNSDoneInfo struct {\n\t// Addrs are the IPv4 and/or IPv6 addresses found in the DNS\n\t// lookup. The contents of the slice should not be mutated.\n\tAddrs []net.IPAddr\n\n\t// Err is any error that occurred during the DNS lookup.\n\tErr error\n\n\t// Coalesced is whether the Addrs were shared with another\n\t// caller who was doing the same DNS lookup concurrently.\n\tCoalesced bool\n}\n    DNSDoneInfo contains information about the results of a DNS lookup.\n\ntype DNSStartInfo struct {\n\tHost string\n}\n    DNSStartInfo contains information about a DNS request.\n\ntype GotConnInfo struct {\n\t// Conn is the connection that was obtained. It is owned by\n\t// the http.Transport and should not be read, written or\n\t// closed by users of ClientTrace.\n\tConn net.Conn\n\n\t// Reused is whether this connection has been previously\n\t// used for another HTTP request.\n\tReused bool\n\n\t// WasIdle is whether this connection was obtained from an\n\t// idle pool.\n\tWasIdle bool\n\n\t// IdleTime reports how long the connection was previously\n\t// idle, if WasIdle is true.\n\tIdleTime time.Duration\n}\n    GotConnInfo is the argument to the [ClientTrace.GotConn] function and\n    contains information about the obtained connection.\n\ntype WroteRequestInfo struct {\n\t// Err is any error encountered while writing the Request.\n\tErr error\n}\n    WroteRequestInfo contains information provided to the WroteRequest hook.\n\n"}, {"path": "stdlib/math-big-internal-asmgen.md", "category": "stdlib", "name": "stdlib/math-big-internal-asmgen", "content": "package asmgen // import \"math/big/internal/asmgen\"\n\nAsmgen generates math/big assembly.\n\nUsage:\n\n    cd go/src/math/big\n    go test ./internal/asmgen -generate\n\nOr:\n\n    go generate math/big\n\nVARIABLES\n\nvar Arch386 = &Arch{\n\tName:      \"386\",\n\tWordBits:  32,\n\tWordBytes: 4,\n\n\tregs: []string{\n\t\t\"BX\", \"SI\", \"DI\", \"BP\",\n\t\t\"CX\", \"DX\", \"AX\",\n\t},\n\top3:              x86Op3,\n\thint:             x86Hint,\n\tmemOK:            true,\n\tsubCarryIsBorrow: true,\n\tmaxColumns:       1,\n\n\tmemIndex: _386MemIndex,\n\n\tmov:      \"MOVL\",\n\tadds:     \"ADDL\",\n\tadcs:     \"ADCL\",\n\tsubs:     \"SUBL\",\n\tsbcs:     \"SBBL\",\n\tlsh:      \"SHLL\",\n\tlshd:     \"SHLL\",\n\trsh:      \"SHRL\",\n\trshd:     \"SHRL\",\n\tand:      \"ANDL\",\n\tor:       \"ORL\",\n\txor:      \"XORL\",\n\tneg:      \"NEGL\",\n\tlea:      \"LEAL\",\n\tmulWideF: x86MulWide,\n\n\taddWords: \"LEAL (%[2]s)(%[1]s*4), %[3]s\",\n\n\tjmpZero:       \"TESTL %[1]s, %[1]s; JZ %[2]s\",\n\tjmpNonZero:    \"TESTL %[1]s, %[1]s; JNZ %[2]s\",\n\tloopBottom:    \"SUBL $1, %[1]s; JNZ %[2]s\",\n\tloopBottomNeg: \"ADDL $1, %[1]s; JNZ %[2]s\",\n}\nvar ArchAMD64 = &Arch{\n\tName:      \"amd64\",\n\tWordBits:  64,\n\tWordBytes: 8,\n\n\tregs: []string{\n\t\t\"BX\", \"SI\", \"DI\",\n\t\t\"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\",\n\t\t\"AX\", \"DX\", \"CX\",\n\t},\n\top3:              x86Op3,\n\thint:             x86Hint,\n\tmemOK:            true,\n\tsubCarryIsBorrow: true,\n\n\toptions: map[Option]func(*Asm, string){\n\t\tOptionAltCarry: amd64JmpADX,\n\t},\n\n\tmov:      \"MOVQ\",\n\tadds:     \"ADDQ\",\n\tadcs:     \"ADCQ\",\n\tsubs:     \"SUBQ\",\n\tsbcs:     \"SBBQ\",\n\tlsh:      \"SHLQ\",\n\tlshd:     \"SHLQ\",\n\trsh:      \"SHRQ\",\n\trshd:     \"SHRQ\",\n\tand:      \"ANDQ\",\n\tor:       \"ORQ\",\n\txor:      \"XORQ\",\n\tneg:      \"NEGQ\",\n\tlea:      \"LEAQ\",\n\taddF:     amd64Add,\n\tmulWideF: x86MulWide,\n\n\taddWords: \"LEAQ (%[2]s)(%[1]s*8), %[3]s\",\n\n\tjmpZero:       \"TESTQ %[1]s, %[1]s; JZ %[2]s\",\n\tjmpNonZero:    \"TESTQ %[1]s, %[1]s; JNZ %[2]s\",\n\tloopBottom:    \"SUBQ $1, %[1]s; JNZ %[2]s\",\n\tloopBottomNeg: \"ADDQ $1, %[1]s; JNZ %[2]s\",\n}\nvar ArchARM = &Arch{\n\tName:          \"arm\",\n\tWordBits:      32,\n\tWordBytes:     4,\n\tCarrySafeLoop: true,\n\n\tregs: []string{\n\n\t\t\"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \"R8\", \"R9\", \"R11\", \"R12\",\n\t},\n\tregShift: true,\n\n\tmov:  \"MOVW\",\n\tadd:  \"ADD\",\n\tadds: \"ADD.S\",\n\tadc:  \"ADC\",\n\tadcs: \"ADC.S\",\n\tsub:  \"SUB\",\n\tsubs: \"SUB.S\",\n\tsbc:  \"SBC\",\n\tsbcs: \"SBC.S\",\n\trsb:  \"RSB\",\n\tand:  \"AND\",\n\tor:   \"ORR\",\n\txor:  \"EOR\",\n\n\tmulWideF: armMulWide,\n\n\taddWords: \"ADD %s<<2, %s, %s\",\n\n\tjmpZero:    \"TEQ $0, %s; BEQ %s\",\n\tjmpNonZero: \"TEQ $0, %s; BNE %s\",\n\n\tloadIncN:  armLoadIncN,\n\tloadDecN:  armLoadDecN,\n\tstoreIncN: armStoreIncN,\n\tstoreDecN: armStoreDecN,\n}\nvar ArchARM64 = &Arch{\n\tName:          \"arm64\",\n\tWordBits:      64,\n\tWordBytes:     8,\n\tCarrySafeLoop: true,\n\n\tregs: []string{\n\n\t\t\"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \"R8\", \"R9\",\n\t\t\"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\", \"R16\", \"R17\", \"R19\",\n\t\t\"R20\", \"R21\", \"R22\", \"R23\", \"R24\", \"R25\", \"R26\",\n\t},\n\treg0: \"ZR\",\n\n\tmov:   \"MOVD\",\n\tadd:   \"ADD\",\n\tadds:  \"ADDS\",\n\tadc:   \"ADC\",\n\tadcs:  \"ADCS\",\n\tsub:   \"SUB\",\n\tsubs:  \"SUBS\",\n\tsbc:   \"SBC\",\n\tsbcs:  \"SBCS\",\n\tmul:   \"MUL\",\n\tmulhi: \"UMULH\",\n\tlsh:   \"LSL\",\n\trsh:   \"LSR\",\n\tand:   \"AND\",\n\tor:    \"ORR\",\n\txor:   \"EOR\",\n\n\taddWords: \"ADD %[1]s<<3, %[2]s, %[3]s\",\n\n\tjmpZero:    \"CBZ %s, %s\",\n\tjmpNonZero: \"CBNZ %s, %s\",\n\n\tloadIncN:  arm64LoadIncN,\n\tloadDecN:  arm64LoadDecN,\n\tstoreIncN: arm64StoreIncN,\n\tstoreDecN: arm64StoreDecN,\n}\nvar ArchLoong64 = &Arch{\n\tName:          \"loong64\",\n\tWordBits:      64,\n\tWordBytes:     8,\n\tCarrySafeLoop: true,\n\n\tregs: []string{\n\n\t\t\"R4\", \"R5\", \"R6\", \"R7\", \"R8\", \"R9\",\n\t\t\"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\", \"R16\", \"R17\", \"R18\", \"R19\",\n\t\t\"R20\", \"R21\", \"R23\", \"R24\", \"R25\", \"R26\", \"R27\",\n\t\t\"R31\",\n\t},\n\treg0:        \"R0\",\n\tregCarry:    \"R28\",\n\tregAltCarry: \"R29\",\n\tregTmp:      \"R30\",\n\n\tmov:   \"MOVV\",\n\tadd:   \"ADDVU\",\n\tsub:   \"SUBVU\",\n\tsltu:  \"SGTU\",\n\tmul:   \"MULV\",\n\tmulhi: \"MULHVU\",\n\tlsh:   \"SLLV\",\n\trsh:   \"SRLV\",\n\tand:   \"AND\",\n\tor:    \"OR\",\n\txor:   \"XOR\",\n\n\tjmpZero:    \"BEQ %s, %s\",\n\tjmpNonZero: \"BNE %s, %s\",\n}\nvar ArchMIPS = &Arch{\n\tName:          \"mipsx\",\n\tBuild:         \"mips || mipsle\",\n\tWordBits:      32,\n\tWordBytes:     4,\n\tCarrySafeLoop: true,\n\n\tregs: []string{\n\n\t\t\"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \"R8\", \"R9\",\n\t\t\"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\", \"R16\", \"R17\", \"R18\", \"R19\",\n\t\t\"R20\", \"R21\", \"R22\", \"R24\", \"R25\",\n\t},\n\treg0:        \"R0\",\n\tregTmp:      \"R23\",\n\tregCarry:    \"R24\",\n\tregAltCarry: \"R25\",\n\n\tmov:      \"MOVW\",\n\tadd:      \"ADDU\",\n\tsltu:     \"SGTU\",\n\tsub:      \"SUBU\",\n\tmulWideF: mipsMulWide,\n\tlsh:      \"SLL\",\n\trsh:      \"SRL\",\n\tand:      \"AND\",\n\tor:       \"OR\",\n\txor:      \"XOR\",\n\n\tjmpZero:    \"BEQ %s, %s\",\n\tjmpNonZero: \"BNE %s, %s\",\n}\nvar ArchMIPS64x = &Arch{\n\tName:          \"mips64x\",\n\tBuild:         \"mips64 || mips64le\",\n\tWordBits:      64,\n\tWordBytes:     8,\n\tCarrySafeLoop: true,\n\n\tregs: []string{\n\n\t\t\"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \"R8\", \"R9\",\n\t\t\"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\", \"R16\", \"R17\", \"R18\", \"R19\",\n\t\t\"R20\", \"R21\", \"R22\", \"R24\", \"R25\",\n\t},\n\treg0:        \"R0\",\n\tregTmp:      \"R23\",\n\tregCarry:    \"R24\",\n\tregAltCarry: \"R25\",\n\n\tmov:      \"MOVV\",\n\tadd:      \"ADDVU\",\n\tsltu:     \"SGTU\",\n\tsub:      \"SUBVU\",\n\tmulWideF: mips64MulWide,\n\tlsh:      \"SLLV\",\n\trsh:      \"SRLV\",\n\tand:      \"AND\",\n\tor:       \"OR\",\n\txor:      \"XOR\",\n\n\tjmpZero:    \"BEQ %s, %s\",\n\tjmpNonZero: \"BNE %s, %s\",\n}\nvar ArchPPC64x = &Arch{\n\tName:          \"ppc64x\",\n\tBuild:         \"ppc64 || ppc64le\",\n\tWordBits:      64,\n\tWordBytes:     8,\n\tCarrySafeLoop: true,\n\n\tregs: []string{\n\n\t\t\"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \"R8\", \"R9\",\n\t\t\"R10\", \"R11\", \"R12\", \"R14\", \"R15\", \"R16\", \"R17\", \"R18\", \"R19\",\n\t\t\"R20\", \"R21\", \"R22\", \"R23\", \"R24\", \"R25\", \"R26\", \"R27\", \"R28\", \"R29\",\n\t},\n\treg0:   \"R0\",\n\tregTmp: \"R31\",\n\n\tmov:   \"MOVD\",\n\tadd:   \"ADD\",\n\tadds:  \"ADDC\",\n\tadcs:  \"ADDE\",\n\tsub:   \"SUB\",\n\tsubs:  \"SUBC\",\n\tsbcs:  \"SUBE\",\n\tmul:   \"MULLD\",\n\tmulhi: \"MULHDU\",\n\tlsh:   \"SLD\",\n\trsh:   \"SRD\",\n\tand:   \"ANDCC\",\n\tor:    \"OR\",\n\txor:   \"XOR\",\n\n\tjmpZero:    \"CMP %[1]s, $0; BEQ %[2]s\",\n\tjmpNonZero: \"CMP %s, $0; BNE %s\",\n\n\tloopTop:    \"CMP %[1]s, $0; BEQ %[2]s; MOVD %[1]s, CTR\",\n\tloopBottom: \"BDNZ %[2]s\",\n}\nvar ArchRISCV64 = &Arch{\n\tName:          \"riscv64\",\n\tWordBits:      64,\n\tWordBytes:     8,\n\tCarrySafeLoop: true,\n\n\tregs: []string{\n\n\t\t\"X5\", \"X6\", \"X7\", \"X8\", \"X9\",\n\t\t\"X10\", \"X11\", \"X12\", \"X13\", \"X14\", \"X15\", \"X16\", \"X17\", \"X18\", \"X19\",\n\t\t\"X20\", \"X21\", \"X22\", \"X23\", \"X24\", \"X25\", \"X26\",\n\t\t\"X30\",\n\t},\n\n\treg0:        \"X0\",\n\tregCarry:    \"X28\",\n\tregAltCarry: \"X29\",\n\tregTmp:      \"X31\",\n\n\tmov:   \"MOV\",\n\tadd:   \"ADD\",\n\tsub:   \"SUB\",\n\tmul:   \"MUL\",\n\tmulhi: \"MULHU\",\n\tlsh:   \"SLL\",\n\trsh:   \"SRL\",\n\tand:   \"AND\",\n\tor:    \"OR\",\n\txor:   \"XOR\",\n\tsltu:  \"SLTU\",\n\n\tjmpZero:    \"BEQZ %s, %s\",\n\tjmpNonZero: \"BNEZ %s, %s\",\n}\nvar ArchS390X = &Arch{\n\tName:          \"s390x\",\n\tWordBits:      64,\n\tWordBytes:     8,\n\tCarrySafeLoop: true,\n\n\tregs: []string{\n\n\t\t\"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \"R8\", \"R9\",\n\t\t\"R10\", \"R11\", \"R12\",\n\t},\n\treg0:       \"R0\",\n\tregTmp:     \"R10\",\n\tsetup:      s390xSetup,\n\tmaxColumns: 2,\n\top3:        s390xOp3,\n\thint:       s390xHint,\n\n\tmov:      \"MOVD\",\n\tadds:     \"ADDC\",\n\tadcs:     \"ADDE\",\n\tsubs:     \"SUBC\",\n\tsbcs:     \"SUBE\",\n\tmulWideF: s390MulWide,\n\tlsh:      \"SLD\",\n\trsh:      \"SRD\",\n\tand:      \"AND\",\n\tor:       \"OR\",\n\txor:      \"XOR\",\n\tneg:      \"NEG\",\n\tlea:      \"LAY\",\n\n\tjmpZero:    \"CMPBEQ %s, $0, %s\",\n\tjmpNonZero: \"CMPBNE %s, $0, %s\",\n}\n\nTYPES\n\ntype Arch struct {\n\tName          string // name of architecture\n\tBuild         string // build tag\n\tWordBits      int    // length of word in bits (32 or 64)\n\tWordBytes     int    // length of word in bytes (4 or 8)\n\tCarrySafeLoop bool   // whether loops preserve carry flag across iterations\n\n\t// Has unexported fields.\n}\n    An Arch defines how to generate assembly for a specific architecture.\n\nfunc (a *Arch) HasShiftWide() bool\n    HasShiftWide reports whether the Arch has working LshWide/RshWide\n    instructions. If not, calling them will panic.\n\ntype Asm struct {\n\tArch *Arch // architecture\n\n\t// Has unexported fields.\n}\n    An Asm is an assembly file being written.\n\nfunc NewAsm(arch *Arch) *Asm\n    NewAsm returns a new Asm preparing assembly for the given architecture to be\n    written to file.\n\nfunc (a *Asm) Add(src1, src2, dst Reg, carry Carry)\n    Add emits dst = src1+src2, with the specified carry behavior.\n\nfunc (a *Asm) AddWords(src1 Reg, src2, dst RegPtr)\n    AddWords emits dst = src1*WordBytes + src2. It does not set or use the carry\n    flag.\n\nfunc (a *Asm) AltCarry() Reg\n    AltCarry returns the secondary carry register, or else the zero Reg.\n\nfunc (a *Asm) And(src1, src2, dst Reg)\n    And emits dst = src1 & src2 It may modify the carry flag.\n\nfunc (a *Asm) Carry() Reg\n    Carry returns the carry register, or else the zero Reg.\n\nfunc (a *Asm) ClearCarry(which Carry)\n    ClearCarry clears the carry flag. The \u2018which\u2019 parameter must be AddCarry\n    or SubCarry to specify how the flag will be used. (On some systems, the sub\n    carry's actual processor bit is inverted from its usual value.)\n\nfunc (a *Asm) Comment(format string, args ...any)\n    Comment emits a line comment to the assembly output.\n\nfunc (a *Asm) ConvertCarry(which Carry, dst Reg)\n    ConvertCarry converts the carry flag in dst from the internal format to a 0\n    or 1. The carry flag is left in an undefined state.\n\nfunc (a *Asm) EOL(format string, args ...any)\n    EOL appends an end-of-line comment to the previous line.\n\nfunc (a *Asm) Enabled(option Option) bool\n    Enabled reports whether the optional CPU feature is considered to be enabled\n    at this point in the assembly output.\n\nfunc (a *Asm) Fatalf(format string, args ...any)\n    Fatalf reports a fatal error by panicking. Panicking is appropriate because\n    there is a bug in the generator, and panicking will show the exact source\n    lines leading to that bug.\n\nfunc (a *Asm) Free(r Reg)\n    Free frees a previously allocated register. If r is not a register (if it's\n    an immediate or a memory reference), Free is a no-op.\n\nfunc (a *Asm) FreeAll()\n    FreeAll frees all known registers.\n\nfunc (a *Asm) Func(decl string) *Func\n    Func starts a new function in the assembly output.\n\nfunc (a *Asm) HasRegShift() bool\n    HasRegShift reports whether the architecture can use shift expressions as\n    operands.\n\nfunc (a *Asm) Imm(x int) Reg\n    Imm returns a Reg representing an immediate (constant) value.\n\nfunc (a *Asm) IsZero(r Reg) bool\n    IsZero reports whether r is a zero immediate or the zero register.\n\nfunc (a *Asm) Jmp(label string)\n    Jmp jumps to the label.\n\nfunc (a *Asm) JmpEnable(option Option, label string) bool\n    JmpEnable emits a test for the optional CPU feature that jumps to label\n    if the feature is present. If JmpEnable returns false, the feature is not\n    available on this architecture and no code was emitted.\n\nfunc (a *Asm) JmpNonZero(src Reg, label string)\n    JmpNonZero jumps to the label if src is non-zero. It may modify the carry\n    flag unless a.Arch,CarrySafeLoop is true.\n\nfunc (a *Asm) JmpZero(src Reg, label string)\n    JmpZero jumps to the label if src is zero. It may modify the carry flag\n    unless a.Arch.CarrySafeLoop is true.\n\nfunc (a *Asm) Label(name string)\n    Label emits a label with the given name.\n\nfunc (a *Asm) Lsh(shift, src, dst Reg)\n    Lsh emits dst = src << shift. It may modify the carry flag.\n\nfunc (a *Asm) LshReg(shift, src Reg) Reg\n    LshReg returns a shift-expression operand src<<shift. If a.HasRegShift() ==\n    false, LshReg panics.\n\nfunc (a *Asm) LshWide(shift, adj, src, dst Reg)\n    LshWide emits dst = src << shift with low bits shifted from adj. It may\n    modify the carry flag.\n\nfunc (a *Asm) Mov(src, dst Reg)\n    Mov emits dst = src.\n\nfunc (a *Asm) MulWide(src1, src2, dstlo, dsthi Reg)\n    MulWide emits dstlo = src1 * src2 and dsthi = (src1 * src2) >> WordBits. The\n    carry flag is left in an undefined state. If dstlo or dsthi is the zero Reg,\n    then those outputs are discarded.\n\nfunc (a *Asm) Neg(src, dst Reg)\n    Neg emits dst = -src. It may modify the carry flag.\n\nfunc (a *Asm) Or(src1, src2, dst Reg)\n    Or emits dst = src1 | src2 It may modify the carry flag.\n\nfunc (a *Asm) Printf(format string, args ...any)\n    Printf emits to the assembly output.\n\nfunc (a *Asm) Reg() Reg\n    Reg allocates a new register.\n\nfunc (a *Asm) RegHint(hint Hint) Reg\n    RegHint allocates a new register, with a hint as to its purpose.\n\nfunc (a *Asm) RegsUsed() RegsUsed\n    RegsUsed returns a snapshot of which registers are currently allocated,\n    which can be passed to a future call to Asm.SetRegsUsed.\n\nfunc (a *Asm) RestoreCarry(src Reg)\n    RestoreCarry restores the carry flag from src. src is left in an undefined\n    state.\n\nfunc (a *Asm) Ret()\n    Ret returns.\n\nfunc (a *Asm) Rsh(shift, src, dst Reg)\n    Rsh emits dst = src >> shift. It may modify the carry flag.\n\nfunc (a *Asm) RshReg(shift, src Reg) Reg\n    RshReg returns a shift-expression operand src>>shift. If a.HasRegShift() ==\n    false, RshReg panics.\n\nfunc (a *Asm) RshWide(shift, adj, src, dst Reg)\n    RshWide emits dst = src >> shift with high bits shifted from adj. It may\n    modify the carry flag.\n\nfunc (a *Asm) SLTU(src1, src2, dst Reg)\n    SLTU emits dst = src2 < src1 (0 or 1), using an unsigned comparison.\n\nfunc (a *Asm) SaveCarry(dst Reg)\n    SaveCarry saves the carry flag into dst. The meaning of the bits in dst is\n    architecture-dependent. The carry flag is left in an undefined state.\n\nfunc (a *Asm) SaveConvertCarry(which Carry, dst Reg)\n    SaveConvertCarry saves and converts the carry flag into dst: 0 unset, 1 set.\n    The carry flag is left in an undefined state.\n\nfunc (a *Asm) SetOption(option Option, on bool)\n    SetOption changes whether the optional CPU feature should be considered to\n    be enabled.\n\nfunc (a *Asm) SetRegsUsed(used RegsUsed)\n    SetRegsUsed sets which registers are currently allocated. The argument\n    should have been returned from a previous call to Asm.RegsUsed.\n\nfunc (a *Asm) Sub(src1, src2, dst Reg, carry Carry)\n    Sub emits dst = src2-src1, with the specified carry behavior.\n\nfunc (a *Asm) Unfree(r Reg)\n    Unfree reallocates a previously freed register r. If r is not a register\n    (if it's an immediate or a memory reference), Unfree is a no-op. If r is not\n    free for allocation, Unfree panics. A Free paired with Unfree can release\n    a register for use temporarily but then reclaim it, such as at the end of a\n    loop body when it must be restored.\n\nfunc (a *Asm) Xor(src1, src2, dst Reg)\n    Xor emits dst = src1 ^ src2 It may modify the carry flag.\n\nfunc (a *Asm) ZR() Reg\n    ZR returns the zero register (the specific register guaranteed to hold the\n    integer 0), or else the zero Reg (Reg{}, which has r.Valid() == false).\n\ntype Carry uint\n    A Carry is a flag field explaining how an instruction sets and uses the\n    carry flags. Different operations expect different sets of bits. Add and\n    Sub expect: UseCarry or 0, SetCarry, KeepCarry, or SmashCarry; and AltCarry\n    or 0. ClearCarry, SaveCarry, and ConvertCarry expect: AddCarry or SubCarry;\n    and AltCarry or 0.\n\nconst (\n\tSetCarry   Carry = 1 << iota // sets carry\n\tUseCarry                     // uses carry\n\tKeepCarry                    // must preserve carry\n\tSmashCarry                   // can modify carry or not, whatever is easiest\n\n\tAltCarry // use the secondary carry flag\n\tAddCarry // use add carry flag semantics (for ClearCarry, ConvertCarry)\n\tSubCarry // use sub carry flag semantics (for ClearCarry, ConvertCarry)\n)\ntype Func struct {\n\tName string\n\tAsm  *Asm\n\n\t// Has unexported fields.\n}\n    A Func represents a single assembly function.\n\nfunc (f *Func) Arg(name string) Reg\n    Arg allocates a new register, copies the named argument (or result) into it,\n    and returns that register.\n\nfunc (f *Func) ArgHint(name string, hint Hint) Reg\n    ArgHint is like Arg but uses a register allocation hint.\n\nfunc (f *Func) ArgPtr(name string) RegPtr\n    ArgPtr is like Arg but returns a RegPtr.\n\nfunc (f *Func) Pipe() *Pipe\n    Pipe creates and returns a new pipe for use in the function f.\n\nfunc (f *Func) StoreArg(src Reg, name string)\n    StoreArg stores src into the named argument (or result).\n\ntype Hint uint\n    A Hint is a hint about what a register will be used for, so that an\n    appropriate one can be selected.\n\nconst (\n\tHintNone       Hint = iota\n\tHintShiftCount      // shift count (CX on x86)\n\tHintMulSrc          // mul source operand (AX on x86)\n\tHintMulHi           // wide mul high output (DX on x86)\n\tHintMemOK           // a memory reference is okay\n\tHintCarry           // carry flag\n\tHintAltCarry        // secondary carry flag\n)\ntype Option int\n    An Option denotes an optional CPU feature that can be tested at runtime.\n\nconst (\n\n\t// OptionAltCarry checks whether there is an add instruction\n\t// that uses a secondary carry flag, so that two different sums\n\t// can be accumulated in parallel with independent carry flags.\n\t// Some architectures (MIPS, Loong64, RISC-V) provide this\n\t// functionality natively, indicated by asm.Carry().Valid() being true.\n\tOptionAltCarry Option\n)\ntype Pipe struct {\n\t// Has unexported fields.\n}\n    A Pipe manages the input and output data pipelines for a function's memory\n    operations.\n\n    The input is one or more equal-length slices of words, so collectively it\n    can be viewed as a matrix, in which each slice is a row and each column is\n    a set of corresponding words from the different slices. The output can be\n    viewed the same way, although it is often just one row.\n\nfunc (p *Pipe) AtUnrollEnd(end func())\n    AtUnrollEnd sets a function to call at the end of an unrolled sequence.\n    See Pipe.Loop for details.\n\nfunc (p *Pipe) AtUnrollStart(start func())\n    AtUnrollStart sets a function to call at the start of an unrolled sequence.\n    See Pipe.Loop for details.\n\nfunc (p *Pipe) Done()\n    Done frees all the registers allocated by the pipe.\n\nfunc (p *Pipe) DropInput(name string)\n    DropInput deletes the named input from the pipe, usually because it has been\n    exhausted. (This is not used yet but will be used in a future generator.)\n\nfunc (p *Pipe) LoadN(n int) [][]Reg\n    LoadN returns the next n columns of input words as a slice of rows.\n    Regs for inputs that have been marked using p.SetMemOK will be direct memory\n    references. Regs for other inputs will be newly allocated registers and must\n    be freed.\n\nfunc (p *Pipe) LoadPtrs(n Reg)\n    LoadPtrs loads the slice pointer arguments into registers, assuming that the\n    slice length n has already been loaded into the register n.\n\n    Start will call LoadPtrs if it has not been called already. LoadPtrs only\n    needs to be called explicitly when code needs to use LoadN before Start,\n    like when the shift.go generators read an initial word before the loop.\n\nfunc (p *Pipe) Loop(block func(in, out [][]Reg))\n    Loop emits code for the loop, calling block repeatedly to emit code\n    that handles a block of N input columns (for arbitrary N = len(in[0])\n    chosen by p). block must call p.StoreN(out) to write N output columns.\n    The out slice is a pre-allocated matrix of uninitialized Reg values.\n    block is expected to set each entry to the Reg that should be written before\n    calling p.StoreN(out).\n\n    For example, if the loop is to be unrolled 4x in blocks of 2 columns each,\n    the sequence of calls to emit the unrolled loop body is:\n\n        start()  // set by pAtUnrollStart\n        ... reads for 2 columns ...\n        block()\n        ... writes for 2 columns ...\n        ... reads for 2 columns ...\n        block()\n        ... writes for 2 columns ...\n        end()  // set by p.AtUnrollEnd\n\n    Any registers allocated during block are freed automatically when block\n    returns.\n\nfunc (p *Pipe) Restart(n Reg, factors ...int)\n    Restart prepares to loop over an additional n columns, beyond a previous\n    loop run by p.Start/p.Loop.\n\nfunc (p *Pipe) SetBackward()\n    SetBackward sets the pipe to process the input and output columns in reverse\n    order. This is needed for left shifts, which might otherwise overwrite data\n    they will read later.\n\nfunc (p *Pipe) SetHint(name string, hint Hint)\n    SetHint records that the inputs from the named vector should be allocated\n    with the given register hint.\n\n    If the hint indicates a single register on the target architecture, then\n    SetHint calls SetMaxColumns(1), since the hinted register can only be used\n    for one value at a time.\n\nfunc (p *Pipe) SetLabel(label string)\n    SetLabel sets the label prefix for the loops emitted by the pipe. The\n    default prefix is \"loop\".\n\nfunc (p *Pipe) SetMaxColumns(m int)\n    SetMaxColumns sets the maximum number of columns processed in a single loop\n    body call.\n\nfunc (p *Pipe) SetUseIndexCounter()\n    SetUseIndexCounter sets the pipe to use an index counter if possible,\n    meaning the loop counter is also used as an index for accessing the slice\n    data. This clever trick is slower on modern processors, but it is still\n    necessary on 386. On non-386 systems, SetUseIndexCounter is a no-op.\n\nfunc (p *Pipe) Start(n Reg, factors ...int)\n    Start prepares to loop over n columns. The factors give a sequence of\n    unrolling factors to use, which must be either strictly increasing or\n    strictly decreasing and must include 1. For example, 4, 1 means to process\n    4 elements at a time and then 1 at a time for the final 0-3; specifying 1,4\n    instead handles 0-3 elements first and then 4 at a time. Similarly, 32, 4,\n    1 means to process 32 at a time, then 4 at a time, then 1 at a time.\n\n    One benefit of using 1, 4 instead of 4, 1 is that the body processing 4 at a\n    time needs more registers, and if it is the final body, the register holding\n    the fragment count (0-3) has been freed and is available for use.\n\n    Start may modify the carry flag.\n\n    Start must be followed by a call to Loop1 or LoopN, but it is permitted to\n    emit other instructions first, for example to set an initial carry flag.\n\nfunc (p *Pipe) StoreN(regs [][]Reg)\n    StoreN writes regs (a slice of rows) to the next n columns of output,\n    where n = len(regs[0]).\n\ntype Reg struct {\n\t// Has unexported fields.\n}\n    A Reg is an allocated register or other assembly operand. (For example,\n    a constant might have name \"$123\" and a memory reference might have name\n    \"0(R8)\".)\n\nfunc (r Reg) IsImm() bool\n    IsImm reports whether r is an immediate value.\n\nfunc (r Reg) IsMem() bool\n    IsMem reports whether r is a memory value.\n\nfunc (r Reg) String() string\n    String returns the assembly syntax for r.\n\nfunc (r Reg) Valid() bool\n    Valid reports whether is valid, meaning r is not the zero value of Reg (a\n    register with no name).\n\ntype RegPtr struct {\n\t// Has unexported fields.\n}\n    A RegPtr is like a Reg but expected to hold a pointer. The separate Go type\n    helps keeps pointers and scalars separate and avoid mistakes; it is okay to\n    convert to Reg as needed to use specific routines.\n\nfunc (r RegPtr) String() string\n    String returns the assembly syntax for r.\n\nfunc (r RegPtr) Valid() bool\n    Valid reports whether is valid, meaning r is not the zero value of RegPtr (a\n    register with no name).\n\ntype RegsUsed struct {\n\t// Has unexported fields.\n}\n    A RegsUsed is a snapshot of which registers are allocated.\n\n"}, {"path": "stdlib/internal-coverage-cmerge.md", "category": "stdlib", "name": "stdlib/internal-coverage-cmerge", "content": "package cmerge // import \"internal/coverage/cmerge\"\n\n\nFUNCTIONS\n\nfunc SaturatingAdd(dst, src uint32) (uint32, bool)\n    Saturating add does a saturating addition of 'dst' and 'src', returning\n    added value or math.MaxUint32 plus an overflow flag.\n\n\nTYPES\n\ntype Merger struct {\n\t// Has unexported fields.\n}\n    Merger provides state and methods to help manage the process of merging\n    together coverage counter data for a given function, for tools that need to\n    implicitly merge counter as they read multiple coverage counter data files.\n\nfunc (cm *Merger) Granularity() coverage.CounterGranularity\n\nfunc (m *Merger) MergeCounters(dst, src []uint32) (error, bool)\n    MergeCounters takes the counter values in 'src' and merges them into 'dst'\n    according to the correct counter mode.\n\nfunc (cm *Merger) Mode() coverage.CounterMode\n\nfunc (cm *Merger) ResetModeAndGranularity()\n\nfunc (m *Merger) SaturatingAdd(dst, src uint32) uint32\n    Saturating add does a saturating addition of 'dst' and 'src', returning\n    added value or math.MaxUint32 if there is an overflow. Overflows are\n    recorded in case the client needs to track them.\n\nfunc (cm *Merger) SetModeAndGranularity(mdf string, cmode coverage.CounterMode, cgran coverage.CounterGranularity) error\n    SetModeAndGranularity records the counter mode and granularity for the\n    current merge. In the specific case of merging across coverage data files\n    from different binaries, where we're combining data from more than one\n    meta-data file, we need to check for and resolve mode/granularity clashes.\n\nfunc (cm *Merger) SetModeMergePolicy(policy ModeMergePolicy)\n\ntype ModeMergePolicy uint8\n\nconst (\n\tModeMergeStrict ModeMergePolicy = iota\n\tModeMergeRelaxed\n)\n"}, {"path": "stdlib/internal-testlog.md", "category": "stdlib", "name": "stdlib/internal-testlog", "content": "package testlog // import \"internal/testlog\"\n\nPackage testlog provides a back-channel communication path between tests and\npackage os, so that cmd/go can see which environment variables and files a test\nconsults.\n\nFUNCTIONS\n\nfunc Getenv(name string)\n    Getenv calls Logger().Getenv, if a logger has been set.\n\nfunc Open(name string)\n    Open calls Logger().Open, if a logger has been set.\n\nfunc PanicOnExit0() bool\n    PanicOnExit0 reports whether to panic on a call to os.Exit(0). This is in\n    the testlog package because, like other definitions in package testlog,\n    it is a hook between the testing package and the os package. This is used to\n    ensure that an early call to os.Exit(0) does not cause a test to pass.\n\nfunc SetLogger(impl Interface)\n    SetLogger sets the test logger implementation for the current process.\n    It must be called only once, at process startup.\n\nfunc SetPanicOnExit0(v bool)\n    SetPanicOnExit0 sets panicOnExit0 to v.\n\n    SetPanicOnExit0 should be an internal detail, but alternate implementations\n    of go test in other build systems may need to access it using linkname.\n\n    Do not remove or change the type signature. See go.dev/issue/67401.\n\nfunc Stat(name string)\n    Stat calls Logger().Stat, if a logger has been set.\n\n\nTYPES\n\ntype Interface interface {\n\tGetenv(key string)\n\tStat(file string)\n\tOpen(file string)\n\tChdir(dir string)\n}\n    Interface is the interface required of test loggers. The os package will\n    invoke the interface's methods to indicate that it is inspecting the given\n    environment variables or files. Multiple goroutines may call these methods\n    simultaneously.\n\nfunc Logger() Interface\n    Logger returns the current test logger implementation. It returns nil if\n    there is no logger.\n\n"}, {"path": "stdlib/fmt.md", "category": "stdlib", "name": "stdlib/fmt", "content": "package fmt // import \"fmt\"\n\nPackage fmt implements formatted I/O with functions analogous to C's printf and\nscanf. The format 'verbs' are derived from C's but are simpler.\n\n# Printing\n\nThe verbs:\n\nGeneral:\n\n    %v\tthe value in a default format\n    \twhen printing structs, the plus flag (%+v) adds field names\n    %#v\ta Go-syntax representation of the value\n    \t(floating-point infinities and NaNs print as \u00b1Inf and NaN)\n    %T\ta Go-syntax representation of the type of the value\n    %%\ta literal percent sign; consumes no value\n\nBoolean:\n\n    %t\tthe word true or false\n\nInteger:\n\n    %b\tbase 2\n    %c\tthe character represented by the corresponding Unicode code point\n    %d\tbase 10\n    %o\tbase 8\n    %O\tbase 8 with 0o prefix\n    %q\ta single-quoted character literal safely escaped with Go syntax.\n    %x\tbase 16, with lower-case letters for a-f\n    %X\tbase 16, with upper-case letters for A-F\n    %U\tUnicode format: U+1234; same as \"U+%04X\"\n\nFloating-point and complex constituents:\n\n    %b\tdecimalless scientific notation with exponent a power of two,\n    \tin the manner of strconv.FormatFloat with the 'b' format,\n    \te.g. -123456p-78\n    %e\tscientific notation, e.g. -1.234456e+78\n    %E\tscientific notation, e.g. -1.234456E+78\n    %f\tdecimal point but no exponent, e.g. 123.456\n    %F\tsynonym for %f\n    %g\t%e for large exponents, %f otherwise. Precision is discussed below.\n    %G\t%E for large exponents, %F otherwise\n    %x\thexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20\n    %X\tupper-case hexadecimal notation, e.g. -0X1.23ABCP+20\n\n    The exponent is always a decimal integer.\n    For formats other than %b the exponent is at least two digits.\n\nString and slice of bytes (treated equivalently with these verbs):\n\n    %s\tthe uninterpreted bytes of the string or slice\n    %q\ta double-quoted string safely escaped with Go syntax\n    %x\tbase 16, lower-case, two characters per byte\n    %X\tbase 16, upper-case, two characters per byte\n\nSlice:\n\n    %p\taddress of 0th element in base 16 notation, with leading 0x\n\nPointer:\n\n    %p\tbase 16 notation, with leading 0x\n    The %b, %d, %o, %x and %X verbs also work with pointers,\n    formatting the value exactly as if it were an integer.\n\nThe default format for %v is:\n\n    bool:                    %t\n    int, int8 etc.:          %d\n    uint, uint8 etc.:        %d, %#x if printed with %#v\n    float32, complex64, etc: %g\n    string:                  %s\n    chan:                    %p\n    pointer:                 %p\n\nFor compound objects, the elements are printed using these rules, recursively,\nlaid out like this:\n\n    struct:             {field0 field1 ...}\n    array, slice:       [elem0 elem1 ...]\n    maps:               map[key1:value1 key2:value2 ...]\n    pointer to above:   &{}, &[], &map[]\n\nWidth is specified by an optional decimal number immediately preceding the verb.\nIf absent, the width is whatever is necessary to represent the value. Precision\nis specified after the (optional) width by a period followed by a decimal\nnumber. If no period is present, a default precision is used. A period with no\nfollowing number specifies a precision of zero. Examples:\n\n    %f     default width, default precision\n    %9f    width 9, default precision\n    %.2f   default width, precision 2\n    %9.2f  width 9, precision 2\n    %9.f   width 9, precision 0\n\nWidth and precision are measured in units of Unicode code points, that is,\nrunes. (This differs from C's printf where the units are always measured in\nbytes.) Either or both of the flags may be replaced with the character '*',\ncausing their values to be obtained from the next operand (preceding the one to\nformat), which must be of type int.\n\nFor most values, width is the minimum number of runes to output, padding the\nformatted form with spaces if necessary.\n\nFor strings, byte slices and byte arrays, however, precision limits the length\nof the input to be formatted (not the size of the output), truncating if\nnecessary. Normally it is measured in runes, but for these types when formatted\nwith the %x or %X format it is measured in bytes.\n\nFor floating-point values, width sets the minimum width of the field and\nprecision sets the number of places after the decimal, if appropriate, except\nthat for %g/%G precision sets the maximum number of significant digits (trailing\nzeros are removed). For example, given 12.345 the format %6.3f prints 12.345\nwhile %.3g prints 12.3. The default precision for %e, %f and %#g is 6; for %g it\nis the smallest number of digits necessary to identify the value uniquely.\n\nFor complex numbers, the width and precision apply to the two components\nindependently and the result is parenthesized, so %f applied to 1.2+3.4i\nproduces (1.200000+3.400000i).\n\nWhen formatting a single integer code point or a rune string (type []rune)\nwith %q, invalid Unicode code points are changed to the Unicode replacement\ncharacter, U+FFFD, as in strconv.QuoteRune.\n\nOther flags:\n\n    '+'\talways print a sign for numeric values;\n    \tguarantee ASCII-only output for %q (%+q)\n    '-'\tpad with spaces on the right rather than the left (left-justify the field)\n    '#'\talternate format: add leading 0b for binary (%#b), 0 for octal (%#o),\n    \t0x or 0X for hex (%#x or %#X); suppress 0x for %p (%#p);\n    \tfor %q, print a raw (backquoted) string if [strconv.CanBackquote]\n    \treturns true;\n    \talways print a decimal point for %e, %E, %f, %F, %g and %G;\n    \tdo not remove trailing zeros for %g and %G;\n    \twrite e.g. U+0078 'x' if the character is printable for %U (%#U)\n    ' '\t(space) leave a space for elided sign in numbers (% d);\n    \tput spaces between bytes printing strings or slices in hex (% x, % X)\n    '0'\tpad with leading zeros rather than spaces;\n    \tfor numbers, this moves the padding after the sign\n\nFlags are ignored by verbs that do not expect them. For example there is no\nalternate decimal format, so %#d and %d behave identically.\n\nFor each Printf-like function, there is also a Print function that takes no\nformat and is equivalent to saying %v for every operand. Another variant Println\ninserts blanks between operands and appends a newline.\n\nRegardless of the verb, if an operand is an interface value, the internal\nconcrete value is used, not the interface itself. Thus:\n\n    var i interface{} = 23\n    fmt.Printf(\"%v\\n\", i)\n\nwill print 23.\n\nExcept when printed using the verbs %T and %p, special formatting considerations\napply for operands that implement certain interfaces. In order of application:\n\n1. If the operand is a reflect.Value, the operand is replaced by the concrete\nvalue that it holds, and printing continues with the next rule.\n\n2. If an operand implements the Formatter interface, it will be invoked. In this\ncase the interpretation of verbs and flags is controlled by that implementation.\n\n3. If the %v verb is used with the # flag (%#v) and the operand implements the\nGoStringer interface, that will be invoked.\n\nIf the format (which is implicitly %v for Println etc.) is valid for a string\n(%s %q %x %X), or is %v but not %#v, the following two rules apply:\n\n4. If an operand implements the error interface, the Error method will be\ninvoked to convert the object to a string, which will then be formatted as\nrequired by the verb (if any).\n\n5. If an operand implements method String() string, that method will be invoked\nto convert the object to a string, which will then be formatted as required by\nthe verb (if any).\n\nFor compound operands such as slices and structs, the format applies to the\nelements of each operand, recursively, not to the operand as a whole. Thus %q\nwill quote each element of a slice of strings, and %6.2f will control formatting\nfor each element of a floating-point array.\n\nHowever, when printing a byte slice with a string-like verb (%s %q %x %X),\nit is treated identically to a string, as a single item.\n\nTo avoid recursion in cases such as\n\n    type X string\n    func (x X) String() string { return Sprintf(\"<%s>\", x) }\n\nconvert the value before recurring:\n\n    func (x X) String() string { return Sprintf(\"<%s>\", string(x)) }\n\nInfinite recursion can also be triggered by self-referential data structures,\nsuch as a slice that contains itself as an element, if that type has a String\nmethod. Such pathologies are rare, however, and the package does not protect\nagainst them.\n\nWhen printing a struct, fmt cannot and therefore does not invoke formatting\nmethods such as Error or String on unexported fields.\n\n# Explicit argument indexes\n\nIn Printf, Sprintf, and Fprintf, the default behavior is for each formatting\nverb to format successive arguments passed in the call. However, the notation\n[n] immediately before the verb indicates that the nth one-indexed argument\nis to be formatted instead. The same notation before a '*' for a width or\nprecision selects the argument index holding the value. After processing a\nbracketed expression [n], subsequent verbs will use arguments n+1, n+2, etc.\nunless otherwise directed.\n\nFor example,\n\n    fmt.Sprintf(\"%[2]d %[1]d\\n\", 11, 22)\n\nwill yield \"22 11\", while\n\n    fmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6)\n\nequivalent to\n\n    fmt.Sprintf(\"%6.2f\", 12.0)\n\nwill yield \" 12.00\". Because an explicit index affects subsequent verbs,\nthis notation can be used to print the same values multiple times by resetting\nthe index for the first argument to be repeated:\n\n    fmt.Sprintf(\"%d %d %#[1]x %#x\", 16, 17)\n\nwill yield \"16 17 0x10 0x11\".\n\n# Format errors\n\nIf an invalid argument is given for a verb, such as providing a string to %d,\nthe generated string will contain a description of the problem, as in these\nexamples:\n\n    Wrong type or unknown verb: %!verb(type=value)\n    \tPrintf(\"%d\", \"hi\"):        %!d(string=hi)\n    Too many arguments: %!(EXTRA type=value)\n    \tPrintf(\"hi\", \"guys\"):      hi%!(EXTRA string=guys)\n    Too few arguments: %!verb(MISSING)\n    \tPrintf(\"hi%d\"):            hi%!d(MISSING)\n    Non-int for width or precision: %!(BADWIDTH) or %!(BADPREC)\n    \tPrintf(\"%*s\", 4.5, \"hi\"):  %!(BADWIDTH)hi\n    \tPrintf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi\n    Invalid or invalid use of argument index: %!(BADINDEX)\n    \tPrintf(\"%*[2]d\", 7):       %!d(BADINDEX)\n    \tPrintf(\"%.[2]d\", 7):       %!d(BADINDEX)\n\nAll errors begin with the string \"%!\" followed sometimes by a single character\n(the verb) and end with a parenthesized description.\n\nIf an Error or String method triggers a panic when called by a print routine,\nthe fmt package reformats the error message from the panic, decorating it with\nan indication that it came through the fmt package. For example, if a String\nmethod calls panic(\"bad\"), the resulting formatted message will look like\n\n    %!s(PANIC=bad)\n\nThe %!s just shows the print verb in use when the failure occurred. If the panic\nis caused by a nil receiver to an Error, String, or GoString method, however,\nthe output is the undecorated string, \"<nil>\".\n\n# Scanning\n\nAn analogous set of functions scans formatted text to yield values. Scan, Scanf\nand Scanln read from os.Stdin; Fscan, Fscanf and Fscanln read from a specified\nio.Reader; Sscan, Sscanf and Sscanln read from an argument string.\n\nScan, Fscan, Sscan treat newlines in the input as spaces.\n\nScanln, Fscanln and Sscanln stop scanning at a newline and require that the\nitems be followed by a newline or EOF.\n\nScanf, Fscanf, and Sscanf parse the arguments according to a format string,\nanalogous to that of Printf. In the text that follows, 'space' means any Unicode\nwhitespace character except newline.\n\nIn the format string, a verb introduced by the % character consumes and parses\ninput; these verbs are described in more detail below. A character other than %,\nspace, or newline in the format consumes exactly that input character, which\nmust be present. A newline with zero or more spaces before it in the format\nstring consumes zero or more spaces in the input followed by a single newline or\nthe end of the input. A space following a newline in the format string consumes\nzero or more spaces in the input. Otherwise, any run of one or more spaces in\nthe format string consumes as many spaces as possible in the input. Unless the\nrun of spaces in the format string appears adjacent to a newline, the run must\nconsume at least one space from the input or find the end of the input.\n\nThe handling of spaces and newlines differs from that of C's scanf family: in C,\nnewlines are treated as any other space, and it is never an error when a run of\nspaces in the format string finds no spaces to consume in the input.\n\nThe verbs behave analogously to those of Printf. For example, %x will scan an\ninteger as a hexadecimal number, and %v will scan the default representation\nformat for the value. The Printf verbs %p and %T and the flags # and + are not\nimplemented. For floating-point and complex values, all valid formatting verbs\n(%b %e %E %f %F %g %G %x %X and %v) are equivalent and accept both decimal and\nhexadecimal notation (for example: \"2.3e+7\", \"0x4.5p-8\") and digit-separating\nunderscores (for example: \"3.14159_26535_89793\").\n\nInput processed by verbs is implicitly space-delimited: the implementation of\nevery verb except %c starts by discarding leading spaces from the remaining\ninput, and the %s verb (and %v reading into a string) stops consuming input at\nthe first space or newline character.\n\nThe familiar base-setting prefixes 0b (binary), 0o and 0 (octal), and 0x\n(hexadecimal) are accepted when scanning integers without a format or with the\n%v verb, as are digit-separating underscores.\n\nWidth is interpreted in the input text but there is no syntax for scanning with\na precision (no %5.2f, just %5f). If width is provided, it applies after leading\nspaces are trimmed and specifies the maximum number of runes to read to satisfy\nthe verb. For example,\n\n    Sscanf(\" 1234567 \", \"%5s%d\", &s, &i)\n\nwill set s to \"12345\" and i to 67 while\n\n    Sscanf(\" 12 34 567 \", \"%5s%d\", &s, &i)\n\nwill set s to \"12\" and i to 34.\n\nIn all the scanning functions, a carriage return followed immediately by a\nnewline is treated as a plain newline (\\r\\n means the same as \\n).\n\nIn all the scanning functions, if an operand implements method Scan (that is,\nit implements the Scanner interface) that method will be used to scan the text\nfor that operand. Also, if the number of arguments scanned is less than the\nnumber of arguments provided, an error is returned.\n\nAll arguments to be scanned must be either pointers to basic types or\nimplementations of the Scanner interface.\n\nLike Scanf and Fscanf, Sscanf need not consume its entire input. There is no way\nto recover how much of the input string Sscanf used.\n\nNote: Fscan etc. can read one character (rune) past the input they return,\nwhich means that a loop calling a scan routine may skip some of the input.\nThis is usually a problem only when there is no space between input values.\nIf the reader provided to Fscan implements ReadRune, that method will be used\nto read characters. If the reader also implements UnreadRune, that method\nwill be used to save the character and successive calls will not lose data.\nTo attach ReadRune and UnreadRune methods to a reader without that capability,\nuse bufio.NewReader.\n\nFUNCTIONS\n\nfunc Append(b []byte, a ...any) []byte\n    Append formats using the default formats for its operands, appends the\n    result to the byte slice, and returns the updated slice.\n\nfunc Appendf(b []byte, format string, a ...any) []byte\n    Appendf formats according to a format specifier, appends the result to the\n    byte slice, and returns the updated slice.\n\nfunc Appendln(b []byte, a ...any) []byte\n    Appendln formats using the default formats for its operands, appends the\n    result to the byte slice, and returns the updated slice. Spaces are always\n    added between operands and a newline is appended.\n\nfunc Errorf(format string, a ...any) error\n    Errorf formats according to a format specifier and returns the string as a\n    value that satisfies error.\n\n    If the format specifier includes a %w verb with an error operand,\n    the returned error will implement an Unwrap method returning the operand.\n    If there is more than one %w verb, the returned error will implement an\n    Unwrap method returning a []error containing all the %w operands in the\n    order they appear in the arguments. It is invalid to supply the %w verb\n    with an operand that does not implement the error interface. The %w verb is\n    otherwise a synonym for %v.\n\nfunc FormatString(state State, verb rune) string\n    FormatString returns a string representing the fully qualified formatting\n    directive captured by the State, followed by the argument verb. (State\n    does not itself contain the verb.) The result has a leading percent sign\n    followed by any flags, the width, and the precision. Missing flags, width,\n    and precision are omitted. This function allows a Formatter to reconstruct\n    the original directive triggering the call to Format.\n\nfunc Fprint(w io.Writer, a ...any) (n int, err error)\n    Fprint formats using the default formats for its operands and writes to w.\n    Spaces are added between operands when neither is a string. It returns the\n    number of bytes written and any write error encountered.\n\nfunc Fprintf(w io.Writer, format string, a ...any) (n int, err error)\n    Fprintf formats according to a format specifier and writes to w. It returns\n    the number of bytes written and any write error encountered.\n\nfunc Fprintln(w io.Writer, a ...any) (n int, err error)\n    Fprintln formats using the default formats for its operands and writes to w.\n    Spaces are always added between operands and a newline is appended.\n    It returns the number of bytes written and any write error encountered.\n\nfunc Fscan(r io.Reader, a ...any) (n int, err error)\n    Fscan scans text read from r, storing successive space-separated values\n    into successive arguments. Newlines count as space. It returns the number of\n    items successfully scanned. If that is less than the number of arguments,\n    err will report why.\n\nfunc Fscanf(r io.Reader, format string, a ...any) (n int, err error)\n    Fscanf scans text read from r, storing successive space-separated values\n    into successive arguments as determined by the format. It returns the number\n    of items successfully parsed. Newlines in the input must match newlines in\n    the format.\n\nfunc Fscanln(r io.Reader, a ...any) (n int, err error)\n    Fscanln is similar to Fscan, but stops scanning at a newline and after the\n    final item there must be a newline or EOF.\n\nfunc Print(a ...any) (n int, err error)\n    Print formats using the default formats for its operands and writes to\n    standard output. Spaces are added between operands when neither is a string.\n    It returns the number of bytes written and any write error encountered.\n\nfunc Printf(format string, a ...any) (n int, err error)\n    Printf formats according to a format specifier and writes to standard\n    output. It returns the number of bytes written and any write error\n    encountered.\n\nfunc Println(a ...any) (n int, err error)\n    Println formats using the default formats for its operands and writes to\n    standard output. Spaces are always added between operands and a newline\n    is appended. It returns the number of bytes written and any write error\n    encountered.\n\nfunc Scan(a ...any) (n int, err error)\n    Scan scans text read from standard input, storing successive space-separated\n    values into successive arguments. Newlines count as space. It returns the\n    number of items successfully scanned. If that is less than the number of\n    arguments, err will report why.\n\nfunc Scanf(format string, a ...any) (n int, err error)\n    Scanf scans text read from standard input, storing successive\n    space-separated values into successive arguments as determined by the\n    format. It returns the number of items successfully scanned. If that is less\n    than the number of arguments, err will report why. Newlines in the input\n    must match newlines in the format. The one exception: the verb %c always\n    scans the next rune in the input, even if it is a space (or tab etc.) or\n    newline.\n\nfunc Scanln(a ...any) (n int, err error)\n    Scanln is similar to Scan, but stops scanning at a newline and after the\n    final item there must be a newline or EOF.\n\nfunc Sprint(a ...any) string\n    Sprint formats using the default formats for its operands and returns\n    the resulting string. Spaces are added between operands when neither is a\n    string.\n\nfunc Sprintf(format string, a ...any) string\n    Sprintf formats according to a format specifier and returns the resulting\n    string.\n\nfunc Sprintln(a ...any) string\n    Sprintln formats using the default formats for its operands and returns the\n    resulting string. Spaces are always added between operands and a newline is\n    appended.\n\nfunc Sscan(str string, a ...any) (n int, err error)\n    Sscan scans the argument string, storing successive space-separated values\n    into successive arguments. Newlines count as space. It returns the number of\n    items successfully scanned. If that is less than the number of arguments,\n    err will report why.\n\nfunc Sscanf(str string, format string, a ...any) (n int, err error)\n    Sscanf scans the argument string, storing successive space-separated values\n    into successive arguments as determined by the format. It returns the number\n    of items successfully parsed. Newlines in the input must match newlines in\n    the format.\n\nfunc Sscanln(str string, a ...any) (n int, err error)\n    Sscanln is similar to Sscan, but stops scanning at a newline and after the\n    final item there must be a newline or EOF.\n\n\nTYPES\n\ntype Formatter interface {\n\tFormat(f State, verb rune)\n}\n    Formatter is implemented by any value that has a Format method. The\n    implementation controls how State and rune are interpreted, and may call\n    Sprint or Fprint(f) etc. to generate its output.\n\ntype GoStringer interface {\n\tGoString() string\n}\n    GoStringer is implemented by any value that has a GoString method, which\n    defines the Go syntax for that value. The GoString method is used to print\n    values passed as an operand to a %#v format.\n\ntype ScanState interface {\n\t// ReadRune reads the next rune (Unicode code point) from the input.\n\t// If invoked during Scanln, Fscanln, or Sscanln, ReadRune() will\n\t// return EOF after returning the first '\\n' or when reading beyond\n\t// the specified width.\n\tReadRune() (r rune, size int, err error)\n\t// UnreadRune causes the next call to ReadRune to return the same rune.\n\tUnreadRune() error\n\t// SkipSpace skips space in the input. Newlines are treated appropriately\n\t// for the operation being performed; see the package documentation\n\t// for more information.\n\tSkipSpace()\n\t// Token skips space in the input if skipSpace is true, then returns the\n\t// run of Unicode code points c satisfying f(c).  If f is nil,\n\t// !unicode.IsSpace(c) is used; that is, the token will hold non-space\n\t// characters. Newlines are treated appropriately for the operation being\n\t// performed; see the package documentation for more information.\n\t// The returned slice points to shared data that may be overwritten\n\t// by the next call to Token, a call to a Scan function using the ScanState\n\t// as input, or when the calling Scan method returns.\n\tToken(skipSpace bool, f func(rune) bool) (token []byte, err error)\n\t// Width returns the value of the width option and whether it has been set.\n\t// The unit is Unicode code points.\n\tWidth() (wid int, ok bool)\n\t// Because ReadRune is implemented by the interface, Read should never be\n\t// called by the scanning routines and a valid implementation of\n\t// ScanState may choose always to return an error from Read.\n\tRead(buf []byte) (n int, err error)\n}\n    ScanState represents the scanner state passed to custom scanners. Scanners\n    may do rune-at-a-time scanning or ask the ScanState to discover the next\n    space-delimited token.\n\ntype Scanner interface {\n\tScan(state ScanState, verb rune) error\n}\n    Scanner is implemented by any value that has a Scan method, which scans\n    the input for the representation of a value and stores the result in the\n    receiver, which must be a pointer to be useful. The Scan method is called\n    for any argument to Scan, Scanf, or Scanln that implements it.\n\ntype State interface {\n\t// Write is the function to call to emit formatted output to be printed.\n\tWrite(b []byte) (n int, err error)\n\t// Width returns the value of the width option and whether it has been set.\n\tWidth() (wid int, ok bool)\n\t// Precision returns the value of the precision option and whether it has been set.\n\tPrecision() (prec int, ok bool)\n\n\t// Flag reports whether the flag c, a character, has been set.\n\tFlag(c int) bool\n}\n    State represents the printer state passed to custom formatters. It provides\n    access to the io.Writer interface plus information about the flags and\n    options for the operand's format specifier.\n\ntype Stringer interface {\n\tString() string\n}\n    Stringer is implemented by any value that has a String method, which defines\n    the \u201cnative\u201d format for that value. The String method is used to print\n    values passed as an operand to any format that accepts a string or to an\n    unformatted printer such as Print.\n\n"}, {"path": "stdlib/crypto-internal-fips140deps.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140deps", "content": "package fipsdeps // import \"crypto/internal/fips140deps\"\n\nPackage fipsdeps contains wrapper packages for internal APIs that are exposed\nto the FIPS module. Since modules are frozen upon validation and supported for\na number of future versions, APIs exposed by crypto/internal/fips140deps/...\nmust not be changed until the modules that use them are no longer supported.\n"}, {"path": "stdlib/internal-trace-internal-testgen.md", "category": "stdlib", "name": "stdlib/internal-trace-internal-testgen", "content": "package testgen // import \"internal/trace/internal/testgen\"\n\n\nVARIABLES\n\nvar (\n\tNoString = \"\"\n\tNoStack  = []trace.StackFrame{}\n)\n\nFUNCTIONS\n\nfunc Main(ver version.Version, f func(*Trace))\n\nTYPES\n\ntype Batch struct {\n\t// Has unexported fields.\n}\n    Batch represents an event batch.\n\nfunc (b *Batch) Event(name string, args ...any)\n    Event emits an event into a batch. name must correspond to one of the names\n    in Specs() result for the version that was passed to this trace. Callers\n    must omit the timestamp delta.\n\nfunc (b *Batch) RawEvent(typ tracev2.EventType, data []byte, args ...uint64)\n    RawEvent emits an event into a batch. name must correspond to one of the\n    names in Specs() result for the version that was passed to this trace.\n\ntype Generation struct {\n\t// Has unexported fields.\n}\n    Generation represents a single generation in the trace.\n\nfunc (g *Generation) Batch(thread trace.ThreadID, time Time) *Batch\n    Batch starts a new event batch in the trace data.\n\n    This is convenience function for generating correct batches.\n\nfunc (g *Generation) Stack(stk []trace.StackFrame) uint64\n    Stack registers a stack with the trace.\n\n    This is a convenience function for easily adding correct stacks to traces.\n\nfunc (g *Generation) String(s string) uint64\n    String registers a string with the trace.\n\n    This is a convenience function for easily adding correct strings to traces.\n\nfunc (g *Generation) Sync(freq uint64, time Time, mono uint64, wall time.Time)\n    Sync configures the sync batch for the generation. For go1.25 and later,\n    the time value is the timestamp of the EvClockSnapshot event. For earlier\n    version, the time value is the timestamp of the batch containing a lone\n    EvFrequency event.\n\ntype Seq uint64\n    Seq represents a sequence counter.\n\ntype Time uint64\n    Time represents a low-level trace timestamp (which does not necessarily\n    correspond to nanoseconds, like trace.Time does).\n\ntype Trace struct {\n\t// Has unexported fields.\n}\n    Trace represents an execution trace for testing.\n\n    It does a little bit of work to ensure that the produced trace is valid,\n    just for convenience. It mainly tracks batches and batch sizes (so they're\n    trivially correct), tracks strings and stacks, and makes sure emitted string\n    and stack batches are valid. That last part can be controlled by a few\n    options.\n\n    Otherwise, it performs no validation on the trace at all.\n\nfunc NewTrace(ver version.Version) *Trace\n    NewTrace creates a new trace.\n\nfunc (t *Trace) DisableTimestamps()\n    DisableTimestamps makes the timestamps for all events generated after this\n    call zero. Raw events are exempted from this because the caller has to pass\n    their own timestamp into those events anyway.\n\nfunc (t *Trace) ExpectFailure(pattern string)\n    ExpectFailure writes down that the trace should be broken. The caller must\n    provide a pattern matching the expected error produced by the parser.\n\nfunc (t *Trace) ExpectSuccess()\n    ExpectSuccess writes down that the trace should successfully parse.\n\nfunc (t *Trace) Generate() []byte\n    Generate creates a test file for the trace.\n\nfunc (t *Trace) Generation(gen uint64) *Generation\n    Generation creates a new trace generation.\n\n    This provides more structure than Event to allow for more easily creating\n    complex traces that are mostly or completely correct.\n\nfunc (t *Trace) RawEvent(typ tracev2.EventType, data []byte, args ...uint64)\n    RawEvent emits an event into the trace. name must correspond to one of the\n    names in Specs() result for the version that was passed to this trace.\n\n"}, {"path": "stdlib/maps.md", "category": "stdlib", "name": "stdlib/maps", "content": "package maps // import \"maps\"\n\nPackage maps defines various functions useful with maps of any type.\n\nThis package does not have any special handling for non-reflexive keys (keys k\nwhere k != k), such as floating-point NaNs.\n\nFUNCTIONS\n\nfunc All[Map ~map[K]V, K comparable, V any](m Map) iter.Seq2[K, V]\n    All returns an iterator over key-value pairs from m. The iteration order\n    is not specified and is not guaranteed to be the same from one call to the\n    next.\n\nfunc Clone[M ~map[K]V, K comparable, V any](m M) M\n    Clone returns a copy of m. This is a shallow clone: the new keys and values\n    are set using ordinary assignment.\n\nfunc Collect[K comparable, V any](seq iter.Seq2[K, V]) map[K]V\n    Collect collects key-value pairs from seq into a new map and returns it.\n\nfunc Copy[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2)\n    Copy copies all key/value pairs in src adding them to dst. When a key in src\n    is already present in dst, the value in dst will be overwritten by the value\n    associated with the key in src.\n\nfunc DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool)\n    DeleteFunc deletes any key/value pairs from m for which del returns true.\n\nfunc Equal[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool\n    Equal reports whether two maps contain the same key/value pairs. Values are\n    compared using ==.\n\nfunc EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool\n    EqualFunc is like Equal, but compares values using eq. Keys are still\n    compared with ==.\n\nfunc Insert[Map ~map[K]V, K comparable, V any](m Map, seq iter.Seq2[K, V])\n    Insert adds the key-value pairs from seq to m. If a key in seq already\n    exists in m, its value will be overwritten.\n\nfunc Keys[Map ~map[K]V, K comparable, V any](m Map) iter.Seq[K]\n    Keys returns an iterator over keys in m. The iteration order is not\n    specified and is not guaranteed to be the same from one call to the next.\n\nfunc Values[Map ~map[K]V, K comparable, V any](m Map) iter.Seq[V]\n    Values returns an iterator over values in m. The iteration order is not\n    specified and is not guaranteed to be the same from one call to the next.\n\n"}, {"path": "stdlib/go-types.md", "category": "stdlib", "name": "stdlib/go-types", "content": "package types // import \"go/types\"\n\nPackage types declares the data types and implements the algorithms for\ntype-checking of Go packages. Use Config.Check to invoke the type checker for a\npackage. Alternatively, create a new type checker with NewChecker and invoke it\nincrementally by calling Checker.Files.\n\nType-checking consists of several interdependent phases:\n\nName resolution maps each identifier (ast.Ident) in the program to the symbol\n(Object) it denotes. Use the Defs and Uses fields of Info or the Info.ObjectOf\nmethod to find the symbol for an identifier, and use the Implicits field of Info\nto find the symbol for certain other kinds of syntax node.\n\nConstant folding computes the exact constant value (constant.Value) of every\nexpression (ast.Expr) that is a compile-time constant. Use the Types field of\nInfo to find the results of constant folding for an expression.\n\nType deduction computes the type (Type) of every expression (ast.Expr) and\nchecks for compliance with the language specification. Use the Types field of\nInfo for the results of type deduction.\n\nApplications that need to type-check one or more complete packages of Go source\ncode may find it more convenient not to invoke the type checker directly but\ninstead to use the Load function in package golang.org/x/tools/go/packages.\n\nFor a tutorial, see https://go.dev/s/types-tutorial.\n\nVARIABLES\n\nvar Typ = []*Basic{\n\tInvalid: {Invalid, 0, \"invalid type\"},\n\n\tBool:          {Bool, IsBoolean, \"bool\"},\n\tInt:           {Int, IsInteger, \"int\"},\n\tInt8:          {Int8, IsInteger, \"int8\"},\n\tInt16:         {Int16, IsInteger, \"int16\"},\n\tInt32:         {Int32, IsInteger, \"int32\"},\n\tInt64:         {Int64, IsInteger, \"int64\"},\n\tUint:          {Uint, IsInteger | IsUnsigned, \"uint\"},\n\tUint8:         {Uint8, IsInteger | IsUnsigned, \"uint8\"},\n\tUint16:        {Uint16, IsInteger | IsUnsigned, \"uint16\"},\n\tUint32:        {Uint32, IsInteger | IsUnsigned, \"uint32\"},\n\tUint64:        {Uint64, IsInteger | IsUnsigned, \"uint64\"},\n\tUintptr:       {Uintptr, IsInteger | IsUnsigned, \"uintptr\"},\n\tFloat32:       {Float32, IsFloat, \"float32\"},\n\tFloat64:       {Float64, IsFloat, \"float64\"},\n\tComplex64:     {Complex64, IsComplex, \"complex64\"},\n\tComplex128:    {Complex128, IsComplex, \"complex128\"},\n\tString:        {String, IsString, \"string\"},\n\tUnsafePointer: {UnsafePointer, 0, \"Pointer\"},\n\n\tUntypedBool:    {UntypedBool, IsBoolean | IsUntyped, \"untyped bool\"},\n\tUntypedInt:     {UntypedInt, IsInteger | IsUntyped, \"untyped int\"},\n\tUntypedRune:    {UntypedRune, IsInteger | IsUntyped, \"untyped rune\"},\n\tUntypedFloat:   {UntypedFloat, IsFloat | IsUntyped, \"untyped float\"},\n\tUntypedComplex: {UntypedComplex, IsComplex | IsUntyped, \"untyped complex\"},\n\tUntypedString:  {UntypedString, IsString | IsUntyped, \"untyped string\"},\n\tUntypedNil:     {UntypedNil, IsUntyped, \"untyped nil\"},\n}\n    Typ contains the predeclared *Basic types indexed by their corresponding\n    BasicKind.\n\n    The *Basic type for Typ[Byte] will have the name \"uint8\". Use\n    Universe.Lookup(\"byte\").Type() to obtain the specific alias basic type named\n    \"byte\" (and analogous for \"rune\").\n\n\nFUNCTIONS\n\nfunc AssertableTo(V *Interface, T Type) bool\n    AssertableTo reports whether a value of type V can be asserted to have type\n    T.\n\n    The behavior of AssertableTo is unspecified in three cases:\n      - if T is Typ[Invalid]\n      - if V is a generalized interface; i.e., an interface that may only be\n        used as a type constraint in Go code\n      - if T is an uninstantiated generic type\n\nfunc AssignableTo(V, T Type) bool\n    AssignableTo reports whether a value of type V is assignable to a variable\n    of type T.\n\n    The behavior of AssignableTo is unspecified if V or T is Typ[Invalid] or an\n    uninstantiated generic type.\n\nfunc CheckExpr(fset *token.FileSet, pkg *Package, pos token.Pos, expr ast.Expr, info *Info) (err error)\n    CheckExpr type checks the expression expr as if it had appeared at position\n    pos of package pkg. Type information about the expression is recorded in\n    info. The expression may be an identifier denoting an uninstantiated generic\n    function or type.\n\n    If pkg == nil, the Universe scope is used and the provided position pos\n    is ignored. If pkg != nil, and pos is invalid, the package scope is used.\n    Otherwise, pos must belong to the package.\n\n    An error is returned if pos is not within the package or if the node cannot\n    be type-checked.\n\n    Note: Eval and CheckExpr should not be used instead of running Check to\n    compute types and values, but in addition to Check, as these functions\n    ignore the context in which an expression is used (e.g., an assignment).\n    Thus, top-level untyped constants will return an untyped type rather than\n    the respective context-specific type.\n\nfunc Comparable(T Type) bool\n    Comparable reports whether values of type T are comparable.\n\nfunc ConvertibleTo(V, T Type) bool\n    ConvertibleTo reports whether a value of type V is convertible to a value of\n    type T.\n\n    The behavior of ConvertibleTo is unspecified if V or T is Typ[Invalid] or an\n    uninstantiated generic type.\n\nfunc DefPredeclaredTestFuncs()\n    DefPredeclaredTestFuncs defines the assert and trace built-ins. These\n    built-ins are intended for debugging and testing of this package only.\n\nfunc ExprString(x ast.Expr) string\n    ExprString returns the (possibly shortened) string representation for x.\n    Shortened representations are suitable for user interfaces but may not\n    necessarily follow Go syntax.\n\nfunc Id(pkg *Package, name string) string\n    Id returns name if it is exported, otherwise it returns the name qualified\n    with the package path.\n\nfunc Identical(x, y Type) bool\n    Identical reports whether x and y are identical types. Receivers of\n    Signature types are ignored.\n\n    Predicates such as Identical, Implements, and Satisfies assume that both\n    operands belong to a consistent collection of symbols (Object values). For\n    example, two Named types can be identical only if their Named.Obj methods\n    return the same TypeName symbol. A collection of symbols is consistent if,\n    for each logical package whose path is P, the creation of those symbols\n    involved at most one call to NewPackage(P, ...). To ensure consistency,\n    use a single Importer for all loaded packages and their dependencies.\n    For more information, see https://github.com/golang/go/issues/57497.\n\nfunc IdenticalIgnoreTags(x, y Type) bool\n    IdenticalIgnoreTags reports whether x and y are identical types if tags are\n    ignored. Receivers of Signature types are ignored.\n\nfunc Implements(V Type, T *Interface) bool\n    Implements reports whether type V implements interface T.\n\n    The behavior of Implements is unspecified if V is Typ[Invalid] or an\n    uninstantiated generic type.\n\nfunc IsInterface(t Type) bool\n    IsInterface reports whether t is an interface type.\n\nfunc ObjectString(obj Object, qf Qualifier) string\n    ObjectString returns the string form of obj. The Qualifier controls the\n    printing of package-level objects, and may be nil.\n\nfunc Satisfies(V Type, T *Interface) bool\n    Satisfies reports whether type V satisfies the constraint T.\n\n    The behavior of Satisfies is unspecified if V is Typ[Invalid] or an\n    uninstantiated generic type.\n\nfunc SelectionString(s *Selection, qf Qualifier) string\n    SelectionString returns the string form of s. The Qualifier controls the\n    printing of package-level objects, and may be nil.\n\n    Examples:\n\n        \"field (T) f int\"\n        \"method (T) f(X) Y\"\n        \"method expr (T) f(X) Y\"\n\nfunc TypeString(typ Type, qf Qualifier) string\n    TypeString returns the string representation of typ. The Qualifier controls\n    the printing of package-level objects, and may be nil.\n\nfunc WriteExpr(buf *bytes.Buffer, x ast.Expr)\n    WriteExpr writes the (possibly shortened) string representation for x to\n    buf. Shortened representations are suitable for user interfaces but may not\n    necessarily follow Go syntax.\n\nfunc WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier)\n    WriteSignature writes the representation of the signature sig to buf,\n    without a leading \"func\" keyword. The Qualifier controls the printing of\n    package-level objects, and may be nil.\n\nfunc WriteType(buf *bytes.Buffer, typ Type, qf Qualifier)\n    WriteType writes the string representation of typ to buf. The Qualifier\n    controls the printing of package-level objects, and may be nil.\n\n\nTYPES\n\ntype Alias struct {\n\t// Has unexported fields.\n}\n    An Alias represents an alias type.\n\n    Alias types are created by alias declarations such as:\n\n        type A = int\n\n    The type on the right-hand side of the declaration can be accessed using\n    Alias.Rhs. This type may itself be an alias. Call Unalias to obtain the\n    first non-alias type in a chain of alias type declarations.\n\n    Like a defined (Named) type, an alias type has a name. Use the Alias.Obj\n    method to access its TypeName object.\n\n    Historically, Alias types were not materialized so that, in the example\n    above, A's type was represented by a Basic (int), not an Alias whose\n    Alias.Rhs is int. But Go 1.24 allows you to declare an alias type with type\n    parameters or arguments:\n\n        type Set[K comparable] = map[K]bool\n        s := make(Set[String])\n\n    and this requires that Alias types be materialized. Use the Alias.TypeParams\n    and Alias.TypeArgs methods to access them.\n\n    To ease the transition, the Alias type was introduced in go1.22,\n    but the type-checker would not construct values of this type unless the\n    GODEBUG=gotypesalias=1 environment variable was provided. Starting in\n    go1.23, this variable is enabled by default. This setting also causes the\n    predeclared type \"any\" to be represented as an Alias, not a bare Interface.\n\nfunc NewAlias(obj *TypeName, rhs Type) *Alias\n    NewAlias creates a new Alias type with the given type name and rhs. rhs must\n    not be nil.\n\nfunc (a *Alias) Obj() *TypeName\n    Obj returns the type name for the declaration defining the alias type a.\n    For instantiated types, this is same as the type name of the origin type.\n\nfunc (a *Alias) Origin() *Alias\n    Origin returns the generic Alias type of which a is an instance. If a is not\n    an instance of a generic alias, Origin returns a.\n\nfunc (a *Alias) Rhs() Type\n    Rhs returns the type R on the right-hand side of an alias declaration \"type\n    A = R\", which may be another alias.\n\nfunc (a *Alias) SetTypeParams(tparams []*TypeParam)\n    SetTypeParams sets the type parameters of the alias type a. The alias a must\n    not have type arguments.\n\nfunc (a *Alias) String() string\n\nfunc (a *Alias) TypeArgs() *TypeList\n    TypeArgs returns the type arguments used to instantiate the Alias type.\n    If a is not an instance of a generic alias, the result is nil.\n\nfunc (a *Alias) TypeParams() *TypeParamList\n    TypeParams returns the type parameters of the alias type a, or nil.\n    A generic Alias and its instances have the same type parameters.\n\nfunc (a *Alias) Underlying() Type\n    Underlying returns the underlying type of the alias type a, which is the\n    underlying type of the aliased type. Underlying types are never Named,\n    TypeParam, or Alias types.\n\n[underlying type]: https://go.dev/ref/spec#Underlying_types.\n\ntype ArgumentError struct {\n\tIndex int\n\tErr   error\n}\n    An ArgumentError holds an error associated with an argument index.\n\nfunc (e *ArgumentError) Error() string\n\nfunc (e *ArgumentError) Unwrap() error\n\ntype Array struct {\n\t// Has unexported fields.\n}\n    An Array represents an array type.\n\nfunc NewArray(elem Type, len int64) *Array\n    NewArray returns a new array type for the given element type and length.\n    A negative length indicates an unknown length.\n\nfunc (a *Array) Elem() Type\n    Elem returns element type of array a.\n\nfunc (a *Array) Len() int64\n    Len returns the length of array a. A negative result indicates an unknown\n    length.\n\nfunc (a *Array) String() string\n\nfunc (a *Array) Underlying() Type\n\ntype Basic struct {\n\t// Has unexported fields.\n}\n    A Basic represents a basic type.\n\nfunc (b *Basic) Info() BasicInfo\n    Info returns information about properties of basic type b.\n\nfunc (b *Basic) Kind() BasicKind\n    Kind returns the kind of basic type b.\n\nfunc (b *Basic) Name() string\n    Name returns the name of basic type b.\n\nfunc (b *Basic) String() string\n\nfunc (b *Basic) Underlying() Type\n\ntype BasicInfo int\n    BasicInfo is a set of flags describing properties of a basic type.\n\nconst (\n\tIsBoolean BasicInfo = 1 << iota\n\tIsInteger\n\tIsUnsigned\n\tIsFloat\n\tIsComplex\n\tIsString\n\tIsUntyped\n\n\tIsOrdered   = IsInteger | IsFloat | IsString\n\tIsNumeric   = IsInteger | IsFloat | IsComplex\n\tIsConstType = IsBoolean | IsNumeric | IsString\n)\n    Properties of basic types.\n\ntype BasicKind int\n    BasicKind describes the kind of basic type.\n\nconst (\n\tInvalid BasicKind = iota // type is invalid\n\n\t// predeclared types\n\tBool\n\tInt\n\tInt8\n\tInt16\n\tInt32\n\tInt64\n\tUint\n\tUint8\n\tUint16\n\tUint32\n\tUint64\n\tUintptr\n\tFloat32\n\tFloat64\n\tComplex64\n\tComplex128\n\tString\n\tUnsafePointer\n\n\t// types for untyped values\n\tUntypedBool\n\tUntypedInt\n\tUntypedRune\n\tUntypedFloat\n\tUntypedComplex\n\tUntypedString\n\tUntypedNil\n\n\t// aliases\n\tByte = Uint8\n\tRune = Int32\n)\ntype Builtin struct {\n\t// Has unexported fields.\n}\n    A Builtin represents a built-in function. Builtins don't have a valid type.\n\nfunc (obj *Builtin) Exported() bool\n    Exported reports whether the object is exported (starts with a capital\n    letter). It doesn't take into account whether the object is in a local\n    (function) scope or not.\n\nfunc (obj *Builtin) Id() string\n    Id is a wrapper for Id(obj.Pkg(), obj.Name()).\n\nfunc (obj *Builtin) Name() string\n    Name returns the object's (package-local, unqualified) name.\n\nfunc (obj *Builtin) Parent() *Scope\n    Parent returns the scope in which the object is declared. The result is nil\n    for methods and struct fields.\n\nfunc (obj *Builtin) Pkg() *Package\n    Pkg returns the package to which the object belongs. The result is nil for\n    labels and objects in the Universe scope.\n\nfunc (obj *Builtin) Pos() token.Pos\n    Pos returns the declaration position of the object's identifier.\n\nfunc (obj *Builtin) String() string\n\nfunc (obj *Builtin) Type() Type\n    Type returns the object's type.\n\ntype Chan struct {\n\t// Has unexported fields.\n}\n    A Chan represents a channel type.\n\nfunc NewChan(dir ChanDir, elem Type) *Chan\n    NewChan returns a new channel type for the given direction and element type.\n\nfunc (c *Chan) Dir() ChanDir\n    Dir returns the direction of channel c.\n\nfunc (c *Chan) Elem() Type\n    Elem returns the element type of channel c.\n\nfunc (c *Chan) String() string\n\nfunc (c *Chan) Underlying() Type\n\ntype ChanDir int\n    A ChanDir value indicates a channel direction.\n\nconst (\n\tSendRecv ChanDir = iota\n\tSendOnly\n\tRecvOnly\n)\n    The direction of a channel is indicated by one of these constants.\n\ntype Checker struct {\n\t*Info\n\n\t// Has unexported fields.\n}\n    A Checker maintains the state of the type checker. It must be created with\n    NewChecker.\n\nfunc NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker\n    NewChecker returns a new Checker instance for a given package. Package files\n    may be added incrementally via checker.Files.\n\nfunc (check *Checker) Files(files []*ast.File) (err error)\n    Files checks the provided files as part of the checker's package.\n\ntype Config struct {\n\t// Context is the context used for resolving global identifiers. If nil, the\n\t// type checker will initialize this field with a newly created context.\n\tContext *Context\n\n\t// GoVersion describes the accepted Go language version. The string must\n\t// start with a prefix of the form \"go%d.%d\" (e.g. \"go1.20\", \"go1.21rc1\", or\n\t// \"go1.21.0\") or it must be empty; an empty string disables Go language\n\t// version checks. If the format is invalid, invoking the type checker will\n\t// result in an error.\n\tGoVersion string\n\n\t// If IgnoreFuncBodies is set, function bodies are not\n\t// type-checked.\n\tIgnoreFuncBodies bool\n\n\t// If FakeImportC is set, `import \"C\"` (for packages requiring Cgo)\n\t// declares an empty \"C\" package and errors are omitted for qualified\n\t// identifiers referring to package C (which won't find an object).\n\t// This feature is intended for the standard library cmd/api tool.\n\t//\n\t// Caution: Effects may be unpredictable due to follow-on errors.\n\t//          Do not use casually!\n\tFakeImportC bool\n\n\t// If Error != nil, it is called with each error found\n\t// during type checking; err has dynamic type Error.\n\t// Secondary errors (for instance, to enumerate all types\n\t// involved in an invalid recursive type declaration) have\n\t// error strings that start with a '\\t' character.\n\t// If Error == nil, type-checking stops with the first\n\t// error found.\n\tError func(err error)\n\n\t// An importer is used to import packages referred to from\n\t// import declarations.\n\t// If the installed importer implements ImporterFrom, the type\n\t// checker calls ImportFrom instead of Import.\n\t// The type checker reports an error if an importer is needed\n\t// but none was installed.\n\tImporter Importer\n\n\t// If Sizes != nil, it provides the sizing functions for package unsafe.\n\t// Otherwise SizesFor(\"gc\", \"amd64\") is used instead.\n\tSizes Sizes\n\n\t// If DisableUnusedImportCheck is set, packages are not checked\n\t// for unused imports.\n\tDisableUnusedImportCheck bool\n\n\t// Has unexported fields.\n}\n    A Config specifies the configuration for type checking. The zero value for\n    Config is a ready-to-use default configuration.\n\nfunc (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, info *Info) (*Package, error)\n    Check type-checks a package and returns the resulting package object and the\n    first error if any. Additionally, if info != nil, Check populates each of\n    the non-nil maps in the Info struct.\n\n    The package is marked as complete if no errors occurred, otherwise it is\n    incomplete. See [Config.Error] for controlling behavior in the presence of\n    errors.\n\n    The package is specified by a list of *ast.Files and corresponding file set,\n    and the package path the package is identified with. The clean path must not\n    be empty or dot (\".\").\n\ntype Const struct {\n\t// Has unexported fields.\n}\n    A Const represents a declared constant.\n\nfunc NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const\n    NewConst returns a new constant with value val. The remaining arguments set\n    the attributes found with all Objects.\n\nfunc (obj *Const) Exported() bool\n    Exported reports whether the object is exported (starts with a capital\n    letter). It doesn't take into account whether the object is in a local\n    (function) scope or not.\n\nfunc (obj *Const) Id() string\n    Id is a wrapper for Id(obj.Pkg(), obj.Name()).\n\nfunc (obj *Const) Name() string\n    Name returns the object's (package-local, unqualified) name.\n\nfunc (obj *Const) Parent() *Scope\n    Parent returns the scope in which the object is declared. The result is nil\n    for methods and struct fields.\n\nfunc (obj *Const) Pkg() *Package\n    Pkg returns the package to which the object belongs. The result is nil for\n    labels and objects in the Universe scope.\n\nfunc (obj *Const) Pos() token.Pos\n    Pos returns the declaration position of the object's identifier.\n\nfunc (obj *Const) String() string\n\nfunc (obj *Const) Type() Type\n    Type returns the object's type.\n\nfunc (obj *Const) Val() constant.Value\n    Val returns the constant's value.\n\ntype Context struct {\n\t// Has unexported fields.\n}\n    A Context is an opaque type checking context. It may be used to share\n    identical type instances across type-checked packages or calls to\n    Instantiate. Contexts are safe for concurrent use.\n\n    The use of a shared context does not guarantee that identical instances are\n    deduplicated in all cases.\n\nfunc NewContext() *Context\n    NewContext creates a new Context.\n\ntype Error struct {\n\tFset *token.FileSet // file set for interpretation of Pos\n\tPos  token.Pos      // error position\n\tMsg  string         // error message\n\tSoft bool           // if set, error is \"soft\"\n\n\t// Has unexported fields.\n}\n    An Error describes a type-checking error; it implements the error interface.\n    A \"soft\" error is an error that still permits a valid interpretation of a\n    package (such as \"unused variable\"); \"hard\" errors may lead to unpredictable\n    behavior if ignored.\n\nfunc (err Error) Error() string\n    Error returns an error string formatted as follows: filename:line:column:\n    message\n\ntype Func struct {\n\t// Has unexported fields.\n}\n    A Func represents a declared function, concrete method, or abstract\n    (interface) method. Its Type() is always a *Signature. An abstract method\n    may belong to many interfaces due to embedding.\n\nfunc MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)\n    MissingMethod returns (nil, false) if V implements T, otherwise it returns a\n    missing method required by T and whether it is missing or just has the wrong\n    type: either a pointer receiver or wrong signature.\n\n    For non-interface types V, or if static is set, V implements T if all\n    methods of T are present in V. Otherwise (V is an interface and static is\n    not set), MissingMethod only checks that methods of T which are also present\n    in V have matching types (e.g., for a type assertion x.(T) where x is of\n    interface type V).\n\nfunc NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func\n    NewFunc returns a new function with the given signature, representing the\n    function's type.\n\nfunc (obj *Func) Exported() bool\n    Exported reports whether the object is exported (starts with a capital\n    letter). It doesn't take into account whether the object is in a local\n    (function) scope or not.\n\nfunc (obj *Func) FullName() string\n    FullName returns the package- or receiver-type-qualified name of function or\n    method obj.\n\nfunc (obj *Func) Id() string\n    Id is a wrapper for Id(obj.Pkg(), obj.Name()).\n\nfunc (obj *Func) Name() string\n    Name returns the object's (package-local, unqualified) name.\n\nfunc (obj *Func) Origin() *Func\n    Origin returns the canonical Func for its receiver, i.e. the Func object\n    recorded in Info.Defs.\n\n    For synthetic functions created during instantiation (such as methods on an\n    instantiated Named type or interface methods that depend on type arguments),\n    this will be the corresponding Func on the generic (uninstantiated) type.\n    For all other Funcs Origin returns the receiver.\n\nfunc (obj *Func) Parent() *Scope\n    Parent returns the scope in which the object is declared. The result is nil\n    for methods and struct fields.\n\nfunc (obj *Func) Pkg() *Package\n    Pkg returns the package to which the function belongs.\n\n    The result is nil for methods of types in the Universe scope, like method\n    Error of the error built-in interface type.\n\nfunc (obj *Func) Pos() token.Pos\n    Pos returns the declaration position of the object's identifier.\n\nfunc (obj *Func) Scope() *Scope\n    Scope returns the scope of the function's body block. The result is nil\n    for imported or instantiated functions and methods (but there is also no\n    mechanism to get to an instantiated function).\n\nfunc (obj *Func) Signature() *Signature\n    Signature returns the signature (type) of the function or method.\n\nfunc (obj *Func) String() string\n\nfunc (obj *Func) Type() Type\n    Type returns the object's type.\n\ntype ImportMode int\n    ImportMode is reserved for future use.\n\ntype Importer interface {\n\t// Import returns the imported package for the given import path.\n\t// The semantics is like for ImporterFrom.ImportFrom except that\n\t// dir and mode are ignored (since they are not present).\n\tImport(path string) (*Package, error)\n}\n    An Importer resolves import paths to Packages.\n\n    CAUTION: This interface does not support the import of locally vendored\n    packages. See https://golang.org/s/go15vendor. If possible, external\n    implementations should implement ImporterFrom.\n\ntype ImporterFrom interface {\n\t// Importer is present for backward-compatibility. Calling\n\t// Import(path) is the same as calling ImportFrom(path, \"\", 0);\n\t// i.e., locally vendored packages may not be found.\n\t// The types package does not call Import if an ImporterFrom\n\t// is present.\n\tImporter\n\n\t// ImportFrom returns the imported package for the given import\n\t// path when imported by a package file located in dir.\n\t// If the import failed, besides returning an error, ImportFrom\n\t// is encouraged to cache and return a package anyway, if one\n\t// was created. This will reduce package inconsistencies and\n\t// follow-on type checker errors due to the missing package.\n\t// The mode value must be 0; it is reserved for future use.\n\t// Two calls to ImportFrom with the same path and dir must\n\t// return the same package.\n\tImportFrom(path, dir string, mode ImportMode) (*Package, error)\n}\n    An ImporterFrom resolves import paths to packages; it supports vendoring per\n    https://golang.org/s/go15vendor. Use go/importer to obtain an ImporterFrom\n    implementation.\n\ntype Info struct {\n\t// Types maps expressions to their types, and for constant\n\t// expressions, also their values. Invalid expressions are\n\t// omitted.\n\t//\n\t// For (possibly parenthesized) identifiers denoting built-in\n\t// functions, the recorded signatures are call-site specific:\n\t// if the call result is not a constant, the recorded type is\n\t// an argument-specific signature. Otherwise, the recorded type\n\t// is invalid.\n\t//\n\t// The Types map does not record the type of every identifier,\n\t// only those that appear where an arbitrary expression is\n\t// permitted. For instance:\n\t// - an identifier f in a selector expression x.f is found\n\t//   only in the Selections map;\n\t// - an identifier z in a variable declaration 'var z int'\n\t//   is found only in the Defs map;\n\t// - an identifier p denoting a package in a qualified\n\t//   identifier p.X is found only in the Uses map.\n\t//\n\t// Similarly, no type is recorded for the (synthetic) FuncType\n\t// node in a FuncDecl.Type field, since there is no corresponding\n\t// syntactic function type expression in the source in this case\n\t// Instead, the function type is found in the Defs map entry for\n\t// the corresponding function declaration.\n\tTypes map[ast.Expr]TypeAndValue\n\n\t// Instances maps identifiers denoting generic types or functions to their\n\t// type arguments and instantiated type.\n\t//\n\t// For example, Instances will map the identifier for 'T' in the type\n\t// instantiation T[int, string] to the type arguments [int, string] and\n\t// resulting instantiated *Named type. Given a generic function\n\t// func F[A any](A), Instances will map the identifier for 'F' in the call\n\t// expression F(int(1)) to the inferred type arguments [int], and resulting\n\t// instantiated *Signature.\n\t//\n\t// Invariant: Instantiating Uses[id].Type() with Instances[id].TypeArgs\n\t// results in an equivalent of Instances[id].Type.\n\tInstances map[*ast.Ident]Instance\n\n\t// Defs maps identifiers to the objects they define (including\n\t// package names, dots \".\" of dot-imports, and blank \"_\" identifiers).\n\t// For identifiers that do not denote objects (e.g., the package name\n\t// in package clauses, or symbolic variables t in t := x.(type) of\n\t// type switch headers), the corresponding objects are nil.\n\t//\n\t// For an embedded field, Defs returns the field *Var it defines.\n\t//\n\t// In ill-typed code, such as a duplicate declaration of the\n\t// same name, Defs may lack an entry for a declaring identifier.\n\t//\n\t// Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos()\n\tDefs map[*ast.Ident]Object\n\n\t// Uses maps identifiers to the objects they denote.\n\t//\n\t// For an embedded field, Uses returns the *TypeName it denotes.\n\t//\n\t// Invariant: Uses[id].Pos() != id.Pos()\n\tUses map[*ast.Ident]Object\n\n\t// Implicits maps nodes to their implicitly declared objects, if any.\n\t// The following node and object types may appear:\n\t//\n\t//     node               declared object\n\t//\n\t//     *ast.ImportSpec    *PkgName for imports without renames\n\t//     *ast.CaseClause    type-specific *Var for each type switch case clause (incl. default)\n\t//     *ast.Field         anonymous parameter *Var (incl. unnamed results)\n\t//\n\tImplicits map[ast.Node]Object\n\n\t// Selections maps selector expressions (excluding qualified identifiers)\n\t// to their corresponding selections.\n\tSelections map[*ast.SelectorExpr]*Selection\n\n\t// Scopes maps ast.Nodes to the scopes they define. Package scopes are not\n\t// associated with a specific node but with all files belonging to a package.\n\t// Thus, the package scope can be found in the type-checked Package object.\n\t// Scopes nest, with the Universe scope being the outermost scope, enclosing\n\t// the package scope, which contains (one or more) files scopes, which enclose\n\t// function scopes which in turn enclose statement and function literal scopes.\n\t// Note that even though package-level functions are declared in the package\n\t// scope, the function scopes are embedded in the file scope of the file\n\t// containing the function declaration.\n\t//\n\t// The Scope of a function contains the declarations of any\n\t// type parameters, parameters, and named results, plus any\n\t// local declarations in the body block.\n\t// It is coextensive with the complete extent of the\n\t// function's syntax ([*ast.FuncDecl] or [*ast.FuncLit]).\n\t// The Scopes mapping does not contain an entry for the\n\t// function body ([*ast.BlockStmt]); the function's scope is\n\t// associated with the [*ast.FuncType].\n\t//\n\t// The following node types may appear in Scopes:\n\t//\n\t//     *ast.File\n\t//     *ast.FuncType\n\t//     *ast.TypeSpec\n\t//     *ast.BlockStmt\n\t//     *ast.IfStmt\n\t//     *ast.SwitchStmt\n\t//     *ast.TypeSwitchStmt\n\t//     *ast.CaseClause\n\t//     *ast.CommClause\n\t//     *ast.ForStmt\n\t//     *ast.RangeStmt\n\t//\n\tScopes map[ast.Node]*Scope\n\n\t// InitOrder is the list of package-level initializers in the order in which\n\t// they must be executed. Initializers referring to variables related by an\n\t// initialization dependency appear in topological order, the others appear\n\t// in source order. Variables without an initialization expression do not\n\t// appear in this list.\n\tInitOrder []*Initializer\n\n\t// FileVersions maps a file to its Go version string.\n\t// If the file doesn't specify a version, the reported\n\t// string is Config.GoVersion.\n\t// Version strings begin with \u201cgo\u201d, like \u201cgo1.21\u201d, and\n\t// are suitable for use with the [go/version] package.\n\tFileVersions map[*ast.File]string\n}\n    Info holds result type information for a type-checked package. Only the\n    information for which a map is provided is collected. If the package has\n    type errors, the collected information may be incomplete.\n\nfunc (info *Info) ObjectOf(id *ast.Ident) Object\n    ObjectOf returns the object denoted by the specified id, or nil if not\n    found.\n\n    If id is an embedded struct field, Info.ObjectOf returns the field (*Var) it\n    defines, not the type (*TypeName) it uses.\n\n    Precondition: the Uses and Defs maps are populated.\n\nfunc (info *Info) PkgNameOf(imp *ast.ImportSpec) *PkgName\n    PkgNameOf returns the local package name defined by the import, or nil if\n    not found.\n\n    For dot-imports, the package name is \".\".\n\n    Precondition: the Defs and Implicts maps are populated.\n\nfunc (info *Info) TypeOf(e ast.Expr) Type\n    TypeOf returns the type of expression e, or nil if not found. Precondition:\n    the Types, Uses and Defs maps are populated.\n\ntype Initializer struct {\n\tLhs []*Var // var Lhs = Rhs\n\tRhs ast.Expr\n}\n    An Initializer describes a package-level variable, or a list of variables\n    in case of a multi-valued initialization expression, and the corresponding\n    initialization expression.\n\nfunc (init *Initializer) String() string\n\ntype Instance struct {\n\tTypeArgs *TypeList\n\tType     Type\n}\n    Instance reports the type arguments and instantiated type for type and\n    function instantiations. For type instantiations, Type will be of dynamic\n    type *Named. For function instantiations, Type will be of dynamic type\n    *Signature.\n\ntype Interface struct {\n\t// Has unexported fields.\n}\n    An Interface represents an interface type.\n\nfunc NewInterface(methods []*Func, embeddeds []*Named) *Interface\n    NewInterface returns a new interface for the given methods and embedded\n    types. NewInterface takes ownership of the provided methods and may modify\n    their types by setting missing receivers.\n\n    Deprecated: Use NewInterfaceType instead which allows arbitrary embedded\n    types.\n\nfunc NewInterfaceType(methods []*Func, embeddeds []Type) *Interface\n    NewInterfaceType returns a new interface for the given methods and embedded\n    types. NewInterfaceType takes ownership of the provided methods and may\n    modify their types by setting missing receivers.\n\n    To avoid race conditions, the interface's type set should be computed before\n    concurrent use of the interface, by explicitly calling Complete.\n\nfunc (t *Interface) Complete() *Interface\n    Complete computes the interface's type set. It must be called by users of\n    NewInterfaceType and NewInterface after the interface's embedded types are\n    fully defined and before using the interface type in any way other than\n    to form other types. The interface must not contain duplicate methods or a\n    panic occurs. Complete returns the receiver.\n\n    Interface types that have been completed are safe for concurrent use.\n\nfunc (t *Interface) Embedded(i int) *Named\n    Embedded returns the i'th embedded defined (*Named) type of interface t for\n    0 <= i < t.NumEmbeddeds(). The result is nil if the i'th embedded type is\n    not a defined type.\n\n    Deprecated: Use Interface.EmbeddedType which is not restricted to defined\n    (*Named) types.\n\nfunc (t *Interface) EmbeddedType(i int) Type\n    EmbeddedType returns the i'th embedded type of interface t for 0 <= i <\n    t.NumEmbeddeds().\n\nfunc (t *Interface) EmbeddedTypes() iter.Seq[Type]\n    EmbeddedTypes returns a go1.23 iterator over the types embedded within an\n    interface.\n\n    Example: for e := range t.EmbeddedTypes() { ... }\n\nfunc (t *Interface) Empty() bool\n    Empty reports whether t is the empty interface.\n\nfunc (t *Interface) ExplicitMethod(i int) *Func\n    ExplicitMethod returns the i'th explicitly declared method of interface t\n    for 0 <= i < t.NumExplicitMethods(). The methods are ordered by their unique\n    Id.\n\nfunc (t *Interface) ExplicitMethods() iter.Seq[*Func]\n    ExplicitMethods returns a go1.23 iterator over the explicit methods of an\n    interface, ordered by Id.\n\n    Example: for m := range t.ExplicitMethods() { ... }\n\nfunc (t *Interface) IsComparable() bool\n    IsComparable reports whether each type in interface t's type set is\n    comparable.\n\nfunc (t *Interface) IsImplicit() bool\n    IsImplicit reports whether the interface t is a wrapper for a type set\n    literal.\n\nfunc (t *Interface) IsMethodSet() bool\n    IsMethodSet reports whether the interface t is fully described by its method\n    set.\n\nfunc (t *Interface) MarkImplicit()\n    MarkImplicit marks the interface t as implicit, meaning this interface\n    corresponds to a constraint literal such as ~T or A|B without explicit\n    interface embedding. MarkImplicit should be called before any concurrent use\n    of implicit interfaces.\n\nfunc (t *Interface) Method(i int) *Func\n    Method returns the i'th method of interface t for 0 <= i < t.NumMethods().\n    The methods are ordered by their unique Id.\n\nfunc (t *Interface) Methods() iter.Seq[*Func]\n    Methods returns a go1.23 iterator over all the methods of an interface,\n    ordered by Id.\n\n    Example: for m := range t.Methods() { ... }\n\nfunc (t *Interface) NumEmbeddeds() int\n    NumEmbeddeds returns the number of embedded types in interface t.\n\nfunc (t *Interface) NumExplicitMethods() int\n    NumExplicitMethods returns the number of explicitly declared methods of\n    interface t.\n\nfunc (t *Interface) NumMethods() int\n    NumMethods returns the total number of methods of interface t.\n\nfunc (t *Interface) String() string\n\nfunc (t *Interface) Underlying() Type\n\ntype Label struct {\n\t// Has unexported fields.\n}\n    A Label represents a declared label. Labels don't have a type.\n\nfunc NewLabel(pos token.Pos, pkg *Package, name string) *Label\n    NewLabel returns a new label.\n\nfunc (obj *Label) Exported() bool\n    Exported reports whether the object is exported (starts with a capital\n    letter). It doesn't take into account whether the object is in a local\n    (function) scope or not.\n\nfunc (obj *Label) Id() string\n    Id is a wrapper for Id(obj.Pkg(), obj.Name()).\n\nfunc (obj *Label) Name() string\n    Name returns the object's (package-local, unqualified) name.\n\nfunc (obj *Label) Parent() *Scope\n    Parent returns the scope in which the object is declared. The result is nil\n    for methods and struct fields.\n\nfunc (obj *Label) Pkg() *Package\n    Pkg returns the package to which the object belongs. The result is nil for\n    labels and objects in the Universe scope.\n\nfunc (obj *Label) Pos() token.Pos\n    Pos returns the declaration position of the object's identifier.\n\nfunc (obj *Label) String() string\n\nfunc (obj *Label) Type() Type\n    Type returns the object's type.\n\ntype Map struct {\n\t// Has unexported fields.\n}\n    A Map represents a map type.\n\nfunc NewMap(key, elem Type) *Map\n    NewMap returns a new map for the given key and element types.\n\nfunc (m *Map) Elem() Type\n    Elem returns the element type of map m.\n\nfunc (m *Map) Key() Type\n    Key returns the key type of map m.\n\nfunc (t *Map) String() string\n\nfunc (t *Map) Underlying() Type\n\ntype MethodSet struct {\n\t// Has unexported fields.\n}\n    A MethodSet is an ordered set of concrete or abstract (interface) methods;\n    a method is a MethodVal selection, and they are ordered by ascending\n    m.Obj().Id(). The zero value for a MethodSet is a ready-to-use empty method\n    set.\n\nfunc NewMethodSet(T Type) *MethodSet\n    NewMethodSet returns the method set for the given type T. It always returns\n    a non-nil method set, even if it is empty.\n\nfunc (s *MethodSet) At(i int) *Selection\n    At returns the i'th method in s for 0 <= i < s.Len().\n\nfunc (s *MethodSet) Len() int\n    Len returns the number of methods in s.\n\nfunc (s *MethodSet) Lookup(pkg *Package, name string) *Selection\n    Lookup returns the method with matching package and name, or nil if not\n    found.\n\nfunc (s *MethodSet) Methods() iter.Seq[*Selection]\n    Methods returns a go1.23 iterator over the methods of a method set.\n\n    Example: for method := range s.Methods() { ... }\n\nfunc (s *MethodSet) String() string\n\ntype Named struct {\n\t// Has unexported fields.\n}\n    A Named represents a named (defined) type.\n\n    A declaration such as:\n\n        type S struct { ... }\n\n    creates a defined type whose underlying type is a struct, and binds this\n    type to the object S, a TypeName. Use Named.Underlying to access the\n    underlying type. Use Named.Obj to obtain the object S.\n\n    Before type aliases (Go 1.9), the spec called defined types \"named types\".\n\nfunc NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named\n    NewNamed returns a new named type for the given type name, underlying type,\n    and associated methods. If the given type name obj doesn't have a type yet,\n    its type is set to the returned named type. The underlying type must not be\n    a *Named.\n\nfunc (t *Named) AddMethod(m *Func)\n    AddMethod adds method m unless it is already in the method list. The method\n    must be in the same package as t, and t must not have type arguments.\n\nfunc (t *Named) Method(i int) *Func\n    Method returns the i'th method of named type t for 0 <= i < t.NumMethods().\n\n    For an ordinary or instantiated type t, the receiver base type of this\n    method is the named type t. For an uninstantiated generic type t, each\n    method receiver is instantiated with its receiver type parameters.\n\n    Methods are numbered deterministically: given the same list of source\n    files presented to the type checker, or the same sequence of NewMethod\n    and AddMethod calls, the mapping from method index to corresponding method\n    remains the same. But the specific ordering is not specified and must not be\n    relied on as it may change in the future.\n\nfunc (t *Named) Methods() iter.Seq[*Func]\n    Methods returns a go1.23 iterator over the declared methods of a named type.\n\n    Example: for m := range t.Methods() { ... }\n\nfunc (t *Named) NumMethods() int\n    NumMethods returns the number of explicit methods defined for t.\n\nfunc (t *Named) Obj() *TypeName\n    Obj returns the type name for the declaration defining the named type t.\n    For instantiated types, this is same as the type name of the origin type.\n\nfunc (t *Named) Origin() *Named\n    Origin returns the generic type from which the named type t is instantiated.\n    If t is not an instantiated type, the result is t.\n\nfunc (t *Named) SetTypeParams(tparams []*TypeParam)\n    SetTypeParams sets the type parameters of the named type t. t must not have\n    type arguments.\n\nfunc (t *Named) SetUnderlying(underlying Type)\n    SetUnderlying sets the underlying type and marks t as complete. t must not\n    have type arguments.\n\nfunc (t *Named) String() string\n\nfunc (t *Named) TypeArgs() *TypeList\n    TypeArgs returns the type arguments used to instantiate the named type t.\n\nfunc (t *Named) TypeParams() *TypeParamList\n    TypeParams returns the type parameters of the named type t, or nil.\n    The result is non-nil for an (originally) generic type even if it is\n    instantiated.\n\nfunc (t *Named) Underlying() Type\n    Underlying returns the underlying type of the named type t, resolving all\n    forwarding declarations. Underlying types are never Named, TypeParam,\n    or Alias types.\n\n[underlying type]: https://go.dev/ref/spec#Underlying_types.\n\ntype Nil struct {\n\t// Has unexported fields.\n}\n    Nil represents the predeclared value nil.\n\nfunc (obj *Nil) Exported() bool\n    Exported reports whether the object is exported (starts with a capital\n    letter). It doesn't take into account whether the object is in a local\n    (function) scope or not.\n\nfunc (obj *Nil) Id() string\n    Id is a wrapper for Id(obj.Pkg(), obj.Name()).\n\nfunc (obj *Nil) Name() string\n    Name returns the object's (package-local, unqualified) name.\n\nfunc (obj *Nil) Parent() *Scope\n    Parent returns the scope in which the object is declared. The result is nil\n    for methods and struct fields.\n\nfunc (obj *Nil) Pkg() *Package\n    Pkg returns the package to which the object belongs. The result is nil for\n    labels and objects in the Universe scope.\n\nfunc (obj *Nil) Pos() token.Pos\n    Pos returns the declaration position of the object's identifier.\n\nfunc (obj *Nil) String() string\n\nfunc (obj *Nil) Type() Type\n    Type returns the object's type.\n\ntype Object interface {\n\tParent() *Scope // scope in which this object is declared; nil for methods and struct fields\n\tPos() token.Pos // position of object identifier in declaration\n\tPkg() *Package  // package to which this object belongs; nil for labels and objects in the Universe scope\n\tName() string   // package local object name\n\tType() Type     // object type\n\tExported() bool // reports whether the name starts with a capital letter\n\tId() string     // object name if exported, qualified name if not exported (see func Id)\n\n\t// String returns a human-readable string of the object.\n\t// Use [ObjectString] to control how package names are formatted in the string.\n\tString() string\n\n\t// Has unexported methods.\n}\n    An Object is a named language entity. An Object may be a constant (Const),\n    type name (TypeName), variable or struct field (Var), function or method\n    (Func), imported package (PkgName), label (Label), built-in function\n    (Builtin), or the predeclared identifier 'nil' (Nil).\n\n    The environment, which is structured as a tree of Scopes, maps each name to\n    the unique Object that it denotes.\n\nfunc LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)\n    LookupFieldOrMethod looks up a field or method with given package and\n    name in T and returns the corresponding *Var or *Func, an index sequence,\n    and a bool indicating if there were any pointer indirections on the path to\n    the field or method. If addressable is set, T is the type of an addressable\n    variable (only matters for method lookups). T must not be nil.\n\n    The last index entry is the field or method index in the (possibly embedded)\n    type where the entry was found, either:\n\n     1. the list of declared methods of a named type; or\n     2. the list of all methods (method set) of an interface type; or\n     3. the list of fields of a struct type.\n\n    The earlier index entries are the indices of the embedded struct fields\n    traversed to get to the found entry, starting at depth 0.\n\n    If no entry is found, a nil object is returned. In this case, the returned\n    index and indirect values have the following meaning:\n\n      - If index != nil, the index sequence points to an ambiguous entry (the\n        same name appeared more than once at the same embedding level).\n\n      - If indirect is set, a method with a pointer receiver type was found but\n        there was no pointer on the path from the actual receiver type to the\n        method's formal receiver base type, nor was the receiver addressable.\n\n    See also LookupSelection, which returns the result as a Selection.\n\ntype Package struct {\n\t// Has unexported fields.\n}\n    A Package describes a Go package.\n\nvar Unsafe *Package\n    The Unsafe package is the package returned by an importer for the import\n    path \"unsafe\".\n\nfunc NewPackage(path, name string) *Package\n    NewPackage returns a new Package for the given package path and name.\n    The package is not complete and contains no explicit imports.\n\nfunc (pkg *Package) Complete() bool\n    A package is complete if its scope contains (at least) all exported objects;\n    otherwise it is incomplete.\n\nfunc (pkg *Package) GoVersion() string\n    GoVersion returns the minimum Go version required by this package. If the\n    minimum version is unknown, GoVersion returns the empty string. Individual\n    source files may specify a different minimum Go version, as reported in the\n    go/ast.File.GoVersion field.\n\nfunc (pkg *Package) Imports() []*Package\n    Imports returns the list of packages directly imported by pkg; the list is\n    in source order.\n\n    If pkg was loaded from export data, Imports includes packages that provide\n    package-level objects referenced by pkg. This may be more or less than the\n    set of packages directly imported by pkg's source code.\n\n    If pkg uses cgo and the FakeImportC configuration option was enabled,\n    the imports list may contain a fake \"C\" package.\n\nfunc (pkg *Package) MarkComplete()\n    MarkComplete marks a package as complete.\n\nfunc (pkg *Package) Name() string\n    Name returns the package name.\n\nfunc (pkg *Package) Path() string\n    Path returns the package path.\n\nfunc (pkg *Package) Scope() *Scope\n    Scope returns the (complete or incomplete) package scope holding the objects\n    declared at package level (TypeNames, Consts, Vars, and Funcs). For a nil\n    pkg receiver, Scope returns the Universe scope.\n\nfunc (pkg *Package) SetImports(list []*Package)\n    SetImports sets the list of explicitly imported packages to list. It is the\n    caller's responsibility to make sure list elements are unique.\n\nfunc (pkg *Package) SetName(name string)\n    SetName sets the package name.\n\nfunc (pkg *Package) String() string\n\ntype PkgName struct {\n\t// Has unexported fields.\n}\n    A PkgName represents an imported Go package. PkgNames don't have a type.\n\nfunc NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName\n    NewPkgName returns a new PkgName object representing an imported package.\n    The remaining arguments set the attributes found with all Objects.\n\nfunc (obj *PkgName) Exported() bool\n    Exported reports whether the object is exported (starts with a capital\n    letter). It doesn't take into account whether the object is in a local\n    (function) scope or not.\n\nfunc (obj *PkgName) Id() string\n    Id is a wrapper for Id(obj.Pkg(), obj.Name()).\n\nfunc (obj *PkgName) Imported() *Package\n    Imported returns the package that was imported. It is distinct from Pkg(),\n    which is the package containing the import statement.\n\nfunc (obj *PkgName) Name() string\n    Name returns the object's (package-local, unqualified) name.\n\nfunc (obj *PkgName) Parent() *Scope\n    Parent returns the scope in which the object is declared. The result is nil\n    for methods and struct fields.\n\nfunc (obj *PkgName) Pkg() *Package\n    Pkg returns the package to which the object belongs. The result is nil for\n    labels and objects in the Universe scope.\n\nfunc (obj *PkgName) Pos() token.Pos\n    Pos returns the declaration position of the object's identifier.\n\nfunc (obj *PkgName) String() string\n\nfunc (obj *PkgName) Type() Type\n    Type returns the object's type.\n\ntype Pointer struct {\n\t// Has unexported fields.\n}\n    A Pointer represents a pointer type.\n\nfunc NewPointer(elem Type) *Pointer\n    NewPointer returns a new pointer type for the given element (base) type.\n\nfunc (p *Pointer) Elem() Type\n    Elem returns the element type for the given pointer p.\n\nfunc (p *Pointer) String() string\n\nfunc (p *Pointer) Underlying() Type\n\ntype Qualifier func(*Package) string\n    A Qualifier controls how named package-level objects are printed in calls to\n    TypeString, ObjectString, and SelectionString.\n\n    These three formatting routines call the Qualifier for each package-level\n    object O, and if the Qualifier returns a non-empty string p, the object is\n    printed in the form p.O. If it returns an empty string, only the object name\n    O is printed.\n\n    Using a nil Qualifier is equivalent to using (*Package).Path: the object is\n    qualified by the import path, e.g., \"encoding/json.Marshal\".\n\nfunc RelativeTo(pkg *Package) Qualifier\n    RelativeTo returns a Qualifier that fully qualifies members of all packages\n    other than pkg.\n\ntype Scope struct {\n\t// Has unexported fields.\n}\n    A Scope maintains a set of objects and links to its containing (parent) and\n    contained (children) scopes. Objects may be inserted and looked up by name.\n    The zero value for Scope is a ready-to-use empty scope.\n\nvar Universe *Scope\n    The Universe scope contains all predeclared objects of Go. It is the\n    outermost scope of any chain of nested scopes.\n\nfunc NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope\n    NewScope returns a new, empty scope contained in the given parent scope,\n    if any. The comment is for debugging only.\n\nfunc (s *Scope) Child(i int) *Scope\n    Child returns the i'th child scope for 0 <= i < NumChildren().\n\nfunc (s *Scope) Children() iter.Seq[*Scope]\n    Children returns a go1.23 iterator over the child scopes nested within scope\n    s.\n\n    Example: for child := range scope.Children() { ... }\n\nfunc (s *Scope) Contains(pos token.Pos) bool\n    Contains reports whether pos is within the scope's extent. The result is\n    guaranteed to be valid only if the type-checked AST has complete position\n    information.\n\nfunc (s *Scope) End() token.Pos\n\nfunc (s *Scope) Innermost(pos token.Pos) *Scope\n    Innermost returns the innermost (child) scope containing pos. If pos is not\n    within any scope, the result is nil. The result is also nil for the Universe\n    scope. The result is guaranteed to be valid only if the type-checked AST has\n    complete position information.\n\nfunc (s *Scope) Insert(obj Object) Object\n    Insert attempts to insert an object obj into scope s. If s already contains\n    an alternative object alt with the same name, Insert leaves s unchanged and\n    returns alt. Otherwise it inserts obj, sets the object's parent scope if not\n    already set, and returns nil.\n\nfunc (s *Scope) Len() int\n    Len returns the number of scope elements.\n\nfunc (s *Scope) Lookup(name string) Object\n    Lookup returns the object in scope s with the given name if such an object\n    exists; otherwise the result is nil.\n\nfunc (s *Scope) LookupParent(name string, pos token.Pos) (*Scope, Object)\n    LookupParent follows the parent chain of scopes starting with s until it\n    finds a scope where Lookup(name) returns a non-nil object, and then returns\n    that scope and object. If a valid position pos is provided, only objects\n    that were declared at or before pos are considered. If no such scope and\n    object exists, the result is (nil, nil). The results are guaranteed to be\n    valid only if the type-checked AST has complete position information.\n\n    Note that obj.Parent() may be different from the returned scope if the\n    object was inserted into the scope and already had a parent at that time\n    (see Insert). This can only happen for dot-imported objects whose parent is\n    the scope of the package that exported them.\n\nfunc (s *Scope) Names() []string\n    Names returns the scope's element names in sorted order.\n\nfunc (s *Scope) NumChildren() int\n    NumChildren returns the number of scopes nested in s.\n\nfunc (s *Scope) Parent() *Scope\n    Parent returns the scope's containing (parent) scope.\n\nfunc (s *Scope) Pos() token.Pos\n    Pos and End describe the scope's source code extent [pos, end). The results\n    are guaranteed to be valid only if the type-checked AST has complete\n    position information. The extent is undefined for Universe and package\n    scopes.\n\nfunc (s *Scope) String() string\n    String returns a string representation of the scope, for debugging.\n\nfunc (s *Scope) WriteTo(w io.Writer, n int, recurse bool)\n    WriteTo writes a string representation of the scope to w, with the scope\n    elements sorted by name. The level of indentation is controlled by n >= 0,\n    with n == 0 for no indentation. If recurse is set, it also writes nested\n    (children) scopes.\n\ntype Selection struct {\n\t// Has unexported fields.\n}\n    A Selection describes a selector expression x.f. For the declarations:\n\n        type T struct{ x int; E }\n        type E struct{}\n        func (e E) m() {}\n        var p *T\n\n    the following relations exist:\n\n        Selector    Kind          Recv    Obj    Type       Index     Indirect\n\n        p.x         FieldVal      T       x      int        {0}       true\n        p.m         MethodVal     *T      m      func()     {1, 0}    true\n        T.m         MethodExpr    T       m      func(T)    {1, 0}    false\n\nfunc LookupSelection(T Type, addressable bool, pkg *Package, name string) (Selection, bool)\n    LookupSelection selects the field or method whose ID is Id(pkg, name),\n    on a value of type T. If addressable is set, T is the type of an addressable\n    variable (this matters only for method lookups). T must not be nil.\n\n    If the selection is valid:\n\n      - Selection.Obj returns the field (Var) or method (Func);\n      - Selection.Indirect reports whether there were any pointer indirections\n        on the path to the field or method.\n      - Selection.Index returns the index sequence, defined below.\n\n    The last index entry is the field or method index in the (possibly embedded)\n    type where the entry was found, either:\n\n     1. the list of declared methods of a named type; or\n     2. the list of all methods (method set) of an interface type; or\n     3. the list of fields of a struct type.\n\n    The earlier index entries are the indices of the embedded struct fields\n    traversed to get to the found entry, starting at depth 0.\n\n    See also LookupFieldOrMethod, which returns the components separately.\n\nfunc (s *Selection) Index() []int\n    Index describes the path from x to f in x.f. The last index entry is the\n    field or method index of the type declaring f; either:\n\n     1. the list of declared methods of a named type; or\n     2. the list of methods of an interface type; or\n     3. the list of fields of a struct type.\n\n    The earlier index entries are the indices of the embedded fields implicitly\n    traversed to get from (the type of) x to f, starting at embedding depth 0.\n\nfunc (s *Selection) Indirect() bool\n    Indirect reports whether any pointer indirection was required to get from x\n    to f in x.f.\n\n    Beware: Indirect spuriously returns true (Go issue #8353) for a MethodVal\n    selection in which the receiver argument and parameter both have type *T so\n    there is no indirection. Unfortunately, a fix is too risky.\n\nfunc (s *Selection) Kind() SelectionKind\n    Kind returns the selection kind.\n\nfunc (s *Selection) Obj() Object\n    Obj returns the object denoted by x.f; a *Var for a field selection,\n    and a *Func in all other cases.\n\nfunc (s *Selection) Recv() Type\n    Recv returns the type of x in x.f.\n\nfunc (s *Selection) String() string\n\nfunc (s *Selection) Type() Type\n    Type returns the type of x.f, which may be different from the type of f.\n    See Selection for more information.\n\ntype SelectionKind int\n    SelectionKind describes the kind of a selector expression x.f (excluding\n    qualified identifiers).\n\n    If x is a struct or *struct, a selector expression x.f may denote a sequence\n    of selection operations x.a.b.c.f. The SelectionKind describes the kind of\n    the final (explicit) operation; all the previous (implicit) operations are\n    always field selections. Each element of Indices specifies an implicit field\n    (a, b, c) by its index in the struct type of the field selection operand.\n\n    For a FieldVal operation, the final selection refers to the field specified\n    by Selection.Obj.\n\n    For a MethodVal operation, the final selection refers to a method. If the\n    \"pointerness\" of the method's declared receiver does not match that of the\n    effective receiver after implicit field selection, then an & or * operation\n    is implicitly applied to the receiver variable or value. So, x.f denotes\n    (&x.a.b.c).f when f requires a pointer receiver but x.a.b.c is a non-pointer\n    variable; and it denotes (*x.a.b.c).f when f requires a non-pointer receiver\n    but x.a.b.c is a pointer value.\n\n    All pointer indirections, whether due to implicit or explicit field\n    selections or * operations inserted for \"pointerness\", panic if applied to a\n    nil pointer, so a method call x.f() may panic even before the function call.\n\n    By contrast, a MethodExpr operation T.f is essentially equivalent to a\n    function literal of the form:\n\n        func(x T, args) (results) { return x.f(args) }\n\n    Consequently, any implicit field selections and * operations inserted for\n    \"pointerness\" are not evaluated until the function is called, so a T.f or\n    (*T).f expression never panics.\n\nconst (\n\tFieldVal   SelectionKind = iota // x.f is a struct field selector\n\tMethodVal                       // x.f is a method selector\n\tMethodExpr                      // x.f is a method expression\n)\ntype Signature struct {\n\t// Has unexported fields.\n}\n    A Signature represents a (non-builtin) function or method type. The receiver\n    is ignored when comparing signatures for identity.\n\nfunc NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature\n    NewSignature returns a new function type for the given receiver, parameters,\n    and results, either of which may be nil. If variadic is set, the function is\n    variadic, it must have at least one parameter, and the last parameter must\n    be of unnamed slice type.\n\n    Deprecated: Use NewSignatureType instead which allows for type parameters.\n\nfunc NewSignatureType(recv *Var, recvTypeParams, typeParams []*TypeParam, params, results *Tuple, variadic bool) *Signature\n    NewSignatureType creates a new function type for the given receiver,\n    receiver type parameters, type parameters, parameters, and results.\n    If variadic is set, params must hold at least one parameter and the last\n    parameter must be an unnamed slice or a type parameter whose type set has\n    an unnamed slice as common underlying type. As a special case, for variadic\n    signatures the last parameter may also be a string type, or a type parameter\n    containing a mix of byte slices and string types in its type set. If recv\n    is non-nil, typeParams must be empty. If recvTypeParams is non-empty,\n    recv must be non-nil.\n\nfunc (s *Signature) Params() *Tuple\n    Params returns the parameters of signature s, or nil.\n\nfunc (s *Signature) Recv() *Var\n    Recv returns the receiver of signature s (if a method), or nil if a\n    function. It is ignored when comparing signatures for identity.\n\n    For an abstract method, Recv returns the enclosing interface either as a\n    *Named or an *Interface. Due to embedding, an interface may contain methods\n    whose receiver type is a different interface.\n\nfunc (s *Signature) RecvTypeParams() *TypeParamList\n    RecvTypeParams returns the receiver type parameters of signature s, or nil.\n\nfunc (s *Signature) Results() *Tuple\n    Results returns the results of signature s, or nil.\n\nfunc (s *Signature) String() string\n\nfunc (s *Signature) TypeParams() *TypeParamList\n    TypeParams returns the type parameters of signature s, or nil.\n\nfunc (s *Signature) Underlying() Type\n\nfunc (s *Signature) Variadic() bool\n    Variadic reports whether the signature s is variadic.\n\ntype Sizes interface {\n\t// Alignof returns the alignment of a variable of type T.\n\t// Alignof must implement the alignment guarantees required by the spec.\n\t// The result must be >= 1.\n\tAlignof(T Type) int64\n\n\t// Offsetsof returns the offsets of the given struct fields, in bytes.\n\t// Offsetsof must implement the offset guarantees required by the spec.\n\t// A negative entry in the result indicates that the struct is too large.\n\tOffsetsof(fields []*Var) []int64\n\n\t// Sizeof returns the size of a variable of type T.\n\t// Sizeof must implement the size guarantees required by the spec.\n\t// A negative result indicates that T is too large.\n\tSizeof(T Type) int64\n}\n    Sizes defines the sizing functions for package unsafe.\n\nfunc SizesFor(compiler, arch string) Sizes\n    SizesFor returns the Sizes used by a compiler for an architecture.\n    The result is nil if a compiler/architecture pair is not known.\n\n    Supported architectures for compiler \"gc\": \"386\", \"amd64\", \"amd64p32\",\n    \"arm\", \"arm64\", \"loong64\", \"mips\", \"mipsle\", \"mips64\", \"mips64le\", \"ppc64\",\n    \"ppc64le\", \"riscv64\", \"s390x\", \"sparc64\", \"wasm\".\n\ntype Slice struct {\n\t// Has unexported fields.\n}\n    A Slice represents a slice type.\n\nfunc NewSlice(elem Type) *Slice\n    NewSlice returns a new slice type for the given element type.\n\nfunc (s *Slice) Elem() Type\n    Elem returns the element type of slice s.\n\nfunc (s *Slice) String() string\n\nfunc (s *Slice) Underlying() Type\n\ntype StdSizes struct {\n\tWordSize int64 // word size in bytes - must be >= 4 (32bits)\n\tMaxAlign int64 // maximum alignment in bytes - must be >= 1\n}\n    StdSizes is a convenience type for creating commonly used Sizes. It makes\n    the following simplifying assumptions:\n\n      - The size of explicitly sized basic types (int16, etc.) is the specified\n        size.\n      - The size of strings and interfaces is 2*WordSize.\n      - The size of slices is 3*WordSize.\n      - The size of an array of n elements corresponds to the size of a struct\n        of n consecutive fields of the array's element type.\n      - The size of a struct is the offset of the last field plus that field's\n        size. As with all element types, if the struct is used in an array its\n        size must first be aligned to a multiple of the struct's alignment.\n      - All other types have size WordSize.\n      - Arrays and structs are aligned per spec definition; all other types are\n        naturally aligned with a maximum alignment MaxAlign.\n\n    *StdSizes implements Sizes.\n\nfunc (s *StdSizes) Alignof(T Type) (result int64)\n\nfunc (s *StdSizes) Offsetsof(fields []*Var) []int64\n\nfunc (s *StdSizes) Sizeof(T Type) int64\n\ntype Struct struct {\n\t// Has unexported fields.\n}\n    A Struct represents a struct type.\n\nfunc NewStruct(fields []*Var, tags []string) *Struct\n    NewStruct returns a new struct with the given fields and corresponding\n    field tags. If a field with index i has a tag, tags[i] must be that tag,\n    but len(tags) may be only as long as required to hold the tag with the\n    largest index i. Consequently, if no field has a tag, tags may be nil.\n\nfunc (s *Struct) Field(i int) *Var\n    Field returns the i'th field for 0 <= i < NumFields().\n\nfunc (s *Struct) Fields() iter.Seq[*Var]\n    Fields returns a go1.23 iterator over the fields of a struct type.\n\n    Example: for field := range s.Fields() { ... }\n\nfunc (s *Struct) NumFields() int\n    NumFields returns the number of fields in the struct (including blank and\n    embedded fields).\n\nfunc (t *Struct) String() string\n\nfunc (s *Struct) Tag(i int) string\n    Tag returns the i'th field tag for 0 <= i < NumFields().\n\nfunc (t *Struct) Underlying() Type\n\ntype Term term\n    A Term represents a term in a Union.\n\nfunc NewTerm(tilde bool, typ Type) *Term\n    NewTerm returns a new union term.\n\nfunc (t *Term) String() string\n\nfunc (t *Term) Tilde() bool\n\nfunc (t *Term) Type() Type\n\ntype Tuple struct {\n\t// Has unexported fields.\n}\n    A Tuple represents an ordered list of variables; a nil *Tuple is a valid\n    (empty) tuple. Tuples are used as components of signatures and to represent\n    the type of multiple assignments; they are not first class types of Go.\n\nfunc NewTuple(x ...*Var) *Tuple\n    NewTuple returns a new tuple for the given variables.\n\nfunc (t *Tuple) At(i int) *Var\n    At returns the i'th variable of tuple t.\n\nfunc (t *Tuple) Len() int\n    Len returns the number variables of tuple t.\n\nfunc (t *Tuple) String() string\n\nfunc (t *Tuple) Underlying() Type\n\nfunc (t *Tuple) Variables() iter.Seq[*Var]\n    Variables returns a go1.23 iterator over the variables of a tuple type.\n\n    Example: for v := range tuple.Variables() { ... }\n\ntype Type interface {\n\t// Underlying returns the underlying type of a type.\n\t// Underlying types are never Named, TypeParam, or Alias types.\n\t//\n\t// See https://go.dev/ref/spec#Underlying_types.\n\tUnderlying() Type\n\n\t// String returns a string representation of a type.\n\tString() string\n}\n    A Type represents a type of Go. All types implement the Type interface.\n\nfunc Default(t Type) Type\n    Default returns the default \"typed\" type for an \"untyped\" type; it returns\n    the incoming type for all other types. The default type for untyped nil is\n    untyped nil.\n\nfunc Instantiate(ctxt *Context, orig Type, targs []Type, validate bool) (Type, error)\n    Instantiate instantiates the type orig with the given type arguments targs.\n    orig must be an *Alias, *Named, or *Signature type. If there is no error,\n    the resulting Type is an instantiated type of the same kind (*Alias,\n    *Named or *Signature, respectively).\n\n    Methods attached to a *Named type are also instantiated, and associated\n    with a new *Func that has the same position as the original method, but nil\n    function scope.\n\n    If ctxt is non-nil, it may be used to de-duplicate the instance against\n    previous instances with the same identity. As a special case, generic\n    *Signature origin types are only considered identical if they are pointer\n    equivalent, so that instantiating distinct (but possibly identical)\n    signatures will yield different instances. The use of a shared context does\n    not guarantee that identical instances are deduplicated in all cases.\n\n    If validate is set, Instantiate verifies that the number of type arguments\n    and parameters match, and that the type arguments satisfy their respective\n    type constraints. If verification fails, the resulting error may wrap an\n    *ArgumentError indicating which type argument did not satisfy its type\n    parameter constraint, and why.\n\n    If validate is not set, Instantiate does not verify the type argument\n    count or whether the type arguments satisfy their constraints. Instantiate\n    is guaranteed to not return an error, but may panic. Specifically, for\n    *Signature types, Instantiate will panic immediately if the type argument\n    count is incorrect; for *Named types, a panic may occur later inside the\n    *Named API.\n\nfunc Unalias(t Type) Type\n    Unalias returns t if it is not an alias type; otherwise it follows t's\n    alias chain until it reaches a non-alias type which is then returned.\n    Consequently, the result is never an alias type.\n\ntype TypeAndValue struct {\n\tType  Type\n\tValue constant.Value\n\t// Has unexported fields.\n}\n    TypeAndValue reports the type and value (for constants) of the corresponding\n    expression.\n\nfunc Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (_ TypeAndValue, err error)\n    Eval returns the type and, if constant, the value for the expression expr,\n    evaluated at position pos of package pkg, which must have been derived from\n    type-checking an AST with complete position information relative to the\n    provided file set.\n\n    The meaning of the parameters fset, pkg, and pos is the same as in\n    CheckExpr. An error is returned if expr cannot be parsed successfully,\n    or the resulting expr AST cannot be type-checked.\n\nfunc (tv TypeAndValue) Addressable() bool\n    Addressable reports whether the corresponding expression is addressable\n    (https://golang.org/ref/spec#Address_operators).\n\nfunc (tv TypeAndValue) Assignable() bool\n    Assignable reports whether the corresponding expression is assignable to\n    (provided a value of the right type).\n\nfunc (tv TypeAndValue) HasOk() bool\n    HasOk reports whether the corresponding expression may be used on the rhs of\n    a comma-ok assignment.\n\nfunc (tv TypeAndValue) IsBuiltin() bool\n    IsBuiltin reports whether the corresponding expression denotes a (possibly\n    parenthesized) built-in function.\n\nfunc (tv TypeAndValue) IsNil() bool\n    IsNil reports whether the corresponding expression denotes the predeclared\n    value nil.\n\nfunc (tv TypeAndValue) IsType() bool\n    IsType reports whether the corresponding expression specifies a type.\n\nfunc (tv TypeAndValue) IsValue() bool\n    IsValue reports whether the corresponding expression is a value. Builtins\n    are not considered values. Constant values have a non- nil Value.\n\nfunc (tv TypeAndValue) IsVoid() bool\n    IsVoid reports whether the corresponding expression is a function call\n    without results.\n\ntype TypeList struct {\n\t// Has unexported fields.\n}\n    TypeList holds a list of types.\n\nfunc (l *TypeList) At(i int) Type\n    At returns the i'th type in the list.\n\nfunc (l *TypeList) Len() int\n    Len returns the number of types in the list. It is safe to call on a nil\n    receiver.\n\nfunc (l *TypeList) Types() iter.Seq[Type]\n    Types returns a go1.23 iterator over the elements of a list of types.\n\n    Example: for t := range l.Types() { ... }\n\ntype TypeName struct {\n\t// Has unexported fields.\n}\n    A TypeName is an Object that represents a type with a name: a defined\n    type (Named), an alias type (Alias), a type parameter (TypeParam), or a\n    predeclared type such as int or error.\n\nfunc NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName\n    NewTypeName returns a new type name denoting the given typ. The remaining\n    arguments set the attributes found with all Objects.\n\n    The typ argument may be a defined (Named) type or an alias type. It may also\n    be nil such that the returned TypeName can be used as argument for NewNamed,\n    which will set the TypeName's type as a side- effect.\n\nfunc (obj *TypeName) Exported() bool\n    Exported reports whether the object is exported (starts with a capital\n    letter). It doesn't take into account whether the object is in a local\n    (function) scope or not.\n\nfunc (obj *TypeName) Id() string\n    Id is a wrapper for Id(obj.Pkg(), obj.Name()).\n\nfunc (obj *TypeName) IsAlias() bool\n    IsAlias reports whether obj is an alias name for a type.\n\nfunc (obj *TypeName) Name() string\n    Name returns the object's (package-local, unqualified) name.\n\nfunc (obj *TypeName) Parent() *Scope\n    Parent returns the scope in which the object is declared. The result is nil\n    for methods and struct fields.\n\nfunc (obj *TypeName) Pkg() *Package\n    Pkg returns the package to which the object belongs. The result is nil for\n    labels and objects in the Universe scope.\n\nfunc (obj *TypeName) Pos() token.Pos\n    Pos returns the declaration position of the object's identifier.\n\nfunc (obj *TypeName) String() string\n\nfunc (obj *TypeName) Type() Type\n    Type returns the object's type.\n\ntype TypeParam struct {\n\t// Has unexported fields.\n}\n    A TypeParam represents the type of a type parameter in a generic\n    declaration.\n\n    A TypeParam has a name; use the TypeParam.Obj method to access its TypeName\n    object.\n\nfunc NewTypeParam(obj *TypeName, constraint Type) *TypeParam\n    NewTypeParam returns a new TypeParam. Type parameters may be set on a Named\n    type by calling SetTypeParams. Setting a type parameter on more than one\n    type will result in a panic.\n\n    The constraint argument can be nil, and set later via SetConstraint.\n    If the constraint is non-nil, it must be fully defined.\n\nfunc (t *TypeParam) Constraint() Type\n    Constraint returns the type constraint specified for t.\n\nfunc (t *TypeParam) Index() int\n    Index returns the index of the type param within its param list, or -1 if\n    the type parameter has not yet been bound to a type.\n\nfunc (t *TypeParam) Obj() *TypeName\n    Obj returns the type name for the type parameter t.\n\nfunc (t *TypeParam) SetConstraint(bound Type)\n    SetConstraint sets the type constraint for t.\n\n    It must be called by users of NewTypeParam after the bound's underlying is\n    fully defined, and before using the type parameter in any way other than\n    to form other types. Once SetConstraint returns the receiver, t is safe for\n    concurrent use.\n\nfunc (t *TypeParam) String() string\n\nfunc (t *TypeParam) Underlying() Type\n    Underlying returns the underlying type of the type parameter t, which is the\n    underlying type of its constraint. This type is always an interface.\n\n[underlying type]: https://go.dev/ref/spec#Underlying_types.\n\ntype TypeParamList struct {\n\t// Has unexported fields.\n}\n    TypeParamList holds a list of type parameters.\n\nfunc (l *TypeParamList) At(i int) *TypeParam\n    At returns the i'th type parameter in the list.\n\nfunc (l *TypeParamList) Len() int\n    Len returns the number of type parameters in the list. It is safe to call on\n    a nil receiver.\n\nfunc (l *TypeParamList) TypeParams() iter.Seq[*TypeParam]\n    TypeParams returns a go1.23 iterator over a list of type parameters.\n\n    Example: for tparam := range l.TypeParams() { ... }\n\ntype Union struct {\n\t// Has unexported fields.\n}\n    A Union represents a union of terms embedded in an interface.\n\nfunc NewUnion(terms []*Term) *Union\n    NewUnion returns a new Union type with the given terms. It is an error to\n    create an empty union; they are syntactically not possible.\n\nfunc (u *Union) Len() int\n\nfunc (u *Union) String() string\n\nfunc (u *Union) Term(i int) *Term\n\nfunc (u *Union) Terms() iter.Seq[*Term]\n    Terms returns a go1.23 iterator over the terms of a union.\n\n    Example: for term := range union.Terms() { ... }\n\nfunc (u *Union) Underlying() Type\n\ntype Var struct {\n\t// Has unexported fields.\n}\n    A Variable represents a declared variable (including function parameters and\n    results, and struct fields).\n\nfunc NewField(pos token.Pos, pkg *Package, name string, typ Type, embedded bool) *Var\n    NewField returns a new variable representing a struct field. For embedded\n    fields, the name is the unqualified type name under which the field is\n    accessible.\n\nfunc NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var\n    NewParam returns a new variable representing a function parameter.\n\n    The caller must subsequently call Var.SetKind if the desired Var is not of\n    kind ParamVar: for example, RecvVar or ResultVar.\n\nfunc NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var\n    NewVar returns a new variable. The arguments set the attributes found with\n    all Objects.\n\n    The caller must subsequently call Var.SetKind if the desired Var is not of\n    kind PackageVar.\n\nfunc (obj *Var) Anonymous() bool\n    Anonymous reports whether the variable is an embedded field. Same as\n    Embedded; only present for backward-compatibility.\n\nfunc (obj *Var) Embedded() bool\n    Embedded reports whether the variable is an embedded field.\n\nfunc (obj *Var) Exported() bool\n    Exported reports whether the object is exported (starts with a capital\n    letter). It doesn't take into account whether the object is in a local\n    (function) scope or not.\n\nfunc (obj *Var) Id() string\n    Id is a wrapper for Id(obj.Pkg(), obj.Name()).\n\nfunc (obj *Var) IsField() bool\n    IsField reports whether the variable is a struct field.\n\nfunc (v *Var) Kind() VarKind\n    Kind reports what kind of variable v is.\n\nfunc (obj *Var) Name() string\n    Name returns the object's (package-local, unqualified) name.\n\nfunc (obj *Var) Origin() *Var\n    Origin returns the canonical Var for its receiver, i.e. the Var object\n    recorded in Info.Defs.\n\n    For synthetic Vars created during instantiation (such as struct fields\n    or function parameters that depend on type arguments), this will be the\n    corresponding Var on the generic (uninstantiated) type. For all other Vars\n    Origin returns the receiver.\n\nfunc (obj *Var) Parent() *Scope\n    Parent returns the scope in which the object is declared. The result is nil\n    for methods and struct fields.\n\nfunc (obj *Var) Pkg() *Package\n    Pkg returns the package to which the object belongs. The result is nil for\n    labels and objects in the Universe scope.\n\nfunc (obj *Var) Pos() token.Pos\n    Pos returns the declaration position of the object's identifier.\n\nfunc (v *Var) SetKind(kind VarKind)\n    SetKind sets the kind of the variable. It should be used only immediately\n    after NewVar or NewParam.\n\nfunc (obj *Var) String() string\n\nfunc (obj *Var) Type() Type\n    Type returns the object's type.\n\ntype VarKind uint8\n    A VarKind discriminates the various kinds of variables.\n\nconst (\n\tPackageVar VarKind // a package-level variable\n\tLocalVar           // a local variable\n\tRecvVar            // a method receiver variable\n\tParamVar           // a function parameter variable\n\tResultVar          // a function result variable\n\tFieldVar           // a struct field\n)\nfunc (kind VarKind) String() string\n\n"}, {"path": "stdlib/encoding-hex.md", "category": "stdlib", "name": "stdlib/encoding-hex", "content": "package hex // import \"encoding/hex\"\n\nPackage hex implements hexadecimal encoding and decoding.\n\nVARIABLES\n\nvar ErrLength = errors.New(\"encoding/hex: odd length hex string\")\n    ErrLength reports an attempt to decode an odd-length input using Decode or\n    DecodeString. The stream-based Decoder returns io.ErrUnexpectedEOF instead\n    of ErrLength.\n\n\nFUNCTIONS\n\nfunc AppendDecode(dst, src []byte) ([]byte, error)\n    AppendDecode appends the hexadecimally decoded src to dst and returns the\n    extended buffer. If the input is malformed, it returns the partially decoded\n    src and an error.\n\nfunc AppendEncode(dst, src []byte) []byte\n    AppendEncode appends the hexadecimally encoded src to dst and returns the\n    extended buffer.\n\nfunc Decode(dst, src []byte) (int, error)\n    Decode decodes src into DecodedLen(len(src)) bytes, returning the actual\n    number of bytes written to dst.\n\n    Decode expects that src contains only hexadecimal characters and that src\n    has even length. If the input is malformed, Decode returns the number of\n    bytes decoded before the error.\n\nfunc DecodeString(s string) ([]byte, error)\n    DecodeString returns the bytes represented by the hexadecimal string s.\n\n    DecodeString expects that src contains only hexadecimal characters and that\n    src has even length. If the input is malformed, DecodeString returns the\n    bytes decoded before the error.\n\nfunc DecodedLen(x int) int\n    DecodedLen returns the length of a decoding of x source bytes. Specifically,\n    it returns x / 2.\n\nfunc Dump(data []byte) string\n    Dump returns a string that contains a hex dump of the given data. The format\n    of the hex dump matches the output of `hexdump -C` on the command line.\n\nfunc Dumper(w io.Writer) io.WriteCloser\n    Dumper returns a io.WriteCloser that writes a hex dump of all written data\n    to w. The format of the dump matches the output of `hexdump -C` on the\n    command line.\n\nfunc Encode(dst, src []byte) int\n    Encode encodes src into EncodedLen(len(src)) bytes of dst. As a convenience,\n    it returns the number of bytes written to dst, but this value is always\n    EncodedLen(len(src)). Encode implements hexadecimal encoding.\n\nfunc EncodeToString(src []byte) string\n    EncodeToString returns the hexadecimal encoding of src.\n\nfunc EncodedLen(n int) int\n    EncodedLen returns the length of an encoding of n source bytes.\n    Specifically, it returns n * 2.\n\nfunc NewDecoder(r io.Reader) io.Reader\n    NewDecoder returns an io.Reader that decodes hexadecimal characters from r.\n    NewDecoder expects that r contain only an even number of hexadecimal\n    characters.\n\nfunc NewEncoder(w io.Writer) io.Writer\n    NewEncoder returns an io.Writer that writes lowercase hexadecimal characters\n    to w.\n\n\nTYPES\n\ntype InvalidByteError byte\n    InvalidByteError values describe errors resulting from an invalid byte in a\n    hex string.\n\nfunc (e InvalidByteError) Error() string\n\n"}, {"path": "stdlib/mime.md", "category": "stdlib", "name": "stdlib/mime", "content": "package mime // import \"mime\"\n\nPackage mime implements parts of the MIME spec.\n\nCONSTANTS\n\nconst (\n\t// BEncoding represents Base64 encoding scheme as defined by RFC 2045.\n\tBEncoding = WordEncoder('b')\n\t// QEncoding represents the Q-encoding scheme as defined by RFC 2047.\n\tQEncoding = WordEncoder('q')\n)\n\nVARIABLES\n\nvar ErrInvalidMediaParameter = errors.New(\"mime: invalid media parameter\")\n    ErrInvalidMediaParameter is returned by ParseMediaType if the media type\n    value was found but there was an error parsing the optional parameters\n\n\nFUNCTIONS\n\nfunc AddExtensionType(ext, typ string) error\n    AddExtensionType sets the MIME type associated with the extension ext to\n    typ. The extension should begin with a leading dot, as in \".html\".\n\nfunc ExtensionsByType(typ string) ([]string, error)\n    ExtensionsByType returns the extensions known to be associated with the\n    MIME type typ. The returned extensions will each begin with a leading dot,\n    as in \".html\". When typ has no associated extensions, ExtensionsByType\n    returns an nil slice.\n\nfunc FormatMediaType(t string, param map[string]string) string\n    FormatMediaType serializes mediatype t and the parameters param as a media\n    type conforming to RFC 2045 and RFC 2616. The type and parameter names\n    are written in lower-case. When any of the arguments result in a standard\n    violation then FormatMediaType returns the empty string.\n\nfunc ParseMediaType(v string) (mediatype string, params map[string]string, err error)\n    ParseMediaType parses a media type value and any optional parameters, per\n    RFC 1521. Media types are the values in Content-Type and Content-Disposition\n    headers (RFC 2183). On success, ParseMediaType returns the media type\n    converted to lowercase and trimmed of white space and a non-nil map.\n    If there is an error parsing the optional parameter, the media type will be\n    returned along with the error ErrInvalidMediaParameter. The returned map,\n    params, maps from the lowercase attribute to the attribute value with its\n    case preserved.\n\nfunc TypeByExtension(ext string) string\n    TypeByExtension returns the MIME type associated with the file extension\n    ext. The extension ext should begin with a leading dot, as in \".html\".\n    When ext has no associated type, TypeByExtension returns \"\".\n\n    Extensions are looked up first case-sensitively, then case-insensitively.\n\n    The built-in table is small but on unix it is augmented by the local\n    system's MIME-info database or mime.types file(s) if available under one or\n    more of these names:\n\n        /usr/local/share/mime/globs2\n        /usr/share/mime/globs2\n        /etc/mime.types\n        /etc/apache2/mime.types\n        /etc/apache/mime.types\n\n    On Windows, MIME types are extracted from the registry.\n\n    Text types have the charset parameter set to \"utf-8\" by default.\n\n\nTYPES\n\ntype WordDecoder struct {\n\t// CharsetReader, if non-nil, defines a function to generate\n\t// charset-conversion readers, converting from the provided\n\t// charset into UTF-8.\n\t// Charsets are always lower-case. utf-8, iso-8859-1 and us-ascii charsets\n\t// are handled by default.\n\t// One of the CharsetReader's result values must be non-nil.\n\tCharsetReader func(charset string, input io.Reader) (io.Reader, error)\n}\n    A WordDecoder decodes MIME headers containing RFC 2047 encoded-words.\n\nfunc (d *WordDecoder) Decode(word string) (string, error)\n    Decode decodes an RFC 2047 encoded-word.\n\nfunc (d *WordDecoder) DecodeHeader(header string) (string, error)\n    DecodeHeader decodes all encoded-words of the given string. It returns an\n    error if and only if [WordDecoder.CharsetReader] of d returns an error.\n\ntype WordEncoder byte\n    A WordEncoder is an RFC 2047 encoded-word encoder.\n\nfunc (e WordEncoder) Encode(charset, s string) string\n    Encode returns the encoded-word form of s. If s is ASCII without special\n    characters, it is returned unchanged. The provided charset is the IANA\n    charset name of s. It is case insensitive.\n\n"}, {"path": "stdlib/internal-coverage-uleb128.md", "category": "stdlib", "name": "stdlib/internal-coverage-uleb128", "content": "package uleb128 // import \"internal/coverage/uleb128\"\n\n\nFUNCTIONS\n\nfunc AppendUleb128(b []byte, v uint) []byte\n"}, {"path": "stdlib/crypto-internal-fips140deps-byteorder.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140deps-byteorder", "content": "package byteorder // import \"crypto/internal/fips140deps/byteorder\"\n\n\nFUNCTIONS\n\nfunc BEAppendUint16(b []byte, v uint16) []byte\nfunc BEAppendUint32(b []byte, v uint32) []byte\nfunc BEAppendUint64(b []byte, v uint64) []byte\nfunc BEPutUint16(b []byte, v uint16)\nfunc BEPutUint32(b []byte, v uint32)\nfunc BEPutUint64(b []byte, v uint64)\nfunc BEUint32(b []byte) uint32\nfunc BEUint64(b []byte) uint64\nfunc LEPutUint64(b []byte, v uint64)\nfunc LEUint16(b []byte) uint16\nfunc LEUint64(b []byte) uint64\n"}, {"path": "stdlib/internal-exportdata.md", "category": "stdlib", "name": "stdlib/internal-exportdata", "content": "package exportdata // import \"internal/exportdata\"\n\nPackage exportdata implements common utilities for finding and reading\ngc-generated object files.\n\nFUNCTIONS\n\nfunc FindPackageDefinition(r *bufio.Reader) (size int, err error)\n    FindPackageDefinition positions the reader r at the beginning of a package\n    definition file (\"__.PKGDEF\") within a GC-created archive by reading from\n    it, and returns the size of the package definition file in the archive.\n\n    The reader must be positioned at the start of the archive file before\n    calling this function, and \"__.PKGDEF\" is assumed to be the first file in\n    the archive.\n\n    See cmd/internal/archive for details on the archive format.\n\nfunc FindPkg(path, srcDir string) (filename, id string, err error)\n    FindPkg returns the filename and unique package id for an import path based\n    on package information provided by build.Import (using the build.Default\n    build.Context). A relative srcDir is interpreted relative to the current\n    working directory.\n\nfunc ReadExportDataHeader(r *bufio.Reader) (n int, err error)\n    ReadExportDataHeader reads the export data header and format from r.\n    It returns the number of bytes read, or an error if the format is no longer\n    supported or it failed to read.\n\n    The only currently supported format is binary export data in the unified\n    export format.\n\nfunc ReadObjectHeaders(r *bufio.Reader) (objapi string, headers []string, err error)\n    ReadObjectHeaders reads object headers from the reader. Object headers are\n    lines that do not start with an end-of-section marker \"$$\". The first header\n    is the objabi header. On success, the reader will be positioned at the\n    beginning of the end-of-section marker.\n\n    It returns an error if any header does not fit in r.Size() bytes.\n\nfunc ReadUnified(r *bufio.Reader) (data []byte, err error)\n    ReadUnified reads the contents of the unified export data from a reader r\n    that contains the contents of a GC-created archive file.\n\n    On success, the reader will be positioned after the end-of-section marker\n    \"\\n$$\\n\".\n\n    Supported GC-created archive files have 4 layers of nesting:\n      - An archive file containing a package definition file.\n      - The package definition file contains headers followed by a data section.\n        Headers are lines (\u2264 4kb) that do not start with \"$$\".\n      - The data section starts with \"$$B\\n\" followed by export data followed\n        by an end of section marker \"\\n$$\\n\". (The section start \"$$\\n\" is no\n        longer supported.)\n      - The export data starts with a format byte ('u') followed by the <data>\n        in the given format. (See ReadExportDataHeader for older formats.)\n\n    Putting this together, the bytes in a GC-created archive files are expected\n    to look like the following. See cmd/internal/archive for more details on ar\n    file headers.\n\n    | <!arch>\\n | ar file signature | __.PKGDEF...size...\\n | ar header for\n    __.PKGDEF including size. | go object <...>\\n | objabi header | <optional\n    headers>\\n | other headers such as build id | $$B\\n | binary format marker |\n    u<data>\\n | unified export <data> | $$\\n | end-of-section marker | [optional\n    padding] | padding byte (0x0A) if size is odd | [ar file header] | other ar\n    files | [ar file data] |\n\n"}, {"path": "stdlib/crypto-ecdsa.md", "category": "stdlib", "name": "stdlib/crypto-ecdsa", "content": "package ecdsa // import \"crypto/ecdsa\"\n\nPackage ecdsa implements the Elliptic Curve Digital Signature Algorithm,\nas defined in FIPS 186-5.\n\nSignatures generated by this package are not deterministic, but entropy is mixed\nwith the private key and the message, achieving the same level of security in\ncase of randomness source failure.\n\nOperations involving private keys are implemented using constant-time\nalgorithms, as long as an elliptic.Curve returned by elliptic.P224,\nelliptic.P256, elliptic.P384, or elliptic.P521 is used.\n\n[FIPS 186-5]: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-5.pdf\n\nFUNCTIONS\n\nfunc Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)\n    Sign signs a hash (which should be the result of hashing a larger message)\n    using the private key, priv. If the hash is longer than the bit-length of\n    the private key's curve order, the hash will be truncated to that length.\n    It returns the signature as a pair of integers. Most applications should use\n    SignASN1 instead of dealing directly with r, s.\n\nfunc SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error)\n    SignASN1 signs a hash (which should be the result of hashing a larger\n    message) using the private key, priv. If the hash is longer than the\n    bit-length of the private key's curve order, the hash will be truncated to\n    that length. It returns the ASN.1 encoded signature.\n\n    The signature is randomized. Most applications should use crypto/rand.Reader\n    as rand. Note that the returned signature does not depend deterministically\n    on the bytes read from rand, and may change between calls and/or between\n    versions.\n\nfunc Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool\n    Verify verifies the signature in r, s of hash using the public key, pub.\n    Its return value records whether the signature is valid. Most applications\n    should use VerifyASN1 instead of dealing directly with r, s.\n\n    The inputs are not considered confidential, and may leak through timing side\n    channels, or if an attacker has control of part of the inputs.\n\nfunc VerifyASN1(pub *PublicKey, hash, sig []byte) bool\n    VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the\n    public key, pub. Its return value records whether the signature is valid.\n\n    The inputs are not considered confidential, and may leak through timing side\n    channels, or if an attacker has control of part of the inputs.\n\n\nTYPES\n\ntype PrivateKey struct {\n\tPublicKey\n\n\t// D is the private scalar value.\n\t//\n\t// Modifying the raw value can produce invalid keys, and may\n\t// invalidate internal optimizations; moreover, [big.Int] methods are not\n\t// suitable for operating on cryptographic values. To encode and decode\n\t// PrivateKey values, use [PrivateKey.Bytes] and [ParseRawPrivateKey] or\n\t// [crypto/x509.MarshalPKCS8PrivateKey] and [crypto/x509.ParsePKCS8PrivateKey].\n\t// For ECDH, use [crypto/ecdh].\n\t//\n\t// This field will be deprecated in Go 1.26.\n\tD *big.Int\n}\n    PrivateKey represents an ECDSA private key.\n\nfunc GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)\n    GenerateKey generates a new ECDSA private key for the specified curve.\n\n    Most applications should use crypto/rand.Reader as rand. Note that the\n    returned key does not depend deterministically on the bytes read from rand,\n    and may change between calls and/or between versions.\n\nfunc ParseRawPrivateKey(curve elliptic.Curve, data []byte) (*PrivateKey, error)\n    ParseRawPrivateKey parses a private key encoded as a fixed-length big-endian\n    integer, according to SEC 1, Version 2.0, Section 2.3.6 (sometimes referred\n    to as the raw format). It returns an error if the value is not reduced\n    modulo the curve's order, or if it's zero.\n\n    curve must be one of elliptic.P224, elliptic.P256, elliptic.P384,\n    or elliptic.P521, or ParseRawPrivateKey returns an error.\n\n    ParseRawPrivateKey accepts the same format as ecdh.Curve.NewPrivateKey does\n    for NIST curves, but returns a PrivateKey instead of an ecdh.PrivateKey.\n\n    Note that private keys are more commonly encoded in ASN.1 or PKCS#8\n    format, which can be parsed with crypto/x509.ParseECPrivateKey or\n    crypto/x509.ParsePKCS8PrivateKey (and encoding/pem).\n\nfunc (priv *PrivateKey) Bytes() ([]byte, error)\n    Bytes encodes the private key as a fixed-length big-endian integer according\n    to SEC 1, Version 2.0, Section 2.3.6 (sometimes referred to as the raw\n    format). It returns an error if the private key is invalid.\n\n    PrivateKey.Curve must be one of elliptic.P224, elliptic.P256, elliptic.P384,\n    or elliptic.P521, or Bytes returns an error.\n\n    Bytes returns the same format as ecdh.PrivateKey.Bytes does for NIST curves.\n\n    Note that private keys are more commonly encoded in ASN.1 or PKCS#8\n    format, which can be generated with crypto/x509.MarshalECPrivateKey or\n    crypto/x509.MarshalPKCS8PrivateKey (and encoding/pem).\n\nfunc (k *PrivateKey) ECDH() (*ecdh.PrivateKey, error)\n    ECDH returns k as a ecdh.PrivateKey. It returns an error if the key is\n    invalid according to the definition of ecdh.Curve.NewPrivateKey, or if the\n    Curve is not supported by crypto/ecdh.\n\nfunc (priv *PrivateKey) Equal(x crypto.PrivateKey) bool\n    Equal reports whether priv and x have the same value.\n\n    See PublicKey.Equal for details on how Curve is compared.\n\nfunc (priv *PrivateKey) Public() crypto.PublicKey\n    Public returns the public key corresponding to priv.\n\nfunc (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error)\n    Sign signs a hash (which should be the result of hashing a larger message\n    with opts.HashFunc()) using the private key, priv. If the hash is longer\n    than the bit-length of the private key's curve order, the hash will be\n    truncated to that length. It returns the ASN.1 encoded signature, like\n    SignASN1.\n\n    If rand is not nil, the signature is randomized. Most applications should\n    use crypto/rand.Reader as rand. Note that the returned signature does not\n    depend deterministically on the bytes read from rand, and may change between\n    calls and/or between versions.\n\n    If rand is nil, Sign will produce a deterministic signature according to RFC\n    6979. When producing a deterministic signature, opts.HashFunc() must be the\n    function used to produce digest and priv.Curve must be one of elliptic.P224,\n    elliptic.P256, elliptic.P384, or elliptic.P521.\n\ntype PublicKey struct {\n\telliptic.Curve\n\n\t// X, Y are the coordinates of the public key point.\n\t//\n\t// Modifying the raw coordinates can produce invalid keys, and may\n\t// invalidate internal optimizations; moreover, [big.Int] methods are not\n\t// suitable for operating on cryptographic values. To encode and decode\n\t// PublicKey values, use [PublicKey.Bytes] and [ParseUncompressedPublicKey]\n\t// or [crypto/x509.MarshalPKIXPublicKey] and [crypto/x509.ParsePKIXPublicKey].\n\t// For ECDH, use [crypto/ecdh]. For lower-level elliptic curve operations,\n\t// use a third-party module like filippo.io/nistec.\n\t//\n\t// These fields will be deprecated in Go 1.26.\n\tX, Y *big.Int\n}\n    PublicKey represents an ECDSA public key.\n\nfunc ParseUncompressedPublicKey(curve elliptic.Curve, data []byte) (*PublicKey, error)\n    ParseUncompressedPublicKey parses a public key encoded as an uncompressed\n    point according to SEC 1, Version 2.0, Section 2.3.3 (also known as the\n    X9.62 uncompressed format). It returns an error if the point is not in\n    uncompressed form, is not on the curve, or is the point at infinity.\n\n    curve must be one of elliptic.P224, elliptic.P256, elliptic.P384,\n    or elliptic.P521, or ParseUncompressedPublicKey returns an error.\n\n    ParseUncompressedPublicKey accepts the same format as\n    ecdh.Curve.NewPublicKey does for NIST curves, but returns a PublicKey\n    instead of an ecdh.PublicKey.\n\n    Note that public keys are more commonly encoded in DER (or PEM) format,\n    which can be parsed with crypto/x509.ParsePKIXPublicKey (and encoding/pem).\n\nfunc (pub *PublicKey) Bytes() ([]byte, error)\n    Bytes encodes the public key as an uncompressed point according to SEC 1,\n    Version 2.0, Section 2.3.3 (also known as the X9.62 uncompressed format).\n    It returns an error if the public key is invalid.\n\n    PublicKey.Curve must be one of elliptic.P224, elliptic.P256, elliptic.P384,\n    or elliptic.P521, or Bytes returns an error.\n\n    Bytes returns the same format as ecdh.PublicKey.Bytes does for NIST curves.\n\n    Note that public keys are more commonly encoded in DER (or PEM) format,\n    which can be generated with crypto/x509.MarshalPKIXPublicKey (and\n    encoding/pem).\n\nfunc (k *PublicKey) ECDH() (*ecdh.PublicKey, error)\n    ECDH returns k as a ecdh.PublicKey. It returns an error if the key is\n    invalid according to the definition of ecdh.Curve.NewPublicKey, or if the\n    Curve is not supported by crypto/ecdh.\n\nfunc (pub *PublicKey) Equal(x crypto.PublicKey) bool\n    Equal reports whether pub and x have the same value.\n\n    Two keys are only considered to have the same value if they have\n    the same Curve value. Note that for example elliptic.P256 and\n    elliptic.P256().Params() are different values, as the latter is a generic\n    not constant time implementation.\n\n"}, {"path": "stdlib/crypto-internal-fips140deps-godebug.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140deps-godebug", "content": "package godebug // import \"crypto/internal/fips140deps/godebug\"\n\n\nFUNCTIONS\n\nfunc Value(name string) string\n\nTYPES\n\ntype Setting godebug.Setting\n\nfunc New(name string) *Setting\n\nfunc (s *Setting) Value() string\n\n"}, {"path": "stdlib/net-http-cookiejar.md", "category": "stdlib", "name": "stdlib/net-http-cookiejar", "content": "package cookiejar // import \"net/http/cookiejar\"\n\nPackage cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.\n\nTYPES\n\ntype Jar struct {\n\t// Has unexported fields.\n}\n    Jar implements the http.CookieJar interface from the net/http package.\n\nfunc New(o *Options) (*Jar, error)\n    New returns a new cookie jar. A nil *Options is equivalent to a zero\n    Options.\n\nfunc (j *Jar) Cookies(u *url.URL) (cookies []*http.Cookie)\n    Cookies implements the Cookies method of the http.CookieJar interface.\n\n    It returns an empty slice if the URL's scheme is not HTTP or HTTPS.\n\nfunc (j *Jar) SetCookies(u *url.URL, cookies []*http.Cookie)\n    SetCookies implements the SetCookies method of the http.CookieJar interface.\n\n    It does nothing if the URL's scheme is not HTTP or HTTPS.\n\ntype Options struct {\n\t// PublicSuffixList is the public suffix list that determines whether\n\t// an HTTP server can set a cookie for a domain.\n\t//\n\t// A nil value is valid and may be useful for testing but it is not\n\t// secure: it means that the HTTP server for foo.co.uk can set a cookie\n\t// for bar.co.uk.\n\tPublicSuffixList PublicSuffixList\n}\n    Options are the options for creating a new Jar.\n\ntype PublicSuffixList interface {\n\t// PublicSuffix returns the public suffix of domain.\n\t//\n\t// TODO: specify which of the caller and callee is responsible for IP\n\t// addresses, for leading and trailing dots, for case sensitivity, and\n\t// for IDN/Punycode.\n\tPublicSuffix(domain string) string\n\n\t// String returns a description of the source of this public suffix\n\t// list. The description will typically contain something like a time\n\t// stamp or version number.\n\tString() string\n}\n    PublicSuffixList provides the public suffix of a domain. For example:\n      - the public suffix of \"example.com\" is \"com\",\n      - the public suffix of \"foo1.foo2.foo3.co.uk\" is \"co.uk\", and\n      - the public suffix of \"bar.pvt.k12.ma.us\" is \"pvt.k12.ma.us\".\n\n    Implementations of PublicSuffixList must be safe for concurrent use by\n    multiple goroutines.\n\n    An implementation that always returns \"\" is valid and may be useful for\n    testing but it is not secure: it means that the HTTP server for foo.com can\n    set a cookie for bar.com.\n\n    A public suffix list implementation is in the package\n    golang.org/x/net/publicsuffix.\n\n"}, {"path": "stdlib/internal-asan.md", "category": "stdlib", "name": "stdlib/internal-asan", "content": "package asan // import \"internal/asan\"\n\nPackage asan contains helper functions for manually instrumenting code for the\naddress sanitizer. The runtime package intentionally exports these functions\nonly in the asan build; this package exports them unconditionally but without\nthe \"asan\" build tag they are no-ops.\n\nCONSTANTS\n\nconst Enabled = false\n\nFUNCTIONS\n\nfunc Read(addr unsafe.Pointer, len uintptr)\nfunc Write(addr unsafe.Pointer, len uintptr)\n"}, {"path": "stdlib/go-doc.md", "category": "stdlib", "name": "stdlib/go-doc", "content": "package doc // import \"go/doc\"\n\nPackage doc extracts source code documentation from a Go AST.\n\nVARIABLES\n\nvar IllegalPrefixes = []string{\n\t\"copyright\",\n\t\"all rights\",\n\t\"author\",\n}\n    IllegalPrefixes is a list of lower-case prefixes that identify a comment\n    as not being a doc comment. This helps to avoid misinterpreting the common\n    mistake of a copyright notice immediately before a package statement as\n    being a doc comment.\n\n\nFUNCTIONS\n\nfunc IsPredeclared(s string) bool\n    IsPredeclared reports whether s is a predeclared identifier.\n\nfunc Synopsis(text string) string\n    Synopsis returns a cleaned version of the first sentence in text.\n\n    Deprecated: New programs should use Package.Synopsis instead, which handles\n    links in text properly.\n\nfunc ToHTML(w io.Writer, text string, words map[string]string)\n    ToHTML converts comment text to formatted HTML.\n\n    Deprecated: ToHTML cannot identify documentation links in the doc comment,\n    because they depend on knowing what package the text came from, which is not\n    included in this API.\n\n    Given the *doc.Package p where text was found, ToHTML(w, text, nil) can be\n    replaced by:\n\n        w.Write(p.HTML(text))\n\n    which is in turn shorthand for:\n\n        w.Write(p.Printer().HTML(p.Parser().Parse(text)))\n\n    If words may be non-nil, the longer replacement is:\n\n        parser := p.Parser()\n        parser.Words = words\n        w.Write(p.Printer().HTML(parser.Parse(d)))\n\nfunc ToText(w io.Writer, text string, prefix, codePrefix string, width int)\n    ToText converts comment text to formatted text.\n\n    Deprecated: ToText cannot identify documentation links in the doc comment,\n    because they depend on knowing what package the text came from, which is not\n    included in this API.\n\n    Given the *doc.Package p where text was found, ToText(w, text, \"\", \"\\t\",\n    80) can be replaced by:\n\n        w.Write(p.Text(text))\n\n    In the general case, ToText(w, text, prefix, codePrefix, width) can be\n    replaced by:\n\n        d := p.Parser().Parse(text)\n        pr := p.Printer()\n        pr.TextPrefix = prefix\n        pr.TextCodePrefix = codePrefix\n        pr.TextWidth = width\n        w.Write(pr.Text(d))\n\n    See the documentation for Package.Text and comment.Printer.Text for more\n    details.\n\n\nTYPES\n\ntype Example struct {\n\tName        string // name of the item being exemplified (including optional suffix)\n\tSuffix      string // example suffix, without leading '_' (only populated by NewFromFiles)\n\tDoc         string // example function doc string\n\tCode        ast.Node\n\tPlay        *ast.File // a whole program version of the example\n\tComments    []*ast.CommentGroup\n\tOutput      string // expected output\n\tUnordered   bool\n\tEmptyOutput bool // expect empty output\n\tOrder       int  // original source code order\n}\n    An Example represents an example function found in a test source file.\n\nfunc Examples(testFiles ...*ast.File) []*Example\n    Examples returns the examples found in testFiles, sorted by Name field.\n    The Order fields record the order in which the examples were encountered.\n    The Suffix field is not populated when Examples is called directly, it is\n    only populated by NewFromFiles for examples it finds in _test.go files.\n\n    Playable Examples must be in a package whose name ends in \"_test\".\n    An Example is \"playable\" (the Play field is non-nil) in either of these\n    circumstances:\n      - The example function is self-contained: the function references only\n        identifiers from other packages (or predeclared identifiers, such as\n        \"int\") and the test file does not include a dot import.\n      - The entire test file is the example: the file contains exactly one\n        example function, zero test, fuzz test, or benchmark function, and at\n        least one top-level function, type, variable, or constant declaration\n        other than the example function.\n\ntype Filter func(string) bool\n\ntype Func struct {\n\tDoc  string\n\tName string\n\tDecl *ast.FuncDecl\n\n\t// methods\n\t// (for functions, these fields have the respective zero value)\n\tRecv  string // actual   receiver \"T\" or \"*T\" possibly followed by type parameters [P1, ..., Pn]\n\tOrig  string // original receiver \"T\" or \"*T\"\n\tLevel int    // embedding level; 0 means not embedded\n\n\t// Examples is a sorted list of examples associated with this\n\t// function or method. Examples are extracted from _test.go files\n\t// provided to NewFromFiles.\n\tExamples []*Example\n}\n    Func is the documentation for a func declaration.\n\ntype Mode int\n    Mode values control the operation of New and NewFromFiles.\n\nconst (\n\t// AllDecls says to extract documentation for all package-level\n\t// declarations, not just exported ones.\n\tAllDecls Mode = 1 << iota\n\n\t// AllMethods says to show all embedded methods, not just the ones of\n\t// invisible (unexported) anonymous fields.\n\tAllMethods\n\n\t// PreserveAST says to leave the AST unmodified. Originally, pieces of\n\t// the AST such as function bodies were nil-ed out to save memory in\n\t// godoc, but not all programs want that behavior.\n\tPreserveAST\n)\ntype Note struct {\n\tPos, End token.Pos // position range of the comment containing the marker\n\tUID      string    // uid found with the marker\n\tBody     string    // note body text\n}\n    A Note represents a marked comment starting with \"MARKER(uid): note body\".\n    Any note with a marker of 2 or more upper case [A-Z] letters and a uid of at\n    least one character is recognized. The \":\" following the uid is optional.\n    Notes are collected in the Package.Notes map indexed by the notes marker.\n\ntype Package struct {\n\tDoc        string\n\tName       string\n\tImportPath string\n\tImports    []string\n\tFilenames  []string\n\tNotes      map[string][]*Note\n\n\t// Deprecated: For backward compatibility Bugs is still populated,\n\t// but all new code should use Notes instead.\n\tBugs []string\n\n\t// declarations\n\tConsts []*Value\n\tTypes  []*Type\n\tVars   []*Value\n\tFuncs  []*Func\n\n\t// Examples is a sorted list of examples associated with\n\t// the package. Examples are extracted from _test.go files\n\t// provided to NewFromFiles.\n\tExamples []*Example\n\n\t// Has unexported fields.\n}\n    Package is the documentation for an entire package.\n\nfunc New(pkg *ast.Package, importPath string, mode Mode) *Package\n    New computes the package documentation for the given package AST. New takes\n    ownership of the AST pkg and may edit or overwrite it. To have the Examples\n    fields populated, use NewFromFiles and include the package's _test.go files.\n\nfunc NewFromFiles(fset *token.FileSet, files []*ast.File, importPath string, opts ...any) (*Package, error)\n    NewFromFiles computes documentation for a package.\n\n    The package is specified by a list of *ast.Files and corresponding file set,\n    which must not be nil.\n\n    NewFromFiles uses all provided files when computing documentation,\n    so it is the caller's responsibility to provide only the files that match\n    the desired build context. \"go/build\".Context.MatchFile can be used for\n    determining whether a file matches a build context with the desired GOOS and\n    GOARCH values, and other build constraints. The import path of the package\n    is specified by importPath.\n\n    Examples found in _test.go files are associated with the corresponding type,\n    function, method, or the package, based on their name. If the example has a\n    suffix in its name, it is set in the [Example.Suffix] field. Examples with\n    malformed names are skipped.\n\n    Optionally, a single extra argument of type Mode can be provided to control\n    low-level aspects of the documentation extraction behavior.\n\n    NewFromFiles takes ownership of the AST files and may edit them, unless the\n    PreserveAST Mode bit is on.\n\nfunc (p *Package) Filter(f Filter)\n    Filter eliminates documentation for names that don't pass through the filter\n    f. TODO(gri): Recognize \"Type.Method\" as a name.\n\nfunc (p *Package) HTML(text string) []byte\n    HTML returns formatted HTML for the doc comment text.\n\n    To customize details of the HTML, use Package.Printer to obtain a\n    comment.Printer, and configure it before calling its HTML method.\n\nfunc (p *Package) Markdown(text string) []byte\n    Markdown returns formatted Markdown for the doc comment text.\n\n    To customize details of the Markdown, use Package.Printer to obtain a\n    comment.Printer, and configure it before calling its Markdown method.\n\nfunc (p *Package) Parser() *comment.Parser\n    Parser returns a doc comment parser configured for parsing doc comments from\n    package p. Each call returns a new parser, so that the caller may customize\n    it before use.\n\nfunc (p *Package) Printer() *comment.Printer\n    Printer returns a doc comment printer configured for printing doc comments\n    from package p. Each call returns a new printer, so that the caller may\n    customize it before use.\n\nfunc (p *Package) Synopsis(text string) string\n    Synopsis returns a cleaned version of the first sentence in text. That\n    sentence ends after the first period followed by space and not preceded by\n    exactly one uppercase letter, or at the first paragraph break. The result\n    string has no \\n, \\r, or \\t characters and uses only single spaces between\n    words. If text starts with any of the IllegalPrefixes, the result is the\n    empty string.\n\nfunc (p *Package) Text(text string) []byte\n    Text returns formatted text for the doc comment text, wrapped to 80 Unicode\n    code points and using tabs for code block indentation.\n\n    To customize details of the formatting, use Package.Printer to obtain a\n    comment.Printer, and configure it before calling its Text method.\n\ntype Type struct {\n\tDoc  string\n\tName string\n\tDecl *ast.GenDecl\n\n\t// associated declarations\n\tConsts  []*Value // sorted list of constants of (mostly) this type\n\tVars    []*Value // sorted list of variables of (mostly) this type\n\tFuncs   []*Func  // sorted list of functions returning this type\n\tMethods []*Func  // sorted list of methods (including embedded ones) of this type\n\n\t// Examples is a sorted list of examples associated with\n\t// this type. Examples are extracted from _test.go files\n\t// provided to NewFromFiles.\n\tExamples []*Example\n}\n    Type is the documentation for a type declaration.\n\ntype Value struct {\n\tDoc   string\n\tNames []string // var or const names in declaration order\n\tDecl  *ast.GenDecl\n\n\t// Has unexported fields.\n}\n    Value is the documentation for a (possibly grouped) var or const\n    declaration.\n\n"}, {"path": "stdlib/encoding-base64.md", "category": "stdlib", "name": "stdlib/encoding-base64", "content": "package base64 // import \"encoding/base64\"\n\nPackage base64 implements base64 encoding as specified by RFC 4648.\n\nCONSTANTS\n\nconst (\n\tStdPadding rune = '=' // Standard padding character\n\tNoPadding  rune = -1  // No padding\n)\n\nVARIABLES\n\nvar RawStdEncoding = StdEncoding.WithPadding(NoPadding)\n    RawStdEncoding is the standard raw, unpadded base64 encoding, as defined\n    in RFC 4648 section 3.2. This is the same as StdEncoding but omits padding\n    characters.\n\nvar RawURLEncoding = URLEncoding.WithPadding(NoPadding)\n    RawURLEncoding is the unpadded alternate base64 encoding defined in RFC\n    4648. It is typically used in URLs and file names. This is the same as\n    URLEncoding but omits padding characters.\n\nvar StdEncoding = NewEncoding(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")\n    StdEncoding is the standard base64 encoding, as defined in RFC 4648.\n\nvar URLEncoding = NewEncoding(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\")\n    URLEncoding is the alternate base64 encoding defined in RFC 4648. It is\n    typically used in URLs and file names.\n\n\nFUNCTIONS\n\nfunc NewDecoder(enc *Encoding, r io.Reader) io.Reader\n    NewDecoder constructs a new base64 stream decoder.\n\nfunc NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser\n    NewEncoder returns a new base64 stream encoder. Data written to the returned\n    writer will be encoded using enc and then written to w. Base64 encodings\n    operate in 4-byte blocks; when finished writing, the caller must Close the\n    returned encoder to flush any partially written blocks.\n\n\nTYPES\n\ntype CorruptInputError int64\n\nfunc (e CorruptInputError) Error() string\n\ntype Encoding struct {\n\t// Has unexported fields.\n}\n    An Encoding is a radix 64 encoding/decoding scheme, defined by a\n    64-character alphabet. The most common encoding is the \"base64\" encoding\n    defined in RFC 4648 and used in MIME (RFC 2045) and PEM (RFC 1421). RFC 4648\n    also defines an alternate encoding, which is the standard encoding with -\n    and _ substituted for + and /.\n\nfunc NewEncoding(encoder string) *Encoding\n    NewEncoding returns a new padded Encoding defined by the given alphabet,\n    which must be a 64-byte string that contains unique byte values and does\n    not contain the padding character or CR / LF ('\\r', '\\n'). The alphabet\n    is treated as a sequence of byte values without any special treatment for\n    multi-byte UTF-8. The resulting Encoding uses the default padding character\n    ('='), which may be changed or disabled via Encoding.WithPadding.\n\nfunc (enc *Encoding) AppendDecode(dst, src []byte) ([]byte, error)\n    AppendDecode appends the base64 decoded src to dst and returns the extended\n    buffer. If the input is malformed, it returns the partially decoded src and\n    an error. New line characters (\\r and \\n) are ignored.\n\nfunc (enc *Encoding) AppendEncode(dst, src []byte) []byte\n    AppendEncode appends the base64 encoded src to dst and returns the extended\n    buffer.\n\nfunc (enc *Encoding) Decode(dst, src []byte) (n int, err error)\n    Decode decodes src using the encoding enc. It writes at most\n    Encoding.DecodedLen(len(src)) bytes to dst and returns the number of bytes\n    written. The caller must ensure that dst is large enough to hold all the\n    decoded data. If src contains invalid base64 data, it will return the number\n    of bytes successfully written and CorruptInputError. New line characters (\\r\n    and \\n) are ignored.\n\nfunc (enc *Encoding) DecodeString(s string) ([]byte, error)\n    DecodeString returns the bytes represented by the base64 string s.\n    If the input is malformed, it returns the partially decoded data and\n    CorruptInputError. New line characters (\\r and \\n) are ignored.\n\nfunc (enc *Encoding) DecodedLen(n int) int\n    DecodedLen returns the maximum length in bytes of the decoded data\n    corresponding to n bytes of base64-encoded data.\n\nfunc (enc *Encoding) Encode(dst, src []byte)\n    Encode encodes src using the encoding enc, writing\n    Encoding.EncodedLen(len(src)) bytes to dst.\n\n    The encoding pads the output to a multiple of 4 bytes, so Encode is\n    not appropriate for use on individual blocks of a large data stream.\n    Use NewEncoder instead.\n\nfunc (enc *Encoding) EncodeToString(src []byte) string\n    EncodeToString returns the base64 encoding of src.\n\nfunc (enc *Encoding) EncodedLen(n int) int\n    EncodedLen returns the length in bytes of the base64 encoding of an input\n    buffer of length n.\n\nfunc (enc Encoding) Strict() *Encoding\n    Strict creates a new encoding identical to enc except with strict decoding\n    enabled. In this mode, the decoder requires that trailing padding bits are\n    zero, as described in RFC 4648 section 3.5.\n\n    Note that the input is still malleable, as new line characters (CR and LF)\n    are still ignored.\n\nfunc (enc Encoding) WithPadding(padding rune) *Encoding\n    WithPadding creates a new encoding identical to enc except with a specified\n    padding character, or NoPadding to disable padding. The padding character\n    must not be '\\r' or '\\n', must not be contained in the encoding's alphabet,\n    must not be negative, and must be a rune equal or below '\\xff'. Padding\n    characters above '\\x7f' are encoded as their exact byte value rather than\n    using the UTF-8 representation of the codepoint.\n\n"}, {"path": "stdlib/debug-pe.md", "category": "stdlib", "name": "stdlib/debug-pe", "content": "package pe // import \"debug/pe\"\n\nPackage pe implements access to PE (Microsoft Windows Portable Executable)\nfiles.\n\n# Security\n\nThis package is not designed to be hardened against adversarial inputs,\nand is outside the scope of https://go.dev/security/policy. In particular,\nonly basic validation is done when parsing object files. As such, care should\nbe taken when parsing untrusted inputs, as parsing malformed files may consume\nsignificant resources, or cause panics.\n\nCONSTANTS\n\nconst (\n\tIMAGE_FILE_MACHINE_UNKNOWN     = 0x0\n\tIMAGE_FILE_MACHINE_AM33        = 0x1d3\n\tIMAGE_FILE_MACHINE_AMD64       = 0x8664\n\tIMAGE_FILE_MACHINE_ARM         = 0x1c0\n\tIMAGE_FILE_MACHINE_ARMNT       = 0x1c4\n\tIMAGE_FILE_MACHINE_ARM64       = 0xaa64\n\tIMAGE_FILE_MACHINE_EBC         = 0xebc\n\tIMAGE_FILE_MACHINE_I386        = 0x14c\n\tIMAGE_FILE_MACHINE_IA64        = 0x200\n\tIMAGE_FILE_MACHINE_LOONGARCH32 = 0x6232\n\tIMAGE_FILE_MACHINE_LOONGARCH64 = 0x6264\n\tIMAGE_FILE_MACHINE_M32R        = 0x9041\n\tIMAGE_FILE_MACHINE_MIPS16      = 0x266\n\tIMAGE_FILE_MACHINE_MIPSFPU     = 0x366\n\tIMAGE_FILE_MACHINE_MIPSFPU16   = 0x466\n\tIMAGE_FILE_MACHINE_POWERPC     = 0x1f0\n\tIMAGE_FILE_MACHINE_POWERPCFP   = 0x1f1\n\tIMAGE_FILE_MACHINE_R4000       = 0x166\n\tIMAGE_FILE_MACHINE_SH3         = 0x1a2\n\tIMAGE_FILE_MACHINE_SH3DSP      = 0x1a3\n\tIMAGE_FILE_MACHINE_SH4         = 0x1a6\n\tIMAGE_FILE_MACHINE_SH5         = 0x1a8\n\tIMAGE_FILE_MACHINE_THUMB       = 0x1c2\n\tIMAGE_FILE_MACHINE_WCEMIPSV2   = 0x169\n\tIMAGE_FILE_MACHINE_RISCV32     = 0x5032\n\tIMAGE_FILE_MACHINE_RISCV64     = 0x5064\n\tIMAGE_FILE_MACHINE_RISCV128    = 0x5128\n)\nconst (\n\tIMAGE_DIRECTORY_ENTRY_EXPORT         = 0\n\tIMAGE_DIRECTORY_ENTRY_IMPORT         = 1\n\tIMAGE_DIRECTORY_ENTRY_RESOURCE       = 2\n\tIMAGE_DIRECTORY_ENTRY_EXCEPTION      = 3\n\tIMAGE_DIRECTORY_ENTRY_SECURITY       = 4\n\tIMAGE_DIRECTORY_ENTRY_BASERELOC      = 5\n\tIMAGE_DIRECTORY_ENTRY_DEBUG          = 6\n\tIMAGE_DIRECTORY_ENTRY_ARCHITECTURE   = 7\n\tIMAGE_DIRECTORY_ENTRY_GLOBALPTR      = 8\n\tIMAGE_DIRECTORY_ENTRY_TLS            = 9\n\tIMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    = 10\n\tIMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   = 11\n\tIMAGE_DIRECTORY_ENTRY_IAT            = 12\n\tIMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   = 13\n\tIMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14\n)\n    IMAGE_DIRECTORY_ENTRY constants\n\nconst (\n\tIMAGE_FILE_RELOCS_STRIPPED         = 0x0001\n\tIMAGE_FILE_EXECUTABLE_IMAGE        = 0x0002\n\tIMAGE_FILE_LINE_NUMS_STRIPPED      = 0x0004\n\tIMAGE_FILE_LOCAL_SYMS_STRIPPED     = 0x0008\n\tIMAGE_FILE_AGGRESIVE_WS_TRIM       = 0x0010\n\tIMAGE_FILE_LARGE_ADDRESS_AWARE     = 0x0020\n\tIMAGE_FILE_BYTES_REVERSED_LO       = 0x0080\n\tIMAGE_FILE_32BIT_MACHINE           = 0x0100\n\tIMAGE_FILE_DEBUG_STRIPPED          = 0x0200\n\tIMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = 0x0400\n\tIMAGE_FILE_NET_RUN_FROM_SWAP       = 0x0800\n\tIMAGE_FILE_SYSTEM                  = 0x1000\n\tIMAGE_FILE_DLL                     = 0x2000\n\tIMAGE_FILE_UP_SYSTEM_ONLY          = 0x4000\n\tIMAGE_FILE_BYTES_REVERSED_HI       = 0x8000\n)\n    Values of IMAGE_FILE_HEADER.Characteristics. These can be combined together.\n\nconst (\n\tIMAGE_SUBSYSTEM_UNKNOWN                  = 0\n\tIMAGE_SUBSYSTEM_NATIVE                   = 1\n\tIMAGE_SUBSYSTEM_WINDOWS_GUI              = 2\n\tIMAGE_SUBSYSTEM_WINDOWS_CUI              = 3\n\tIMAGE_SUBSYSTEM_OS2_CUI                  = 5\n\tIMAGE_SUBSYSTEM_POSIX_CUI                = 7\n\tIMAGE_SUBSYSTEM_NATIVE_WINDOWS           = 8\n\tIMAGE_SUBSYSTEM_WINDOWS_CE_GUI           = 9\n\tIMAGE_SUBSYSTEM_EFI_APPLICATION          = 10\n\tIMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER  = 11\n\tIMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER       = 12\n\tIMAGE_SUBSYSTEM_EFI_ROM                  = 13\n\tIMAGE_SUBSYSTEM_XBOX                     = 14\n\tIMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION = 16\n)\n    OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values.\n\nconst (\n\tIMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA       = 0x0020\n\tIMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE          = 0x0040\n\tIMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY       = 0x0080\n\tIMAGE_DLLCHARACTERISTICS_NX_COMPAT             = 0x0100\n\tIMAGE_DLLCHARACTERISTICS_NO_ISOLATION          = 0x0200\n\tIMAGE_DLLCHARACTERISTICS_NO_SEH                = 0x0400\n\tIMAGE_DLLCHARACTERISTICS_NO_BIND               = 0x0800\n\tIMAGE_DLLCHARACTERISTICS_APPCONTAINER          = 0x1000\n\tIMAGE_DLLCHARACTERISTICS_WDM_DRIVER            = 0x2000\n\tIMAGE_DLLCHARACTERISTICS_GUARD_CF              = 0x4000\n\tIMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000\n)\n    OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics\n    values. These can be combined together.\n\nconst (\n\tIMAGE_SCN_CNT_CODE               = 0x00000020\n\tIMAGE_SCN_CNT_INITIALIZED_DATA   = 0x00000040\n\tIMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080\n\tIMAGE_SCN_LNK_COMDAT             = 0x00001000\n\tIMAGE_SCN_MEM_DISCARDABLE        = 0x02000000\n\tIMAGE_SCN_MEM_EXECUTE            = 0x20000000\n\tIMAGE_SCN_MEM_READ               = 0x40000000\n\tIMAGE_SCN_MEM_WRITE              = 0x80000000\n)\n    Section characteristics flags.\n\nconst (\n\tIMAGE_COMDAT_SELECT_NODUPLICATES = 1\n\tIMAGE_COMDAT_SELECT_ANY          = 2\n\tIMAGE_COMDAT_SELECT_SAME_SIZE    = 3\n\tIMAGE_COMDAT_SELECT_EXACT_MATCH  = 4\n\tIMAGE_COMDAT_SELECT_ASSOCIATIVE  = 5\n\tIMAGE_COMDAT_SELECT_LARGEST      = 6\n)\n    These constants make up the possible values for the 'Selection' field in an\n    AuxFormat5.\n\nconst COFFSymbolSize = 18\n\nTYPES\n\ntype COFFSymbol struct {\n\tName               [8]uint8\n\tValue              uint32\n\tSectionNumber      int16\n\tType               uint16\n\tStorageClass       uint8\n\tNumberOfAuxSymbols uint8\n}\n    COFFSymbol represents single COFF symbol table record.\n\nfunc (sym *COFFSymbol) FullName(st StringTable) (string, error)\n    FullName finds real name of symbol sym. Normally name is stored in sym.Name,\n    but if it is longer then 8 characters, it is stored in COFF string table st\n    instead.\n\ntype COFFSymbolAuxFormat5 struct {\n\tSize           uint32\n\tNumRelocs      uint16\n\tNumLineNumbers uint16\n\tChecksum       uint32\n\tSecNum         uint16\n\tSelection      uint8\n\t// Has unexported fields.\n}\n    COFFSymbolAuxFormat5 describes the expected form of an aux symbol\n    attached to a section definition symbol. The PE format defines\n    a number of different aux symbol formats: format 1 for function\n    definitions, format 2 for .be and .ef symbols, and so on. Format 5\n    holds extra info associated with a section definition, including\n    number of relocations + line numbers, as well as COMDAT info. See\n    https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#auxiliary-format-5-section-definitions\n    for more on what's going on here.\n\ntype DataDirectory struct {\n\tVirtualAddress uint32\n\tSize           uint32\n}\n\ntype File struct {\n\tFileHeader\n\tOptionalHeader any // of type *OptionalHeader32 or *OptionalHeader64\n\tSections       []*Section\n\tSymbols        []*Symbol    // COFF symbols with auxiliary symbol records removed\n\tCOFFSymbols    []COFFSymbol // all COFF symbols (including auxiliary symbol records)\n\tStringTable    StringTable\n\n\t// Has unexported fields.\n}\n    A File represents an open PE file.\n\nfunc NewFile(r io.ReaderAt) (*File, error)\n    NewFile creates a new File for accessing a PE binary in an underlying\n    reader.\n\nfunc Open(name string) (*File, error)\n    Open opens the named file using os.Open and prepares it for use as a PE\n    binary.\n\nfunc (f *File) COFFSymbolReadSectionDefAux(idx int) (*COFFSymbolAuxFormat5, error)\n    COFFSymbolReadSectionDefAux returns a blob of auxiliary information\n    (including COMDAT info) for a section definition symbol. Here 'idx' is the\n    index of a section symbol in the main COFFSymbol array for the File. Return\n    value is a pointer to the appropriate aux symbol struct. For more info, see:\n\n    auxiliary symbols:\n    https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#auxiliary-symbol-records\n    COMDAT sections:\n    https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#comdat-sections-object-only\n    auxiliary info for section definitions:\n    https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#auxiliary-format-5-section-definitions\n\nfunc (f *File) Close() error\n    Close closes the File. If the File was created using NewFile directly\n    instead of Open, Close has no effect.\n\nfunc (f *File) DWARF() (*dwarf.Data, error)\n\nfunc (f *File) ImportedLibraries() ([]string, error)\n    ImportedLibraries returns the names of all libraries referred to by the\n    binary f that are expected to be linked with the binary at dynamic link\n    time.\n\nfunc (f *File) ImportedSymbols() ([]string, error)\n    ImportedSymbols returns the names of all symbols referred to by the binary\n    f that are expected to be satisfied by other libraries at dynamic load time.\n    It does not return weak symbols.\n\nfunc (f *File) Section(name string) *Section\n    Section returns the first section with the given name, or nil if no such\n    section exists.\n\ntype FileHeader struct {\n\tMachine              uint16\n\tNumberOfSections     uint16\n\tTimeDateStamp        uint32\n\tPointerToSymbolTable uint32\n\tNumberOfSymbols      uint32\n\tSizeOfOptionalHeader uint16\n\tCharacteristics      uint16\n}\n\ntype FormatError struct {\n}\n    FormatError is unused. The type is retained for compatibility.\n\nfunc (e *FormatError) Error() string\n\ntype ImportDirectory struct {\n\tOriginalFirstThunk uint32\n\tTimeDateStamp      uint32\n\tForwarderChain     uint32\n\tName               uint32\n\tFirstThunk         uint32\n\n\t// Has unexported fields.\n}\n\ntype OptionalHeader32 struct {\n\tMagic                       uint16\n\tMajorLinkerVersion          uint8\n\tMinorLinkerVersion          uint8\n\tSizeOfCode                  uint32\n\tSizeOfInitializedData       uint32\n\tSizeOfUninitializedData     uint32\n\tAddressOfEntryPoint         uint32\n\tBaseOfCode                  uint32\n\tBaseOfData                  uint32\n\tImageBase                   uint32\n\tSectionAlignment            uint32\n\tFileAlignment               uint32\n\tMajorOperatingSystemVersion uint16\n\tMinorOperatingSystemVersion uint16\n\tMajorImageVersion           uint16\n\tMinorImageVersion           uint16\n\tMajorSubsystemVersion       uint16\n\tMinorSubsystemVersion       uint16\n\tWin32VersionValue           uint32\n\tSizeOfImage                 uint32\n\tSizeOfHeaders               uint32\n\tCheckSum                    uint32\n\tSubsystem                   uint16\n\tDllCharacteristics          uint16\n\tSizeOfStackReserve          uint32\n\tSizeOfStackCommit           uint32\n\tSizeOfHeapReserve           uint32\n\tSizeOfHeapCommit            uint32\n\tLoaderFlags                 uint32\n\tNumberOfRvaAndSizes         uint32\n\tDataDirectory               [16]DataDirectory\n}\n\ntype OptionalHeader64 struct {\n\tMagic                       uint16\n\tMajorLinkerVersion          uint8\n\tMinorLinkerVersion          uint8\n\tSizeOfCode                  uint32\n\tSizeOfInitializedData       uint32\n\tSizeOfUninitializedData     uint32\n\tAddressOfEntryPoint         uint32\n\tBaseOfCode                  uint32\n\tImageBase                   uint64\n\tSectionAlignment            uint32\n\tFileAlignment               uint32\n\tMajorOperatingSystemVersion uint16\n\tMinorOperatingSystemVersion uint16\n\tMajorImageVersion           uint16\n\tMinorImageVersion           uint16\n\tMajorSubsystemVersion       uint16\n\tMinorSubsystemVersion       uint16\n\tWin32VersionValue           uint32\n\tSizeOfImage                 uint32\n\tSizeOfHeaders               uint32\n\tCheckSum                    uint32\n\tSubsystem                   uint16\n\tDllCharacteristics          uint16\n\tSizeOfStackReserve          uint64\n\tSizeOfStackCommit           uint64\n\tSizeOfHeapReserve           uint64\n\tSizeOfHeapCommit            uint64\n\tLoaderFlags                 uint32\n\tNumberOfRvaAndSizes         uint32\n\tDataDirectory               [16]DataDirectory\n}\n\ntype Reloc struct {\n\tVirtualAddress   uint32\n\tSymbolTableIndex uint32\n\tType             uint16\n}\n    Reloc represents a PE COFF relocation. Each section contains its own\n    relocation list.\n\ntype Section struct {\n\tSectionHeader\n\tRelocs []Reloc\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\t// Has unexported fields.\n}\n    Section provides access to PE COFF section.\n\nfunc (s *Section) Data() ([]byte, error)\n    Data reads and returns the contents of the PE section s.\n\n    If s.Offset is 0, the section has no contents, and Data will always return a\n    non-nil error.\n\nfunc (s *Section) Open() io.ReadSeeker\n    Open returns a new ReadSeeker reading the PE section s.\n\n    If s.Offset is 0, the section has no contents, and all calls to the returned\n    reader will return a non-nil error.\n\ntype SectionHeader struct {\n\tName                 string\n\tVirtualSize          uint32\n\tVirtualAddress       uint32\n\tSize                 uint32\n\tOffset               uint32\n\tPointerToRelocations uint32\n\tPointerToLineNumbers uint32\n\tNumberOfRelocations  uint16\n\tNumberOfLineNumbers  uint16\n\tCharacteristics      uint32\n}\n    SectionHeader is similar to SectionHeader32 with Name field replaced by Go\n    string.\n\ntype SectionHeader32 struct {\n\tName                 [8]uint8\n\tVirtualSize          uint32\n\tVirtualAddress       uint32\n\tSizeOfRawData        uint32\n\tPointerToRawData     uint32\n\tPointerToRelocations uint32\n\tPointerToLineNumbers uint32\n\tNumberOfRelocations  uint16\n\tNumberOfLineNumbers  uint16\n\tCharacteristics      uint32\n}\n    SectionHeader32 represents real PE COFF section header.\n\ntype StringTable []byte\n    StringTable is a COFF string table.\n\nfunc (st StringTable) String(start uint32) (string, error)\n    String extracts string from COFF string table st at offset start.\n\ntype Symbol struct {\n\tName          string\n\tValue         uint32\n\tSectionNumber int16\n\tType          uint16\n\tStorageClass  uint8\n}\n    Symbol is similar to COFFSymbol with Name field replaced by Go string.\n    Symbol also does not have NumberOfAuxSymbols.\n\n"}, {"path": "stdlib/go-printer.md", "category": "stdlib", "name": "stdlib/go-printer", "content": "package printer // import \"go/printer\"\n\nPackage printer implements printing of AST nodes.\n\nFUNCTIONS\n\nfunc Fprint(output io.Writer, fset *token.FileSet, node any) error\n    Fprint \"pretty-prints\" an AST node to output. It calls Config.Fprint with\n    default settings. Note that gofmt uses tabs for indentation but spaces for\n    alignment; use format.Node (package go/format) for output that matches\n    gofmt.\n\n\nTYPES\n\ntype CommentedNode struct {\n\tNode     any // *ast.File, or ast.Expr, ast.Decl, ast.Spec, or ast.Stmt\n\tComments []*ast.CommentGroup\n}\n    A CommentedNode bundles an AST node and corresponding comments. It may be\n    provided as argument to any of the Fprint functions.\n\ntype Config struct {\n\tMode     Mode // default: 0\n\tTabwidth int  // default: 8\n\tIndent   int  // default: 0 (all code is indented at least by this much)\n}\n    A Config node controls the output of Fprint.\n\nfunc (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node any) error\n    Fprint \"pretty-prints\" an AST node to output for a given configuration cfg.\n    Position information is interpreted relative to the file set fset.\n    The node type must be *ast.File, *CommentedNode, []ast.Decl, []ast.Stmt,\n    or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt.\n\ntype Mode uint\n    A Mode value is a set of flags (or 0). They control printing.\n\nconst (\n\tRawFormat Mode = 1 << iota // do not use a tabwriter; if set, UseSpaces is ignored\n\tTabIndent                  // use tabs for indentation independent of UseSpaces\n\tUseSpaces                  // use spaces instead of tabs for alignment\n\tSourcePos                  // emit //line directives to preserve original source positions\n)\n"}, {"path": "stdlib/go-constant.md", "category": "stdlib", "name": "stdlib/go-constant", "content": "package constant // import \"go/constant\"\n\nPackage constant implements Values representing untyped Go constants and their\ncorresponding operations.\n\nA special Unknown value may be used when a value is unknown due to an error.\nOperations on unknown values produce unknown values unless specified otherwise.\n\nFUNCTIONS\n\nfunc BitLen(x Value) int\n    BitLen returns the number of bits required to represent the absolute value x\n    in binary representation; x must be an Int or an Unknown. If x is Unknown,\n    the result is 0.\n\nfunc BoolVal(x Value) bool\n    BoolVal returns the Go boolean value of x, which must be a Bool or an\n    Unknown. If x is Unknown, the result is false.\n\nfunc Bytes(x Value) []byte\n    Bytes returns the bytes for the absolute value of x in little- endian binary\n    representation; x must be an Int.\n\nfunc Compare(x_ Value, op token.Token, y_ Value) bool\n    Compare returns the result of the comparison x op y. The comparison must be\n    defined for the operands. If one of the operands is Unknown, the result is\n    false.\n\nfunc Float32Val(x Value) (float32, bool)\n    Float32Val is like Float64Val but for float32 instead of float64.\n\nfunc Float64Val(x Value) (float64, bool)\n    Float64Val returns the nearest Go float64 value of x and whether the result\n    is exact; x must be numeric or an Unknown, but not Complex. For values\n    too small (too close to 0) to represent as float64, Float64Val silently\n    underflows to 0. The result sign always matches the sign of x, even for 0.\n    If x is Unknown, the result is (0, false).\n\nfunc Int64Val(x Value) (int64, bool)\n    Int64Val returns the Go int64 value of x and whether the result is exact;\n    x must be an Int or an Unknown. If the result is not exact, its value is\n    undefined. If x is Unknown, the result is (0, false).\n\nfunc Sign(x Value) int\n    Sign returns -1, 0, or 1 depending on whether x < 0, x == 0, or x > 0;\n    x must be numeric or Unknown. For complex values x, the sign is 0 if x == 0,\n    otherwise it is != 0. If x is Unknown, the result is 1.\n\nfunc StringVal(x Value) string\n    StringVal returns the Go string value of x, which must be a String or an\n    Unknown. If x is Unknown, the result is \"\".\n\nfunc Uint64Val(x Value) (uint64, bool)\n    Uint64Val returns the Go uint64 value of x and whether the result is exact;\n    x must be an Int or an Unknown. If the result is not exact, its value is\n    undefined. If x is Unknown, the result is (0, false).\n\nfunc Val(x Value) any\n    Val returns the underlying value for a given constant. Since it returns an\n    interface, it is up to the caller to type assert the result to the expected\n    type. The possible dynamic return types are:\n\n        x Kind             type of result\n        -----------------------------------------\n        Bool               bool\n        String             string\n        Int                int64 or *big.Int\n        Float              *big.Float or *big.Rat\n        everything else    nil\n\n\nTYPES\n\ntype Kind int\n    Kind specifies the kind of value represented by a Value.\n\nconst (\n\t// unknown values\n\tUnknown Kind = iota\n\n\t// non-numeric values\n\tBool\n\tString\n\n\t// numeric values\n\tInt\n\tFloat\n\tComplex\n)\nfunc (i Kind) String() string\n\ntype Value interface {\n\t// Kind returns the value kind.\n\tKind() Kind\n\n\t// String returns a short, quoted (human-readable) form of the value.\n\t// For numeric values, the result may be an approximation;\n\t// for String values the result may be a shortened string.\n\t// Use ExactString for a string representing a value exactly.\n\tString() string\n\n\t// ExactString returns an exact, quoted (human-readable) form of the value.\n\t// If the Value is of Kind String, use StringVal to obtain the unquoted string.\n\tExactString() string\n\n\t// Has unexported methods.\n}\n    A Value represents the value of a Go constant.\n\nfunc BinaryOp(x_ Value, op token.Token, y_ Value) Value\n    BinaryOp returns the result of the binary expression x op y. The operation\n    must be defined for the operands. If one of the operands is Unknown,\n    the result is Unknown. BinaryOp doesn't handle comparisons or shifts;\n    use Compare or Shift instead.\n\n    To force integer division of Int operands, use op == token.QUO_ASSIGN\n    instead of token.QUO; the result is guaranteed to be Int in this case.\n    Division by zero leads to a run-time panic.\n\nfunc Denom(x Value) Value\n    Denom returns the denominator of x; x must be Int, Float, or Unknown.\n    If x is Unknown, or if it is too large or small to represent as a fraction,\n    the result is Unknown. Otherwise the result is an Int >= 1.\n\nfunc Imag(x Value) Value\n    Imag returns the imaginary part of x, which must be a numeric or unknown\n    value. If x is Unknown, the result is Unknown.\n\nfunc Make(x any) Value\n    Make returns the Value for x.\n\n        type of x        result Kind\n        ----------------------------\n        bool             Bool\n        string           String\n        int64            Int\n        *big.Int         Int\n        *big.Float       Float\n        *big.Rat         Float\n        anything else    Unknown\n\nfunc MakeBool(b bool) Value\n    MakeBool returns the Bool value for b.\n\nfunc MakeFloat64(x float64) Value\n    MakeFloat64 returns the Float value for x. If x is -0.0, the result is 0.0.\n    If x is not finite, the result is an Unknown.\n\nfunc MakeFromBytes(bytes []byte) Value\n    MakeFromBytes returns the Int value given the bytes of its little-endian\n    binary representation. An empty byte slice argument represents 0.\n\nfunc MakeFromLiteral(lit string, tok token.Token, zero uint) Value\n    MakeFromLiteral returns the corresponding integer, floating-point,\n    imaginary, character, or string value for a Go literal string. The tok\n    value must be one of token.INT, token.FLOAT, token.IMAG, token.CHAR,\n    or token.STRING. The final argument must be zero. If the literal string\n    syntax is invalid, the result is an Unknown.\n\nfunc MakeImag(x Value) Value\n    MakeImag returns the Complex value x*i; x must be Int, Float, or Unknown.\n    If x is Unknown, the result is Unknown.\n\nfunc MakeInt64(x int64) Value\n    MakeInt64 returns the Int value for x.\n\nfunc MakeString(s string) Value\n    MakeString returns the String value for s.\n\nfunc MakeUint64(x uint64) Value\n    MakeUint64 returns the Int value for x.\n\nfunc MakeUnknown() Value\n    MakeUnknown returns the Unknown value.\n\nfunc Num(x Value) Value\n    Num returns the numerator of x; x must be Int, Float, or Unknown. If x is\n    Unknown, or if it is too large or small to represent as a fraction, the\n    result is Unknown. Otherwise the result is an Int with the same sign as x.\n\nfunc Real(x Value) Value\n    Real returns the real part of x, which must be a numeric or unknown value.\n    If x is Unknown, the result is Unknown.\n\nfunc Shift(x Value, op token.Token, s uint) Value\n    Shift returns the result of the shift expression x op s with op == token.SHL\n    or token.SHR (<< or >>). x must be an Int or an Unknown. If x is Unknown,\n    the result is x.\n\nfunc ToComplex(x Value) Value\n    ToComplex converts x to a Complex value if x is representable as a Complex.\n    Otherwise it returns an Unknown.\n\nfunc ToFloat(x Value) Value\n    ToFloat converts x to a Float value if x is representable as a Float.\n    Otherwise it returns an Unknown.\n\nfunc ToInt(x Value) Value\n    ToInt converts x to an Int value if x is representable as an Int. Otherwise\n    it returns an Unknown.\n\nfunc UnaryOp(op token.Token, y Value, prec uint) Value\n    UnaryOp returns the result of the unary expression op y. The operation must\n    be defined for the operand. If prec > 0 it specifies the ^ (xor) result size\n    in bits. If y is Unknown, the result is Unknown.\n\n"}, {"path": "stdlib/os.md", "category": "stdlib", "name": "stdlib/os", "content": "package os // import \"os\"\n\nPackage os provides a platform-independent interface to operating system\nfunctionality. The design is Unix-like, although the error handling is Go-like;\nfailing calls return values of type error rather than error numbers. Often, more\ninformation is available within the error. For example, if a call that takes a\nfile name fails, such as Open or Stat, the error will include the failing file\nname when printed and will be of type *PathError, which may be unpacked for more\ninformation.\n\nThe os interface is intended to be uniform across all operating systems.\nFeatures not generally available appear in the system-specific package syscall.\n\nHere is a simple example, opening a file and reading some of it.\n\n    file, err := os.Open(\"file.go\") // For read access.\n    if err != nil {\n    \tlog.Fatal(err)\n    }\n\nIf the open fails, the error string will be self-explanatory, like\n\n    open file.go: no such file or directory\n\nThe file's data can then be read into a slice of bytes. Read and Write take\ntheir byte counts from the length of the argument slice.\n\n    data := make([]byte, 100)\n    count, err := file.Read(data)\n    if err != nil {\n    \tlog.Fatal(err)\n    }\n    fmt.Printf(\"read %d bytes: %q\\n\", count, data[:count])\n\n# Concurrency\n\nThe methods of File correspond to file system operations. All are safe for\nconcurrent use. The maximum number of concurrent operations on a File may be\nlimited by the OS or the system. The number should be high, but exceeding it may\ndegrade performance or cause other issues.\n\nCONSTANTS\n\nconst (\n\t// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.\n\tO_RDONLY int = syscall.O_RDONLY // open the file read-only.\n\tO_WRONLY int = syscall.O_WRONLY // open the file write-only.\n\tO_RDWR   int = syscall.O_RDWR   // open the file read-write.\n\t// The remaining values may be or'ed in to control behavior.\n\tO_APPEND int = syscall.O_APPEND // append data to the file when writing.\n\tO_CREATE int = syscall.O_CREAT  // create a new file if none exists.\n\tO_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist.\n\tO_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.\n\tO_TRUNC  int = syscall.O_TRUNC  // truncate regular writable file when opened.\n)\n    Flags to OpenFile wrapping those of the underlying system. Not all flags may\n    be implemented on a given system.\n\nconst (\n\tSEEK_SET int = 0 // seek relative to the origin of the file\n\tSEEK_CUR int = 1 // seek relative to the current offset\n\tSEEK_END int = 2 // seek relative to the end\n)\n    Seek whence values.\n\n    Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.\n\nconst (\n\tPathSeparator     = '/' // OS-specific path separator\n\tPathListSeparator = ':' // OS-specific path list separator\n)\nconst (\n\t// The single letters are the abbreviations\n\t// used by the String method's formatting.\n\tModeDir        = fs.ModeDir        // d: is a directory\n\tModeAppend     = fs.ModeAppend     // a: append-only\n\tModeExclusive  = fs.ModeExclusive  // l: exclusive use\n\tModeTemporary  = fs.ModeTemporary  // T: temporary file; Plan 9 only\n\tModeSymlink    = fs.ModeSymlink    // L: symbolic link\n\tModeDevice     = fs.ModeDevice     // D: device file\n\tModeNamedPipe  = fs.ModeNamedPipe  // p: named pipe (FIFO)\n\tModeSocket     = fs.ModeSocket     // S: Unix domain socket\n\tModeSetuid     = fs.ModeSetuid     // u: setuid\n\tModeSetgid     = fs.ModeSetgid     // g: setgid\n\tModeCharDevice = fs.ModeCharDevice // c: Unix character device, when ModeDevice is set\n\tModeSticky     = fs.ModeSticky     // t: sticky\n\tModeIrregular  = fs.ModeIrregular  // ?: non-regular file; nothing else is known about this file\n\n\t// Mask for the type bits. For regular files, none will be set.\n\tModeType = fs.ModeType\n\n\tModePerm = fs.ModePerm // Unix permission bits, 0o777\n)\n    The defined file mode bits are the most significant bits of the FileMode.\n    The nine least-significant bits are the standard Unix rwxrwxrwx permissions.\n    The values of these bits should be considered part of the public API and may\n    be used in wire protocols or disk representations: they must not be changed,\n    although new bits might be added.\n\nconst DevNull = \"/dev/null\"\n    DevNull is the name of the operating system's \u201cnull device.\u201d On Unix-like\n    systems, it is \"/dev/null\"; on Windows, \"NUL\".\n\n\nVARIABLES\n\nvar (\n\t// ErrInvalid indicates an invalid argument.\n\t// Methods on File will return this error when the receiver is nil.\n\tErrInvalid = fs.ErrInvalid // \"invalid argument\"\n\n\tErrPermission = fs.ErrPermission // \"permission denied\"\n\tErrExist      = fs.ErrExist      // \"file already exists\"\n\tErrNotExist   = fs.ErrNotExist   // \"file does not exist\"\n\tErrClosed     = fs.ErrClosed     // \"file already closed\"\n\n\tErrNoDeadline       = errNoDeadline()       // \"file type does not support deadline\"\n\tErrDeadlineExceeded = errDeadlineExceeded() // \"i/o timeout\"\n)\n    Portable analogs of some common system call errors.\n\n    Errors returned from this package may be tested against these errors with\n    errors.Is.\n\nvar (\n\tStdin  = NewFile(uintptr(syscall.Stdin), \"/dev/stdin\")\n\tStdout = NewFile(uintptr(syscall.Stdout), \"/dev/stdout\")\n\tStderr = NewFile(uintptr(syscall.Stderr), \"/dev/stderr\")\n)\n    Stdin, Stdout, and Stderr are open Files pointing to the standard input,\n    standard output, and standard error file descriptors.\n\n    Note that the Go runtime writes to standard error for panics and crashes;\n    closing Stderr may cause those messages to go elsewhere, perhaps to a file\n    opened later.\n\nvar Args []string\n    Args hold the command-line arguments, starting with the program name.\n\nvar ErrProcessDone = errors.New(\"os: process already finished\")\n    ErrProcessDone indicates a Process has finished.\n\n\nFUNCTIONS\n\nfunc Chdir(dir string) error\n    Chdir changes the current working directory to the named directory. If there\n    is an error, it will be of type *PathError.\n\nfunc Chmod(name string, mode FileMode) error\n    Chmod changes the mode of the named file to mode. If the file is a symbolic\n    link, it changes the mode of the link's target. If there is an error,\n    it will be of type *PathError.\n\n    A different subset of the mode bits are used, depending on the operating\n    system.\n\n    On Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and ModeSticky\n    are used.\n\n    On Windows, only the 0o200 bit (owner writable) of mode is used; it controls\n    whether the file's read-only attribute is set or cleared. The other bits are\n    currently unused. For compatibility with Go 1.12 and earlier, use a non-zero\n    mode. Use mode 0o400 for a read-only file and 0o600 for a readable+writable\n    file.\n\n    On Plan 9, the mode's permission bits, ModeAppend, ModeExclusive, and\n    ModeTemporary are used.\n\nfunc Chown(name string, uid, gid int) error\n    Chown changes the numeric uid and gid of the named file. If the file\n    is a symbolic link, it changes the uid and gid of the link's target.\n    A uid or gid of -1 means to not change that value. If there is an error,\n    it will be of type *PathError.\n\n    On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or\n    syscall.EPLAN9 error, wrapped in *PathError.\n\nfunc Chtimes(name string, atime time.Time, mtime time.Time) error\n    Chtimes changes the access and modification times of the named file, similar\n    to the Unix utime() or utimes() functions. A zero time.Time value will leave\n    the corresponding file time unchanged.\n\n    The underlying filesystem may truncate or round the values to a less precise\n    time unit. If there is an error, it will be of type *PathError.\n\nfunc Clearenv()\n    Clearenv deletes all environment variables.\n\nfunc CopyFS(dir string, fsys fs.FS) error\n    CopyFS copies the file system fsys into the directory dir, creating dir if\n    necessary.\n\n    Files are created with mode 0o666 plus any execute permissions from the\n    source, and directories are created with mode 0o777 (before umask).\n\n    CopyFS will not overwrite existing files. If a file name in fsys\n    already exists in the destination, CopyFS will return an error such that\n    errors.Is(err, fs.ErrExist) will be true.\n\n    Symbolic links in dir are followed.\n\n    New files added to fsys (including if dir is a subdirectory of fsys) while\n    CopyFS is running are not guaranteed to be copied.\n\n    Copying stops at and returns the first error encountered.\n\nfunc DirFS(dir string) fs.FS\n    DirFS returns a file system (an fs.FS) for the tree of files rooted at the\n    directory dir.\n\n    Note that DirFS(\"/prefix\") only guarantees that the Open calls\n    it makes to the operating system will begin with \"/prefix\":\n    DirFS(\"/prefix\").Open(\"file\") is the same as os.Open(\"/prefix/file\").\n    So if /prefix/file is a symbolic link pointing outside the /prefix tree,\n    then using DirFS does not stop the access any more than using os.Open does.\n    Additionally, the root of the fs.FS returned for a relative path,\n    DirFS(\"prefix\"), will be affected by later calls to Chdir. DirFS is\n    therefore not a general substitute for a chroot-style security mechanism\n    when the directory tree contains arbitrary content.\n\n    Use Root.FS to obtain a fs.FS that prevents escapes from the tree via\n    symbolic links.\n\n    The directory dir must not be \"\".\n\n    The result implements io/fs.StatFS, io/fs.ReadFileFS, io/fs.ReadDirFS,\n    and io/fs.ReadLinkFS.\n\nfunc Environ() []string\n    Environ returns a copy of strings representing the environment, in the form\n    \"key=value\".\n\nfunc Executable() (string, error)\n    Executable returns the path name for the executable that started the current\n    process. There is no guarantee that the path is still pointing to the\n    correct executable. If a symlink was used to start the process, depending on\n    the operating system, the result might be the symlink or the path it pointed\n    to. If a stable result is needed, path/filepath.EvalSymlinks might help.\n\n    Executable returns an absolute path unless an error occurred.\n\n    The main use case is finding resources located relative to an executable.\n\nfunc Exit(code int)\n    Exit causes the current program to exit with the given status code.\n    Conventionally, code zero indicates success, non-zero an error. The program\n    terminates immediately; deferred functions are not run.\n\n    For portability, the status code should be in the range [0, 125].\n\nfunc Expand(s string, mapping func(string) string) string\n    Expand replaces ${var} or $var in the string based on the mapping function.\n    For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).\n\nfunc ExpandEnv(s string) string\n    ExpandEnv replaces ${var} or $var in the string according to the values of\n    the current environment variables. References to undefined variables are\n    replaced by the empty string.\n\nfunc Getegid() int\n    Getegid returns the numeric effective group id of the caller.\n\n    On Windows, it returns -1.\n\nfunc Getenv(key string) string\n    Getenv retrieves the value of the environment variable named by the key.\n    It returns the value, which will be empty if the variable is not present.\n    To distinguish between an empty value and an unset value, use LookupEnv.\n\nfunc Geteuid() int\n    Geteuid returns the numeric effective user id of the caller.\n\n    On Windows, it returns -1.\n\nfunc Getgid() int\n    Getgid returns the numeric group id of the caller.\n\n    On Windows, it returns -1.\n\nfunc Getgroups() ([]int, error)\n    Getgroups returns a list of the numeric ids of groups that the caller\n    belongs to.\n\n    On Windows, it returns syscall.EWINDOWS. See the os/user package for a\n    possible alternative.\n\nfunc Getpagesize() int\n    Getpagesize returns the underlying system's memory page size.\n\nfunc Getpid() int\n    Getpid returns the process id of the caller.\n\nfunc Getppid() int\n    Getppid returns the process id of the caller's parent.\n\nfunc Getuid() int\n    Getuid returns the numeric user id of the caller.\n\n    On Windows, it returns -1.\n\nfunc Getwd() (dir string, err error)\n    Getwd returns an absolute path name corresponding to the current directory.\n    If the current directory can be reached via multiple paths (due to symbolic\n    links), Getwd may return any one of them.\n\n    On Unix platforms, if the environment variable PWD provides an absolute\n    name, and it is a name of the current directory, it is returned.\n\nfunc Hostname() (name string, err error)\n    Hostname returns the host name reported by the kernel.\n\nfunc IsExist(err error) bool\n    IsExist returns a boolean indicating whether its argument is known to report\n    that a file or directory already exists. It is satisfied by ErrExist as well\n    as some syscall errors.\n\n    This function predates errors.Is. It only supports errors returned by the os\n    package. New code should use errors.Is(err, fs.ErrExist).\n\nfunc IsNotExist(err error) bool\n    IsNotExist returns a boolean indicating whether its argument is known\n    to report that a file or directory does not exist. It is satisfied by\n    ErrNotExist as well as some syscall errors.\n\n    This function predates errors.Is. It only supports errors returned by the os\n    package. New code should use errors.Is(err, fs.ErrNotExist).\n\nfunc IsPathSeparator(c uint8) bool\n    IsPathSeparator reports whether c is a directory separator character.\n\nfunc IsPermission(err error) bool\n    IsPermission returns a boolean indicating whether its argument is known to\n    report that permission is denied. It is satisfied by ErrPermission as well\n    as some syscall errors.\n\n    This function predates errors.Is. It only supports errors returned by the os\n    package. New code should use errors.Is(err, fs.ErrPermission).\n\nfunc IsTimeout(err error) bool\n    IsTimeout returns a boolean indicating whether its argument is known to\n    report that a timeout occurred.\n\n    This function predates errors.Is, and the notion of whether an error\n    indicates a timeout can be ambiguous. For example, the Unix error\n    EWOULDBLOCK sometimes indicates a timeout and sometimes does not. New code\n    should use errors.Is with a value appropriate to the call returning the\n    error, such as os.ErrDeadlineExceeded.\n\nfunc Lchown(name string, uid, gid int) error\n    Lchown changes the numeric uid and gid of the named file. If the file is a\n    symbolic link, it changes the uid and gid of the link itself. If there is an\n    error, it will be of type *PathError.\n\n    On Windows, it always returns the syscall.EWINDOWS error, wrapped in\n    *PathError.\n\nfunc Link(oldname, newname string) error\n    Link creates newname as a hard link to the oldname file. If there is an\n    error, it will be of type *LinkError.\n\nfunc LookupEnv(key string) (string, bool)\n    LookupEnv retrieves the value of the environment variable named by the key.\n    If the variable is present in the environment the value (which may be empty)\n    is returned and the boolean is true. Otherwise the returned value will be\n    empty and the boolean will be false.\n\nfunc Mkdir(name string, perm FileMode) error\n    Mkdir creates a new directory with the specified name and permission bits\n    (before umask). If there is an error, it will be of type *PathError.\n\nfunc MkdirAll(path string, perm FileMode) error\n    MkdirAll creates a directory named path, along with any necessary parents,\n    and returns nil, or else returns an error. The permission bits perm (before\n    umask) are used for all directories that MkdirAll creates. If path is\n    already a directory, MkdirAll does nothing and returns nil.\n\nfunc MkdirTemp(dir, pattern string) (string, error)\n    MkdirTemp creates a new temporary directory in the directory dir and returns\n    the pathname of the new directory. The new directory's name is generated by\n    adding a random string to the end of pattern. If pattern includes a \"*\",\n    the random string replaces the last \"*\" instead. The directory is created\n    with mode 0o700 (before umask). If dir is the empty string, MkdirTemp uses\n    the default directory for temporary files, as returned by TempDir. Multiple\n    programs or goroutines calling MkdirTemp simultaneously will not choose the\n    same directory. It is the caller's responsibility to remove the directory\n    when it is no longer needed.\n\nfunc NewSyscallError(syscall string, err error) error\n    NewSyscallError returns, as an error, a new SyscallError with the given\n    system call name and error details. As a convenience, if err is nil,\n    NewSyscallError returns nil.\n\nfunc Pipe() (r *File, w *File, err error)\n    Pipe returns a connected pair of Files; reads from r return bytes written to\n    w. It returns the files and an error, if any.\n\nfunc ReadFile(name string) ([]byte, error)\n    ReadFile reads the named file and returns the contents. A successful call\n    returns err == nil, not err == EOF. Because ReadFile reads the whole file,\n    it does not treat an EOF from Read as an error to be reported.\n\nfunc Readlink(name string) (string, error)\n    Readlink returns the destination of the named symbolic link. If there is an\n    error, it will be of type *PathError.\n\n    If the link destination is relative, Readlink returns the relative path\n    without resolving it to an absolute one.\n\nfunc Remove(name string) error\n    Remove removes the named file or (empty) directory. If there is an error,\n    it will be of type *PathError.\n\nfunc RemoveAll(path string) error\n    RemoveAll removes path and any children it contains. It removes everything\n    it can but returns the first error it encounters. If the path does not\n    exist, RemoveAll returns nil (no error). If there is an error, it will be of\n    type *PathError.\n\nfunc Rename(oldpath, newpath string) error\n    Rename renames (moves) oldpath to newpath. If newpath already exists and\n    is not a directory, Rename replaces it. If newpath already exists and is\n    a directory, Rename returns an error. OS-specific restrictions may apply\n    when oldpath and newpath are in different directories. Even within the\n    same directory, on non-Unix platforms Rename is not an atomic operation.\n    If there is an error, it will be of type *LinkError.\n\nfunc SameFile(fi1, fi2 FileInfo) bool\n    SameFile reports whether fi1 and fi2 describe the same file. For example,\n    on Unix this means that the device and inode fields of the two underlying\n    structures are identical; on other systems the decision may be based on the\n    path names. SameFile only applies to results returned by this package's\n    Stat. It returns false in other cases.\n\nfunc Setenv(key, value string) error\n    Setenv sets the value of the environment variable named by the key.\n    It returns an error, if any.\n\nfunc Symlink(oldname, newname string) error\n    Symlink creates newname as a symbolic link to oldname. On Windows, a symlink\n    to a non-existent oldname creates a file symlink; if oldname is later\n    created as a directory the symlink will not work. If there is an error,\n    it will be of type *LinkError.\n\nfunc TempDir() string\n    TempDir returns the default directory to use for temporary files.\n\n    On Unix systems, it returns $TMPDIR if non-empty, else /tmp. On Windows,\n    it uses GetTempPath, returning the first non-empty value from %TMP%, %TEMP%,\n    %USERPROFILE%, or the Windows directory. On Plan 9, it returns /tmp.\n\n    The directory is neither guaranteed to exist nor have accessible\n    permissions.\n\nfunc Truncate(name string, size int64) error\n    Truncate changes the size of the named file. If the file is a symbolic link,\n    it changes the size of the link's target. If there is an error, it will be\n    of type *PathError.\n\nfunc Unsetenv(key string) error\n    Unsetenv unsets a single environment variable.\n\nfunc UserCacheDir() (string, error)\n    UserCacheDir returns the default root directory to use for user-specific\n    cached data. Users should create their own application-specific subdirectory\n    within this one and use that.\n\n    On Unix systems, it returns $XDG_CACHE_HOME as specified by\n    https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\n    if non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches.\n    On Windows, it returns %LocalAppData%. On Plan 9, it returns\n    $home/lib/cache.\n\n    If the location cannot be determined (for example, $HOME is not defined) or\n    the path in $XDG_CACHE_HOME is relative, then it will return an error.\n\nfunc UserConfigDir() (string, error)\n    UserConfigDir returns the default root directory to use for user-specific\n    configuration data. Users should create their own application-specific\n    subdirectory within this one and use that.\n\n    On Unix systems, it returns $XDG_CONFIG_HOME as specified by\n    https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\n    if non-empty, else $HOME/.config. On Darwin, it returns\n    $HOME/Library/Application Support. On Windows, it returns %AppData%. On Plan\n    9, it returns $home/lib.\n\n    If the location cannot be determined (for example, $HOME is not defined) or\n    the path in $XDG_CONFIG_HOME is relative, then it will return an error.\n\nfunc UserHomeDir() (string, error)\n    UserHomeDir returns the current user's home directory.\n\n    On Unix, including macOS, it returns the $HOME environment variable.\n    On Windows, it returns %USERPROFILE%. On Plan 9, it returns the $home\n    environment variable.\n\n    If the expected variable is not set in the environment, UserHomeDir returns\n    either a platform-specific default value or a non-nil error.\n\nfunc WriteFile(name string, data []byte, perm FileMode) error\n    WriteFile writes data to the named file, creating it if necessary. If the\n    file does not exist, WriteFile creates it with permissions perm (before\n    umask); otherwise WriteFile truncates it before writing, without changing\n    permissions. Since WriteFile requires multiple system calls to complete,\n    a failure mid-operation can leave the file in a partially written state.\n\n\nTYPES\n\ntype DirEntry = fs.DirEntry\n    A DirEntry is an entry read from a directory (using the ReadDir function or\n    a File.ReadDir method).\n\nfunc ReadDir(name string) ([]DirEntry, error)\n    ReadDir reads the named directory, returning all its directory entries\n    sorted by filename. If an error occurs reading the directory, ReadDir\n    returns the entries it was able to read before the error, along with the\n    error.\n\ntype File struct {\n\t// Has unexported fields.\n}\n    File represents an open file descriptor.\n\n    The methods of File are safe for concurrent use.\n\nfunc Create(name string) (*File, error)\n    Create creates or truncates the named file. If the file already exists,\n    it is truncated. If the file does not exist, it is created with mode 0o666\n    (before umask). If successful, methods on the returned File can be used\n    for I/O; the associated file descriptor has mode O_RDWR. The directory\n    containing the file must already exist. If there is an error, it will be of\n    type *PathError.\n\nfunc CreateTemp(dir, pattern string) (*File, error)\n    CreateTemp creates a new temporary file in the directory dir, opens the\n    file for reading and writing, and returns the resulting file. The filename\n    is generated by taking pattern and adding a random string to the end.\n    If pattern includes a \"*\", the random string replaces the last \"*\". The\n    file is created with mode 0o600 (before umask). If dir is the empty string,\n    CreateTemp uses the default directory for temporary files, as returned by\n    TempDir. Multiple programs or goroutines calling CreateTemp simultaneously\n    will not choose the same file. The caller can use the file's Name method to\n    find the pathname of the file. It is the caller's responsibility to remove\n    the file when it is no longer needed.\n\nfunc NewFile(fd uintptr, name string) *File\n    NewFile returns a new File with the given file descriptor and name.\n    The returned value will be nil if fd is not a valid file descriptor.\n\n    NewFile's behavior differs on some platforms:\n\n      - On Unix, if fd is in non-blocking mode, NewFile will attempt to return a\n        pollable file.\n      - On Windows, if fd is opened for asynchronous I/O (that is,\n        syscall.FILE_FLAG_OVERLAPPED has been specified in the\n        syscall.CreateFile call), NewFile will attempt to return a pollable\n        file by associating fd with the Go runtime I/O completion port. The I/O\n        operations will be performed synchronously if the association fails.\n\n    Only pollable files support File.SetDeadline, File.SetReadDeadline,\n    and File.SetWriteDeadline.\n\n    After passing it to NewFile, fd may become invalid under the same conditions\n    described in the comments of File.Fd, and the same constraints apply.\n\nfunc Open(name string) (*File, error)\n    Open opens the named file for reading. If successful, methods on the\n    returned file can be used for reading; the associated file descriptor has\n    mode O_RDONLY. If there is an error, it will be of type *PathError.\n\nfunc OpenFile(name string, flag int, perm FileMode) (*File, error)\n    OpenFile is the generalized open call; most users will use Open or Create\n    instead. It opens the named file with specified flag (O_RDONLY etc.).\n    If the file does not exist, and the O_CREATE flag is passed, it is created\n    with mode perm (before umask); the containing directory must exist.\n    If successful, methods on the returned File can be used for I/O. If there is\n    an error, it will be of type *PathError.\n\nfunc OpenInRoot(dir, name string) (*File, error)\n    OpenInRoot opens the file name in the directory dir. It is equivalent to\n    OpenRoot(dir) followed by opening the file in the root.\n\n    OpenInRoot returns an error if any component of the name references a\n    location outside of dir.\n\n    See Root for details and limitations.\n\nfunc (f *File) Chdir() error\n    Chdir changes the current working directory to the file, which must be a\n    directory. If there is an error, it will be of type *PathError.\n\nfunc (f *File) Chmod(mode FileMode) error\n    Chmod changes the mode of the file to mode. If there is an error, it will be\n    of type *PathError.\n\nfunc (f *File) Chown(uid, gid int) error\n    Chown changes the numeric uid and gid of the named file. If there is an\n    error, it will be of type *PathError.\n\n    On Windows, it always returns the syscall.EWINDOWS error, wrapped in\n    *PathError.\n\nfunc (f *File) Close() error\n    Close closes the File, rendering it unusable for I/O. On files that support\n    File.SetDeadline, any pending I/O operations will be canceled and return\n    immediately with an ErrClosed error. Close will return an error if it has\n    already been called.\n\nfunc (f *File) Fd() uintptr\n    Fd returns the system file descriptor or handle referencing the open file.\n    If f is closed, the descriptor becomes invalid. If f is garbage\n    collected, a finalizer may close the descriptor, making it invalid; see\n    runtime.SetFinalizer for more information on when a finalizer might be run.\n\n    Do not close the returned descriptor; that could cause a later close of f to\n    close an unrelated descriptor.\n\n    Fd's behavior differs on some platforms:\n\n      - On Unix and Windows, File.SetDeadline methods will stop working.\n      - On Windows, the file descriptor will be disassociated from the Go\n        runtime I/O completion port if there are no concurrent I/O operations on\n        the file.\n\n    For most uses prefer the f.SyscallConn method.\n\nfunc (f *File) Name() string\n    Name returns the name of the file as presented to Open.\n\n    It is safe to call Name after [Close].\n\nfunc (f *File) Read(b []byte) (n int, err error)\n    Read reads up to len(b) bytes from the File and stores them in b. It\n    returns the number of bytes read and any error encountered. At end of file,\n    Read returns 0, io.EOF.\n\nfunc (f *File) ReadAt(b []byte, off int64) (n int, err error)\n    ReadAt reads len(b) bytes from the File starting at byte offset off.\n    It returns the number of bytes read and the error, if any. ReadAt always\n    returns a non-nil error when n < len(b). At end of file, that error is\n    io.EOF.\n\nfunc (f *File) ReadDir(n int) ([]DirEntry, error)\n    ReadDir reads the contents of the directory associated with the file f and\n    returns a slice of DirEntry values in directory order. Subsequent calls on\n    the same file will yield later DirEntry records in the directory.\n\n    If n > 0, ReadDir returns at most n DirEntry records. In this case,\n    if ReadDir returns an empty slice, it will return an error explaining why.\n    At the end of a directory, the error is io.EOF.\n\n    If n <= 0, ReadDir returns all the DirEntry records remaining in the\n    directory. When it succeeds, it returns a nil error (not io.EOF).\n\nfunc (f *File) ReadFrom(r io.Reader) (n int64, err error)\n    ReadFrom implements io.ReaderFrom.\n\nfunc (f *File) Readdir(n int) ([]FileInfo, error)\n    Readdir reads the contents of the directory associated with file and\n    returns a slice of up to n FileInfo values, as would be returned by Lstat,\n    in directory order. Subsequent calls on the same file will yield further\n    FileInfos.\n\n    If n > 0, Readdir returns at most n FileInfo structures. In this case,\n    if Readdir returns an empty slice, it will return a non-nil error explaining\n    why. At the end of a directory, the error is io.EOF.\n\n    If n <= 0, Readdir returns all the FileInfo from the directory in a single\n    slice. In this case, if Readdir succeeds (reads all the way to the end of\n    the directory), it returns the slice and a nil error. If it encounters an\n    error before the end of the directory, Readdir returns the FileInfo read\n    until that point and a non-nil error.\n\n    Most clients are better served by the more efficient ReadDir method.\n\nfunc (f *File) Readdirnames(n int) (names []string, err error)\n    Readdirnames reads the contents of the directory associated with file and\n    returns a slice of up to n names of files in the directory, in directory\n    order. Subsequent calls on the same file will yield further names.\n\n    If n > 0, Readdirnames returns at most n names. In this case,\n    if Readdirnames returns an empty slice, it will return a non-nil error\n    explaining why. At the end of a directory, the error is io.EOF.\n\n    If n <= 0, Readdirnames returns all the names from the directory in a single\n    slice. In this case, if Readdirnames succeeds (reads all the way to the end\n    of the directory), it returns the slice and a nil error. If it encounters an\n    error before the end of the directory, Readdirnames returns the names read\n    until that point and a non-nil error.\n\nfunc (f *File) Seek(offset int64, whence int) (ret int64, err error)\n    Seek sets the offset for the next Read or Write on file to offset,\n    interpreted according to whence: 0 means relative to the origin of the file,\n    1 means relative to the current offset, and 2 means relative to the end.\n    It returns the new offset and an error, if any. The behavior of Seek on a\n    file opened with O_APPEND is not specified.\n\nfunc (f *File) SetDeadline(t time.Time) error\n    SetDeadline sets the read and write deadlines for a File. It is equivalent\n    to calling both SetReadDeadline and SetWriteDeadline.\n\n    Only some kinds of files support setting a deadline. Calls to SetDeadline\n    for files that do not support deadlines will return ErrNoDeadline. On most\n    systems ordinary files do not support deadlines, but pipes do.\n\n    A deadline is an absolute time after which I/O operations fail with an error\n    instead of blocking. The deadline applies to all future and pending I/O,\n    not just the immediately following call to Read or Write. After a deadline\n    has been exceeded, the connection can be refreshed by setting a deadline in\n    the future.\n\n    If the deadline is exceeded a call to Read or Write or to other I/O methods\n    will return an error that wraps ErrDeadlineExceeded. This can be tested\n    using errors.Is(err, os.ErrDeadlineExceeded). That error implements the\n    Timeout method, and calling the Timeout method will return true, but there\n    are other possible errors for which the Timeout will return true even if the\n    deadline has not been exceeded.\n\n    An idle timeout can be implemented by repeatedly extending the deadline\n    after successful Read or Write calls.\n\n    A zero value for t means I/O operations will not time out.\n\nfunc (f *File) SetReadDeadline(t time.Time) error\n    SetReadDeadline sets the deadline for future Read calls and any\n    currently-blocked Read call. A zero value for t means Read will not time\n    out. Not all files support setting deadlines; see SetDeadline.\n\nfunc (f *File) SetWriteDeadline(t time.Time) error\n    SetWriteDeadline sets the deadline for any future Write calls and any\n    currently-blocked Write call. Even if Write times out, it may return n > 0,\n    indicating that some of the data was successfully written. A zero value for\n    t means Write will not time out. Not all files support setting deadlines;\n    see SetDeadline.\n\nfunc (f *File) Stat() (FileInfo, error)\n    Stat returns the FileInfo structure describing file. If there is an error,\n    it will be of type *PathError.\n\nfunc (f *File) Sync() error\n    Sync commits the current contents of the file to stable storage. Typically,\n    this means flushing the file system's in-memory copy of recently written\n    data to disk.\n\nfunc (f *File) SyscallConn() (syscall.RawConn, error)\n    SyscallConn returns a raw file. This implements the syscall.Conn interface.\n\nfunc (f *File) Truncate(size int64) error\n    Truncate changes the size of the file. It does not change the I/O offset.\n    If there is an error, it will be of type *PathError.\n\nfunc (f *File) Write(b []byte) (n int, err error)\n    Write writes len(b) bytes from b to the File. It returns the number of\n    bytes written and an error, if any. Write returns a non-nil error when n !=\n    len(b).\n\nfunc (f *File) WriteAt(b []byte, off int64) (n int, err error)\n    WriteAt writes len(b) bytes to the File starting at byte offset off.\n    It returns the number of bytes written and an error, if any. WriteAt returns\n    a non-nil error when n != len(b).\n\n    If file was opened with the O_APPEND flag, WriteAt returns an error.\n\nfunc (f *File) WriteString(s string) (n int, err error)\n    WriteString is like Write, but writes the contents of string s rather than a\n    slice of bytes.\n\nfunc (f *File) WriteTo(w io.Writer) (n int64, err error)\n    WriteTo implements io.WriterTo.\n\ntype FileInfo = fs.FileInfo\n    A FileInfo describes a file and is returned by Stat and Lstat.\n\nfunc Lstat(name string) (FileInfo, error)\n    Lstat returns a FileInfo describing the named file. If the file is a\n    symbolic link, the returned FileInfo describes the symbolic link. Lstat\n    makes no attempt to follow the link. If there is an error, it will be of\n    type *PathError.\n\n    On Windows, if the file is a reparse point that is a surrogate for another\n    named entity (such as a symbolic link or mounted folder), the returned\n    FileInfo describes the reparse point, and makes no attempt to resolve it.\n\nfunc Stat(name string) (FileInfo, error)\n    Stat returns a FileInfo describing the named file. If there is an error,\n    it will be of type *PathError.\n\ntype FileMode = fs.FileMode\n    A FileMode represents a file's mode and permission bits. The bits have the\n    same definition on all systems, so that information about files can be moved\n    from one system to another portably. Not all bits apply to all systems.\n    The only required bit is ModeDir for directories.\n\ntype LinkError struct {\n\tOp  string\n\tOld string\n\tNew string\n\tErr error\n}\n    LinkError records an error during a link or symlink or rename system call\n    and the paths that caused it.\n\nfunc (e *LinkError) Error() string\n\nfunc (e *LinkError) Unwrap() error\n\ntype PathError = fs.PathError\n    PathError records an error and the operation and file path that caused it.\n\ntype ProcAttr struct {\n\t// If Dir is non-empty, the child changes into the directory before\n\t// creating the process.\n\tDir string\n\t// If Env is non-nil, it gives the environment variables for the\n\t// new process in the form returned by Environ.\n\t// If it is nil, the result of Environ will be used.\n\tEnv []string\n\t// Files specifies the open files inherited by the new process. The\n\t// first three entries correspond to standard input, standard output, and\n\t// standard error. An implementation may support additional entries,\n\t// depending on the underlying operating system. A nil entry corresponds\n\t// to that file being closed when the process starts.\n\t// On Unix systems, StartProcess will change these File values\n\t// to blocking mode, which means that SetDeadline will stop working\n\t// and calling Close will not interrupt a Read or Write.\n\tFiles []*File\n\n\t// Operating system-specific process creation attributes.\n\t// Note that setting this field means that your program\n\t// may not execute properly or even compile on some\n\t// operating systems.\n\tSys *syscall.SysProcAttr\n}\n    ProcAttr holds the attributes that will be applied to a new process started\n    by StartProcess.\n\ntype Process struct {\n\tPid int\n\n\t// Has unexported fields.\n}\n    Process stores the information about a process created by StartProcess.\n\nfunc FindProcess(pid int) (*Process, error)\n    FindProcess looks for a running process by its pid.\n\n    The Process it returns can be used to obtain information about the\n    underlying operating system process.\n\n    On Unix systems, FindProcess always succeeds and returns a Process for the\n    given pid, regardless of whether the process exists. To test whether the\n    process actually exists, see whether p.Signal(syscall.Signal(0)) reports an\n    error.\n\nfunc StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)\n    StartProcess starts a new process with the program, arguments and attributes\n    specified by name, argv and attr. The argv slice will become os.Args in the\n    new process, so it normally starts with the program name.\n\n    If the calling goroutine has locked the operating system thread with\n    runtime.LockOSThread and modified any inheritable OS-level thread state\n    (for example, Linux or Plan 9 name spaces), the new process will inherit the\n    caller's thread state.\n\n    StartProcess is a low-level interface. The os/exec package provides\n    higher-level interfaces.\n\n    If there is an error, it will be of type *PathError.\n\nfunc (p *Process) Kill() error\n    Kill causes the Process to exit immediately. Kill does not wait until the\n    Process has actually exited. This only kills the Process itself, not any\n    other processes it may have started.\n\nfunc (p *Process) Release() error\n    Release releases any resources associated with the Process p, rendering it\n    unusable in the future. Release only needs to be called if Process.Wait is\n    not.\n\nfunc (p *Process) Signal(sig Signal) error\n    Signal sends a signal to the Process. Sending Interrupt on Windows is not\n    implemented.\n\nfunc (p *Process) Wait() (*ProcessState, error)\n    Wait waits for the Process to exit, and then returns a ProcessState\n    describing its status and an error, if any. Wait releases any resources\n    associated with the Process. On most operating systems, the Process must be\n    a child of the current process or an error will be returned.\n\ntype ProcessState struct {\n\t// Has unexported fields.\n}\n    ProcessState stores information about a process, as reported by Wait.\n\nfunc (p *ProcessState) ExitCode() int\n    ExitCode returns the exit code of the exited process, or -1 if the process\n    hasn't exited or was terminated by a signal.\n\nfunc (p *ProcessState) Exited() bool\n    Exited reports whether the program has exited. On Unix systems this reports\n    true if the program exited due to calling exit, but false if the program\n    terminated due to a signal.\n\nfunc (p *ProcessState) Pid() int\n    Pid returns the process id of the exited process.\n\nfunc (p *ProcessState) String() string\n\nfunc (p *ProcessState) Success() bool\n    Success reports whether the program exited successfully, such as with exit\n    status 0 on Unix.\n\nfunc (p *ProcessState) Sys() any\n    Sys returns system-dependent exit information about the process. Convert\n    it to the appropriate underlying type, such as syscall.WaitStatus on Unix,\n    to access its contents.\n\nfunc (p *ProcessState) SysUsage() any\n    SysUsage returns system-dependent resource usage information about the\n    exited process. Convert it to the appropriate underlying type, such as\n    *syscall.Rusage on Unix, to access its contents. (On Unix, *syscall.Rusage\n    matches struct rusage as defined in the getrusage(2) manual page.)\n\nfunc (p *ProcessState) SystemTime() time.Duration\n    SystemTime returns the system CPU time of the exited process and its\n    children.\n\nfunc (p *ProcessState) UserTime() time.Duration\n    UserTime returns the user CPU time of the exited process and its children.\n\ntype Root struct {\n\t// Has unexported fields.\n}\n    Root may be used to only access files within a single directory tree.\n\n    Methods on Root can only access files and directories beneath a root\n    directory. If any component of a file name passed to a method of Root\n    references a location outside the root, the method returns an error.\n    File names may reference the directory itself (.).\n\n    Methods on Root will follow symbolic links, but symbolic links may not\n    reference a location outside the root. Symbolic links must not be absolute.\n\n    Methods on Root do not prohibit traversal of filesystem boundaries, Linux\n    bind mounts, /proc special files, or access to Unix device files.\n\n    Methods on Root are safe to be used from multiple goroutines simultaneously.\n\n    On most platforms, creating a Root opens a file descriptor or handle\n    referencing the directory. If the directory is moved, methods on Root\n    reference the original directory in its new location.\n\n    Root's behavior differs on some platforms:\n\n      - When GOOS=windows, file names may not reference Windows reserved device\n        names such as NUL and COM1.\n      - On Unix, Root.Chmod, Root.Chown, and Root.Chtimes are vulnerable to a\n        race condition. If the target of the operation is changed from a regular\n        file to a symlink while the operation is in progress, the operation may\n        be performed on the link rather than the link target.\n      - When GOOS=js, Root is vulnerable to TOCTOU (time-of-check-time-of-use)\n        attacks in symlink validation, and cannot ensure that operations will\n        not escape the root.\n      - When GOOS=plan9 or GOOS=js, Root does not track directories across\n        renames. On these platforms, a Root references a directory name,\n        not a file descriptor.\n      - WASI preview 1 (GOOS=wasip1) does not support Root.Chmod.\n\nfunc OpenRoot(name string) (*Root, error)\n    OpenRoot opens the named directory. It follows symbolic links in the\n    directory name. If there is an error, it will be of type *PathError.\n\nfunc (r *Root) Chmod(name string, mode FileMode) error\n    Chmod changes the mode of the named file in the root to mode. See Chmod for\n    more details.\n\nfunc (r *Root) Chown(name string, uid, gid int) error\n    Chown changes the numeric uid and gid of the named file in the root.\n    See Chown for more details.\n\nfunc (r *Root) Chtimes(name string, atime time.Time, mtime time.Time) error\n    Chtimes changes the access and modification times of the named file in the\n    root. See Chtimes for more details.\n\nfunc (r *Root) Close() error\n    Close closes the Root. After Close is called, methods on Root return errors.\n\nfunc (r *Root) Create(name string) (*File, error)\n    Create creates or truncates the named file in the root. See Create for more\n    details.\n\nfunc (r *Root) FS() fs.FS\n    FS returns a file system (an fs.FS) for the tree of files in the root.\n\n    The result implements io/fs.StatFS, io/fs.ReadFileFS, io/fs.ReadDirFS,\n    and io/fs.ReadLinkFS.\n\nfunc (r *Root) Lchown(name string, uid, gid int) error\n    Lchown changes the numeric uid and gid of the named file in the root.\n    See Lchown for more details.\n\nfunc (r *Root) Link(oldname, newname string) error\n    Link creates newname as a hard link to the oldname file. Both paths are\n    relative to the root. See Link for more details.\n\n    If oldname is a symbolic link, Link creates new link to oldname and not its\n    target. This behavior may differ from that of Link on some platforms.\n\n    When GOOS=js, Link returns an error if oldname is a symbolic link.\n\nfunc (r *Root) Lstat(name string) (FileInfo, error)\n    Lstat returns a FileInfo describing the named file in the root. If the file\n    is a symbolic link, the returned FileInfo describes the symbolic link.\n    See Lstat for more details.\n\nfunc (r *Root) Mkdir(name string, perm FileMode) error\n    Mkdir creates a new directory in the root with the specified name and\n    permission bits (before umask). See Mkdir for more details.\n\n    If perm contains bits other than the nine least-significant bits (0o777),\n    Mkdir returns an error.\n\nfunc (r *Root) MkdirAll(name string, perm FileMode) error\n    MkdirAll creates a new directory in the root, along with any necessary\n    parents. See MkdirAll for more details.\n\n    If perm contains bits other than the nine least-significant bits (0o777),\n    MkdirAll returns an error.\n\nfunc (r *Root) Name() string\n    Name returns the name of the directory presented to OpenRoot.\n\n    It is safe to call Name after [Close].\n\nfunc (r *Root) Open(name string) (*File, error)\n    Open opens the named file in the root for reading. See Open for more\n    details.\n\nfunc (r *Root) OpenFile(name string, flag int, perm FileMode) (*File, error)\n    OpenFile opens the named file in the root. See OpenFile for more details.\n\n    If perm contains bits other than the nine least-significant bits (0o777),\n    OpenFile returns an error.\n\nfunc (r *Root) OpenRoot(name string) (*Root, error)\n    OpenRoot opens the named directory in the root. If there is an error,\n    it will be of type *PathError.\n\nfunc (r *Root) ReadFile(name string) ([]byte, error)\n    ReadFile reads the named file in the root and returns its contents.\n    See ReadFile for more details.\n\nfunc (r *Root) Readlink(name string) (string, error)\n    Readlink returns the destination of the named symbolic link in the root.\n    See Readlink for more details.\n\nfunc (r *Root) Remove(name string) error\n    Remove removes the named file or (empty) directory in the root. See Remove\n    for more details.\n\nfunc (r *Root) RemoveAll(name string) error\n    RemoveAll removes the named file or directory and any children that it\n    contains. See RemoveAll for more details.\n\nfunc (r *Root) Rename(oldname, newname string) error\n    Rename renames (moves) oldname to newname. Both paths are relative to the\n    root. See Rename for more details.\n\nfunc (r *Root) Stat(name string) (FileInfo, error)\n    Stat returns a FileInfo describing the named file in the root. See Stat for\n    more details.\n\nfunc (r *Root) Symlink(oldname, newname string) error\n    Symlink creates newname as a symbolic link to oldname. See Symlink for more\n    details.\n\n    Symlink does not validate oldname, which may reference a location outside\n    the root.\n\n    On Windows, a directory link is created if oldname references a directory\n    within the root. Otherwise a file link is created.\n\nfunc (r *Root) WriteFile(name string, data []byte, perm FileMode) error\n    WriteFile writes data to the named file in the root, creating it if\n    necessary. See WriteFile for more details.\n\ntype Signal interface {\n\tString() string\n\tSignal() // to distinguish from other Stringers\n}\n    A Signal represents an operating system signal. The usual underlying\n    implementation is operating system-dependent: on Unix it is syscall.Signal.\n\nvar (\n\tInterrupt Signal = syscall.SIGINT\n\tKill      Signal = syscall.SIGKILL\n)\n    The only signal values guaranteed to be present in the os package on all\n    systems are os.Interrupt (send the process an interrupt) and os.Kill (force\n    the process to exit). On Windows, sending os.Interrupt to a process with\n    os.Process.Signal is not implemented; it will return an error instead of\n    sending a signal.\n\ntype SyscallError struct {\n\tSyscall string\n\tErr     error\n}\n    SyscallError records an error from a specific system call.\n\nfunc (e *SyscallError) Error() string\n\nfunc (e *SyscallError) Timeout() bool\n    Timeout reports whether this error represents a timeout.\n\nfunc (e *SyscallError) Unwrap() error\n\n"}, {"path": "stdlib/sync-atomic.md", "category": "stdlib", "name": "stdlib/sync-atomic", "content": "package atomic // import \"sync/atomic\"\n\nPackage atomic provides low-level atomic memory primitives useful for\nimplementing synchronization algorithms.\n\nThese functions require great care to be used correctly. Except for special,\nlow-level applications, synchronization is better done with channels or the\nfacilities of the sync package. Share memory by communicating; don't communicate\nby sharing memory.\n\nThe swap operation, implemented by the SwapT functions, is the atomic equivalent\nof:\n\n    old = *addr\n    *addr = new\n    return old\n\nThe compare-and-swap operation, implemented by the CompareAndSwapT functions,\nis the atomic equivalent of:\n\n    if *addr == old {\n    \t*addr = new\n    \treturn true\n    }\n    return false\n\nThe add operation, implemented by the AddT functions, is the atomic equivalent\nof:\n\n    *addr += delta\n    return *addr\n\nThe load and store operations, implemented by the LoadT and StoreT functions,\nare the atomic equivalents of \"return *addr\" and \"*addr = val\".\n\nIn the terminology of the Go memory model, if the effect of an atomic\noperation A is observed by atomic operation B, then A \u201csynchronizes before\u201d B.\nAdditionally, all the atomic operations executed in a program behave as though\nexecuted in some sequentially consistent order. This definition provides the\nsame semantics as C++'s sequentially consistent atomics and Java's volatile\nvariables.\n\n[the Go memory model]: https://go.dev/ref/mem\n\nFUNCTIONS\n\nfunc AddInt32(addr *int32, delta int32) (new int32)\n    AddInt32 atomically adds delta to *addr and returns the new value. Consider\n    using the more ergonomic and less error-prone Int32.Add instead.\n\nfunc AddInt64(addr *int64, delta int64) (new int64)\n    AddInt64 atomically adds delta to *addr and returns the new value.\n    Consider using the more ergonomic and less error-prone Int64.Add instead\n    (particularly if you target 32-bit platforms; see the bugs section).\n\nfunc AddUint32(addr *uint32, delta uint32) (new uint32)\n    AddUint32 atomically adds delta to *addr and returns the new value.\n    To subtract a signed positive constant value c from x, do AddUint32(&x,\n    ^uint32(c-1)). In particular, to decrement x, do AddUint32(&x, ^uint32(0)).\n    Consider using the more ergonomic and less error-prone Uint32.Add instead.\n\nfunc AddUint64(addr *uint64, delta uint64) (new uint64)\n    AddUint64 atomically adds delta to *addr and returns the new value.\n    To subtract a signed positive constant value c from x, do AddUint64(&x,\n    ^uint64(c-1)). In particular, to decrement x, do AddUint64(&x, ^uint64(0)).\n    Consider using the more ergonomic and less error-prone Uint64.Add instead\n    (particularly if you target 32-bit platforms; see the bugs section).\n\nfunc AddUintptr(addr *uintptr, delta uintptr) (new uintptr)\n    AddUintptr atomically adds delta to *addr and returns the new value.\n    Consider using the more ergonomic and less error-prone Uintptr.Add instead.\n\nfunc AndInt32(addr *int32, mask int32) (old int32)\n    AndInt32 atomically performs a bitwise AND operation on *addr using the\n    bitmask provided as mask and returns the old value. Consider using the more\n    ergonomic and less error-prone Int32.And instead.\n\nfunc AndInt64(addr *int64, mask int64) (old int64)\n    AndInt64 atomically performs a bitwise AND operation on *addr using the\n    bitmask provided as mask and returns the old value. Consider using the more\n    ergonomic and less error-prone Int64.And instead.\n\nfunc AndUint32(addr *uint32, mask uint32) (old uint32)\n    AndUint32 atomically performs a bitwise AND operation on *addr using the\n    bitmask provided as mask and returns the old value. Consider using the more\n    ergonomic and less error-prone Uint32.And instead.\n\nfunc AndUint64(addr *uint64, mask uint64) (old uint64)\n    AndUint64 atomically performs a bitwise AND operation on *addr using the\n    bitmask provided as mask and returns the old. Consider using the more\n    ergonomic and less error-prone Uint64.And instead.\n\nfunc AndUintptr(addr *uintptr, mask uintptr) (old uintptr)\n    AndUintptr atomically performs a bitwise AND operation on *addr using the\n    bitmask provided as mask and returns the old value. Consider using the more\n    ergonomic and less error-prone Uintptr.And instead.\n\nfunc CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)\n    CompareAndSwapInt32 executes the compare-and-swap operation for an\n    int32 value. Consider using the more ergonomic and less error-prone\n    Int32.CompareAndSwap instead.\n\nfunc CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)\n    CompareAndSwapInt64 executes the compare-and-swap operation for an\n    int64 value. Consider using the more ergonomic and less error-prone\n    Int64.CompareAndSwap instead (particularly if you target 32-bit platforms;\n    see the bugs section).\n\nfunc CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)\n    CompareAndSwapPointer executes the compare-and-swap operation for a\n    unsafe.Pointer value. Consider using the more ergonomic and less error-prone\n    Pointer.CompareAndSwap instead.\n\nfunc CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)\n    CompareAndSwapUint32 executes the compare-and-swap operation for a\n    uint32 value. Consider using the more ergonomic and less error-prone\n    Uint32.CompareAndSwap instead.\n\nfunc CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)\n    CompareAndSwapUint64 executes the compare-and-swap operation for a\n    uint64 value. Consider using the more ergonomic and less error-prone\n    Uint64.CompareAndSwap instead (particularly if you target 32-bit platforms;\n    see the bugs section).\n\nfunc CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)\n    CompareAndSwapUintptr executes the compare-and-swap operation for a\n    uintptr value. Consider using the more ergonomic and less error-prone\n    Uintptr.CompareAndSwap instead.\n\nfunc LoadInt32(addr *int32) (val int32)\n    LoadInt32 atomically loads *addr. Consider using the more ergonomic and less\n    error-prone Int32.Load instead.\n\nfunc LoadInt64(addr *int64) (val int64)\n    LoadInt64 atomically loads *addr. Consider using the more ergonomic and less\n    error-prone Int64.Load instead (particularly if you target 32-bit platforms;\n    see the bugs section).\n\nfunc LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)\n    LoadPointer atomically loads *addr. Consider using the more ergonomic and\n    less error-prone Pointer.Load instead.\n\nfunc LoadUint32(addr *uint32) (val uint32)\n    LoadUint32 atomically loads *addr. Consider using the more ergonomic and\n    less error-prone Uint32.Load instead.\n\nfunc LoadUint64(addr *uint64) (val uint64)\n    LoadUint64 atomically loads *addr. Consider using the more ergonomic and\n    less error-prone Uint64.Load instead (particularly if you target 32-bit\n    platforms; see the bugs section).\n\nfunc LoadUintptr(addr *uintptr) (val uintptr)\n    LoadUintptr atomically loads *addr. Consider using the more ergonomic and\n    less error-prone Uintptr.Load instead.\n\nfunc OrInt32(addr *int32, mask int32) (old int32)\n    OrInt32 atomically performs a bitwise OR operation on *addr using the\n    bitmask provided as mask and returns the old value. Consider using the more\n    ergonomic and less error-prone Int32.Or instead.\n\nfunc OrInt64(addr *int64, mask int64) (old int64)\n    OrInt64 atomically performs a bitwise OR operation on *addr using the\n    bitmask provided as mask and returns the old value. Consider using the more\n    ergonomic and less error-prone Int64.Or instead.\n\nfunc OrUint32(addr *uint32, mask uint32) (old uint32)\n    OrUint32 atomically performs a bitwise OR operation on *addr using the\n    bitmask provided as mask and returns the old value. Consider using the more\n    ergonomic and less error-prone Uint32.Or instead.\n\nfunc OrUint64(addr *uint64, mask uint64) (old uint64)\n    OrUint64 atomically performs a bitwise OR operation on *addr using the\n    bitmask provided as mask and returns the old value. Consider using the more\n    ergonomic and less error-prone Uint64.Or instead.\n\nfunc OrUintptr(addr *uintptr, mask uintptr) (old uintptr)\n    OrUintptr atomically performs a bitwise OR operation on *addr using the\n    bitmask provided as mask and returns the old value. Consider using the more\n    ergonomic and less error-prone Uintptr.Or instead.\n\nfunc StoreInt32(addr *int32, val int32)\n    StoreInt32 atomically stores val into *addr. Consider using the more\n    ergonomic and less error-prone Int32.Store instead.\n\nfunc StoreInt64(addr *int64, val int64)\n    StoreInt64 atomically stores val into *addr. Consider using the more\n    ergonomic and less error-prone Int64.Store instead (particularly if you\n    target 32-bit platforms; see the bugs section).\n\nfunc StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)\n    StorePointer atomically stores val into *addr. Consider using the more\n    ergonomic and less error-prone Pointer.Store instead.\n\nfunc StoreUint32(addr *uint32, val uint32)\n    StoreUint32 atomically stores val into *addr. Consider using the more\n    ergonomic and less error-prone Uint32.Store instead.\n\nfunc StoreUint64(addr *uint64, val uint64)\n    StoreUint64 atomically stores val into *addr. Consider using the more\n    ergonomic and less error-prone Uint64.Store instead (particularly if you\n    target 32-bit platforms; see the bugs section).\n\nfunc StoreUintptr(addr *uintptr, val uintptr)\n    StoreUintptr atomically stores val into *addr. Consider using the more\n    ergonomic and less error-prone Uintptr.Store instead.\n\nfunc SwapInt32(addr *int32, new int32) (old int32)\n    SwapInt32 atomically stores new into *addr and returns the previous *addr\n    value. Consider using the more ergonomic and less error-prone Int32.Swap\n    instead.\n\nfunc SwapInt64(addr *int64, new int64) (old int64)\n    SwapInt64 atomically stores new into *addr and returns the previous *addr\n    value. Consider using the more ergonomic and less error-prone Int64.Swap\n    instead (particularly if you target 32-bit platforms; see the bugs section).\n\nfunc SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)\n    SwapPointer atomically stores new into *addr and returns the previous *addr\n    value. Consider using the more ergonomic and less error-prone Pointer.Swap\n    instead.\n\nfunc SwapUint32(addr *uint32, new uint32) (old uint32)\n    SwapUint32 atomically stores new into *addr and returns the previous *addr\n    value. Consider using the more ergonomic and less error-prone Uint32.Swap\n    instead.\n\nfunc SwapUint64(addr *uint64, new uint64) (old uint64)\n    SwapUint64 atomically stores new into *addr and returns the previous *addr\n    value. Consider using the more ergonomic and less error-prone Uint64.Swap\n    instead (particularly if you target 32-bit platforms; see the bugs section).\n\nfunc SwapUintptr(addr *uintptr, new uintptr) (old uintptr)\n    SwapUintptr atomically stores new into *addr and returns the previous *addr\n    value. Consider using the more ergonomic and less error-prone Uintptr.Swap\n    instead.\n\n\nTYPES\n\ntype Bool struct {\n\t// Has unexported fields.\n}\n    A Bool is an atomic boolean value. The zero value is false.\n\n    Bool must not be copied after first use.\n\nfunc (x *Bool) CompareAndSwap(old, new bool) (swapped bool)\n    CompareAndSwap executes the compare-and-swap operation for the boolean value\n    x.\n\nfunc (x *Bool) Load() bool\n    Load atomically loads and returns the value stored in x.\n\nfunc (x *Bool) Store(val bool)\n    Store atomically stores val into x.\n\nfunc (x *Bool) Swap(new bool) (old bool)\n    Swap atomically stores new into x and returns the previous value.\n\ntype Int32 struct {\n\t// Has unexported fields.\n}\n    An Int32 is an atomic int32. The zero value is zero.\n\n    Int32 must not be copied after first use.\n\nfunc (x *Int32) Add(delta int32) (new int32)\n    Add atomically adds delta to x and returns the new value.\n\nfunc (x *Int32) And(mask int32) (old int32)\n    And atomically performs a bitwise AND operation on x using the bitmask\n    provided as mask and returns the old value.\n\nfunc (x *Int32) CompareAndSwap(old, new int32) (swapped bool)\n    CompareAndSwap executes the compare-and-swap operation for x.\n\nfunc (x *Int32) Load() int32\n    Load atomically loads and returns the value stored in x.\n\nfunc (x *Int32) Or(mask int32) (old int32)\n    Or atomically performs a bitwise OR operation on x using the bitmask\n    provided as mask and returns the old value.\n\nfunc (x *Int32) Store(val int32)\n    Store atomically stores val into x.\n\nfunc (x *Int32) Swap(new int32) (old int32)\n    Swap atomically stores new into x and returns the previous value.\n\ntype Int64 struct {\n\t// Has unexported fields.\n}\n    An Int64 is an atomic int64. The zero value is zero.\n\n    Int64 must not be copied after first use.\n\nfunc (x *Int64) Add(delta int64) (new int64)\n    Add atomically adds delta to x and returns the new value.\n\nfunc (x *Int64) And(mask int64) (old int64)\n    And atomically performs a bitwise AND operation on x using the bitmask\n    provided as mask and returns the old value.\n\nfunc (x *Int64) CompareAndSwap(old, new int64) (swapped bool)\n    CompareAndSwap executes the compare-and-swap operation for x.\n\nfunc (x *Int64) Load() int64\n    Load atomically loads and returns the value stored in x.\n\nfunc (x *Int64) Or(mask int64) (old int64)\n    Or atomically performs a bitwise OR operation on x using the bitmask\n    provided as mask and returns the old value.\n\nfunc (x *Int64) Store(val int64)\n    Store atomically stores val into x.\n\nfunc (x *Int64) Swap(new int64) (old int64)\n    Swap atomically stores new into x and returns the previous value.\n\ntype Pointer[T any] struct {\n\t// Has unexported fields.\n}\n    A Pointer is an atomic pointer of type *T. The zero value is a nil *T.\n\n    Pointer must not be copied after first use.\n\nfunc (x *Pointer[T]) CompareAndSwap(old, new *T) (swapped bool)\n    CompareAndSwap executes the compare-and-swap operation for x.\n\nfunc (x *Pointer[T]) Load() *T\n    Load atomically loads and returns the value stored in x.\n\nfunc (x *Pointer[T]) Store(val *T)\n    Store atomically stores val into x.\n\nfunc (x *Pointer[T]) Swap(new *T) (old *T)\n    Swap atomically stores new into x and returns the previous value.\n\ntype Uint32 struct {\n\t// Has unexported fields.\n}\n    A Uint32 is an atomic uint32. The zero value is zero.\n\n    Uint32 must not be copied after first use.\n\nfunc (x *Uint32) Add(delta uint32) (new uint32)\n    Add atomically adds delta to x and returns the new value.\n\nfunc (x *Uint32) And(mask uint32) (old uint32)\n    And atomically performs a bitwise AND operation on x using the bitmask\n    provided as mask and returns the old value.\n\nfunc (x *Uint32) CompareAndSwap(old, new uint32) (swapped bool)\n    CompareAndSwap executes the compare-and-swap operation for x.\n\nfunc (x *Uint32) Load() uint32\n    Load atomically loads and returns the value stored in x.\n\nfunc (x *Uint32) Or(mask uint32) (old uint32)\n    Or atomically performs a bitwise OR operation on x using the bitmask\n    provided as mask and returns the old value.\n\nfunc (x *Uint32) Store(val uint32)\n    Store atomically stores val into x.\n\nfunc (x *Uint32) Swap(new uint32) (old uint32)\n    Swap atomically stores new into x and returns the previous value.\n\ntype Uint64 struct {\n\t// Has unexported fields.\n}\n    A Uint64 is an atomic uint64. The zero value is zero.\n\n    Uint64 must not be copied after first use.\n\nfunc (x *Uint64) Add(delta uint64) (new uint64)\n    Add atomically adds delta to x and returns the new value.\n\nfunc (x *Uint64) And(mask uint64) (old uint64)\n    And atomically performs a bitwise AND operation on x using the bitmask\n    provided as mask and returns the old value.\n\nfunc (x *Uint64) CompareAndSwap(old, new uint64) (swapped bool)\n    CompareAndSwap executes the compare-and-swap operation for x.\n\nfunc (x *Uint64) Load() uint64\n    Load atomically loads and returns the value stored in x.\n\nfunc (x *Uint64) Or(mask uint64) (old uint64)\n    Or atomically performs a bitwise OR operation on x using the bitmask\n    provided as mask and returns the old value.\n\nfunc (x *Uint64) Store(val uint64)\n    Store atomically stores val into x.\n\nfunc (x *Uint64) Swap(new uint64) (old uint64)\n    Swap atomically stores new into x and returns the previous value.\n\ntype Uintptr struct {\n\t// Has unexported fields.\n}\n    A Uintptr is an atomic uintptr. The zero value is zero.\n\n    Uintptr must not be copied after first use.\n\nfunc (x *Uintptr) Add(delta uintptr) (new uintptr)\n    Add atomically adds delta to x and returns the new value.\n\nfunc (x *Uintptr) And(mask uintptr) (old uintptr)\n    And atomically performs a bitwise AND operation on x using the bitmask\n    provided as mask and returns the old value.\n\nfunc (x *Uintptr) CompareAndSwap(old, new uintptr) (swapped bool)\n    CompareAndSwap executes the compare-and-swap operation for x.\n\nfunc (x *Uintptr) Load() uintptr\n    Load atomically loads and returns the value stored in x.\n\nfunc (x *Uintptr) Or(mask uintptr) (old uintptr)\n    Or atomically performs a bitwise OR operation on x using the bitmask\n    provided as mask and returns the old value.\n\nfunc (x *Uintptr) Store(val uintptr)\n    Store atomically stores val into x.\n\nfunc (x *Uintptr) Swap(new uintptr) (old uintptr)\n    Swap atomically stores new into x and returns the previous value.\n\ntype Value struct {\n\t// Has unexported fields.\n}\n    A Value provides an atomic load and store of a consistently typed value.\n    The zero value for a Value returns nil from Value.Load. Once Value.Store has\n    been called, a Value must not be copied.\n\n    A Value must not be copied after first use.\n\nfunc (v *Value) CompareAndSwap(old, new any) (swapped bool)\n    CompareAndSwap executes the compare-and-swap operation for the Value.\n\n    All calls to CompareAndSwap for a given Value must use values of the same\n    concrete type. CompareAndSwap of an inconsistent type panics, as does\n    CompareAndSwap(old, nil).\n\nfunc (v *Value) Load() (val any)\n    Load returns the value set by the most recent Store. It returns nil if there\n    has been no call to Store for this Value.\n\nfunc (v *Value) Store(val any)\n    Store sets the value of the Value v to val. All calls to Store for a given\n    Value must use values of the same concrete type. Store of an inconsistent\n    type panics, as does Store(nil).\n\nfunc (v *Value) Swap(new any) (old any)\n    Swap stores new into Value and returns the previous value. It returns nil if\n    the Value is empty.\n\n    All calls to Swap for a given Value must use values of the same concrete\n    type. Swap of an inconsistent type panics, as does Swap(nil).\n\n\nBUG: On 386, the 64-bit functions use instructions unavailable before the Pentium MMX.\n\nOn non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core.\n\nOn ARM, 386, and 32-bit MIPS, it is the caller's responsibility to arrange\nfor 64-bit alignment of 64-bit words accessed atomically via the primitive\natomic functions (types [Int64] and [Uint64] are automatically aligned).\nThe first word in an allocated struct, array, or slice; in a global\nvariable; or in a local variable (because on 32-bit architectures, the\nsubject of 64-bit atomic operations will escape to the heap) can be\nrelied upon to be 64-bit aligned.\n\n"}, {"path": "stdlib/io-fs.md", "category": "stdlib", "name": "stdlib/io-fs", "content": "package fs // import \"io/fs\"\n\nPackage fs defines basic interfaces to a file system. A file system can be\nprovided by the host operating system but also by other packages.\n\nSee the testing/fstest package for support with testing implementations of file\nsystems.\n\nVARIABLES\n\nvar (\n\tErrInvalid    = errInvalid()    // \"invalid argument\"\n\tErrPermission = errPermission() // \"permission denied\"\n\tErrExist      = errExist()      // \"file already exists\"\n\tErrNotExist   = errNotExist()   // \"file does not exist\"\n\tErrClosed     = errClosed()     // \"file already closed\"\n)\n    Generic file system errors. Errors returned by file systems can be tested\n    against these errors using errors.Is.\n\nvar SkipAll = errors.New(\"skip everything and stop the walk\")\n    SkipAll is used as a return value from WalkDirFunc to indicate that all\n    remaining files and directories are to be skipped. It is not returned as an\n    error by any function.\n\nvar SkipDir = errors.New(\"skip this directory\")\n    SkipDir is used as a return value from WalkDirFunc to indicate that the\n    directory named in the call is to be skipped. It is not returned as an error\n    by any function.\n\n\nFUNCTIONS\n\nfunc FormatDirEntry(dir DirEntry) string\n    FormatDirEntry returns a formatted version of dir for human readability.\n    Implementations of DirEntry can call this from a String method. The outputs\n    for a directory named subdir and a file named hello.go are:\n\n        d subdir/\n        - hello.go\n\nfunc FormatFileInfo(info FileInfo) string\n    FormatFileInfo returns a formatted version of info for human readability.\n    Implementations of FileInfo can call this from a String method. The output\n    for a file named \"hello.go\", 100 bytes, mode 0o644, created January 1,\n    1970 at noon is\n\n        -rw-r--r-- 100 1970-01-01 12:00:00 hello.go\n\nfunc Glob(fsys FS, pattern string) (matches []string, err error)\n    Glob returns the names of all files matching pattern or nil if there is\n    no matching file. The syntax of patterns is the same as in path.Match.\n    The pattern may describe hierarchical names such as usr/*/bin/ed.\n\n    Glob ignores file system errors such as I/O errors reading directories.\n    The only possible returned error is path.ErrBadPattern, reporting that the\n    pattern is malformed.\n\n    If fs implements GlobFS, Glob calls fs.Glob. Otherwise, Glob uses ReadDir to\n    traverse the directory tree and look for matches for the pattern.\n\nfunc ReadFile(fsys FS, name string) ([]byte, error)\n    ReadFile reads the named file from the file system fs and returns its\n    contents. A successful call returns a nil error, not io.EOF. (Because\n    ReadFile reads the whole file, the expected EOF from the final Read is not\n    treated as an error to be reported.)\n\n    If fs implements ReadFileFS, ReadFile calls fs.ReadFile. Otherwise ReadFile\n    calls fs.Open and uses Read and Close on the returned File.\n\nfunc ReadLink(fsys FS, name string) (string, error)\n    ReadLink returns the destination of the named symbolic link.\n\n    If fsys does not implement ReadLinkFS, then ReadLink returns an error.\n\nfunc ValidPath(name string) bool\n    ValidPath reports whether the given path name is valid for use in a call to\n    Open.\n\n    Path names passed to open are UTF-8-encoded, unrooted, slash-separated\n    sequences of path elements, like \u201cx/y/z\u201d. Path names must not contain an\n    element that is \u201c.\u201d or \u201c..\u201d or the empty string, except for the special case\n    that the name \".\" may be used for the root directory. Paths must not start\n    or end with a slash: \u201c/x\u201d and \u201cx/\u201d are invalid.\n\n    Note that paths are slash-separated on all systems, even Windows.\n    Paths containing other characters such as backslash and colon are\n    accepted as valid, but those characters must never be interpreted by an FS\n    implementation as path element separators.\n\nfunc WalkDir(fsys FS, root string, fn WalkDirFunc) error\n    WalkDir walks the file tree rooted at root, calling fn for each file or\n    directory in the tree, including root.\n\n    All errors that arise visiting files and directories are filtered by fn:\n    see the fs.WalkDirFunc documentation for details.\n\n    The files are walked in lexical order, which makes the output deterministic\n    but requires WalkDir to read an entire directory into memory before\n    proceeding to walk that directory.\n\n    WalkDir does not follow symbolic links found in directories, but if root\n    itself is a symbolic link, its target will be walked.\n\n\nTYPES\n\ntype DirEntry interface {\n\t// Name returns the name of the file (or subdirectory) described by the entry.\n\t// This name is only the final element of the path (the base name), not the entire path.\n\t// For example, Name would return \"hello.go\" not \"home/gopher/hello.go\".\n\tName() string\n\n\t// IsDir reports whether the entry describes a directory.\n\tIsDir() bool\n\n\t// Type returns the type bits for the entry.\n\t// The type bits are a subset of the usual FileMode bits, those returned by the FileMode.Type method.\n\tType() FileMode\n\n\t// Info returns the FileInfo for the file or subdirectory described by the entry.\n\t// The returned FileInfo may be from the time of the original directory read\n\t// or from the time of the call to Info. If the file has been removed or renamed\n\t// since the directory read, Info may return an error satisfying errors.Is(err, ErrNotExist).\n\t// If the entry denotes a symbolic link, Info reports the information about the link itself,\n\t// not the link's target.\n\tInfo() (FileInfo, error)\n}\n    A DirEntry is an entry read from a directory (using the ReadDir function or\n    a ReadDirFile's ReadDir method).\n\nfunc FileInfoToDirEntry(info FileInfo) DirEntry\n    FileInfoToDirEntry returns a DirEntry that returns information from info.\n    If info is nil, FileInfoToDirEntry returns nil.\n\nfunc ReadDir(fsys FS, name string) ([]DirEntry, error)\n    ReadDir reads the named directory and returns a list of directory entries\n    sorted by filename.\n\n    If fs implements ReadDirFS, ReadDir calls fs.ReadDir. Otherwise ReadDir\n    calls fs.Open and uses ReadDir and Close on the returned file.\n\ntype FS interface {\n\t// Open opens the named file.\n\t// [File.Close] must be called to release any associated resources.\n\t//\n\t// When Open returns an error, it should be of type *PathError\n\t// with the Op field set to \"open\", the Path field set to name,\n\t// and the Err field describing the problem.\n\t//\n\t// Open should reject attempts to open names that do not satisfy\n\t// ValidPath(name), returning a *PathError with Err set to\n\t// ErrInvalid or ErrNotExist.\n\tOpen(name string) (File, error)\n}\n    An FS provides access to a hierarchical file system.\n\n    The FS interface is the minimum implementation required of the file system.\n    A file system may implement additional interfaces, such as ReadFileFS,\n    to provide additional or optimized functionality.\n\n    testing/fstest.TestFS may be used to test implementations of an FS for\n    correctness.\n\nfunc Sub(fsys FS, dir string) (FS, error)\n    Sub returns an FS corresponding to the subtree rooted at fsys's dir.\n\n    If dir is \".\", Sub returns fsys unchanged. Otherwise, if fs implements\n    SubFS, Sub returns fsys.Sub(dir). Otherwise, Sub returns a new FS\n    implementation sub that, in effect, implements sub.Open(name) as\n    fsys.Open(path.Join(dir, name)). The implementation also translates calls to\n    ReadDir, ReadFile, ReadLink, Lstat, and Glob appropriately.\n\n    Note that Sub(os.DirFS(\"/\"), \"prefix\") is equivalent to os.DirFS(\"/prefix\")\n    and that neither of them guarantees to avoid operating system accesses\n    outside \"/prefix\", because the implementation of os.DirFS does not check for\n    symbolic links inside \"/prefix\" that point to other directories. That is,\n    os.DirFS is not a general substitute for a chroot-style security mechanism,\n    and Sub does not change that fact.\n\ntype File interface {\n\tStat() (FileInfo, error)\n\tRead([]byte) (int, error)\n\tClose() error\n}\n    A File provides access to a single file. The File interface is the minimum\n    implementation required of the file. Directory files should also implement\n    ReadDirFile. A file may implement io.ReaderAt or io.Seeker as optimizations.\n\ntype FileInfo interface {\n\tName() string       // base name of the file\n\tSize() int64        // length in bytes for regular files; system-dependent for others\n\tMode() FileMode     // file mode bits\n\tModTime() time.Time // modification time\n\tIsDir() bool        // abbreviation for Mode().IsDir()\n\tSys() any           // underlying data source (can return nil)\n}\n    A FileInfo describes a file and is returned by Stat.\n\nfunc Lstat(fsys FS, name string) (FileInfo, error)\n    Lstat returns a FileInfo describing the named file. If the file is a\n    symbolic link, the returned FileInfo describes the symbolic link. Lstat\n    makes no attempt to follow the link.\n\n    If fsys does not implement ReadLinkFS, then Lstat is identical to Stat.\n\nfunc Stat(fsys FS, name string) (FileInfo, error)\n    Stat returns a FileInfo describing the named file from the file system.\n\n    If fs implements StatFS, Stat calls fs.Stat. Otherwise, Stat opens the File\n    to stat it.\n\ntype FileMode uint32\n    A FileMode represents a file's mode and permission bits. The bits have the\n    same definition on all systems, so that information about files can be moved\n    from one system to another portably. Not all bits apply to all systems.\n    The only required bit is ModeDir for directories.\n\nconst (\n\t// The single letters are the abbreviations\n\t// used by the String method's formatting.\n\tModeDir        FileMode = 1 << (32 - 1 - iota) // d: is a directory\n\tModeAppend                                     // a: append-only\n\tModeExclusive                                  // l: exclusive use\n\tModeTemporary                                  // T: temporary file; Plan 9 only\n\tModeSymlink                                    // L: symbolic link\n\tModeDevice                                     // D: device file\n\tModeNamedPipe                                  // p: named pipe (FIFO)\n\tModeSocket                                     // S: Unix domain socket\n\tModeSetuid                                     // u: setuid\n\tModeSetgid                                     // g: setgid\n\tModeCharDevice                                 // c: Unix character device, when ModeDevice is set\n\tModeSticky                                     // t: sticky\n\tModeIrregular                                  // ?: non-regular file; nothing else is known about this file\n\n\t// Mask for the type bits. For regular files, none will be set.\n\tModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice | ModeCharDevice | ModeIrregular\n\n\tModePerm FileMode = 0777 // Unix permission bits\n)\n    The defined file mode bits are the most significant bits of the FileMode.\n    The nine least-significant bits are the standard Unix rwxrwxrwx permissions.\n    The values of these bits should be considered part of the public API and may\n    be used in wire protocols or disk representations: they must not be changed,\n    although new bits might be added.\n\nfunc (m FileMode) IsDir() bool\n    IsDir reports whether m describes a directory. That is, it tests for the\n    ModeDir bit being set in m.\n\nfunc (m FileMode) IsRegular() bool\n    IsRegular reports whether m describes a regular file. That is, it tests that\n    no mode type bits are set.\n\nfunc (m FileMode) Perm() FileMode\n    Perm returns the Unix permission bits in m (m & ModePerm).\n\nfunc (m FileMode) String() string\n\nfunc (m FileMode) Type() FileMode\n    Type returns type bits in m (m & ModeType).\n\ntype GlobFS interface {\n\tFS\n\n\t// Glob returns the names of all files matching pattern,\n\t// providing an implementation of the top-level\n\t// Glob function.\n\tGlob(pattern string) ([]string, error)\n}\n    A GlobFS is a file system with a Glob method.\n\ntype PathError struct {\n\tOp   string\n\tPath string\n\tErr  error\n}\n    PathError records an error and the operation and file path that caused it.\n\nfunc (e *PathError) Error() string\n\nfunc (e *PathError) Timeout() bool\n    Timeout reports whether this error represents a timeout.\n\nfunc (e *PathError) Unwrap() error\n\ntype ReadDirFS interface {\n\tFS\n\n\t// ReadDir reads the named directory\n\t// and returns a list of directory entries sorted by filename.\n\tReadDir(name string) ([]DirEntry, error)\n}\n    ReadDirFS is the interface implemented by a file system that provides an\n    optimized implementation of ReadDir.\n\ntype ReadDirFile interface {\n\tFile\n\n\t// ReadDir reads the contents of the directory and returns\n\t// a slice of up to n DirEntry values in directory order.\n\t// Subsequent calls on the same file will yield further DirEntry values.\n\t//\n\t// If n > 0, ReadDir returns at most n DirEntry structures.\n\t// In this case, if ReadDir returns an empty slice, it will return\n\t// a non-nil error explaining why.\n\t// At the end of a directory, the error is io.EOF.\n\t// (ReadDir must return io.EOF itself, not an error wrapping io.EOF.)\n\t//\n\t// If n <= 0, ReadDir returns all remaining DirEntry values from the directory\n\t// in a single slice. In this case, if ReadDir succeeds (reads all the way\n\t// to the end of the directory), it returns the slice and a nil error.\n\t// If it encounters an error before the end of the directory,\n\t// ReadDir returns the DirEntry list read until that point and a non-nil error.\n\tReadDir(n int) ([]DirEntry, error)\n}\n    A ReadDirFile is a directory file whose entries can be read with the\n    ReadDir method. Every directory file should implement this interface. (It\n    is permissible for any file to implement this interface, but if so ReadDir\n    should return an error for non-directories.)\n\ntype ReadFileFS interface {\n\tFS\n\n\t// ReadFile reads the named file and returns its contents.\n\t// A successful call returns a nil error, not io.EOF.\n\t// (Because ReadFile reads the whole file, the expected EOF\n\t// from the final Read is not treated as an error to be reported.)\n\t//\n\t// The caller is permitted to modify the returned byte slice.\n\t// This method should return a copy of the underlying data.\n\tReadFile(name string) ([]byte, error)\n}\n    ReadFileFS is the interface implemented by a file system that provides an\n    optimized implementation of ReadFile.\n\ntype ReadLinkFS interface {\n\tFS\n\n\t// ReadLink returns the destination of the named symbolic link.\n\t// If there is an error, it should be of type [*PathError].\n\tReadLink(name string) (string, error)\n\n\t// Lstat returns a [FileInfo] describing the named file.\n\t// If the file is a symbolic link, the returned [FileInfo] describes the symbolic link.\n\t// Lstat makes no attempt to follow the link.\n\t// If there is an error, it should be of type [*PathError].\n\tLstat(name string) (FileInfo, error)\n}\n    ReadLinkFS is the interface implemented by a file system that supports\n    reading symbolic links.\n\ntype StatFS interface {\n\tFS\n\n\t// Stat returns a FileInfo describing the file.\n\t// If there is an error, it should be of type *PathError.\n\tStat(name string) (FileInfo, error)\n}\n    A StatFS is a file system with a Stat method.\n\ntype SubFS interface {\n\tFS\n\n\t// Sub returns an FS corresponding to the subtree rooted at dir.\n\tSub(dir string) (FS, error)\n}\n    A SubFS is a file system with a Sub method.\n\ntype WalkDirFunc func(path string, d DirEntry, err error) error\n    WalkDirFunc is the type of the function called by WalkDir to visit each file\n    or directory.\n\n    The path argument contains the argument to WalkDir as a prefix. That is,\n    if WalkDir is called with root argument \"dir\" and finds a file named \"a\" in\n    that directory, the walk function will be called with argument \"dir/a\".\n\n    The d argument is the DirEntry for the named path.\n\n    The error result returned by the function controls how WalkDir continues.\n    If the function returns the special value SkipDir, WalkDir skips the current\n    directory (path if d.IsDir() is true, otherwise path's parent directory). If\n    the function returns the special value SkipAll, WalkDir skips all remaining\n    files and directories. Otherwise, if the function returns a non-nil error,\n    WalkDir stops entirely and returns that error.\n\n    The err argument reports an error related to path, signaling that WalkDir\n    will not walk into that directory. The function can decide how to handle\n    that error; as described earlier, returning the error will cause WalkDir to\n    stop walking the entire tree.\n\n    WalkDir calls the function with a non-nil err argument in two cases.\n\n    First, if the initial Stat on the root directory fails, WalkDir calls the\n    function with path set to root, d set to nil, and err set to the error from\n    fs.Stat.\n\n    Second, if a directory's ReadDir method (see ReadDirFile) fails, WalkDir\n    calls the function with path set to the directory's path, d set to an\n    DirEntry describing the directory, and err set to the error from ReadDir.\n    In this second case, the function is called twice with the path of the\n    directory: the first call is before the directory read is attempted and has\n    err set to nil, giving the function a chance to return SkipDir or SkipAll\n    and avoid the ReadDir entirely. The second call is after a failed ReadDir\n    and reports the error from ReadDir. (If ReadDir succeeds, there is no second\n    call.)\n\n    The differences between WalkDirFunc compared to path/filepath.WalkFunc are:\n\n      - The second argument has type DirEntry instead of FileInfo.\n      - The function is called before reading a directory, to allow SkipDir\n        or SkipAll to bypass the directory read entirely or skip all remaining\n        files and directories respectively.\n      - If a directory read fails, the function is called a second time for that\n        directory to report the error.\n\n"}, {"path": "stdlib/go-build.md", "category": "stdlib", "name": "stdlib/go-build", "content": "package build // import \"go/build\"\n\nPackage build gathers information about Go packages.\n\n# Build Constraints\n\nA build constraint, also known as a build tag, is a condition under which a file\nshould be included in the package. Build constraints are given by a line comment\nthat begins\n\n    //go:build\n\nBuild constraints may also be part of a file's name (for example,\nsource_windows.go will only be included if the target operating system is\nwindows).\n\nSee 'go help buildconstraint' (https://pkg.go.dev/cmd/go#hdr-Build_constraints)\nfor details.\n\n# Go Path\n\nThe Go path is a list of directory trees containing Go source code. It is\nconsulted to resolve imports that cannot be found in the standard Go tree.\nThe default path is the value of the GOPATH environment variable, interpreted\nas a path list appropriate to the operating system (on Unix, the variable is a\ncolon-separated string; on Windows, a semicolon-separated string; on Plan 9,\na list).\n\nEach directory listed in the Go path must have a prescribed structure:\n\nThe src/ directory holds source code. The path below 'src' determines the import\npath or executable name.\n\nThe pkg/ directory holds installed package objects. As in the Go tree, each\ntarget operating system and architecture pair has its own subdirectory of pkg\n(pkg/GOOS_GOARCH).\n\nIf DIR is a directory listed in the Go path, a package with source\nin DIR/src/foo/bar can be imported as \"foo/bar\" and has its compiled\nform installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\" (or, for gccgo,\n\"DIR/pkg/gccgo/foo/libbar.a\").\n\nThe bin/ directory holds compiled commands. Each command is named for its source\ndirectory, but only using the final element, not the entire path. That is,\nthe command with source in DIR/src/foo/quux is installed into DIR/bin/quux,\nnot DIR/bin/foo/quux. The foo/ is stripped so that you can add DIR/bin to your\nPATH to get at the installed commands.\n\nHere's an example directory layout:\n\n    GOPATH=/home/user/gocode\n\n    /home/user/gocode/\n        src/\n            foo/\n                bar/               (go code in package bar)\n                    x.go\n                quux/              (go code in package main)\n                    y.go\n        bin/\n            quux                   (installed command)\n        pkg/\n            linux_amd64/\n                foo/\n                    bar.a          (installed package object)\n\n# Binary-Only Packages\n\nIn Go 1.12 and earlier, it was possible to distribute packages in binary\nform without including the source code used for compiling the package.\nThe package was distributed with a source file not excluded by build constraints\nand containing a \"//go:binary-only-package\" comment. Like a build constraint,\nthis comment appeared at the top of a file, preceded only by blank lines and\nother line comments and with a blank line following the comment, to separate it\nfrom the package documentation. Unlike build constraints, this comment is only\nrecognized in non-test Go source files.\n\nThe minimal source code for a binary-only package was therefore:\n\n    //go:binary-only-package\n\n    package mypkg\n\nThe source code could include additional Go code. That code was never compiled\nbut would be processed by tools like godoc and might be useful as end-user\ndocumentation.\n\n\"go build\" and other commands no longer support binary-only-packages. Import\nand ImportDir will still set the BinaryOnly flag in packages containing these\ncomments for use in tools and error messages.\n\nVARIABLES\n\nvar ToolDir = getToolDir()\n    ToolDir is the directory containing build tools.\n\n\nFUNCTIONS\n\nfunc ArchChar(goarch string) (string, error)\n    ArchChar returns \"?\" and an error. In earlier versions of Go, the returned\n    string was used to derive the compiler and linker tool names, the default\n    object file suffix, and the default linker output name. As of Go 1.5,\n    those strings no longer vary by architecture; they are compile, link, .o,\n    and a.out, respectively.\n\nfunc IsLocalImport(path string) bool\n    IsLocalImport reports whether the import path is a local import path,\n    like \".\", \"..\", \"./foo\", or \"../foo\".\n\n\nTYPES\n\ntype Context struct {\n\tGOARCH string // target architecture\n\tGOOS   string // target operating system\n\tGOROOT string // Go root\n\tGOPATH string // Go paths\n\n\t// Dir is the caller's working directory, or the empty string to use\n\t// the current directory of the running process. In module mode, this is used\n\t// to locate the main module.\n\t//\n\t// If Dir is non-empty, directories passed to Import and ImportDir must\n\t// be absolute.\n\tDir string\n\n\tCgoEnabled  bool   // whether cgo files are included\n\tUseAllFiles bool   // use files regardless of go:build lines, file names\n\tCompiler    string // compiler to assume when computing target paths\n\n\t// The build, tool, and release tags specify build constraints\n\t// that should be considered satisfied when processing go:build lines.\n\t// Clients creating a new context may customize BuildTags, which\n\t// defaults to empty, but it is usually an error to customize ToolTags or ReleaseTags.\n\t// ToolTags defaults to build tags appropriate to the current Go toolchain configuration.\n\t// ReleaseTags defaults to the list of Go releases the current release is compatible with.\n\t// BuildTags is not set for the Default build Context.\n\t// In addition to the BuildTags, ToolTags, and ReleaseTags, build constraints\n\t// consider the values of GOARCH and GOOS as satisfied tags.\n\t// The last element in ReleaseTags is assumed to be the current release.\n\tBuildTags   []string\n\tToolTags    []string\n\tReleaseTags []string\n\n\t// The install suffix specifies a suffix to use in the name of the installation\n\t// directory. By default it is empty, but custom builds that need to keep\n\t// their outputs separate can set InstallSuffix to do so. For example, when\n\t// using the race detector, the go command uses InstallSuffix = \"race\", so\n\t// that on a Linux/386 system, packages are written to a directory named\n\t// \"linux_386_race\" instead of the usual \"linux_386\".\n\tInstallSuffix string\n\n\t// JoinPath joins the sequence of path fragments into a single path.\n\t// If JoinPath is nil, Import uses filepath.Join.\n\tJoinPath func(elem ...string) string\n\n\t// SplitPathList splits the path list into a slice of individual paths.\n\t// If SplitPathList is nil, Import uses filepath.SplitList.\n\tSplitPathList func(list string) []string\n\n\t// IsAbsPath reports whether path is an absolute path.\n\t// If IsAbsPath is nil, Import uses filepath.IsAbs.\n\tIsAbsPath func(path string) bool\n\n\t// IsDir reports whether the path names a directory.\n\t// If IsDir is nil, Import calls os.Stat and uses the result's IsDir method.\n\tIsDir func(path string) bool\n\n\t// HasSubdir reports whether dir is lexically a subdirectory of\n\t// root, perhaps multiple levels below. It does not try to check\n\t// whether dir exists.\n\t// If so, HasSubdir sets rel to a slash-separated path that\n\t// can be joined to root to produce a path equivalent to dir.\n\t// If HasSubdir is nil, Import uses an implementation built on\n\t// filepath.EvalSymlinks.\n\tHasSubdir func(root, dir string) (rel string, ok bool)\n\n\t// ReadDir returns a slice of fs.FileInfo, sorted by Name,\n\t// describing the content of the named directory.\n\t// If ReadDir is nil, Import uses os.ReadDir.\n\tReadDir func(dir string) ([]fs.FileInfo, error)\n\n\t// OpenFile opens a file (not a directory) for reading.\n\t// If OpenFile is nil, Import uses os.Open.\n\tOpenFile func(path string) (io.ReadCloser, error)\n}\n    A Context specifies the supporting context for a build.\n\nvar Default Context = defaultContext()\n    Default is the default Context for builds. It uses the GOARCH, GOOS, GOROOT,\n    and GOPATH environment variables if set, or else the compiled code's GOARCH,\n    GOOS, and GOROOT.\n\nfunc (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Package, error)\n    Import returns details about the Go package named by the import path,\n    interpreting local import paths relative to the srcDir directory. If the\n    path is a local import path naming a package that can be imported using a\n    standard import path, the returned package will set p.ImportPath to that\n    path.\n\n    In the directory containing the package, .go, .c, .h, and .s files are\n    considered part of the package except for:\n\n      - .go files in package documentation\n      - files starting with _ or . (likely editor temporary files)\n      - files with build constraints not satisfied by the context\n\n    If an error occurs, Import returns a non-nil error and a non-nil *Package\n    containing partial information.\n\nfunc (ctxt *Context) ImportDir(dir string, mode ImportMode) (*Package, error)\n    ImportDir is like Import but processes the Go package found in the named\n    directory.\n\nfunc (ctxt *Context) MatchFile(dir, name string) (match bool, err error)\n    MatchFile reports whether the file with the given name in the given\n    directory matches the context and would be included in a Package created by\n    ImportDir of that directory.\n\n    MatchFile considers the name of the file and may use ctxt.OpenFile to read\n    some or all of the file's content.\n\nfunc (ctxt *Context) SrcDirs() []string\n    SrcDirs returns a list of package source root directories. It draws from the\n    current Go root and Go path but omits directories that do not exist.\n\ntype Directive struct {\n\tText string         // full line comment including leading slashes\n\tPos  token.Position // position of comment\n}\n    A Directive is a Go directive comment (//go:zzz...) found in a source file.\n\ntype ImportMode uint\n    An ImportMode controls the behavior of the Import method.\n\nconst (\n\t// If FindOnly is set, Import stops after locating the directory\n\t// that should contain the sources for a package. It does not\n\t// read any files in the directory.\n\tFindOnly ImportMode = 1 << iota\n\n\t// If AllowBinary is set, Import can be satisfied by a compiled\n\t// package object without corresponding sources.\n\t//\n\t// Deprecated:\n\t// The supported way to create a compiled-only package is to\n\t// write source code containing a //go:binary-only-package comment at\n\t// the top of the file. Such a package will be recognized\n\t// regardless of this flag setting (because it has source code)\n\t// and will have BinaryOnly set to true in the returned Package.\n\tAllowBinary\n\n\t// If ImportComment is set, parse import comments on package statements.\n\t// Import returns an error if it finds a comment it cannot understand\n\t// or finds conflicting comments in multiple source files.\n\t// See golang.org/s/go14customimport for more information.\n\tImportComment\n\n\t// By default, Import searches vendor directories\n\t// that apply in the given source directory before searching\n\t// the GOROOT and GOPATH roots.\n\t// If an Import finds and returns a package using a vendor\n\t// directory, the resulting ImportPath is the complete path\n\t// to the package, including the path elements leading up\n\t// to and including \"vendor\".\n\t// For example, if Import(\"y\", \"x/subdir\", 0) finds\n\t// \"x/vendor/y\", the returned package's ImportPath is \"x/vendor/y\",\n\t// not plain \"y\".\n\t// See golang.org/s/go15vendor for more information.\n\t//\n\t// Setting IgnoreVendor ignores vendor directories.\n\t//\n\t// In contrast to the package's ImportPath,\n\t// the returned package's Imports, TestImports, and XTestImports\n\t// are always the exact import paths from the source files:\n\t// Import makes no attempt to resolve or check those paths.\n\tIgnoreVendor\n)\ntype MultiplePackageError struct {\n\tDir      string   // directory containing files\n\tPackages []string // package names found\n\tFiles    []string // corresponding files: Files[i] declares package Packages[i]\n}\n    MultiplePackageError describes a directory containing multiple buildable Go\n    source files for multiple packages.\n\nfunc (e *MultiplePackageError) Error() string\n\ntype NoGoError struct {\n\tDir string\n}\n    NoGoError is the error used by Import to describe a directory containing no\n    buildable Go source files. (It may still contain test files, files hidden by\n    build tags, and so on.)\n\nfunc (e *NoGoError) Error() string\n\ntype Package struct {\n\tDir           string   // directory containing package sources\n\tName          string   // package name\n\tImportComment string   // path in import comment on package statement\n\tDoc           string   // documentation synopsis\n\tImportPath    string   // import path of package (\"\" if unknown)\n\tRoot          string   // root of Go tree where this package lives\n\tSrcRoot       string   // package source root directory (\"\" if unknown)\n\tPkgRoot       string   // package install root directory (\"\" if unknown)\n\tPkgTargetRoot string   // architecture dependent install root directory (\"\" if unknown)\n\tBinDir        string   // command install directory (\"\" if unknown)\n\tGoroot        bool     // package found in Go root\n\tPkgObj        string   // installed .a file\n\tAllTags       []string // tags that can influence file selection in this directory\n\tConflictDir   string   // this directory shadows Dir in $GOPATH\n\tBinaryOnly    bool     // cannot be rebuilt from source (has //go:binary-only-package comment)\n\n\t// Source files\n\tGoFiles           []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n\tCgoFiles          []string // .go source files that import \"C\"\n\tIgnoredGoFiles    []string // .go source files ignored for this build (including ignored _test.go files)\n\tInvalidGoFiles    []string // .go source files with detected problems (parse error, wrong package name, and so on)\n\tIgnoredOtherFiles []string // non-.go source files ignored for this build\n\tCFiles            []string // .c source files\n\tCXXFiles          []string // .cc, .cpp and .cxx source files\n\tMFiles            []string // .m (Objective-C) source files\n\tHFiles            []string // .h, .hh, .hpp and .hxx source files\n\tFFiles            []string // .f, .F, .for and .f90 Fortran source files\n\tSFiles            []string // .s source files\n\tSwigFiles         []string // .swig files\n\tSwigCXXFiles      []string // .swigcxx files\n\tSysoFiles         []string // .syso system object files to add to archive\n\n\t// Cgo directives\n\tCgoCFLAGS    []string // Cgo CFLAGS directives\n\tCgoCPPFLAGS  []string // Cgo CPPFLAGS directives\n\tCgoCXXFLAGS  []string // Cgo CXXFLAGS directives\n\tCgoFFLAGS    []string // Cgo FFLAGS directives\n\tCgoLDFLAGS   []string // Cgo LDFLAGS directives\n\tCgoPkgConfig []string // Cgo pkg-config directives\n\n\t// Test information\n\tTestGoFiles  []string // _test.go files in package\n\tXTestGoFiles []string // _test.go files outside package\n\n\t// Go directive comments (//go:zzz...) found in source files.\n\tDirectives      []Directive\n\tTestDirectives  []Directive\n\tXTestDirectives []Directive\n\n\t// Dependency information\n\tImports        []string                    // import paths from GoFiles, CgoFiles\n\tImportPos      map[string][]token.Position // line information for Imports\n\tTestImports    []string                    // import paths from TestGoFiles\n\tTestImportPos  map[string][]token.Position // line information for TestImports\n\tXTestImports   []string                    // import paths from XTestGoFiles\n\tXTestImportPos map[string][]token.Position // line information for XTestImports\n\n\t// //go:embed patterns found in Go source files\n\t// For example, if a source file says\n\t//\t//go:embed a* b.c\n\t// then the list will contain those two strings as separate entries.\n\t// (See package embed for more details about //go:embed.)\n\tEmbedPatterns        []string                    // patterns from GoFiles, CgoFiles\n\tEmbedPatternPos      map[string][]token.Position // line information for EmbedPatterns\n\tTestEmbedPatterns    []string                    // patterns from TestGoFiles\n\tTestEmbedPatternPos  map[string][]token.Position // line information for TestEmbedPatterns\n\tXTestEmbedPatterns   []string                    // patterns from XTestGoFiles\n\tXTestEmbedPatternPos map[string][]token.Position // line information for XTestEmbedPatternPos\n}\n    A Package describes the Go package found in a directory.\n\nfunc Import(path, srcDir string, mode ImportMode) (*Package, error)\n    Import is shorthand for Default.Import.\n\nfunc ImportDir(dir string, mode ImportMode) (*Package, error)\n    ImportDir is shorthand for Default.ImportDir.\n\nfunc (p *Package) IsCommand() bool\n    IsCommand reports whether the package is considered a command to be\n    installed (not just a library). Packages named \"main\" are treated as\n    commands.\n\n"}, {"path": "stdlib/internal-reflectlite.md", "category": "stdlib", "name": "stdlib/internal-reflectlite", "content": "package reflectlite // import \"internal/reflectlite\"\n\nPackage reflectlite implements lightweight version of reflect, not using any\npackage except for \"runtime\", \"unsafe\", and \"internal/abi\"\n\nCONSTANTS\n\nconst (\n\t// Import-and-export these constants as necessary\n\tInterface = abi.Interface\n\tSlice     = abi.Slice\n\tString    = abi.String\n\tStruct    = abi.Struct\n)\nconst Ptr = abi.Pointer\n\nFUNCTIONS\n\nfunc Swapper(slice any) func(i, j int)\n    Swapper returns a function that swaps the elements in the provided slice.\n\n    Swapper panics if the provided interface is not a slice.\n\n\nTYPES\n\ntype Kind = abi.Kind\n    A Kind represents the specific kind of type that a Type represents. The zero\n    Kind is not a valid kind.\n\ntype Type interface {\n\n\t// Name returns the type's name within its package for a defined type.\n\t// For other (non-defined) types it returns the empty string.\n\tName() string\n\n\t// PkgPath returns a defined type's package path, that is, the import path\n\t// that uniquely identifies the package, such as \"encoding/base64\".\n\t// If the type was predeclared (string, error) or not defined (*T, struct{},\n\t// []int, or A where A is an alias for a non-defined type), the package path\n\t// will be the empty string.\n\tPkgPath() string\n\n\t// Size returns the number of bytes needed to store\n\t// a value of the given type; it is analogous to unsafe.Sizeof.\n\tSize() uintptr\n\n\t// Kind returns the specific kind of this type.\n\tKind() Kind\n\n\t// Implements reports whether the type implements the interface type u.\n\tImplements(u Type) bool\n\n\t// AssignableTo reports whether a value of the type is assignable to type u.\n\tAssignableTo(u Type) bool\n\n\t// Comparable reports whether values of this type are comparable.\n\tComparable() bool\n\n\t// String returns a string representation of the type.\n\t// The string representation may use shortened package names\n\t// (e.g., base64 instead of \"encoding/base64\") and is not\n\t// guaranteed to be unique among types. To test for type identity,\n\t// compare the Types directly.\n\tString() string\n\n\t// Elem returns a type's element type.\n\t// It panics if the type's Kind is not Ptr.\n\tElem() Type\n\n\t// Has unexported methods.\n}\n    Type is the representation of a Go type.\n\n    Not all methods apply to all kinds of types. Restrictions, if any,\n    are noted in the documentation for each method. Use the Kind method to find\n    out the kind of type before calling kind-specific methods. Calling a method\n    inappropriate to the kind of type causes a run-time panic.\n\n    Type values are comparable, such as with the == operator, so they can be\n    used as map keys. Two Type values are equal if they represent identical\n    types.\n\nfunc TypeOf(i any) Type\n    TypeOf returns the reflection Type that represents the dynamic type of i.\n    If i is a nil interface value, TypeOf returns nil.\n\ntype Value struct {\n\t// Has unexported fields.\n}\n    Value is the reflection interface to a Go value.\n\n    Not all methods apply to all kinds of values. Restrictions, if any,\n    are noted in the documentation for each method. Use the Kind method to find\n    out the kind of value before calling kind-specific methods. Calling a method\n    inappropriate to the kind of type causes a run time panic.\n\n    The zero Value represents no value. Its IsValid method returns false, its\n    Kind method returns Invalid, its String method returns \"<invalid Value>\",\n    and all other methods panic. Most functions and methods never return\n    an invalid value. If one does, its documentation states the conditions\n    explicitly.\n\n    A Value can be used concurrently by multiple goroutines provided that the\n    underlying Go value can be used concurrently for the equivalent direct\n    operations.\n\n    To compare two Values, compare the results of the Interface method. Using ==\n    on two Values does not compare the underlying values they represent.\n\nfunc ValueOf(i any) Value\n    ValueOf returns a new Value initialized to the concrete value stored in the\n    interface i. ValueOf(nil) returns the zero Value.\n\nfunc (v Value) CanSet() bool\n    CanSet reports whether the value of v can be changed. A Value can be changed\n    only if it is addressable and was not obtained by the use of unexported\n    struct fields. If CanSet returns false, calling Set or any type-specific\n    setter (e.g., SetBool, SetInt) will panic.\n\nfunc (v Value) Elem() Value\n    Elem returns the value that the interface v contains or that the pointer v\n    points to. It panics if v's Kind is not Interface or Pointer. It returns the\n    zero Value if v is nil.\n\nfunc (v Value) IsNil() bool\n    IsNil reports whether its argument v is nil. The argument must be a chan,\n    func, interface, map, pointer, or slice value; if it is not, IsNil panics.\n    Note that IsNil is not always equivalent to a regular comparison with nil in\n    Go. For example, if v was created by calling ValueOf with an uninitialized\n    interface variable i, i==nil will be true but v.IsNil will panic as v will\n    be the zero Value.\n\nfunc (v Value) IsValid() bool\n    IsValid reports whether v represents a value. It returns false if v is the\n    zero Value. If IsValid returns false, all other methods except String panic.\n    Most functions and methods never return an invalid Value. If one does,\n    its documentation states the conditions explicitly.\n\nfunc (v Value) Kind() Kind\n    Kind returns v's Kind. If v is the zero Value (IsValid returns false),\n    Kind returns Invalid.\n\nfunc (v Value) Len() int\n    Len returns v's length. It panics if v's Kind is not Array, Chan, Map,\n    Slice, or String.\n\nfunc (v Value) Set(x Value)\n    Set assigns x to the value v. It panics if CanSet returns false. As in Go,\n    x's value must be assignable to v's type.\n\nfunc (v Value) Type() Type\n    Type returns v's type.\n\ntype ValueError struct {\n\tMethod string\n\tKind   Kind\n}\n    A ValueError occurs when a Value method is invoked on a Value that does not\n    support it. Such cases are documented in the description of each method.\n\nfunc (e *ValueError) Error() string\n\n"}, {"path": "stdlib/image-draw.md", "category": "stdlib", "name": "stdlib/image-draw", "content": "package draw // import \"image/draw\"\n\nPackage draw provides image composition functions.\n\nSee \"The Go image/draw package\" for an introduction to this package:\nhttps://golang.org/doc/articles/image_draw.html\n\nFUNCTIONS\n\nfunc Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)\n    Draw calls DrawMask with a nil mask.\n\nfunc DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op)\n    DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces\n    the rectangle r in dst with the result of a Porter-Duff composition.\n    A nil mask is treated as opaque.\n\n\nTYPES\n\ntype Drawer interface {\n\t// Draw aligns r.Min in dst with sp in src and then replaces the\n\t// rectangle r in dst with the result of drawing src on dst.\n\tDraw(dst Image, r image.Rectangle, src image.Image, sp image.Point)\n}\n    Drawer contains the Draw method.\n\nvar FloydSteinberg Drawer = floydSteinberg{}\n    FloydSteinberg is a Drawer that is the Src Op with Floyd-Steinberg error\n    diffusion.\n\ntype Image interface {\n\timage.Image\n\tSet(x, y int, c color.Color)\n}\n    Image is an image.Image with a Set method to change a single pixel.\n\ntype Op int\n    Op is a Porter-Duff compositing operator.\n\nconst (\n\t// Over specifies ``(src in mask) over dst''.\n\tOver Op = iota\n\t// Src specifies ``src in mask''.\n\tSrc\n)\nfunc (op Op) Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point)\n    Draw implements the Drawer interface by calling the Draw function with this\n    Op.\n\ntype Quantizer interface {\n\t// Quantize appends up to cap(p) - len(p) colors to p and returns the\n\t// updated palette suitable for converting m to a paletted image.\n\tQuantize(p color.Palette, m image.Image) color.Palette\n}\n    Quantizer produces a palette for an image.\n\ntype RGBA64Image interface {\n\timage.RGBA64Image\n\tSet(x, y int, c color.Color)\n\tSetRGBA64(x, y int, c color.RGBA64)\n}\n    RGBA64Image extends both the Image and image.RGBA64Image interfaces with\n    a SetRGBA64 method to change a single pixel. SetRGBA64 is equivalent to\n    calling Set, but it can avoid allocations from converting concrete color\n    types to the color.Color interface type.\n\n"}, {"path": "stdlib/crypto-internal-fips140-pbkdf2.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-pbkdf2", "content": "package pbkdf2 // import \"crypto/internal/fips140/pbkdf2\"\n\n\nFUNCTIONS\n\nfunc Key[Hash hash.Hash](h func() Hash, password string, salt []byte, iter, keyLength int) ([]byte, error)\n"}, {"path": "stdlib/testing-iotest.md", "category": "stdlib", "name": "stdlib/testing-iotest", "content": "package iotest // import \"testing/iotest\"\n\nPackage iotest implements Readers and Writers useful mainly for testing.\n\nVARIABLES\n\nvar ErrTimeout = errors.New(\"timeout\")\n    ErrTimeout is a fake timeout error.\n\n\nFUNCTIONS\n\nfunc DataErrReader(r io.Reader) io.Reader\n    DataErrReader changes the way errors are handled by a Reader. Normally,\n    a Reader returns an error (typically EOF) from the first Read call after\n    the last piece of data is read. DataErrReader wraps a Reader and changes\n    its behavior so the final error is returned along with the final data,\n    instead of in the first call after the final data.\n\nfunc ErrReader(err error) io.Reader\n    ErrReader returns an io.Reader that returns 0, err from all Read calls.\n\nfunc HalfReader(r io.Reader) io.Reader\n    HalfReader returns a Reader that implements Read by reading half as many\n    requested bytes from r.\n\nfunc NewReadLogger(prefix string, r io.Reader) io.Reader\n    NewReadLogger returns a reader that behaves like r except that it logs\n    (using log.Printf) each read to standard error, printing the prefix and the\n    hexadecimal data read.\n\nfunc NewWriteLogger(prefix string, w io.Writer) io.Writer\n    NewWriteLogger returns a writer that behaves like w except that it logs\n    (using log.Printf) each write to standard error, printing the prefix and the\n    hexadecimal data written.\n\nfunc OneByteReader(r io.Reader) io.Reader\n    OneByteReader returns a Reader that implements each non-empty Read by\n    reading one byte from r.\n\nfunc TestReader(r io.Reader, content []byte) error\n    TestReader tests that reading from r returns the expected file content.\n    It does reads of different sizes, until EOF. If r implements io.ReaderAt\n    or io.Seeker, TestReader also checks that those operations behave as they\n    should.\n\n    If TestReader finds any misbehaviors, it returns an error reporting them.\n    The error text may span multiple lines.\n\nfunc TimeoutReader(r io.Reader) io.Reader\n    TimeoutReader returns ErrTimeout on the second read with no data. Subsequent\n    calls to read succeed.\n\nfunc TruncateWriter(w io.Writer, n int64) io.Writer\n    TruncateWriter returns a Writer that writes to w but stops silently after n\n    bytes.\n\n"}, {"path": "stdlib/log-slog.md", "category": "stdlib", "name": "stdlib/log-slog", "content": "package slog // import \"log/slog\"\n\nPackage slog provides structured logging, in which log records include a\nmessage, a severity level, and various other attributes expressed as key-value\npairs.\n\nIt defines a type, Logger, which provides several methods (such as Logger.Info\nand Logger.Error) for reporting events of interest.\n\nEach Logger is associated with a Handler. A Logger output method creates a\nRecord from the method arguments and passes it to the Handler, which decides how\nto handle it. There is a default Logger accessible through top-level functions\n(such as Info and Error) that call the corresponding Logger methods.\n\nA log record consists of a time, a level, a message, and a set of key-value\npairs, where the keys are strings and the values may be of any type. As an\nexample,\n\n    slog.Info(\"hello\", \"count\", 3)\n\ncreates a record containing the time of the call, a level of Info, the message\n\"hello\", and a single pair with key \"count\" and value 3.\n\nThe Info top-level function calls the Logger.Info method on the default Logger.\nIn addition to Logger.Info, there are methods for Debug, Warn and Error levels.\nBesides these convenience methods for common levels, there is also a Logger.Log\nmethod which takes the level as an argument. Each of these methods has a\ncorresponding top-level function that uses the default logger.\n\nThe default handler formats the log record's message, time, level, and\nattributes as a string and passes it to the log package.\n\n    2022/11/08 15:28:26 INFO hello count=3\n\nFor more control over the output format, create a logger with a different\nhandler. This statement uses New to create a new logger with a TextHandler that\nwrites structured records in text form to standard error:\n\n    logger := slog.New(slog.NewTextHandler(os.Stderr, nil))\n\nTextHandler output is a sequence of key=value pairs, easily and unambiguously\nparsed by machine. This statement:\n\n    logger.Info(\"hello\", \"count\", 3)\n\nproduces this output:\n\n    time=2022-11-08T15:28:26.000-05:00 level=INFO msg=hello count=3\n\nThe package also provides JSONHandler, whose output is line-delimited JSON:\n\n    logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\n    logger.Info(\"hello\", \"count\", 3)\n\nproduces this output:\n\n    {\"time\":\"2022-11-08T15:28:26.000000000-05:00\",\"level\":\"INFO\",\"msg\":\"hello\",\"count\":3}\n\nBoth TextHandler and JSONHandler can be configured with HandlerOptions.\nThere are options for setting the minimum level (see Levels, below), displaying\nthe source file and line of the log call, and modifying attributes before they\nare logged.\n\nSetting a logger as the default with\n\n    slog.SetDefault(logger)\n\nwill cause the top-level functions like Info to use it. SetDefault also updates\nthe default logger used by the log package, so that existing applications that\nuse log.Printf and related functions will send log records to the logger's\nhandler without needing to be rewritten.\n\nSome attributes are common to many log calls. For example, you may wish to\ninclude the URL or trace identifier of a server request with all log events\narising from the request. Rather than repeat the attribute with every log call,\nyou can use Logger.With to construct a new Logger containing the attributes:\n\n    logger2 := logger.With(\"url\", r.URL)\n\nThe arguments to With are the same key-value pairs used in Logger.Info.\nThe result is a new Logger with the same handler as the original, but additional\nattributes that will appear in the output of every call.\n\n# Levels\n\nA Level is an integer representing the importance or severity of a log event.\nThe higher the level, the more severe the event. This package defines constants\nfor the most common levels, but any int can be used as a level.\n\nIn an application, you may wish to log messages only at a certain level or\ngreater. One common configuration is to log messages at Info or higher levels,\nsuppressing debug logging until it is needed. The built-in handlers can be\nconfigured with the minimum level to output by setting [HandlerOptions.Level].\nThe program's `main` function typically does this. The default value is\nLevelInfo.\n\nSetting the [HandlerOptions.Level] field to a Level value fixes the handler's\nminimum level throughout its lifetime. Setting it to a LevelVar allows the level\nto be varied dynamically. A LevelVar holds a Level and is safe to read or write\nfrom multiple goroutines. To vary the level dynamically for an entire program,\nfirst initialize a global LevelVar:\n\n    var programLevel = new(slog.LevelVar) // Info by default\n\nThen use the LevelVar to construct a handler, and make it the default:\n\n    h := slog.NewJSONHandler(os.Stderr, &slog.HandlerOptions{Level: programLevel})\n    slog.SetDefault(slog.New(h))\n\nNow the program can change its logging level with a single statement:\n\n    programLevel.Set(slog.LevelDebug)\n\n# Groups\n\nAttributes can be collected into groups. A group has a name that is used to\nqualify the names of its attributes. How this qualification is displayed depends\non the handler. TextHandler separates the group and attribute names with a dot.\nJSONHandler treats each group as a separate JSON object, with the group name as\nthe key.\n\nUse Group to create a Group attribute from a name and a list of key-value pairs:\n\n    slog.Group(\"request\",\n        \"method\", r.Method,\n        \"url\", r.URL)\n\nTextHandler would display this group as\n\n    request.method=GET request.url=http://example.com\n\nJSONHandler would display it as\n\n    \"request\":{\"method\":\"GET\",\"url\":\"http://example.com\"}\n\nUse Logger.WithGroup to qualify all of a Logger's output with a group name.\nCalling WithGroup on a Logger results in a new Logger with the same Handler as\nthe original, but with all its attributes qualified by the group name.\n\nThis can help prevent duplicate attribute keys in large systems, where\nsubsystems might use the same keys. Pass each subsystem a different Logger with\nits own group name so that potential duplicates are qualified:\n\n    logger := slog.Default().With(\"id\", systemID)\n    parserLogger := logger.WithGroup(\"parser\")\n    parseInput(input, parserLogger)\n\nWhen parseInput logs with parserLogger, its keys will be qualified with\n\"parser\", so even if it uses the common key \"id\", the log line will have\ndistinct keys.\n\n# Contexts\n\nSome handlers may wish to include information from the context.Context that is\navailable at the call site. One example of such information is the identifier\nfor the current span when tracing is enabled.\n\nThe Logger.Log and Logger.LogAttrs methods take a context as a first argument,\nas do their corresponding top-level functions.\n\nAlthough the convenience methods on Logger (Info and so on) and the\ncorresponding top-level functions do not take a context, the alternatives ending\nin \"Context\" do. For example,\n\n    slog.InfoContext(ctx, \"message\")\n\nIt is recommended to pass a context to an output method if one is available.\n\n# Attrs and Values\n\nAn Attr is a key-value pair. The Logger output methods accept Attrs as well as\nalternating keys and values. The statement\n\n    slog.Info(\"hello\", slog.Int(\"count\", 3))\n\nbehaves the same as\n\n    slog.Info(\"hello\", \"count\", 3)\n\nThere are convenience constructors for Attr such as Int, String, and Bool for\ncommon types, as well as the function Any for constructing Attrs of any type.\n\nThe value part of an Attr is a type called Value. Like an [any], a Value can\nhold any Go value, but it can represent typical values, including all numbers\nand strings, without an allocation.\n\nFor the most efficient log output, use Logger.LogAttrs. It is similar to\nLogger.Log but accepts only Attrs, not alternating keys and values; this allows\nit, too, to avoid allocation.\n\nThe call\n\n    logger.LogAttrs(ctx, slog.LevelInfo, \"hello\", slog.Int(\"count\", 3))\n\nis the most efficient way to achieve the same output as\n\n    slog.InfoContext(ctx, \"hello\", \"count\", 3)\n\n# Customizing a type's logging behavior\n\nIf a type implements the LogValuer interface, the Value returned from its\nLogValue method is used for logging. You can use this to control how values\nof the type appear in logs. For example, you can redact secret information\nlike passwords, or gather a struct's fields in a Group. See the examples under\nLogValuer for details.\n\nA LogValue method may return a Value that itself implements LogValuer. The\nValue.Resolve method handles these cases carefully, avoiding infinite loops and\nunbounded recursion. Handler authors and others may wish to use Value.Resolve\ninstead of calling LogValue directly.\n\n# Wrapping output methods\n\nThe logger functions use reflection over the call stack to find the file name\nand line number of the logging call within the application. This can produce\nincorrect source information for functions that wrap slog. For instance,\nif you define this function in file mylog.go:\n\n    func Infof(logger *slog.Logger, format string, args ...any) {\n        logger.Info(fmt.Sprintf(format, args...))\n    }\n\nand you call it like this in main.go:\n\n    Infof(slog.Default(), \"hello, %s\", \"world\")\n\nthen slog will report the source file as mylog.go, not main.go.\n\nA correct implementation of Infof will obtain the source location (pc) and\npass it to NewRecord. The Infof function in the package-level example called\n\"wrapping\" demonstrates how to do this.\n\n# Working with Records\n\nSometimes a Handler will need to modify a Record before passing it on to another\nHandler or backend. A Record contains a mixture of simple public fields (e.g.\nTime, Level, Message) and hidden fields that refer to state (such as attributes)\nindirectly. This means that modifying a simple copy of a Record (e.g. by calling\nRecord.Add or Record.AddAttrs to add attributes) may have unexpected effects on\nthe original. Before modifying a Record, use Record.Clone to create a copy that\nshares no state with the original, or create a new Record with NewRecord and\nbuild up its Attrs by traversing the old ones with Record.Attrs.\n\n# Performance considerations\n\nIf profiling your application demonstrates that logging is taking significant\ntime, the following suggestions may help.\n\nIf many log lines have a common attribute, use Logger.With to create a Logger\nwith that attribute. The built-in handlers will format that attribute only once,\nat the call to Logger.With. The Handler interface is designed to allow that\noptimization, and a well-written Handler should take advantage of it.\n\nThe arguments to a log call are always evaluated, even if the log event is\ndiscarded. If possible, defer computation so that it happens only if the value\nis actually logged. For example, consider the call\n\n    slog.Info(\"starting request\", \"url\", r.URL.String())  // may compute String unnecessarily\n\nThe URL.String method will be called even if the logger discards Info-level\nevents. Instead, pass the URL directly:\n\n    slog.Info(\"starting request\", \"url\", &r.URL) // calls URL.String only if needed\n\nThe built-in TextHandler will call its String method, but only if the log event\nis enabled. Avoiding the call to String also preserves the structure of the\nunderlying value. For example JSONHandler emits the components of the parsed\nURL as a JSON object. If you want to avoid eagerly paying the cost of the String\ncall without causing the handler to potentially inspect the structure of the\nvalue, wrap the value in a fmt.Stringer implementation that hides its Marshal\nmethods.\n\nYou can also use the LogValuer interface to avoid unnecessary work in disabled\nlog calls. Say you need to log some expensive value:\n\n    slog.Debug(\"frobbing\", \"value\", computeExpensiveValue(arg))\n\nEven if this line is disabled, computeExpensiveValue will be called. To avoid\nthat, define a type implementing LogValuer:\n\n    type expensive struct { arg int }\n\n    func (e expensive) LogValue() slog.Value {\n        return slog.AnyValue(computeExpensiveValue(e.arg))\n    }\n\nThen use a value of that type in log calls:\n\n    slog.Debug(\"frobbing\", \"value\", expensive{arg})\n\nNow computeExpensiveValue will only be called when the line is enabled.\n\nThe built-in handlers acquire a lock before calling io.Writer.Write to ensure\nthat exactly one Record is written at a time in its entirety. Although each log\nrecord has a timestamp, the built-in handlers do not use that time to sort the\nwritten records. User-defined handlers are responsible for their own locking and\nsorting.\n\n# Writing a handler\n\nFor a guide to writing a custom handler, see\nhttps://golang.org/s/slog-handler-guide.\n\nCONSTANTS\n\nconst (\n\t// TimeKey is the key used by the built-in handlers for the time\n\t// when the log method is called. The associated Value is a [time.Time].\n\tTimeKey = \"time\"\n\t// LevelKey is the key used by the built-in handlers for the level\n\t// of the log call. The associated value is a [Level].\n\tLevelKey = \"level\"\n\t// MessageKey is the key used by the built-in handlers for the\n\t// message of the log call. The associated value is a string.\n\tMessageKey = \"msg\"\n\t// SourceKey is the key used by the built-in handlers for the source file\n\t// and line of the log call. The associated value is a *[Source].\n\tSourceKey = \"source\"\n)\n    Keys for \"built-in\" attributes.\n\n\nFUNCTIONS\n\nfunc Debug(msg string, args ...any)\n    Debug calls Logger.Debug on the default logger.\n\nfunc DebugContext(ctx context.Context, msg string, args ...any)\n    DebugContext calls Logger.DebugContext on the default logger.\n\nfunc Error(msg string, args ...any)\n    Error calls Logger.Error on the default logger.\n\nfunc ErrorContext(ctx context.Context, msg string, args ...any)\n    ErrorContext calls Logger.ErrorContext on the default logger.\n\nfunc Info(msg string, args ...any)\n    Info calls Logger.Info on the default logger.\n\nfunc InfoContext(ctx context.Context, msg string, args ...any)\n    InfoContext calls Logger.InfoContext on the default logger.\n\nfunc Log(ctx context.Context, level Level, msg string, args ...any)\n    Log calls Logger.Log on the default logger.\n\nfunc LogAttrs(ctx context.Context, level Level, msg string, attrs ...Attr)\n    LogAttrs calls Logger.LogAttrs on the default logger.\n\nfunc NewLogLogger(h Handler, level Level) *log.Logger\n    NewLogLogger returns a new log.Logger such that each call to its Output\n    method dispatches a Record to the specified handler. The logger acts as a\n    bridge from the older log API to newer structured logging handlers.\n\nfunc SetDefault(l *Logger)\n    SetDefault makes l the default Logger, which is used by the top-level\n    functions Info, Debug and so on. After this call, output from the log\n    package's default Logger (as with log.Print, etc.) will be logged using l's\n    Handler, at a level controlled by SetLogLoggerLevel.\n\nfunc Warn(msg string, args ...any)\n    Warn calls Logger.Warn on the default logger.\n\nfunc WarnContext(ctx context.Context, msg string, args ...any)\n    WarnContext calls Logger.WarnContext on the default logger.\n\n\nTYPES\n\ntype Attr struct {\n\tKey   string\n\tValue Value\n}\n    An Attr is a key-value pair.\n\nfunc Any(key string, value any) Attr\n    Any returns an Attr for the supplied value. See AnyValue for how values are\n    treated.\n\nfunc Bool(key string, v bool) Attr\n    Bool returns an Attr for a bool.\n\nfunc Duration(key string, v time.Duration) Attr\n    Duration returns an Attr for a time.Duration.\n\nfunc Float64(key string, v float64) Attr\n    Float64 returns an Attr for a floating-point number.\n\nfunc Group(key string, args ...any) Attr\n    Group returns an Attr for a Group Value. The first argument is the key;\n    the remaining arguments are converted to Attrs as in Logger.Log.\n\n    Use Group to collect several key-value pairs under a single key on a\n    log line, or as the result of LogValue in order to log a single value as\n    multiple Attrs.\n\nfunc GroupAttrs(key string, attrs ...Attr) Attr\n    GroupAttrs returns an Attr for a Group Value consisting of the given Attrs.\n\n    GroupAttrs is a more efficient version of Group that accepts only Attr\n    values.\n\nfunc Int(key string, value int) Attr\n    Int converts an int to an int64 and returns an Attr with that value.\n\nfunc Int64(key string, value int64) Attr\n    Int64 returns an Attr for an int64.\n\nfunc String(key, value string) Attr\n    String returns an Attr for a string value.\n\nfunc Time(key string, v time.Time) Attr\n    Time returns an Attr for a time.Time. It discards the monotonic portion.\n\nfunc Uint64(key string, v uint64) Attr\n    Uint64 returns an Attr for a uint64.\n\nfunc (a Attr) Equal(b Attr) bool\n    Equal reports whether a and b have equal keys and values.\n\nfunc (a Attr) String() string\n\ntype Handler interface {\n\t// Enabled reports whether the handler handles records at the given level.\n\t// The handler ignores records whose level is lower.\n\t// It is called early, before any arguments are processed,\n\t// to save effort if the log event should be discarded.\n\t// If called from a Logger method, the first argument is the context\n\t// passed to that method, or context.Background() if nil was passed\n\t// or the method does not take a context.\n\t// The context is passed so Enabled can use its values\n\t// to make a decision.\n\tEnabled(context.Context, Level) bool\n\n\t// Handle handles the Record.\n\t// It will only be called when Enabled returns true.\n\t// The Context argument is as for Enabled.\n\t// It is present solely to provide Handlers access to the context's values.\n\t// Canceling the context should not affect record processing.\n\t// (Among other things, log messages may be necessary to debug a\n\t// cancellation-related problem.)\n\t//\n\t// Handle methods that produce output should observe the following rules:\n\t//   - If r.Time is the zero time, ignore the time.\n\t//   - If r.PC is zero, ignore it.\n\t//   - Attr's values should be resolved.\n\t//   - If an Attr's key and value are both the zero value, ignore the Attr.\n\t//     This can be tested with attr.Equal(Attr{}).\n\t//   - If a group's key is empty, inline the group's Attrs.\n\t//   - If a group has no Attrs (even if it has a non-empty key),\n\t//     ignore it.\n\t//\n\t// [Logger] discards any errors from Handle. Wrap the Handle method to\n\t// process any errors from Handlers.\n\tHandle(context.Context, Record) error\n\n\t// WithAttrs returns a new Handler whose attributes consist of\n\t// both the receiver's attributes and the arguments.\n\t// The Handler owns the slice: it may retain, modify or discard it.\n\tWithAttrs(attrs []Attr) Handler\n\n\t// WithGroup returns a new Handler with the given group appended to\n\t// the receiver's existing groups.\n\t// The keys of all subsequent attributes, whether added by With or in a\n\t// Record, should be qualified by the sequence of group names.\n\t//\n\t// How this qualification happens is up to the Handler, so long as\n\t// this Handler's attribute keys differ from those of another Handler\n\t// with a different sequence of group names.\n\t//\n\t// A Handler should treat WithGroup as starting a Group of Attrs that ends\n\t// at the end of the log event. That is,\n\t//\n\t//     logger.WithGroup(\"s\").LogAttrs(ctx, level, msg, slog.Int(\"a\", 1), slog.Int(\"b\", 2))\n\t//\n\t// should behave like\n\t//\n\t//     logger.LogAttrs(ctx, level, msg, slog.Group(\"s\", slog.Int(\"a\", 1), slog.Int(\"b\", 2)))\n\t//\n\t// If the name is empty, WithGroup returns the receiver.\n\tWithGroup(name string) Handler\n}\n    A Handler handles log records produced by a Logger.\n\n    A typical handler may print log records to standard error, or write them to\n    a file or database, or perhaps augment them with additional attributes and\n    pass them on to another handler.\n\n    Any of the Handler's methods may be called concurrently with itself or\n    with other methods. It is the responsibility of the Handler to manage this\n    concurrency.\n\n    Users of the slog package should not invoke Handler methods directly.\n    They should use the methods of Logger instead.\n\n    Before implementing your own handler, consult\n    https://go.dev/s/slog-handler-guide.\n\nvar DiscardHandler Handler = discardHandler{}\n    DiscardHandler discards all log output. DiscardHandler.Enabled returns false\n    for all Levels.\n\ntype HandlerOptions struct {\n\t// AddSource causes the handler to compute the source code position\n\t// of the log statement and add a SourceKey attribute to the output.\n\tAddSource bool\n\n\t// Level reports the minimum record level that will be logged.\n\t// The handler discards records with lower levels.\n\t// If Level is nil, the handler assumes LevelInfo.\n\t// The handler calls Level.Level for each record processed;\n\t// to adjust the minimum level dynamically, use a LevelVar.\n\tLevel Leveler\n\n\t// ReplaceAttr is called to rewrite each non-group attribute before it is logged.\n\t// The attribute's value has been resolved (see [Value.Resolve]).\n\t// If ReplaceAttr returns a zero Attr, the attribute is discarded.\n\t//\n\t// The built-in attributes with keys \"time\", \"level\", \"source\", and \"msg\"\n\t// are passed to this function, except that time is omitted\n\t// if zero, and source is omitted if AddSource is false.\n\t//\n\t// The first argument is a list of currently open groups that contain the\n\t// Attr. It must not be retained or modified. ReplaceAttr is never called\n\t// for Group attributes, only their contents. For example, the attribute\n\t// list\n\t//\n\t//     Int(\"a\", 1), Group(\"g\", Int(\"b\", 2)), Int(\"c\", 3)\n\t//\n\t// results in consecutive calls to ReplaceAttr with the following arguments:\n\t//\n\t//     nil, Int(\"a\", 1)\n\t//     []string{\"g\"}, Int(\"b\", 2)\n\t//     nil, Int(\"c\", 3)\n\t//\n\t// ReplaceAttr can be used to change the default keys of the built-in\n\t// attributes, convert types (for example, to replace a `time.Time` with the\n\t// integer seconds since the Unix epoch), sanitize personal information, or\n\t// remove attributes from the output.\n\tReplaceAttr func(groups []string, a Attr) Attr\n}\n    HandlerOptions are options for a TextHandler or JSONHandler. A zero\n    HandlerOptions consists entirely of default values.\n\ntype JSONHandler struct {\n\t// Has unexported fields.\n}\n    JSONHandler is a Handler that writes Records to an io.Writer as\n    line-delimited JSON objects.\n\nfunc NewJSONHandler(w io.Writer, opts *HandlerOptions) *JSONHandler\n    NewJSONHandler creates a JSONHandler that writes to w, using the given\n    options. If opts is nil, the default options are used.\n\nfunc (h *JSONHandler) Enabled(_ context.Context, level Level) bool\n    Enabled reports whether the handler handles records at the given level.\n    The handler ignores records whose level is lower.\n\nfunc (h *JSONHandler) Handle(_ context.Context, r Record) error\n    Handle formats its argument Record as a JSON object on a single line.\n\n    If the Record's time is zero, the time is omitted. Otherwise, the key is\n    \"time\" and the value is output as with json.Marshal.\n\n    The level's key is \"level\" and its value is the result of calling\n    Level.String.\n\n    If the AddSource option is set and source information is available, the key\n    is \"source\", and the value is a record of type Source.\n\n    The message's key is \"msg\".\n\n    To modify these or other attributes, or remove them from the output,\n    use [HandlerOptions.ReplaceAttr].\n\n    Values are formatted as with an encoding/json.Encoder with\n    SetEscapeHTML(false), with two exceptions.\n\n    First, an Attr whose Value is of type error is formatted as a string,\n    by calling its Error method. Only errors in Attrs receive this special\n    treatment, not errors embedded in structs, slices, maps or other data\n    structures that are processed by the encoding/json package.\n\n    Second, an encoding failure does not cause Handle to return an error.\n    Instead, the error message is formatted as a string.\n\n    Each call to Handle results in a single serialized call to io.Writer.Write.\n\nfunc (h *JSONHandler) WithAttrs(attrs []Attr) Handler\n    WithAttrs returns a new JSONHandler whose attributes consists of h's\n    attributes followed by attrs.\n\nfunc (h *JSONHandler) WithGroup(name string) Handler\n\ntype Kind int\n    Kind is the kind of a Value.\n\nconst (\n\tKindAny Kind = iota\n\tKindBool\n\tKindDuration\n\tKindFloat64\n\tKindInt64\n\tKindString\n\tKindTime\n\tKindUint64\n\tKindGroup\n\tKindLogValuer\n)\nfunc (k Kind) String() string\n\ntype Level int\n    A Level is the importance or severity of a log event. The higher the level,\n    the more important or severe the event.\n\nconst (\n\tLevelDebug Level = -4\n\tLevelInfo  Level = 0\n\tLevelWarn  Level = 4\n\tLevelError Level = 8\n)\n    Names for common levels.\n\n    Level numbers are inherently arbitrary, but we picked them to satisfy three\n    constraints. Any system can map them to another numbering scheme if it\n    wishes.\n\n    First, we wanted the default level to be Info, Since Levels are ints,\n    Info is the default value for int, zero.\n\n    Second, we wanted to make it easy to use levels to specify logger verbosity.\n    Since a larger level means a more severe event, a logger that accepts events\n    with smaller (or more negative) level means a more verbose logger. Logger\n    verbosity is thus the negation of event severity, and the default verbosity\n    of 0 accepts all events at least as severe as INFO.\n\n    Third, we wanted some room between levels to accommodate schemes with\n    named levels between ours. For example, Google Cloud Logging defines a\n    Notice level between Info and Warn. Since there are only a few of these\n    intermediate levels, the gap between the numbers need not be large.\n    Our gap of 4 matches OpenTelemetry's mapping. Subtracting 9 from an\n    OpenTelemetry level in the DEBUG, INFO, WARN and ERROR ranges converts it to\n    the corresponding slog Level range. OpenTelemetry also has the names TRACE\n    and FATAL, which slog does not. But those OpenTelemetry levels can still be\n    represented as slog Levels by using the appropriate integers.\n\nfunc SetLogLoggerLevel(level Level) (oldLevel Level)\n    SetLogLoggerLevel controls the level for the bridge to the log package.\n\n    Before SetDefault is called, slog top-level logging functions call the\n    default log.Logger. In that mode, SetLogLoggerLevel sets the minimum level\n    for those calls. By default, the minimum level is Info, so calls to Debug\n    (as well as top-level logging calls at lower levels) will not be passed to\n    the log.Logger. After calling\n\n        slog.SetLogLoggerLevel(slog.LevelDebug)\n\n    calls to Debug will be passed to the log.Logger.\n\n    After SetDefault is called, calls to the default log.Logger are passed to\n    the slog default handler. In that mode, SetLogLoggerLevel sets the level at\n    which those calls are logged. That is, after calling\n\n        slog.SetLogLoggerLevel(slog.LevelDebug)\n\n    A call to log.Printf will result in output at level LevelDebug.\n\n    SetLogLoggerLevel returns the previous value.\n\nfunc (l Level) AppendText(b []byte) ([]byte, error)\n    AppendText implements encoding.TextAppender by calling Level.String.\n\nfunc (l Level) Level() Level\n    Level returns the receiver. It implements Leveler.\n\nfunc (l Level) MarshalJSON() ([]byte, error)\n    MarshalJSON implements encoding/json.Marshaler by quoting the output of\n    Level.String.\n\nfunc (l Level) MarshalText() ([]byte, error)\n    MarshalText implements encoding.TextMarshaler by calling Level.AppendText.\n\nfunc (l Level) String() string\n    String returns a name for the level. If the level has a name, then that\n    name in uppercase is returned. If the level is between named values, then an\n    integer is appended to the uppercased name. Examples:\n\n        LevelWarn.String() => \"WARN\"\n        (LevelInfo+2).String() => \"INFO+2\"\n\nfunc (l *Level) UnmarshalJSON(data []byte) error\n    UnmarshalJSON implements encoding/json.Unmarshaler It accepts any string\n    produced by Level.MarshalJSON, ignoring case. It also accepts numeric\n    offsets that would result in a different string on output. For example,\n    \"Error-8\" would marshal as \"INFO\".\n\nfunc (l *Level) UnmarshalText(data []byte) error\n    UnmarshalText implements encoding.TextUnmarshaler. It accepts any string\n    produced by Level.MarshalText, ignoring case. It also accepts numeric\n    offsets that would result in a different string on output. For example,\n    \"Error-8\" would marshal as \"INFO\".\n\ntype LevelVar struct {\n\t// Has unexported fields.\n}\n    A LevelVar is a Level variable, to allow a Handler level to change\n    dynamically. It implements Leveler as well as a Set method, and it is safe\n    for use by multiple goroutines. The zero LevelVar corresponds to LevelInfo.\n\nfunc (v *LevelVar) AppendText(b []byte) ([]byte, error)\n    AppendText implements encoding.TextAppender by calling Level.AppendText.\n\nfunc (v *LevelVar) Level() Level\n    Level returns v's level.\n\nfunc (v *LevelVar) MarshalText() ([]byte, error)\n    MarshalText implements encoding.TextMarshaler by calling\n    LevelVar.AppendText.\n\nfunc (v *LevelVar) Set(l Level)\n    Set sets v's level to l.\n\nfunc (v *LevelVar) String() string\n\nfunc (v *LevelVar) UnmarshalText(data []byte) error\n    UnmarshalText implements encoding.TextUnmarshaler by calling\n    Level.UnmarshalText.\n\ntype Leveler interface {\n\tLevel() Level\n}\n    A Leveler provides a Level value.\n\n    As Level itself implements Leveler, clients typically supply a Level value\n    wherever a Leveler is needed, such as in HandlerOptions. Clients who need to\n    vary the level dynamically can provide a more complex Leveler implementation\n    such as *LevelVar.\n\ntype LogValuer interface {\n\tLogValue() Value\n}\n    A LogValuer is any Go value that can convert itself into a Value for\n    logging.\n\n    This mechanism may be used to defer expensive operations until they are\n    needed, or to expand a single value into a sequence of components.\n\ntype Logger struct {\n\t// Has unexported fields.\n}\n    A Logger records structured information about each call to its Log, Debug,\n    Info, Warn, and Error methods. For each call, it creates a Record and passes\n    it to a Handler.\n\n    To create a new Logger, call New or a Logger method that begins \"With\".\n\nfunc Default() *Logger\n    Default returns the default Logger.\n\nfunc New(h Handler) *Logger\n    New creates a new Logger with the given non-nil Handler.\n\nfunc With(args ...any) *Logger\n    With calls Logger.With on the default logger.\n\nfunc (l *Logger) Debug(msg string, args ...any)\n    Debug logs at LevelDebug.\n\nfunc (l *Logger) DebugContext(ctx context.Context, msg string, args ...any)\n    DebugContext logs at LevelDebug with the given context.\n\nfunc (l *Logger) Enabled(ctx context.Context, level Level) bool\n    Enabled reports whether l emits log records at the given context and level.\n\nfunc (l *Logger) Error(msg string, args ...any)\n    Error logs at LevelError.\n\nfunc (l *Logger) ErrorContext(ctx context.Context, msg string, args ...any)\n    ErrorContext logs at LevelError with the given context.\n\nfunc (l *Logger) Handler() Handler\n    Handler returns l's Handler.\n\nfunc (l *Logger) Info(msg string, args ...any)\n    Info logs at LevelInfo.\n\nfunc (l *Logger) InfoContext(ctx context.Context, msg string, args ...any)\n    InfoContext logs at LevelInfo with the given context.\n\nfunc (l *Logger) Log(ctx context.Context, level Level, msg string, args ...any)\n    Log emits a log record with the current time and the given level and\n    message. The Record's Attrs consist of the Logger's attributes followed by\n    the Attrs specified by args.\n\n    The attribute arguments are processed as follows:\n      - If an argument is an Attr, it is used as is.\n      - If an argument is a string and this is not the last argument, the\n        following argument is treated as the value and the two are combined into\n        an Attr.\n      - Otherwise, the argument is treated as a value with key \"!BADKEY\".\n\nfunc (l *Logger) LogAttrs(ctx context.Context, level Level, msg string, attrs ...Attr)\n    LogAttrs is a more efficient version of Logger.Log that accepts only Attrs.\n\nfunc (l *Logger) Warn(msg string, args ...any)\n    Warn logs at LevelWarn.\n\nfunc (l *Logger) WarnContext(ctx context.Context, msg string, args ...any)\n    WarnContext logs at LevelWarn with the given context.\n\nfunc (l *Logger) With(args ...any) *Logger\n    With returns a Logger that includes the given attributes in each output\n    operation. Arguments are converted to attributes as if by Logger.Log.\n\nfunc (l *Logger) WithGroup(name string) *Logger\n    WithGroup returns a Logger that starts a group, if name is non-empty. The\n    keys of all attributes added to the Logger will be qualified by the given\n    name. (How that qualification happens depends on the [Handler.WithGroup]\n    method of the Logger's Handler.)\n\n    If name is empty, WithGroup returns the receiver.\n\ntype Record struct {\n\t// The time at which the output method (Log, Info, etc.) was called.\n\tTime time.Time\n\n\t// The log message.\n\tMessage string\n\n\t// The level of the event.\n\tLevel Level\n\n\t// The program counter at the time the record was constructed, as determined\n\t// by runtime.Callers. If zero, no program counter is available.\n\t//\n\t// The only valid use for this value is as an argument to\n\t// [runtime.CallersFrames]. In particular, it must not be passed to\n\t// [runtime.FuncForPC].\n\tPC uintptr\n\n\t// Has unexported fields.\n}\n    A Record holds information about a log event. Copies of a Record share\n    state. Do not modify a Record after handing out a copy to it. Call NewRecord\n    to create a new Record. Use Record.Clone to create a copy with no shared\n    state.\n\nfunc NewRecord(t time.Time, level Level, msg string, pc uintptr) Record\n    NewRecord creates a Record from the given arguments. Use Record.AddAttrs to\n    add attributes to the Record.\n\n    NewRecord is intended for logging APIs that want to support a Handler as a\n    backend.\n\nfunc (r *Record) Add(args ...any)\n    Add converts the args to Attrs as described in Logger.Log, then appends the\n    Attrs to the Record's list of Attrs. It omits empty groups.\n\nfunc (r *Record) AddAttrs(attrs ...Attr)\n    AddAttrs appends the given Attrs to the Record's list of Attrs. It omits\n    empty groups.\n\nfunc (r Record) Attrs(f func(Attr) bool)\n    Attrs calls f on each Attr in the Record. Iteration stops if f returns\n    false.\n\nfunc (r Record) Clone() Record\n    Clone returns a copy of the record with no shared state. The original record\n    and the clone can both be modified without interfering with each other.\n\nfunc (r Record) NumAttrs() int\n    NumAttrs returns the number of attributes in the Record.\n\nfunc (r Record) Source() *Source\n    Source returns a new Source for the log event using r's PC. If the PC field\n    is zero, meaning the Record was created without the necessary information or\n    the location is unavailable, then nil is returned.\n\ntype Source struct {\n\t// Function is the package path-qualified function name containing the\n\t// source line. If non-empty, this string uniquely identifies a single\n\t// function in the program. This may be the empty string if not known.\n\tFunction string `json:\"function\"`\n\t// File and Line are the file name and line number (1-based) of the source\n\t// line. These may be the empty string and zero, respectively, if not known.\n\tFile string `json:\"file\"`\n\tLine int    `json:\"line\"`\n}\n    Source describes the location of a line of source code.\n\ntype TextHandler struct {\n\t// Has unexported fields.\n}\n    TextHandler is a Handler that writes Records to an io.Writer as a sequence\n    of key=value pairs separated by spaces and followed by a newline.\n\nfunc NewTextHandler(w io.Writer, opts *HandlerOptions) *TextHandler\n    NewTextHandler creates a TextHandler that writes to w, using the given\n    options. If opts is nil, the default options are used.\n\nfunc (h *TextHandler) Enabled(_ context.Context, level Level) bool\n    Enabled reports whether the handler handles records at the given level.\n    The handler ignores records whose level is lower.\n\nfunc (h *TextHandler) Handle(_ context.Context, r Record) error\n    Handle formats its argument Record as a single line of space-separated\n    key=value items.\n\n    If the Record's time is zero, the time is omitted. Otherwise, the key is\n    \"time\" and the value is output in RFC3339 format with millisecond precision.\n\n    The level's key is \"level\" and its value is the result of calling\n    Level.String.\n\n    If the AddSource option is set and source information is available, the key\n    is \"source\" and the value is output as FILE:LINE.\n\n    The message's key is \"msg\".\n\n    To modify these or other attributes, or remove them from the output,\n    use [HandlerOptions.ReplaceAttr].\n\n    If a value implements encoding.TextMarshaler, the result of MarshalText is\n    written. Otherwise, the result of fmt.Sprint is written.\n\n    Keys and values are quoted with strconv.Quote if they contain Unicode space\n    characters, non-printing characters, '\"' or '='.\n\n    Keys inside groups consist of components (keys or group names) separated by\n    dots. No further escaping is performed. Thus there is no way to determine\n    from the key \"a.b.c\" whether there are two groups \"a\" and \"b\" and a key \"c\",\n    or a single group \"a.b\" and a key \"c\", or single group \"a\" and a key \"b.c\".\n    If it is necessary to reconstruct the group structure of a key even in the\n    presence of dots inside components, use [HandlerOptions.ReplaceAttr] to\n    encode that information in the key.\n\n    Each call to Handle results in a single serialized call to io.Writer.Write.\n\nfunc (h *TextHandler) WithAttrs(attrs []Attr) Handler\n    WithAttrs returns a new TextHandler whose attributes consists of h's\n    attributes followed by attrs.\n\nfunc (h *TextHandler) WithGroup(name string) Handler\n\ntype Value struct {\n\t// Has unexported fields.\n}\n    A Value can represent any Go value, but unlike type any, it can represent\n    most small values without an allocation. The zero Value corresponds to nil.\n\nfunc AnyValue(v any) Value\n    AnyValue returns a Value for the supplied value.\n\n    If the supplied value is of type Value, it is returned unmodified.\n\n    Given a value of one of Go's predeclared string, bool, or (non-complex)\n    numeric types, AnyValue returns a Value of kind KindString, KindBool,\n    KindUint64, KindInt64, or KindFloat64. The width of the original numeric\n    type is not preserved.\n\n    Given a time.Time or time.Duration value, AnyValue returns a Value of kind\n    KindTime or KindDuration. The monotonic time is not preserved.\n\n    For nil, or values of all other types, including named types whose\n    underlying type is numeric, AnyValue returns a value of kind KindAny.\n\nfunc BoolValue(v bool) Value\n    BoolValue returns a Value for a bool.\n\nfunc DurationValue(v time.Duration) Value\n    DurationValue returns a Value for a time.Duration.\n\nfunc Float64Value(v float64) Value\n    Float64Value returns a Value for a floating-point number.\n\nfunc GroupValue(as ...Attr) Value\n    GroupValue returns a new Value for a list of Attrs. The caller must not\n    subsequently mutate the argument slice.\n\nfunc Int64Value(v int64) Value\n    Int64Value returns a Value for an int64.\n\nfunc IntValue(v int) Value\n    IntValue returns a Value for an int.\n\nfunc StringValue(value string) Value\n    StringValue returns a new Value for a string.\n\nfunc TimeValue(v time.Time) Value\n    TimeValue returns a Value for a time.Time. It discards the monotonic\n    portion.\n\nfunc Uint64Value(v uint64) Value\n    Uint64Value returns a Value for a uint64.\n\nfunc (v Value) Any() any\n    Any returns v's value as an any.\n\nfunc (v Value) Bool() bool\n    Bool returns v's value as a bool. It panics if v is not a bool.\n\nfunc (v Value) Duration() time.Duration\n    Duration returns v's value as a time.Duration. It panics if v is not a\n    time.Duration.\n\nfunc (v Value) Equal(w Value) bool\n    Equal reports whether v and w represent the same Go value.\n\nfunc (v Value) Float64() float64\n    Float64 returns v's value as a float64. It panics if v is not a float64.\n\nfunc (v Value) Group() []Attr\n    Group returns v's value as a []Attr. It panics if v's Kind is not KindGroup.\n\nfunc (v Value) Int64() int64\n    Int64 returns v's value as an int64. It panics if v is not a signed integer.\n\nfunc (v Value) Kind() Kind\n    Kind returns v's Kind.\n\nfunc (v Value) LogValuer() LogValuer\n    LogValuer returns v's value as a LogValuer. It panics if v is not a\n    LogValuer.\n\nfunc (v Value) Resolve() (rv Value)\n    Resolve repeatedly calls LogValue on v while it implements LogValuer,\n    and returns the result. If v resolves to a group, the group's attributes'\n    values are not recursively resolved. If the number of LogValue calls exceeds\n    a threshold, a Value containing an error is returned. Resolve's return value\n    is guaranteed not to be of Kind KindLogValuer.\n\nfunc (v Value) String() string\n    String returns Value's value as a string, formatted like fmt.Sprint.\n    Unlike the methods Int64, Float64, and so on, which panic if v is of the\n    wrong kind, String never panics.\n\nfunc (v Value) Time() time.Time\n    Time returns v's value as a time.Time. It panics if v is not a time.Time.\n\nfunc (v Value) Uint64() uint64\n    Uint64 returns v's value as a uint64. It panics if v is not an unsigned\n    integer.\n\n"}, {"path": "stdlib/go-ast.md", "category": "stdlib", "name": "stdlib/go-ast", "content": "package ast // import \"go/ast\"\n\nPackage ast declares the types used to represent syntax trees for Go packages.\n\nSyntax trees may be constructed directly, but they are typically produced from\nGo source code by the parser; see the ParseFile function in package go/parser.\n\nFUNCTIONS\n\nfunc FileExports(src *File) bool\n    FileExports trims the AST for a Go source file in place such that only\n    exported nodes remain: all top-level identifiers which are not exported and\n    their associated information (such as type, initial value, or function body)\n    are removed. Non-exported fields and methods of exported types are stripped.\n    The [File.Comments] list is not changed.\n\n    FileExports reports whether there are exported declarations.\n\nfunc FilterDecl(decl Decl, f Filter) bool\n    FilterDecl trims the AST for a Go declaration in place by removing all names\n    (including struct field and interface method names, but not from parameter\n    lists) that don't pass through the filter f.\n\n    FilterDecl reports whether there are any declared names left after\n    filtering.\n\nfunc FilterFile(src *File, f Filter) bool\n    FilterFile trims the AST for a Go file in place by removing all names from\n    top-level declarations (including struct field and interface method names,\n    but not from parameter lists) that don't pass through the filter f. If the\n    declaration is empty afterwards, the declaration is removed from the AST.\n    Import declarations are always removed. The [File.Comments] list is not\n    changed.\n\n    FilterFile reports whether there are any top-level declarations left after\n    filtering.\n\nfunc FilterPackage(pkg *Package, f Filter) bool\n    FilterPackage trims the AST for a Go package in place by removing all names\n    from top-level declarations (including struct field and interface method\n    names, but not from parameter lists) that don't pass through the filter f.\n    If the declaration is empty afterwards, the declaration is removed from the\n    AST. The pkg.Files list is not changed, so that file names and top-level\n    package comments don't get lost.\n\n    FilterPackage reports whether there are any top-level declarations left\n    after filtering.\n\n    Deprecated: use the type checker go/types instead of Package; see Object.\n    Alternatively, use FilterFile.\n\nfunc Fprint(w io.Writer, fset *token.FileSet, x any, f FieldFilter) error\n    Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil,\n    position information is interpreted relative to that file set. Otherwise\n    positions are printed as integer values (file set specific offsets).\n\n    A non-nil FieldFilter f may be provided to control the output: struct fields\n    for which f(fieldname, fieldvalue) is true are printed; all others are\n    filtered from the output. Unexported struct fields are never printed.\n\nfunc Inspect(node Node, f func(Node) bool)\n    Inspect traverses an AST in depth-first order: It starts by calling f(node);\n    node must not be nil. If f returns true, Inspect invokes f recursively for\n    each of the non-nil children of node, followed by a call of f(nil).\n\n    In many cases it may be more convenient to use Preorder, which returns an\n    iterator over the sqeuence of nodes, or PreorderStack, which (like Inspect)\n    provides control over descent into subtrees, but additionally reports the\n    stack of enclosing nodes.\n\nfunc IsExported(name string) bool\n    IsExported reports whether name starts with an upper-case letter.\n\nfunc IsGenerated(file *File) bool\n    IsGenerated reports whether the file was generated by a program,\n    not handwritten, by detecting the special comment described at\n    https://go.dev/s/generatedcode.\n\n    The syntax tree must have been parsed with the [parser.ParseComments] flag.\n    Example:\n\n        f, err := parser.ParseFile(fset, filename, src, parser.ParseComments|parser.PackageClauseOnly)\n        if err != nil { ... }\n        gen := ast.IsGenerated(f)\n\nfunc NotNilFilter(_ string, v reflect.Value) bool\n    NotNilFilter is a FieldFilter that returns true for field values that are\n    not nil; it returns false otherwise.\n\nfunc PackageExports(pkg *Package) bool\n    PackageExports trims the AST for a Go package in place such that only\n    exported nodes remain. The pkg.Files list is not changed, so that file names\n    and top-level package comments don't get lost.\n\n    PackageExports reports whether there are exported declarations; it returns\n    false otherwise.\n\n    Deprecated: use the type checker go/types instead of Package; see Object.\n    Alternatively, use FileExports.\n\nfunc Preorder(root Node) iter.Seq[Node]\n    Preorder returns an iterator over all the nodes of the syntax tree beneath\n    (and including) the specified root, in depth-first preorder.\n\n    For greater control over the traversal of each subtree, use Inspect or\n    PreorderStack.\n\nfunc PreorderStack(root Node, stack []Node, f func(n Node, stack []Node) bool)\n    PreorderStack traverses the tree rooted at root, calling f before visiting\n    each node.\n\n    Each call to f provides the current node and traversal stack, consisting\n    of the original value of stack appended with all nodes from root to n,\n    excluding n itself. (This design allows calls to PreorderStack to be nested\n    without double counting.)\n\n    If f returns false, the traversal skips over that subtree. Unlike Inspect,\n    no second call to f is made after visiting node n. (In practice, the second\n    call is nearly always used only to pop the stack, and it is surprisingly\n    tricky to do this correctly.)\n\nfunc Print(fset *token.FileSet, x any) error\n    Print prints x to standard output, skipping nil fields. Print(fset, x) is\n    the same as Fprint(os.Stdout, fset, x, NotNilFilter).\n\nfunc SortImports(fset *token.FileSet, f *File)\n    SortImports sorts runs of consecutive import lines in import blocks in f.\n    It also removes duplicate imports when it is possible to do so without data\n    loss.\n\nfunc Walk(v Visitor, node Node)\n    Walk traverses an AST in depth-first order: It starts by calling\n    v.Visit(node); node must not be nil. If the visitor w returned by\n    v.Visit(node) is not nil, Walk is invoked recursively with visitor w for\n    each of the non-nil children of node, followed by a call of w.Visit(nil).\n\n\nTYPES\n\ntype ArrayType struct {\n\tLbrack token.Pos // position of \"[\"\n\tLen    Expr      // Ellipsis node for [...]T array types, nil for slice types\n\tElt    Expr      // element type\n}\n    An ArrayType node represents an array or slice type.\n\nfunc (x *ArrayType) End() token.Pos\n\nfunc (x *ArrayType) Pos() token.Pos\n\ntype AssignStmt struct {\n\tLhs    []Expr\n\tTokPos token.Pos   // position of Tok\n\tTok    token.Token // assignment token, DEFINE\n\tRhs    []Expr\n}\n    An AssignStmt node represents an assignment or a short variable declaration.\n\nfunc (s *AssignStmt) End() token.Pos\n\nfunc (s *AssignStmt) Pos() token.Pos\n\ntype BadDecl struct {\n\tFrom, To token.Pos // position range of bad declaration\n}\n    A BadDecl node is a placeholder for a declaration containing syntax errors\n    for which a correct declaration node cannot be created.\n\nfunc (d *BadDecl) End() token.Pos\n\nfunc (d *BadDecl) Pos() token.Pos\n\ntype BadExpr struct {\n\tFrom, To token.Pos // position range of bad expression\n}\n    A BadExpr node is a placeholder for an expression containing syntax errors\n    for which a correct expression node cannot be created.\n\nfunc (x *BadExpr) End() token.Pos\n\nfunc (x *BadExpr) Pos() token.Pos\n\ntype BadStmt struct {\n\tFrom, To token.Pos // position range of bad statement\n}\n    A BadStmt node is a placeholder for statements containing syntax errors for\n    which no correct statement nodes can be created.\n\nfunc (s *BadStmt) End() token.Pos\n\nfunc (s *BadStmt) Pos() token.Pos\n\ntype BasicLit struct {\n\tValuePos token.Pos   // literal position\n\tKind     token.Token // token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\tValue    string      // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o`\n}\n    A BasicLit node represents a literal of basic type.\n\n    Note that for the CHAR and STRING kinds, the literal is stored with its\n    quotes. For example, for a double-quoted STRING, the first and the last rune\n    in the Value field will be \". The strconv.Unquote and strconv.UnquoteChar\n    functions can be used to unquote STRING and CHAR values, respectively.\n\n    For raw string literals (Kind == token.STRING && Value[0] == '`'), the\n    Value field contains the string text without carriage returns (\\r) that may\n    have been present in the source. Because the end position is computed using\n    len(Value), the position reported by BasicLit.End does not match the true\n    source end position for raw string literals containing carriage returns.\n\nfunc (x *BasicLit) End() token.Pos\n\nfunc (x *BasicLit) Pos() token.Pos\n\ntype BinaryExpr struct {\n\tX     Expr        // left operand\n\tOpPos token.Pos   // position of Op\n\tOp    token.Token // operator\n\tY     Expr        // right operand\n}\n    A BinaryExpr node represents a binary expression.\n\nfunc (x *BinaryExpr) End() token.Pos\n\nfunc (x *BinaryExpr) Pos() token.Pos\n\ntype BlockStmt struct {\n\tLbrace token.Pos // position of \"{\"\n\tList   []Stmt\n\tRbrace token.Pos // position of \"}\", if any (may be absent due to syntax error)\n}\n    A BlockStmt node represents a braced statement list.\n\nfunc (s *BlockStmt) End() token.Pos\n\nfunc (s *BlockStmt) Pos() token.Pos\n\ntype BranchStmt struct {\n\tTokPos token.Pos   // position of Tok\n\tTok    token.Token // keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\tLabel  *Ident      // label name; or nil\n}\n    A BranchStmt node represents a break, continue, goto, or fallthrough\n    statement.\n\nfunc (s *BranchStmt) End() token.Pos\n\nfunc (s *BranchStmt) Pos() token.Pos\n\ntype CallExpr struct {\n\tFun      Expr      // function expression\n\tLparen   token.Pos // position of \"(\"\n\tArgs     []Expr    // function arguments; or nil\n\tEllipsis token.Pos // position of \"...\" (token.NoPos if there is no \"...\")\n\tRparen   token.Pos // position of \")\"\n}\n    A CallExpr node represents an expression followed by an argument list.\n\nfunc (x *CallExpr) End() token.Pos\n\nfunc (x *CallExpr) Pos() token.Pos\n\ntype CaseClause struct {\n\tCase  token.Pos // position of \"case\" or \"default\" keyword\n\tList  []Expr    // list of expressions or types; nil means default case\n\tColon token.Pos // position of \":\"\n\tBody  []Stmt    // statement list; or nil\n}\n    A CaseClause represents a case of an expression or type switch statement.\n\nfunc (s *CaseClause) End() token.Pos\n\nfunc (s *CaseClause) Pos() token.Pos\n\ntype ChanDir int\n    The direction of a channel type is indicated by a bit mask including one or\n    both of the following constants.\n\nconst (\n\tSEND ChanDir = 1 << iota\n\tRECV\n)\ntype ChanType struct {\n\tBegin token.Pos // position of \"chan\" keyword or \"<-\" (whichever comes first)\n\tArrow token.Pos // position of \"<-\" (token.NoPos if there is no \"<-\")\n\tDir   ChanDir   // channel direction\n\tValue Expr      // value type\n}\n    A ChanType node represents a channel type.\n\nfunc (x *ChanType) End() token.Pos\n\nfunc (x *ChanType) Pos() token.Pos\n\ntype CommClause struct {\n\tCase  token.Pos // position of \"case\" or \"default\" keyword\n\tComm  Stmt      // send or receive statement; nil means default case\n\tColon token.Pos // position of \":\"\n\tBody  []Stmt    // statement list; or nil\n}\n    A CommClause node represents a case of a select statement.\n\nfunc (s *CommClause) End() token.Pos\n\nfunc (s *CommClause) Pos() token.Pos\n\ntype Comment struct {\n\tSlash token.Pos // position of \"/\" starting the comment\n\tText  string    // comment text (excluding '\\n' for //-style comments)\n}\n    A Comment node represents a single //-style or /*-style comment.\n\n    The Text field contains the comment text without carriage returns (\\r) that\n    may have been present in the source. Because a comment's end position is\n    computed using len(Text), the position reported by Comment.End does not\n    match the true source end position for comments containing carriage returns.\n\nfunc (c *Comment) End() token.Pos\n\nfunc (c *Comment) Pos() token.Pos\n\ntype CommentGroup struct {\n\tList []*Comment // len(List) > 0\n}\n    A CommentGroup represents a sequence of comments with no other tokens and no\n    empty lines between.\n\nfunc (g *CommentGroup) End() token.Pos\n\nfunc (g *CommentGroup) Pos() token.Pos\n\nfunc (g *CommentGroup) Text() string\n    Text returns the text of the comment. Comment markers (//, /*, and */),\n    the first space of a line comment, and leading and trailing empty lines\n    are removed. Comment directives like \"//line\" and \"//go:noinline\" are also\n    removed. Multiple empty lines are reduced to one, and trailing space on\n    lines is trimmed. Unless the result is empty, it is newline-terminated.\n\ntype CommentMap map[Node][]*CommentGroup\n    A CommentMap maps an AST node to a list of comment groups associated with\n    it. See NewCommentMap for a description of the association.\n\nfunc NewCommentMap(fset *token.FileSet, node Node, comments []*CommentGroup) CommentMap\n    NewCommentMap creates a new comment map by associating comment groups of the\n    comments list with the nodes of the AST specified by node.\n\n    A comment group g is associated with a node n if:\n\n      - g starts on the same line as n ends\n      - g starts on the line immediately following n, and there is at least one\n        empty line after g and before the next node\n      - g starts before n and is not associated to the node before n via the\n        previous rules\n\n    NewCommentMap tries to associate a comment group to the \"largest\" node\n    possible: For instance, if the comment is a line comment trailing an\n    assignment, the comment is associated with the entire assignment rather than\n    just the last operand in the assignment.\n\nfunc (cmap CommentMap) Comments() []*CommentGroup\n    Comments returns the list of comment groups in the comment map. The result\n    is sorted in source order.\n\nfunc (cmap CommentMap) Filter(node Node) CommentMap\n    Filter returns a new comment map consisting of only those entries of cmap\n    for which a corresponding node exists in the AST specified by node.\n\nfunc (cmap CommentMap) String() string\n\nfunc (cmap CommentMap) Update(old, new Node) Node\n    Update replaces an old node in the comment map with the new node and returns\n    the new node. Comments that were associated with the old node are associated\n    with the new node.\n\ntype CompositeLit struct {\n\tType       Expr      // literal type; or nil\n\tLbrace     token.Pos // position of \"{\"\n\tElts       []Expr    // list of composite elements; or nil\n\tRbrace     token.Pos // position of \"}\"\n\tIncomplete bool      // true if (source) expressions are missing in the Elts list\n}\n    A CompositeLit node represents a composite literal.\n\nfunc (x *CompositeLit) End() token.Pos\n\nfunc (x *CompositeLit) Pos() token.Pos\n\ntype Decl interface {\n\tNode\n\t// Has unexported methods.\n}\n    All declaration nodes implement the Decl interface.\n\ntype DeclStmt struct {\n\tDecl Decl // *GenDecl with CONST, TYPE, or VAR token\n}\n    A DeclStmt node represents a declaration in a statement list.\n\nfunc (s *DeclStmt) End() token.Pos\n\nfunc (s *DeclStmt) Pos() token.Pos\n\ntype DeferStmt struct {\n\tDefer token.Pos // position of \"defer\" keyword\n\tCall  *CallExpr\n}\n    A DeferStmt node represents a defer statement.\n\nfunc (s *DeferStmt) End() token.Pos\n\nfunc (s *DeferStmt) Pos() token.Pos\n\ntype Ellipsis struct {\n\tEllipsis token.Pos // position of \"...\"\n\tElt      Expr      // ellipsis element type (parameter lists only); or nil\n}\n    An Ellipsis node stands for the \"...\" type in a parameter list or the \"...\"\n    length in an array type.\n\nfunc (x *Ellipsis) End() token.Pos\n\nfunc (x *Ellipsis) Pos() token.Pos\n\ntype EmptyStmt struct {\n\tSemicolon token.Pos // position of following \";\"\n\tImplicit  bool      // if set, \";\" was omitted in the source\n}\n    An EmptyStmt node represents an empty statement. The \"position\" of the\n    empty statement is the position of the immediately following (explicit or\n    implicit) semicolon.\n\nfunc (s *EmptyStmt) End() token.Pos\n\nfunc (s *EmptyStmt) Pos() token.Pos\n\ntype Expr interface {\n\tNode\n\t// Has unexported methods.\n}\n    All expression nodes implement the Expr interface.\n\nfunc Unparen(e Expr) Expr\n    Unparen returns the expression with any enclosing parentheses removed.\n\ntype ExprStmt struct {\n\tX Expr // expression\n}\n    An ExprStmt node represents a (stand-alone) expression in a statement list.\n\nfunc (s *ExprStmt) End() token.Pos\n\nfunc (s *ExprStmt) Pos() token.Pos\n\ntype Field struct {\n\tDoc     *CommentGroup // associated documentation; or nil\n\tNames   []*Ident      // field/method/(type) parameter names; or nil\n\tType    Expr          // field/method/parameter type; or nil\n\tTag     *BasicLit     // field tag; or nil\n\tComment *CommentGroup // line comments; or nil\n}\n    A Field represents a Field declaration list in a struct type, a method list\n    in an interface type, or a parameter/result declaration in a signature.\n    [Field.Names] is nil for unnamed parameters (parameter lists which only\n    contain types) and embedded struct fields. In the latter case, the field\n    name is the type name.\n\nfunc (f *Field) End() token.Pos\n\nfunc (f *Field) Pos() token.Pos\n\ntype FieldFilter func(name string, value reflect.Value) bool\n    A FieldFilter may be provided to Fprint to control the output.\n\ntype FieldList struct {\n\tOpening token.Pos // position of opening parenthesis/brace/bracket, if any\n\tList    []*Field  // field list; or nil\n\tClosing token.Pos // position of closing parenthesis/brace/bracket, if any\n}\n    A FieldList represents a list of Fields, enclosed by parentheses, curly\n    braces, or square brackets.\n\nfunc (f *FieldList) End() token.Pos\n\nfunc (f *FieldList) NumFields() int\n    NumFields returns the number of parameters or struct fields represented by a\n    FieldList.\n\nfunc (f *FieldList) Pos() token.Pos\n\ntype File struct {\n\tDoc     *CommentGroup // associated documentation; or nil\n\tPackage token.Pos     // position of \"package\" keyword\n\tName    *Ident        // package name\n\tDecls   []Decl        // top-level declarations; or nil\n\n\tFileStart, FileEnd token.Pos       // start and end of entire file\n\tScope              *Scope          // package scope (this file only). Deprecated: see Object\n\tImports            []*ImportSpec   // imports in this file\n\tUnresolved         []*Ident        // unresolved identifiers in this file. Deprecated: see Object\n\tComments           []*CommentGroup // list of all comments in the source file\n\tGoVersion          string          // minimum Go version required by //go:build or // +build directives\n}\n    A File node represents a Go source file.\n\n    The Comments list contains all comments in the source file in order of\n    appearance, including the comments that are pointed to from other nodes via\n    Doc and Comment fields.\n\n    For correct printing of source code containing comments (using packages\n    go/format and go/printer), special care must be taken to update comments\n    when a File's syntax tree is modified: For printing, comments are\n    interspersed between tokens based on their position. If syntax tree nodes\n    are removed or moved, relevant comments in their vicinity must also be\n    removed (from the [File.Comments] list) or moved accordingly (by updating\n    their positions). A CommentMap may be used to facilitate some of these\n    operations.\n\n    Whether and how a comment is associated with a node depends on the\n    interpretation of the syntax tree by the manipulating program: except for\n    Doc and Comment comments directly associated with nodes, the remaining\n    comments are \"free-floating\" (see also issues #18593, #20744).\n\n[#18593]: https://go.dev/issue/18593\n[#20744]: https://go.dev/issue/20744\n\nfunc MergePackageFiles(pkg *Package, mode MergeMode) *File\n    MergePackageFiles creates a file AST by merging the ASTs of the files\n    belonging to a package. The mode flags control merging behavior.\n\n    Deprecated: this function is poorly specified and has unfixable bugs;\n    also Package is deprecated.\n\nfunc (f *File) End() token.Pos\n    End returns the end of the last declaration in the file. It may be invalid,\n    for example in an empty file.\n\n    (Use FileEnd for the end of the entire file. It is always valid.)\n\nfunc (f *File) Pos() token.Pos\n    Pos returns the position of the package declaration. It may be invalid,\n    for example in an empty file.\n\n    (Use FileStart for the start of the entire file. It is always valid.)\n\ntype Filter func(string) bool\n\ntype ForStmt struct {\n\tFor  token.Pos // position of \"for\" keyword\n\tInit Stmt      // initialization statement; or nil\n\tCond Expr      // condition; or nil\n\tPost Stmt      // post iteration statement; or nil\n\tBody *BlockStmt\n}\n    A ForStmt represents a for statement.\n\nfunc (s *ForStmt) End() token.Pos\n\nfunc (s *ForStmt) Pos() token.Pos\n\ntype FuncDecl struct {\n\tDoc  *CommentGroup // associated documentation; or nil\n\tRecv *FieldList    // receiver (methods); or nil (functions)\n\tName *Ident        // function/method name\n\tType *FuncType     // function signature: type and value parameters, results, and position of \"func\" keyword\n\tBody *BlockStmt    // function body; or nil for external (non-Go) function\n}\n    A FuncDecl node represents a function declaration.\n\nfunc (d *FuncDecl) End() token.Pos\n\nfunc (d *FuncDecl) Pos() token.Pos\n\ntype FuncLit struct {\n\tType *FuncType  // function type\n\tBody *BlockStmt // function body\n}\n    A FuncLit node represents a function literal.\n\nfunc (x *FuncLit) End() token.Pos\n\nfunc (x *FuncLit) Pos() token.Pos\n\ntype FuncType struct {\n\tFunc       token.Pos  // position of \"func\" keyword (token.NoPos if there is no \"func\")\n\tTypeParams *FieldList // type parameters; or nil\n\tParams     *FieldList // (incoming) parameters; non-nil\n\tResults    *FieldList // (outgoing) results; or nil\n}\n    A FuncType node represents a function type.\n\nfunc (x *FuncType) End() token.Pos\n\nfunc (x *FuncType) Pos() token.Pos\n\ntype GenDecl struct {\n\tDoc    *CommentGroup // associated documentation; or nil\n\tTokPos token.Pos     // position of Tok\n\tTok    token.Token   // IMPORT, CONST, TYPE, or VAR\n\tLparen token.Pos     // position of '(', if any\n\tSpecs  []Spec\n\tRparen token.Pos // position of ')', if any\n}\n    A GenDecl node (generic declaration node) represents an import, constant,\n    type or variable declaration. A valid Lparen position (Lparen.IsValid())\n    indicates a parenthesized declaration.\n\n    Relationship between Tok value and Specs element type:\n\n        token.IMPORT  *ImportSpec\n        token.CONST   *ValueSpec\n        token.TYPE    *TypeSpec\n        token.VAR     *ValueSpec\n\nfunc (d *GenDecl) End() token.Pos\n\nfunc (d *GenDecl) Pos() token.Pos\n\ntype GoStmt struct {\n\tGo   token.Pos // position of \"go\" keyword\n\tCall *CallExpr\n}\n    A GoStmt node represents a go statement.\n\nfunc (s *GoStmt) End() token.Pos\n\nfunc (s *GoStmt) Pos() token.Pos\n\ntype Ident struct {\n\tNamePos token.Pos // identifier position\n\tName    string    // identifier name\n\tObj     *Object   // denoted object, or nil. Deprecated: see Object.\n}\n    An Ident node represents an identifier.\n\nfunc NewIdent(name string) *Ident\n    NewIdent creates a new Ident without position. Useful for ASTs generated by\n    code other than the Go parser.\n\nfunc (x *Ident) End() token.Pos\n\nfunc (id *Ident) IsExported() bool\n    IsExported reports whether id starts with an upper-case letter.\n\nfunc (x *Ident) Pos() token.Pos\n\nfunc (id *Ident) String() string\n\ntype IfStmt struct {\n\tIf   token.Pos // position of \"if\" keyword\n\tInit Stmt      // initialization statement; or nil\n\tCond Expr      // condition\n\tBody *BlockStmt\n\tElse Stmt // else branch; or nil\n}\n    An IfStmt node represents an if statement.\n\nfunc (s *IfStmt) End() token.Pos\n\nfunc (s *IfStmt) Pos() token.Pos\n\ntype ImportSpec struct {\n\tDoc     *CommentGroup // associated documentation; or nil\n\tName    *Ident        // local package name (including \".\"); or nil\n\tPath    *BasicLit     // import path\n\tComment *CommentGroup // line comments; or nil\n\tEndPos  token.Pos     // end of spec (overrides Path.Pos if nonzero)\n}\n    An ImportSpec node represents a single package import.\n\nfunc (s *ImportSpec) End() token.Pos\n\nfunc (s *ImportSpec) Pos() token.Pos\n\ntype Importer func(imports map[string]*Object, path string) (pkg *Object, err error)\n    An Importer resolves import paths to package Objects. The imports map\n    records the packages already imported, indexed by package id (canonical\n    import path). An Importer must determine the canonical import path and\n    check the map to see if it is already present in the imports map. If so,\n    the Importer can return the map entry. Otherwise, the Importer should load\n    the package data for the given path into a new *Object (pkg), record pkg in\n    the imports map, and then return pkg.\n\n    Deprecated: use the type checker go/types instead; see Object.\n\ntype IncDecStmt struct {\n\tX      Expr\n\tTokPos token.Pos   // position of Tok\n\tTok    token.Token // INC or DEC\n}\n    An IncDecStmt node represents an increment or decrement statement.\n\nfunc (s *IncDecStmt) End() token.Pos\n\nfunc (s *IncDecStmt) Pos() token.Pos\n\ntype IndexExpr struct {\n\tX      Expr      // expression\n\tLbrack token.Pos // position of \"[\"\n\tIndex  Expr      // index expression\n\tRbrack token.Pos // position of \"]\"\n}\n    An IndexExpr node represents an expression followed by an index.\n\nfunc (x *IndexExpr) End() token.Pos\n\nfunc (x *IndexExpr) Pos() token.Pos\n\ntype IndexListExpr struct {\n\tX       Expr      // expression\n\tLbrack  token.Pos // position of \"[\"\n\tIndices []Expr    // index expressions\n\tRbrack  token.Pos // position of \"]\"\n}\n    An IndexListExpr node represents an expression followed by multiple indices.\n\nfunc (x *IndexListExpr) End() token.Pos\n\nfunc (x *IndexListExpr) Pos() token.Pos\n\ntype InterfaceType struct {\n\tInterface  token.Pos  // position of \"interface\" keyword\n\tMethods    *FieldList // list of embedded interfaces, methods, or types\n\tIncomplete bool       // true if (source) methods or types are missing in the Methods list\n}\n    An InterfaceType node represents an interface type.\n\nfunc (x *InterfaceType) End() token.Pos\n\nfunc (x *InterfaceType) Pos() token.Pos\n\ntype KeyValueExpr struct {\n\tKey   Expr\n\tColon token.Pos // position of \":\"\n\tValue Expr\n}\n    A KeyValueExpr node represents (key : value) pairs in composite literals.\n\nfunc (x *KeyValueExpr) End() token.Pos\n\nfunc (x *KeyValueExpr) Pos() token.Pos\n\ntype LabeledStmt struct {\n\tLabel *Ident\n\tColon token.Pos // position of \":\"\n\tStmt  Stmt\n}\n    A LabeledStmt node represents a labeled statement.\n\nfunc (s *LabeledStmt) End() token.Pos\n\nfunc (s *LabeledStmt) Pos() token.Pos\n\ntype MapType struct {\n\tMap   token.Pos // position of \"map\" keyword\n\tKey   Expr\n\tValue Expr\n}\n    A MapType node represents a map type.\n\nfunc (x *MapType) End() token.Pos\n\nfunc (x *MapType) Pos() token.Pos\n\ntype MergeMode uint\n    The MergeMode flags control the behavior of MergePackageFiles.\n\n    Deprecated: use the type checker go/types instead of Package; see Object.\n\nconst (\n\t// If set, duplicate function declarations are excluded.\n\tFilterFuncDuplicates MergeMode = 1 << iota\n\t// If set, comments that are not associated with a specific\n\t// AST node (as Doc or Comment) are excluded.\n\tFilterUnassociatedComments\n\t// If set, duplicate import declarations are excluded.\n\tFilterImportDuplicates\n)\n    Deprecated: use the type checker go/types instead of Package; see Object.\n\ntype Node interface {\n\tPos() token.Pos // position of first character belonging to the node\n\tEnd() token.Pos // position of first character immediately after the node\n}\n    All node types implement the Node interface.\n\ntype ObjKind int\n    ObjKind describes what an Object represents.\n\nconst (\n\tBad ObjKind = iota // for error handling\n\tPkg                // package\n\tCon                // constant\n\tTyp                // type\n\tVar                // variable\n\tFun                // function or method\n\tLbl                // label\n)\n    The list of possible Object kinds.\n\nfunc (kind ObjKind) String() string\n\ntype Object struct {\n\tKind ObjKind\n\tName string // declared name\n\tDecl any    // corresponding Field, XxxSpec, FuncDecl, LabeledStmt, AssignStmt, Scope; or nil\n\tData any    // object-specific data; or nil\n\tType any    // placeholder for type information; may be nil\n}\n    An Object describes a named language entity such as a package, constant,\n    type, variable, function (incl. methods), or label.\n\n    The Data fields contains object-specific data:\n\n        Kind    Data type         Data value\n        Pkg     *Scope            package scope\n        Con     int               iota for the respective declaration\n\n    Deprecated: The relationship between Idents and Objects cannot be correctly\n    computed without type information. For example, the expression T{K: 0} may\n    denote a struct, map, slice, or array literal, depending on the type of T.\n    If T is a struct, then K refers to a field of T, whereas for the other types\n    it refers to a value in the environment.\n\n    New programs should set the [parser.SkipObjectResolution] parser flag to\n    disable syntactic object resolution (which also saves CPU and memory),\n    and instead use the type checker go/types if object resolution is desired.\n    See the Defs, Uses, and Implicits fields of the [types.Info] struct for\n    details.\n\nfunc NewObj(kind ObjKind, name string) *Object\n    NewObj creates a new object of a given kind and name.\n\nfunc (obj *Object) Pos() token.Pos\n    Pos computes the source position of the declaration of an object name.\n    The result may be an invalid position if it cannot be computed (obj.Decl may\n    be nil or not correct).\n\ntype Package struct {\n\tName    string             // package name\n\tScope   *Scope             // package scope across all files\n\tImports map[string]*Object // map of package id -> package object\n\tFiles   map[string]*File   // Go source files by filename\n}\n    A Package node represents a set of source files collectively building a Go\n    package.\n\n    Deprecated: use the type checker go/types instead; see Object.\n\nfunc NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)\n    NewPackage creates a new Package node from a set of File nodes. It resolves\n    unresolved identifiers across files and updates each file's Unresolved\n    list accordingly. If a non-nil importer and universe scope are provided,\n    they are used to resolve identifiers not declared in any of the package\n    files. Any remaining unresolved identifiers are reported as undeclared.\n    If the files belong to different packages, one package name is selected and\n    files with different package names are reported and then ignored. The result\n    is a package node and a scanner.ErrorList if there were errors.\n\n    Deprecated: use the type checker go/types instead; see Object.\n\nfunc (p *Package) End() token.Pos\n\nfunc (p *Package) Pos() token.Pos\n\ntype ParenExpr struct {\n\tLparen token.Pos // position of \"(\"\n\tX      Expr      // parenthesized expression\n\tRparen token.Pos // position of \")\"\n}\n    A ParenExpr node represents a parenthesized expression.\n\nfunc (x *ParenExpr) End() token.Pos\n\nfunc (x *ParenExpr) Pos() token.Pos\n\ntype RangeStmt struct {\n\tFor        token.Pos   // position of \"for\" keyword\n\tKey, Value Expr        // Key, Value may be nil\n\tTokPos     token.Pos   // position of Tok; invalid if Key == nil\n\tTok        token.Token // ILLEGAL if Key == nil, ASSIGN, DEFINE\n\tRange      token.Pos   // position of \"range\" keyword\n\tX          Expr        // value to range over\n\tBody       *BlockStmt\n}\n    A RangeStmt represents a for statement with a range clause.\n\nfunc (s *RangeStmt) End() token.Pos\n\nfunc (s *RangeStmt) Pos() token.Pos\n\ntype ReturnStmt struct {\n\tReturn  token.Pos // position of \"return\" keyword\n\tResults []Expr    // result expressions; or nil\n}\n    A ReturnStmt node represents a return statement.\n\nfunc (s *ReturnStmt) End() token.Pos\n\nfunc (s *ReturnStmt) Pos() token.Pos\n\ntype Scope struct {\n\tOuter   *Scope\n\tObjects map[string]*Object\n}\n    A Scope maintains the set of named language entities declared in the scope\n    and a link to the immediately surrounding (outer) scope.\n\n    Deprecated: use the type checker go/types instead; see Object.\n\nfunc NewScope(outer *Scope) *Scope\n    NewScope creates a new scope nested in the outer scope.\n\nfunc (s *Scope) Insert(obj *Object) (alt *Object)\n    Insert attempts to insert a named object obj into the scope s. If the scope\n    already contains an object alt with the same name, Insert leaves the scope\n    unchanged and returns alt. Otherwise it inserts obj and returns nil.\n\nfunc (s *Scope) Lookup(name string) *Object\n    Lookup returns the object with the given name if it is found in scope s,\n    otherwise it returns nil. Outer scopes are ignored.\n\nfunc (s *Scope) String() string\n    Debugging support\n\ntype SelectStmt struct {\n\tSelect token.Pos  // position of \"select\" keyword\n\tBody   *BlockStmt // CommClauses only\n}\n    A SelectStmt node represents a select statement.\n\nfunc (s *SelectStmt) End() token.Pos\n\nfunc (s *SelectStmt) Pos() token.Pos\n\ntype SelectorExpr struct {\n\tX   Expr   // expression\n\tSel *Ident // field selector\n}\n    A SelectorExpr node represents an expression followed by a selector.\n\nfunc (x *SelectorExpr) End() token.Pos\n\nfunc (x *SelectorExpr) Pos() token.Pos\n\ntype SendStmt struct {\n\tChan  Expr\n\tArrow token.Pos // position of \"<-\"\n\tValue Expr\n}\n    A SendStmt node represents a send statement.\n\nfunc (s *SendStmt) End() token.Pos\n\nfunc (s *SendStmt) Pos() token.Pos\n\ntype SliceExpr struct {\n\tX      Expr      // expression\n\tLbrack token.Pos // position of \"[\"\n\tLow    Expr      // begin of slice range; or nil\n\tHigh   Expr      // end of slice range; or nil\n\tMax    Expr      // maximum capacity of slice; or nil\n\tSlice3 bool      // true if 3-index slice (2 colons present)\n\tRbrack token.Pos // position of \"]\"\n}\n    A SliceExpr node represents an expression followed by slice indices.\n\nfunc (x *SliceExpr) End() token.Pos\n\nfunc (x *SliceExpr) Pos() token.Pos\n\ntype Spec interface {\n\tNode\n\n\t// Has unexported methods.\n}\n    The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.\n\ntype StarExpr struct {\n\tStar token.Pos // position of \"*\"\n\tX    Expr      // operand\n}\n    A StarExpr node represents an expression of the form \"*\" Expression.\n    Semantically it could be a unary \"*\" expression, or a pointer type.\n\nfunc (x *StarExpr) End() token.Pos\n\nfunc (x *StarExpr) Pos() token.Pos\n\ntype Stmt interface {\n\tNode\n\t// Has unexported methods.\n}\n    All statement nodes implement the Stmt interface.\n\ntype StructType struct {\n\tStruct     token.Pos  // position of \"struct\" keyword\n\tFields     *FieldList // list of field declarations\n\tIncomplete bool       // true if (source) fields are missing in the Fields list\n}\n    A StructType node represents a struct type.\n\nfunc (x *StructType) End() token.Pos\n\nfunc (x *StructType) Pos() token.Pos\n\ntype SwitchStmt struct {\n\tSwitch token.Pos  // position of \"switch\" keyword\n\tInit   Stmt       // initialization statement; or nil\n\tTag    Expr       // tag expression; or nil\n\tBody   *BlockStmt // CaseClauses only\n}\n    A SwitchStmt node represents an expression switch statement.\n\nfunc (s *SwitchStmt) End() token.Pos\n\nfunc (s *SwitchStmt) Pos() token.Pos\n\ntype TypeAssertExpr struct {\n\tX      Expr      // expression\n\tLparen token.Pos // position of \"(\"\n\tType   Expr      // asserted type; nil means type switch X.(type)\n\tRparen token.Pos // position of \")\"\n}\n    A TypeAssertExpr node represents an expression followed by a type assertion.\n\nfunc (x *TypeAssertExpr) End() token.Pos\n\nfunc (x *TypeAssertExpr) Pos() token.Pos\n\ntype TypeSpec struct {\n\tDoc        *CommentGroup // associated documentation; or nil\n\tName       *Ident        // type name\n\tTypeParams *FieldList    // type parameters; or nil\n\tAssign     token.Pos     // position of '=', if any\n\tType       Expr          // *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes\n\tComment    *CommentGroup // line comments; or nil\n}\n    A TypeSpec node represents a type declaration (TypeSpec production).\n\nfunc (s *TypeSpec) End() token.Pos\n\nfunc (s *TypeSpec) Pos() token.Pos\n\ntype TypeSwitchStmt struct {\n\tSwitch token.Pos  // position of \"switch\" keyword\n\tInit   Stmt       // initialization statement; or nil\n\tAssign Stmt       // x := y.(type) or y.(type)\n\tBody   *BlockStmt // CaseClauses only\n}\n    A TypeSwitchStmt node represents a type switch statement.\n\nfunc (s *TypeSwitchStmt) End() token.Pos\n\nfunc (s *TypeSwitchStmt) Pos() token.Pos\n\ntype UnaryExpr struct {\n\tOpPos token.Pos   // position of Op\n\tOp    token.Token // operator\n\tX     Expr        // operand\n}\n    A UnaryExpr node represents a unary expression. Unary \"*\" expressions are\n    represented via StarExpr nodes.\n\nfunc (x *UnaryExpr) End() token.Pos\n\nfunc (x *UnaryExpr) Pos() token.Pos\n\ntype ValueSpec struct {\n\tDoc     *CommentGroup // associated documentation; or nil\n\tNames   []*Ident      // value names (len(Names) > 0)\n\tType    Expr          // value type; or nil\n\tValues  []Expr        // initial values; or nil\n\tComment *CommentGroup // line comments; or nil\n}\n    A ValueSpec node represents a constant or variable declaration (ConstSpec or\n    VarSpec production).\n\nfunc (s *ValueSpec) End() token.Pos\n\nfunc (s *ValueSpec) Pos() token.Pos\n\ntype Visitor interface {\n\tVisit(node Node) (w Visitor)\n}\n    A Visitor's Visit method is invoked for each node encountered by Walk.\n    If the result visitor w is not nil, Walk visits each of the children of node\n    with the visitor w, followed by a call of w.Visit(nil).\n\n"}, {"path": "stdlib/runtime.md", "category": "stdlib", "name": "stdlib/runtime", "content": "package runtime // import \"runtime\"\n\nPackage runtime contains operations that interact with Go's runtime system,\nsuch as functions to control goroutines. It also includes the low-level type\ninformation used by the reflect package; see reflect's documentation for the\nprogrammable interface to the run-time type system.\n\n# Environment Variables\n\nThe following environment variables ($name or %name%, depending on the host\noperating system) control the run-time behavior of Go programs. The meanings and\nuse may change from release to release.\n\nThe GOGC variable sets the initial garbage collection target percentage.\nA collection is triggered when the ratio of freshly allocated data to live\ndata remaining after the previous collection reaches this percentage. The\ndefault is GOGC=100. Setting GOGC=off disables the garbage collector entirely.\nruntime/debug.SetGCPercent allows changing this percentage at run time.\n\nThe GOMEMLIMIT variable sets a soft memory limit for the runtime. This memory\nlimit includes the Go heap and all other memory managed by the runtime, and\nexcludes external memory sources such as mappings of the binary itself, memory\nmanaged in other languages, and memory held by the operating system on behalf\nof the Go program. GOMEMLIMIT is a numeric value in bytes with an optional unit\nsuffix. The supported suffixes include B, KiB, MiB, GiB, and TiB. These suffixes\nrepresent quantities of bytes as defined by the IEC 80000-13 standard. That is,\nthey are based on powers of two: KiB means 2^10 bytes, MiB means 2^20 bytes,\nand so on. The default setting is math.MaxInt64, which effectively disables the\nmemory limit. runtime/debug.SetMemoryLimit allows changing this limit at run\ntime.\n\nThe GODEBUG variable controls debugging variables within the runtime. It is a\ncomma-separated list of name=val pairs setting these named variables:\n\n    clobberfree: setting clobberfree=1 causes the garbage collector to\n    clobber the memory content of an object with bad content when it frees\n    the object.\n\n    cpu.*: cpu.all=off disables the use of all optional instruction set extensions.\n    cpu.extension=off disables use of instructions from the specified instruction set extension.\n    extension is the lower case name for the instruction set extension such as sse41 or avx\n    as listed in internal/cpu package. As an example cpu.avx=off disables runtime detection\n    and thereby use of AVX instructions.\n\n    cgocheck: setting cgocheck=0 disables all checks for packages\n    using cgo to incorrectly pass Go pointers to non-Go code.\n    Setting cgocheck=1 (the default) enables relatively cheap\n    checks that may miss some errors. A more complete, but slow,\n    cgocheck mode can be enabled using GOEXPERIMENT (which\n    requires a rebuild), see https://pkg.go.dev/internal/goexperiment for details.\n\n    checkfinalizers: setting checkfinalizers=1 causes the garbage collector to run\n    multiple partial non-parallel stop-the-world collections to identify common issues with\n    finalizers and cleanups, like those listed at\n    https://go.dev/doc/gc-guide#Finalizers_cleanups_and_weak_pointers. If a potential issue\n    is found, the program will terminate with a description of all potential issues, the\n    associated values, and a list of those values' finalizers and cleanups, including where\n    they were created. It also adds tracking for tiny blocks to help diagnose issues with\n    those as well. The analysis performed during the partial collection is conservative.\n    Notably, it flags any path back to the original object from the cleanup function,\n    cleanup arguments, or finalizer function as a potential issue, even if that path might\n    be severed sometime later during execution (though this is not a recommended pattern).\n    This mode also produces one line of output to stderr every GC cycle with information\n    about the finalizer and cleanup queue lengths. Lines produced by this mode start with\n    \"checkfinalizers:\".\n\n    decoratemappings: controls whether the Go runtime annotates OS\n    anonymous memory mappings with context about their purpose. These\n    annotations appear in /proc/self/maps and /proc/self/smaps as\n    \"[anon: Go: ...]\". This setting is only used on Linux. For Go 1.25, it\n    defaults to `decoratemappings=1`, enabling annotations. Using\n    `decoratemappings=0` reverts to the pre-Go 1.25 behavior.\n\n    disablethp: setting disablethp=1 on Linux disables transparent huge pages for the heap.\n    It has no effect on other platforms. disablethp is meant for compatibility with versions\n    of Go before 1.21, which stopped working around a Linux kernel default that can result\n    in significant memory overuse. See https://go.dev/issue/64332. This setting will be\n    removed in a future release, so operators should tweak their Linux configuration to suit\n    their needs before then. See https://go.dev/doc/gc-guide#Linux_transparent_huge_pages.\n\n    dontfreezetheworld: by default, the start of a fatal panic or throw\n    \"freezes the world\", preempting all threads to stop all running\n    goroutines, which makes it possible to traceback all goroutines, and\n    keeps their state close to the point of panic. Setting\n    dontfreezetheworld=1 disables this preemption, allowing goroutines to\n    continue executing during panic processing. Note that goroutines that\n    naturally enter the scheduler will still stop. This can be useful when\n    debugging the runtime scheduler, as freezetheworld perturbs scheduler\n    state and thus may hide problems.\n\n    efence: setting efence=1 causes the allocator to run in a mode\n    where each object is allocated on a unique page and addresses are\n    never recycled.\n\n    gccheckmark: setting gccheckmark=1 enables verification of the\n    garbage collector's concurrent mark phase by performing a\n    second mark pass while the world is stopped.  If the second\n    pass finds a reachable object that was not found by concurrent\n    mark, the garbage collector will panic.\n\n    gcpacertrace: setting gcpacertrace=1 causes the garbage collector to\n    print information about the internal state of the concurrent pacer.\n\n    gcshrinkstackoff: setting gcshrinkstackoff=1 disables moving goroutines\n    onto smaller stacks. In this mode, a goroutine's stack can only grow.\n\n    gcstoptheworld: setting gcstoptheworld=1 disables concurrent garbage collection,\n    making every garbage collection a stop-the-world event. Setting gcstoptheworld=2\n    also disables concurrent sweeping after the garbage collection finishes.\n\n    gctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard\n    error at each collection, summarizing the amount of memory collected and the\n    length of the pause. The format of this line is subject to change. Included in\n    the explanation below is also the relevant runtime/metrics metric for each field.\n    Currently, it is:\n    \tgc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #->#-># MB, # MB goal, # MB stacks, #MB globals, # P\n    where the fields are as follows:\n    \tgc #         the GC number, incremented at each GC\n    \t@#s          time in seconds since program start\n    \t#%           percentage of time spent in GC since program start\n    \t#+...+#      wall-clock/CPU times for the phases of the GC\n    \t#->#-># MB   heap size at GC start, at GC end, and live heap, or /gc/scan/heap:bytes\n    \t# MB goal    goal heap size, or /gc/heap/goal:bytes\n    \t# MB stacks  estimated scannable stack size, or /gc/scan/stack:bytes\n    \t# MB globals scannable global size, or /gc/scan/globals:bytes\n    \t# P          number of processors used, or /sched/gomaxprocs:threads\n    The phases are stop-the-world (STW) sweep termination, concurrent\n    mark and scan, and STW mark termination. The CPU times\n    for mark/scan are broken down in to assist time (GC performed in\n    line with allocation), background GC time, and idle GC time.\n    If the line ends with \"(forced)\", this GC was forced by a\n    runtime.GC() call.\n\n    harddecommit: setting harddecommit=1 causes memory that is returned to the OS to\n    also have protections removed on it. This is the only mode of operation on Windows,\n    but is helpful in debugging scavenger-related issues on other platforms. Currently,\n    only supported on Linux.\n\n    inittrace: setting inittrace=1 causes the runtime to emit a single line to standard\n    error for each package with init work, summarizing the execution time and memory\n    allocation. No information is printed for inits executed as part of plugin loading\n    and for packages without both user defined and compiler generated init work.\n    The format of this line is subject to change. Currently, it is:\n    \tinit # @#ms, # ms clock, # bytes, # allocs\n    where the fields are as follows:\n    \tinit #      the package name\n    \t@# ms       time in milliseconds when the init started since program start\n    \t# clock     wall-clock time for package initialization work\n    \t# bytes     memory allocated on the heap\n    \t# allocs    number of heap allocations\n\n    madvdontneed: setting madvdontneed=0 will use MADV_FREE\n    instead of MADV_DONTNEED on Linux when returning memory to the\n    kernel. This is more efficient, but means RSS numbers will\n    drop only when the OS is under memory pressure. On the BSDs and\n    Illumos/Solaris, setting madvdontneed=1 will use MADV_DONTNEED instead\n    of MADV_FREE. This is less efficient, but causes RSS numbers to drop\n    more quickly.\n\n    memprofilerate: setting memprofilerate=X will update the value of runtime.MemProfileRate.\n    When set to 0 memory profiling is disabled.  Refer to the description of\n    MemProfileRate for the default value.\n\n    profstackdepth: profstackdepth=128 (the default) will set the maximum stack\n    depth used by all pprof profilers except for the CPU profiler to 128 frames.\n    Stack traces that exceed this limit will be truncated to the limit starting\n    from the leaf frame. Setting profstackdepth to any value above 1024 will\n    silently default to 1024. Future versions of Go may remove this limitation\n    and extend profstackdepth to apply to the CPU profiler and execution tracer.\n\n    pagetrace: setting pagetrace=/path/to/file will write out a trace of page events\n    that can be viewed, analyzed, and visualized using the x/debug/cmd/pagetrace tool.\n    Build your program with GOEXPERIMENT=pagetrace to enable this functionality. Do not\n    enable this functionality if your program is a setuid binary as it introduces a security\n    risk in that scenario. Currently not supported on Windows, plan9 or js/wasm. Setting this\n    option for some applications can produce large traces, so use with care.\n\n    panicnil: setting panicnil=1 disables the runtime error when calling panic with nil\n    interface value or an untyped nil.\n\n    invalidptr: invalidptr=1 (the default) causes the garbage collector and stack\n    copier to crash the program if an invalid pointer value (for example, 1)\n    is found in a pointer-typed location. Setting invalidptr=0 disables this check.\n    This should only be used as a temporary workaround to diagnose buggy code.\n    The real fix is to not store integers in pointer-typed locations.\n\n    sbrk: setting sbrk=1 replaces the memory allocator and garbage collector\n    with a trivial allocator that obtains memory from the operating system and\n    never reclaims any memory.\n\n    scavtrace: setting scavtrace=1 causes the runtime to emit a single line to standard\n    error, roughly once per GC cycle, summarizing the amount of work done by the\n    scavenger as well as the total amount of memory returned to the operating system\n    and an estimate of physical memory utilization. The format of this line is subject\n    to change, but currently it is:\n    \tscav # KiB work (bg), # KiB work (eager), # KiB total, #% util\n    where the fields are as follows:\n    \t# KiB work (bg)    the amount of memory returned to the OS in the background since\n    \t                   the last line\n    \t# KiB work (eager) the amount of memory returned to the OS eagerly since the last line\n    \t# KiB now          the amount of address space currently returned to the OS\n    \t#% util            the fraction of all unscavenged heap memory which is in-use\n    If the line ends with \"(forced)\", then scavenging was forced by a\n    debug.FreeOSMemory() call.\n\n    scheddetail: setting schedtrace=X and scheddetail=1 causes the scheduler to emit\n    detailed multiline info every X milliseconds, describing state of the scheduler,\n    processors, threads and goroutines.\n\n    schedtrace: setting schedtrace=X causes the scheduler to emit a single line to standard\n    error every X milliseconds, summarizing the scheduler state.\n\n    tracebackancestors: setting tracebackancestors=N extends tracebacks with the stacks at\n    which goroutines were created, where N limits the number of ancestor goroutines to\n    report. This also extends the information returned by runtime.Stack.\n    Setting N to 0 will report no ancestry information.\n\n    tracefpunwindoff: setting tracefpunwindoff=1 forces the execution tracer to\n    use the runtime's default stack unwinder instead of frame pointer unwinding.\n    This increases tracer overhead, but could be helpful as a workaround or for\n    debugging unexpected regressions caused by frame pointer unwinding.\n\n    traceadvanceperiod: the approximate period in nanoseconds between trace generations. Only\n    applies if a program is built with GOEXPERIMENT=exectracer2. Used primarily for testing\n    and debugging the execution tracer.\n\n    tracecheckstackownership: setting tracecheckstackownership=1 enables a debug check in the\n    execution tracer to double-check stack ownership before taking a stack trace.\n\n    asyncpreemptoff: asyncpreemptoff=1 disables signal-based\n    asynchronous goroutine preemption. This makes some loops\n    non-preemptible for long periods, which may delay GC and\n    goroutine scheduling. This is useful for debugging GC issues\n    because it also disables the conservative stack scanning used\n    for asynchronously preempted goroutines.\n\nThe net and net/http packages also refer to debugging variables in GODEBUG.\nSee the documentation for those packages for details.\n\nThe GOMAXPROCS variable limits the number of operating system threads that can\nexecute user-level Go code simultaneously. There is no limit to the number of\nthreads that can be blocked in system calls on behalf of Go code; those do not\ncount against the GOMAXPROCS limit. This package's GOMAXPROCS function queries\nand changes the limit.\n\nThe GORACE variable configures the race detector, for programs built using\n-race. See the Race Detector article for details.\n\nThe GOTRACEBACK variable controls the amount of output generated when a Go\nprogram fails due to an unrecovered panic or an unexpected runtime condition.\nBy default, a failure prints a stack trace for the current goroutine, eliding\nfunctions internal to the run-time system, and then exits with exit code 2.\nThe failure prints stack traces for all goroutines if there is no current\ngoroutine or the failure is internal to the run-time. GOTRACEBACK=none omits\nthe goroutine stack traces entirely. GOTRACEBACK=single (the default) behaves\nas described above. GOTRACEBACK=all adds stack traces for all user-created\ngoroutines. GOTRACEBACK=system is like \u201call\u201d but adds stack frames for\nrun-time functions and shows goroutines created internally by the run-time.\nGOTRACEBACK=crash is like \u201csystem\u201d but crashes in an operating system-specific\nmanner instead of exiting. For example, on Unix systems, the crash raises\nSIGABRT to trigger a core dump. GOTRACEBACK=wer is like \u201ccrash\u201d but doesn't\ndisable Windows Error Reporting (WER). For historical reasons, the GOTRACEBACK\nsettings 0, 1, and 2 are synonyms for none, all, and system, respectively.\nThe runtime/debug.SetTraceback function allows increasing the amount of output\nat run time, but it cannot reduce the amount below that specified by the\nenvironment variable.\n\nThe GOARCH, GOOS, GOPATH, and GOROOT environment variables complete the set of\nGo environment variables. They influence the building of Go programs (see cmd/go\nand go/build). GOARCH, GOOS, and GOROOT are recorded at compile time and made\navailable by constants or functions in this package, but they do not influence\nthe execution of the run-time system.\n\n# Security\n\nOn Unix platforms, Go's runtime system behaves slightly differently when\na binary is setuid/setgid or executed with setuid/setgid-like properties,\nin order to prevent dangerous behaviors. On Linux this is determined by checking\nfor the AT_SECURE flag in the auxiliary vector, on the BSDs and Solaris/Illumos\nit is determined by checking the issetugid syscall, and on AIX it is determined\nby checking if the uid/gid match the effective uid/gid.\n\nWhen the runtime determines the binary is setuid/setgid-like, it does three main\nthings:\n  - The standard input/output file descriptors (0, 1, 2) are checked to be open.\n    If any of them are closed, they are opened pointing at /dev/null.\n  - The value of the GOTRACEBACK environment variable is set to 'none'.\n  - When a signal is received that terminates the program, or the program\n    encounters an unrecoverable panic that would otherwise override the value\n    of GOTRACEBACK, the goroutine stack, registers, and other memory related\n    information are omitted.\n\n[Race Detector article]: https://go.dev/doc/articles/race_detector\n\nCONSTANTS\n\nconst Compiler = \"gc\"\n    Compiler is the name of the compiler toolchain that built the running\n    binary. Known toolchains are:\n\n        gc      Also known as cmd/compile.\n        gccgo   The gccgo front end, part of the GCC compiler suite.\n\nconst GOARCH string = goarch.GOARCH\n    GOARCH is the running program's architecture target: one of 386, amd64, arm,\n    s390x, and so on.\n\nconst GOOS string = goos.GOOS\n    GOOS is the running program's operating system target: one of darwin,\n    freebsd, linux, and so on. To view possible combinations of GOOS and GOARCH,\n    run \"go tool dist list\".\n\n\nVARIABLES\n\nvar MemProfileRate int = 512 * 1024\n    MemProfileRate controls the fraction of memory allocations that are recorded\n    and reported in the memory profile. The profiler aims to sample an average\n    of one allocation per MemProfileRate bytes allocated.\n\n    To include every allocated block in the profile, set MemProfileRate to 1.\n    To turn off profiling entirely, set MemProfileRate to 0.\n\n    The tools that process the memory profiles assume that the profile rate is\n    constant across the lifetime of the program and equal to the current value.\n    Programs that change the memory profiling rate should do so just once,\n    as early as possible in the execution of the program (for example, at the\n    beginning of main).\n\n\nFUNCTIONS\n\nfunc BlockProfile(p []BlockProfileRecord) (n int, ok bool)\n    BlockProfile returns n, the number of records in the current blocking\n    profile. If len(p) >= n, BlockProfile copies the profile into p and returns\n    n, true. If len(p) < n, BlockProfile does not change p and returns n, false.\n\n    Most clients should use the runtime/pprof package or the testing package's\n    -test.blockprofile flag instead of calling BlockProfile directly.\n\nfunc Breakpoint()\n    Breakpoint executes a breakpoint trap.\n\nfunc CPUProfile() []byte\n    CPUProfile panics. It formerly provided raw access to chunks of a\n    pprof-format profile generated by the runtime. The details of generating\n    that format have changed, so this functionality has been removed.\n\n    Deprecated: Use the runtime/pprof package, or the handlers in the\n    net/http/pprof package, or the testing package's -test.cpuprofile flag\n    instead.\n\nfunc Caller(skip int) (pc uintptr, file string, line int, ok bool)\n    Caller reports file and line number information about function invocations\n    on the calling goroutine's stack. The argument skip is the number of stack\n    frames to ascend, with 0 identifying the caller of Caller. (For historical\n    reasons the meaning of skip differs between Caller and Callers.) The return\n    values report the program counter, the file name (using forward slashes as\n    path separator, even on Windows), and the line number within the file of\n    the corresponding call. The boolean ok is false if it was not possible to\n    recover the information.\n\nfunc Callers(skip int, pc []uintptr) int\n    Callers fills the slice pc with the return program counters of function\n    invocations on the calling goroutine's stack. The argument skip is the\n    number of stack frames to skip before recording in pc, with 0 identifying\n    the frame for Callers itself and 1 identifying the caller of Callers.\n    It returns the number of entries written to pc.\n\n    To translate these PCs into symbolic information such as function names\n    and line numbers, use CallersFrames. CallersFrames accounts for inlined\n    functions and adjusts the return program counters into call program\n    counters. Iterating over the returned slice of PCs directly is discouraged,\n    as is using FuncForPC on any of the returned PCs, since these cannot account\n    for inlining or return program counter adjustment.\n\nfunc GC()\n    GC runs a garbage collection and blocks the caller until the garbage\n    collection is complete. It may also block the entire program.\n\nfunc GOMAXPROCS(n int) int\n    GOMAXPROCS sets the maximum number of CPUs that can be executing\n    simultaneously and returns the previous setting. If n < 1, it does not\n    change the current setting.\n\n    # Default\n\n    If the GOMAXPROCS environment variable is set to a positive whole number,\n    GOMAXPROCS defaults to that value.\n\n    Otherwise, the Go runtime selects an appropriate default value from a\n    combination of\n      - the number of logical CPUs on the machine,\n      - the process\u2019s CPU affinity mask,\n      - and, on Linux, the process\u2019s average CPU throughput limit based on\n        cgroup CPU quota, if any.\n\n    If GODEBUG=containermaxprocs=0 is set and GOMAXPROCS is not set by the\n    environment variable, then GOMAXPROCS instead defaults to the value of\n    runtime.NumCPU. Note that GODEBUG=containermaxprocs=0 is default for\n    language version 1.24 and below.\n\n    # Updates\n\n    The Go runtime periodically updates the default value based on changes to\n    the total logical CPU count, the CPU affinity mask, or cgroup quota. Setting\n    a custom value with the GOMAXPROCS environment variable or by calling\n    GOMAXPROCS disables automatic updates. The default value and automatic\n    updates can be restored by calling SetDefaultGOMAXPROCS.\n\n    If GODEBUG=updatemaxprocs=0 is set, the Go runtime does not perform\n    automatic GOMAXPROCS updating. Note that GODEBUG=updatemaxprocs=0 is default\n    for language version 1.24 and below.\n\n    # Compatibility\n\n    Note that the default GOMAXPROCS behavior may change as the scheduler\n    improves, especially the implementation detail below.\n\n    # Implementation details\n\n    When computing default GOMAXPROCS via cgroups, the Go runtime computes the\n    \"average CPU throughput limit\" as the cgroup CPU quota / period. In cgroup\n    v2, these values come from the cpu.max file. In cgroup v1, they come from\n    cpu.cfs_quota_us and cpu.cfs_period_us, respectively. In container runtimes\n    that allow configuring CPU limits, this value usually corresponds to the\n    \"CPU limit\" option, not \"CPU request\".\n\n    The Go runtime typically selects the default GOMAXPROCS as the minimum\n    of the logical CPU count, the CPU affinity mask count, or the cgroup CPU\n    throughput limit. However, it will never set GOMAXPROCS less than 2 unless\n    the logical CPU count or CPU affinity mask count are below 2.\n\n    If the cgroup CPU throughput limit is not a whole number, the Go runtime\n    rounds up to the next whole number.\n\n    GOMAXPROCS updates are performed up to once per second, or less if the\n    application is idle.\n\n[default]: https://go.dev/doc/godebug#default\n\nfunc GOROOT() string\n    GOROOT returns the root of the Go tree. It uses the GOROOT environment\n    variable, if set at process start, or else the root used during the Go\n    build.\n\n    Deprecated: The root used during the Go build will not be meaningful if the\n    binary is copied to another machine. Use the system path to locate the \u201cgo\u201d\n    binary, and use \u201cgo env GOROOT\u201d to find its GOROOT.\n\nfunc Goexit()\n    Goexit terminates the goroutine that calls it. No other goroutine is\n    affected. Goexit runs all deferred calls before terminating the goroutine.\n    Because Goexit is not a panic, any recover calls in those deferred functions\n    will return nil.\n\n    Calling Goexit from the main goroutine terminates that goroutine without\n    func main returning. Since func main has not returned, the program continues\n    execution of other goroutines. If all other goroutines exit, the program\n    crashes.\n\n    It crashes if called from a thread not created by the Go runtime.\n\nfunc GoroutineProfile(p []StackRecord) (n int, ok bool)\n    GoroutineProfile returns n, the number of records in the active goroutine\n    stack profile. If len(p) >= n, GoroutineProfile copies the profile into p\n    and returns n, true. If len(p) < n, GoroutineProfile does not change p and\n    returns n, false.\n\n    Most clients should use the runtime/pprof package instead of calling\n    GoroutineProfile directly.\n\nfunc Gosched()\n    Gosched yields the processor, allowing other goroutines to run. It does not\n    suspend the current goroutine, so execution resumes automatically.\n\nfunc KeepAlive(x any)\n    KeepAlive marks its argument as currently reachable. This ensures that the\n    object is not freed, and its finalizer is not run, before the point in the\n    program where KeepAlive is called.\n\n    A very simplified example showing where KeepAlive is required:\n\n        type File struct { d int }\n        d, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)\n        // ... do something if err != nil ...\n        p := &File{d}\n        runtime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\n        var buf [10]byte\n        n, err := syscall.Read(p.d, buf[:])\n        // Ensure p is not finalized until Read returns.\n        runtime.KeepAlive(p)\n        // No more uses of p after this point.\n\n    Without the KeepAlive call, the finalizer could run at the start of\n    syscall.Read, closing the file descriptor before syscall.Read makes the\n    actual system call.\n\n    Note: KeepAlive should only be used to prevent finalizers from running\n    prematurely. In particular, when used with unsafe.Pointer, the rules for\n    valid uses of unsafe.Pointer still apply.\n\nfunc LockOSThread()\n    LockOSThread wires the calling goroutine to its current operating system\n    thread. The calling goroutine will always execute in that thread, and no\n    other goroutine will execute in it, until the calling goroutine has made as\n    many calls to UnlockOSThread as to LockOSThread. If the calling goroutine\n    exits without unlocking the thread, the thread will be terminated.\n\n    All init functions are run on the startup thread. Calling LockOSThread from\n    an init function will cause the main function to be invoked on that thread.\n\n    A goroutine should call LockOSThread before calling OS services or non-Go\n    library functions that depend on per-thread state.\n\nfunc MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)\n    MemProfile returns a profile of memory allocated and freed per allocation\n    site.\n\n    MemProfile returns n, the number of records in the current memory profile.\n    If len(p) >= n, MemProfile copies the profile into p and returns n, true.\n    If len(p) < n, MemProfile does not change p and returns n, false.\n\n    If inuseZero is true, the profile includes allocation records where\n    r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes. These are sites where\n    memory was allocated, but it has all been released back to the runtime.\n\n    The returned profile may be up to two garbage collection cycles old. This is\n    to avoid skewing the profile toward allocations; because allocations happen\n    in real time but frees are delayed until the garbage collector performs\n    sweeping, the profile only accounts for allocations that have had a chance\n    to be freed by the garbage collector.\n\n    Most clients should use the runtime/pprof package or the testing package's\n    -test.memprofile flag instead of calling MemProfile directly.\n\nfunc MutexProfile(p []BlockProfileRecord) (n int, ok bool)\n    MutexProfile returns n, the number of records in the current mutex profile.\n    If len(p) >= n, MutexProfile copies the profile into p and returns n, true.\n    Otherwise, MutexProfile does not change p, and returns n, false.\n\n    Most clients should use the runtime/pprof package instead of calling\n    MutexProfile directly.\n\nfunc NumCPU() int\n    NumCPU returns the number of logical CPUs usable by the current process.\n\n    The set of available CPUs is checked by querying the operating system at\n    process startup. Changes to operating system CPU allocation after process\n    startup are not reflected.\n\nfunc NumCgoCall() int64\n    NumCgoCall returns the number of cgo calls made by the current process.\n\nfunc NumGoroutine() int\n    NumGoroutine returns the number of goroutines that currently exist.\n\nfunc ReadMemStats(m *MemStats)\n    ReadMemStats populates m with memory allocator statistics.\n\n    The returned memory allocator statistics are up to date as of the call to\n    ReadMemStats. This is in contrast with a heap profile, which is a snapshot\n    as of the most recently completed garbage collection cycle.\n\nfunc ReadTrace() []byte\n    ReadTrace returns the next chunk of binary tracing data, blocking until data\n    is available. If tracing is turned off and all the data accumulated while\n    it was on has been returned, ReadTrace returns nil. The caller must copy the\n    returned data before calling ReadTrace again. ReadTrace must be called from\n    one goroutine at a time.\n\nfunc SetBlockProfileRate(rate int)\n    SetBlockProfileRate controls the fraction of goroutine blocking events that\n    are reported in the blocking profile. The profiler aims to sample an average\n    of one blocking event per rate nanoseconds spent blocked.\n\n    To include every blocking event in the profile, pass rate = 1. To turn off\n    profiling entirely, pass rate <= 0.\n\nfunc SetCPUProfileRate(hz int)\n    SetCPUProfileRate sets the CPU profiling rate to hz samples per second.\n    If hz <= 0, SetCPUProfileRate turns off profiling. If the profiler is on,\n    the rate cannot be changed without first turning it off.\n\n    Most clients should use the runtime/pprof package or the testing package's\n    -test.cpuprofile flag instead of calling SetCPUProfileRate directly.\n\nfunc SetCgoTraceback(version int, traceback, context, symbolizer unsafe.Pointer)\n    SetCgoTraceback records three C functions to use to gather traceback\n    information from C code and to convert that traceback information into\n    symbolic information. These are used when printing stack traces for a\n    program that uses cgo.\n\n    The traceback and context functions may be called from a signal handler, and\n    must therefore use only async-signal safe functions. The symbolizer function\n    may be called while the program is crashing, and so must be cautious about\n    using memory. None of the functions may call back into Go.\n\n    The context function will be called with a single argument, a pointer to a\n    struct:\n\n        struct {\n        \tContext uintptr\n        }\n\n    In C syntax, this struct will be\n\n        struct {\n        \tuintptr_t Context;\n        };\n\n    If the Context field is 0, the context function is being called to record\n    the current traceback context. It should record in the Context field\n    whatever information is needed about the current point of execution to later\n    produce a stack trace, probably the stack pointer and PC. In this case the\n    context function will be called from C code.\n\n    If the Context field is not 0, then it is a value returned by a previous\n    call to the context function. This case is called when the context is no\n    longer needed; that is, when the Go code is returning to its C code caller.\n    This permits the context function to release any associated resources.\n\n    While it would be correct for the context function to record a complete a\n    stack trace whenever it is called, and simply copy that out in the traceback\n    function, in a typical program the context function will be called many\n    times without ever recording a traceback for that context. Recording a\n    complete stack trace in a call to the context function is likely to be\n    inefficient.\n\n    The traceback function will be called with a single argument, a pointer to a\n    struct:\n\n        struct {\n        \tContext    uintptr\n        \tSigContext uintptr\n        \tBuf        *uintptr\n        \tMax        uintptr\n        }\n\n    In C syntax, this struct will be\n\n        struct {\n        \tuintptr_t  Context;\n        \tuintptr_t  SigContext;\n        \tuintptr_t* Buf;\n        \tuintptr_t  Max;\n        };\n\n    The Context field will be zero to gather a traceback from the current\n    program execution point. In this case, the traceback function will be called\n    from C code.\n\n    Otherwise Context will be a value previously returned by a call to the\n    context function. The traceback function should gather a stack trace from\n    that saved point in the program execution. The traceback function may\n    be called from an execution thread other than the one that recorded the\n    context, but only when the context is known to be valid and unchanging.\n    The traceback function may also be called deeper in the call stack on the\n    same thread that recorded the context. The traceback function may be called\n    multiple times with the same Context value; it will usually be appropriate\n    to cache the result, if possible, the first time this is called for a\n    specific context value.\n\n    If the traceback function is called from a signal handler on a Unix system,\n    SigContext will be the signal context argument passed to the signal handler\n    (a C ucontext_t* cast to uintptr_t). This may be used to start tracing at\n    the point where the signal occurred. If the traceback function is not called\n    from a signal handler, SigContext will be zero.\n\n    Buf is where the traceback information should be stored. It should be PC\n    values, such that Buf[0] is the PC of the caller, Buf[1] is the PC of that\n    function's caller, and so on. Max is the maximum number of entries to store.\n    The function should store a zero to indicate the top of the stack, or that\n    the caller is on a different stack, presumably a Go stack.\n\n    Unlike runtime.Callers, the PC values returned should, when passed to\n    the symbolizer function, return the file/line of the call instruction.\n    No additional subtraction is required or appropriate.\n\n    On all platforms, the traceback function is invoked when a call from Go to\n    C to Go requests a stack trace. On linux/amd64, linux/ppc64le, linux/arm64,\n    and freebsd/amd64, the traceback function is also invoked when a signal is\n    received by a thread that is executing a cgo call. The traceback function\n    should not make assumptions about when it is called, as future versions of\n    Go may make additional calls.\n\n    The symbolizer function will be called with a single argument, a pointer to\n    a struct:\n\n        struct {\n        \tPC      uintptr // program counter to fetch information for\n        \tFile    *byte   // file name (NUL terminated)\n        \tLineno  uintptr // line number\n        \tFunc    *byte   // function name (NUL terminated)\n        \tEntry   uintptr // function entry point\n        \tMore    uintptr // set non-zero if more info for this PC\n        \tData    uintptr // unused by runtime, available for function\n        }\n\n    In C syntax, this struct will be\n\n        struct {\n        \tuintptr_t PC;\n        \tchar*     File;\n        \tuintptr_t Lineno;\n        \tchar*     Func;\n        \tuintptr_t Entry;\n        \tuintptr_t More;\n        \tuintptr_t Data;\n        };\n\n    The PC field will be a value returned by a call to the traceback function.\n\n    The first time the function is called for a particular traceback, all the\n    fields except PC will be 0. The function should fill in the other fields\n    if possible, setting them to 0/nil if the information is not available.\n    The Data field may be used to store any useful information across calls.\n    The More field should be set to non-zero if there is more information for\n    this PC, zero otherwise. If More is set non-zero, the function will be\n    called again with the same PC, and may return different information (this\n    is intended for use with inlined functions). If More is zero, the function\n    will be called with the next PC value in the traceback. When the traceback\n    is complete, the function will be called once more with PC set to zero;\n    this may be used to free any information. Each call will leave the fields\n    of the struct set to the same values they had upon return, except for the PC\n    field when the More field is zero. The function must not keep a copy of the\n    struct pointer between calls.\n\n    When calling SetCgoTraceback, the version argument is the version number\n    of the structs that the functions expect to receive. Currently this must be\n    zero.\n\n    The symbolizer function may be nil, in which case the results of the\n    traceback function will be displayed as numbers. If the traceback function\n    is nil, the symbolizer function will never be called. The context function\n    may be nil, in which case the traceback function will only be called with\n    the context field set to zero. If the context function is nil, then calls\n    from Go to C to Go will not show a traceback for the C portion of the call\n    stack.\n\n    SetCgoTraceback should be called only once, ideally from an init function.\n\nfunc SetDefaultGOMAXPROCS()\n    SetDefaultGOMAXPROCS updates the GOMAXPROCS setting to the runtime default,\n    as described by GOMAXPROCS, ignoring the GOMAXPROCS environment variable.\n\n    SetDefaultGOMAXPROCS can be used to enable the default automatic updating\n    GOMAXPROCS behavior if it has been disabled by the GOMAXPROCS environment\n    variable or a prior call to GOMAXPROCS, or to force an immediate update if\n    the caller is aware of a change to the total logical CPU count, CPU affinity\n    mask or cgroup quota.\n\nfunc SetFinalizer(obj any, finalizer any)\n    SetFinalizer sets the finalizer associated with obj to the provided\n    finalizer function. When the garbage collector finds an unreachable\n    block with an associated finalizer, it clears the association and runs\n    finalizer(obj) in a separate goroutine. This makes obj reachable again,\n    but now without an associated finalizer. Assuming that SetFinalizer is\n    not called again, the next time the garbage collector sees that obj is\n    unreachable, it will free obj.\n\n    SetFinalizer(obj, nil) clears any finalizer associated with obj.\n\n    New Go code should consider using AddCleanup instead, which is much less\n    error-prone than SetFinalizer.\n\n    The argument obj must be a pointer to an object allocated by calling new,\n    by taking the address of a composite literal, or by taking the address of\n    a local variable. The argument finalizer must be a function that takes a\n    single argument to which obj's type can be assigned, and can have arbitrary\n    ignored return values. If either of these is not true, SetFinalizer may\n    abort the program.\n\n    Finalizers are run in dependency order: if A points at B, both have\n    finalizers, and they are otherwise unreachable, only the finalizer for A\n    runs; once A is freed, the finalizer for B can run. If a cyclic structure\n    includes a block with a finalizer, that cycle is not guaranteed to be\n    garbage collected and the finalizer is not guaranteed to run, because there\n    is no ordering that respects the dependencies.\n\n    The finalizer is scheduled to run at some arbitrary time after the program\n    can no longer reach the object to which obj points. There is no guarantee\n    that finalizers will run before a program exits, so typically they are\n    useful only for releasing non-memory resources associated with an object\n    during a long-running program. For example, an os.File object could use a\n    finalizer to close the associated operating system file descriptor when\n    a program discards an os.File without calling Close, but it would be a\n    mistake to depend on a finalizer to flush an in-memory I/O buffer such as a\n    bufio.Writer, because the buffer would not be flushed at program exit.\n\n    It is not guaranteed that a finalizer will run if the size of *obj is zero\n    bytes, because it may share same address with other zero-size objects in\n    memory. See https://go.dev/ref/spec#Size_and_alignment_guarantees.\n\n    It is not guaranteed that a finalizer will run for objects allocated\n    in initializers for package-level variables. Such objects may be\n    linker-allocated, not heap-allocated.\n\n    Note that because finalizers may execute arbitrarily far into the future\n    after an object is no longer referenced, the runtime is allowed to\n    perform a space-saving optimization that batches objects together in a\n    single allocation slot. The finalizer for an unreferenced object in such\n    an allocation may never run if it always exists in the same batch as a\n    referenced object. Typically, this batching only happens for tiny (on the\n    order of 16 bytes or less) and pointer-free objects.\n\n    A finalizer may run as soon as an object becomes unreachable. In order\n    to use finalizers correctly, the program must ensure that the object\n    is reachable until it is no longer required. Objects stored in global\n    variables, or that can be found by tracing pointers from a global variable,\n    are reachable. A function argument or receiver may become unreachable at\n    the last point where the function mentions it. To make an unreachable object\n    reachable, pass the object to a call of the KeepAlive function to mark the\n    last point in the function where the object must be reachable.\n\n    For example, if p points to a struct, such as os.File, that contains a file\n    descriptor d, and p has a finalizer that closes that file descriptor, and if\n    the last use of p in a function is a call to syscall.Write(p.d, buf, size),\n    then p may be unreachable as soon as the program enters syscall.Write.\n    The finalizer may run at that moment, closing p.d, causing syscall.Write\n    to fail because it is writing to a closed file descriptor (or, worse,\n    to an entirely different file descriptor opened by a different goroutine).\n    To avoid this problem, call KeepAlive(p) after the call to syscall.Write.\n\n    A single goroutine runs all finalizers for a program, sequentially.\n    If a finalizer must run for a long time, it should do so by starting a new\n    goroutine.\n\n    In the terminology of the Go memory model, a call SetFinalizer(x,\n    f) \u201csynchronizes before\u201d the finalization call f(x). However, there is no\n    guarantee that KeepAlive(x) or any other use of x \u201csynchronizes before\u201d\n    f(x), so in general a finalizer should use a mutex or other synchronization\n    mechanism if it needs to access mutable state in x. For example, consider\n    a finalizer that inspects a mutable field in x that is modified from time\n    to time in the main program before x becomes unreachable and the finalizer\n    is invoked. The modifications in the main program and the inspection in the\n    finalizer need to use appropriate synchronization, such as mutexes or atomic\n    updates, to avoid read-write races.\n\nfunc SetMutexProfileFraction(rate int) int\n    SetMutexProfileFraction controls the fraction of mutex contention events\n    that are reported in the mutex profile. On average 1/rate events are\n    reported. The previous rate is returned.\n\n    To turn off profiling entirely, pass rate 0. To just read the current rate,\n    pass rate < 0. (For n>1 the details of sampling may change.)\n\nfunc Stack(buf []byte, all bool) int\n    Stack formats a stack trace of the calling goroutine into buf and returns\n    the number of bytes written to buf. If all is true, Stack formats stack\n    traces of all other goroutines into buf after the trace for the current\n    goroutine.\n\nfunc StartTrace() error\n    StartTrace enables tracing for the current process. While tracing, the data\n    will be buffered and available via ReadTrace. StartTrace returns an error\n    if tracing is already enabled. Most clients should use the runtime/trace\n    package or the testing package's -test.trace flag instead of calling\n    StartTrace directly.\n\nfunc StopTrace()\n    StopTrace stops tracing, if it was previously enabled. StopTrace only\n    returns after all the reads for the trace have completed.\n\nfunc ThreadCreateProfile(p []StackRecord) (n int, ok bool)\n    ThreadCreateProfile returns n, the number of records in the thread creation\n    profile. If len(p) >= n, ThreadCreateProfile copies the profile into p and\n    returns n, true. If len(p) < n, ThreadCreateProfile does not change p and\n    returns n, false.\n\n    Most clients should use the runtime/pprof package instead of calling\n    ThreadCreateProfile directly.\n\nfunc UnlockOSThread()\n    UnlockOSThread undoes an earlier call to LockOSThread. If this drops the\n    number of active LockOSThread calls on the calling goroutine to zero,\n    it unwires the calling goroutine from its fixed operating system thread.\n    If there are no active LockOSThread calls, this is a no-op.\n\n    Before calling UnlockOSThread, the caller must ensure that the OS thread\n    is suitable for running other goroutines. If the caller made any permanent\n    changes to the state of the thread that would affect other goroutines,\n    it should not call this function and thus leave the goroutine locked to the\n    OS thread until the goroutine (and hence the thread) exits.\n\nfunc Version() string\n    Version returns the Go tree's version string. It is either the commit hash\n    and date at the time of the build or, when possible, a release tag like\n    \"go1.3\".\n\n\nTYPES\n\ntype BlockProfileRecord struct {\n\tCount  int64\n\tCycles int64\n\tStackRecord\n}\n    BlockProfileRecord describes blocking events originated at a particular call\n    sequence (stack trace).\n\ntype Cleanup struct {\n\t// Has unexported fields.\n}\n    Cleanup is a handle to a cleanup call for a specific object.\n\nfunc AddCleanup[T, S any](ptr *T, cleanup func(S), arg S) Cleanup\n    AddCleanup attaches a cleanup function to ptr. Some time after ptr is\n    no longer reachable, the runtime will call cleanup(arg) in a separate\n    goroutine.\n\n    A typical use is that ptr is an object wrapping an underlying resource\n    (e.g., a File object wrapping an OS file descriptor), arg is the underlying\n    resource (e.g., the OS file descriptor), and the cleanup function releases\n    the underlying resource (e.g., by calling the close system call).\n\n    There are few constraints on ptr. In particular, multiple cleanups may\n    be attached to the same pointer, or to different pointers within the same\n    allocation.\n\n    If ptr is reachable from cleanup or arg, ptr will never be collected and\n    the cleanup will never run. As a protection against simple cases of this,\n    AddCleanup panics if arg is equal to ptr.\n\n    There is no specified order in which cleanups will run. In particular, if\n    several objects point to each other and all become unreachable at the same\n    time, their cleanups all become eligible to run and can run in any order.\n    This is true even if the objects form a cycle.\n\n    Cleanups run concurrently with any user-created goroutines. Cleanups may\n    also run concurrently with one another (unlike finalizers). If a cleanup\n    function must run for a long time, it should create a new goroutine to avoid\n    blocking the execution of other cleanups.\n\n    If ptr has both a cleanup and a finalizer, the cleanup will only run once it\n    has been finalized and becomes unreachable without an associated finalizer.\n\n    The cleanup(arg) call is not always guaranteed to run; in particular it is\n    not guaranteed to run before program exit.\n\n    Cleanups are not guaranteed to run if the size of T is zero bytes,\n    because it may share same address with other zero-size objects in memory.\n    See https://go.dev/ref/spec#Size_and_alignment_guarantees.\n\n    It is not guaranteed that a cleanup will run for objects allocated\n    in initializers for package-level variables. Such objects may be\n    linker-allocated, not heap-allocated.\n\n    Note that because cleanups may execute arbitrarily far into the future\n    after an object is no longer referenced, the runtime is allowed to\n    perform a space-saving optimization that batches objects together in a\n    single allocation slot. The cleanup for an unreferenced object in such\n    an allocation may never run if it always exists in the same batch as a\n    referenced object. Typically, this batching only happens for tiny (on the\n    order of 16 bytes or less) and pointer-free objects.\n\n    A cleanup may run as soon as an object becomes unreachable. In order to use\n    cleanups correctly, the program must ensure that the object is reachable\n    until it is safe to run its cleanup. Objects stored in global variables, or\n    that can be found by tracing pointers from a global variable, are reachable.\n    A function argument or receiver may become unreachable at the last point\n    where the function mentions it. To ensure a cleanup does not get called\n    prematurely, pass the object to the KeepAlive function after the last point\n    where the object must remain reachable.\n\nfunc (c Cleanup) Stop()\n    Stop cancels the cleanup call. Stop will have no effect if the cleanup call\n    has already been queued for execution (because ptr became unreachable).\n    To guarantee that Stop removes the cleanup function, the caller must ensure\n    that the pointer that was passed to AddCleanup is reachable across the call\n    to Stop.\n\ntype Error interface {\n\terror\n\n\t// RuntimeError is a no-op function but\n\t// serves to distinguish types that are runtime\n\t// errors from ordinary errors: a type is a\n\t// runtime error if it has a RuntimeError method.\n\tRuntimeError()\n}\n    Error identifies a runtime error used in panic.\n\n    The Go runtime triggers panics for a variety of cases, as described by the\n    Go Language Spec, such as out-of-bounds slice/array access, close of nil\n    channels, type assertion failures, etc.\n\n    When these cases occur, the Go runtime panics with an error that implements\n    Error. This can be useful when recovering from panics to distinguish between\n    custom application panics and fundamental runtime panics.\n\n    Packages outside of the Go standard library should not implement Error.\n\ntype Frame struct {\n\t// PC is the program counter for the location in this frame.\n\t// For a frame that calls another frame, this will be the\n\t// program counter of a call instruction. Because of inlining,\n\t// multiple frames may have the same PC value, but different\n\t// symbolic information.\n\tPC uintptr\n\n\t// Func is the Func value of this call frame. This may be nil\n\t// for non-Go code or fully inlined functions.\n\tFunc *Func\n\n\t// Function is the package path-qualified function name of\n\t// this call frame. If non-empty, this string uniquely\n\t// identifies a single function in the program.\n\t// This may be the empty string if not known.\n\t// If Func is not nil then Function == Func.Name().\n\tFunction string\n\n\t// File and Line are the file name and line number of the\n\t// location in this frame. For non-leaf frames, this will be\n\t// the location of a call. These may be the empty string and\n\t// zero, respectively, if not known. The file name uses\n\t// forward slashes, even on Windows.\n\tFile string\n\tLine int\n\n\t// Entry point program counter for the function; may be zero\n\t// if not known. If Func is not nil then Entry ==\n\t// Func.Entry().\n\tEntry uintptr\n\n\t// Has unexported fields.\n}\n    Frame is the information returned by Frames for each call frame.\n\ntype Frames struct {\n\t// Has unexported fields.\n}\n    Frames may be used to get function/file/line information for a slice of PC\n    values returned by Callers.\n\nfunc CallersFrames(callers []uintptr) *Frames\n    CallersFrames takes a slice of PC values returned by Callers and prepares to\n    return function/file/line information. Do not change the slice until you are\n    done with the Frames.\n\nfunc (ci *Frames) Next() (frame Frame, more bool)\n    Next returns a Frame representing the next call frame in the slice of PC\n    values. If it has already returned all call frames, Next returns a zero\n    Frame.\n\n    The more result indicates whether the next call to Next will return a valid\n    Frame. It does not necessarily indicate whether this call returned one.\n\n    See the Frames example for idiomatic usage.\n\ntype Func struct {\n\t// Has unexported fields.\n}\n    A Func represents a Go function in the running binary.\n\nfunc FuncForPC(pc uintptr) *Func\n    FuncForPC returns a *Func describing the function that contains the given\n    program counter address, or else nil.\n\n    If pc represents multiple functions because of inlining, it returns the\n    *Func describing the innermost function, but with an entry of the outermost\n    function.\n\nfunc (f *Func) Entry() uintptr\n    Entry returns the entry address of the function.\n\nfunc (f *Func) FileLine(pc uintptr) (file string, line int)\n    FileLine returns the file name and line number of the source code\n    corresponding to the program counter pc. The result will not be accurate if\n    pc is not a program counter within f.\n\nfunc (f *Func) Name() string\n    Name returns the name of the function.\n\ntype MemProfileRecord struct {\n\tAllocBytes, FreeBytes     int64       // number of bytes allocated, freed\n\tAllocObjects, FreeObjects int64       // number of objects allocated, freed\n\tStack0                    [32]uintptr // stack trace for this record; ends at first 0 entry\n}\n    A MemProfileRecord describes the live objects allocated by a particular call\n    sequence (stack trace).\n\nfunc (r *MemProfileRecord) InUseBytes() int64\n    InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).\n\nfunc (r *MemProfileRecord) InUseObjects() int64\n    InUseObjects returns the number of objects in use (AllocObjects -\n    FreeObjects).\n\nfunc (r *MemProfileRecord) Stack() []uintptr\n    Stack returns the stack trace associated with the record, a prefix of\n    r.Stack0.\n\ntype MemStats struct {\n\n\t// Alloc is bytes of allocated heap objects.\n\t//\n\t// This is the same as HeapAlloc (see below).\n\tAlloc uint64\n\n\t// TotalAlloc is cumulative bytes allocated for heap objects.\n\t//\n\t// TotalAlloc increases as heap objects are allocated, but\n\t// unlike Alloc and HeapAlloc, it does not decrease when\n\t// objects are freed.\n\tTotalAlloc uint64\n\n\t// Sys is the total bytes of memory obtained from the OS.\n\t//\n\t// Sys is the sum of the XSys fields below. Sys measures the\n\t// virtual address space reserved by the Go runtime for the\n\t// heap, stacks, and other internal data structures. It's\n\t// likely that not all of the virtual address space is backed\n\t// by physical memory at any given moment, though in general\n\t// it all was at some point.\n\tSys uint64\n\n\t// Lookups is the number of pointer lookups performed by the\n\t// runtime.\n\t//\n\t// This is primarily useful for debugging runtime internals.\n\tLookups uint64\n\n\t// Mallocs is the cumulative count of heap objects allocated.\n\t// The number of live objects is Mallocs - Frees.\n\tMallocs uint64\n\n\t// Frees is the cumulative count of heap objects freed.\n\tFrees uint64\n\n\t// HeapAlloc is bytes of allocated heap objects.\n\t//\n\t// \"Allocated\" heap objects include all reachable objects, as\n\t// well as unreachable objects that the garbage collector has\n\t// not yet freed. Specifically, HeapAlloc increases as heap\n\t// objects are allocated and decreases as the heap is swept\n\t// and unreachable objects are freed. Sweeping occurs\n\t// incrementally between GC cycles, so these two processes\n\t// occur simultaneously, and as a result HeapAlloc tends to\n\t// change smoothly (in contrast with the sawtooth that is\n\t// typical of stop-the-world garbage collectors).\n\tHeapAlloc uint64\n\n\t// HeapSys is bytes of heap memory obtained from the OS.\n\t//\n\t// HeapSys measures the amount of virtual address space\n\t// reserved for the heap. This includes virtual address space\n\t// that has been reserved but not yet used, which consumes no\n\t// physical memory, but tends to be small, as well as virtual\n\t// address space for which the physical memory has been\n\t// returned to the OS after it became unused (see HeapReleased\n\t// for a measure of the latter).\n\t//\n\t// HeapSys estimates the largest size the heap has had.\n\tHeapSys uint64\n\n\t// HeapIdle is bytes in idle (unused) spans.\n\t//\n\t// Idle spans have no objects in them. These spans could be\n\t// (and may already have been) returned to the OS, or they can\n\t// be reused for heap allocations, or they can be reused as\n\t// stack memory.\n\t//\n\t// HeapIdle minus HeapReleased estimates the amount of memory\n\t// that could be returned to the OS, but is being retained by\n\t// the runtime so it can grow the heap without requesting more\n\t// memory from the OS. If this difference is significantly\n\t// larger than the heap size, it indicates there was a recent\n\t// transient spike in live heap size.\n\tHeapIdle uint64\n\n\t// HeapInuse is bytes in in-use spans.\n\t//\n\t// In-use spans have at least one object in them. These spans\n\t// can only be used for other objects of roughly the same\n\t// size.\n\t//\n\t// HeapInuse minus HeapAlloc estimates the amount of memory\n\t// that has been dedicated to particular size classes, but is\n\t// not currently being used. This is an upper bound on\n\t// fragmentation, but in general this memory can be reused\n\t// efficiently.\n\tHeapInuse uint64\n\n\t// HeapReleased is bytes of physical memory returned to the OS.\n\t//\n\t// This counts heap memory from idle spans that was returned\n\t// to the OS and has not yet been reacquired for the heap.\n\tHeapReleased uint64\n\n\t// HeapObjects is the number of allocated heap objects.\n\t//\n\t// Like HeapAlloc, this increases as objects are allocated and\n\t// decreases as the heap is swept and unreachable objects are\n\t// freed.\n\tHeapObjects uint64\n\n\t// StackInuse is bytes in stack spans.\n\t//\n\t// In-use stack spans have at least one stack in them. These\n\t// spans can only be used for other stacks of the same size.\n\t//\n\t// There is no StackIdle because unused stack spans are\n\t// returned to the heap (and hence counted toward HeapIdle).\n\tStackInuse uint64\n\n\t// StackSys is bytes of stack memory obtained from the OS.\n\t//\n\t// StackSys is StackInuse, plus any memory obtained directly\n\t// from the OS for OS thread stacks.\n\t//\n\t// In non-cgo programs this metric is currently equal to StackInuse\n\t// (but this should not be relied upon, and the value may change in\n\t// the future).\n\t//\n\t// In cgo programs this metric includes OS thread stacks allocated\n\t// directly from the OS. Currently, this only accounts for one stack in\n\t// c-shared and c-archive build modes and other sources of stacks from\n\t// the OS (notably, any allocated by C code) are not currently measured.\n\t// Note this too may change in the future.\n\tStackSys uint64\n\n\t// MSpanInuse is bytes of allocated mspan structures.\n\tMSpanInuse uint64\n\n\t// MSpanSys is bytes of memory obtained from the OS for mspan\n\t// structures.\n\tMSpanSys uint64\n\n\t// MCacheInuse is bytes of allocated mcache structures.\n\tMCacheInuse uint64\n\n\t// MCacheSys is bytes of memory obtained from the OS for\n\t// mcache structures.\n\tMCacheSys uint64\n\n\t// BuckHashSys is bytes of memory in profiling bucket hash tables.\n\tBuckHashSys uint64\n\n\t// GCSys is bytes of memory in garbage collection metadata.\n\tGCSys uint64\n\n\t// OtherSys is bytes of memory in miscellaneous off-heap\n\t// runtime allocations.\n\tOtherSys uint64\n\n\t// NextGC is the target heap size of the next GC cycle.\n\t//\n\t// The garbage collector's goal is to keep HeapAlloc \u2264 NextGC.\n\t// At the end of each GC cycle, the target for the next cycle\n\t// is computed based on the amount of reachable data and the\n\t// value of GOGC.\n\tNextGC uint64\n\n\t// LastGC is the time the last garbage collection finished, as\n\t// nanoseconds since 1970 (the UNIX epoch).\n\tLastGC uint64\n\n\t// PauseTotalNs is the cumulative nanoseconds in GC\n\t// stop-the-world pauses since the program started.\n\t//\n\t// During a stop-the-world pause, all goroutines are paused\n\t// and only the garbage collector can run.\n\tPauseTotalNs uint64\n\n\t// PauseNs is a circular buffer of recent GC stop-the-world\n\t// pause times in nanoseconds.\n\t//\n\t// The most recent pause is at PauseNs[(NumGC+255)%256]. In\n\t// general, PauseNs[N%256] records the time paused in the most\n\t// recent N%256th GC cycle. There may be multiple pauses per\n\t// GC cycle; this is the sum of all pauses during a cycle.\n\tPauseNs [256]uint64\n\n\t// PauseEnd is a circular buffer of recent GC pause end times,\n\t// as nanoseconds since 1970 (the UNIX epoch).\n\t//\n\t// This buffer is filled the same way as PauseNs. There may be\n\t// multiple pauses per GC cycle; this records the end of the\n\t// last pause in a cycle.\n\tPauseEnd [256]uint64\n\n\t// NumGC is the number of completed GC cycles.\n\tNumGC uint32\n\n\t// NumForcedGC is the number of GC cycles that were forced by\n\t// the application calling the GC function.\n\tNumForcedGC uint32\n\n\t// GCCPUFraction is the fraction of this program's available\n\t// CPU time used by the GC since the program started.\n\t//\n\t// GCCPUFraction is expressed as a number between 0 and 1,\n\t// where 0 means GC has consumed none of this program's CPU. A\n\t// program's available CPU time is defined as the integral of\n\t// GOMAXPROCS since the program started. That is, if\n\t// GOMAXPROCS is 2 and a program has been running for 10\n\t// seconds, its \"available CPU\" is 20 seconds. GCCPUFraction\n\t// does not include CPU time used for write barrier activity.\n\t//\n\t// This is the same as the fraction of CPU reported by\n\t// GODEBUG=gctrace=1.\n\tGCCPUFraction float64\n\n\t// EnableGC indicates that GC is enabled. It is always true,\n\t// even if GOGC=off.\n\tEnableGC bool\n\n\t// DebugGC is currently unused.\n\tDebugGC bool\n\n\t// BySize reports per-size class allocation statistics.\n\t//\n\t// BySize[N] gives statistics for allocations of size S where\n\t// BySize[N-1].Size < S \u2264 BySize[N].Size.\n\t//\n\t// This does not report allocations larger than BySize[60].Size.\n\tBySize [61]struct {\n\t\t// Size is the maximum byte size of an object in this\n\t\t// size class.\n\t\tSize uint32\n\n\t\t// Mallocs is the cumulative count of heap objects\n\t\t// allocated in this size class. The cumulative bytes\n\t\t// of allocation is Size*Mallocs. The number of live\n\t\t// objects in this size class is Mallocs - Frees.\n\t\tMallocs uint64\n\n\t\t// Frees is the cumulative count of heap objects freed\n\t\t// in this size class.\n\t\tFrees uint64\n\t}\n}\n    A MemStats records statistics about the memory allocator.\n\ntype PanicNilError struct {\n\t// Has unexported fields.\n}\n    A PanicNilError happens when code calls panic(nil).\n\n    Before Go 1.21, programs that called panic(nil) observed recover returning\n    nil. Starting in Go 1.21, programs that call panic(nil) observe recover\n    returning a *PanicNilError. Programs can change back to the old behavior by\n    setting GODEBUG=panicnil=1.\n\nfunc (*PanicNilError) Error() string\n\nfunc (*PanicNilError) RuntimeError()\n\ntype Pinner struct {\n\t// Has unexported fields.\n}\n    A Pinner is a set of Go objects each pinned to a fixed location in memory.\n    The Pinner.Pin method pins one object, while Pinner.Unpin unpins all pinned\n    objects. See their comments for more information.\n\nfunc (p *Pinner) Pin(pointer any)\n    Pin pins a Go object, preventing it from being moved or freed by the garbage\n    collector until the Pinner.Unpin method has been called.\n\n    A pointer to a pinned object can be directly stored in C memory or can be\n    contained in Go memory passed to C functions. If the pinned object itself\n    contains pointers to Go objects, these objects must be pinned separately if\n    they are going to be accessed from C code.\n\n    The argument must be a pointer of any type or an unsafe.Pointer. It's safe\n    to call Pin on non-Go pointers, in which case Pin will do nothing.\n\nfunc (p *Pinner) Unpin()\n    Unpin unpins all pinned objects of the Pinner.\n\ntype StackRecord struct {\n\tStack0 [32]uintptr // stack trace for this record; ends at first 0 entry\n}\n    A StackRecord describes a single execution stack.\n\nfunc (r *StackRecord) Stack() []uintptr\n    Stack returns the stack trace associated with the record, a prefix of\n    r.Stack0.\n\ntype TypeAssertionError struct {\n\t// Has unexported fields.\n}\n    A TypeAssertionError explains a failed type assertion.\n\nfunc (e *TypeAssertionError) Error() string\n\nfunc (*TypeAssertionError) RuntimeError()\n\n"}, {"path": "stdlib/compress-bzip2.md", "category": "stdlib", "name": "stdlib/compress-bzip2", "content": "package bzip2 // import \"compress/bzip2\"\n\nPackage bzip2 implements bzip2 decompression.\n\nFUNCTIONS\n\nfunc NewReader(r io.Reader) io.Reader\n    NewReader returns an io.Reader which decompresses bzip2 data from r.\n    If r does not also implement io.ByteReader, the decompressor may read more\n    data than necessary from r.\n\n\nTYPES\n\ntype StructuralError string\n    A StructuralError is returned when the bzip2 data is found to be\n    syntactically invalid.\n\nfunc (s StructuralError) Error() string\n\n"}, {"path": "stdlib/internal-cpu.md", "category": "stdlib", "name": "stdlib/internal-cpu", "content": "package cpu // import \"internal/cpu\"\n\nPackage cpu implements processor feature detection used by the Go standard\nlibrary.\n\nCONSTANTS\n\nconst CacheLinePadSize = 128\n    CacheLinePadSize is used to prevent false sharing of cache lines. We\n    choose 128 because Apple Silicon, a.k.a. M1, has 128-byte cache line size.\n    It doesn't cost much and is much more future-proof.\n\n\nVARIABLES\n\nvar ARM struct {\n\t_            CacheLinePad\n\tHasVFPv4     bool\n\tHasIDIVA     bool\n\tHasV7Atomics bool\n\t_            CacheLinePad\n}\n    The booleans in ARM contain the correspondingly named cpu feature bit.\n    The struct is padded to avoid false sharing.\n\nvar ARM64 struct {\n\t_          CacheLinePad\n\tHasAES     bool\n\tHasPMULL   bool\n\tHasSHA1    bool\n\tHasSHA2    bool\n\tHasSHA512  bool\n\tHasSHA3    bool\n\tHasCRC32   bool\n\tHasATOMICS bool\n\tHasCPUID   bool\n\tHasDIT     bool\n\tIsNeoverse bool\n\t_          CacheLinePad\n}\n    The booleans in ARM64 contain the correspondingly named cpu feature bit.\n    The struct is padded to avoid false sharing.\n\nvar CacheLineSize uintptr = CacheLinePadSize\n    CacheLineSize is the CPU's assumed cache line size. There is currently no\n    runtime detection of the real cache line size so we use the constant per\n    GOARCH CacheLinePadSize as an approximation.\n\nvar DebugOptions bool\n    DebugOptions is set to true by the runtime if the OS supports reading\n    GODEBUG early in runtime startup. This should not be changed after it is\n    initialized.\n\nvar Loong64 struct {\n\t_         CacheLinePad\n\tHasLSX    bool // support 128-bit vector extension\n\tHasLASX   bool // support 256-bit vector extension\n\tHasCRC32  bool // support CRC instruction\n\tHasLAMCAS bool // support AMCAS[_DB].{B/H/W/D}\n\tHasLAM_BH bool // support AM{SWAP/ADD}[_DB].{B/H} instruction\n\t_         CacheLinePad\n}\n    The booleans in Loong64 contain the correspondingly named cpu feature bit.\n    The struct is padded to avoid false sharing.\n\nvar MIPS64X struct {\n\t_      CacheLinePad\n\tHasMSA bool // MIPS SIMD architecture\n\t_      CacheLinePad\n}\nvar PPC64 struct {\n\t_         CacheLinePad\n\tHasDARN   bool // Hardware random number generator (requires kernel enablement)\n\tHasSCV    bool // Syscall vectored (requires kernel enablement)\n\tIsPOWER8  bool // ISA v2.07 (POWER8)\n\tIsPOWER9  bool // ISA v3.00 (POWER9)\n\tIsPOWER10 bool // ISA v3.1  (POWER10)\n\t_         CacheLinePad\n}\n    For ppc64(le), it is safe to check only for ISA level starting on ISA v3.00,\n    since there are no optional categories. There are some exceptions that\n    also require kernel support to work (darn, scv), so there are feature bits\n    for those as well. The minimum processor requirement is POWER8 (ISA 2.07).\n    The struct is padded to avoid false sharing.\n\nvar RISCV64 struct {\n\t_                 CacheLinePad\n\tHasFastMisaligned bool // Fast misaligned accesses\n\tHasV              bool // Vector extension compatible with RVV 1.0\n\tHasZbb            bool // Basic bit-manipulation extension\n\t_                 CacheLinePad\n}\n    RISCV64 contains the supported CPU features and performance characteristics\n    for riscv64 platforms. The booleans in RISCV64, with the exception of\n    HasFastMisaligned, indicate the presence of RISC-V extensions. The struct is\n    padded to avoid false sharing.\n\nvar S390X struct {\n\t_         CacheLinePad\n\tHasZARCH  bool // z architecture mode is active [mandatory]\n\tHasSTFLE  bool // store facility list extended [mandatory]\n\tHasLDISP  bool // long (20-bit) displacements [mandatory]\n\tHasEIMM   bool // 32-bit immediates [mandatory]\n\tHasDFP    bool // decimal floating point\n\tHasETF3EH bool // ETF-3 enhanced\n\tHasMSA    bool // message security assist (CPACF)\n\tHasAES    bool // KM-AES{128,192,256} functions\n\tHasAESCBC bool // KMC-AES{128,192,256} functions\n\tHasAESCTR bool // KMCTR-AES{128,192,256} functions\n\tHasAESGCM bool // KMA-GCM-AES{128,192,256} functions\n\tHasGHASH  bool // KIMD-GHASH function\n\tHasSHA1   bool // K{I,L}MD-SHA-1 functions\n\tHasSHA256 bool // K{I,L}MD-SHA-256 functions\n\tHasSHA512 bool // K{I,L}MD-SHA-512 functions\n\tHasSHA3   bool // K{I,L}MD-SHA3-{224,256,384,512} and K{I,L}MD-SHAKE-{128,256} functions\n\tHasVX     bool // vector facility. Note: the runtime sets this when it processes auxv records.\n\tHasVXE    bool // vector-enhancements facility 1\n\tHasKDSA   bool // elliptic curve functions\n\tHasECDSA  bool // NIST curves\n\tHasEDDSA  bool // Edwards curves\n\t_         CacheLinePad\n}\nvar X86 struct {\n\t_            CacheLinePad\n\tHasAES       bool\n\tHasADX       bool\n\tHasAVX       bool\n\tHasAVX2      bool\n\tHasAVX512F   bool\n\tHasAVX512BW  bool\n\tHasAVX512VL  bool\n\tHasBMI1      bool\n\tHasBMI2      bool\n\tHasERMS      bool\n\tHasFSRM      bool\n\tHasFMA       bool\n\tHasOSXSAVE   bool\n\tHasPCLMULQDQ bool\n\tHasPOPCNT    bool\n\tHasRDTSCP    bool\n\tHasSHA       bool\n\tHasSSE3      bool\n\tHasSSSE3     bool\n\tHasSSE41     bool\n\tHasSSE42     bool\n\t_            CacheLinePad\n}\n    The booleans in X86 contain the correspondingly named cpuid feature bit.\n    HasAVX and HasAVX2 are only set if the OS does support XMM and YMM registers\n    in addition to the cpuid feature bit being set. The struct is padded to\n    avoid false sharing.\n\n\nFUNCTIONS\n\nfunc Initialize(env string)\n    Initialize examines the processor and sets the relevant variables above.\n    This is called by the runtime package early in program initialization,\n    before normal init functions are run. env is set by runtime if the OS\n    supports cpu feature options in GODEBUG.\n\nfunc Name() string\n    Name returns the CPU name given by the vendor if it can be read directly\n    from memory or by CPU instructions. If the CPU name can not be determined an\n    empty string is returned.\n\n    Implementations that use the Operating System (e.g. sysctl or /sys/) to\n    gather CPU information for display should be placed in internal/sysinfo.\n\n\nTYPES\n\ntype CacheLinePad struct {\n\t// Has unexported fields.\n}\n    CacheLinePad is used to pad structs to avoid false sharing.\n\n"}, {"path": "stdlib/internal-bisect.md", "category": "stdlib", "name": "stdlib/internal-bisect", "content": "package bisect // import \"internal/bisect\"\n\nPackage bisect can be used by compilers and other programs to serve as a target\nfor the bisect debugging tool. See golang.org/x/tools/cmd/bisect for details\nabout using the tool.\n\nTo be a bisect target, allowing bisect to help determine which of a set of\nindependent changes provokes a failure, a program needs to:\n\n 1. Define a way to accept a change pattern on its command line or in its\n    environment. The most common mechanism is a command-line flag. The pattern\n    can be passed to New to create a Matcher, the compiled form of a pattern.\n\n 2. Assign each change a unique ID. One possibility is to use a sequence number,\n    but the most common mechanism is to hash some kind of identifying\n    information like the file and line number where the change might be applied.\n    Hash hashes its arguments to compute an ID.\n\n 3. Enable each change that the pattern says should be enabled. The\n    Matcher.ShouldEnable method answers this question for a given change ID.\n\n 4. Print a report identifying each change that the pattern says should be\n    printed. The Matcher.ShouldPrint method answers this question for a given\n    change ID. The report consists of one more lines on standard error or\n    standard output that contain a \u201cmatch marker\u201d. Marker returns the match\n    marker for a given ID. When bisect reports a change as causing the failure,\n    it identifies the change by printing the report lines with the match marker\n    removed.\n\n# Example Usage\n\nA program starts by defining how it receives the pattern. In this example,\nwe will assume a flag. The next step is to compile the pattern:\n\n    m, err := bisect.New(patternFlag)\n    if err != nil {\n    \tlog.Fatal(err)\n    }\n\nThen, each time a potential change is considered, the program computes a change\nID by hashing identifying information (source file and line, in this case)\nand then calls m.ShouldPrint and m.ShouldEnable to decide whether to print and\nenable the change, respectively. The two can return different values depending\non whether bisect is trying to find a minimal set of changes to disable or to\nenable to provoke the failure.\n\nIt is usually helpful to write a helper function that accepts the identifying\ninformation and then takes care of hashing, printing, and reporting whether\nthe identified change should be enabled. For example, a helper for changes\nidentified by a file and line number would be:\n\n    func ShouldEnable(file string, line int) {\n    \th := bisect.Hash(file, line)\n    \tif m.ShouldPrint(h) {\n    \t\tfmt.Fprintf(os.Stderr, \"%v %s:%d\\n\", bisect.Marker(h), file, line)\n    \t}\n    \treturn m.ShouldEnable(h)\n    }\n\nFinally, note that New returns a nil Matcher when there is no pattern, meaning\nthat the target is not running under bisect at all, so all changes should be\nenabled and none should be printed. In that common case, the computation of the\nhash can be avoided entirely by checking for m == nil first:\n\n    func ShouldEnable(file string, line int) bool {\n    \tif m == nil {\n    \t\treturn true\n    \t}\n    \th := bisect.Hash(file, line)\n    \tif m.ShouldPrint(h) {\n    \t\tfmt.Fprintf(os.Stderr, \"%v %s:%d\\n\", bisect.Marker(h), file, line)\n    \t}\n    \treturn m.ShouldEnable(h)\n    }\n\nWhen the identifying information is expensive to format, this code can call\nMatcher.MarkerOnly to find out whether short report lines containing only the\nmarker are permitted for a given run. (Bisect permits such lines when it is\nstill exploring the space of possible changes and will not be showing the output\nto the user.) If so, the client can choose to print only the marker:\n\n    func ShouldEnable(file string, line int) bool {\n    \tif m == nil {\n    \t\treturn true\n    \t}\n    \th := bisect.Hash(file, line)\n    \tif m.ShouldPrint(h) {\n    \t\tif m.MarkerOnly() {\n    \t\t\tbisect.PrintMarker(os.Stderr, h)\n    \t\t} else {\n    \t\t\tfmt.Fprintf(os.Stderr, \"%v %s:%d\\n\", bisect.Marker(h), file, line)\n    \t\t}\n    \t}\n    \treturn m.ShouldEnable(h)\n    }\n\nThis specific helper \u2013 deciding whether to enable a change identified by file\nand line number and printing about the change when necessary \u2013 is provided by\nthe Matcher.FileLine method.\n\nAnother common usage is deciding whether to make a change in a function based\non the caller's stack, to identify the specific calling contexts that the change\nbreaks. The Matcher.Stack method takes care of obtaining the stack, printing it\nwhen necessary, and reporting whether to enable the change based on that stack.\n\n# Pattern Syntax\n\nPatterns are generated by the bisect tool and interpreted by New. Users should\nnot have to understand the patterns except when debugging a target's bisect\nsupport or debugging the bisect tool itself.\n\nThe pattern syntax selecting a change is a sequence of bit strings separated by\n+ and - operators. Each bit string denotes the set of changes with IDs ending\nin those bits, + is set addition, - is set subtraction, and the expression\nis evaluated in the usual left-to-right order. The special binary number\n\u201cy\u201d denotes the set of all changes, standing in for the empty bit string.\nIn the expression, all the + operators must appear before all the - operators.\nA leading + adds to an empty set. A leading - subtracts from the set of all\npossible suffixes.\n\nFor example:\n\n  - \u201c01+10\u201d and \u201c+01+10\u201d both denote the set of changes with IDs ending with the\n    bits 01 or 10.\n\n  - \u201c01+10-1001\u201d denotes the set of changes with IDs ending with the bits 01 or\n    10, but excluding those ending in 1001.\n\n  - \u201c-01-1000\u201d and \u201cy-01-1000 both denote the set of all changes with IDs not\n    ending in 01 nor 1000.\n\n  - \u201c0+1-01+001\u201d is not a valid pattern, because all the + operators do not\n    appear before all the - operators.\n\nIn the syntaxes described so far, the pattern specifies the changes to enable\nand report. If a pattern is prefixed by a \u201c!\u201d, the meaning changes: the pattern\nspecifies the changes to DISABLE and report. This mode of operation is needed\nwhen a program passes with all changes enabled but fails with no changes\nenabled. In this case, bisect searches for minimal sets of changes to disable.\nPut another way, the leading \u201c!\u201d inverts the result from Matcher.ShouldEnable\nbut does not invert the result from Matcher.ShouldPrint.\n\nAs a convenience for manual debugging, \u201cn\u201d is an alias for \u201c!y\u201d, meaning to\ndisable and report all changes.\n\nFinally, a leading \u201cv\u201d in the pattern indicates that the reports will be\nshown to the user of bisect to describe the changes involved in a failure.\nAt the API level, the leading \u201cv\u201d causes [Matcher.Visible] to return true.\nSee the next section for details.\n\n# Match Reports\n\nThe target program must enable only those changed matched by the pattern,\nand it must print a match report for each such change. A match report consists\nof one or more lines of text that will be printed by the bisect tool to describe\na change implicated in causing a failure. Each line in the report for a given\nchange must contain a match marker with that change ID, as returned by Marker.\nThe markers are elided when displaying the lines to the user.\n\nA match marker has the form \u201c[bisect-match 0x1234]\u201d where 0x1234 is the change\nID in hexadecimal. An alternate form is \u201c[bisect-match 010101]\u201d, giving the\nchange ID in binary.\n\nWhen [Matcher.Visible] returns false, the match reports are only being\nprocessed by bisect to learn the set of enabled changes, not shown to the user,\nmeaning that each report can be a match marker on a line by itself, eliding the\nusual textual description. When the textual description is expensive to compute,\nchecking [Matcher.Visible] can help the avoid that expense in most runs.\n\nFUNCTIONS\n\nfunc AppendMarker(dst []byte, id uint64) []byte\n    AppendMarker is like Marker but appends the marker to dst.\n\nfunc CutMarker(line string) (short string, id uint64, ok bool)\n    CutMarker finds the first match marker in line and removes it, returning\n    the shortened line (with the marker removed), the ID from the match marker,\n    and whether a marker was found at all. If there is no marker, CutMarker\n    returns line, 0, false.\n\nfunc Hash(data ...any) uint64\n    Hash computes a hash of the data arguments, each of which must be of type\n    string, byte, int, uint, int32, uint32, int64, uint64, uintptr, or a slice\n    of one of those types.\n\nfunc Marker(id uint64) string\n    Marker returns the match marker text to use on any line reporting details\n    about a match of the given ID. It always returns the hexadecimal format.\n\nfunc PrintMarker(w Writer, h uint64) error\n    PrintMarker prints to w a one-line report containing only the marker for h.\n    It is appropriate to use when Matcher.ShouldPrint and Matcher.MarkerOnly\n    both return true.\n\n\nTYPES\n\ntype Matcher struct {\n\t// Has unexported fields.\n}\n    A Matcher is the parsed, compiled form of a PATTERN string. The nil *Matcher\n    is valid: it has all changes enabled but none reported.\n\nfunc New(pattern string) (*Matcher, error)\n    New creates and returns a new Matcher implementing the given pattern.\n    The pattern syntax is defined in the package doc comment.\n\n    In addition to the pattern syntax syntax, New(\"\") returns nil, nil.\n    The nil *Matcher is valid for use: it returns true from ShouldEnable and\n    false from ShouldPrint for all changes. Callers can avoid calling Hash,\n    Matcher.ShouldEnable, and Matcher.ShouldPrint entirely when they recognize\n    the nil Matcher.\n\nfunc (m *Matcher) FileLine(w Writer, file string, line int) bool\n    FileLine reports whether the change identified by file and line should be\n    enabled. If the change should be printed, FileLine prints a one-line report\n    to w.\n\nfunc (m *Matcher) MarkerOnly() bool\n    MarkerOnly reports whether it is okay to print only the marker for a given\n    change, omitting the identifying information. MarkerOnly returns true when\n    bisect is using the printed reports only for an intermediate search step,\n    not for showing to users.\n\nfunc (m *Matcher) ShouldEnable(id uint64) bool\n    ShouldEnable reports whether the change with the given id should be enabled.\n\nfunc (m *Matcher) ShouldPrint(id uint64) bool\n    ShouldPrint reports whether to print identifying information about the\n    change with the given id.\n\nfunc (m *Matcher) Stack(w Writer) bool\n    MatchStack assigns the current call stack a change ID. If the stack should\n    be printed, MatchStack prints it. Then MatchStack reports whether a change\n    at the current call stack should be enabled.\n\ntype Writer interface {\n\tWrite([]byte) (int, error)\n}\n    Writer is the same interface as io.Writer. It is duplicated here to avoid\n    importing io.\n\n"}, {"path": "stdlib/internal-dag.md", "category": "stdlib", "name": "stdlib/internal-dag", "content": "package dag // import \"internal/dag\"\n\nPackage dag implements a language for expressing directed acyclic graphs.\n\nThe general syntax of a rule is:\n\n    a, b < c, d;\n\nwhich means c and d come after a and b in the partial order (that is, there are\nedges from c and d to a and b), but doesn't provide a relative order between a\nvs b or c vs d.\n\nThe rules can chain together, as in:\n\n    e < f, g < h;\n\nwhich is equivalent to\n\n    e < f, g;\n    f, g < h;\n\nExcept for the special bottom element \"NONE\", each name must appear exactly once\non the right-hand side of any rule. That rule serves as the definition of the\nallowed successor for that name. The definition must appear before any uses of\nthe name on the left-hand side of a rule. (That is, the rules themselves must be\nordered according to the partial order, for easier reading by people.)\n\nNegative assertions double-check the partial order:\n\n    i !< j\n\nmeans that it must NOT be the case that i < j. Negative assertions may appear\nanywhere in the rules, even before i and j have been defined.\n\nComments begin with #.\n\nTYPES\n\ntype Graph struct {\n\tNodes []string\n\n\t// Has unexported fields.\n}\n\nfunc Parse(dag string) (*Graph, error)\n    Parse parses the DAG language and returns the transitive closure of the\n    described graph. In the returned graph, there is an edge from \"b\" to \"a\" if\n    b < a (or a > b) in the partial order.\n\nfunc (g *Graph) AddEdge(from, to string)\n\nfunc (g *Graph) DelEdge(from, to string)\n\nfunc (g *Graph) Edges(from string) []string\n\nfunc (g *Graph) HasEdge(from, to string) bool\n\nfunc (g *Graph) Topo() []string\n    Topo returns a topological sort of g. This function is deterministic.\n\nfunc (g *Graph) TransitiveReduction()\n    TransitiveReduction removes edges from g that are transitively reachable.\n    g must be transitively closed.\n\nfunc (g *Graph) Transpose()\n    Transpose reverses all edges in g.\n\n"}, {"path": "stdlib/debug-buildinfo.md", "category": "stdlib", "name": "stdlib/debug-buildinfo", "content": "package buildinfo // import \"debug/buildinfo\"\n\nPackage buildinfo provides access to information embedded in a Go binary about\nhow it was built. This includes the Go toolchain version, and the set of modules\nused (for binaries built in module mode).\n\nBuild information is available for the currently running binary in\nruntime/debug.ReadBuildInfo.\n\nTYPES\n\ntype BuildInfo = debug.BuildInfo\n    Type alias for build info. We cannot move the types here, since\n    runtime/debug would need to import this package, which would make it a much\n    larger dependency.\n\nfunc Read(r io.ReaderAt) (*BuildInfo, error)\n    Read returns build information embedded in a Go binary file accessed through\n    the given ReaderAt. Most information is only available for binaries built\n    with module support.\n\nfunc ReadFile(name string) (info *BuildInfo, err error)\n    ReadFile returns build information embedded in a Go binary file at the given\n    path. Most information is only available for binaries built with module\n    support.\n\n"}, {"path": "stdlib/math-rand.md", "category": "stdlib", "name": "stdlib/math-rand", "content": "package rand // import \"math/rand\"\n\nPackage rand implements pseudo-random number generators suitable for tasks such\nas simulation, but it should not be used for security-sensitive work.\n\nRandom numbers are generated by a Source, usually wrapped in a Rand. Both\ntypes should be used by a single goroutine at a time: sharing among multiple\ngoroutines requires some kind of synchronization.\n\nTop-level functions, such as Float64 and Int, are safe for concurrent use by\nmultiple goroutines.\n\nThis package's outputs might be easily predictable regardless of how it's\nseeded. For random numbers suitable for security-sensitive work, see the\ncrypto/rand package.\n\nFUNCTIONS\n\nfunc ExpFloat64() float64\n    ExpFloat64 returns an exponentially distributed float64 in the range (0,\n    +[math.MaxFloat64]] with an exponential distribution whose rate parameter\n    (lambda) is 1 and whose mean is 1/lambda (1) from the default Source. To\n    produce a distribution with a different rate parameter, callers can adjust\n    the output using:\n\n        sample = ExpFloat64() / desiredRateParameter\n\nfunc Float32() float32\n    Float32 returns, as a float32, a pseudo-random number in the half-open\n    interval [0.0,1.0) from the default Source.\n\nfunc Float64() float64\n    Float64 returns, as a float64, a pseudo-random number in the half-open\n    interval [0.0,1.0) from the default Source.\n\nfunc Int() int\n    Int returns a non-negative pseudo-random int from the default Source.\n\nfunc Int31() int32\n    Int31 returns a non-negative pseudo-random 31-bit integer as an int32 from\n    the default Source.\n\nfunc Int31n(n int32) int32\n    Int31n returns, as an int32, a non-negative pseudo-random number in the\n    half-open interval [0,n) from the default Source. It panics if n <= 0.\n\nfunc Int63() int64\n    Int63 returns a non-negative pseudo-random 63-bit integer as an int64 from\n    the default Source.\n\nfunc Int63n(n int64) int64\n    Int63n returns, as an int64, a non-negative pseudo-random number in the\n    half-open interval [0,n) from the default Source. It panics if n <= 0.\n\nfunc Intn(n int) int\n    Intn returns, as an int, a non-negative pseudo-random number in the\n    half-open interval [0,n) from the default Source. It panics if n <= 0.\n\nfunc NormFloat64() float64\n    NormFloat64 returns a normally distributed float64 in the range\n    [-math.MaxFloat64, +[math.MaxFloat64]] with standard normal distribution\n    (mean = 0, stddev = 1) from the default Source. To produce a different\n    normal distribution, callers can adjust the output using:\n\n        sample = NormFloat64() * desiredStdDev + desiredMean\n\nfunc Perm(n int) []int\n    Perm returns, as a slice of n ints, a pseudo-random permutation of the\n    integers in the half-open interval [0,n) from the default Source.\n\nfunc Read(p []byte) (n int, err error)\n    Read generates len(p) random bytes from the default Source and writes them\n    into p. It always returns len(p) and a nil error. Read, unlike the Rand.Read\n    method, is safe for concurrent use.\n\n    Deprecated: For almost all use cases, crypto/rand.Read is more appropriate.\n    If a deterministic source is required, use math/rand/v2.ChaCha8.Read.\n\nfunc Seed(seed int64)\n    Seed uses the provided seed value to initialize the default Source to a\n    deterministic state. Seed values that have the same remainder when divided\n    by 2\u00b3\u00b9-1 generate the same pseudo-random sequence. Seed, unlike the\n    Rand.Seed method, is safe for concurrent use.\n\n    If Seed is not called, the generator is seeded randomly at program startup.\n\n    Prior to Go 1.20, the generator was seeded like Seed(1) at program startup.\n    To force the old behavior, call Seed(1) at program startup. Alternately,\n    set GODEBUG=randautoseed=0 in the environment before making any calls to\n    functions in this package.\n\n    Deprecated: As of Go 1.20 there is no reason to call Seed with a random\n    value. Programs that call Seed with a known value to get a specific\n    sequence of results should use New(NewSource(seed)) to obtain a local random\n    generator.\n\n    As of Go 1.24 Seed is a no-op. To restore the previous behavior set\n    GODEBUG=randseednop=0.\n\nfunc Shuffle(n int, swap func(i, j int))\n    Shuffle pseudo-randomizes the order of elements using the default Source. n\n    is the number of elements. Shuffle panics if n < 0. swap swaps the elements\n    with indexes i and j.\n\nfunc Uint32() uint32\n    Uint32 returns a pseudo-random 32-bit value as a uint32 from the default\n    Source.\n\nfunc Uint64() uint64\n    Uint64 returns a pseudo-random 64-bit value as a uint64 from the default\n    Source.\n\n\nTYPES\n\ntype Rand struct {\n\t// Has unexported fields.\n}\n    A Rand is a source of random numbers.\n\nfunc New(src Source) *Rand\n    New returns a new Rand that uses random values from src to generate other\n    random values.\n\nfunc (r *Rand) ExpFloat64() float64\n    ExpFloat64 returns an exponentially distributed float64 in the range (0,\n    +[math.MaxFloat64]] with an exponential distribution whose rate parameter\n    (lambda) is 1 and whose mean is 1/lambda (1). To produce a distribution with\n    a different rate parameter, callers can adjust the output using:\n\n        sample = ExpFloat64() / desiredRateParameter\n\nfunc (r *Rand) Float32() float32\n    Float32 returns, as a float32, a pseudo-random number in the half-open\n    interval [0.0,1.0).\n\nfunc (r *Rand) Float64() float64\n    Float64 returns, as a float64, a pseudo-random number in the half-open\n    interval [0.0,1.0).\n\nfunc (r *Rand) Int() int\n    Int returns a non-negative pseudo-random int.\n\nfunc (r *Rand) Int31() int32\n    Int31 returns a non-negative pseudo-random 31-bit integer as an int32.\n\nfunc (r *Rand) Int31n(n int32) int32\n    Int31n returns, as an int32, a non-negative pseudo-random number in the\n    half-open interval [0,n). It panics if n <= 0.\n\nfunc (r *Rand) Int63() int64\n    Int63 returns a non-negative pseudo-random 63-bit integer as an int64.\n\nfunc (r *Rand) Int63n(n int64) int64\n    Int63n returns, as an int64, a non-negative pseudo-random number in the\n    half-open interval [0,n). It panics if n <= 0.\n\nfunc (r *Rand) Intn(n int) int\n    Intn returns, as an int, a non-negative pseudo-random number in the\n    half-open interval [0,n). It panics if n <= 0.\n\nfunc (r *Rand) NormFloat64() float64\n    NormFloat64 returns a normally distributed float64 in the range\n    -math.MaxFloat64 through +[math.MaxFloat64] inclusive, with standard\n    normal distribution (mean = 0, stddev = 1). To produce a different normal\n    distribution, callers can adjust the output using:\n\n        sample = NormFloat64() * desiredStdDev + desiredMean\n\nfunc (r *Rand) Perm(n int) []int\n    Perm returns, as a slice of n ints, a pseudo-random permutation of the\n    integers in the half-open interval [0,n).\n\nfunc (r *Rand) Read(p []byte) (n int, err error)\n    Read generates len(p) random bytes and writes them into p. It always returns\n    len(p) and a nil error. Read should not be called concurrently with any\n    other Rand method.\n\nfunc (r *Rand) Seed(seed int64)\n    Seed uses the provided seed value to initialize the generator to a\n    deterministic state. Seed should not be called concurrently with any other\n    Rand method.\n\nfunc (r *Rand) Shuffle(n int, swap func(i, j int))\n    Shuffle pseudo-randomizes the order of elements. n is the number of\n    elements. Shuffle panics if n < 0. swap swaps the elements with indexes i\n    and j.\n\nfunc (r *Rand) Uint32() uint32\n    Uint32 returns a pseudo-random 32-bit value as a uint32.\n\nfunc (r *Rand) Uint64() uint64\n    Uint64 returns a pseudo-random 64-bit value as a uint64.\n\ntype Source interface {\n\tInt63() int64\n\tSeed(seed int64)\n}\n    A Source represents a source of uniformly-distributed pseudo-random int64\n    values in the range [0, 1<<63).\n\n    A Source is not safe for concurrent use by multiple goroutines.\n\nfunc NewSource(seed int64) Source\n    NewSource returns a new pseudo-random Source seeded with the given value.\n    Unlike the default Source used by top-level functions, this source is\n    not safe for concurrent use by multiple goroutines. The returned Source\n    implements Source64.\n\ntype Source64 interface {\n\tSource\n\tUint64() uint64\n}\n    A Source64 is a Source that can also generate uniformly-distributed\n    pseudo-random uint64 values in the range [0, 1<<64) directly. If a Rand r's\n    underlying Source s implements Source64, then r.Uint64 returns the result of\n    one call to s.Uint64 instead of making two calls to s.Int63.\n\ntype Zipf struct {\n\t// Has unexported fields.\n}\n    A Zipf generates Zipf distributed variates.\n\nfunc NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf\n    NewZipf returns a Zipf variate generator. The generator generates values k \u2208\n    [0, imax] such that P(k) is proportional to (v + k) ** (-s). Requirements:\n    s > 1 and v >= 1.\n\nfunc (z *Zipf) Uint64() uint64\n    Uint64 returns a value drawn from the Zipf distribution described by the\n    Zipf object.\n\n"}, {"path": "stdlib/crypto-internal-fips140-subtle.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-subtle", "content": "package subtle // import \"crypto/internal/fips140/subtle\"\n\n\nFUNCTIONS\n\nfunc ConstantTimeByteEq(x, y uint8) int\n    ConstantTimeByteEq returns 1 if x == y and 0 otherwise.\n\nfunc ConstantTimeCompare(x, y []byte) int\n    ConstantTimeCompare returns 1 if the two slices, x and y, have equal\n    contents and 0 otherwise. The time taken is a function of the length of the\n    slices and is independent of the contents. If the lengths of x and y do not\n    match it returns 0 immediately.\n\nfunc ConstantTimeCopy(v int, x, y []byte)\n    ConstantTimeCopy copies the contents of y into x (a slice of equal length)\n    if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v\n    takes any other value.\n\nfunc ConstantTimeEq(x, y int32) int\n    ConstantTimeEq returns 1 if x == y and 0 otherwise.\n\nfunc ConstantTimeLessOrEq(x, y int) int\n    ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise. Its behavior is\n    undefined if x or y are negative or > 2**31 - 1.\n\nfunc ConstantTimeLessOrEqBytes(x, y []byte) int\n    ConstantTimeLessOrEqBytes returns 1 if x <= y and 0 otherwise. The\n    comparison is lexigraphical, or big-endian. The time taken is a function of\n    the length of the slices and is independent of the contents. If the lengths\n    of x and y do not match it returns 0 immediately.\n\nfunc ConstantTimeSelect(v, x, y int) int\n    ConstantTimeSelect returns x if v == 1 and y if v == 0. Its behavior is\n    undefined if v takes any other value.\n\nfunc XORBytes(dst, x, y []byte) int\n    XORBytes sets dst[i] = x[i] ^ y[i] for all i < n = min(len(x), len(y)),\n    returning n, the number of bytes written to dst.\n\n    If dst does not have length at least n, XORBytes panics without writing\n    anything to dst.\n\n    dst and x or y may overlap exactly or not at all, otherwise XORBytes may\n    panic.\n\n"}, {"path": "stdlib/crypto-x509-internal-macos.md", "category": "stdlib", "name": "stdlib/crypto-x509-internal-macos", "content": "package macOS // import \"crypto/x509/internal/macos\"\n\nPackage macOS provides cgo-less wrappers for Core Foundation and\nSecurity.framework, similarly to how package syscall provides access to\nlibSystem.dylib.\n\nCONSTANTS\n\nconst (\n\t// various macOS error codes that can be returned from\n\t// SecTrustEvaluateWithError that we can map to Go cert\n\t// verification error types.\n\tErrSecCertificateExpired = -67818\n\tErrSecHostNameMismatch   = -67602\n\tErrSecNotTrusted         = -67843\n)\n\nFUNCTIONS\n\nfunc CFArrayAppendValue(array CFRef, val CFRef)\nfunc CFArrayGetCount(array CFRef) int\nfunc CFDataGetBytePtr(data CFRef) uintptr\nfunc CFDataGetLength(data CFRef) int\nfunc CFDataToSlice(data CFRef) []byte\n    CFDataToSlice returns a copy of the contents of data as a bytes slice.\n\nfunc CFEqual(a, b CFRef) bool\nfunc CFErrorGetCode(errRef CFRef) int\nfunc CFNumberGetValue(num CFRef) (int32, error)\nfunc CFRelease(ref CFRef)\nfunc CFStringToString(ref CFRef) string\n    CFStringToString returns a Go string representation of the passed in\n    CFString, or an empty string if it's invalid.\n\nfunc ReleaseCFArray(array CFRef)\n    ReleaseCFArray iterates through an array, releasing its contents, and then\n    releases the array itself. This is necessary because we cannot, easily,\n    set the CFArrayCallBacks argument when creating CFArrays.\n\nfunc SecCertificateCopyData(cert CFRef) ([]byte, error)\nfunc SecTrustEvaluateWithError(trustObj CFRef) (int, error)\nfunc SecTrustSetVerifyDate(trustObj CFRef, dateRef CFRef) error\n\nTYPES\n\ntype CFRef uintptr\n    CFRef is an opaque reference to a Core Foundation object. It is a pointer,\n    but to memory not owned by Go, so not an unsafe.Pointer.\n\nfunc BytesToCFData(b []byte) CFRef\n\nfunc CFArrayCreateMutable() CFRef\n\nfunc CFArrayGetValueAtIndex(array CFRef, index int) CFRef\n\nfunc CFDateCreate(seconds float64) CFRef\n\nfunc CFDictionaryGetValueIfPresent(dict CFRef, key CFString) (value CFRef, ok bool)\n\nfunc CFErrorCopyDescription(errRef CFRef) CFRef\n\nfunc CFStringCreateExternalRepresentation(strRef CFRef) (CFRef, error)\n\nfunc SecCertificateCreateWithData(b []byte) (CFRef, error)\n\nfunc SecPolicyCreateSSL(name string) (CFRef, error)\n\nfunc SecTrustCopyCertificateChain(trustObj CFRef) (CFRef, error)\n\nfunc SecTrustCreateWithCertificates(certs CFRef, policies CFRef) (CFRef, error)\n\nfunc SecTrustEvaluate(trustObj CFRef) (CFRef, error)\n\nfunc TimeToCFDateRef(t time.Time) CFRef\n    TimeToCFDateRef converts a time.Time into an apple CFDateRef.\n\ntype CFString CFRef\n\nfunc StringToCFString(s string) CFString\n    StringToCFString returns a copy of the UTF-8 contents of s as a new\n    CFString.\n\ntype OSStatus struct {\n\t// Has unexported fields.\n}\n\nfunc (s OSStatus) Error() string\n\n"}, {"path": "stdlib/crypto-internal-fips140test.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140test", "content": ""}, {"path": "stdlib/internal-xcoff.md", "category": "stdlib", "name": "stdlib/internal-xcoff", "content": "package xcoff // import \"internal/xcoff\"\n\nPackage xcoff implements access to XCOFF (Extended Common Object File Format)\nfiles.\n\nCONSTANTS\n\nconst (\n\tSAIAMAG   = 0x8\n\tAIAFMAG   = \"`\\n\"\n\tAIAMAG    = \"<aiaff>\\n\"\n\tAIAMAGBIG = \"<bigaf>\\n\"\n\n\t// Sizeof\n\tFL_HSZ_BIG = 0x80\n\tAR_HSZ_BIG = 0x70\n)\nconst (\n\tFILHSZ_32 = 20\n\tFILHSZ_64 = 24\n)\nconst (\n\tU802TOCMAGIC = 0737 // AIX 32-bit XCOFF\n\tU64_TOCMAGIC = 0767 // AIX 64-bit XCOFF\n)\nconst (\n\tF_RELFLG    = 0x0001\n\tF_EXEC      = 0x0002\n\tF_LNNO      = 0x0004\n\tF_FDPR_PROF = 0x0010\n\tF_FDPR_OPTI = 0x0020\n\tF_DSA       = 0x0040\n\tF_VARPG     = 0x0100\n\tF_DYNLOAD   = 0x1000\n\tF_SHROBJ    = 0x2000\n\tF_LOADONLY  = 0x4000\n)\n    Flags that describe the type of the object file.\n\nconst (\n\tSTYP_DWARF  = 0x0010\n\tSTYP_TEXT   = 0x0020\n\tSTYP_DATA   = 0x0040\n\tSTYP_BSS    = 0x0080\n\tSTYP_EXCEPT = 0x0100\n\tSTYP_INFO   = 0x0200\n\tSTYP_TDATA  = 0x0400\n\tSTYP_TBSS   = 0x0800\n\tSTYP_LOADER = 0x1000\n\tSTYP_DEBUG  = 0x2000\n\tSTYP_TYPCHK = 0x4000\n\tSTYP_OVRFLO = 0x8000\n)\n    Flags defining the section type.\n\nconst (\n\tSSUBTYP_DWINFO  = 0x10000 // DWARF info section\n\tSSUBTYP_DWLINE  = 0x20000 // DWARF line-number section\n\tSSUBTYP_DWPBNMS = 0x30000 // DWARF public names section\n\tSSUBTYP_DWPBTYP = 0x40000 // DWARF public types section\n\tSSUBTYP_DWARNGE = 0x50000 // DWARF aranges section\n\tSSUBTYP_DWABREV = 0x60000 // DWARF abbreviation section\n\tSSUBTYP_DWSTR   = 0x70000 // DWARF strings section\n\tSSUBTYP_DWRNGES = 0x80000 // DWARF ranges section\n\tSSUBTYP_DWLOC   = 0x90000 // DWARF location lists section\n\tSSUBTYP_DWFRAME = 0xA0000 // DWARF frames section\n\tSSUBTYP_DWMAC   = 0xB0000 // DWARF macros section\n)\nconst (\n\t// Nscnum\n\tN_DEBUG = -2\n\tN_ABS   = -1\n\tN_UNDEF = 0\n\n\t//Ntype\n\tSYM_V_INTERNAL  = 0x1000\n\tSYM_V_HIDDEN    = 0x2000\n\tSYM_V_PROTECTED = 0x3000\n\tSYM_V_EXPORTED  = 0x4000\n\tSYM_TYPE_FUNC   = 0x0020 // is function\n)\nconst (\n\tC_NULL    = 0   // Symbol table entry marked for deletion\n\tC_EXT     = 2   // External symbol\n\tC_STAT    = 3   // Static symbol\n\tC_BLOCK   = 100 // Beginning or end of inner block\n\tC_FCN     = 101 // Beginning or end of function\n\tC_FILE    = 103 // Source file name and compiler information\n\tC_HIDEXT  = 107 // Unnamed external symbol\n\tC_BINCL   = 108 // Beginning of include file\n\tC_EINCL   = 109 // End of include file\n\tC_WEAKEXT = 111 // Weak external symbol\n\tC_DWARF   = 112 // DWARF symbol\n\tC_GSYM    = 128 // Global variable\n\tC_LSYM    = 129 // Automatic variable allocated on stack\n\tC_PSYM    = 130 // Argument to subroutine allocated on stack\n\tC_RSYM    = 131 // Register variable\n\tC_RPSYM   = 132 // Argument to function or procedure stored in register\n\tC_STSYM   = 133 // Statically allocated symbol\n\tC_BCOMM   = 135 // Beginning of common block\n\tC_ECOML   = 136 // Local member of common block\n\tC_ECOMM   = 137 // End of common block\n\tC_DECL    = 140 // Declaration of object\n\tC_ENTRY   = 141 // Alternate entry\n\tC_FUN     = 142 // Function or procedure\n\tC_BSTAT   = 143 // Beginning of static block\n\tC_ESTAT   = 144 // End of static block\n\tC_GTLS    = 145 // Global thread-local variable\n\tC_STTLS   = 146 // Static thread-local variable\n)\n    Storage Class.\n\nconst (\n\tXTY_ER = 0 // External reference\n\tXTY_SD = 1 // Section definition\n\tXTY_LD = 2 // Label definition\n\tXTY_CM = 3 // Common csect definition\n)\n    Symbol type field.\n\nconst (\n\tXFT_FN = 0   // Source File Name\n\tXFT_CT = 1   // Compile Time Stamp\n\tXFT_CV = 2   // Compiler Version Number\n\tXFT_CD = 128 // Compiler Defined Information\n)\n    Defines for File auxiliary definitions: x_ftype field of x_file\n\nconst (\n\tXMC_PR     = 0  // Program code\n\tXMC_RO     = 1  // Read-only constant\n\tXMC_DB     = 2  // Debug dictionary table\n\tXMC_TC     = 3  // TOC entry\n\tXMC_UA     = 4  // Unclassified\n\tXMC_RW     = 5  // Read/Write data\n\tXMC_GL     = 6  // Global linkage\n\tXMC_XO     = 7  // Extended operation\n\tXMC_SV     = 8  // 32-bit supervisor call descriptor\n\tXMC_BS     = 9  // BSS class\n\tXMC_DS     = 10 // Function descriptor\n\tXMC_UC     = 11 // Unnamed FORTRAN common\n\tXMC_TC0    = 15 // TOC anchor\n\tXMC_TD     = 16 // Scalar data entry in the TOC\n\tXMC_SV64   = 17 // 64-bit supervisor call descriptor\n\tXMC_SV3264 = 18 // Supervisor call descriptor for both 32-bit and 64-bit\n\tXMC_TL     = 20 // Read/Write thread-local data\n\tXMC_UL     = 21 // Read/Write thread-local data (.tbss)\n\tXMC_TE     = 22 // TOC entry\n)\n    Storage-mapping class.\n\nconst (\n\tLDHDRSZ_32 = 32\n\tLDHDRSZ_64 = 56\n)\nconst (\n\tR_POS = 0x00 // A(sym) Positive Relocation\n\tR_NEG = 0x01 // -A(sym) Negative Relocation\n\tR_REL = 0x02 // A(sym-*) Relative to self\n\tR_TOC = 0x03 // A(sym-TOC) Relative to TOC\n\tR_TRL = 0x12 // A(sym-TOC) TOC Relative indirect load.\n\n\tR_TRLA = 0x13 // A(sym-TOC) TOC Rel load address. modifiable inst\n\tR_GL   = 0x05 // A(external TOC of sym) Global Linkage\n\tR_TCL  = 0x06 // A(local TOC of sym) Local object TOC address\n\tR_RL   = 0x0C // A(sym) Pos indirect load. modifiable instruction\n\tR_RLA  = 0x0D // A(sym) Pos Load Address. modifiable instruction\n\tR_REF  = 0x0F // AL0(sym) Non relocating ref. No garbage collect\n\tR_BA   = 0x08 // A(sym) Branch absolute. Cannot modify instruction\n\tR_RBA  = 0x18 // A(sym) Branch absolute. modifiable instruction\n\tR_BR   = 0x0A // A(sym-*) Branch rel to self. non modifiable\n\tR_RBR  = 0x1A // A(sym-*) Branch rel to self. modifiable instr\n\n\tR_TLS    = 0x20 // General-dynamic reference to TLS symbol\n\tR_TLS_IE = 0x21 // Initial-exec reference to TLS symbol\n\tR_TLS_LD = 0x22 // Local-dynamic reference to TLS symbol\n\tR_TLS_LE = 0x23 // Local-exec reference to TLS symbol\n\tR_TLSM   = 0x24 // Module reference to TLS symbol\n\tR_TLSML  = 0x25 // Module reference to local (own) module\n\n\tR_TOCU = 0x30 // Relative to TOC - high order bits\n\tR_TOCL = 0x31 // Relative to TOC - low order bits\n)\nconst SYMESZ = 18\n\nTYPES\n\ntype Archive struct {\n\tArchiveHeader\n\tMembers []*Member\n\n\t// Has unexported fields.\n}\n    Archive represents an open AIX big archive.\n\nfunc NewArchive(r io.ReaderAt) (*Archive, error)\n    NewArchive creates a new Archive for accessing an AIX big archive in an\n    underlying reader.\n\nfunc OpenArchive(name string) (*Archive, error)\n    OpenArchive opens the named archive using os.Open and prepares it for use as\n    an AIX big archive.\n\nfunc (a *Archive) Close() error\n    Close closes the Archive. If the Archive was created using NewArchive\n    directly instead of OpenArchive, Close has no effect.\n\nfunc (arch *Archive) GetFile(name string) (*File, error)\n    GetFile returns the XCOFF file defined by member name. FIXME: This doesn't\n    work if an archive has two members with the same name which can occur if an\n    archive has both 32-bits and 64-bits files.\n\ntype ArchiveHeader struct {\n\t// Has unexported fields.\n}\n    ArchiveHeader holds information about a big archive file header\n\ntype AuxCSect32 struct {\n\tXscnlen   uint32 // Length or symbol table index\n\tXparmhash uint32 // Offset of parameter type-check string\n\tXsnhash   uint16 // .typchk section number\n\tXsmtyp    uint8  // Symbol alignment and type\n\tXsmclas   uint8  // Storage-mapping class\n\tXstab     uint32 // Reserved\n\tXsnstab   uint16 // Reserved\n}\n    csect Auxiliary Entry.\n\ntype AuxCSect64 struct {\n\tXscnlenlo uint32 // Lower 4 bytes of length or symbol table index\n\tXparmhash uint32 // Offset of parameter type-check string\n\tXsnhash   uint16 // .typchk section number\n\tXsmtyp    uint8  // Symbol alignment and type\n\tXsmclas   uint8  // Storage-mapping class\n\tXscnlenhi uint32 // Upper 4 bytes of length or symbol table index\n\tXpad      uint8  // Unused\n\tXauxtype  uint8  // Type of auxiliary entry\n}\n\ntype AuxFcn32 struct {\n\tXexptr   uint32 // File offset to exception table entry\n\tXfsize   uint32 // Size of function in bytes\n\tXlnnoptr uint32 // File pointer to line number\n\tXendndx  uint32 // Symbol table index of next entry\n\tXpad     uint16 // Unused\n}\n    Function Auxiliary Entry\n\ntype AuxFcn64 struct {\n\tXlnnoptr uint64 // File pointer to line number\n\tXfsize   uint32 // Size of function in bytes\n\tXendndx  uint32 // Symbol table index of next entry\n\tXpad     uint8  // Unused\n\tXauxtype uint8  // Type of auxiliary entry\n}\n\ntype AuxFile64 struct {\n\tXfname   [8]byte // Name or offset inside string table\n\tXftype   uint8   // Source file string type\n\tXauxtype uint8   // Type of auxiliary entry\n}\n    File Auxiliary Entry\n\ntype AuxSect64 struct {\n\tXscnlen uint64 // section length\n\tXnreloc uint64 // Num RLDs\n\n\tXauxtype uint8 // Type of auxiliary entry\n\t// Has unexported fields.\n}\n\ntype AuxiliaryCSect struct {\n\tLength              int64\n\tStorageMappingClass int\n\tSymbolType          int\n}\n    AuxiliaryCSect holds information about an XCOFF symbol in an AUX_CSECT\n    entry.\n\ntype AuxiliaryFcn struct {\n\tSize int64\n}\n    AuxiliaryFcn holds information about an XCOFF symbol in an AUX_FCN entry.\n\ntype File struct {\n\tFileHeader\n\tSections     []*Section\n\tSymbols      []*Symbol\n\tStringTable  []byte\n\tLibraryPaths []string\n\n\t// Has unexported fields.\n}\n    A File represents an open XCOFF file.\n\nfunc NewFile(r io.ReaderAt) (*File, error)\n    NewFile creates a new File for accessing an XCOFF binary in an underlying\n    reader.\n\nfunc Open(name string) (*File, error)\n    Open opens the named file using os.Open and prepares it for use as an XCOFF\n    binary.\n\nfunc (f *File) CSect(name string) []byte\n    CSect reads and returns the contents of a csect.\n\nfunc (f *File) Close() error\n    Close closes the File. If the File was created using NewFile directly\n    instead of Open, Close has no effect.\n\nfunc (f *File) DWARF() (*dwarf.Data, error)\n\nfunc (f *File) ImportedLibraries() ([]string, error)\n    ImportedLibraries returns the names of all libraries referred to by the\n    binary f that are expected to be linked with the binary at dynamic link\n    time.\n\nfunc (f *File) ImportedSymbols() ([]ImportedSymbol, error)\n    ImportedSymbols returns the names of all symbols referred to by the binary\n    f that are expected to be satisfied by other libraries at dynamic load time.\n    It does not return weak symbols.\n\nfunc (f *File) Section(name string) *Section\n    Section returns the first section with the given name, or nil if no such\n    section exists. Xcoff have section's name limited to 8 bytes. Some sections\n    like .gosymtab can be trunked but this method will still find them.\n\nfunc (f *File) SectionByType(typ uint32) *Section\n    SectionByType returns the first section in f with the given type, or nil if\n    there is no such section.\n\ntype FileHeader struct {\n\tTargetMachine uint16\n}\n    FileHeader holds information about an XCOFF file header.\n\ntype FileHeader32 struct {\n\tFmagic   uint16 // Target machine\n\tFnscns   uint16 // Number of sections\n\tFtimedat uint32 // Time and date of file creation\n\tFsymptr  uint32 // Byte offset to symbol table start\n\tFnsyms   uint32 // Number of entries in symbol table\n\tFopthdr  uint16 // Number of bytes in optional header\n\tFflags   uint16 // Flags\n}\n    File Header.\n\ntype FileHeader64 struct {\n\tFmagic   uint16 // Target machine\n\tFnscns   uint16 // Number of sections\n\tFtimedat uint32 // Time and date of file creation\n\tFsymptr  uint64 // Byte offset to symbol table start\n\tFopthdr  uint16 // Number of bytes in optional header\n\tFflags   uint16 // Flags\n\tFnsyms   uint32 // Number of entries in symbol table\n}\n\ntype ImportedSymbol struct {\n\tName    string\n\tLibrary string\n}\n    ImportedSymbol holds information about an imported XCOFF symbol.\n\ntype LoaderHeader32 struct {\n\tLversion uint32 // Loader section version number\n\tLnsyms   uint32 // Number of symbol table entries\n\tLnreloc  uint32 // Number of relocation table entries\n\tListlen  uint32 // Length of import file ID string table\n\tLnimpid  uint32 // Number of import file IDs\n\tLimpoff  uint32 // Offset to start of import file IDs\n\tLstlen   uint32 // Length of string table\n\tLstoff   uint32 // Offset to start of string table\n}\n    Loader Header.\n\ntype LoaderHeader64 struct {\n\tLversion uint32 // Loader section version number\n\tLnsyms   uint32 // Number of symbol table entries\n\tLnreloc  uint32 // Number of relocation table entries\n\tListlen  uint32 // Length of import file ID string table\n\tLnimpid  uint32 // Number of import file IDs\n\tLstlen   uint32 // Length of string table\n\tLimpoff  uint64 // Offset to start of import file IDs\n\tLstoff   uint64 // Offset to start of string table\n\tLsymoff  uint64 // Offset to start of symbol table\n\tLrldoff  uint64 // Offset to start of relocation entries\n}\n\ntype LoaderSymbol32 struct {\n\tLname   [8]byte // Symbol name or byte offset into string table\n\tLvalue  uint32  // Address field\n\tLscnum  uint16  // Section number containing symbol\n\tLsmtype uint8   // Symbol type, export, import flags\n\tLsmclas uint8   // Symbol storage class\n\tLifile  uint32  // Import file ID; ordinal of import file IDs\n\tLparm   uint32  // Parameter type-check field\n}\n    Loader Symbol.\n\ntype LoaderSymbol64 struct {\n\tLvalue  uint64 // Address field\n\tLoffset uint32 // Byte offset into string table of symbol name\n\tLscnum  uint16 // Section number containing symbol\n\tLsmtype uint8  // Symbol type, export, import flags\n\tLsmclas uint8  // Symbol storage class\n\tLifile  uint32 // Import file ID; ordinal of import file IDs\n\tLparm   uint32 // Parameter type-check field\n}\n\ntype Member struct {\n\tMemberHeader\n\t// Has unexported fields.\n}\n    Member represents a member of an AIX big archive.\n\ntype MemberHeader struct {\n\tName string\n\tSize uint64\n}\n    MemberHeader holds information about a big archive member\n\ntype Reloc struct {\n\tVirtualAddress   uint64\n\tSymbol           *Symbol\n\tSigned           bool\n\tInstructionFixed bool\n\tLength           uint8\n\tType             uint8\n}\n\ntype Reloc32 struct {\n\tRvaddr  uint32 // (virtual) address of reference\n\tRsymndx uint32 // Index into symbol table\n\tRsize   uint8  // Sign and reloc bit len\n\tRtype   uint8  // Toc relocation type\n}\n\ntype Reloc64 struct {\n\tRvaddr  uint64 // (virtual) address of reference\n\tRsymndx uint32 // Index into symbol table\n\tRsize   uint8  // Sign and reloc bit len\n\tRtype   uint8  // Toc relocation type\n}\n\ntype Section struct {\n\tSectionHeader\n\tRelocs []Reloc\n\tio.ReaderAt\n\t// Has unexported fields.\n}\n\nfunc (s *Section) Data() ([]byte, error)\n    Data reads and returns the contents of the XCOFF section s.\n\ntype SectionHeader struct {\n\tName           string\n\tVirtualAddress uint64\n\tSize           uint64\n\tType           uint32\n\tRelptr         uint64\n\tNreloc         uint32\n}\n    SectionHeader holds information about an XCOFF section header.\n\ntype SectionHeader32 struct {\n\tSname    [8]byte // Section name\n\tSpaddr   uint32  // Physical address\n\tSvaddr   uint32  // Virtual address\n\tSsize    uint32  // Section size\n\tSscnptr  uint32  // Offset in file to raw data for section\n\tSrelptr  uint32  // Offset in file to relocation entries for section\n\tSlnnoptr uint32  // Offset in file to line number entries for section\n\tSnreloc  uint16  // Number of relocation entries\n\tSnlnno   uint16  // Number of line number entries\n\tSflags   uint32  // Flags to define the section type\n}\n    Section Header.\n\ntype SectionHeader64 struct {\n\tSname    [8]byte // Section name\n\tSpaddr   uint64  // Physical address\n\tSvaddr   uint64  // Virtual address\n\tSsize    uint64  // Section size\n\tSscnptr  uint64  // Offset in file to raw data for section\n\tSrelptr  uint64  // Offset in file to relocation entries for section\n\tSlnnoptr uint64  // Offset in file to line number entries for section\n\tSnreloc  uint32  // Number of relocation entries\n\tSnlnno   uint32  // Number of line number entries\n\tSflags   uint32  // Flags to define the section type\n\tSpad     uint32  // Needs to be 72 bytes long\n}\n\ntype SymEnt32 struct {\n\tNname   [8]byte // Symbol name\n\tNvalue  uint32  // Symbol value\n\tNscnum  uint16  // Section number of symbol\n\tNtype   uint16  // Basic and derived type specification\n\tNsclass uint8   // Storage class of symbol\n\tNnumaux uint8   // Number of auxiliary entries\n}\n    Symbol Table Entry.\n\ntype SymEnt64 struct {\n\tNvalue  uint64 // Symbol value\n\tNoffset uint32 // Offset of the name in string table or .debug section\n\tNscnum  uint16 // Section number of symbol\n\tNtype   uint16 // Basic and derived type specification\n\tNsclass uint8  // Storage class of symbol\n\tNnumaux uint8  // Number of auxiliary entries\n}\n\ntype Symbol struct {\n\tName          string\n\tValue         uint64\n\tSectionNumber int\n\tStorageClass  int\n\tAuxFcn        AuxiliaryFcn\n\tAuxCSect      AuxiliaryCSect\n}\n\n"}, {"path": "stdlib/internal-buildcfg.md", "category": "stdlib", "name": "stdlib/internal-buildcfg", "content": "package buildcfg // import \"internal/buildcfg\"\n\nPackage buildcfg provides access to the build configuration described by the\ncurrent environment. It is for use by build tools such as cmd/go or cmd/compile\nand for setting up go/build's Default context.\n\nNote that it does NOT provide access to the build configuration used to\nbuild the currently-running binary. For that, use runtime.GOOS etc as well as\ninternal/goexperiment.\n\nCONSTANTS\n\nconst DefaultCGO_ENABLED = \"\"\nconst DefaultGO386 = `sse2`\nconst DefaultGOAMD64 = `v1`\nconst DefaultGOARM = `7`\nconst DefaultGOARM64 = `v8.0`\nconst DefaultGOEXPERIMENT = defaultGOEXPERIMENT\n    DefaultGOEXPERIMENT is the embedded default GOEXPERIMENT string. It is not\n    guaranteed to be canonical.\n\nconst DefaultGOFIPS140 = `off`\nconst DefaultGOMIPS = `hardfloat`\nconst DefaultGOMIPS64 = `hardfloat`\nconst DefaultGOPPC64 = `power8`\nconst DefaultGORISCV64 = `rva20u64`\n\nVARIABLES\n\nvar (\n\tGOROOT    = os.Getenv(\"GOROOT\") // cached for efficiency\n\tGOARCH    = envOr(\"GOARCH\", defaultGOARCH)\n\tGOOS      = envOr(\"GOOS\", defaultGOOS)\n\tGO386     = envOr(\"GO386\", DefaultGO386)\n\tGOAMD64   = goamd64()\n\tGOARM     = goarm()\n\tGOARM64   = goarm64()\n\tGOMIPS    = gomips()\n\tGOMIPS64  = gomips64()\n\tGOPPC64   = goppc64()\n\tGORISCV64 = goriscv64()\n\tGOWASM    = gowasm()\n\tToolTags  = toolTags()\n\tGO_LDSO   = defaultGO_LDSO\n\tGOFIPS140 = gofips140()\n\tVersion   = version\n)\nvar Error error\n    Error is one of the errors found (if any) in the build configuration.\n\nvar FramePointerEnabled = GOARCH == \"amd64\" || GOARCH == \"arm64\"\n    FramePointerEnabled enables the use of platform conventions for saving frame\n    pointers.\n\n    This used to be an experiment, but now it's always enabled on platforms that\n    support it.\n\n    Note: must agree with runtime.framepointer_enabled.\n\n\nFUNCTIONS\n\nfunc Check()\n    Check exits the program with a fatal error if Error is non-nil.\n\nfunc GOGOARCH() (name, value string)\n    GOGOARCH returns the name and value of the GO$GOARCH setting. For example,\n    if GOARCH is \"amd64\" it might return \"GOAMD64\", \"v2\".\n\nfunc Getgoextlinkenabled() string\nfunc ParseGOEXPERIMENT(goos, goarch, goexp string) (*ExperimentFlags, error)\n    ParseGOEXPERIMENT parses a (GOOS, GOARCH, GOEXPERIMENT) configuration tuple\n    and returns the enabled and baseline experiment flag sets.\n\n    TODO(mdempsky): Move to internal/goexperiment.\n\nfunc ParseGoarm64(v string) (g Goarm64Features, e error)\n\nTYPES\n\ntype ExperimentFlags struct {\n\tgoexperiment.Flags\n\t// Has unexported fields.\n}\n    ExperimentFlags represents a set of GOEXPERIMENT flags relative to a\n    baseline (platform-default) experiment configuration.\n\nvar Experiment ExperimentFlags = func() ExperimentFlags {\n\tflags, err := ParseGOEXPERIMENT(GOOS, GOARCH, envOr(\"GOEXPERIMENT\", defaultGOEXPERIMENT))\n\tif err != nil {\n\t\tError = err\n\t\treturn ExperimentFlags{}\n\t}\n\treturn *flags\n}()\n    Experiment contains the toolchain experiments enabled for the current build.\n\n    (This is not necessarily the set of experiments the compiler itself was\n    built with.)\n\n    Experiment.baseline specifies the experiment flags that are enabled\n    by default in the current toolchain. This is, in effect, the \"control\"\n    configuration and any variation from this is an experiment.\n\nfunc (exp *ExperimentFlags) All() []string\n    All returns a list of all experiment settings. Disabled experiments appear\n    in the list prefixed by \"no\".\n\nfunc (exp *ExperimentFlags) Enabled() []string\n    Enabled returns a list of enabled experiments, as lower-cased experiment\n    names.\n\nfunc (exp *ExperimentFlags) String() string\n    String returns the canonical GOEXPERIMENT string to enable this experiment\n    configuration. (Experiments in the same state as in the baseline are\n    elided.)\n\ntype Goarm64Features struct {\n\tVersion string\n\t// Large Systems Extension\n\tLSE bool\n\t// ARM v8.0 Cryptographic Extension. It includes the following features:\n\t// * FEAT_AES, which includes the AESD and AESE instructions.\n\t// * FEAT_PMULL, which includes the PMULL, PMULL2 instructions.\n\t// * FEAT_SHA1, which includes the SHA1* instructions.\n\t// * FEAT_SHA256, which includes the SHA256* instructions.\n\tCrypto bool\n}\n\nfunc (g Goarm64Features) String() string\n\nfunc (g Goarm64Features) Supports(s string) bool\n    Returns true if g supports giving ARM64 ISA Note that this function doesn't\n    accept / test suffixes (like \",lse\" or \",crypto\")\n\ntype GoarmFeatures struct {\n\tVersion   int\n\tSoftFloat bool\n}\n\nfunc (g GoarmFeatures) String() string\n\n"}, {"path": "stdlib/image-png.md", "category": "stdlib", "name": "stdlib/image-png", "content": "package png // import \"image/png\"\n\nPackage png implements a PNG image decoder and encoder.\n\nThe PNG specification is at https://www.w3.org/TR/PNG/.\n\nFUNCTIONS\n\nfunc Decode(r io.Reader) (image.Image, error)\n    Decode reads a PNG image from r and returns it as an image.Image. The type\n    of Image returned depends on the PNG contents.\n\nfunc DecodeConfig(r io.Reader) (image.Config, error)\n    DecodeConfig returns the color model and dimensions of a PNG image without\n    decoding the entire image.\n\nfunc Encode(w io.Writer, m image.Image) error\n    Encode writes the Image m to w in PNG format. Any Image may be encoded,\n    but images that are not image.NRGBA might be encoded lossily.\n\n\nTYPES\n\ntype CompressionLevel int\n    CompressionLevel indicates the compression level.\n\nconst (\n\tDefaultCompression CompressionLevel = 0\n\tNoCompression      CompressionLevel = -1\n\tBestSpeed          CompressionLevel = -2\n\tBestCompression    CompressionLevel = -3\n)\ntype Encoder struct {\n\tCompressionLevel CompressionLevel\n\n\t// BufferPool optionally specifies a buffer pool to get temporary\n\t// EncoderBuffers when encoding an image.\n\tBufferPool EncoderBufferPool\n}\n    Encoder configures encoding PNG images.\n\nfunc (enc *Encoder) Encode(w io.Writer, m image.Image) error\n    Encode writes the Image m to w in PNG format.\n\ntype EncoderBuffer encoder\n    EncoderBuffer holds the buffers used for encoding PNG images.\n\ntype EncoderBufferPool interface {\n\tGet() *EncoderBuffer\n\tPut(*EncoderBuffer)\n}\n    EncoderBufferPool is an interface for getting and returning temporary\n    instances of the EncoderBuffer struct. This can be used to reuse buffers\n    when encoding multiple images.\n\ntype FormatError string\n    A FormatError reports that the input is not a valid PNG.\n\nfunc (e FormatError) Error() string\n\ntype UnsupportedError string\n    An UnsupportedError reports that the input uses a valid but unimplemented\n    PNG feature.\n\nfunc (e UnsupportedError) Error() string\n\n"}, {"path": "stdlib/internal-nettrace.md", "category": "stdlib", "name": "stdlib/internal-nettrace", "content": "package nettrace // import \"internal/nettrace\"\n\nPackage nettrace contains internal hooks for tracing activity in the net\npackage. This package is purely internal for use by the net/http/httptrace\npackage and has no stable API exposed to end users.\n\nTYPES\n\ntype LookupIPAltResolverKey struct{}\n    LookupIPAltResolverKey is a context.Context Value key used by tests to\n    specify an alternate resolver func. It is not exposed to outsider users.\n    (But see issue 12503) The value should be the same type as lookupIP:\n\n        func lookupIP(ctx context.Context, host string) ([]IPAddr, error)\n\ntype Trace struct {\n\t// DNSStart is called with the hostname of a DNS lookup\n\t// before it begins.\n\tDNSStart func(name string)\n\n\t// DNSDone is called after a DNS lookup completes (or fails).\n\t// The coalesced parameter is whether singleflight de-duped\n\t// the call. The addrs are of type net.IPAddr but can't\n\t// actually be for circular dependency reasons.\n\tDNSDone func(netIPs []any, coalesced bool, err error)\n\n\t// ConnectStart is called before a Dial, excluding Dials made\n\t// during DNS lookups. In the case of DualStack (Happy Eyeballs)\n\t// dialing, this may be called multiple times, from multiple\n\t// goroutines.\n\tConnectStart func(network, addr string)\n\n\t// ConnectDone is called after a Dial with the results, excluding\n\t// Dials made during DNS lookups. It may also be called multiple\n\t// times, like ConnectStart.\n\tConnectDone func(network, addr string, err error)\n}\n    Trace contains a set of hooks for tracing events within the net package.\n    Any specific hook may be nil.\n\ntype TraceKey struct{}\n    TraceKey is a context.Context Value key. Its associated value should be a\n    *Trace struct.\n\n"}, {"path": "stdlib/internal-oserror.md", "category": "stdlib", "name": "stdlib/internal-oserror", "content": "package oserror // import \"internal/oserror\"\n\nPackage oserror defines errors values used in the os package.\n\nThese types are defined here to permit the syscall package to reference them.\n\nVARIABLES\n\nvar (\n\tErrInvalid    = errors.New(\"invalid argument\")\n\tErrPermission = errors.New(\"permission denied\")\n\tErrExist      = errors.New(\"file already exists\")\n\tErrNotExist   = errors.New(\"file does not exist\")\n\tErrClosed     = errors.New(\"file already closed\")\n)\n"}, {"path": "stdlib/crypto-internal-fips140only.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140only", "content": "package fips140only // import \"crypto/internal/fips140only\"\n\n\nVARIABLES\n\nvar Enabled = godebug.New(\"fips140\").Value() == \"only\"\n    Enabled reports whether FIPS 140-only mode is enabled, in which non-approved\n    cryptography returns an error or panics.\n\n\nFUNCTIONS\n\nfunc ApprovedHash(h hash.Hash) bool\nfunc ApprovedRandomReader(r io.Reader) bool\n"}, {"path": "stdlib/crypto-aes.md", "category": "stdlib", "name": "stdlib/crypto-aes", "content": "package aes // import \"crypto/aes\"\n\nPackage aes implements AES encryption (formerly Rijndael), as defined in U.S.\nFederal Information Processing Standards Publication 197.\n\nThe AES operations in this package are not implemented using constant-time\nalgorithms. An exception is when running on systems with enabled hardware\nsupport for AES that makes these operations constant-time. Examples\ninclude amd64 systems using AES-NI extensions and s390x systems using\nMessage-Security-Assist extensions. On such systems, when the result of\nNewCipher is passed to cipher.NewGCM, the GHASH operation used by GCM is also\nconstant-time.\n\nCONSTANTS\n\nconst BlockSize = 16\n    The AES block size in bytes.\n\n\nFUNCTIONS\n\nfunc NewCipher(key []byte) (cipher.Block, error)\n    NewCipher creates and returns a new cipher.Block. The key argument must\n    be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192,\n    or AES-256.\n\n\nTYPES\n\ntype KeySizeError int\n\nfunc (k KeySizeError) Error() string\n\n"}, {"path": "stdlib/crypto-elliptic.md", "category": "stdlib", "name": "stdlib/crypto-elliptic", "content": "package elliptic // import \"crypto/elliptic\"\n\nPackage elliptic implements the standard NIST P-224, P-256, P-384, and P-521\nelliptic curves over prime fields.\n\nDirect use of this package is deprecated, beyond the P224, P256, P384, and P521\nvalues necessary to use crypto/ecdsa. Most other uses should migrate to the\nmore efficient and safer crypto/ecdh, or to third-party modules for lower-level\nfunctionality.\n\nFUNCTIONS\n\nfunc GenerateKey(curve Curve, rand io.Reader) (priv []byte, x, y *big.Int, err error)\n    GenerateKey returns a public/private key pair. The private key is generated\n    using the given reader, which must return random data.\n\n    Deprecated: for ECDH, use the GenerateKey methods of the crypto/ecdh\n    package; for ECDSA, use the GenerateKey function of the crypto/ecdsa\n    package.\n\nfunc Marshal(curve Curve, x, y *big.Int) []byte\n    Marshal converts a point on the curve into the uncompressed form specified\n    in SEC 1, Version 2.0, Section 2.3.3. If the point is not on the curve (or\n    is the conventional point at infinity), the behavior is undefined.\n\n    Deprecated: for ECDH, use the crypto/ecdh package. This function returns an\n    encoding equivalent to that of PublicKey.Bytes in crypto/ecdh.\n\nfunc MarshalCompressed(curve Curve, x, y *big.Int) []byte\n    MarshalCompressed converts a point on the curve into the compressed form\n    specified in SEC 1, Version 2.0, Section 2.3.3. If the point is not on the\n    curve (or is the conventional point at infinity), the behavior is undefined.\n\nfunc Unmarshal(curve Curve, data []byte) (x, y *big.Int)\n    Unmarshal converts a point, serialized by Marshal, into an x, y pair. It\n    is an error if the point is not in uncompressed form, is not on the curve,\n    or is the point at infinity. On error, x = nil.\n\n    Deprecated: for ECDH, use the crypto/ecdh package. This function accepts an\n    encoding equivalent to that of the NewPublicKey methods in crypto/ecdh.\n\nfunc UnmarshalCompressed(curve Curve, data []byte) (x, y *big.Int)\n    UnmarshalCompressed converts a point, serialized by MarshalCompressed,\n    into an x, y pair. It is an error if the point is not in compressed form,\n    is not on the curve, or is the point at infinity. On error, x = nil.\n\n\nTYPES\n\ntype Curve interface {\n\t// Params returns the parameters for the curve.\n\tParams() *CurveParams\n\n\t// IsOnCurve reports whether the given (x,y) lies on the curve.\n\t//\n\t// Deprecated: this is a low-level unsafe API. For ECDH, use the crypto/ecdh\n\t// package. The NewPublicKey methods of NIST curves in crypto/ecdh accept\n\t// the same encoding as the Unmarshal function, and perform on-curve checks.\n\tIsOnCurve(x, y *big.Int) bool\n\n\t// Add returns the sum of (x1,y1) and (x2,y2).\n\t//\n\t// Deprecated: this is a low-level unsafe API.\n\tAdd(x1, y1, x2, y2 *big.Int) (x, y *big.Int)\n\n\t// Double returns 2*(x,y).\n\t//\n\t// Deprecated: this is a low-level unsafe API.\n\tDouble(x1, y1 *big.Int) (x, y *big.Int)\n\n\t// ScalarMult returns k*(x,y) where k is an integer in big-endian form.\n\t//\n\t// Deprecated: this is a low-level unsafe API. For ECDH, use the crypto/ecdh\n\t// package. Most uses of ScalarMult can be replaced by a call to the ECDH\n\t// methods of NIST curves in crypto/ecdh.\n\tScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int)\n\n\t// ScalarBaseMult returns k*G, where G is the base point of the group\n\t// and k is an integer in big-endian form.\n\t//\n\t// Deprecated: this is a low-level unsafe API. For ECDH, use the crypto/ecdh\n\t// package. Most uses of ScalarBaseMult can be replaced by a call to the\n\t// PrivateKey.PublicKey method in crypto/ecdh.\n\tScalarBaseMult(k []byte) (x, y *big.Int)\n}\n    A Curve represents a short-form Weierstrass curve with a=-3.\n\n    The behavior of Add, Double, and ScalarMult when the input is not a point on\n    the curve is undefined.\n\n    Note that the conventional point at infinity (0, 0) is not considered\n    on the curve, although it can be returned by Add, Double, ScalarMult,\n    or ScalarBaseMult (but not the Unmarshal or UnmarshalCompressed functions).\n\n    Using Curve implementations besides those returned by P224, P256, P384,\n    and P521 is deprecated.\n\nfunc P224() Curve\n    P224 returns a Curve which implements NIST P-224 (FIPS 186-3, section\n    D.2.2), also known as secp224r1. The CurveParams.Name of this Curve is\n    \"P-224\".\n\n    Multiple invocations of this function will return the same value, so it can\n    be used for equality checks and switch statements.\n\n    The cryptographic operations are implemented using constant-time algorithms.\n\nfunc P256() Curve\n    P256 returns a Curve which implements NIST P-256 (FIPS 186-3, section\n    D.2.3), also known as secp256r1 or prime256v1. The CurveParams.Name of this\n    Curve is \"P-256\".\n\n    Multiple invocations of this function will return the same value, so it can\n    be used for equality checks and switch statements.\n\n    The cryptographic operations are implemented using constant-time algorithms.\n\nfunc P384() Curve\n    P384 returns a Curve which implements NIST P-384 (FIPS 186-3, section\n    D.2.4), also known as secp384r1. The CurveParams.Name of this Curve is\n    \"P-384\".\n\n    Multiple invocations of this function will return the same value, so it can\n    be used for equality checks and switch statements.\n\n    The cryptographic operations are implemented using constant-time algorithms.\n\nfunc P521() Curve\n    P521 returns a Curve which implements NIST P-521 (FIPS 186-3, section\n    D.2.5), also known as secp521r1. The CurveParams.Name of this Curve is\n    \"P-521\".\n\n    Multiple invocations of this function will return the same value, so it can\n    be used for equality checks and switch statements.\n\n    The cryptographic operations are implemented using constant-time algorithms.\n\ntype CurveParams struct {\n\tP       *big.Int // the order of the underlying field\n\tN       *big.Int // the order of the base point\n\tB       *big.Int // the constant of the curve equation\n\tGx, Gy  *big.Int // (x,y) of the base point\n\tBitSize int      // the size of the underlying field\n\tName    string   // the canonical name of the curve\n}\n    CurveParams contains the parameters of an elliptic curve and also provides a\n    generic, non-constant time implementation of Curve.\n\n    The generic Curve implementation is deprecated, and using custom curves\n    (those not returned by P224, P256, P384, and P521) is not guaranteed to\n    provide any security property.\n\nfunc (curve *CurveParams) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int)\n    Add implements [Curve.Add].\n\n    Deprecated: the CurveParams methods are deprecated and are not guaranteed\n    to provide any security property. For ECDH, use the crypto/ecdh package.\n    For ECDSA, use the crypto/ecdsa package with a Curve value returned directly\n    from P224, P256, P384, or P521.\n\nfunc (curve *CurveParams) Double(x1, y1 *big.Int) (*big.Int, *big.Int)\n    Double implements [Curve.Double].\n\n    Deprecated: the CurveParams methods are deprecated and are not guaranteed\n    to provide any security property. For ECDH, use the crypto/ecdh package.\n    For ECDSA, use the crypto/ecdsa package with a Curve value returned directly\n    from P224, P256, P384, or P521.\n\nfunc (curve *CurveParams) IsOnCurve(x, y *big.Int) bool\n    IsOnCurve implements [Curve.IsOnCurve].\n\n    Deprecated: the CurveParams methods are deprecated and are not guaranteed\n    to provide any security property. For ECDH, use the crypto/ecdh package.\n    For ECDSA, use the crypto/ecdsa package with a Curve value returned directly\n    from P224, P256, P384, or P521.\n\nfunc (curve *CurveParams) Params() *CurveParams\n\nfunc (curve *CurveParams) ScalarBaseMult(k []byte) (*big.Int, *big.Int)\n    ScalarBaseMult implements [Curve.ScalarBaseMult].\n\n    Deprecated: the CurveParams methods are deprecated and are not guaranteed\n    to provide any security property. For ECDH, use the crypto/ecdh package.\n    For ECDSA, use the crypto/ecdsa package with a Curve value returned directly\n    from P224, P256, P384, or P521.\n\nfunc (curve *CurveParams) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int)\n    ScalarMult implements [Curve.ScalarMult].\n\n    Deprecated: the CurveParams methods are deprecated and are not guaranteed\n    to provide any security property. For ECDH, use the crypto/ecdh package.\n    For ECDSA, use the crypto/ecdsa package with a Curve value returned directly\n    from P224, P256, P384, or P521.\n\n"}, {"path": "stdlib/internal-godebug.md", "category": "stdlib", "name": "stdlib/internal-godebug", "content": "package godebug // import \"internal/godebug\"\n\nPackage godebug makes the settings in the $GODEBUG environment variable\navailable to other packages. These settings are often used for compatibility\ntweaks, when we need to change a default behavior but want to let users opt back\nin to the original. For example GODEBUG=http2server=0 disables HTTP/2 support in\nthe net/http server.\n\nIn typical usage, code should declare a Setting as a global and then call Value\neach time the current setting value is needed:\n\n    var http2server = godebug.New(\"http2server\")\n\n    func ServeConn(c net.Conn) {\n    \tif http2server.Value() == \"0\" {\n    \t\tdisallow HTTP/2\n    \t\t...\n    \t}\n    \t...\n    }\n\nEach time a non-default setting causes a change in program behavior, code\nmust call Setting.IncNonDefault to increment a counter that can be reported\nby runtime/metrics.Read. The call must only happen when the program executes a\nnon-default behavior, not just when the setting is set to a non-default value.\nThis is occasionally (but very rarely) infeasible, in which case the\ninternal/godebugs table entry must set Opaque: true, and the documentation in\ndoc/godebug.md should mention that metrics are unavailable.\n\nConventionally, the global variable representing a godebug is named for the\ngodebug itself, with no case changes:\n\n    var gotypesalias = godebug.New(\"gotypesalias\") // this\n    var goTypesAlias = godebug.New(\"gotypesalias\") // NOT THIS\n\nThe test in internal/godebugs that checks for use of IncNonDefault requires the\nuse of this convention.\n\nNote that counters used with IncNonDefault must be added to various tables in\nother packages. See the Setting.IncNonDefault documentation for details.\n\nTYPES\n\ntype Setting struct {\n\t// Has unexported fields.\n}\n    A Setting is a single setting in the $GODEBUG environment variable.\n\nfunc New(name string) *Setting\n    New returns a new Setting for the $GODEBUG setting with the given name.\n\n    GODEBUGs meant for use by end users must be listed in ../godebugs/table.go,\n    which is used for generating and checking various documentation.\n    If the name is not listed in that table, New will succeed but calling\n    Value on the returned Setting will panic. To disable that panic for\n    access to an undocumented setting, prefix the name with a #, as in\n    godebug.New(\"#gofsystrace\"). The # is a signal to New but not part of the\n    key used in $GODEBUG.\n\n    Note that almost all settings should arrange to call [IncNonDefault]\n    precisely when program behavior is changing from the default due to the\n    setting (not just when the setting is different, but when program behavior\n    changes). See the internal/godebug package comment for more.\n\nfunc (s *Setting) IncNonDefault()\n    IncNonDefault increments the non-default behavior counter associated with\n    the given setting. This counter is exposed in the runtime/metrics value\n    /godebug/non-default-behavior/<name>:events.\n\n    Note that Value must be called at least once before IncNonDefault.\n\nfunc (s *Setting) Name() string\n    Name returns the name of the setting.\n\nfunc (s *Setting) String() string\n    String returns a printable form for the setting: name=value.\n\nfunc (s *Setting) Undocumented() bool\n    Undocumented reports whether this is an undocumented setting.\n\nfunc (s *Setting) Value() string\n    Value returns the current value for the GODEBUG setting s.\n\n    Value maintains an internal cache that is synchronized with changes to the\n    $GODEBUG environment variable, making Value efficient to call as frequently\n    as needed. Clients should therefore typically not attempt their own caching\n    of Value's result.\n\n"}, {"path": "stdlib/internal-itoa.md", "category": "stdlib", "name": "stdlib/internal-itoa", "content": "package itoa // import \"internal/itoa\"\n\n\nFUNCTIONS\n\nfunc Itoa(val int) string\n    Itoa converts val to a decimal string.\n\nfunc Uitoa(val uint) string\n    Uitoa converts val to a decimal string.\n\nfunc Uitox(val uint) string\n    Uitox converts val (a uint) to a hexadecimal string.\n\n"}, {"path": "stdlib/crypto-internal-fips140-hkdf.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-hkdf", "content": "package hkdf // import \"crypto/internal/fips140/hkdf\"\n\n\nFUNCTIONS\n\nfunc Expand[H hash.Hash](h func() H, pseudorandomKey []byte, info string, keyLen int) []byte\nfunc Extract[H hash.Hash](h func() H, secret, salt []byte) []byte\nfunc Key[H hash.Hash](h func() H, secret, salt []byte, info string, keyLen int) []byte\n"}, {"path": "stdlib/sort.md", "category": "stdlib", "name": "stdlib/sort", "content": "package sort // import \"sort\"\n\nPackage sort provides primitives for sorting slices and user-defined\ncollections.\n\nFUNCTIONS\n\nfunc Find(n int, cmp func(int) int) (i int, found bool)\n    Find uses binary search to find and return the smallest index i in [0,\n    n) at which cmp(i) <= 0. If there is no such index i, Find returns i = n.\n    The found result is true if i < n and cmp(i) == 0. Find calls cmp(i) only\n    for i in the range [0, n).\n\n    To permit binary search, Find requires that cmp(i) > 0 for a leading prefix\n    of the range, cmp(i) == 0 in the middle, and cmp(i) < 0 for the final suffix\n    of the range. (Each subrange could be empty.) The usual way to establish\n    this condition is to interpret cmp(i) as a comparison of a desired target\n    value t against entry i in an underlying indexed data structure x, returning\n    <0, 0, and >0 when t < x[i], t == x[i], and t > x[i], respectively.\n\n    For example, to look for a particular string in a sorted, random-access list\n    of strings:\n\n        i, found := sort.Find(x.Len(), func(i int) int {\n            return strings.Compare(target, x.At(i))\n        })\n        if found {\n            fmt.Printf(\"found %s at entry %d\\n\", target, i)\n        } else {\n            fmt.Printf(\"%s not found, would insert at %d\", target, i)\n        }\n\nfunc Float64s(x []float64)\n    Float64s sorts a slice of float64s in increasing order. Not-a-number (NaN)\n    values are ordered before other values.\n\n    Note: as of Go 1.22, this function simply calls slices.Sort.\n\nfunc Float64sAreSorted(x []float64) bool\n    Float64sAreSorted reports whether the slice x is sorted in increasing order,\n    with not-a-number (NaN) values before any other values.\n\n    Note: as of Go 1.22, this function simply calls slices.IsSorted.\n\nfunc Ints(x []int)\n    Ints sorts a slice of ints in increasing order.\n\n    Note: as of Go 1.22, this function simply calls slices.Sort.\n\nfunc IntsAreSorted(x []int) bool\n    IntsAreSorted reports whether the slice x is sorted in increasing order.\n\n    Note: as of Go 1.22, this function simply calls slices.IsSorted.\n\nfunc IsSorted(data Interface) bool\n    IsSorted reports whether data is sorted.\n\n    Note: in many situations, the newer slices.IsSortedFunc function is more\n    ergonomic and runs faster.\n\nfunc Search(n int, f func(int) bool) int\n    Search uses binary search to find and return the smallest index i in [0,\n    n) at which f(i) is true, assuming that on the range [0, n), f(i) == true\n    implies f(i+1) == true. That is, Search requires that f is false for some\n    (possibly empty) prefix of the input range [0, n) and then true for the\n    (possibly empty) remainder; Search returns the first true index. If there is\n    no such index, Search returns n. (Note that the \"not found\" return value is\n    not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in\n    the range [0, n).\n\n    A common use of Search is to find the index i for a value x in a sorted,\n    indexable data structure such as an array or slice. In this case,\n    the argument f, typically a closure, captures the value to be searched for,\n    and how the data structure is indexed and ordered.\n\n    For instance, given a slice data sorted in ascending order, the call\n    Search(len(data), func(i int) bool { return data[i] >= 23 }) returns the\n    smallest index i such that data[i] >= 23. If the caller wants to find\n    whether 23 is in the slice, it must test data[i] == 23 separately.\n\n    Searching data sorted in descending order would use the <= operator instead\n    of the >= operator.\n\n    To complete the example above, the following code tries to find the value x\n    in an integer slice data sorted in ascending order:\n\n        x := 23\n        i := sort.Search(len(data), func(i int) bool { return data[i] >= x })\n        if i < len(data) && data[i] == x {\n        \t// x is present at data[i]\n        } else {\n        \t// x is not present in data,\n        \t// but i is the index where it would be inserted.\n        }\n\n    As a more whimsical example, this program guesses your number:\n\n        func GuessingGame() {\n        \tvar s string\n        \tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n        \tanswer := sort.Search(100, func(i int) bool {\n        \t\tfmt.Printf(\"Is your number <= %d? \", i)\n        \t\tfmt.Scanf(\"%s\", &s)\n        \t\treturn s != \"\" && s[0] == 'y'\n        \t})\n        \tfmt.Printf(\"Your number is %d.\\n\", answer)\n        }\n\nfunc SearchFloat64s(a []float64, x float64) int\n    SearchFloat64s searches for x in a sorted slice of float64s and returns the\n    index as specified by Search. The return value is the index to insert x if x\n    is not present (it could be len(a)). The slice must be sorted in ascending\n    order.\n\nfunc SearchInts(a []int, x int) int\n    SearchInts searches for x in a sorted slice of ints and returns the index as\n    specified by Search. The return value is the index to insert x if x is not\n    present (it could be len(a)). The slice must be sorted in ascending order.\n\nfunc SearchStrings(a []string, x string) int\n    SearchStrings searches for x in a sorted slice of strings and returns the\n    index as specified by Search. The return value is the index to insert x if x\n    is not present (it could be len(a)). The slice must be sorted in ascending\n    order.\n\nfunc Slice(x any, less func(i, j int) bool)\n    Slice sorts the slice x given the provided less function. It panics if x is\n    not a slice.\n\n    The sort is not guaranteed to be stable: equal elements may be reversed from\n    their original order. For a stable sort, use SliceStable.\n\n    The less function must satisfy the same requirements as the Interface type's\n    Less method.\n\n    Note: in many situations, the newer slices.SortFunc function is more\n    ergonomic and runs faster.\n\nfunc SliceIsSorted(x any, less func(i, j int) bool) bool\n    SliceIsSorted reports whether the slice x is sorted according to the\n    provided less function. It panics if x is not a slice.\n\n    Note: in many situations, the newer slices.IsSortedFunc function is more\n    ergonomic and runs faster.\n\nfunc SliceStable(x any, less func(i, j int) bool)\n    SliceStable sorts the slice x using the provided less function, keeping\n    equal elements in their original order. It panics if x is not a slice.\n\n    The less function must satisfy the same requirements as the Interface type's\n    Less method.\n\n    Note: in many situations, the newer slices.SortStableFunc function is more\n    ergonomic and runs faster.\n\nfunc Sort(data Interface)\n    Sort sorts data in ascending order as determined by the Less method. It\n    makes one call to data.Len to determine n and O(n*log(n)) calls to data.Less\n    and data.Swap. The sort is not guaranteed to be stable.\n\n    Note: in many situations, the newer slices.SortFunc function is more\n    ergonomic and runs faster.\n\nfunc Stable(data Interface)\n    Stable sorts data in ascending order as determined by the Less method,\n    while keeping the original order of equal elements.\n\n    It makes one call to data.Len to determine n, O(n*log(n)) calls to data.Less\n    and O(n*log(n)*log(n)) calls to data.Swap.\n\n    Note: in many situations, the newer slices.SortStableFunc function is more\n    ergonomic and runs faster.\n\nfunc Strings(x []string)\n    Strings sorts a slice of strings in increasing order.\n\n    Note: as of Go 1.22, this function simply calls slices.Sort.\n\nfunc StringsAreSorted(x []string) bool\n    StringsAreSorted reports whether the slice x is sorted in increasing order.\n\n    Note: as of Go 1.22, this function simply calls slices.IsSorted.\n\n\nTYPES\n\ntype Float64Slice []float64\n    Float64Slice implements Interface for a []float64, sorting in increasing\n    order, with not-a-number (NaN) values ordered before other values.\n\nfunc (x Float64Slice) Len() int\n\nfunc (x Float64Slice) Less(i, j int) bool\n    Less reports whether x[i] should be ordered before x[j], as required by\n    the sort Interface. Note that floating-point comparison by itself is\n    not a transitive relation: it does not report a consistent ordering for\n    not-a-number (NaN) values. This implementation of Less places NaN values\n    before any others, by using:\n\n        x[i] < x[j] || (math.IsNaN(x[i]) && !math.IsNaN(x[j]))\n\nfunc (p Float64Slice) Search(x float64) int\n    Search returns the result of applying SearchFloat64s to the receiver and x.\n\nfunc (x Float64Slice) Sort()\n    Sort is a convenience method: x.Sort() calls Sort(x).\n\nfunc (x Float64Slice) Swap(i, j int)\n\ntype IntSlice []int\n    IntSlice attaches the methods of Interface to []int, sorting in increasing\n    order.\n\nfunc (x IntSlice) Len() int\n\nfunc (x IntSlice) Less(i, j int) bool\n\nfunc (p IntSlice) Search(x int) int\n    Search returns the result of applying SearchInts to the receiver and x.\n\nfunc (x IntSlice) Sort()\n    Sort is a convenience method: x.Sort() calls Sort(x).\n\nfunc (x IntSlice) Swap(i, j int)\n\ntype Interface interface {\n\t// Len is the number of elements in the collection.\n\tLen() int\n\n\t// Less reports whether the element with index i\n\t// must sort before the element with index j.\n\t//\n\t// If both Less(i, j) and Less(j, i) are false,\n\t// then the elements at index i and j are considered equal.\n\t// Sort may place equal elements in any order in the final result,\n\t// while Stable preserves the original input order of equal elements.\n\t//\n\t// Less must describe a [Strict Weak Ordering]. For example:\n\t//  - if both Less(i, j) and Less(j, k) are true, then Less(i, k) must be true as well.\n\t//  - if both Less(i, j) and Less(j, k) are false, then Less(i, k) must be false as well.\n\t//\n\t// Note that floating-point comparison (the < operator on float32 or float64 values)\n\t// is not a strict weak ordering when not-a-number (NaN) values are involved.\n\t// See Float64Slice.Less for a correct implementation for floating-point values.\n\t//\n\t// [Strict Weak Ordering]: https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings\n\tLess(i, j int) bool\n\n\t// Swap swaps the elements with indexes i and j.\n\tSwap(i, j int)\n}\n    An implementation of Interface can be sorted by the routines in this\n    package. The methods refer to elements of the underlying collection by\n    integer index.\n\nfunc Reverse(data Interface) Interface\n    Reverse returns the reverse order for data.\n\ntype StringSlice []string\n    StringSlice attaches the methods of Interface to []string, sorting in\n    increasing order.\n\nfunc (x StringSlice) Len() int\n\nfunc (x StringSlice) Less(i, j int) bool\n\nfunc (p StringSlice) Search(x string) int\n    Search returns the result of applying SearchStrings to the receiver and x.\n\nfunc (x StringSlice) Sort()\n    Sort is a convenience method: x.Sort() calls Sort(x).\n\nfunc (x StringSlice) Swap(i, j int)\n\n"}, {"path": "stdlib/encoding-json.md", "category": "stdlib", "name": "stdlib/encoding-json", "content": "package json // import \"encoding/json\"\n\nPackage json implements encoding and decoding of JSON as defined in RFC 7159.\nThe mapping between JSON and Go values is described in the documentation for the\nMarshal and Unmarshal functions.\n\nSee \"JSON and Go\" for an introduction to this package:\nhttps://golang.org/doc/articles/json_and_go.html\n\n# Security Considerations\n\nThe JSON standard (RFC 7159) is lax in its definition of a number of parser\nbehaviors. As such, many JSON parsers behave differently in various scenarios.\nThese differences in parsers mean that systems that use multiple independent\nJSON parser implementations may parse the same JSON object in differing ways.\n\nSystems that rely on a JSON object being parsed consistently for security\npurposes should be careful to understand the behaviors of this parser, as well\nas how these behaviors may cause interoperability issues with other parser\nimplementations.\n\nDue to the Go Backwards Compatibility promise (https://go.dev/doc/go1compat)\nthere are a number of behaviors this package exhibits that may cause\ninteropability issues, but cannot be changed. In particular the following\nparsing behaviors may cause issues:\n\n  - If a JSON object contains duplicate keys, keys are processed in the order\n    they are observed, meaning later values will replace or be merged into prior\n    values, depending on the field type (in particular maps and structs will\n    have values merged, while other types have values replaced).\n  - When parsing a JSON object into a Go struct, keys are considered in a\n    case-insensitive fashion.\n  - When parsing a JSON object into a Go struct, unknown keys in the JSON object\n    are ignored (unless a Decoder is used and Decoder.DisallowUnknownFields has\n    been called).\n  - Invalid UTF-8 bytes in JSON strings are replaced by the Unicode replacement\n    character.\n  - Large JSON number integers will lose precision when unmarshaled into\n    floating-point types.\n\nFUNCTIONS\n\nfunc Compact(dst *bytes.Buffer, src []byte) error\n    Compact appends to dst the JSON-encoded src with insignificant space\n    characters elided.\n\nfunc HTMLEscape(dst *bytes.Buffer, src []byte)\n    HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and\n    U+2029 characters inside string literals changed to \\u003c, \\u003e, \\u0026,\n    \\u2028, \\u2029 so that the JSON will be safe to embed inside HTML <script>\n    tags. For historical reasons, web browsers don't honor standard HTML\n    escaping within <script> tags, so an alternative JSON encoding must be used.\n\nfunc Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error\n    Indent appends to dst an indented form of the JSON-encoded src. Each element\n    in a JSON object or array begins on a new, indented line beginning with\n    prefix followed by one or more copies of indent according to the indentation\n    nesting. The data appended to dst does not begin with the prefix nor any\n    indentation, to make it easier to embed inside other formatted JSON data.\n    Although leading space characters (space, tab, carriage return, newline) at\n    the beginning of src are dropped, trailing space characters at the end of\n    src are preserved and copied to dst. For example, if src has no trailing\n    spaces, neither will dst; if src ends in a trailing newline, so will dst.\n\nfunc Marshal(v any) ([]byte, error)\n    Marshal returns the JSON encoding of v.\n\n    Marshal traverses the value v recursively. If an encountered\n    value implements Marshaler and is not a nil pointer, Marshal calls\n    [Marshaler.MarshalJSON] to produce JSON. If no [Marshaler.MarshalJSON]\n    method is present but the value implements encoding.TextMarshaler instead,\n    Marshal calls encoding.TextMarshaler.MarshalText and encodes the\n    result as a JSON string. The nil pointer exception is not strictly\n    necessary but mimics a similar, necessary exception in the behavior of\n    [Unmarshaler.UnmarshalJSON].\n\n    Otherwise, Marshal uses the following type-dependent default encodings:\n\n    Boolean values encode as JSON booleans.\n\n    Floating point, integer, and Number values encode as JSON numbers. NaN and\n    +/-Inf values will return an UnsupportedValueError.\n\n    String values encode as JSON strings coerced to valid UTF-8, replacing\n    invalid bytes with the Unicode replacement rune. So that the JSON will\n    be safe to embed inside HTML <script> tags, the string is encoded using\n    HTMLEscape, which replaces \"<\", \">\", \"&\", U+2028, and U+2029 are escaped to\n    \"\\u003c\",\"\\u003e\", \"\\u0026\", \"\\u2028\", and \"\\u2029\". This replacement can be\n    disabled when using an Encoder, by calling Encoder.SetEscapeHTML(false).\n\n    Array and slice values encode as JSON arrays, except that []byte encodes as\n    a base64-encoded string, and a nil slice encodes as the null JSON value.\n\n    Struct values encode as JSON objects. Each exported struct field becomes\n    a member of the object, using the field name as the object key, unless the\n    field is omitted for one of the reasons given below.\n\n    The encoding of each struct field can be customized by the format string\n    stored under the \"json\" key in the struct field's tag. The format string\n    gives the name of the field, possibly followed by a comma-separated list\n    of options. The name may be empty in order to specify options without\n    overriding the default field name.\n\n    The \"omitempty\" option specifies that the field should be omitted from\n    the encoding if the field has an empty value, defined as false, 0,\n    a nil pointer, a nil interface value, and any array, slice, map, or string\n    of length zero.\n\n    As a special case, if the field tag is \"-\", the field is always omitted.\n    Note that a field with name \"-\" can still be generated using the tag \"-,\".\n\n    Examples of struct field tags and their meanings:\n\n        // Field appears in JSON as key \"myName\".\n        Field int `json:\"myName\"`\n\n        // Field appears in JSON as key \"myName\" and\n        // the field is omitted from the object if its value is empty,\n        // as defined above.\n        Field int `json:\"myName,omitempty\"`\n\n        // Field appears in JSON as key \"Field\" (the default), but\n        // the field is skipped if empty.\n        // Note the leading comma.\n        Field int `json:\",omitempty\"`\n\n        // Field is ignored by this package.\n        Field int `json:\"-\"`\n\n        // Field appears in JSON as key \"-\".\n        Field int `json:\"-,\"`\n\n    The \"omitzero\" option specifies that the field should be omitted from the\n    encoding if the field has a zero value, according to rules:\n\n    1) If the field type has an \"IsZero() bool\" method, that will be used to\n    determine whether the value is zero.\n\n    2) Otherwise, the value is zero if it is the zero value for its type.\n\n    If both \"omitempty\" and \"omitzero\" are specified, the field will be omitted\n    if the value is either empty or zero (or both).\n\n    The \"string\" option signals that a field is stored as JSON inside a\n    JSON-encoded string. It applies only to fields of string, floating point,\n    integer, or boolean types. This extra level of encoding is sometimes used\n    when communicating with JavaScript programs:\n\n        Int64String int64 `json:\",string\"`\n\n    The key name will be used if it's a non-empty string consisting of only\n    Unicode letters, digits, and ASCII punctuation except quotation marks,\n    backslash, and comma.\n\n    Embedded struct fields are usually marshaled as if their inner exported\n    fields were fields in the outer struct, subject to the usual Go visibility\n    rules amended as described in the next paragraph. An anonymous struct field\n    with a name given in its JSON tag is treated as having that name, rather\n    than being anonymous. An anonymous struct field of interface type is treated\n    the same as having that type as its name, rather than being anonymous.\n\n    The Go visibility rules for struct fields are amended for JSON when deciding\n    which field to marshal or unmarshal. If there are multiple fields at the\n    same level, and that level is the least nested (and would therefore be the\n    nesting level selected by the usual Go rules), the following extra rules\n    apply:\n\n    1) Of those fields, if any are JSON-tagged, only tagged fields are\n    considered, even if there are multiple untagged fields that would otherwise\n    conflict.\n\n    2) If there is exactly one field (tagged or not according to the first\n    rule), that is selected.\n\n    3) Otherwise there are multiple fields, and all are ignored; no error\n    occurs.\n\n    Handling of anonymous struct fields is new in Go 1.1. Prior to Go 1.1,\n    anonymous struct fields were ignored. To force ignoring of an anonymous\n    struct field in both current and earlier versions, give the field a JSON tag\n    of \"-\".\n\n    Map values encode as JSON objects. The map's key type must either be a\n    string, an integer type, or implement encoding.TextMarshaler. The map keys\n    are sorted and used as JSON object keys by applying the following rules,\n    subject to the UTF-8 coercion described for string values above:\n      - keys of any string type are used directly\n      - keys that implement encoding.TextMarshaler are marshaled\n      - integer keys are converted to strings\n\n    Pointer values encode as the value pointed to. A nil pointer encodes as the\n    null JSON value.\n\n    Interface values encode as the value contained in the interface. A nil\n    interface value encodes as the null JSON value.\n\n    Channel, complex, and function values cannot be encoded in JSON. Attempting\n    to encode such a value causes Marshal to return an UnsupportedTypeError.\n\n    JSON cannot represent cyclic data structures and Marshal does not handle\n    them. Passing cyclic structures to Marshal will result in an error.\n\nfunc MarshalIndent(v any, prefix, indent string) ([]byte, error)\n    MarshalIndent is like Marshal but applies Indent to format the output.\n    Each JSON element in the output will begin on a new line beginning with\n    prefix followed by one or more copies of indent according to the indentation\n    nesting.\n\nfunc Unmarshal(data []byte, v any) error\n    Unmarshal parses the JSON-encoded data and stores the result in the\n    value pointed to by v. If v is nil or not a pointer, Unmarshal returns an\n    InvalidUnmarshalError.\n\n    Unmarshal uses the inverse of the encodings that Marshal uses, allocating\n    maps, slices, and pointers as necessary, with the following additional\n    rules:\n\n    To unmarshal JSON into a pointer, Unmarshal first handles the case of the\n    JSON being the JSON literal null. In that case, Unmarshal sets the pointer\n    to nil. Otherwise, Unmarshal unmarshals the JSON into the value pointed at\n    by the pointer. If the pointer is nil, Unmarshal allocates a new value for\n    it to point to.\n\n    To unmarshal JSON into a value implementing Unmarshaler, Unmarshal\n    calls that value's [Unmarshaler.UnmarshalJSON] method, including\n    when the input is a JSON null. Otherwise, if the value implements\n    encoding.TextUnmarshaler and the input is a JSON quoted string, Unmarshal\n    calls encoding.TextUnmarshaler.UnmarshalText with the unquoted form of the\n    string.\n\n    To unmarshal JSON into a struct, Unmarshal matches incoming object keys\n    to the keys used by Marshal (either the struct field name or its tag),\n    ignoring case. If multiple struct fields match an object key, an exact case\n    match is preferred over a case-insensitive one.\n\n    Incoming object members are processed in the order observed. If an object\n    includes duplicate keys, later duplicates will replace or be merged into\n    prior values.\n\n    To unmarshal JSON into an interface value, Unmarshal stores one of these in\n    the interface value:\n\n      - bool, for JSON booleans\n      - float64, for JSON numbers\n      - string, for JSON strings\n      - []any, for JSON arrays\n      - map[string]any, for JSON objects\n      - nil for JSON null\n\n    To unmarshal a JSON array into a slice, Unmarshal resets the slice length\n    to zero and then appends each element to the slice. As a special case,\n    to unmarshal an empty JSON array into a slice, Unmarshal replaces the slice\n    with a new empty slice.\n\n    To unmarshal a JSON array into a Go array, Unmarshal decodes JSON array\n    elements into corresponding Go array elements. If the Go array is smaller\n    than the JSON array, the additional JSON array elements are discarded.\n    If the JSON array is smaller than the Go array, the additional Go array\n    elements are set to zero values.\n\n    To unmarshal a JSON object into a map, Unmarshal first establishes\n    a map to use. If the map is nil, Unmarshal allocates a new map.\n    Otherwise Unmarshal reuses the existing map, keeping existing entries.\n    Unmarshal then stores key-value pairs from the JSON object into the map.\n    The map's key type must either be any string type, an integer, or implement\n    encoding.TextUnmarshaler.\n\n    If the JSON-encoded data contain a syntax error, Unmarshal returns a\n    SyntaxError.\n\n    If a JSON value is not appropriate for a given target type, or if a JSON\n    number overflows the target type, Unmarshal skips that field and completes\n    the unmarshaling as best it can. If no more serious errors are encountered,\n    Unmarshal returns an UnmarshalTypeError describing the earliest such error.\n    In any case, it's not guaranteed that all the remaining fields following the\n    problematic one will be unmarshaled into the target object.\n\n    The JSON null value unmarshals into an interface, map, pointer, or slice\n    by setting that Go value to nil. Because null is often used in JSON to mean\n    \u201cnot present,\u201d unmarshaling a JSON null into any other Go type has no effect\n    on the value and produces no error.\n\n    When unmarshaling quoted strings, invalid UTF-8 or invalid UTF-16 surrogate\n    pairs are not treated as an error. Instead, they are replaced by the Unicode\n    replacement character U+FFFD.\n\nfunc Valid(data []byte) bool\n    Valid reports whether data is a valid JSON encoding.\n\n\nTYPES\n\ntype Decoder struct {\n\t// Has unexported fields.\n}\n    A Decoder reads and decodes JSON values from an input stream.\n\nfunc NewDecoder(r io.Reader) *Decoder\n    NewDecoder returns a new decoder that reads from r.\n\n    The decoder introduces its own buffering and may read data from r beyond the\n    JSON values requested.\n\nfunc (dec *Decoder) Buffered() io.Reader\n    Buffered returns a reader of the data remaining in the Decoder's buffer.\n    The reader is valid until the next call to Decoder.Decode.\n\nfunc (dec *Decoder) Decode(v any) error\n    Decode reads the next JSON-encoded value from its input and stores it in the\n    value pointed to by v.\n\n    See the documentation for Unmarshal for details about the conversion of JSON\n    into a Go value.\n\nfunc (dec *Decoder) DisallowUnknownFields()\n    DisallowUnknownFields causes the Decoder to return an error when the\n    destination is a struct and the input contains object keys which do not\n    match any non-ignored, exported fields in the destination.\n\nfunc (dec *Decoder) InputOffset() int64\n    InputOffset returns the input stream byte offset of the current decoder\n    position. The offset gives the location of the end of the most recently\n    returned token and the beginning of the next token.\n\nfunc (dec *Decoder) More() bool\n    More reports whether there is another element in the current array or object\n    being parsed.\n\nfunc (dec *Decoder) Token() (Token, error)\n    Token returns the next JSON token in the input stream. At the end of the\n    input stream, Token returns nil, io.EOF.\n\n    Token guarantees that the delimiters [ ] { } it returns are properly nested\n    and matched: if Token encounters an unexpected delimiter in the input,\n    it will return an error.\n\n    The input stream consists of basic JSON values\u2014bool, string, number,\n    and null\u2014along with delimiters [ ] { } of type Delim to mark the start and\n    end of arrays and objects. Commas and colons are elided.\n\nfunc (dec *Decoder) UseNumber()\n    UseNumber causes the Decoder to unmarshal a number into an interface value\n    as a Number instead of as a float64.\n\ntype Delim rune\n    A Delim is a JSON array or object delimiter, one of [ ] { or }.\n\nfunc (d Delim) String() string\n\ntype Encoder struct {\n\t// Has unexported fields.\n}\n    An Encoder writes JSON values to an output stream.\n\nfunc NewEncoder(w io.Writer) *Encoder\n    NewEncoder returns a new encoder that writes to w.\n\nfunc (enc *Encoder) Encode(v any) error\n    Encode writes the JSON encoding of v to the stream, with insignificant space\n    characters elided, followed by a newline character.\n\n    See the documentation for Marshal for details about the conversion of Go\n    values to JSON.\n\nfunc (enc *Encoder) SetEscapeHTML(on bool)\n    SetEscapeHTML specifies whether problematic HTML characters should be\n    escaped inside JSON quoted strings. The default behavior is to escape &, <,\n    and > to \\u0026, \\u003c, and \\u003e to avoid certain safety problems that\n    can arise when embedding JSON in HTML.\n\n    In non-HTML settings where the escaping interferes with the readability of\n    the output, SetEscapeHTML(false) disables this behavior.\n\nfunc (enc *Encoder) SetIndent(prefix, indent string)\n    SetIndent instructs the encoder to format each subsequent encoded value as\n    if indented by the package-level function Indent(dst, src, prefix, indent).\n    Calling SetIndent(\"\", \"\") disables indentation.\n\ntype InvalidUTF8Error struct {\n\tS string // the whole string value that caused the error\n}\n    Before Go 1.2, an InvalidUTF8Error was returned by Marshal when attempting\n    to encode a string value with invalid UTF-8 sequences. As of Go 1.2,\n    Marshal instead coerces the string to valid UTF-8 by replacing invalid bytes\n    with the Unicode replacement rune U+FFFD.\n\n    Deprecated: No longer used; kept for compatibility.\n\nfunc (e *InvalidUTF8Error) Error() string\n\ntype InvalidUnmarshalError struct {\n\tType reflect.Type\n}\n    An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.\n    (The argument to Unmarshal must be a non-nil pointer.)\n\nfunc (e *InvalidUnmarshalError) Error() string\n\ntype Marshaler interface {\n\tMarshalJSON() ([]byte, error)\n}\n    Marshaler is the interface implemented by types that can marshal themselves\n    into valid JSON.\n\ntype MarshalerError struct {\n\tType reflect.Type\n\tErr  error\n\t// Has unexported fields.\n}\n    A MarshalerError represents an error from calling a [Marshaler.MarshalJSON]\n    or encoding.TextMarshaler.MarshalText method.\n\nfunc (e *MarshalerError) Error() string\n\nfunc (e *MarshalerError) Unwrap() error\n    Unwrap returns the underlying error.\n\ntype Number string\n    A Number represents a JSON number literal.\n\nfunc (n Number) Float64() (float64, error)\n    Float64 returns the number as a float64.\n\nfunc (n Number) Int64() (int64, error)\n    Int64 returns the number as an int64.\n\nfunc (n Number) String() string\n    String returns the literal text of the number.\n\ntype RawMessage []byte\n    RawMessage is a raw encoded JSON value. It implements Marshaler and\n    Unmarshaler and can be used to delay JSON decoding or precompute a JSON\n    encoding.\n\nfunc (m RawMessage) MarshalJSON() ([]byte, error)\n    MarshalJSON returns m as the JSON encoding of m.\n\nfunc (m *RawMessage) UnmarshalJSON(data []byte) error\n    UnmarshalJSON sets *m to a copy of data.\n\ntype SyntaxError struct {\n\tOffset int64 // error occurred after reading Offset bytes\n\t// Has unexported fields.\n}\n    A SyntaxError is a description of a JSON syntax error. Unmarshal will return\n    a SyntaxError if the JSON can't be parsed.\n\nfunc (e *SyntaxError) Error() string\n\ntype Token any\n    A Token holds a value of one of these types:\n\n      - Delim, for the four JSON delimiters [ ] { }\n      - bool, for JSON booleans\n      - float64, for JSON numbers\n      - Number, for JSON numbers\n      - string, for JSON string literals\n      - nil, for JSON null\n\ntype UnmarshalFieldError struct {\n\tKey   string\n\tType  reflect.Type\n\tField reflect.StructField\n}\n    An UnmarshalFieldError describes a JSON object key that led to an unexported\n    (and therefore unwritable) struct field.\n\n    Deprecated: No longer used; kept for compatibility.\n\nfunc (e *UnmarshalFieldError) Error() string\n\ntype UnmarshalTypeError struct {\n\tValue  string       // description of JSON value - \"bool\", \"array\", \"number -5\"\n\tType   reflect.Type // type of Go value it could not be assigned to\n\tOffset int64        // error occurred after reading Offset bytes\n\tStruct string       // name of the struct type containing the field\n\tField  string       // the full path from root node to the field, include embedded struct\n}\n    An UnmarshalTypeError describes a JSON value that was not appropriate for a\n    value of a specific Go type.\n\nfunc (e *UnmarshalTypeError) Error() string\n\ntype Unmarshaler interface {\n\tUnmarshalJSON([]byte) error\n}\n    Unmarshaler is the interface implemented by types that can unmarshal a JSON\n    description of themselves. The input can be assumed to be a valid encoding\n    of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to\n    retain the data after returning.\n\ntype UnsupportedTypeError struct {\n\tType reflect.Type\n}\n    An UnsupportedTypeError is returned by Marshal when attempting to encode an\n    unsupported value type.\n\nfunc (e *UnsupportedTypeError) Error() string\n\ntype UnsupportedValueError struct {\n\tValue reflect.Value\n\tStr   string\n}\n    An UnsupportedValueError is returned by Marshal when attempting to encode an\n    unsupported value.\n\nfunc (e *UnsupportedValueError) Error() string\n\n"}, {"path": "stdlib/reflect-internal-example2.md", "category": "stdlib", "name": "stdlib/reflect-internal-example2", "content": "package example2 // import \"reflect/internal/example2\"\n\n\nTYPES\n\ntype MyStruct struct {\n\tMyStructs []MyStruct\n\tMyStruct  *MyStruct\n}\n\n"}, {"path": "stdlib/encoding-ascii85.md", "category": "stdlib", "name": "stdlib/encoding-ascii85", "content": "package ascii85 // import \"encoding/ascii85\"\n\nPackage ascii85 implements the ascii85 data encoding as used in the btoa tool\nand Adobe's PostScript and PDF document formats.\n\nFUNCTIONS\n\nfunc Decode(dst, src []byte, flush bool) (ndst, nsrc int, err error)\n    Decode decodes src into dst, returning both the number of bytes written to\n    dst and the number consumed from src. If src contains invalid ascii85 data,\n    Decode will return the number of bytes successfully written and a\n    CorruptInputError. Decode ignores space and control characters in src.\n    Often, ascii85-encoded data is wrapped in <~ and ~> symbols. Decode expects\n    these to have been stripped by the caller.\n\n    If flush is true, Decode assumes that src represents the end of the input\n    stream and processes it completely rather than wait for the completion of\n    another 32-bit block.\n\n    NewDecoder wraps an io.Reader interface around Decode.\n\nfunc Encode(dst, src []byte) int\n    Encode encodes src into at most MaxEncodedLen(len(src)) bytes of dst,\n    returning the actual number of bytes written.\n\n    The encoding handles 4-byte chunks, using a special encoding for the last\n    fragment, so Encode is not appropriate for use on individual blocks of a\n    large data stream. Use NewEncoder instead.\n\n    Often, ascii85-encoded data is wrapped in <~ and ~> symbols. Encode does not\n    add these.\n\nfunc MaxEncodedLen(n int) int\n    MaxEncodedLen returns the maximum length of an encoding of n source bytes.\n\nfunc NewDecoder(r io.Reader) io.Reader\n    NewDecoder constructs a new ascii85 stream decoder.\n\nfunc NewEncoder(w io.Writer) io.WriteCloser\n    NewEncoder returns a new ascii85 stream encoder. Data written to the\n    returned writer will be encoded and then written to w. Ascii85 encodings\n    operate in 32-bit blocks; when finished writing, the caller must Close the\n    returned encoder to flush any trailing partial block.\n\n\nTYPES\n\ntype CorruptInputError int64\n\nfunc (e CorruptInputError) Error() string\n\n"}, {"path": "stdlib/math-big.md", "category": "stdlib", "name": "stdlib/math-big", "content": "package big // import \"math/big\"\n\nPackage big implements arbitrary-precision arithmetic (big numbers). The\nfollowing numeric types are supported:\n\n    Int    signed integers\n    Rat    rational numbers\n    Float  floating-point numbers\n\nThe zero value for an Int, Rat, or Float correspond to 0. Thus, new values can\nbe declared in the usual ways and denote 0 without further initialization:\n\n    var x Int        // &x is an *Int of value 0\n    var r = &Rat{}   // r is a *Rat of value 0\n    y := new(Float)  // y is a *Float of value 0\n\nAlternatively, new values can be allocated and initialized with factory\nfunctions of the form:\n\n    func NewT(v V) *T\n\nFor instance, NewInt(x) returns an *Int set to the value of the int64 argument\nx, NewRat(a, b) returns a *Rat set to the fraction a/b where a and b are int64\nvalues, and NewFloat(f) returns a *Float initialized to the float64 argument f.\nMore flexibility is provided with explicit setters, for instance:\n\n    var z1 Int\n    z1.SetUint64(123)                 // z1 := 123\n    z2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4\n    z3 := new(Float).SetInt(z1)       // z3 := 123.0\n\nSetters, numeric operations and predicates are represented as methods of the\nform:\n\n    func (z *T) SetV(v V) *T          // z = v\n    func (z *T) Unary(x *T) *T        // z = unary x\n    func (z *T) Binary(x, y *T) *T    // z = x binary y\n    func (x *T) Pred() P              // p = pred(x)\n\nwith T one of Int, Rat, or Float. For unary and binary operations, the result\nis the receiver (usually named z in that case; see below); if it is one of the\noperands x or y it may be safely overwritten (and its memory reused).\n\nArithmetic expressions are typically written as a sequence of individual method\ncalls, with each call corresponding to an operation. The receiver denotes the\nresult and the method arguments are the operation's operands. For instance,\ngiven three *Int values a, b and c, the invocation\n\n    c.Add(a, b)\n\ncomputes the sum a + b and stores the result in c, overwriting whatever value\nwas held in c before. Unless specified otherwise, operations permit aliasing of\nparameters, so it is perfectly ok to write\n\n    sum.Add(sum, x)\n\nto accumulate values x in a sum.\n\n(By always passing in a result value via the receiver, memory use can be much\nbetter controlled. Instead of having to allocate new memory for each result,\nan operation can reuse the space allocated for the result value, and overwrite\nthat value with the new result in the process.)\n\nNotational convention: Incoming method parameters (including the receiver)\nare named consistently in the API to clarify their use. Incoming operands are\nusually named x, y, a, b, and so on, but never z. A parameter specifying the\nresult is named z (typically the receiver).\n\nFor instance, the arguments for (*Int).Add are named x and y, and because the\nreceiver specifies the result destination, it is called z:\n\n    func (z *Int) Add(x, y *Int) *Int\n\nMethods of this form typically return the incoming receiver as well, to enable\nsimple call chaining.\n\nMethods which don't require a result value to be passed in (for instance,\nInt.Sign), simply return the result. In this case, the receiver is typically the\nfirst operand, named x:\n\n    func (x *Int) Sign() int\n\nVarious methods support conversions between strings and corresponding numeric\nvalues, and vice versa: *Int, *Rat, and *Float values implement the Stringer\ninterface for a (default) string representation of the value, but also provide\nSetString methods to initialize a value from a string in a variety of supported\nformats (see the respective SetString documentation).\n\nFinally, *Int, *Rat, and *Float satisfy fmt.Scanner for scanning and (except for\n*Rat) the Formatter interface for formatted printing.\n\nCONSTANTS\n\nconst (\n\tMaxExp  = math.MaxInt32  // largest supported exponent\n\tMinExp  = math.MinInt32  // smallest supported exponent\n\tMaxPrec = math.MaxUint32 // largest (theoretically) supported precision; likely memory-limited\n)\n    Exponent and precision limits.\n\nconst MaxBase = 10 + ('z' - 'a' + 1) + ('Z' - 'A' + 1)\n    MaxBase is the largest number base accepted for string conversions.\n\n\nFUNCTIONS\n\nfunc Jacobi(x, y *Int) int\n    Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0. The y argument\n    must be an odd integer.\n\nfunc ParseFloat(s string, base int, prec uint, mode RoundingMode) (f *Float, b int, err error)\n    ParseFloat is like f.Parse(s, base) with f set to the given precision and\n    rounding mode.\n\n\nTYPES\n\ntype Accuracy int8\n    Accuracy describes the rounding error produced by the most recent operation\n    that generated a Float value, relative to the exact value.\n\nconst (\n\tBelow Accuracy = -1\n\tExact Accuracy = 0\n\tAbove Accuracy = +1\n)\n    Constants describing the Accuracy of a Float.\n\nfunc (i Accuracy) String() string\n\ntype ErrNaN struct {\n\t// Has unexported fields.\n}\n    An ErrNaN panic is raised by a Float operation that would lead to a NaN\n    under IEEE 754 rules. An ErrNaN implements the error interface.\n\nfunc (err ErrNaN) Error() string\n\ntype Float struct {\n\t// Has unexported fields.\n}\n    A nonzero finite Float represents a multi-precision floating point number\n\n        sign \u00d7 mantissa \u00d7 2**exponent\n\n    with 0.5 <= mantissa < 1.0, and MinExp <= exponent <= MaxExp. A Float may\n    also be zero (+0, -0) or infinite (+Inf, -Inf). All Floats are ordered,\n    and the ordering of two Floats x and y is defined by x.Cmp(y).\n\n    Each Float value also has a precision, rounding mode, and accuracy.\n    The precision is the maximum number of mantissa bits available to represent\n    the value. The rounding mode specifies how a result should be rounded to\n    fit into the mantissa bits, and accuracy describes the rounding error with\n    respect to the exact result.\n\n    Unless specified otherwise, all operations (including setters) that\n    specify a *Float variable for the result (usually via the receiver with\n    the exception of Float.MantExp), round the numeric result according to the\n    precision and rounding mode of the result variable.\n\n    If the provided result precision is 0 (see below), it is set to the\n    precision of the argument with the largest precision value before any\n    rounding takes place, and the rounding mode remains unchanged. Thus,\n    uninitialized Floats provided as result arguments will have their precision\n    set to a reasonable value determined by the operands, and their mode is the\n    zero value for RoundingMode (ToNearestEven).\n\n    By setting the desired precision to 24 or 53 and using matching rounding\n    mode (typically ToNearestEven), Float operations produce the same results\n    as the corresponding float32 or float64 IEEE 754 arithmetic for operands\n    that correspond to normal (i.e., not denormal) float32 or float64 numbers.\n    Exponent underflow and overflow lead to a 0 or an Infinity for different\n    values than IEEE 754 because Float exponents have a much larger range.\n\n    The zero (uninitialized) value for a Float is ready to use and represents\n    the number +0.0 exactly, with precision 0 and rounding mode ToNearestEven.\n\n    Operations always take pointer arguments (*Float) rather than Float values,\n    and each unique Float value requires its own unique *Float pointer.\n    To \"copy\" a Float value, an existing (or newly allocated) Float must be set\n    to a new value using the Float.Set method; shallow copies of Floats are not\n    supported and may lead to errors.\n\nfunc NewFloat(x float64) *Float\n    NewFloat allocates and returns a new Float set to x, with precision 53 and\n    rounding mode ToNearestEven. NewFloat panics with ErrNaN if x is a NaN.\n\nfunc (z *Float) Abs(x *Float) *Float\n    Abs sets z to the (possibly rounded) value |x| (the absolute value of x) and\n    returns z.\n\nfunc (x *Float) Acc() Accuracy\n    Acc returns the accuracy of x produced by the most recent operation,\n    unless explicitly documented otherwise by that operation.\n\nfunc (z *Float) Add(x, y *Float) *Float\n    Add sets z to the rounded sum x+y and returns z. If z's precision is 0,\n    it is changed to the larger of x's or y's precision before the operation.\n    Rounding is performed according to z's precision and rounding mode; and\n    z's accuracy reports the result error relative to the exact (not rounded)\n    result. Add panics with ErrNaN if x and y are infinities with opposite\n    signs. The value of z is undefined in that case.\n\nfunc (x *Float) Append(buf []byte, fmt byte, prec int) []byte\n    Append appends to buf the string form of the floating-point number x,\n    as generated by x.Text, and returns the extended buffer.\n\nfunc (x *Float) AppendText(b []byte) ([]byte, error)\n    AppendText implements the encoding.TextAppender interface. Only the Float\n    value is marshaled (in full precision), other attributes such as precision\n    or accuracy are ignored.\n\nfunc (x *Float) Cmp(y *Float) int\n    Cmp compares x and y and returns:\n      - -1 if x < y;\n      - 0 if x == y (incl. -0 == 0, -Inf == -Inf, and +Inf == +Inf);\n      - +1 if x > y.\n\nfunc (z *Float) Copy(x *Float) *Float\n    Copy sets z to x, with the same precision, rounding mode, and accuracy as x.\n    Copy returns z. If x and z are identical, Copy is a no-op.\n\nfunc (x *Float) Float32() (float32, Accuracy)\n    Float32 returns the float32 value nearest to x. If x is too small to be\n    represented by a float32 (|x| < math.SmallestNonzeroFloat32), the result\n    is (0, Below) or (-0, Above), respectively, depending on the sign of x.\n    If x is too large to be represented by a float32 (|x| > math.MaxFloat32),\n    the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.\n\nfunc (x *Float) Float64() (float64, Accuracy)\n    Float64 returns the float64 value nearest to x. If x is too small to be\n    represented by a float64 (|x| < math.SmallestNonzeroFloat64), the result\n    is (0, Below) or (-0, Above), respectively, depending on the sign of x.\n    If x is too large to be represented by a float64 (|x| > math.MaxFloat64),\n    the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.\n\nfunc (x *Float) Format(s fmt.State, format rune)\n    Format implements fmt.Formatter. It accepts all the regular formats for\n    floating-point numbers ('b', 'e', 'E', 'f', 'F', 'g', 'G', 'x') as well as\n    'p' and 'v'. See (*Float).Text for the interpretation of 'p'. The 'v' format\n    is handled like 'g'. Format also supports specification of the minimum\n    precision in digits, the output field width, as well as the format flags '+'\n    and ' ' for sign control, '0' for space or zero padding, and '-' for left or\n    right justification. See the fmt package for details.\n\nfunc (z *Float) GobDecode(buf []byte) error\n    GobDecode implements the encoding/gob.GobDecoder interface. The result is\n    rounded per the precision and rounding mode of z unless z's precision is 0,\n    in which case z is set exactly to the decoded value.\n\nfunc (x *Float) GobEncode() ([]byte, error)\n    GobEncode implements the encoding/gob.GobEncoder interface. The Float value\n    and all its attributes (precision, rounding mode, accuracy) are marshaled.\n\nfunc (x *Float) Int(z *Int) (*Int, Accuracy)\n    Int returns the result of truncating x towards zero; or nil if x is an\n    infinity. The result is Exact if x.IsInt(); otherwise it is Below for x > 0,\n    and Above for x < 0. If a non-nil *Int argument z is provided, Int stores\n    the result in z instead of allocating a new Int.\n\nfunc (x *Float) Int64() (int64, Accuracy)\n    Int64 returns the integer resulting from truncating x towards zero. If\n    math.MinInt64 <= x <= math.MaxInt64, the result is Exact if x is an integer,\n    and Above (x < 0) or Below (x > 0) otherwise. The result is (math.MinInt64,\n    Above) for x < math.MinInt64, and (math.MaxInt64, Below) for x >\n    math.MaxInt64.\n\nfunc (x *Float) IsInf() bool\n    IsInf reports whether x is +Inf or -Inf.\n\nfunc (x *Float) IsInt() bool\n    IsInt reports whether x is an integer. \u00b1Inf values are not integers.\n\nfunc (x *Float) MantExp(mant *Float) (exp int)\n    MantExp breaks x into its mantissa and exponent components and returns\n    the exponent. If a non-nil mant argument is provided its value is set\n    to the mantissa of x, with the same precision and rounding mode as x.\n    The components satisfy x == mant \u00d7 2**exp, with 0.5 <= |mant| < 1.0.\n    Calling MantExp with a nil argument is an efficient way to get the exponent\n    of the receiver.\n\n    Special cases are:\n\n        (  \u00b10).MantExp(mant) = 0, with mant set to   \u00b10\n        (\u00b1Inf).MantExp(mant) = 0, with mant set to \u00b1Inf\n\n    x and mant may be the same in which case x is set to its mantissa value.\n\nfunc (x *Float) MarshalText() (text []byte, err error)\n    MarshalText implements the encoding.TextMarshaler interface. Only the Float\n    value is marshaled (in full precision), other attributes such as precision\n    or accuracy are ignored.\n\nfunc (x *Float) MinPrec() uint\n    MinPrec returns the minimum precision required to represent x exactly (i.e.,\n    the smallest prec before x.SetPrec(prec) would start rounding x). The result\n    is 0 for |x| == 0 and |x| == Inf.\n\nfunc (x *Float) Mode() RoundingMode\n    Mode returns the rounding mode of x.\n\nfunc (z *Float) Mul(x, y *Float) *Float\n    Mul sets z to the rounded product x*y and returns z. Precision, rounding,\n    and accuracy reporting are as for Float.Add. Mul panics with ErrNaN if\n    one operand is zero and the other operand an infinity. The value of z is\n    undefined in that case.\n\nfunc (z *Float) Neg(x *Float) *Float\n    Neg sets z to the (possibly rounded) value of x with its sign negated,\n    and returns z.\n\nfunc (z *Float) Parse(s string, base int) (f *Float, b int, err error)\n    Parse parses s which must contain a text representation of a floating- point\n    number with a mantissa in the given conversion base (the exponent is always\n    a decimal number), or a string representing an infinite value.\n\n    For base 0, an underscore character \u201c_\u201d may appear between a base prefix\n    and an adjacent digit, and between successive digits; such underscores do\n    not change the value of the number, or the returned digit count. Incorrect\n    placement of underscores is reported as an error if there are no other\n    errors. If base != 0, underscores are not recognized and thus terminate\n    scanning like any other character that is not a valid radix point or digit.\n\n    It sets z to the (possibly rounded) value of the corresponding floating-\n    point value, and returns z, the actual base b, and an error err, if any.\n    The entire string (not just a prefix) must be consumed for success.\n    If z's precision is 0, it is changed to 64 before rounding takes effect.\n    The number must be of the form:\n\n        number    = [ sign ] ( float | \"inf\" | \"Inf\" ) .\n        sign      = \"+\" | \"-\" .\n        float     = ( mantissa | prefix pmantissa ) [ exponent ] .\n        prefix    = \"0\" [ \"b\" | \"B\" | \"o\" | \"O\" | \"x\" | \"X\" ] .\n        mantissa  = digits \".\" [ digits ] | digits | \".\" digits .\n        pmantissa = [ \"_\" ] digits \".\" [ digits ] | [ \"_\" ] digits | \".\" digits .\n        exponent  = ( \"e\" | \"E\" | \"p\" | \"P\" ) [ sign ] digits .\n        digits    = digit { [ \"_\" ] digit } .\n        digit     = \"0\" ... \"9\" | \"a\" ... \"z\" | \"A\" ... \"Z\" .\n\n    The base argument must be 0, 2, 8, 10, or 16. Providing an invalid base\n    argument will lead to a run-time panic.\n\n    For base 0, the number prefix determines the actual base: A prefix of\n    \u201c0b\u201d or \u201c0B\u201d selects base 2, \u201c0o\u201d or \u201c0O\u201d selects base 8, and \u201c0x\u201d or \u201c0X\u201d\n    selects base 16. Otherwise, the actual base is 10 and no prefix is accepted.\n    The octal prefix \"0\" is not supported (a leading \"0\" is simply considered a\n    \"0\").\n\n    A \"p\" or \"P\" exponent indicates a base 2 (rather than base 10) exponent;\n    for instance, \"0x1.fffffffffffffp1023\" (using base 0) represents the maximum\n    float64 value. For hexadecimal mantissae, the exponent character must be\n    one of 'p' or 'P', if present (an \"e\" or \"E\" exponent indicator cannot be\n    distinguished from a mantissa digit).\n\n    The returned *Float f is nil and the value of z is valid but not defined if\n    an error is reported.\n\nfunc (x *Float) Prec() uint\n    Prec returns the mantissa precision of x in bits. The result may be 0 for\n    |x| == 0 and |x| == Inf.\n\nfunc (z *Float) Quo(x, y *Float) *Float\n    Quo sets z to the rounded quotient x/y and returns z. Precision, rounding,\n    and accuracy reporting are as for Float.Add. Quo panics with ErrNaN if both\n    operands are zero or infinities. The value of z is undefined in that case.\n\nfunc (x *Float) Rat(z *Rat) (*Rat, Accuracy)\n    Rat returns the rational number corresponding to x; or nil if x is an\n    infinity. The result is Exact if x is not an Inf. If a non-nil *Rat argument\n    z is provided, Rat stores the result in z instead of allocating a new Rat.\n\nfunc (z *Float) Scan(s fmt.ScanState, ch rune) error\n    Scan is a support routine for fmt.Scanner; it sets z to the value of the\n    scanned number. It accepts formats whose verbs are supported by fmt.Scan\n    for floating point values, which are: 'b' (binary), 'e', 'E', 'f', 'F',\n    'g' and 'G'. Scan doesn't handle \u00b1Inf.\n\nfunc (z *Float) Set(x *Float) *Float\n    Set sets z to the (possibly rounded) value of x and returns z. If z's\n    precision is 0, it is changed to the precision of x before setting z (and\n    rounding will have no effect). Rounding is performed according to z's\n    precision and rounding mode; and z's accuracy reports the result error\n    relative to the exact (not rounded) result.\n\nfunc (z *Float) SetFloat64(x float64) *Float\n    SetFloat64 sets z to the (possibly rounded) value of x and returns z. If\n    z's precision is 0, it is changed to 53 (and rounding will have no effect).\n    SetFloat64 panics with ErrNaN if x is a NaN.\n\nfunc (z *Float) SetInf(signbit bool) *Float\n    SetInf sets z to the infinite Float -Inf if signbit is set, or +Inf if\n    signbit is not set, and returns z. The precision of z is unchanged and the\n    result is always Exact.\n\nfunc (z *Float) SetInt(x *Int) *Float\n    SetInt sets z to the (possibly rounded) value of x and returns z.\n    If z's precision is 0, it is changed to the larger of x.BitLen() or 64 (and\n    rounding will have no effect).\n\nfunc (z *Float) SetInt64(x int64) *Float\n    SetInt64 sets z to the (possibly rounded) value of x and returns z. If z's\n    precision is 0, it is changed to 64 (and rounding will have no effect).\n\nfunc (z *Float) SetMantExp(mant *Float, exp int) *Float\n    SetMantExp sets z to mant \u00d7 2**exp and returns z. The result z has the\n    same precision and rounding mode as mant. SetMantExp is an inverse of\n    Float.MantExp but does not require 0.5 <= |mant| < 1.0. Specifically, for a\n    given x of type *Float, SetMantExp relates to Float.MantExp as follows:\n\n        mant := new(Float)\n        new(Float).SetMantExp(mant, x.MantExp(mant)).Cmp(x) == 0\n\n    Special cases are:\n\n        z.SetMantExp(  \u00b10, exp) =   \u00b10\n        z.SetMantExp(\u00b1Inf, exp) = \u00b1Inf\n\n    z and mant may be the same in which case z's exponent is set to exp.\n\nfunc (z *Float) SetMode(mode RoundingMode) *Float\n    SetMode sets z's rounding mode to mode and returns an exact z. z remains\n    unchanged otherwise. z.SetMode(z.Mode()) is a cheap way to set z's accuracy\n    to Exact.\n\nfunc (z *Float) SetPrec(prec uint) *Float\n    SetPrec sets z's precision to prec and returns the (possibly) rounded value\n    of z. Rounding occurs according to z's rounding mode if the mantissa cannot\n    be represented in prec bits without loss of precision. SetPrec(0) maps all\n    finite values to \u00b10; infinite values remain unchanged. If prec > MaxPrec,\n    it is set to MaxPrec.\n\nfunc (z *Float) SetRat(x *Rat) *Float\n    SetRat sets z to the (possibly rounded) value of x and returns z. If z's\n    precision is 0, it is changed to the largest of a.BitLen(), b.BitLen(),\n    or 64; with x = a/b.\n\nfunc (z *Float) SetString(s string) (*Float, bool)\n    SetString sets z to the value of s and returns z and a boolean indicating\n    success. s must be a floating-point number of the same format as accepted\n    by Float.Parse, with base argument 0. The entire string (not just a prefix)\n    must be valid for success. If the operation failed, the value of z is\n    undefined but the returned value is nil.\n\nfunc (z *Float) SetUint64(x uint64) *Float\n    SetUint64 sets z to the (possibly rounded) value of x and returns z. If z's\n    precision is 0, it is changed to 64 (and rounding will have no effect).\n\nfunc (x *Float) Sign() int\n    Sign returns:\n      - -1 if x < 0;\n      - 0 if x is \u00b10;\n      - +1 if x > 0.\n\nfunc (x *Float) Signbit() bool\n    Signbit reports whether x is negative or negative zero.\n\nfunc (z *Float) Sqrt(x *Float) *Float\n    Sqrt sets z to the rounded square root of x, and returns it.\n\n    If z's precision is 0, it is changed to x's precision before the operation.\n    Rounding is performed according to z's precision and rounding mode, but z's\n    accuracy is not computed. Specifically, the result of z.Acc() is undefined.\n\n    The function panics if z < 0. The value of z is undefined in that case.\n\nfunc (x *Float) String() string\n    String formats x like x.Text('g', 10). (String must be called explicitly,\n    Float.Format does not support %s verb.)\n\nfunc (z *Float) Sub(x, y *Float) *Float\n    Sub sets z to the rounded difference x-y and returns z. Precision, rounding,\n    and accuracy reporting are as for Float.Add. Sub panics with ErrNaN if x and\n    y are infinities with equal signs. The value of z is undefined in that case.\n\nfunc (x *Float) Text(format byte, prec int) string\n    Text converts the floating-point number x to a string according to the given\n    format and precision prec. The format is one of:\n\n        'e'\t-d.dddde\u00b1dd, decimal exponent, at least two (possibly 0) exponent digits\n        'E'\t-d.ddddE\u00b1dd, decimal exponent, at least two (possibly 0) exponent digits\n        'f'\t-ddddd.dddd, no exponent\n        'g'\tlike 'e' for large exponents, like 'f' otherwise\n        'G'\tlike 'E' for large exponents, like 'f' otherwise\n        'x'\t-0xd.dddddp\u00b1dd, hexadecimal mantissa, decimal power of two exponent\n        'p'\t-0x.dddp\u00b1dd, hexadecimal mantissa, decimal power of two exponent (non-standard)\n        'b'\t-ddddddp\u00b1dd, decimal mantissa, decimal power of two exponent (non-standard)\n\n    For the power-of-two exponent formats, the mantissa is printed in normalized\n    form:\n\n        'x'\thexadecimal mantissa in [1, 2), or 0\n        'p'\thexadecimal mantissa in [\u00bd, 1), or 0\n        'b'\tdecimal integer mantissa using x.Prec() bits, or 0\n\n    Note that the 'x' form is the one used by most other languages and\n    libraries.\n\n    If format is a different character, Text returns a \"%\" followed by the\n    unrecognized format character.\n\n    The precision prec controls the number of digits (excluding the exponent)\n    printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats. For 'e', 'E',\n    'f', and 'x', it is the number of digits after the decimal point. For 'g'\n    and 'G' it is the total number of digits. A negative precision selects the\n    smallest number of decimal digits necessary to identify the value x uniquely\n    using x.Prec() mantissa bits. The prec value is ignored for the 'b' and 'p'\n    formats.\n\nfunc (x *Float) Uint64() (uint64, Accuracy)\n    Uint64 returns the unsigned integer resulting from truncating x towards\n    zero. If 0 <= x <= math.MaxUint64, the result is Exact if x is an\n    integer and Below otherwise. The result is (0, Above) for x < 0, and\n    (math.MaxUint64, Below) for x > math.MaxUint64.\n\nfunc (z *Float) UnmarshalText(text []byte) error\n    UnmarshalText implements the encoding.TextUnmarshaler interface. The result\n    is rounded per the precision and rounding mode of z. If z's precision is 0,\n    it is changed to 64 before rounding takes effect.\n\ntype Int struct {\n\t// Has unexported fields.\n}\n    An Int represents a signed multi-precision integer. The zero value for an\n    Int represents the value 0.\n\n    Operations always take pointer arguments (*Int) rather than Int values,\n    and each unique Int value requires its own unique *Int pointer. To \"copy\" an\n    Int value, an existing (or newly allocated) Int must be set to a new value\n    using the Int.Set method; shallow copies of Ints are not supported and may\n    lead to errors.\n\n    Note that methods may leak the Int's value through timing side-channels.\n    Because of this and because of the scope and complexity of the\n    implementation, Int is not well-suited to implement cryptographic\n    operations. The standard library avoids exposing non-trivial Int methods\n    to attacker-controlled inputs and the determination of whether a bug in\n    math/big is considered a security vulnerability might depend on the impact\n    on the standard library.\n\nfunc NewInt(x int64) *Int\n    NewInt allocates and returns a new Int set to x.\n\nfunc (z *Int) Abs(x *Int) *Int\n    Abs sets z to |x| (the absolute value of x) and returns z.\n\nfunc (z *Int) Add(x, y *Int) *Int\n    Add sets z to the sum x+y and returns z.\n\nfunc (z *Int) And(x, y *Int) *Int\n    And sets z = x & y and returns z.\n\nfunc (z *Int) AndNot(x, y *Int) *Int\n    AndNot sets z = x &^ y and returns z.\n\nfunc (x *Int) Append(buf []byte, base int) []byte\n    Append appends the string representation of x, as generated by x.Text(base),\n    to buf and returns the extended buffer.\n\nfunc (x *Int) AppendText(b []byte) (text []byte, err error)\n    AppendText implements the encoding.TextAppender interface.\n\nfunc (z *Int) Binomial(n, k int64) *Int\n    Binomial sets z to the binomial coefficient C(n, k) and returns z.\n\nfunc (x *Int) Bit(i int) uint\n    Bit returns the value of the i'th bit of x. That is, it returns (x>>i)&1.\n    The bit index i must be >= 0.\n\nfunc (x *Int) BitLen() int\n    BitLen returns the length of the absolute value of x in bits. The bit length\n    of 0 is 0.\n\nfunc (x *Int) Bits() []Word\n    Bits provides raw (unchecked but fast) access to x by returning its absolute\n    value as a little-endian Word slice. The result and x share the same\n    underlying array. Bits is intended to support implementation of missing\n    low-level Int functionality outside this package; it should be avoided\n    otherwise.\n\nfunc (x *Int) Bytes() []byte\n    Bytes returns the absolute value of x as a big-endian byte slice.\n\n    To use a fixed length slice, or a preallocated one, use Int.FillBytes.\n\nfunc (x *Int) Cmp(y *Int) (r int)\n    Cmp compares x and y and returns:\n      - -1 if x < y;\n      - 0 if x == y;\n      - +1 if x > y.\n\nfunc (x *Int) CmpAbs(y *Int) int\n    CmpAbs compares the absolute values of x and y and returns:\n      - -1 if |x| < |y|;\n      - 0 if |x| == |y|;\n      - +1 if |x| > |y|.\n\nfunc (z *Int) Div(x, y *Int) *Int\n    Div sets z to the quotient x/y for y != 0 and returns z. If y == 0,\n    a division-by-zero run-time panic occurs. Div implements Euclidean division\n    (unlike Go); see Int.DivMod for more details.\n\nfunc (z *Int) DivMod(x, y, m *Int) (*Int, *Int)\n    DivMod sets z to the quotient x div y and m to the modulus x mod y and\n    returns the pair (z, m) for y != 0. If y == 0, a division-by-zero run-time\n    panic occurs.\n\n    DivMod implements Euclidean division and modulus (unlike Go):\n\n        q = x div y  such that\n        m = x - y*q  with 0 <= m < |y|\n\n    (See Raymond T. Boute, \u201cThe Euclidean definition of the functions div and\n    mod\u201d. ACM Transactions on Programming Languages and Systems (TOPLAS),\n    14(2):127-144, New York, NY, USA, 4/1992. ACM press.) See Int.QuoRem for\n    T-division and modulus (like Go).\n\nfunc (z *Int) Exp(x, y, m *Int) *Int\n    Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z.\n    If m == nil or m == 0, z = x**y unless y <= 0 then z = 1. If m != 0, y < 0,\n    and x and m are not relatively prime, z is unchanged and nil is returned.\n\n    Modular exponentiation of inputs of a particular size is not a\n    cryptographically constant-time operation.\n\nfunc (x *Int) FillBytes(buf []byte) []byte\n    FillBytes sets buf to the absolute value of x, storing it as a zero-extended\n    big-endian byte slice, and returns buf.\n\n    If the absolute value of x doesn't fit in buf, FillBytes will panic.\n\nfunc (x *Int) Float64() (float64, Accuracy)\n    Float64 returns the float64 value nearest x, and an indication of any\n    rounding that occurred.\n\nfunc (x *Int) Format(s fmt.State, ch rune)\n    Format implements fmt.Formatter. It accepts the formats 'b' (binary),\n    'o' (octal with 0 prefix), 'O' (octal with 0o prefix), 'd' (decimal),\n    'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal). Also supported\n    are the full suite of package fmt's format flags for integral types,\n    including '+' and ' ' for sign control, '#' for leading zero in octal and\n    for hexadecimal, a leading \"0x\" or \"0X\" for \"%#x\" and \"%#X\" respectively,\n    specification of minimum digits precision, output field width, space or zero\n    padding, and '-' for left or right justification.\n\nfunc (z *Int) GCD(x, y, a, b *Int) *Int\n    GCD sets z to the greatest common divisor of a and b and returns z. If x or\n    y are not nil, GCD sets their value such that z = a*x + b*y.\n\n    a and b may be positive, zero or negative. (Before Go 1.14 both had to be >\n    0.) Regardless of the signs of a and b, z is always >= 0.\n\n    If a == b == 0, GCD sets z = x = y = 0.\n\n    If a == 0 and b != 0, GCD sets z = |b|, x = 0, y = sign(b) * 1.\n\n    If a != 0 and b == 0, GCD sets z = |a|, x = sign(a) * 1, y = 0.\n\nfunc (z *Int) GobDecode(buf []byte) error\n    GobDecode implements the encoding/gob.GobDecoder interface.\n\nfunc (x *Int) GobEncode() ([]byte, error)\n    GobEncode implements the encoding/gob.GobEncoder interface.\n\nfunc (x *Int) Int64() int64\n    Int64 returns the int64 representation of x. If x cannot be represented in\n    an int64, the result is undefined.\n\nfunc (x *Int) IsInt64() bool\n    IsInt64 reports whether x can be represented as an int64.\n\nfunc (x *Int) IsUint64() bool\n    IsUint64 reports whether x can be represented as a uint64.\n\nfunc (z *Int) Lsh(x *Int, n uint) *Int\n    Lsh sets z = x << n and returns z.\n\nfunc (x *Int) MarshalJSON() ([]byte, error)\n    MarshalJSON implements the encoding/json.Marshaler interface.\n\nfunc (x *Int) MarshalText() (text []byte, err error)\n    MarshalText implements the encoding.TextMarshaler interface.\n\nfunc (z *Int) Mod(x, y *Int) *Int\n    Mod sets z to the modulus x%y for y != 0 and returns z. If y == 0,\n    a division-by-zero run-time panic occurs. Mod implements Euclidean modulus\n    (unlike Go); see Int.DivMod for more details.\n\nfunc (z *Int) ModInverse(g, n *Int) *Int\n    ModInverse sets z to the multiplicative inverse of g in the ring \u2124/n\u2124 and\n    returns z. If g and n are not relatively prime, g has no multiplicative\n    inverse in the ring \u2124/n\u2124. In this case, z is unchanged and the return value\n    is nil. If n == 0, a division-by-zero run-time panic occurs.\n\nfunc (z *Int) ModSqrt(x, p *Int) *Int\n    ModSqrt sets z to a square root of x mod p if such a square root exists, and\n    returns z. The modulus p must be an odd prime. If x is not a square mod p,\n    ModSqrt leaves z unchanged and returns nil. This function panics if p is not\n    an odd integer, its behavior is undefined if p is odd but not prime.\n\nfunc (z *Int) Mul(x, y *Int) *Int\n    Mul sets z to the product x*y and returns z.\n\nfunc (z *Int) MulRange(a, b int64) *Int\n    MulRange sets z to the product of all integers in the range [a, b]\n    inclusively and returns z. If a > b (empty range), the result is 1.\n\nfunc (z *Int) Neg(x *Int) *Int\n    Neg sets z to -x and returns z.\n\nfunc (z *Int) Not(x *Int) *Int\n    Not sets z = ^x and returns z.\n\nfunc (z *Int) Or(x, y *Int) *Int\n    Or sets z = x | y and returns z.\n\nfunc (x *Int) ProbablyPrime(n int) bool\n    ProbablyPrime reports whether x is probably prime, applying the Miller-Rabin\n    test with n pseudorandomly chosen bases as well as a Baillie-PSW test.\n\n    If x is prime, ProbablyPrime returns true. If x is chosen randomly and not\n    prime, ProbablyPrime probably returns false. The probability of returning\n    true for a randomly chosen non-prime is at most \u00bc\u207f.\n\n    ProbablyPrime is 100% accurate for inputs less than 2\u2076\u2074. See Menezes et al.,\n    Handbook of Applied Cryptography, 1997, pp. 145-149, and FIPS 186-4 Appendix\n    F for further discussion of the error probabilities.\n\n    ProbablyPrime is not suitable for judging primes that an adversary may have\n    crafted to fool the test.\n\n    As of Go 1.8, ProbablyPrime(0) is allowed and applies only a Baillie-PSW\n    test. Before Go 1.8, ProbablyPrime applied only the Miller-Rabin tests,\n    and ProbablyPrime(0) panicked.\n\nfunc (z *Int) Quo(x, y *Int) *Int\n    Quo sets z to the quotient x/y for y != 0 and returns z. If y == 0,\n    a division-by-zero run-time panic occurs. Quo implements truncated division\n    (like Go); see Int.QuoRem for more details.\n\nfunc (z *Int) QuoRem(x, y, r *Int) (*Int, *Int)\n    QuoRem sets z to the quotient x/y and r to the remainder x%y and returns the\n    pair (z, r) for y != 0. If y == 0, a division-by-zero run-time panic occurs.\n\n    QuoRem implements T-division and modulus (like Go):\n\n        q = x/y      with the result truncated to zero\n        r = x - y*q\n\n    (See Daan Leijen, \u201cDivision and Modulus for Computer Scientists\u201d.) See\n    Int.DivMod for Euclidean division and modulus (unlike Go).\n\nfunc (z *Int) Rand(rnd *rand.Rand, n *Int) *Int\n    Rand sets z to a pseudo-random number in [0, n) and returns z.\n\n    As this uses the math/rand package, it must not be used for\n    security-sensitive work. Use crypto/rand.Int instead.\n\nfunc (z *Int) Rem(x, y *Int) *Int\n    Rem sets z to the remainder x%y for y != 0 and returns z. If y == 0,\n    a division-by-zero run-time panic occurs. Rem implements truncated modulus\n    (like Go); see Int.QuoRem for more details.\n\nfunc (z *Int) Rsh(x *Int, n uint) *Int\n    Rsh sets z = x >> n and returns z.\n\nfunc (z *Int) Scan(s fmt.ScanState, ch rune) error\n    Scan is a support routine for fmt.Scanner; it sets z to the value of\n    the scanned number. It accepts the formats 'b' (binary), 'o' (octal),\n    'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).\n\nfunc (z *Int) Set(x *Int) *Int\n    Set sets z to x and returns z.\n\nfunc (z *Int) SetBit(x *Int, i int, b uint) *Int\n    SetBit sets z to x, with x's i'th bit set to b (0 or 1). That is,\n      - if b is 1, SetBit sets z = x | (1 << i);\n      - if b is 0, SetBit sets z = x &^ (1 << i);\n      - if b is not 0 or 1, SetBit will panic.\n\nfunc (z *Int) SetBits(abs []Word) *Int\n    SetBits provides raw (unchecked but fast) access to z by setting its\n    value to abs, interpreted as a little-endian Word slice, and returning z.\n    The result and abs share the same underlying array. SetBits is intended to\n    support implementation of missing low-level Int functionality outside this\n    package; it should be avoided otherwise.\n\nfunc (z *Int) SetBytes(buf []byte) *Int\n    SetBytes interprets buf as the bytes of a big-endian unsigned integer,\n    sets z to that value, and returns z.\n\nfunc (z *Int) SetInt64(x int64) *Int\n    SetInt64 sets z to x and returns z.\n\nfunc (z *Int) SetString(s string, base int) (*Int, bool)\n    SetString sets z to the value of s, interpreted in the given base,\n    and returns z and a boolean indicating success. The entire string (not just\n    a prefix) must be valid for success. If SetString fails, the value of z is\n    undefined but the returned value is nil.\n\n    The base argument must be 0 or a value between 2 and MaxBase. For base 0,\n    the number prefix determines the actual base: A prefix of \u201c0b\u201d or \u201c0B\u201d\n    selects base 2, \u201c0\u201d, \u201c0o\u201d or \u201c0O\u201d selects base 8, and \u201c0x\u201d or \u201c0X\u201d selects\n    base 16. Otherwise, the selected base is 10 and no prefix is accepted.\n\n    For bases <= 36, lower and upper case letters are considered the same: The\n    letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35. For bases\n    > 36, the upper case letters 'A' to 'Z' represent the digit values 36 to 61.\n\n    For base 0, an underscore character \u201c_\u201d may appear between a base prefix\n    and an adjacent digit, and between successive digits; such underscores do\n    not change the value of the number. Incorrect placement of underscores is\n    reported as an error if there are no other errors. If base != 0, underscores\n    are not recognized and act like any other character that is not a valid\n    digit.\n\nfunc (z *Int) SetUint64(x uint64) *Int\n    SetUint64 sets z to x and returns z.\n\nfunc (x *Int) Sign() int\n    Sign returns:\n      - -1 if x < 0;\n      - 0 if x == 0;\n      - +1 if x > 0.\n\nfunc (z *Int) Sqrt(x *Int) *Int\n    Sqrt sets z to \u230a\u221ax\u230b, the largest integer such that z\u00b2 \u2264 x, and returns z.\n    It panics if x is negative.\n\nfunc (x *Int) String() string\n    String returns the decimal representation of x as generated by x.Text(10).\n\nfunc (z *Int) Sub(x, y *Int) *Int\n    Sub sets z to the difference x-y and returns z.\n\nfunc (x *Int) Text(base int) string\n    Text returns the string representation of x in the given base. Base must\n    be between 2 and 62, inclusive. The result uses the lower-case letters 'a'\n    to 'z' for digit values 10 to 35, and the upper-case letters 'A' to 'Z' for\n    digit values 36 to 61. No prefix (such as \"0x\") is added to the string.\n    If x is a nil pointer it returns \"<nil>\".\n\nfunc (x *Int) TrailingZeroBits() uint\n    TrailingZeroBits returns the number of consecutive least significant zero\n    bits of |x|.\n\nfunc (x *Int) Uint64() uint64\n    Uint64 returns the uint64 representation of x. If x cannot be represented in\n    a uint64, the result is undefined.\n\nfunc (z *Int) UnmarshalJSON(text []byte) error\n    UnmarshalJSON implements the encoding/json.Unmarshaler interface.\n\nfunc (z *Int) UnmarshalText(text []byte) error\n    UnmarshalText implements the encoding.TextUnmarshaler interface.\n\nfunc (z *Int) Xor(x, y *Int) *Int\n    Xor sets z = x ^ y and returns z.\n\ntype Rat struct {\n\t// Has unexported fields.\n}\n    A Rat represents a quotient a/b of arbitrary precision. The zero value for a\n    Rat represents the value 0.\n\n    Operations always take pointer arguments (*Rat) rather than Rat values,\n    and each unique Rat value requires its own unique *Rat pointer. To \"copy\" a\n    Rat value, an existing (or newly allocated) Rat must be set to a new value\n    using the Rat.Set method; shallow copies of Rats are not supported and may\n    lead to errors.\n\nfunc NewRat(a, b int64) *Rat\n    NewRat creates a new Rat with numerator a and denominator b.\n\nfunc (z *Rat) Abs(x *Rat) *Rat\n    Abs sets z to |x| (the absolute value of x) and returns z.\n\nfunc (z *Rat) Add(x, y *Rat) *Rat\n    Add sets z to the sum x+y and returns z.\n\nfunc (x *Rat) AppendText(b []byte) ([]byte, error)\n    AppendText implements the encoding.TextAppender interface.\n\nfunc (x *Rat) Cmp(y *Rat) int\n    Cmp compares x and y and returns:\n      - -1 if x < y;\n      - 0 if x == y;\n      - +1 if x > y.\n\nfunc (x *Rat) Denom() *Int\n    Denom returns the denominator of x; it is always > 0. The result is a\n    reference to x's denominator, unless x is an uninitialized (zero value) Rat,\n    in which case the result is a new Int of value 1. (To initialize x,\n    any operation that sets x will do, including x.Set(x).) If the result is a\n    reference to x's denominator it may change if a new value is assigned to x,\n    and vice versa.\n\nfunc (x *Rat) Float32() (f float32, exact bool)\n    Float32 returns the nearest float32 value for x and a bool indicating\n    whether f represents x exactly. If the magnitude of x is too large to be\n    represented by a float32, f is an infinity and exact is false. The sign of f\n    always matches the sign of x, even if f == 0.\n\nfunc (x *Rat) Float64() (f float64, exact bool)\n    Float64 returns the nearest float64 value for x and a bool indicating\n    whether f represents x exactly. If the magnitude of x is too large to be\n    represented by a float64, f is an infinity and exact is false. The sign of f\n    always matches the sign of x, even if f == 0.\n\nfunc (x *Rat) FloatPrec() (n int, exact bool)\n    FloatPrec returns the number n of non-repeating digits immediately following\n    the decimal point of the decimal representation of x. The boolean result\n    indicates whether a decimal representation of x with that many fractional\n    digits is exact or rounded.\n\n    Examples:\n\n        x      n    exact    decimal representation n fractional digits\n        0      0    true     0\n        1      0    true     1\n        1/2    1    true     0.5\n        1/3    0    false    0       (0.333... rounded)\n        1/4    2    true     0.25\n        1/6    1    false    0.2     (0.166... rounded)\n\nfunc (x *Rat) FloatString(prec int) string\n    FloatString returns a string representation of x in decimal form with prec\n    digits of precision after the radix point. The last digit is rounded to\n    nearest, with halves rounded away from zero.\n\nfunc (z *Rat) GobDecode(buf []byte) error\n    GobDecode implements the encoding/gob.GobDecoder interface.\n\nfunc (x *Rat) GobEncode() ([]byte, error)\n    GobEncode implements the encoding/gob.GobEncoder interface.\n\nfunc (z *Rat) Inv(x *Rat) *Rat\n    Inv sets z to 1/x and returns z. If x == 0, Inv panics.\n\nfunc (x *Rat) IsInt() bool\n    IsInt reports whether the denominator of x is 1.\n\nfunc (x *Rat) MarshalText() (text []byte, err error)\n    MarshalText implements the encoding.TextMarshaler interface.\n\nfunc (z *Rat) Mul(x, y *Rat) *Rat\n    Mul sets z to the product x*y and returns z.\n\nfunc (z *Rat) Neg(x *Rat) *Rat\n    Neg sets z to -x and returns z.\n\nfunc (x *Rat) Num() *Int\n    Num returns the numerator of x; it may be <= 0. The result is a reference\n    to x's numerator; it may change if a new value is assigned to x, and vice\n    versa. The sign of the numerator corresponds to the sign of x.\n\nfunc (z *Rat) Quo(x, y *Rat) *Rat\n    Quo sets z to the quotient x/y and returns z. If y == 0, Quo panics.\n\nfunc (x *Rat) RatString() string\n    RatString returns a string representation of x in the form \"a/b\" if b != 1,\n    and in the form \"a\" if b == 1.\n\nfunc (z *Rat) Scan(s fmt.ScanState, ch rune) error\n    Scan is a support routine for fmt.Scanner. It accepts the formats 'e', 'E',\n    'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.\n\nfunc (z *Rat) Set(x *Rat) *Rat\n    Set sets z to x (by making a copy of x) and returns z.\n\nfunc (z *Rat) SetFloat64(f float64) *Rat\n    SetFloat64 sets z to exactly f and returns z. If f is not finite, SetFloat\n    returns nil.\n\nfunc (z *Rat) SetFrac(a, b *Int) *Rat\n    SetFrac sets z to a/b and returns z. If b == 0, SetFrac panics.\n\nfunc (z *Rat) SetFrac64(a, b int64) *Rat\n    SetFrac64 sets z to a/b and returns z. If b == 0, SetFrac64 panics.\n\nfunc (z *Rat) SetInt(x *Int) *Rat\n    SetInt sets z to x (by making a copy of x) and returns z.\n\nfunc (z *Rat) SetInt64(x int64) *Rat\n    SetInt64 sets z to x and returns z.\n\nfunc (z *Rat) SetString(s string) (*Rat, bool)\n    SetString sets z to the value of s and returns z and a boolean indicating\n    success. s can be given as a (possibly signed) fraction \"a/b\", or as a\n    floating-point number optionally followed by an exponent. If a fraction\n    is provided, both the dividend and the divisor may be a decimal integer\n    or independently use a prefix of \u201c0b\u201d, \u201c0\u201d or \u201c0o\u201d, or \u201c0x\u201d (or their\n    upper-case variants) to denote a binary, octal, or hexadecimal integer,\n    respectively. The divisor may not be signed. If a floating-point number is\n    provided, it may be in decimal form or use any of the same prefixes as above\n    but for \u201c0\u201d to denote a non-decimal mantissa. A leading \u201c0\u201d is considered a\n    decimal leading 0; it does not indicate octal representation in this case.\n    An optional base-10 \u201ce\u201d or base-2 \u201cp\u201d (or their upper-case variants)\n    exponent may be provided as well, except for hexadecimal floats which\n    only accept an (optional) \u201cp\u201d exponent (because an \u201ce\u201d or \u201cE\u201d cannot be\n    distinguished from a mantissa digit). If the exponent's absolute value is\n    too large, the operation may fail. The entire string, not just a prefix,\n    must be valid for success. If the operation failed, the value of z is\n    undefined but the returned value is nil.\n\nfunc (z *Rat) SetUint64(x uint64) *Rat\n    SetUint64 sets z to x and returns z.\n\nfunc (x *Rat) Sign() int\n    Sign returns:\n      - -1 if x < 0;\n      - 0 if x == 0;\n      - +1 if x > 0.\n\nfunc (x *Rat) String() string\n    String returns a string representation of x in the form \"a/b\" (even if b ==\n    1).\n\nfunc (z *Rat) Sub(x, y *Rat) *Rat\n    Sub sets z to the difference x-y and returns z.\n\nfunc (z *Rat) UnmarshalText(text []byte) error\n    UnmarshalText implements the encoding.TextUnmarshaler interface.\n\ntype RoundingMode byte\n    RoundingMode determines how a Float value is rounded to the desired\n    precision. Rounding may change the Float value; the rounding error is\n    described by the Float's Accuracy.\n\nconst (\n\tToNearestEven RoundingMode = iota // == IEEE 754-2008 roundTiesToEven\n\tToNearestAway                     // == IEEE 754-2008 roundTiesToAway\n\tToZero                            // == IEEE 754-2008 roundTowardZero\n\tAwayFromZero                      // no IEEE 754-2008 equivalent\n\tToNegativeInf                     // == IEEE 754-2008 roundTowardNegative\n\tToPositiveInf                     // == IEEE 754-2008 roundTowardPositive\n)\n    These constants define supported rounding modes.\n\nfunc (i RoundingMode) String() string\n\ntype Word uint\n    A Word represents a single digit of a multi-precision unsigned integer.\n\n"}, {"path": "stdlib/path-filepath.md", "category": "stdlib", "name": "stdlib/path-filepath", "content": "package filepath // import \"path/filepath\"\n\nPackage filepath implements utility routines for manipulating filename paths in\na way compatible with the target operating system-defined file paths.\n\nThe filepath package uses either forward slashes or backslashes, depending on\nthe operating system. To process paths such as URLs that always use forward\nslashes regardless of the operating system, see the path package.\n\nCONSTANTS\n\nconst (\n\tSeparator     = os.PathSeparator\n\tListSeparator = os.PathListSeparator\n)\n\nVARIABLES\n\nvar ErrBadPattern = errors.New(\"syntax error in pattern\")\n    ErrBadPattern indicates a pattern was malformed.\n\nvar SkipAll error = fs.SkipAll\n    SkipAll is used as a return value from WalkFunc to indicate that all\n    remaining files and directories are to be skipped. It is not returned as an\n    error by any function.\n\nvar SkipDir error = fs.SkipDir\n    SkipDir is used as a return value from WalkFunc to indicate that the\n    directory named in the call is to be skipped. It is not returned as an error\n    by any function.\n\n\nFUNCTIONS\n\nfunc Abs(path string) (string, error)\n    Abs returns an absolute representation of path. If the path is not absolute\n    it will be joined with the current working directory to turn it into an\n    absolute path. The absolute path name for a given file is not guaranteed to\n    be unique. Abs calls Clean on the result.\n\nfunc Base(path string) string\n    Base returns the last element of path. Trailing path separators are removed\n    before extracting the last element. If the path is empty, Base returns \".\".\n    If the path consists entirely of separators, Base returns a single\n    separator.\n\nfunc Clean(path string) string\n    Clean returns the shortest path name equivalent to path by purely lexical\n    processing. It applies the following rules iteratively until no further\n    processing can be done:\n\n     1. Replace multiple Separator elements with a single one.\n     2. Eliminate each . path name element (the current directory).\n     3. Eliminate each inner .. path name element (the parent directory) along\n        with the non-.. element that precedes it.\n     4. Eliminate .. elements that begin a rooted path: that is, replace \"/..\"\n        by \"/\" at the beginning of a path, assuming Separator is '/'.\n\n    The returned path ends in a slash only if it represents a root directory,\n    such as \"/\" on Unix or `C:\\` on Windows.\n\n    Finally, any occurrences of slash are replaced by Separator.\n\n    If the result of this process is an empty string, Clean returns the string\n    \".\".\n\n    On Windows, Clean does not modify the volume name other than to replace\n    occurrences of \"/\" with `\\`. For example, Clean(\"//host/share/../x\") returns\n    `\\\\host\\share\\x`.\n\n    See also Rob Pike, \u201cLexical File Names in Plan 9 or Getting Dot-Dot Right,\u201d\n    https://9p.io/sys/doc/lexnames.html\n\nfunc Dir(path string) string\n    Dir returns all but the last element of path, typically the path's\n    directory. After dropping the final element, Dir calls Clean on the path and\n    trailing slashes are removed. If the path is empty, Dir returns \".\". If the\n    path consists entirely of separators, Dir returns a single separator. The\n    returned path does not end in a separator unless it is the root directory.\n\nfunc EvalSymlinks(path string) (string, error)\n    EvalSymlinks returns the path name after the evaluation of any symbolic\n    links. If path is relative the result will be relative to the current\n    directory, unless one of the components is an absolute symbolic link.\n    EvalSymlinks calls Clean on the result.\n\nfunc Ext(path string) string\n    Ext returns the file name extension used by path. The extension is the\n    suffix beginning at the final dot in the final element of path; it is empty\n    if there is no dot.\n\nfunc FromSlash(path string) string\n    FromSlash returns the result of replacing each slash ('/') character in\n    path with a separator character. Multiple slashes are replaced by multiple\n    separators.\n\n    See also the Localize function, which converts a slash-separated path as\n    used by the io/fs package to an operating system path.\n\nfunc Glob(pattern string) (matches []string, err error)\n    Glob returns the names of all files matching pattern or nil if there\n    is no matching file. The syntax of patterns is the same as in Match.\n    The pattern may describe hierarchical names such as /usr/*/bin/ed (assuming\n    the Separator is '/').\n\n    Glob ignores file system errors such as I/O errors reading directories. The\n    only possible returned error is ErrBadPattern, when pattern is malformed.\n\nfunc HasPrefix(p, prefix string) bool\n    HasPrefix exists for historical compatibility and should not be used.\n\n    Deprecated: HasPrefix does not respect path boundaries and does not ignore\n    case when required.\n\nfunc IsAbs(path string) bool\n    IsAbs reports whether the path is absolute.\n\nfunc IsLocal(path string) bool\n    IsLocal reports whether path, using lexical analysis only, has all of these\n    properties:\n\n      - is within the subtree rooted at the directory in which path is evaluated\n      - is not an absolute path\n      - is not empty\n      - on Windows, is not a reserved name such as \"NUL\"\n\n    If IsLocal(path) returns true, then Join(base, path) will always produce a\n    path contained within base and Clean(path) will always produce an unrooted\n    path with no \"..\" path elements.\n\n    IsLocal is a purely lexical operation. In particular, it does not account\n    for the effect of any symbolic links that may exist in the filesystem.\n\nfunc Join(elem ...string) string\n    Join joins any number of path elements into a single path, separating them\n    with an OS specific Separator. Empty elements are ignored. The result is\n    Cleaned. However, if the argument list is empty or all its elements are\n    empty, Join returns an empty string. On Windows, the result will only be a\n    UNC path if the first non-empty element is a UNC path.\n\nfunc Localize(path string) (string, error)\n    Localize converts a slash-separated path into an operating system path.\n    The input path must be a valid path as reported by io/fs.ValidPath.\n\n    Localize returns an error if the path cannot be represented by the operating\n    system. For example, the path a\\b is rejected on Windows, on which \\ is a\n    separator character and cannot be part of a filename.\n\n    The path returned by Localize will always be local, as reported by IsLocal.\n\nfunc Match(pattern, name string) (matched bool, err error)\n    Match reports whether name matches the shell file name pattern. The pattern\n    syntax is:\n\n        pattern:\n        \t{ term }\n        term:\n        \t'*'         matches any sequence of non-Separator characters\n        \t'?'         matches any single non-Separator character\n        \t'[' [ '^' ] { character-range } ']'\n        \t            character class (must be non-empty)\n        \tc           matches character c (c != '*', '?', '\\\\', '[')\n        \t'\\\\' c      matches character c\n\n        character-range:\n        \tc           matches character c (c != '\\\\', '-', ']')\n        \t'\\\\' c      matches character c\n        \tlo '-' hi   matches character c for lo <= c <= hi\n\n    Match requires pattern to match all of name, not just a substring. The only\n    possible returned error is ErrBadPattern, when pattern is malformed.\n\n    On Windows, escaping is disabled. Instead, '\\\\' is treated as path\n    separator.\n\nfunc Rel(basepath, targpath string) (string, error)\n    Rel returns a relative path that is lexically equivalent to targpath when\n    joined to basepath with an intervening separator. That is, Join(basepath,\n    Rel(basepath, targpath)) is equivalent to targpath itself. On success,\n    the returned path will always be relative to basepath, even if basepath and\n    targpath share no elements. An error is returned if targpath can't be made\n    relative to basepath or if knowing the current working directory would be\n    necessary to compute it. Rel calls Clean on the result.\n\nfunc Split(path string) (dir, file string)\n    Split splits path immediately following the final Separator, separating it\n    into a directory and file name component. If there is no Separator in path,\n    Split returns an empty dir and file set to path. The returned values have\n    the property that path = dir+file.\n\nfunc SplitList(path string) []string\n    SplitList splits a list of paths joined by the OS-specific ListSeparator,\n    usually found in PATH or GOPATH environment variables. Unlike strings.Split,\n    SplitList returns an empty slice when passed an empty string.\n\nfunc ToSlash(path string) string\n    ToSlash returns the result of replacing each separator character in path\n    with a slash ('/') character. Multiple separators are replaced by multiple\n    slashes.\n\nfunc VolumeName(path string) string\n    VolumeName returns leading volume name. Given \"C:\\foo\\bar\" it returns \"C:\"\n    on Windows. Given \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\". On other\n    platforms it returns \"\".\n\nfunc Walk(root string, fn WalkFunc) error\n    Walk walks the file tree rooted at root, calling fn for each file or\n    directory in the tree, including root.\n\n    All errors that arise visiting files and directories are filtered by fn:\n    see the WalkFunc documentation for details.\n\n    The files are walked in lexical order, which makes the output deterministic\n    but requires Walk to read an entire directory into memory before proceeding\n    to walk that directory.\n\n    Walk does not follow symbolic links.\n\n    Walk is less efficient than WalkDir, introduced in Go 1.16, which avoids\n    calling os.Lstat on every visited file or directory.\n\nfunc WalkDir(root string, fn fs.WalkDirFunc) error\n    WalkDir walks the file tree rooted at root, calling fn for each file or\n    directory in the tree, including root.\n\n    All errors that arise visiting files and directories are filtered by fn:\n    see the fs.WalkDirFunc documentation for details.\n\n    The files are walked in lexical order, which makes the output deterministic\n    but requires WalkDir to read an entire directory into memory before\n    proceeding to walk that directory.\n\n    WalkDir does not follow symbolic links.\n\n    WalkDir calls fn with paths that use the separator character appropriate for\n    the operating system. This is unlike io/fs.WalkDir, which always uses slash\n    separated paths.\n\n\nTYPES\n\ntype WalkFunc func(path string, info fs.FileInfo, err error) error\n    WalkFunc is the type of the function called by Walk to visit each file or\n    directory.\n\n    The path argument contains the argument to Walk as a prefix. That is,\n    if Walk is called with root argument \"dir\" and finds a file named \"a\" in\n    that directory, the walk function will be called with argument \"dir/a\".\n\n    The directory and file are joined with Join, which may clean the directory\n    name: if Walk is called with the root argument \"x/../dir\" and finds a file\n    named \"a\" in that directory, the walk function will be called with argument\n    \"dir/a\", not \"x/../dir/a\".\n\n    The info argument is the fs.FileInfo for the named path.\n\n    The error result returned by the function controls how Walk continues.\n    If the function returns the special value SkipDir, Walk skips the current\n    directory (path if info.IsDir() is true, otherwise path's parent directory).\n    If the function returns the special value SkipAll, Walk skips all remaining\n    files and directories. Otherwise, if the function returns a non-nil error,\n    Walk stops entirely and returns that error.\n\n    The err argument reports an error related to path, signaling that Walk will\n    not walk into that directory. The function can decide how to handle that\n    error; as described earlier, returning the error will cause Walk to stop\n    walking the entire tree.\n\n    Walk calls the function with a non-nil err argument in two cases.\n\n    First, if an os.Lstat on the root directory or any directory or file in\n    the tree fails, Walk calls the function with path set to that directory or\n    file's path, info set to nil, and err set to the error from os.Lstat.\n\n    Second, if a directory's Readdirnames method fails, Walk calls the\n    function with path set to the directory's path, info, set to an fs.FileInfo\n    describing the directory, and err set to the error from Readdirnames.\n\n"}, {"path": "stdlib/net-http-internal-ascii.md", "category": "stdlib", "name": "stdlib/net-http-internal-ascii", "content": "package ascii // import \"net/http/internal/ascii\"\n\n\nFUNCTIONS\n\nfunc EqualFold(s, t string) bool\n    EqualFold is strings.EqualFold, ASCII only. It reports whether s and t are\n    equal, ASCII-case-insensitively.\n\nfunc Is(s string) bool\n    Is returns whether s is ASCII.\n\nfunc IsPrint(s string) bool\n    IsPrint returns whether s is ASCII and printable according to\n    https://tools.ietf.org/html/rfc20#section-4.2.\n\nfunc ToLower(s string) (lower string, ok bool)\n    ToLower returns the lowercase version of s if s is ASCII and printable.\n\n"}, {"path": "stdlib/crypto-hkdf.md", "category": "stdlib", "name": "stdlib/crypto-hkdf", "content": "package hkdf // import \"crypto/hkdf\"\n\nPackage hkdf implements the HMAC-based Extract-and-Expand Key Derivation\nFunction (HKDF) as defined in RFC 5869.\n\nHKDF is a cryptographic key derivation function (KDF) with the goal of expanding\nlimited input keying material into one or more cryptographically strong secret\nkeys.\n\nFUNCTIONS\n\nfunc Expand[H hash.Hash](h func() H, pseudorandomKey []byte, info string, keyLength int) ([]byte, error)\n    Expand derives a key from the given hash, key, and optional context info,\n    returning a []byte of length keyLength that can be used as cryptographic\n    key. The extraction step is skipped.\n\n    The key should have been generated by Extract, or be a uniformly random\n    or pseudorandom cryptographically strong key. See RFC 5869, Section 3.3.\n    Most common scenarios will want to use Key instead.\n\nfunc Extract[H hash.Hash](h func() H, secret, salt []byte) ([]byte, error)\n    Extract generates a pseudorandom key for use with Expand from an input\n    secret and an optional independent salt.\n\n    Only use this function if you need to reuse the extracted key with multiple\n    Expand invocations and different context values. Most common scenarios,\n    including the generation of multiple keys, should use Key instead.\n\nfunc Key[Hash hash.Hash](h func() Hash, secret, salt []byte, info string, keyLength int) ([]byte, error)\n    Key derives a key from the given hash, secret, salt and context info,\n    returning a []byte of length keyLength that can be used as cryptographic\n    key. Salt and info can be nil.\n\n"}, {"path": "stdlib/unicode-utf16.md", "category": "stdlib", "name": "stdlib/unicode-utf16", "content": "package utf16 // import \"unicode/utf16\"\n\nPackage utf16 implements encoding and decoding of UTF-16 sequences.\n\nFUNCTIONS\n\nfunc AppendRune(a []uint16, r rune) []uint16\n    AppendRune appends the UTF-16 encoding of the Unicode code point r to the\n    end of p and returns the extended buffer. If the rune is not a valid Unicode\n    code point, it appends the encoding of U+FFFD.\n\nfunc Decode(s []uint16) []rune\n    Decode returns the Unicode code point sequence represented by the UTF-16\n    encoding s.\n\nfunc DecodeRune(r1, r2 rune) rune\n    DecodeRune returns the UTF-16 decoding of a surrogate pair. If the pair\n    is not a valid UTF-16 surrogate pair, DecodeRune returns the Unicode\n    replacement code point U+FFFD.\n\nfunc Encode(s []rune) []uint16\n    Encode returns the UTF-16 encoding of the Unicode code point sequence s.\n\nfunc EncodeRune(r rune) (r1, r2 rune)\n    EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\n    If the rune is not a valid Unicode code point or does not need encoding,\n    EncodeRune returns U+FFFD, U+FFFD.\n\nfunc IsSurrogate(r rune) bool\n    IsSurrogate reports whether the specified Unicode code point can appear in a\n    surrogate pair.\n\nfunc RuneLen(r rune) int\n    RuneLen returns the number of 16-bit words in the UTF-16 encoding of the\n    rune. It returns -1 if the rune is not a valid value to encode in UTF-16.\n\n"}, {"path": "stdlib/text-template.md", "category": "stdlib", "name": "stdlib/text-template", "content": "package template // import \"text/template\"\n\nPackage template implements data-driven templates for generating textual output.\n\nTo generate HTML output, see html/template, which has the same interface as this\npackage but automatically secures HTML output against certain attacks.\n\nTemplates are executed by applying them to a data structure. Annotations in the\ntemplate refer to elements of the data structure (typically a field of a struct\nor a key in a map) to control execution and derive values to be displayed.\nExecution of the template walks the structure and sets the cursor, represented\nby a period '.' and called \"dot\", to the value at the current location in the\nstructure as execution proceeds.\n\nThe security model used by this package assumes that template authors are\ntrusted. The package does not auto-escape output, so injecting code into a\ntemplate can lead to arbitrary code execution if the template is executed by an\nuntrusted source.\n\nThe input text for a template is UTF-8-encoded text in any format.\n\"Actions\"--data evaluations or control structures--are delimited by \"{{\" and\n\"}}\"; all text outside actions is copied to the output unchanged.\n\nOnce parsed, a template may be executed safely in parallel, although if parallel\nexecutions share a Writer the output may be interleaved.\n\nHere is a trivial example that prints \"17 items are made of wool\".\n\n    type Inventory struct {\n    \tMaterial string\n    \tCount    uint\n    }\n    sweaters := Inventory{\"wool\", 17}\n    tmpl, err := template.New(\"test\").Parse(\"{{.Count}} items are made of {{.Material}}\")\n    if err != nil { panic(err) }\n    err = tmpl.Execute(os.Stdout, sweaters)\n    if err != nil { panic(err) }\n\nMore intricate examples appear below.\n\n# Text and spaces\n\nBy default, all text between actions is copied verbatim when the template is\nexecuted. For example, the string \" items are made of \" in the example above\nappears on standard output when the program is run.\n\nHowever, to aid in formatting template source code, if an action's left\ndelimiter (by default \"{{\") is followed immediately by a minus sign and white\nspace, all trailing white space is trimmed from the immediately preceding text.\nSimilarly, if the right delimiter (\"}}\") is preceded by white space and a minus\nsign, all leading white space is trimmed from the immediately following text.\nIn these trim markers, the white space must be present: \"{{- 3}}\" is like\n\"{{3}}\" but trims the immediately preceding text, while \"{{-3}}\" parses as an\naction containing the number -3.\n\nFor instance, when executing the template whose source is\n\n    \"{{23 -}} < {{- 45}}\"\n\nthe generated output would be\n\n    \"23<45\"\n\nFor this trimming, the definition of white space characters is the same as in\nGo: space, horizontal tab, carriage return, and newline.\n\n# Actions\n\nHere is the list of actions. \"Arguments\" and \"pipelines\" are evaluations of\ndata, defined in detail in the corresponding sections that follow.\n\n    {{/* a comment */}}\n    {{- /* a comment with white space trimmed from preceding and following text */ -}}\n    \tA comment; discarded. May contain newlines.\n    \tComments do not nest and must start and end at the\n    \tdelimiters, as shown here.\n\n    {{pipeline}}\n    \tThe default textual representation (the same as would be\n    \tprinted by fmt.Print) of the value of the pipeline is copied\n    \tto the output.\n\n    {{if pipeline}} T1 {{end}}\n    \tIf the value of the pipeline is empty, no output is generated;\n    \totherwise, T1 is executed. The empty values are false, 0, any\n    \tnil pointer or interface value, and any array, slice, map, or\n    \tstring of length zero.\n    \tDot is unaffected.\n\n    {{if pipeline}} T1 {{else}} T0 {{end}}\n    \tIf the value of the pipeline is empty, T0 is executed;\n    \totherwise, T1 is executed. Dot is unaffected.\n\n    {{if pipeline}} T1 {{else if pipeline}} T0 {{end}}\n    \tTo simplify the appearance of if-else chains, the else action\n    \tof an if may include another if directly; the effect is exactly\n    \tthe same as writing\n    \t\t{{if pipeline}} T1 {{else}}{{if pipeline}} T0 {{end}}{{end}}\n\n    {{range pipeline}} T1 {{end}}\n    \tThe value of the pipeline must be an array, slice, map, iter.Seq,\n    \titer.Seq2, integer or channel.\n    \tIf the value of the pipeline has length zero, nothing is output;\n    \totherwise, dot is set to the successive elements of the array,\n    \tslice, or map and T1 is executed. If the value is a map and the\n    \tkeys are of basic type with a defined order, the elements will be\n    \tvisited in sorted key order.\n\n    {{range pipeline}} T1 {{else}} T0 {{end}}\n    \tThe value of the pipeline must be an array, slice, map, iter.Seq,\n    \titer.Seq2, integer or channel.\n    \tIf the value of the pipeline has length zero, dot is unaffected and\n    \tT0 is executed; otherwise, dot is set to the successive elements\n    \tof the array, slice, or map and T1 is executed.\n\n    {{break}}\n    \tThe innermost {{range pipeline}} loop is ended early, stopping the\n    \tcurrent iteration and bypassing all remaining iterations.\n\n    {{continue}}\n    \tThe current iteration of the innermost {{range pipeline}} loop is\n    \tstopped, and the loop starts the next iteration.\n\n    {{template \"name\"}}\n    \tThe template with the specified name is executed with nil data.\n\n    {{template \"name\" pipeline}}\n    \tThe template with the specified name is executed with dot set\n    \tto the value of the pipeline.\n\n    {{block \"name\" pipeline}} T1 {{end}}\n    \tA block is shorthand for defining a template\n    \t\t{{define \"name\"}} T1 {{end}}\n    \tand then executing it in place\n    \t\t{{template \"name\" pipeline}}\n    \tThe typical use is to define a set of root templates that are\n    \tthen customized by redefining the block templates within.\n\n    {{with pipeline}} T1 {{end}}\n    \tIf the value of the pipeline is empty, no output is generated;\n    \totherwise, dot is set to the value of the pipeline and T1 is\n    \texecuted.\n\n    {{with pipeline}} T1 {{else}} T0 {{end}}\n    \tIf the value of the pipeline is empty, dot is unaffected and T0\n    \tis executed; otherwise, dot is set to the value of the pipeline\n    \tand T1 is executed.\n\n    {{with pipeline}} T1 {{else with pipeline}} T0 {{end}}\n    \tTo simplify the appearance of with-else chains, the else action\n    \tof a with may include another with directly; the effect is exactly\n    \tthe same as writing\n    \t\t{{with pipeline}} T1 {{else}}{{with pipeline}} T0 {{end}}{{end}}\n\n# Arguments\n\nAn argument is a simple value, denoted by one of the following.\n\n  - A boolean, string, character, integer, floating-point, imaginary or complex\n    constant in Go syntax. These behave like Go's untyped constants. Note that,\n    as in Go, whether a large integer constant overflows when assigned or passed\n    to a function can depend on whether the host machine's ints are 32 or 64\n    bits.\n\n  - The keyword nil, representing an untyped Go nil.\n\n  - The character '.' (period):\n\n    .\n\n    The result is the value of dot.\n\n  - A variable name, which is a (possibly empty) alphanumeric string preceded by\n    a dollar sign, such as\n\n    $piOver2\n\n    or\n\n    $\n\n    The result is the value of the variable. Variables are described below.\n\n  - The name of a field of the data, which must be a struct, preceded by a\n    period, such as\n\n    .Field\n\n    The result is the value of the field. Field invocations may be chained:\n\n    .Field1.Field2\n\n    Fields can also be evaluated on variables, including chaining:\n\n    $x.Field1.Field2\n\n  - The name of a key of the data, which must be a map, preceded by a period,\n    such as\n\n    .Key\n\n    The result is the map element value indexed by the key. Key invocations may\n    be chained and combined with fields to any depth:\n\n    .Field1.Key1.Field2.Key2\n\n    Although the key must be an alphanumeric identifier, unlike with field\n    names they do not need to start with an upper case letter. Keys can also be\n    evaluated on variables, including chaining:\n\n    $x.key1.key2\n\n  - The name of a niladic method of the data, preceded by a period, such as\n\n    .Method\n\n    The result is the value of invoking the method with dot as the receiver,\n    dot.Method(). Such a method must have one return value (of any type) or\n    two return values, the second of which is an error. If it has two and the\n    returned error is non-nil, execution terminates and an error is returned to\n    the caller as the value of Execute. Method invocations may be chained and\n    combined with fields and keys to any depth:\n\n    .Field1.Key1.Method1.Field2.Key2.Method2\n\n    Methods can also be evaluated on variables, including chaining:\n\n    $x.Method1.Field\n\n  - The name of a niladic function, such as\n\n    fun\n\n    The result is the value of invoking the function, fun(). The return types\n    and values behave as in methods. Functions and function names are described\n    below.\n\n  - A parenthesized instance of one the above, for grouping. The result may be\n    accessed by a field or map key invocation.\n\n    print (.F1 arg1) (.F2 arg2) (.StructValuedMethod \"arg\").Field\n\nArguments may evaluate to any type; if they are pointers the implementation\nautomatically indirects to the base type when required. If an evaluation yields\na function value, such as a function-valued field of a struct, the function is\nnot invoked automatically, but it can be used as a truth value for an if action\nand the like. To invoke it, use the call function, defined below.\n\n# Pipelines\n\nA pipeline is a possibly chained sequence of \"commands\". A command is a simple\nvalue (argument) or a function or method call, possibly with multiple arguments:\n\n    Argument\n    \tThe result is the value of evaluating the argument.\n    .Method [Argument...]\n    \tThe method can be alone or the last element of a chain but,\n    \tunlike methods in the middle of a chain, it can take arguments.\n    \tThe result is the value of calling the method with the\n    \targuments:\n    \t\tdot.Method(Argument1, etc.)\n    functionName [Argument...]\n    \tThe result is the value of calling the function associated\n    \twith the name:\n    \t\tfunction(Argument1, etc.)\n    \tFunctions and function names are described below.\n\nA pipeline may be \"chained\" by separating a sequence of commands with pipeline\ncharacters '|'. In a chained pipeline, the result of each command is passed as\nthe last argument of the following command. The output of the final command in\nthe pipeline is the value of the pipeline.\n\nThe output of a command will be either one value or two values, the second of\nwhich has type error. If that second value is present and evaluates to non-nil,\nexecution terminates and the error is returned to the caller of Execute.\n\n# Variables\n\nA pipeline inside an action may initialize a variable to capture the result.\nThe initialization has syntax\n\n    $variable := pipeline\n\nwhere $variable is the name of the variable. An action that declares a variable\nproduces no output.\n\nVariables previously declared can also be assigned, using the syntax\n\n    $variable = pipeline\n\nIf a \"range\" action initializes a variable, the variable is set to the\nsuccessive elements of the iteration. Also, a \"range\" may declare two variables,\nseparated by a comma:\n\n    range $index, $element := pipeline\n\nin which case $index and $element are set to the successive values of the\narray/slice index or map key and element, respectively. Note that if there\nis only one variable, it is assigned the element; this is opposite to the\nconvention in Go range clauses.\n\nA variable's scope extends to the \"end\" action of the control structure (\"if\",\n\"with\", or \"range\") in which it is declared, or to the end of the template\nif there is no such control structure. A template invocation does not inherit\nvariables from the point of its invocation.\n\nWhen execution begins, $ is set to the data argument passed to Execute, that is,\nto the starting value of dot.\n\n# Examples\n\nHere are some example one-line templates demonstrating pipelines and variables.\nAll produce the quoted word \"output\":\n\n    {{\"\\\"output\\\"\"}}\n    \tA string constant.\n    {{`\"output\"`}}\n    \tA raw string constant.\n    {{printf \"%q\" \"output\"}}\n    \tA function call.\n    {{\"output\" | printf \"%q\"}}\n    \tA function call whose final argument comes from the previous\n    \tcommand.\n    {{printf \"%q\" (print \"out\" \"put\")}}\n    \tA parenthesized argument.\n    {{\"put\" | printf \"%s%s\" \"out\" | printf \"%q\"}}\n    \tA more elaborate call.\n    {{\"output\" | printf \"%s\" | printf \"%q\"}}\n    \tA longer chain.\n    {{with \"output\"}}{{printf \"%q\" .}}{{end}}\n    \tA with action using dot.\n    {{with $x := \"output\" | printf \"%q\"}}{{$x}}{{end}}\n    \tA with action that creates and uses a variable.\n    {{with $x := \"output\"}}{{printf \"%q\" $x}}{{end}}\n    \tA with action that uses the variable in another action.\n    {{with $x := \"output\"}}{{$x | printf \"%q\"}}{{end}}\n    \tThe same, but pipelined.\n\n# Functions\n\nDuring execution functions are found in two function maps: first in the\ntemplate, then in the global function map. By default, no functions are defined\nin the template but the Funcs method can be used to add them.\n\nPredefined global functions are named as follows.\n\n    and\n    \tReturns the boolean AND of its arguments by returning the\n    \tfirst empty argument or the last argument. That is,\n    \t\"and x y\" behaves as \"if x then y else x.\"\n    \tEvaluation proceeds through the arguments left to right\n    \tand returns when the result is determined.\n    call\n    \tReturns the result of calling the first argument, which\n    \tmust be a function, with the remaining arguments as parameters.\n    \tThus \"call .X.Y 1 2\" is, in Go notation, dot.X.Y(1, 2) where\n    \tY is a func-valued field, map entry, or the like.\n    \tThe first argument must be the result of an evaluation\n    \tthat yields a value of function type (as distinct from\n    \ta predefined function such as print). The function must\n    \treturn either one or two result values, the second of which\n    \tis of type error. If the arguments don't match the function\n    \tor the returned error value is non-nil, execution stops.\n    html\n    \tReturns the escaped HTML equivalent of the textual\n    \trepresentation of its arguments. This function is unavailable\n    \tin html/template, with a few exceptions.\n    index\n    \tReturns the result of indexing its first argument by the\n    \tfollowing arguments. Thus \"index x 1 2 3\" is, in Go syntax,\n    \tx[1][2][3]. Each indexed item must be a map, slice, or array.\n    slice\n    \tslice returns the result of slicing its first argument by the\n    \tremaining arguments. Thus \"slice x 1 2\" is, in Go syntax, x[1:2],\n    \twhile \"slice x\" is x[:], \"slice x 1\" is x[1:], and \"slice x 1 2 3\"\n    \tis x[1:2:3]. The first argument must be a string, slice, or array.\n    js\n    \tReturns the escaped JavaScript equivalent of the textual\n    \trepresentation of its arguments.\n    len\n    \tReturns the integer length of its argument.\n    not\n    \tReturns the boolean negation of its single argument.\n    or\n    \tReturns the boolean OR of its arguments by returning the\n    \tfirst non-empty argument or the last argument, that is,\n    \t\"or x y\" behaves as \"if x then x else y\".\n    \tEvaluation proceeds through the arguments left to right\n    \tand returns when the result is determined.\n    print\n    \tAn alias for fmt.Sprint\n    printf\n    \tAn alias for fmt.Sprintf\n    println\n    \tAn alias for fmt.Sprintln\n    urlquery\n    \tReturns the escaped value of the textual representation of\n    \tits arguments in a form suitable for embedding in a URL query.\n    \tThis function is unavailable in html/template, with a few\n    \texceptions.\n\nThe boolean functions take any zero value to be false and a non-zero value to be\ntrue.\n\nThere is also a set of binary comparison operators defined as functions:\n\n    eq\n    \tReturns the boolean truth of arg1 == arg2\n    ne\n    \tReturns the boolean truth of arg1 != arg2\n    lt\n    \tReturns the boolean truth of arg1 < arg2\n    le\n    \tReturns the boolean truth of arg1 <= arg2\n    gt\n    \tReturns the boolean truth of arg1 > arg2\n    ge\n    \tReturns the boolean truth of arg1 >= arg2\n\nFor simpler multi-way equality tests, eq (only) accepts two or more arguments\nand compares the second and subsequent to the first, returning in effect\n\n    arg1==arg2 || arg1==arg3 || arg1==arg4 ...\n\n(Unlike with || in Go, however, eq is a function call and all the arguments will\nbe evaluated.)\n\nThe comparison functions work on any values whose type Go defines as comparable.\nFor basic types such as integers, the rules are relaxed: size and exact type\nare ignored, so any integer value, signed or unsigned, may be compared with any\nother integer value. (The arithmetic value is compared, not the bit pattern, so\nall negative integers are less than all unsigned integers.) However, as usual,\none may not compare an int with a float32 and so on.\n\n# Associated templates\n\nEach template is named by a string specified when it is created. Also, each\ntemplate is associated with zero or more other templates that it may invoke by\nname; such associations are transitive and form a name space of templates.\n\nA template may use a template invocation to instantiate another associated\ntemplate; see the explanation of the \"template\" action above. The name must be\nthat of a template associated with the template that contains the invocation.\n\n# Nested template definitions\n\nWhen parsing a template, another template may be defined and associated with the\ntemplate being parsed. Template definitions must appear at the top level of the\ntemplate, much like global variables in a Go program.\n\nThe syntax of such definitions is to surround each template declaration with a\n\"define\" and \"end\" action.\n\nThe define action names the template being created by providing a string\nconstant. Here is a simple example:\n\n    {{define \"T1\"}}ONE{{end}}\n    {{define \"T2\"}}TWO{{end}}\n    {{define \"T3\"}}{{template \"T1\"}} {{template \"T2\"}}{{end}}\n    {{template \"T3\"}}\n\nThis defines two templates, T1 and T2, and a third T3 that invokes the other\ntwo when it is executed. Finally it invokes T3. If executed this template will\nproduce the text\n\n    ONE TWO\n\nBy construction, a template may reside in only one association. If it's\nnecessary to have a template addressable from multiple associations, the\ntemplate definition must be parsed multiple times to create distinct *Template\nvalues, or must be copied with Template.Clone or Template.AddParseTree.\n\nParse may be called multiple times to assemble the various associated templates;\nsee ParseFiles, ParseGlob, Template.ParseFiles and Template.ParseGlob for simple\nways to parse related templates stored in files.\n\nA template may be executed directly or through Template.ExecuteTemplate, which\nexecutes an associated template identified by name. To invoke our example above,\nwe might write,\n\n    err := tmpl.Execute(os.Stdout, \"no data needed\")\n    if err != nil {\n    \tlog.Fatalf(\"execution failed: %s\", err)\n    }\n\nor to invoke a particular template explicitly by name,\n\n    err := tmpl.ExecuteTemplate(os.Stdout, \"T2\", \"no data needed\")\n    if err != nil {\n    \tlog.Fatalf(\"execution failed: %s\", err)\n    }\n\nFUNCTIONS\n\nfunc HTMLEscape(w io.Writer, b []byte)\n    HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n\nfunc HTMLEscapeString(s string) string\n    HTMLEscapeString returns the escaped HTML equivalent of the plain text data\n    s.\n\nfunc HTMLEscaper(args ...any) string\n    HTMLEscaper returns the escaped HTML equivalent of the textual\n    representation of its arguments.\n\nfunc IsTrue(val any) (truth, ok bool)\n    IsTrue reports whether the value is 'true', in the sense of not the zero of\n    its type, and whether the value has a meaningful truth value. This is the\n    definition of truth used by if and other such actions.\n\nfunc JSEscape(w io.Writer, b []byte)\n    JSEscape writes to w the escaped JavaScript equivalent of the plain text\n    data b.\n\nfunc JSEscapeString(s string) string\n    JSEscapeString returns the escaped JavaScript equivalent of the plain text\n    data s.\n\nfunc JSEscaper(args ...any) string\n    JSEscaper returns the escaped JavaScript equivalent of the textual\n    representation of its arguments.\n\nfunc URLQueryEscaper(args ...any) string\n    URLQueryEscaper returns the escaped value of the textual representation of\n    its arguments in a form suitable for embedding in a URL query.\n\n\nTYPES\n\ntype ExecError struct {\n\tName string // Name of template.\n\tErr  error  // Pre-formatted error.\n}\n    ExecError is the custom error type returned when Execute has an error\n    evaluating its template. (If a write error occurs, the actual error is\n    returned; it will not be of type ExecError.)\n\nfunc (e ExecError) Error() string\n\nfunc (e ExecError) Unwrap() error\n\ntype FuncMap map[string]any\n    FuncMap is the type of the map defining the mapping from names to functions.\n    Each function must have either a single return value, or two return values\n    of which the second has type error. In that case, if the second (error)\n    return value evaluates to non-nil during execution, execution terminates and\n    Execute returns that error.\n\n    Errors returned by Execute wrap the underlying error; call errors.As to\n    unwrap them.\n\n    When template execution invokes a function with an argument list, that list\n    must be assignable to the function's parameter types. Functions meant to\n    apply to arguments of arbitrary type can use parameters of type interface{}\n    or of type reflect.Value. Similarly, functions meant to return a result of\n    arbitrary type can return interface{} or reflect.Value.\n\ntype Template struct {\n\t*parse.Tree\n\n\t// Has unexported fields.\n}\n    Template is the representation of a parsed template. The *parse.Tree\n    field is exported only for use by html/template and should be treated as\n    unexported by all other clients.\n\nfunc Must(t *Template, err error) *Template\n    Must is a helper that wraps a call to a function returning (*Template,\n    error) and panics if the error is non-nil. It is intended for use in\n    variable initializations such as\n\n        var t = template.Must(template.New(\"name\").Parse(\"text\"))\n\nfunc New(name string) *Template\n    New allocates a new, undefined template with the given name.\n\nfunc ParseFS(fsys fs.FS, patterns ...string) (*Template, error)\n    ParseFS is like Template.ParseFiles or Template.ParseGlob but reads from\n    the file system fsys instead of the host operating system's file system.\n    It accepts a list of glob patterns (see path.Match). (Note that most file\n    names serve as glob patterns matching only themselves.)\n\nfunc ParseFiles(filenames ...string) (*Template, error)\n    ParseFiles creates a new Template and parses the template definitions from\n    the named files. The returned template's name will have the base name\n    and parsed contents of the first file. There must be at least one file.\n    If an error occurs, parsing stops and the returned *Template is nil.\n\n    When parsing multiple files with the same name in different directories,\n    the last one mentioned will be the one that results. For instance,\n    ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template named \"foo\",\n    while \"a/foo\" is unavailable.\n\nfunc ParseGlob(pattern string) (*Template, error)\n    ParseGlob creates a new Template and parses the template definitions from\n    the files identified by the pattern. The files are matched according to the\n    semantics of filepath.Match, and the pattern must match at least one file.\n    The returned template will have the filepath.Base name and (parsed) contents\n    of the first file matched by the pattern. ParseGlob is equivalent to calling\n    ParseFiles with the list of files matched by the pattern.\n\n    When parsing multiple files with the same name in different directories,\n    the last one mentioned will be the one that results.\n\nfunc (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)\n    AddParseTree associates the argument parse tree with the template t, giving\n    it the specified name. If the template has not been defined, this tree\n    becomes its definition. If it has been defined and already has that name,\n    the existing definition is replaced; otherwise a new template is created,\n    defined, and returned.\n\nfunc (t *Template) Clone() (*Template, error)\n    Clone returns a duplicate of the template, including all associated\n    templates. The actual representation is not copied, but the name space of\n    associated templates is, so further calls to Template.Parse in the copy\n    will add templates to the copy but not to the original. Clone can be used\n    to prepare common templates and use them with variant definitions for other\n    templates by adding the variants after the clone is made.\n\nfunc (t *Template) DefinedTemplates() string\n    DefinedTemplates returns a string listing the defined templates, prefixed\n    by the string \"; defined templates are: \". If there are none, it returns the\n    empty string. For generating an error message here and in html/template.\n\nfunc (t *Template) Delims(left, right string) *Template\n    Delims sets the action delimiters to the specified strings, to be\n    used in subsequent calls to Template.Parse, Template.ParseFiles, or\n    Template.ParseGlob. Nested template definitions will inherit the settings.\n    An empty delimiter stands for the corresponding default: {{ or }}. The\n    return value is the template, so calls can be chained.\n\nfunc (t *Template) Execute(wr io.Writer, data any) error\n    Execute applies a parsed template to the specified data object,\n    and writes the output to wr. If an error occurs executing the template or\n    writing its output, execution stops, but partial results may already have\n    been written to the output writer. A template may be executed safely in\n    parallel, although if parallel executions share a Writer the output may be\n    interleaved.\n\n    If data is a reflect.Value, the template applies to the concrete value that\n    the reflect.Value holds, as in fmt.Print.\n\nfunc (t *Template) ExecuteTemplate(wr io.Writer, name string, data any) error\n    ExecuteTemplate applies the template associated with t that has the given\n    name to the specified data object and writes the output to wr. If an error\n    occurs executing the template or writing its output, execution stops,\n    but partial results may already have been written to the output writer. A\n    template may be executed safely in parallel, although if parallel executions\n    share a Writer the output may be interleaved.\n\nfunc (t *Template) Funcs(funcMap FuncMap) *Template\n    Funcs adds the elements of the argument map to the template's function map.\n    It must be called before the template is parsed. It panics if a value in the\n    map is not a function with appropriate return type or if the name cannot be\n    used syntactically as a function in a template. It is legal to overwrite\n    elements of the map. The return value is the template, so calls can be\n    chained.\n\nfunc (t *Template) Lookup(name string) *Template\n    Lookup returns the template with the given name that is associated with t.\n    It returns nil if there is no such template or the template has no\n    definition.\n\nfunc (t *Template) Name() string\n    Name returns the name of the template.\n\nfunc (t *Template) New(name string) *Template\n    New allocates a new, undefined template associated with the given one and\n    with the same delimiters. The association, which is transitive, allows one\n    template to invoke another with a {{template}} action.\n\n    Because associated templates share underlying data, template construction\n    cannot be done safely in parallel. Once the templates are constructed,\n    they can be executed in parallel.\n\nfunc (t *Template) Option(opt ...string) *Template\n    Option sets options for the template. Options are described by strings,\n    either a simple string or \"key=value\". There can be at most one equals\n    sign in an option string. If the option string is unrecognized or otherwise\n    invalid, Option panics.\n\n    Known options:\n\n    missingkey: Control the behavior during execution if a map is indexed with a\n    key that is not present in the map.\n\n        \"missingkey=default\" or \"missingkey=invalid\"\n        \tThe default behavior: Do nothing and continue execution.\n        \tIf printed, the result of the index operation is the string\n        \t\"<no value>\".\n        \"missingkey=zero\"\n        \tThe operation returns the zero value for the map type's element.\n        \"missingkey=error\"\n        \tExecution stops immediately with an error.\n\nfunc (t *Template) Parse(text string) (*Template, error)\n    Parse parses text as a template body for t. Named template definitions\n    ({{define ...}} or {{block ...}} statements) in text define additional\n    templates associated with t and are removed from the definition of t itself.\n\n    Templates can be redefined in successive calls to Parse. A template\n    definition with a body containing only white space and comments is\n    considered empty and will not replace an existing template's body. This\n    allows using Parse to add new named template definitions without overwriting\n    the main template body.\n\nfunc (t *Template) ParseFS(fsys fs.FS, patterns ...string) (*Template, error)\n    ParseFS is like Template.ParseFiles or Template.ParseGlob but reads from\n    the file system fsys instead of the host operating system's file system.\n    It accepts a list of glob patterns (see path.Match). (Note that most file\n    names serve as glob patterns matching only themselves.)\n\nfunc (t *Template) ParseFiles(filenames ...string) (*Template, error)\n    ParseFiles parses the named files and associates the resulting templates\n    with t. If an error occurs, parsing stops and the returned template is nil;\n    otherwise it is t. There must be at least one file. Since the templates\n    created by ParseFiles are named by the base (see filepath.Base) names of\n    the argument files, t should usually have the name of one of the (base)\n    names of the files. If it does not, depending on t's contents before calling\n    ParseFiles, t.Execute may fail. In that case use t.ExecuteTemplate to\n    execute a valid template.\n\n    When parsing multiple files with the same name in different directories,\n    the last one mentioned will be the one that results.\n\nfunc (t *Template) ParseGlob(pattern string) (*Template, error)\n    ParseGlob parses the template definitions in the files identified by the\n    pattern and associates the resulting templates with t. The files are matched\n    according to the semantics of filepath.Match, and the pattern must match at\n    least one file. ParseGlob is equivalent to calling Template.ParseFiles with\n    the list of files matched by the pattern.\n\n    When parsing multiple files with the same name in different directories,\n    the last one mentioned will be the one that results.\n\nfunc (t *Template) Templates() []*Template\n    Templates returns a slice of defined templates associated with t.\n\n"}, {"path": "stdlib/crypto-internal-fips140-edwards25519-field.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-edwards25519-field", "content": "package field // import \"crypto/internal/fips140/edwards25519/field\"\n\nPackage field implements fast arithmetic modulo 2^255-19.\n\nTYPES\n\ntype Element struct {\n\t// Has unexported fields.\n}\n    Element represents an element of the field GF(2^255-19). Note that this is\n    not a cryptographically secure group, and should only be used to interact\n    with edwards25519.Point coordinates.\n\n    This type works similarly to math/big.Int, and all arguments and receivers\n    are allowed to alias.\n\n    The zero value is a valid zero element.\n\nfunc (v *Element) Absolute(u *Element) *Element\n    Absolute sets v to |u|, and returns v.\n\nfunc (v *Element) Add(a, b *Element) *Element\n    Add sets v = a + b, and returns v.\n\nfunc (v *Element) Bytes() []byte\n    Bytes returns the canonical 32-byte little-endian encoding of v.\n\nfunc (v *Element) Equal(u *Element) int\n    Equal returns 1 if v and u are equal, and 0 otherwise.\n\nfunc (v *Element) Invert(z *Element) *Element\n    Invert sets v = 1/z mod p, and returns v.\n\n    If z == 0, Invert returns v = 0.\n\nfunc (v *Element) IsNegative() int\n    IsNegative returns 1 if v is negative, and 0 otherwise.\n\nfunc (v *Element) Mult32(x *Element, y uint32) *Element\n    Mult32 sets v = x * y, and returns v.\n\nfunc (v *Element) Multiply(x, y *Element) *Element\n    Multiply sets v = x * y, and returns v.\n\nfunc (v *Element) Negate(a *Element) *Element\n    Negate sets v = -a, and returns v.\n\nfunc (v *Element) One() *Element\n    One sets v = 1, and returns v.\n\nfunc (v *Element) Pow22523(x *Element) *Element\n    Pow22523 set v = x^((p-5)/8), and returns v. (p-5)/8 is 2^252-3.\n\nfunc (v *Element) Select(a, b *Element, cond int) *Element\n    Select sets v to a if cond == 1, and to b if cond == 0.\n\nfunc (v *Element) Set(a *Element) *Element\n    Set sets v = a, and returns v.\n\nfunc (v *Element) SetBytes(x []byte) (*Element, error)\n    SetBytes sets v to x, where x is a 32-byte little-endian encoding. If x is\n    not of the right length, SetBytes returns nil and an error, and the receiver\n    is unchanged.\n\n    Consistent with RFC 7748, the most significant bit (the high bit of the last\n    byte) is ignored, and non-canonical values (2^255-19 through 2^255-1) are\n    accepted. Note that this is laxer than specified by RFC 8032, but consistent\n    with most Ed25519 implementations.\n\nfunc (r *Element) SqrtRatio(u, v *Element) (R *Element, wasSquare int)\n    SqrtRatio sets r to the non-negative square root of the ratio of u and v.\n\n    If u/v is square, SqrtRatio returns r and 1. If u/v is not square, SqrtRatio\n    sets r according to Section 4.3 of draft-irtf-cfrg-ristretto255-decaf448-00,\n    and returns r and 0.\n\nfunc (v *Element) Square(x *Element) *Element\n    Square sets v = x * x, and returns v.\n\nfunc (v *Element) Subtract(a, b *Element) *Element\n    Subtract sets v = a - b, and returns v.\n\nfunc (v *Element) Swap(u *Element, cond int)\n    Swap swaps v and u if cond == 1 or leaves them unchanged if cond == 0,\n    and returns v.\n\nfunc (v *Element) Zero() *Element\n    Zero sets v = 0, and returns v.\n\n"}, {"path": "stdlib/go-token.md", "category": "stdlib", "name": "stdlib/go-token", "content": "package token // import \"go/token\"\n\nPackage token defines constants representing the lexical tokens of the Go\nprogramming language and basic operations on tokens (printing, predicates).\n\nCONSTANTS\n\nconst (\n\tLowestPrec  = 0 // non-operators\n\tUnaryPrec   = 6\n\tHighestPrec = 7\n)\n    A set of constants for precedence-based expression parsing. Non-operators\n    have lowest precedence, followed by operators starting with precedence 1 up\n    to unary operators. The highest precedence serves as \"catch-all\" precedence\n    for selector, indexing, and other operator and delimiter tokens.\n\n\nFUNCTIONS\n\nfunc IsExported(name string) bool\n    IsExported reports whether name starts with an upper-case letter.\n\nfunc IsIdentifier(name string) bool\n    IsIdentifier reports whether name is a Go identifier, that is, a non-empty\n    string made up of letters, digits, and underscores, where the first\n    character is not a digit. Keywords are not identifiers.\n\nfunc IsKeyword(name string) bool\n    IsKeyword reports whether name is a Go keyword, such as \"func\" or \"return\".\n\n\nTYPES\n\ntype File struct {\n\t// Has unexported fields.\n}\n    A File is a handle for a file belonging to a FileSet. A File has a name,\n    size, and line offset table.\n\n    Use FileSet.AddFile to create a File. A File may belong to more than one\n    FileSet; see FileSet.AddExistingFiles.\n\nfunc (f *File) AddLine(offset int)\n    AddLine adds the line offset for a new line. The line offset must be larger\n    than the offset for the previous line and smaller than the file size;\n    otherwise the line offset is ignored.\n\nfunc (f *File) AddLineColumnInfo(offset int, filename string, line, column int)\n    AddLineColumnInfo adds alternative file, line, and column number information\n    for a given file offset. The offset must be larger than the offset for\n    the previously added alternative line info and smaller than the file size;\n    otherwise the information is ignored.\n\n    AddLineColumnInfo is typically used to register alternative position\n    information for line directives such as //line filename:line:column.\n\nfunc (f *File) AddLineInfo(offset int, filename string, line int)\n    AddLineInfo is like File.AddLineColumnInfo with a column = 1 argument.\n    It is here for backward-compatibility for code prior to Go 1.11.\n\nfunc (f *File) Base() int\n    Base returns the base offset of file f as registered with AddFile.\n\nfunc (f *File) Line(p Pos) int\n    Line returns the line number for the given file position p; p must be a Pos\n    value in that file or NoPos.\n\nfunc (f *File) LineCount() int\n    LineCount returns the number of lines in file f.\n\nfunc (f *File) LineStart(line int) Pos\n    LineStart returns the Pos value of the start of the specified line.\n    It ignores any alternative positions set using File.AddLineColumnInfo.\n    LineStart panics if the 1-based line number is invalid.\n\nfunc (f *File) Lines() []int\n    Lines returns the effective line offset table of the form described by\n    File.SetLines. Callers must not mutate the result.\n\nfunc (f *File) MergeLine(line int)\n    MergeLine merges a line with the following line. It is akin to replacing\n    the newline character at the end of the line with a space (to not change the\n    remaining offsets). To obtain the line number, consult e.g. [Position.Line].\n    MergeLine will panic if given an invalid line number.\n\nfunc (f *File) Name() string\n    Name returns the file name of file f as registered with AddFile.\n\nfunc (f *File) Offset(p Pos) int\n    Offset returns the offset for the given file position p.\n\n    If p is before the file's start position (or if p is NoPos), the result is\n    0; if p is past the file's end position, the result is the file size (see\n    also go.dev/issue/57490).\n\n    The following invariant, though not true for offset values in general,\n    holds for the result offset: f.Offset(f.Pos(offset)) == offset\n\nfunc (f *File) Pos(offset int) Pos\n    Pos returns the Pos value for the given file offset.\n\n    If offset is negative, the result is the file's start position; if the\n    offset is too large, the result is the file's end position (see also\n    go.dev/issue/57490).\n\n    The following invariant, though not true for Pos values in general, holds\n    for the result p: f.Pos(f.Offset(p)) == p.\n\nfunc (f *File) Position(p Pos) (pos Position)\n    Position returns the Position value for the given file position p.\n    If p is out of bounds, it is adjusted to match the File.Offset behavior.\n    Calling f.Position(p) is equivalent to calling f.PositionFor(p, true).\n\nfunc (f *File) PositionFor(p Pos, adjusted bool) (pos Position)\n    PositionFor returns the Position value for the given file position p.\n    If p is out of bounds, it is adjusted to match the File.Offset behavior.\n    If adjusted is set, the position may be adjusted by position-altering //line\n    comments; otherwise those comments are ignored. p must be a Pos value in f\n    or NoPos.\n\nfunc (f *File) SetLines(lines []int) bool\n    SetLines sets the line offsets for a file and reports whether it succeeded.\n    The line offsets are the offsets of the first character of each line;\n    for instance for the content \"ab\\nc\\n\" the line offsets are {0, 3}. An empty\n    file has an empty line offset table. Each line offset must be larger than\n    the offset for the previous line and smaller than the file size; otherwise\n    SetLines fails and returns false. Callers must not mutate the provided slice\n    after SetLines returns.\n\nfunc (f *File) SetLinesForContent(content []byte)\n    SetLinesForContent sets the line offsets for the given file content.\n    It ignores position-altering //line comments.\n\nfunc (f *File) Size() int\n    Size returns the size of file f as registered with AddFile.\n\ntype FileSet struct {\n\t// Has unexported fields.\n}\n    A FileSet represents a set of source files. Methods of file sets are\n    synchronized; multiple goroutines may invoke them concurrently.\n\n    The byte offsets for each file in a file set are mapped into distinct\n    (integer) intervals, one interval [base, base+size] per file. FileSet.Base\n    represents the first byte in the file, and size is the corresponding\n    file size. A Pos value is a value in such an interval. By determining the\n    interval a Pos value belongs to, the file, its file base, and thus the byte\n    offset (position) the Pos value is representing can be computed.\n\n    When adding a new file, a file base must be provided. That can be any\n    integer value that is past the end of any interval of any file already\n    in the file set. For convenience, FileSet.Base provides such a value,\n    which is simply the end of the Pos interval of the most recently added file,\n    plus one. Unless there is a need to extend an interval later, using the\n    FileSet.Base should be used as argument for FileSet.AddFile.\n\n    A File may be removed from a FileSet when it is no longer needed. This may\n    reduce memory usage in a long-running application.\n\nfunc NewFileSet() *FileSet\n    NewFileSet creates a new file set.\n\nfunc (s *FileSet) AddExistingFiles(files ...*File)\n    AddExistingFiles adds the specified files to the FileSet if they are not\n    already present. The caller must ensure that no pair of Files that would\n    appear in the resulting FileSet overlap.\n\nfunc (s *FileSet) AddFile(filename string, base, size int) *File\n    AddFile adds a new file with a given filename, base offset, and file size to\n    the file set s and returns the file. Multiple files may have the same name.\n    The base offset must not be smaller than the FileSet.Base, and size must not\n    be negative. As a special case, if a negative base is provided, the current\n    value of the FileSet.Base is used instead.\n\n    Adding the file will set the file set's FileSet.Base value to base + size +\n    1 as the minimum base value for the next file. The following relationship\n    exists between a Pos value p for a given file offset offs:\n\n        int(p) = base + offs\n\n    with offs in the range [0, size] and thus p in the range [base, base+size].\n    For convenience, File.Pos may be used to create file-specific position\n    values from a file offset.\n\nfunc (s *FileSet) Base() int\n    Base returns the minimum base offset that must be provided to\n    FileSet.AddFile when adding the next file.\n\nfunc (s *FileSet) File(p Pos) (f *File)\n    File returns the file that contains the position p. If no such file is found\n    (for instance for p == NoPos), the result is nil.\n\nfunc (s *FileSet) Iterate(yield func(*File) bool)\n    Iterate calls yield for the files in the file set in ascending Base order\n    until yield returns false.\n\nfunc (s *FileSet) Position(p Pos) (pos Position)\n    Position converts a Pos p in the fileset into a Position value. Calling\n    s.Position(p) is equivalent to calling s.PositionFor(p, true).\n\nfunc (s *FileSet) PositionFor(p Pos, adjusted bool) (pos Position)\n    PositionFor converts a Pos p in the fileset into a Position value.\n    If adjusted is set, the position may be adjusted by position-altering //line\n    comments; otherwise those comments are ignored. p must be a Pos value in s\n    or NoPos.\n\nfunc (s *FileSet) Read(decode func(any) error) error\n    Read calls decode to deserialize a file set into s; s must not be nil.\n\nfunc (s *FileSet) RemoveFile(file *File)\n    RemoveFile removes a file from the FileSet so that subsequent queries for\n    its Pos interval yield a negative result. This reduces the memory usage of a\n    long-lived FileSet that encounters an unbounded stream of files.\n\n    Removing a file that does not belong to the set has no effect.\n\nfunc (s *FileSet) Write(encode func(any) error) error\n    Write calls encode to serialize the file set s.\n\ntype Pos int\n    Pos is a compact encoding of a source position within a file set.\n    It can be converted into a Position for a more convenient, but much larger,\n    representation.\n\n    The Pos value for a given file is a number in the range [base, base+size],\n    where base and size are specified when a file is added to the file set. The\n    difference between a Pos value and the corresponding file base corresponds\n    to the byte offset of that position (represented by the Pos value) from\n    the beginning of the file. Thus, the file base offset is the Pos value\n    representing the first byte in the file.\n\n    To create the Pos value for a specific source offset (measured in bytes),\n    first add the respective file to the current file set using FileSet.AddFile\n    and then call File.Pos(offset) for that file. Given a Pos value p for a\n    specific file set fset, the corresponding Position value is obtained by\n    calling fset.Position(p).\n\n    Pos values can be compared directly with the usual comparison operators: If\n    two Pos values p and q are in the same file, comparing p and q is equivalent\n    to comparing the respective source file offsets. If p and q are in different\n    files, p < q is true if the file implied by p was added to the respective\n    file set before the file implied by q.\n\nconst NoPos Pos = 0\n    The zero value for Pos is NoPos; there is no file and line information\n    associated with it, and NoPos.IsValid() is false. NoPos is always smaller\n    than any other Pos value. The corresponding Position value for NoPos is the\n    zero value for Position.\n\nfunc (p Pos) IsValid() bool\n    IsValid reports whether the position is valid.\n\ntype Position struct {\n\tFilename string // filename, if any\n\tOffset   int    // offset, starting at 0\n\tLine     int    // line number, starting at 1\n\tColumn   int    // column number, starting at 1 (byte count)\n}\n    Position describes an arbitrary source position including the file, line,\n    and column location. A Position is valid if the line number is > 0.\n\nfunc (pos *Position) IsValid() bool\n    IsValid reports whether the position is valid.\n\nfunc (pos Position) String() string\n    String returns a string in one of several forms:\n\n        file:line:column    valid position with file name\n        file:line           valid position with file name but no column (column == 0)\n        line:column         valid position without file name\n        line                valid position without file name and no column (column == 0)\n        file                invalid position with file name\n        -                   invalid position without file name\n\ntype Token int\n    Token is the set of lexical tokens of the Go programming language.\n\nconst (\n\t// Special tokens\n\tILLEGAL Token = iota\n\tEOF\n\tCOMMENT\n\n\t// Identifiers and basic type literals\n\t// (these tokens stand for classes of literals)\n\tIDENT  // main\n\tINT    // 12345\n\tFLOAT  // 123.45\n\tIMAG   // 123.45i\n\tCHAR   // 'a'\n\tSTRING // \"abc\"\n\n\t// Operators and delimiters\n\tADD // +\n\tSUB // -\n\tMUL // *\n\tQUO // /\n\tREM // %\n\n\tAND     // &\n\tOR      // |\n\tXOR     // ^\n\tSHL     // <<\n\tSHR     // >>\n\tAND_NOT // &^\n\n\tADD_ASSIGN // +=\n\tSUB_ASSIGN // -=\n\tMUL_ASSIGN // *=\n\tQUO_ASSIGN // /=\n\tREM_ASSIGN // %=\n\n\tAND_ASSIGN     // &=\n\tOR_ASSIGN      // |=\n\tXOR_ASSIGN     // ^=\n\tSHL_ASSIGN     // <<=\n\tSHR_ASSIGN     // >>=\n\tAND_NOT_ASSIGN // &^=\n\n\tLAND  // &&\n\tLOR   // ||\n\tARROW // <-\n\tINC   // ++\n\tDEC   // --\n\n\tEQL    // ==\n\tLSS    // <\n\tGTR    // >\n\tASSIGN // =\n\tNOT    // !\n\n\tNEQ      // !=\n\tLEQ      // <=\n\tGEQ      // >=\n\tDEFINE   // :=\n\tELLIPSIS // ...\n\n\tLPAREN // (\n\tLBRACK // [\n\tLBRACE // {\n\tCOMMA  // ,\n\tPERIOD // .\n\n\tRPAREN    // )\n\tRBRACK    // ]\n\tRBRACE    // }\n\tSEMICOLON // ;\n\tCOLON     // :\n\n\t// Keywords\n\tBREAK\n\tCASE\n\tCHAN\n\tCONST\n\tCONTINUE\n\n\tDEFAULT\n\tDEFER\n\tELSE\n\tFALLTHROUGH\n\tFOR\n\n\tFUNC\n\tGO\n\tGOTO\n\tIF\n\tIMPORT\n\n\tINTERFACE\n\tMAP\n\tPACKAGE\n\tRANGE\n\tRETURN\n\n\tSELECT\n\tSTRUCT\n\tSWITCH\n\tTYPE\n\tVAR\n\n\t// additional tokens, handled in an ad-hoc manner\n\tTILDE\n)\n    The list of tokens.\n\nfunc Lookup(ident string) Token\n    Lookup maps an identifier to its keyword token or IDENT (if not a keyword).\n\nfunc (tok Token) IsKeyword() bool\n    IsKeyword returns true for tokens corresponding to keywords; it returns\n    false otherwise.\n\nfunc (tok Token) IsLiteral() bool\n    IsLiteral returns true for tokens corresponding to identifiers and basic\n    type literals; it returns false otherwise.\n\nfunc (tok Token) IsOperator() bool\n    IsOperator returns true for tokens corresponding to operators and\n    delimiters; it returns false otherwise.\n\nfunc (op Token) Precedence() int\n    Precedence returns the operator precedence of the binary operator op.\n    If op is not a binary operator, the result is LowestPrecedence.\n\nfunc (tok Token) String() string\n    String returns the string corresponding to the token tok. For operators,\n    delimiters, and keywords the string is the actual token character sequence\n    (e.g., for the token ADD, the string is \"+\"). For all other tokens the\n    string corresponds to the token constant name (e.g. for the token IDENT,\n    the string is \"IDENT\").\n\n"}, {"path": "stdlib/net-mail.md", "category": "stdlib", "name": "stdlib/net-mail", "content": "package mail // import \"net/mail\"\n\nPackage mail implements parsing of mail messages.\n\nFor the most part, this package follows the syntax as specified by RFC 5322 and\nextended by RFC 6532. Notable divergences:\n  - Obsolete address formats are not parsed, including addresses with embedded\n    route information.\n  - The full range of spacing (the CFWS syntax element) is not supported,\n    such as breaking addresses across lines.\n  - No unicode normalization is performed.\n  - A leading From line is permitted, as in mbox format (RFC 4155).\n\nVARIABLES\n\nvar ErrHeaderNotPresent = errors.New(\"mail: header not in message\")\n\nFUNCTIONS\n\nfunc ParseDate(date string) (time.Time, error)\n    ParseDate parses an RFC 5322 date string.\n\n\nTYPES\n\ntype Address struct {\n\tName    string // Proper name; may be empty.\n\tAddress string // user@domain\n}\n    Address represents a single mail address. An address such as \"Barry Gibbs\n    <bg@example.com>\" is represented as Address{Name: \"Barry Gibbs\", Address:\n    \"bg@example.com\"}.\n\nfunc ParseAddress(address string) (*Address, error)\n    ParseAddress parses a single RFC 5322 address, e.g. \"Barry Gibbs\n    <bg@example.com>\"\n\nfunc ParseAddressList(list string) ([]*Address, error)\n    ParseAddressList parses the given string as a list of addresses.\n\nfunc (a *Address) String() string\n    String formats the address as a valid RFC 5322 address. If the address's\n    name contains non-ASCII characters the name will be rendered according to\n    RFC 2047.\n\ntype AddressParser struct {\n\t// WordDecoder optionally specifies a decoder for RFC 2047 encoded-words.\n\tWordDecoder *mime.WordDecoder\n}\n    An AddressParser is an RFC 5322 address parser.\n\nfunc (p *AddressParser) Parse(address string) (*Address, error)\n    Parse parses a single RFC 5322 address of the form \"Gogh Fir\n    <gf@example.com>\" or \"foo@example.com\".\n\nfunc (p *AddressParser) ParseList(list string) ([]*Address, error)\n    ParseList parses the given string as a list of comma-separated addresses of\n    the form \"Gogh Fir <gf@example.com>\" or \"foo@example.com\".\n\ntype Header map[string][]string\n    A Header represents the key-value pairs in a mail message header.\n\nfunc (h Header) AddressList(key string) ([]*Address, error)\n    AddressList parses the named header field as a list of addresses.\n\nfunc (h Header) Date() (time.Time, error)\n    Date parses the Date header field.\n\nfunc (h Header) Get(key string) string\n    Get gets the first value associated with the given key. It is case\n    insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided\n    key. If there are no values associated with the key, Get returns \"\".\n    To access multiple values of a key, or to use non-canonical keys, access the\n    map directly.\n\ntype Message struct {\n\tHeader Header\n\tBody   io.Reader\n}\n    A Message represents a parsed mail message.\n\nfunc ReadMessage(r io.Reader) (msg *Message, err error)\n    ReadMessage reads a message from r. The headers are parsed, and the body of\n    the message will be available for reading from msg.Body.\n\n"}, {"path": "stdlib/encoding-binary.md", "category": "stdlib", "name": "stdlib/encoding-binary", "content": "package binary // import \"encoding/binary\"\n\nPackage binary implements simple translation between numbers and byte sequences\nand encoding and decoding of varints.\n\nNumbers are translated by reading and writing fixed-size values. A fixed-size\nvalue is either a fixed-size arithmetic type (bool, int8, uint8, int16, float32,\ncomplex64, ...) or an array or struct containing only fixed-size values.\n\nThe varint functions encode and decode single integer values using a\nvariable-length encoding; smaller values require fewer bytes. For a\nspecification, see https://developers.google.com/protocol-buffers/docs/encoding.\n\nThis package favors simplicity over efficiency. Clients that require\nhigh-performance serialization, especially for large data structures,\nshould look at more advanced solutions such as the encoding/gob package or\ngoogle.golang.org/protobuf for protocol buffers.\n\nCONSTANTS\n\nconst (\n\tMaxVarintLen16 = 3\n\tMaxVarintLen32 = 5\n\tMaxVarintLen64 = 10\n)\n    MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.\n\n\nVARIABLES\n\nvar BigEndian bigEndian\n    BigEndian is the big-endian implementation of ByteOrder and AppendByteOrder.\n\nvar LittleEndian littleEndian\n    LittleEndian is the little-endian implementation of ByteOrder and\n    AppendByteOrder.\n\nvar NativeEndian nativeEndian\n    NativeEndian is the native-endian implementation of ByteOrder and\n    AppendByteOrder.\n\n\nFUNCTIONS\n\nfunc Append(buf []byte, order ByteOrder, data any) ([]byte, error)\n    Append appends the binary representation of data to buf. buf may be nil,\n    in which case a new buffer will be allocated. See Write on which data are\n    acceptable. It returns the (possibly extended) buffer containing data or an\n    error.\n\nfunc AppendUvarint(buf []byte, x uint64) []byte\n    AppendUvarint appends the varint-encoded form of x, as generated by\n    PutUvarint, to buf and returns the extended buffer.\n\nfunc AppendVarint(buf []byte, x int64) []byte\n    AppendVarint appends the varint-encoded form of x, as generated by\n    PutVarint, to buf and returns the extended buffer.\n\nfunc Decode(buf []byte, order ByteOrder, data any) (int, error)\n    Decode decodes binary data from buf into data according to the given byte\n    order. It returns an error if buf is too small, otherwise the number of\n    bytes consumed from buf.\n\nfunc Encode(buf []byte, order ByteOrder, data any) (int, error)\n    Encode encodes the binary representation of data into buf according to the\n    given byte order. It returns an error if buf is too small, otherwise the\n    number of bytes written into buf.\n\nfunc PutUvarint(buf []byte, x uint64) int\n    PutUvarint encodes a uint64 into buf and returns the number of bytes\n    written. If the buffer is too small, PutUvarint will panic.\n\nfunc PutVarint(buf []byte, x int64) int\n    PutVarint encodes an int64 into buf and returns the number of bytes written.\n    If the buffer is too small, PutVarint will panic.\n\nfunc Read(r io.Reader, order ByteOrder, data any) error\n    Read reads structured binary data from r into data. Data must be a pointer\n    to a fixed-size value or a slice of fixed-size values. Bytes read from r\n    are decoded using the specified byte order and written to successive fields\n    of the data. When decoding boolean values, a zero byte is decoded as false,\n    and any other non-zero byte is decoded as true. When reading into structs,\n    the field data for fields with blank (_) field names is skipped; i.e.,\n    blank field names may be used for padding. When reading into a struct,\n    all non-blank fields must be exported or Read may panic.\n\n    The error is io.EOF only if no bytes were read. If an io.EOF happens after\n    reading some but not all the bytes, Read returns io.ErrUnexpectedEOF.\n\nfunc ReadUvarint(r io.ByteReader) (uint64, error)\n    ReadUvarint reads an encoded unsigned integer from r and returns it as\n    a uint64. The error is io.EOF only if no bytes were read. If an io.EOF\n    happens after reading some but not all the bytes, ReadUvarint returns\n    io.ErrUnexpectedEOF.\n\nfunc ReadVarint(r io.ByteReader) (int64, error)\n    ReadVarint reads an encoded signed integer from r and returns it as an\n    int64. The error is io.EOF only if no bytes were read. If an io.EOF\n    happens after reading some but not all the bytes, ReadVarint returns\n    io.ErrUnexpectedEOF.\n\nfunc Size(v any) int\n    Size returns how many bytes Write would generate to encode the value v,\n    which must be a fixed-size value or a slice of fixed-size values, or a\n    pointer to such data. If v is neither of these, Size returns -1.\n\nfunc Uvarint(buf []byte) (uint64, int)\n    Uvarint decodes a uint64 from buf and returns that value and the number of\n    bytes read (> 0). If an error occurred, the value is 0 and the number of\n    bytes n is <= 0 meaning:\n      - n == 0: buf too small;\n      - n < 0: value larger than 64 bits (overflow) and -n is the number of\n        bytes read.\n\nfunc Varint(buf []byte) (int64, int)\n    Varint decodes an int64 from buf and returns that value and the number of\n    bytes read (> 0). If an error occurred, the value is 0 and the number of\n    bytes n is <= 0 with the following meaning:\n      - n == 0: buf too small;\n      - n < 0: value larger than 64 bits (overflow) and -n is the number of\n        bytes read.\n\nfunc Write(w io.Writer, order ByteOrder, data any) error\n    Write writes the binary representation of data into w. Data must be a\n    fixed-size value or a slice of fixed-size values, or a pointer to such\n    data. Boolean values encode as one byte: 1 for true, and 0 for false.\n    Bytes written to w are encoded using the specified byte order and read from\n    successive fields of the data. When writing structs, zero values are written\n    for fields with blank (_) field names.\n\n\nTYPES\n\ntype AppendByteOrder interface {\n\tAppendUint16([]byte, uint16) []byte\n\tAppendUint32([]byte, uint32) []byte\n\tAppendUint64([]byte, uint64) []byte\n\tString() string\n}\n    AppendByteOrder specifies how to append 16-, 32-, or 64-bit unsigned\n    integers into a byte slice.\n\n    It is implemented by LittleEndian, BigEndian, and NativeEndian.\n\ntype ByteOrder interface {\n\tUint16([]byte) uint16\n\tUint32([]byte) uint32\n\tUint64([]byte) uint64\n\tPutUint16([]byte, uint16)\n\tPutUint32([]byte, uint32)\n\tPutUint64([]byte, uint64)\n\tString() string\n}\n    A ByteOrder specifies how to convert byte slices into 16-, 32-, or 64-bit\n    unsigned integers.\n\n    It is implemented by LittleEndian, BigEndian, and NativeEndian.\n\n"}, {"path": "stdlib/unique.md", "category": "stdlib", "name": "stdlib/unique", "content": "package unique // import \"unique\"\n\nThe unique package provides facilities for canonicalizing (\"interning\")\ncomparable values.\n\nTYPES\n\ntype Handle[T comparable] struct {\n\t// Has unexported fields.\n}\n    Handle is a globally unique identity for some value of type T.\n\n    Two handles compare equal exactly if the two values used to create the\n    handles would have also compared equal. The comparison of two handles is\n    trivial and typically much more efficient than comparing the values used to\n    create them.\n\nfunc Make[T comparable](value T) Handle[T]\n    Make returns a globally unique handle for a value of type T. Handles are\n    equal if and only if the values used to produce them are equal. Make is safe\n    for concurrent use by multiple goroutines.\n\nfunc (h Handle[T]) Value() T\n    Value returns a shallow copy of the T value that produced the Handle.\n    Value is safe for concurrent use by multiple goroutines.\n\n"}, {"path": "stdlib/crypto-sha3.md", "category": "stdlib", "name": "stdlib/crypto-sha3", "content": "package sha3 // import \"crypto/sha3\"\n\nPackage sha3 implements the SHA-3 hash algorithms and the SHAKE extendable\noutput functions defined in FIPS 202.\n\nFUNCTIONS\n\nfunc Sum224(data []byte) [28]byte\n    Sum224 returns the SHA3-224 hash of data.\n\nfunc Sum256(data []byte) [32]byte\n    Sum256 returns the SHA3-256 hash of data.\n\nfunc Sum384(data []byte) [48]byte\n    Sum384 returns the SHA3-384 hash of data.\n\nfunc Sum512(data []byte) [64]byte\n    Sum512 returns the SHA3-512 hash of data.\n\nfunc SumSHAKE128(data []byte, length int) []byte\n    SumSHAKE128 applies the SHAKE128 extendable output function to data and\n    returns an output of the given length in bytes.\n\nfunc SumSHAKE256(data []byte, length int) []byte\n    SumSHAKE256 applies the SHAKE256 extendable output function to data and\n    returns an output of the given length in bytes.\n\n\nTYPES\n\ntype SHA3 struct {\n\t// Has unexported fields.\n}\n    SHA3 is an instance of a SHA-3 hash. It implements hash.Hash.\n\nfunc New224() *SHA3\n    New224 creates a new SHA3-224 hash.\n\nfunc New256() *SHA3\n    New256 creates a new SHA3-256 hash.\n\nfunc New384() *SHA3\n    New384 creates a new SHA3-384 hash.\n\nfunc New512() *SHA3\n    New512 creates a new SHA3-512 hash.\n\nfunc (s *SHA3) AppendBinary(p []byte) ([]byte, error)\n    AppendBinary implements encoding.BinaryAppender.\n\nfunc (s *SHA3) BlockSize() int\n    BlockSize returns the hash's rate.\n\nfunc (d *SHA3) Clone() (hash.Cloner, error)\n    Clone implements hash.Cloner.\n\nfunc (s *SHA3) MarshalBinary() ([]byte, error)\n    MarshalBinary implements encoding.BinaryMarshaler.\n\nfunc (s *SHA3) Reset()\n    Reset resets the hash to its initial state.\n\nfunc (s *SHA3) Size() int\n    Size returns the number of bytes Sum will produce.\n\nfunc (s *SHA3) Sum(b []byte) []byte\n    Sum appends the current hash to b and returns the resulting slice.\n\nfunc (s *SHA3) UnmarshalBinary(data []byte) error\n    UnmarshalBinary implements encoding.BinaryUnmarshaler.\n\nfunc (s *SHA3) Write(p []byte) (n int, err error)\n    Write absorbs more data into the hash's state.\n\ntype SHAKE struct {\n\t// Has unexported fields.\n}\n    SHAKE is an instance of a SHAKE extendable output function.\n\nfunc NewCSHAKE128(N, S []byte) *SHAKE\n    NewCSHAKE128 creates a new cSHAKE128 XOF.\n\n    N is used to define functions based on cSHAKE, it can be empty when\n    plain cSHAKE is desired. S is a customization byte string used for domain\n    separation. When N and S are both empty, this is equivalent to NewSHAKE128.\n\nfunc NewCSHAKE256(N, S []byte) *SHAKE\n    NewCSHAKE256 creates a new cSHAKE256 XOF.\n\n    N is used to define functions based on cSHAKE, it can be empty when\n    plain cSHAKE is desired. S is a customization byte string used for domain\n    separation. When N and S are both empty, this is equivalent to NewSHAKE256.\n\nfunc NewSHAKE128() *SHAKE\n    NewSHAKE128 creates a new SHAKE128 XOF.\n\nfunc NewSHAKE256() *SHAKE\n    NewSHAKE256 creates a new SHAKE256 XOF.\n\nfunc (s *SHAKE) AppendBinary(p []byte) ([]byte, error)\n    AppendBinary implements encoding.BinaryAppender.\n\nfunc (s *SHAKE) BlockSize() int\n    BlockSize returns the rate of the XOF.\n\nfunc (s *SHAKE) MarshalBinary() ([]byte, error)\n    MarshalBinary implements encoding.BinaryMarshaler.\n\nfunc (s *SHAKE) Read(p []byte) (n int, err error)\n    Read squeezes more output from the XOF.\n\n    Any call to Write after a call to Read will panic.\n\nfunc (s *SHAKE) Reset()\n    Reset resets the XOF to its initial state.\n\nfunc (s *SHAKE) UnmarshalBinary(data []byte) error\n    UnmarshalBinary implements encoding.BinaryUnmarshaler.\n\nfunc (s *SHAKE) Write(p []byte) (n int, err error)\n    Write absorbs more data into the XOF's state.\n\n    It panics if any output has already been read.\n\n"}, {"path": "stdlib/internal-coverage-stringtab.md", "category": "stdlib", "name": "stdlib/internal-coverage-stringtab", "content": "package stringtab // import \"internal/coverage/stringtab\"\n\n\nTYPES\n\ntype Reader struct {\n\t// Has unexported fields.\n}\n    Reader is a helper for reading a string table previously serialized by a\n    Writer.Write call.\n\nfunc NewReader(r *slicereader.Reader) *Reader\n    NewReader creates a stringtab.Reader to read the contents of a string table\n    from 'r'.\n\nfunc (str *Reader) Entries() int\n    Entries returns the number of decoded entries in a string table.\n\nfunc (str *Reader) Get(idx uint32) string\n    Get returns string 'idx' within the string table.\n\nfunc (str *Reader) Read()\n    Read reads/decodes a string table using the reader provided.\n\ntype Writer struct {\n\t// Has unexported fields.\n}\n    Writer implements a string table writing utility.\n\nfunc (stw *Writer) Freeze()\n    Freeze sends a signal to the writer that no more additions are allowed,\n    only lookups of existing strings (if a lookup triggers addition, a panic\n    will result). Useful as a mechanism for \"finalizing\" a string table prior to\n    writing it out.\n\nfunc (stw *Writer) InitWriter()\n    InitWriter initializes a stringtab.Writer.\n\nfunc (stw *Writer) Lookup(s string) uint32\n    Lookup looks up string 's' in the writer's table, adding a new entry if need\n    be, and returning an index into the table.\n\nfunc (stw *Writer) Nentries() uint32\n    Nentries returns the number of strings interned so far.\n\nfunc (stw *Writer) Size() uint32\n    Size computes the memory in bytes needed for the serialized version of a\n    stringtab.Writer.\n\nfunc (stw *Writer) Write(w io.Writer) error\n    Write writes the string table in serialized form to the specified io.Writer.\n\n"}, {"path": "stdlib/io.md", "category": "stdlib", "name": "stdlib/io", "content": "package io // import \"io\"\n\nPackage io provides basic interfaces to I/O primitives. Its primary job is to\nwrap existing implementations of such primitives, such as those in package os,\ninto shared public interfaces that abstract the functionality, plus some other\nrelated primitives.\n\nBecause these interfaces and primitives wrap lower-level operations with various\nimplementations, unless otherwise informed clients should not assume they are\nsafe for parallel execution.\n\nCONSTANTS\n\nconst (\n\tSeekStart   = 0 // seek relative to the origin of the file\n\tSeekCurrent = 1 // seek relative to the current offset\n\tSeekEnd     = 2 // seek relative to the end\n)\n    Seek whence values.\n\n\nVARIABLES\n\nvar EOF = errors.New(\"EOF\")\n    EOF is the error returned by Read when no more input is available. (Read\n    must return EOF itself, not an error wrapping EOF, because callers will test\n    for EOF using ==.) Functions should return EOF only to signal a graceful\n    end of input. If the EOF occurs unexpectedly in a structured data stream,\n    the appropriate error is either ErrUnexpectedEOF or some other error giving\n    more detail.\n\nvar ErrClosedPipe = errors.New(\"io: read/write on closed pipe\")\n    ErrClosedPipe is the error used for read or write operations on a closed\n    pipe.\n\nvar ErrNoProgress = errors.New(\"multiple Read calls return no data or error\")\n    ErrNoProgress is returned by some clients of a Reader when many calls to\n    Read have failed to return any data or error, usually the sign of a broken\n    Reader implementation.\n\nvar ErrShortBuffer = errors.New(\"short buffer\")\n    ErrShortBuffer means that a read required a longer buffer than was provided.\n\nvar ErrShortWrite = errors.New(\"short write\")\n    ErrShortWrite means that a write accepted fewer bytes than requested but\n    failed to return an explicit error.\n\nvar ErrUnexpectedEOF = errors.New(\"unexpected EOF\")\n    ErrUnexpectedEOF means that EOF was encountered in the middle of reading a\n    fixed-size block or data structure.\n\n\nFUNCTIONS\n\nfunc Copy(dst Writer, src Reader) (written int64, err error)\n    Copy copies from src to dst until either EOF is reached on src or an\n    error occurs. It returns the number of bytes copied and the first error\n    encountered while copying, if any.\n\n    A successful Copy returns err == nil, not err == EOF. Because Copy is\n    defined to read from src until EOF, it does not treat an EOF from Read as an\n    error to be reported.\n\n    If src implements WriterTo, the copy is implemented by calling\n    src.WriteTo(dst). Otherwise, if dst implements ReaderFrom, the copy is\n    implemented by calling dst.ReadFrom(src).\n\nfunc CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)\n    CopyBuffer is identical to Copy except that it stages through the provided\n    buffer (if one is required) rather than allocating a temporary one.\n    If buf is nil, one is allocated; otherwise if it has zero length, CopyBuffer\n    panics.\n\n    If either src implements WriterTo or dst implements ReaderFrom, buf will not\n    be used to perform the copy.\n\nfunc CopyN(dst Writer, src Reader, n int64) (written int64, err error)\n    CopyN copies n bytes (or until an error) from src to dst. It returns the\n    number of bytes copied and the earliest error encountered while copying.\n    On return, written == n if and only if err == nil.\n\n    If dst implements ReaderFrom, the copy is implemented using it.\n\nfunc Pipe() (*PipeReader, *PipeWriter)\n    Pipe creates a synchronous in-memory pipe. It can be used to connect code\n    expecting an io.Reader with code expecting an io.Writer.\n\n    Reads and Writes on the pipe are matched one to one except when multiple\n    Reads are needed to consume a single Write. That is, each Write to the\n    PipeWriter blocks until it has satisfied one or more Reads from the\n    PipeReader that fully consume the written data. The data is copied directly\n    from the Write to the corresponding Read (or Reads); there is no internal\n    buffering.\n\n    It is safe to call Read and Write in parallel with each other or with Close.\n    Parallel calls to Read and parallel calls to Write are also safe: the\n    individual calls will be gated sequentially.\n\nfunc ReadAll(r Reader) ([]byte, error)\n    ReadAll reads from r until an error or EOF and returns the data it read.\n    A successful call returns err == nil, not err == EOF. Because ReadAll is\n    defined to read from src until EOF, it does not treat an EOF from Read as an\n    error to be reported.\n\nfunc ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)\n    ReadAtLeast reads from r into buf until it has read at least min bytes.\n    It returns the number of bytes copied and an error if fewer bytes were read.\n    The error is EOF only if no bytes were read. If an EOF happens after\n    reading fewer than min bytes, ReadAtLeast returns ErrUnexpectedEOF. If min\n    is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\n    On return, n >= min if and only if err == nil. If r returns an error having\n    read at least min bytes, the error is dropped.\n\nfunc ReadFull(r Reader, buf []byte) (n int, err error)\n    ReadFull reads exactly len(buf) bytes from r into buf. It returns the number\n    of bytes copied and an error if fewer bytes were read. The error is EOF only\n    if no bytes were read. If an EOF happens after reading some but not all the\n    bytes, ReadFull returns ErrUnexpectedEOF. On return, n == len(buf) if and\n    only if err == nil. If r returns an error having read at least len(buf)\n    bytes, the error is dropped.\n\nfunc WriteString(w Writer, s string) (n int, err error)\n    WriteString writes the contents of the string s to w, which accepts a\n    slice of bytes. If w implements StringWriter, [StringWriter.WriteString] is\n    invoked directly. Otherwise, [Writer.Write] is called exactly once.\n\n\nTYPES\n\ntype ByteReader interface {\n\tReadByte() (byte, error)\n}\n    ByteReader is the interface that wraps the ReadByte method.\n\n    ReadByte reads and returns the next byte from the input or any error\n    encountered. If ReadByte returns an error, no input byte was consumed,\n    and the returned byte value is undefined.\n\n    ReadByte provides an efficient interface for byte-at-time processing.\n    A Reader that does not implement ByteReader can be wrapped using\n    bufio.NewReader to add this method.\n\ntype ByteScanner interface {\n\tByteReader\n\tUnreadByte() error\n}\n    ByteScanner is the interface that adds the UnreadByte method to the basic\n    ReadByte method.\n\n    UnreadByte causes the next call to ReadByte to return the last byte read.\n    If the last operation was not a successful call to ReadByte, UnreadByte\n    may return an error, unread the last byte read (or the byte prior to the\n    last-unread byte), or (in implementations that support the Seeker interface)\n    seek to one byte before the current offset.\n\ntype ByteWriter interface {\n\tWriteByte(c byte) error\n}\n    ByteWriter is the interface that wraps the WriteByte method.\n\ntype Closer interface {\n\tClose() error\n}\n    Closer is the interface that wraps the basic Close method.\n\n    The behavior of Close after the first call is undefined. Specific\n    implementations may document their own behavior.\n\ntype LimitedReader struct {\n\tR Reader // underlying reader\n\tN int64  // max bytes remaining\n}\n    A LimitedReader reads from R but limits the amount of data returned to just\n    N bytes. Each call to Read updates N to reflect the new amount remaining.\n    Read returns EOF when N <= 0 or when the underlying R returns EOF.\n\nfunc (l *LimitedReader) Read(p []byte) (n int, err error)\n\ntype OffsetWriter struct {\n\t// Has unexported fields.\n}\n    An OffsetWriter maps writes at offset base to offset base+off in the\n    underlying writer.\n\nfunc NewOffsetWriter(w WriterAt, off int64) *OffsetWriter\n    NewOffsetWriter returns an OffsetWriter that writes to w starting at offset\n    off.\n\nfunc (o *OffsetWriter) Seek(offset int64, whence int) (int64, error)\n\nfunc (o *OffsetWriter) Write(p []byte) (n int, err error)\n\nfunc (o *OffsetWriter) WriteAt(p []byte, off int64) (n int, err error)\n\ntype PipeReader struct {\n\t// Has unexported fields.\n}\n    A PipeReader is the read half of a pipe.\n\nfunc (r *PipeReader) Close() error\n    Close closes the reader; subsequent writes to the write half of the pipe\n    will return the error ErrClosedPipe.\n\nfunc (r *PipeReader) CloseWithError(err error) error\n    CloseWithError closes the reader; subsequent writes to the write half of the\n    pipe will return the error err.\n\n    CloseWithError never overwrites the previous error if it exists and always\n    returns nil.\n\nfunc (r *PipeReader) Read(data []byte) (n int, err error)\n    Read implements the standard Read interface: it reads data from the pipe,\n    blocking until a writer arrives or the write end is closed. If the write\n    end is closed with an error, that error is returned as err; otherwise err is\n    EOF.\n\ntype PipeWriter struct {\n\t// Has unexported fields.\n}\n    A PipeWriter is the write half of a pipe.\n\nfunc (w *PipeWriter) Close() error\n    Close closes the writer; subsequent reads from the read half of the pipe\n    will return no bytes and EOF.\n\nfunc (w *PipeWriter) CloseWithError(err error) error\n    CloseWithError closes the writer; subsequent reads from the read half of the\n    pipe will return no bytes and the error err, or EOF if err is nil.\n\n    CloseWithError never overwrites the previous error if it exists and always\n    returns nil.\n\nfunc (w *PipeWriter) Write(data []byte) (n int, err error)\n    Write implements the standard Write interface: it writes data to the pipe,\n    blocking until one or more readers have consumed all the data or the read\n    end is closed. If the read end is closed with an error, that err is returned\n    as err; otherwise err is ErrClosedPipe.\n\ntype ReadCloser interface {\n\tReader\n\tCloser\n}\n    ReadCloser is the interface that groups the basic Read and Close methods.\n\nfunc NopCloser(r Reader) ReadCloser\n    NopCloser returns a ReadCloser with a no-op Close method wrapping the\n    provided Reader r. If r implements WriterTo, the returned ReadCloser will\n    implement WriterTo by forwarding calls to r.\n\ntype ReadSeekCloser interface {\n\tReader\n\tSeeker\n\tCloser\n}\n    ReadSeekCloser is the interface that groups the basic Read, Seek and Close\n    methods.\n\ntype ReadSeeker interface {\n\tReader\n\tSeeker\n}\n    ReadSeeker is the interface that groups the basic Read and Seek methods.\n\ntype ReadWriteCloser interface {\n\tReader\n\tWriter\n\tCloser\n}\n    ReadWriteCloser is the interface that groups the basic Read, Write and Close\n    methods.\n\ntype ReadWriteSeeker interface {\n\tReader\n\tWriter\n\tSeeker\n}\n    ReadWriteSeeker is the interface that groups the basic Read, Write and Seek\n    methods.\n\ntype ReadWriter interface {\n\tReader\n\tWriter\n}\n    ReadWriter is the interface that groups the basic Read and Write methods.\n\ntype Reader interface {\n\tRead(p []byte) (n int, err error)\n}\n    Reader is the interface that wraps the basic Read method.\n\n    Read reads up to len(p) bytes into p. It returns the number of bytes read (0\n    <= n <= len(p)) and any error encountered. Even if Read returns n < len(p),\n    it may use all of p as scratch space during the call. If some data is\n    available but not len(p) bytes, Read conventionally returns what is\n    available instead of waiting for more.\n\n    When Read encounters an error or end-of-file condition after successfully\n    reading n > 0 bytes, it returns the number of bytes read. It may return the\n    (non-nil) error from the same call or return the error (and n == 0) from a\n    subsequent call. An instance of this general case is that a Reader returning\n    a non-zero number of bytes at the end of the input stream may return either\n    err == EOF or err == nil. The next Read should return 0, EOF.\n\n    Callers should always process the n > 0 bytes returned before considering\n    the error err. Doing so correctly handles I/O errors that happen after\n    reading some bytes and also both of the allowed EOF behaviors.\n\n    If len(p) == 0, Read should always return n == 0. It may return a non-nil\n    error if some error condition is known, such as EOF.\n\n    Implementations of Read are discouraged from returning a zero byte count\n    with a nil error, except when len(p) == 0. Callers should treat a return\n    of 0 and nil as indicating that nothing happened; in particular it does not\n    indicate EOF.\n\n    Implementations must not retain p.\n\nfunc LimitReader(r Reader, n int64) Reader\n    LimitReader returns a Reader that reads from r but stops with EOF after n\n    bytes. The underlying implementation is a *LimitedReader.\n\nfunc MultiReader(readers ...Reader) Reader\n    MultiReader returns a Reader that's the logical concatenation of the\n    provided input readers. They're read sequentially. Once all inputs have\n    returned EOF, Read will return EOF. If any of the readers return a non-nil,\n    non-EOF error, Read will return that error.\n\nfunc TeeReader(r Reader, w Writer) Reader\n    TeeReader returns a Reader that writes to w what it reads from r. All reads\n    from r performed through it are matched with corresponding writes to w.\n    There is no internal buffering - the write must complete before the read\n    completes. Any error encountered while writing is reported as a read error.\n\ntype ReaderAt interface {\n\tReadAt(p []byte, off int64) (n int, err error)\n}\n    ReaderAt is the interface that wraps the basic ReadAt method.\n\n    ReadAt reads len(p) bytes into p starting at offset off in the underlying\n    input source. It returns the number of bytes read (0 <= n <= len(p)) and any\n    error encountered.\n\n    When ReadAt returns n < len(p), it returns a non-nil error explaining why\n    more bytes were not returned. In this respect, ReadAt is stricter than Read.\n\n    Even if ReadAt returns n < len(p), it may use all of p as scratch\n    space during the call. If some data is available but not len(p) bytes,\n    ReadAt blocks until either all the data is available or an error occurs.\n    In this respect ReadAt is different from Read.\n\n    If the n = len(p) bytes returned by ReadAt are at the end of the input\n    source, ReadAt may return either err == EOF or err == nil.\n\n    If ReadAt is reading from an input source with a seek offset, ReadAt should\n    not affect nor be affected by the underlying seek offset.\n\n    Clients of ReadAt can execute parallel ReadAt calls on the same input\n    source.\n\n    Implementations must not retain p.\n\ntype ReaderFrom interface {\n\tReadFrom(r Reader) (n int64, err error)\n}\n    ReaderFrom is the interface that wraps the ReadFrom method.\n\n    ReadFrom reads data from r until EOF or error. The return value n is the\n    number of bytes read. Any error except EOF encountered during the read is\n    also returned.\n\n    The Copy function uses ReaderFrom if available.\n\ntype RuneReader interface {\n\tReadRune() (r rune, size int, err error)\n}\n    RuneReader is the interface that wraps the ReadRune method.\n\n    ReadRune reads a single encoded Unicode character and returns the rune and\n    its size in bytes. If no character is available, err will be set.\n\ntype RuneScanner interface {\n\tRuneReader\n\tUnreadRune() error\n}\n    RuneScanner is the interface that adds the UnreadRune method to the basic\n    ReadRune method.\n\n    UnreadRune causes the next call to ReadRune to return the last rune read.\n    If the last operation was not a successful call to ReadRune, UnreadRune\n    may return an error, unread the last rune read (or the rune prior to the\n    last-unread rune), or (in implementations that support the Seeker interface)\n    seek to the start of the rune before the current offset.\n\ntype SectionReader struct {\n\t// Has unexported fields.\n}\n    SectionReader implements Read, Seek, and ReadAt on a section of an\n    underlying ReaderAt.\n\nfunc NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader\n    NewSectionReader returns a SectionReader that reads from r starting at\n    offset off and stops with EOF after n bytes.\n\nfunc (s *SectionReader) Outer() (r ReaderAt, off int64, n int64)\n    Outer returns the underlying ReaderAt and offsets for the section.\n\n    The returned values are the same that were passed to NewSectionReader when\n    the SectionReader was created.\n\nfunc (s *SectionReader) Read(p []byte) (n int, err error)\n\nfunc (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)\n\nfunc (s *SectionReader) Seek(offset int64, whence int) (int64, error)\n\nfunc (s *SectionReader) Size() int64\n    Size returns the size of the section in bytes.\n\ntype Seeker interface {\n\tSeek(offset int64, whence int) (int64, error)\n}\n    Seeker is the interface that wraps the basic Seek method.\n\n    Seek sets the offset for the next Read or Write to offset, interpreted\n    according to whence: SeekStart means relative to the start of the file,\n    SeekCurrent means relative to the current offset, and SeekEnd means relative\n    to the end (for example, offset = -2 specifies the penultimate byte of the\n    file). Seek returns the new offset relative to the start of the file or an\n    error, if any.\n\n    Seeking to an offset before the start of the file is an error. Seeking\n    to any positive offset may be allowed, but if the new offset exceeds the\n    size of the underlying object the behavior of subsequent I/O operations is\n    implementation-dependent.\n\ntype StringWriter interface {\n\tWriteString(s string) (n int, err error)\n}\n    StringWriter is the interface that wraps the WriteString method.\n\ntype WriteCloser interface {\n\tWriter\n\tCloser\n}\n    WriteCloser is the interface that groups the basic Write and Close methods.\n\ntype WriteSeeker interface {\n\tWriter\n\tSeeker\n}\n    WriteSeeker is the interface that groups the basic Write and Seek methods.\n\ntype Writer interface {\n\tWrite(p []byte) (n int, err error)\n}\n    Writer is the interface that wraps the basic Write method.\n\n    Write writes len(p) bytes from p to the underlying data stream. It returns\n    the number of bytes written from p (0 <= n <= len(p)) and any error\n    encountered that caused the write to stop early. Write must return a non-nil\n    error if it returns n < len(p). Write must not modify the slice data,\n    even temporarily.\n\n    Implementations must not retain p.\n\nvar Discard Writer = discard{}\n    Discard is a Writer on which all Write calls succeed without doing anything.\n\nfunc MultiWriter(writers ...Writer) Writer\n    MultiWriter creates a writer that duplicates its writes to all the provided\n    writers, similar to the Unix tee(1) command.\n\n    Each write is written to each listed writer, one at a time. If a listed\n    writer returns an error, that overall write operation stops and returns the\n    error; it does not continue down the list.\n\ntype WriterAt interface {\n\tWriteAt(p []byte, off int64) (n int, err error)\n}\n    WriterAt is the interface that wraps the basic WriteAt method.\n\n    WriteAt writes len(p) bytes from p to the underlying data stream at offset\n    off. It returns the number of bytes written from p (0 <= n <= len(p)) and\n    any error encountered that caused the write to stop early. WriteAt must\n    return a non-nil error if it returns n < len(p).\n\n    If WriteAt is writing to a destination with a seek offset, WriteAt should\n    not affect nor be affected by the underlying seek offset.\n\n    Clients of WriteAt can execute parallel WriteAt calls on the same\n    destination if the ranges do not overlap.\n\n    Implementations must not retain p.\n\ntype WriterTo interface {\n\tWriteTo(w Writer) (n int64, err error)\n}\n    WriterTo is the interface that wraps the WriteTo method.\n\n    WriteTo writes data to w until there's no more data to write or when an\n    error occurs. The return value n is the number of bytes written. Any error\n    encountered during the write is also returned.\n\n    The Copy function uses WriterTo if available.\n\n"}, {"path": "stdlib/internal-syscall-execenv.md", "category": "stdlib", "name": "stdlib/internal-syscall-execenv", "content": "package execenv // import \"internal/syscall/execenv\"\n\n\nFUNCTIONS\n\nfunc Default(sys *syscall.SysProcAttr) ([]string, error)\n    Default will return the default environment variables based on the process\n    attributes provided.\n\n    Defaults to syscall.Environ() on all platforms other than Windows.\n\n"}, {"path": "stdlib/hash-maphash.md", "category": "stdlib", "name": "stdlib/hash-maphash", "content": "package maphash // import \"hash/maphash\"\n\nPackage maphash provides hash functions on byte sequences and comparable values.\nThese hash functions are intended to be used to implement hash tables or other\ndata structures that need to map arbitrary strings or byte sequences to a\nuniform distribution on unsigned 64-bit integers. Each different instance of a\nhash table or data structure should use its own Seed.\n\nThe hash functions are not cryptographically secure. (See crypto/sha256 and\ncrypto/sha512 for cryptographic use.)\n\nFUNCTIONS\n\nfunc Bytes(seed Seed, b []byte) uint64\n    Bytes returns the hash of b with the given seed.\n\n    Bytes is equivalent to, but more convenient and efficient than:\n\n        var h Hash\n        h.SetSeed(seed)\n        h.Write(b)\n        return h.Sum64()\n\nfunc Comparable[T comparable](seed Seed, v T) uint64\n    Comparable returns the hash of comparable value v with the given seed\n    such that Comparable(s, v1) == Comparable(s, v2) if v1 == v2. If v != v,\n    then the resulting hash is randomly distributed.\n\nfunc String(seed Seed, s string) uint64\n    String returns the hash of s with the given seed.\n\n    String is equivalent to, but more convenient and efficient than:\n\n        var h Hash\n        h.SetSeed(seed)\n        h.WriteString(s)\n        return h.Sum64()\n\nfunc WriteComparable[T comparable](h *Hash, x T)\n    WriteComparable adds x to the data hashed by h.\n\n\nTYPES\n\ntype Hash struct {\n\t// Has unexported fields.\n}\n    A Hash computes a seeded hash of a byte sequence.\n\n    The zero Hash is a valid Hash ready to use. A zero Hash chooses a random\n    seed for itself during the first call to a Reset, Write, Seed, Clone,\n    or Sum64 method. For control over the seed, use SetSeed.\n\n    The computed hash values depend only on the initial seed and the sequence\n    of bytes provided to the Hash object, not on the way in which the bytes are\n    provided. For example, the three sequences\n\n        h.Write([]byte{'f','o','o'})\n        h.WriteByte('f'); h.WriteByte('o'); h.WriteByte('o')\n        h.WriteString(\"foo\")\n\n    all have the same effect.\n\n    Hashes are intended to be collision-resistant, even for situations where an\n    adversary controls the byte sequences being hashed.\n\n    A Hash is not safe for concurrent use by multiple goroutines, but a Seed is.\n    If multiple goroutines must compute the same seeded hash, each can declare\n    its own Hash and call SetSeed with a common Seed.\n\nfunc (h *Hash) BlockSize() int\n    BlockSize returns h's block size.\n\nfunc (h *Hash) Clone() (hash.Cloner, error)\n    Clone implements hash.Cloner.\n\nfunc (h *Hash) Reset()\n    Reset discards all bytes added to h. (The seed remains the same.)\n\nfunc (h *Hash) Seed() Seed\n    Seed returns h's seed value.\n\nfunc (h *Hash) SetSeed(seed Seed)\n    SetSeed sets h to use seed, which must have been returned by MakeSeed or\n    by another Hash.Seed method. Two Hash objects with the same seed behave\n    identically. Two Hash objects with different seeds will very likely behave\n    differently. Any bytes added to h before this call will be discarded.\n\nfunc (h *Hash) Size() int\n    Size returns h's hash value size, 8 bytes.\n\nfunc (h *Hash) Sum(b []byte) []byte\n    Sum appends the hash's current 64-bit value to b. It exists for implementing\n    hash.Hash. For direct calls, it is more efficient to use Hash.Sum64.\n\nfunc (h *Hash) Sum64() uint64\n    Sum64 returns h's current 64-bit value, which depends on h's seed and\n    the sequence of bytes added to h since the last call to Hash.Reset or\n    Hash.SetSeed.\n\n    All bits of the Sum64 result are close to uniformly and independently\n    distributed, so it can be safely reduced by using bit masking, shifting,\n    or modular arithmetic.\n\nfunc (h *Hash) Write(b []byte) (int, error)\n    Write adds b to the sequence of bytes hashed by h. It always writes all of b\n    and never fails; the count and error result are for implementing io.Writer.\n\nfunc (h *Hash) WriteByte(b byte) error\n    WriteByte adds b to the sequence of bytes hashed by h. It never fails;\n    the error result is for implementing io.ByteWriter.\n\nfunc (h *Hash) WriteString(s string) (int, error)\n    WriteString adds the bytes of s to the sequence of bytes hashed by h.\n    It always writes all of s and never fails; the count and error result are\n    for implementing io.StringWriter.\n\ntype Seed struct {\n\t// Has unexported fields.\n}\n    A Seed is a random value that selects the specific hash function computed\n    by a Hash. If two Hashes use the same Seeds, they will compute the same hash\n    values for any given input. If two Hashes use different Seeds, they are very\n    likely to compute distinct hash values for any given input.\n\n    A Seed must be initialized by calling MakeSeed. The zero seed is\n    uninitialized and not valid for use with Hash's SetSeed method.\n\n    Each Seed value is local to a single process and cannot be serialized or\n    otherwise recreated in a different process.\n\nfunc MakeSeed() Seed\n    MakeSeed returns a new random seed.\n\n"}, {"path": "stdlib/os-exec-internal-fdtest.md", "category": "stdlib", "name": "stdlib/os-exec-internal-fdtest", "content": "package fdtest // import \"os/exec/internal/fdtest\"\n\nPackage fdtest provides test helpers for working with file descriptors across\nexec.\n\nFUNCTIONS\n\nfunc Exists(fd uintptr) bool\n    Exists returns true if fd is a valid file descriptor.\n\n"}, {"path": "stdlib/html.md", "category": "stdlib", "name": "stdlib/html", "content": "package html // import \"html\"\n\nPackage html provides functions for escaping and unescaping HTML text.\n\nFUNCTIONS\n\nfunc EscapeString(s string) string\n    EscapeString escapes special characters like \"<\" to become \"&lt;\".\n    It escapes only five such characters: <, >, &, ' and \".\n    UnescapeString(EscapeString(s)) == s always holds, but the converse isn't\n    always true.\n\nfunc UnescapeString(s string) string\n    UnescapeString unescapes entities like \"&lt;\" to become \"<\".\n    It unescapes a larger range of entities than EscapeString escapes.\n    For example, \"&aacute;\" unescapes to \"\u00e1\", as does \"&#225;\" and \"&#xE1;\".\n    UnescapeString(EscapeString(s)) == s always holds, but the converse isn't\n    always true.\n\n"}, {"path": "stdlib/net.md", "category": "stdlib", "name": "stdlib/net", "content": "package net // import \"net\"\n\nPackage net provides a portable interface for network I/O, including TCP/IP,\nUDP, domain name resolution, and Unix domain sockets.\n\nAlthough the package provides access to low-level networking primitives, most\nclients will need only the basic interface provided by the Dial, Listen, and\nAccept functions and the associated Conn and Listener interfaces. The crypto/tls\npackage uses the same interfaces and similar Dial and Listen functions.\n\nThe Dial function connects to a server:\n\n    conn, err := net.Dial(\"tcp\", \"golang.org:80\")\n    if err != nil {\n    \t// handle error\n    }\n    fmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\n    status, err := bufio.NewReader(conn).ReadString('\\n')\n    // ...\n\nThe Listen function creates servers:\n\n    ln, err := net.Listen(\"tcp\", \":8080\")\n    if err != nil {\n    \t// handle error\n    }\n    for {\n    \tconn, err := ln.Accept()\n    \tif err != nil {\n    \t\t// handle error\n    \t}\n    \tgo handleConnection(conn)\n    }\n\n# Name Resolution\n\nThe method for resolving domain names, whether indirectly with functions like\nDial or directly with functions like LookupHost and LookupAddr, varies by\noperating system.\n\nOn Unix systems, the resolver has two options for resolving names. It can use\na pure Go resolver that sends DNS requests directly to the servers listed in\n/etc/resolv.conf, or it can use a cgo-based resolver that calls C library\nroutines such as getaddrinfo and getnameinfo.\n\nOn Unix the pure Go resolver is preferred over the cgo resolver, because a\nblocked DNS request consumes only a goroutine, while a blocked C call consumes\nan operating system thread. When cgo is available, the cgo-based resolver is\nused instead under a variety of conditions: on systems that do not let programs\nmake direct DNS requests (OS X), when the LOCALDOMAIN environment variable\nis present (even if empty), when the RES_OPTIONS or HOSTALIASES environment\nvariable is non-empty, when the ASR_CONFIG environment variable is non-empty\n(OpenBSD only), when /etc/resolv.conf or /etc/nsswitch.conf specify the use of\nfeatures that the Go resolver does not implement.\n\nOn all systems (except Plan 9), when the cgo resolver is being used this package\napplies a concurrent cgo lookup limit to prevent the system from running out of\nsystem threads. Currently, it is limited to 500 concurrent lookups.\n\nThe resolver decision can be overridden by setting the netdns value of the\nGODEBUG environment variable (see package runtime) to go or cgo, as in:\n\n    export GODEBUG=netdns=go    # force pure Go resolver\n    export GODEBUG=netdns=cgo   # force native resolver (cgo, win32)\n\nThe decision can also be forced while building the Go source tree by setting the\nnetgo or netcgo build tag. The netgo build tag disables entirely the use of the\nnative (CGO) resolver, meaning the Go resolver is the only one that can be used.\nWith the netcgo build tag the native and the pure Go resolver are compiled\ninto the binary, but the native (CGO) resolver is preferred over the Go\nresolver. With netcgo, the Go resolver can still be forced at runtime with\nGODEBUG=netdns=go.\n\nA numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver to print\ndebugging information about its decisions. To force a particular resolver while\nalso printing debugging information, join the two settings by a plus sign,\nas in GODEBUG=netdns=go+1.\n\nThe Go resolver will send an EDNS0 additional header with a DNS request,\nto signal a willingness to accept a larger DNS packet size. This can reportedly\ncause sporadic failures with the DNS server run by some modems and routers.\nSetting GODEBUG=netedns0=0 will disable sending the additional header.\n\nOn macOS, if Go code that uses the net package is built with\n-buildmode=c-archive, linking the resulting archive into a C program requires\npassing -lresolv when linking the C code.\n\nOn Plan 9, the resolver always accesses /net/cs and /net/dns.\n\nOn Windows, in Go 1.18.x and earlier, the resolver always used C library\nfunctions, such as GetAddrInfo and DnsQuery.\n\nCONSTANTS\n\nconst (\n\tIPv4len = 4\n\tIPv6len = 16\n)\n    IP address lengths (bytes).\n\n\nVARIABLES\n\nvar (\n\tIPv4bcast     = IPv4(255, 255, 255, 255) // limited broadcast\n\tIPv4allsys    = IPv4(224, 0, 0, 1)       // all systems\n\tIPv4allrouter = IPv4(224, 0, 0, 2)       // all routers\n\tIPv4zero      = IPv4(0, 0, 0, 0)         // all zeros\n)\n    Well-known IPv4 addresses\n\nvar (\n\tIPv6zero                   = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\tIPv6unspecified            = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n\tIPv6loopback               = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}\n\tIPv6interfacelocalallnodes = IP{0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}\n\tIPv6linklocalallnodes      = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}\n\tIPv6linklocalallrouters    = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02}\n)\n    Well-known IPv6 addresses\n\nvar (\n\tErrWriteToConnected = errors.New(\"use of WriteTo with pre-connected connection\")\n)\n    Various errors contained in OpError.\n\nvar DefaultResolver = &Resolver{}\n    DefaultResolver is the resolver used by the package-level Lookup functions\n    and by Dialers without a specified Resolver.\n\nvar ErrClosed error = errClosed\n    ErrClosed is the error returned by an I/O call on a network connection that\n    has already been closed, or that is closed by another goroutine before the\n    I/O is completed. This may be wrapped in another error, and should normally\n    be tested using errors.Is(err, net.ErrClosed).\n\n\nFUNCTIONS\n\nfunc Dial(network, address string) (Conn, error)\n    Dial connects to the address on the named network.\n\n    Known networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only), \"udp\",\n    \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\" (IPv4-only), \"ip6\"\n    (IPv6-only), \"unix\", \"unixgram\" and \"unixpacket\".\n\n    For TCP and UDP networks, the address has the form \"host:port\". The host\n    must be a literal IP address, or a host name that can be resolved to IP\n    addresses. The port must be a literal port number or a service name. If\n    the host is a literal IPv6 address it must be enclosed in square brackets,\n    as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\". The zone specifies the\n    scope of the literal IPv6 address as defined in RFC 4007. The functions\n    JoinHostPort and SplitHostPort manipulate a pair of host and port in this\n    form. When using TCP, and the host resolves to multiple IP addresses,\n    Dial will try each IP address in order until one succeeds.\n\n    Examples:\n\n        Dial(\"tcp\", \"golang.org:http\")\n        Dial(\"tcp\", \"192.0.2.1:http\")\n        Dial(\"tcp\", \"198.51.100.1:80\")\n        Dial(\"udp\", \"[2001:db8::1]:domain\")\n        Dial(\"udp\", \"[fe80::1%lo0]:53\")\n        Dial(\"tcp\", \":80\")\n\n    For IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed by a\n    colon and a literal protocol number or a protocol name, and the address has\n    the form \"host\". The host must be a literal IP address or a literal IPv6\n    address with zone. It depends on each operating system how the operating\n    system behaves with a non-well known protocol number such as \"0\" or \"255\".\n\n    Examples:\n\n        Dial(\"ip4:1\", \"192.0.2.1\")\n        Dial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n        Dial(\"ip6:58\", \"fe80::1%lo0\")\n\n    For TCP, UDP and IP networks, if the host is empty or a literal unspecified\n    IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for TCP and UDP, \"\",\n    \"0.0.0.0\" or \"::\" for IP, the local system is assumed.\n\n    For Unix networks, the address must be a file system path.\n\nfunc DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error)\n    DialIP acts like Dial for IP networks.\n\n    The network must be an IP network name; see func Dial for details.\n\n    If laddr is nil, a local address is automatically chosen. If the IP field of\n    raddr is nil or an unspecified IP address, the local system is assumed.\n\nfunc DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)\n    DialTCP acts like Dial for TCP networks.\n\n    The network must be a TCP network name; see func Dial for details.\n\n    If laddr is nil, a local address is automatically chosen. If the IP field of\n    raddr is nil or an unspecified IP address, the local system is assumed.\n\nfunc DialTimeout(network, address string, timeout time.Duration) (Conn, error)\n    DialTimeout acts like Dial but takes a timeout.\n\n    The timeout includes name resolution, if required. When using TCP,\n    and the host in the address parameter resolves to multiple IP addresses,\n    the timeout is spread over each consecutive dial, such that each is given an\n    appropriate fraction of the time to connect.\n\n    See func Dial for a description of the network and address parameters.\n\nfunc DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error)\n    DialUDP acts like Dial for UDP networks.\n\n    The network must be a UDP network name; see func Dial for details.\n\n    If laddr is nil, a local address is automatically chosen. If the IP field of\n    raddr is nil or an unspecified IP address, the local system is assumed.\n\nfunc DialUnix(network string, laddr, raddr *UnixAddr) (*UnixConn, error)\n    DialUnix acts like Dial for Unix networks.\n\n    The network must be a Unix network name; see func Dial for details.\n\n    If laddr is non-nil, it is used as the local address for the connection.\n\nfunc FileConn(f *os.File) (c Conn, err error)\n    FileConn returns a copy of the network connection corresponding to the\n    open file f. It is the caller's responsibility to close f when finished.\n    Closing c does not affect f, and closing f does not affect c.\n\nfunc FileListener(f *os.File) (ln Listener, err error)\n    FileListener returns a copy of the network listener corresponding to the\n    open file f. It is the caller's responsibility to close ln when finished.\n    Closing ln does not affect f, and closing f does not affect ln.\n\nfunc FilePacketConn(f *os.File) (c PacketConn, err error)\n    FilePacketConn returns a copy of the packet network connection corresponding\n    to the open file f. It is the caller's responsibility to close f when\n    finished. Closing c does not affect f, and closing f does not affect c.\n\nfunc InterfaceAddrs() ([]Addr, error)\n    InterfaceAddrs returns a list of the system's unicast interface addresses.\n\n    The returned list does not identify the associated interface; use Interfaces\n    and Interface.Addrs for more detail.\n\nfunc InterfaceByIndex(index int) (*Interface, error)\n    InterfaceByIndex returns the interface specified by index.\n\n    On Solaris, it returns one of the logical network interfaces sharing the\n    logical data link; for more precision use InterfaceByName.\n\nfunc InterfaceByName(name string) (*Interface, error)\n    InterfaceByName returns the interface specified by name.\n\nfunc Interfaces() ([]Interface, error)\n    Interfaces returns a list of the system's network interfaces.\n\nfunc JoinHostPort(host, port string) string\n    JoinHostPort combines host and port into a network address of the form\n    \"host:port\". If host contains a colon, as found in literal IPv6 addresses,\n    then JoinHostPort returns \"[host]:port\".\n\n    See func Dial for a description of the host and port parameters.\n\nfunc Listen(network, address string) (Listener, error)\n    Listen announces on the local network address.\n\n    The network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\n    For TCP networks, if the host in the address parameter is empty or a literal\n    unspecified IP address, Listen listens on all available unicast and anycast\n    IP addresses of the local system. To only use IPv4, use network \"tcp4\". The\n    address can use a host name, but this is not recommended, because it will\n    create a listener for at most one of the host's IP addresses. If the port\n    in the address parameter is empty or \"0\", as in \"127.0.0.1:\" or \"[::1]:0\",\n    a port number is automatically chosen. The Addr method of Listener can be\n    used to discover the chosen port.\n\n    See func Dial for a description of the network and address parameters.\n\n    Listen uses context.Background internally; to specify the context,\n    use ListenConfig.Listen.\n\nfunc ListenIP(network string, laddr *IPAddr) (*IPConn, error)\n    ListenIP acts like ListenPacket for IP networks.\n\n    The network must be an IP network name; see func Dial for details.\n\n    If the IP field of laddr is nil or an unspecified IP address, ListenIP\n    listens on all available IP addresses of the local system except multicast\n    IP addresses.\n\nfunc ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)\n    ListenMulticastUDP acts like ListenPacket for UDP networks but takes a group\n    address on a specific network interface.\n\n    The network must be a UDP network name; see func Dial for details.\n\n    ListenMulticastUDP listens on all available IP addresses of the local system\n    including the group, multicast IP address. If ifi is nil, ListenMulticastUDP\n    uses the system-assigned multicast interface, although this is not\n    recommended because the assignment depends on platforms and sometimes it\n    might require routing configuration. If the Port field of gaddr is 0,\n    a port number is automatically chosen.\n\n    ListenMulticastUDP is just for convenience of simple, small applications.\n    There are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for\n    general purpose uses.\n\n    Note that ListenMulticastUDP will set the IP_MULTICAST_LOOP socket option to\n    0 under IPPROTO_IP, to disable loopback of multicast packets.\n\nfunc ListenPacket(network, address string) (PacketConn, error)\n    ListenPacket announces on the local network address.\n\n    The network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP transport.\n    The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by a colon and a\n    literal protocol number or a protocol name, as in \"ip:1\" or \"ip:icmp\".\n\n    For UDP and IP networks, if the host in the address parameter is empty or\n    a literal unspecified IP address, ListenPacket listens on all available IP\n    addresses of the local system except multicast IP addresses. To only use\n    IPv4, use network \"udp4\" or \"ip4:proto\". The address can use a host name,\n    but this is not recommended, because it will create a listener for at\n    most one of the host's IP addresses. If the port in the address parameter\n    is empty or \"0\", as in \"127.0.0.1:\" or \"[::1]:0\", a port number is\n    automatically chosen. The LocalAddr method of PacketConn can be used to\n    discover the chosen port.\n\n    See func Dial for a description of the network and address parameters.\n\n    ListenPacket uses context.Background internally; to specify the context,\n    use ListenConfig.ListenPacket.\n\nfunc ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)\n    ListenTCP acts like Listen for TCP networks.\n\n    The network must be a TCP network name; see func Dial for details.\n\n    If the IP field of laddr is nil or an unspecified IP address, ListenTCP\n    listens on all available unicast and anycast IP addresses of the local\n    system. If the Port field of laddr is 0, a port number is automatically\n    chosen.\n\nfunc ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)\n    ListenUDP acts like ListenPacket for UDP networks.\n\n    The network must be a UDP network name; see func Dial for details.\n\n    If the IP field of laddr is nil or an unspecified IP address,\n    ListenUDP listens on all available IP addresses of the local system except\n    multicast IP addresses. If the Port field of laddr is 0, a port number is\n    automatically chosen.\n\nfunc ListenUnix(network string, laddr *UnixAddr) (*UnixListener, error)\n    ListenUnix acts like Listen for Unix networks.\n\n    The network must be \"unix\" or \"unixpacket\".\n\nfunc ListenUnixgram(network string, laddr *UnixAddr) (*UnixConn, error)\n    ListenUnixgram acts like ListenPacket for Unix networks.\n\n    The network must be \"unixgram\".\n\nfunc LookupAddr(addr string) (names []string, err error)\n    LookupAddr performs a reverse lookup for the given address, returning a list\n    of names mapping to that address.\n\n    The returned names are validated to be properly formatted\n    presentation-format domain names. If the response contains invalid names,\n    those records are filtered out and an error will be returned alongside the\n    remaining results, if any.\n\n    When using the host C library resolver, at most one result will be returned.\n    To bypass the host resolver, use a custom Resolver.\n\n    LookupAddr uses context.Background internally; to specify the context,\n    use Resolver.LookupAddr.\n\nfunc LookupCNAME(host string) (cname string, err error)\n    LookupCNAME returns the canonical name for the given host. Callers that do\n    not care about the canonical name can call LookupHost or LookupIP directly;\n    both take care of resolving the canonical name as part of the lookup.\n\n    A canonical name is the final name after following zero or more CNAME\n    records. LookupCNAME does not return an error if host does not contain DNS\n    \"CNAME\" records, as long as host resolves to address records.\n\n    The returned canonical name is validated to be a properly formatted\n    presentation-format domain name.\n\n    LookupCNAME uses context.Background internally; to specify the context,\n    use Resolver.LookupCNAME.\n\nfunc LookupHost(host string) (addrs []string, err error)\n    LookupHost looks up the given host using the local resolver. It returns a\n    slice of that host's addresses.\n\n    LookupHost uses context.Background internally; to specify the context,\n    use Resolver.LookupHost.\n\nfunc LookupIP(host string) ([]IP, error)\n    LookupIP looks up host using the local resolver. It returns a slice of that\n    host's IPv4 and IPv6 addresses.\n\nfunc LookupMX(name string) ([]*MX, error)\n    LookupMX returns the DNS MX records for the given domain name sorted by\n    preference.\n\n    The returned mail server names are validated to be properly formatted\n    presentation-format domain names, or numeric IP addresses. If the response\n    contains invalid names, those records are filtered out and an error will be\n    returned alongside the remaining results, if any.\n\n    LookupMX uses context.Background internally; to specify the context,\n    use Resolver.LookupMX.\n\nfunc LookupNS(name string) ([]*NS, error)\n    LookupNS returns the DNS NS records for the given domain name.\n\n    The returned name server names are validated to be properly formatted\n    presentation-format domain names. If the response contains invalid names,\n    those records are filtered out and an error will be returned alongside the\n    remaining results, if any.\n\n    LookupNS uses context.Background internally; to specify the context,\n    use Resolver.LookupNS.\n\nfunc LookupPort(network, service string) (port int, err error)\n    LookupPort looks up the port for the given network and service.\n\n    LookupPort uses context.Background internally; to specify the context,\n    use Resolver.LookupPort.\n\nfunc LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)\n    LookupSRV tries to resolve an SRV query of the given service, protocol,\n    and domain name. The proto is \"tcp\" or \"udp\". The returned records are\n    sorted by priority and randomized by weight within a priority.\n\n    LookupSRV constructs the DNS name to look up following RFC 2782. That is,\n    it looks up _service._proto.name. To accommodate services publishing SRV\n    records under non-standard names, if both service and proto are empty\n    strings, LookupSRV looks up name directly.\n\n    The returned service names are validated to be properly formatted\n    presentation-format domain names. If the response contains invalid names,\n    those records are filtered out and an error will be returned alongside the\n    remaining results, if any.\n\nfunc LookupTXT(name string) ([]string, error)\n    LookupTXT returns the DNS TXT records for the given domain name.\n\n    If a DNS TXT record holds multiple strings, they are concatenated as a\n    single string.\n\n    LookupTXT uses context.Background internally; to specify the context,\n    use Resolver.LookupTXT.\n\nfunc ParseCIDR(s string) (IP, *IPNet, error)\n    ParseCIDR parses s as a CIDR notation IP address and prefix length, like\n    \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in RFC 4632 and RFC 4291.\n\n    It returns the IP address and the network implied by the IP and prefix\n    length. For example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n    192.0.2.1 and the network 192.0.2.0/24.\n\nfunc ParseMAC(s string) (hw HardwareAddr, err error)\n    ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP\n    over InfiniBand link-layer address using one of the following formats:\n\n        00:00:5e:00:53:01\n        02:00:5e:10:00:00:00:01\n        00:00:00:00:fe:80:00:00:00:00:00:00:02:00:5e:10:00:00:00:01\n        00-00-5e-00-53-01\n        02-00-5e-10-00-00-00-01\n        00-00-00-00-fe-80-00-00-00-00-00-00-02-00-5e-10-00-00-00-01\n        0000.5e00.5301\n        0200.5e10.0000.0001\n        0000.0000.fe80.0000.0000.0000.0200.5e10.0000.0001\n\nfunc Pipe() (Conn, Conn)\n    Pipe creates a synchronous, in-memory, full duplex network connection;\n    both ends implement the Conn interface. Reads on one end are matched with\n    writes on the other, copying data directly between the two; there is no\n    internal buffering.\n\nfunc ResolveIPAddr(network, address string) (*IPAddr, error)\n    ResolveIPAddr returns an address of IP end point.\n\n    The network must be an IP network name.\n\n    If the host in the address parameter is not a literal IP address,\n    ResolveIPAddr resolves the address to an address of IP end point. Otherwise,\n    it parses the address as a literal IP address. The address parameter can use\n    a host name, but this is not recommended, because it will return at most one\n    of the host name's IP addresses.\n\n    See func Dial for a description of the network and address parameters.\n\nfunc ResolveTCPAddr(network, address string) (*TCPAddr, error)\n    ResolveTCPAddr returns an address of TCP end point.\n\n    The network must be a TCP network name.\n\n    If the host in the address parameter is not a literal IP address or the\n    port is not a literal port number, ResolveTCPAddr resolves the address to\n    an address of TCP end point. Otherwise, it parses the address as a pair of\n    literal IP address and port number. The address parameter can use a host\n    name, but this is not recommended, because it will return at most one of the\n    host name's IP addresses.\n\n    See func Dial for a description of the network and address parameters.\n\nfunc ResolveUDPAddr(network, address string) (*UDPAddr, error)\n    ResolveUDPAddr returns an address of UDP end point.\n\n    The network must be a UDP network name.\n\n    If the host in the address parameter is not a literal IP address or the\n    port is not a literal port number, ResolveUDPAddr resolves the address to\n    an address of UDP end point. Otherwise, it parses the address as a pair of\n    literal IP address and port number. The address parameter can use a host\n    name, but this is not recommended, because it will return at most one of the\n    host name's IP addresses.\n\n    See func Dial for a description of the network and address parameters.\n\nfunc ResolveUnixAddr(network, address string) (*UnixAddr, error)\n    ResolveUnixAddr returns an address of Unix domain socket end point.\n\n    The network must be a Unix network name.\n\n    See func Dial for a description of the network and address parameters.\n\nfunc SplitHostPort(hostport string) (host, port string, err error)\n    SplitHostPort splits a network address of the form \"host:port\",\n    \"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or host%zone\n    and port.\n\n    A literal IPv6 address in hostport must be enclosed in square brackets,\n    as in \"[::1]:80\", \"[::1%lo0]:80\".\n\n    See func Dial for a description of the hostport parameter, and host and port\n    results.\n\n\nTYPES\n\ntype Addr interface {\n\tNetwork() string // name of the network (for example, \"tcp\", \"udp\")\n\tString() string  // string form of address (for example, \"192.0.2.1:25\", \"[2001:db8::1]:80\")\n}\n    Addr represents a network end point address.\n\n    The two methods [Addr.Network] and [Addr.String] conventionally return\n    strings that can be passed as the arguments to Dial, but the exact form and\n    meaning of the strings is up to the implementation.\n\ntype AddrError struct {\n\tErr  string\n\tAddr string\n}\n\nfunc (e *AddrError) Error() string\n\nfunc (e *AddrError) Temporary() bool\n\nfunc (e *AddrError) Timeout() bool\n\ntype Buffers [][]byte\n    Buffers contains zero or more runs of bytes to write.\n\n    On certain machines, for certain types of connections, this is optimized\n    into an OS-specific batch write operation (such as \"writev\").\n\nfunc (v *Buffers) Read(p []byte) (n int, err error)\n    Read from the buffers.\n\n    Read implements io.Reader for Buffers.\n\n    Read modifies the slice v as well as v[i] for 0 <= i < len(v), but does not\n    modify v[i][j] for any i, j.\n\nfunc (v *Buffers) WriteTo(w io.Writer) (n int64, err error)\n    WriteTo writes contents of the buffers to w.\n\n    WriteTo implements io.WriterTo for Buffers.\n\n    WriteTo modifies the slice v as well as v[i] for 0 <= i < len(v), but does\n    not modify v[i][j] for any i, j.\n\ntype Conn interface {\n\t// Read reads data from the connection.\n\t// Read can be made to time out and return an error after a fixed\n\t// time limit; see SetDeadline and SetReadDeadline.\n\tRead(b []byte) (n int, err error)\n\n\t// Write writes data to the connection.\n\t// Write can be made to time out and return an error after a fixed\n\t// time limit; see SetDeadline and SetWriteDeadline.\n\tWrite(b []byte) (n int, err error)\n\n\t// Close closes the connection.\n\t// Any blocked Read or Write operations will be unblocked and return errors.\n\t// Close may or may not block until any buffered data is sent;\n\t// for TCP connections see [*TCPConn.SetLinger].\n\tClose() error\n\n\t// LocalAddr returns the local network address, if known.\n\tLocalAddr() Addr\n\n\t// RemoteAddr returns the remote network address, if known.\n\tRemoteAddr() Addr\n\n\t// SetDeadline sets the read and write deadlines associated\n\t// with the connection. It is equivalent to calling both\n\t// SetReadDeadline and SetWriteDeadline.\n\t//\n\t// A deadline is an absolute time after which I/O operations\n\t// fail instead of blocking. The deadline applies to all future\n\t// and pending I/O, not just the immediately following call to\n\t// Read or Write. After a deadline has been exceeded, the\n\t// connection can be refreshed by setting a deadline in the future.\n\t//\n\t// If the deadline is exceeded a call to Read or Write or to other\n\t// I/O methods will return an error that wraps os.ErrDeadlineExceeded.\n\t// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).\n\t// The error's Timeout method will return true, but note that there\n\t// are other possible errors for which the Timeout method will\n\t// return true even if the deadline has not been exceeded.\n\t//\n\t// An idle timeout can be implemented by repeatedly extending\n\t// the deadline after successful Read or Write calls.\n\t//\n\t// A zero value for t means I/O operations will not time out.\n\tSetDeadline(t time.Time) error\n\n\t// SetReadDeadline sets the deadline for future Read calls\n\t// and any currently-blocked Read call.\n\t// A zero value for t means Read will not time out.\n\tSetReadDeadline(t time.Time) error\n\n\t// SetWriteDeadline sets the deadline for future Write calls\n\t// and any currently-blocked Write call.\n\t// Even if write times out, it may return n > 0, indicating that\n\t// some of the data was successfully written.\n\t// A zero value for t means Write will not time out.\n\tSetWriteDeadline(t time.Time) error\n}\n    Conn is a generic stream-oriented network connection.\n\n    Multiple goroutines may invoke methods on a Conn simultaneously.\n\ntype DNSConfigError struct {\n\tErr error\n}\n    DNSConfigError represents an error reading the machine's DNS configuration.\n    (No longer used; kept for compatibility.)\n\nfunc (e *DNSConfigError) Error() string\n\nfunc (e *DNSConfigError) Temporary() bool\n\nfunc (e *DNSConfigError) Timeout() bool\n\nfunc (e *DNSConfigError) Unwrap() error\n\ntype DNSError struct {\n\tUnwrapErr   error  // error returned by the [DNSError.Unwrap] method, might be nil\n\tErr         string // description of the error\n\tName        string // name looked for\n\tServer      string // server used\n\tIsTimeout   bool   // if true, timed out; not all timeouts set this\n\tIsTemporary bool   // if true, error is temporary; not all errors set this\n\n\t// IsNotFound is set to true when the requested name does not\n\t// contain any records of the requested type (data not found),\n\t// or the name itself was not found (NXDOMAIN).\n\tIsNotFound bool\n}\n    DNSError represents a DNS lookup error.\n\nfunc (e *DNSError) Error() string\n\nfunc (e *DNSError) Temporary() bool\n    Temporary reports whether the DNS error is known to be temporary. This is\n    not always known; a DNS lookup may fail due to a temporary error and return\n    a DNSError for which Temporary returns false.\n\nfunc (e *DNSError) Timeout() bool\n    Timeout reports whether the DNS lookup is known to have timed out.\n    This is not always known; a DNS lookup may fail due to a timeout and return\n    a DNSError for which Timeout returns false.\n\nfunc (e *DNSError) Unwrap() error\n    Unwrap returns e.UnwrapErr.\n\ntype Dialer struct {\n\t// Timeout is the maximum amount of time a dial will wait for\n\t// a connect to complete. If Deadline is also set, it may fail\n\t// earlier.\n\t//\n\t// The default is no timeout.\n\t//\n\t// When using TCP and dialing a host name with multiple IP\n\t// addresses, the timeout may be divided between them.\n\t//\n\t// With or without a timeout, the operating system may impose\n\t// its own earlier timeout. For instance, TCP timeouts are\n\t// often around 3 minutes.\n\tTimeout time.Duration\n\n\t// Deadline is the absolute point in time after which dials\n\t// will fail. If Timeout is set, it may fail earlier.\n\t// Zero means no deadline, or dependent on the operating system\n\t// as with the Timeout option.\n\tDeadline time.Time\n\n\t// LocalAddr is the local address to use when dialing an\n\t// address. The address must be of a compatible type for the\n\t// network being dialed.\n\t// If nil, a local address is automatically chosen.\n\tLocalAddr Addr\n\n\t// DualStack previously enabled RFC 6555 Fast Fallback\n\t// support, also known as \"Happy Eyeballs\", in which IPv4 is\n\t// tried soon if IPv6 appears to be misconfigured and\n\t// hanging.\n\t//\n\t// Deprecated: Fast Fallback is enabled by default. To\n\t// disable, set FallbackDelay to a negative value.\n\tDualStack bool\n\n\t// FallbackDelay specifies the length of time to wait before\n\t// spawning a RFC 6555 Fast Fallback connection. That is, this\n\t// is the amount of time to wait for IPv6 to succeed before\n\t// assuming that IPv6 is misconfigured and falling back to\n\t// IPv4.\n\t//\n\t// If zero, a default delay of 300ms is used.\n\t// A negative value disables Fast Fallback support.\n\tFallbackDelay time.Duration\n\n\t// KeepAlive specifies the interval between keep-alive\n\t// probes for an active network connection.\n\t//\n\t// KeepAlive is ignored if KeepAliveConfig.Enable is true.\n\t//\n\t// If zero, keep-alive probes are sent with a default value\n\t// (currently 15 seconds), if supported by the protocol and operating\n\t// system. Network protocols or operating systems that do\n\t// not support keep-alive ignore this field.\n\t// If negative, keep-alive probes are disabled.\n\tKeepAlive time.Duration\n\n\t// KeepAliveConfig specifies the keep-alive probe configuration\n\t// for an active network connection, when supported by the\n\t// protocol and operating system.\n\t//\n\t// If KeepAliveConfig.Enable is true, keep-alive probes are enabled.\n\t// If KeepAliveConfig.Enable is false and KeepAlive is negative,\n\t// keep-alive probes are disabled.\n\tKeepAliveConfig KeepAliveConfig\n\n\t// Resolver optionally specifies an alternate resolver to use.\n\tResolver *Resolver\n\n\t// Cancel is an optional channel whose closure indicates that\n\t// the dial should be canceled. Not all types of dials support\n\t// cancellation.\n\t//\n\t// Deprecated: Use DialContext instead.\n\tCancel <-chan struct{}\n\n\t// If Control is not nil, it is called after creating the network\n\t// connection but before actually dialing.\n\t//\n\t// Network and address parameters passed to Control function are not\n\t// necessarily the ones passed to Dial. Calling Dial with TCP networks\n\t// will cause the Control function to be called with \"tcp4\" or \"tcp6\",\n\t// UDP networks become \"udp4\" or \"udp6\", IP networks become \"ip4\" or \"ip6\",\n\t// and other known networks are passed as-is.\n\t//\n\t// Control is ignored if ControlContext is not nil.\n\tControl func(network, address string, c syscall.RawConn) error\n\n\t// If ControlContext is not nil, it is called after creating the network\n\t// connection but before actually dialing.\n\t//\n\t// Network and address parameters passed to ControlContext function are not\n\t// necessarily the ones passed to Dial. Calling Dial with TCP networks\n\t// will cause the ControlContext function to be called with \"tcp4\" or \"tcp6\",\n\t// UDP networks become \"udp4\" or \"udp6\", IP networks become \"ip4\" or \"ip6\",\n\t// and other known networks are passed as-is.\n\t//\n\t// If ControlContext is not nil, Control is ignored.\n\tControlContext func(ctx context.Context, network, address string, c syscall.RawConn) error\n\n\t// Has unexported fields.\n}\n    A Dialer contains options for connecting to an address.\n\n    The zero value for each field is equivalent to dialing without that option.\n    Dialing with the zero value of Dialer is therefore equivalent to just\n    calling the Dial function.\n\n    It is safe to call Dialer's methods concurrently.\n\nfunc (d *Dialer) Dial(network, address string) (Conn, error)\n    Dial connects to the address on the named network.\n\n    See func Dial for a description of the network and address parameters.\n\n    Dial uses context.Background internally; to specify the context, use\n    Dialer.DialContext.\n\nfunc (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)\n    DialContext connects to the address on the named network using the provided\n    context.\n\n    The provided Context must be non-nil. If the context expires before the\n    connection is complete, an error is returned. Once successfully connected,\n    any expiration of the context will not affect the connection.\n\n    When using TCP, and the host in the address parameter resolves to multiple\n    network addresses, any dial timeout (from d.Timeout or ctx) is spread over\n    each consecutive dial, such that each is given an appropriate fraction\n    of the time to connect. For example, if a host has 4 IP addresses and the\n    timeout is 1 minute, the connect to each single address will be given 15\n    seconds to complete before trying the next one.\n\n    See func Dial for a description of the network and address parameters.\n\nfunc (d *Dialer) MultipathTCP() bool\n    MultipathTCP reports whether MPTCP will be used.\n\n    This method doesn't check if MPTCP is supported by the operating system or\n    not.\n\nfunc (d *Dialer) SetMultipathTCP(use bool)\n    SetMultipathTCP directs the Dial methods to use, or not use, MPTCP, if\n    supported by the operating system. This method overrides the system default\n    and the GODEBUG=multipathtcp=... setting if any.\n\n    If MPTCP is not available on the host or not supported by the server,\n    the Dial methods will fall back to TCP.\n\ntype Error interface {\n\terror\n\tTimeout() bool // Is the error a timeout?\n\n\t// Deprecated: Temporary errors are not well-defined.\n\t// Most \"temporary\" errors are timeouts, and the few exceptions are surprising.\n\t// Do not use this method.\n\tTemporary() bool\n}\n    An Error represents a network error.\n\ntype Flags uint\n\nconst (\n\tFlagUp           Flags = 1 << iota // interface is administratively up\n\tFlagBroadcast                      // interface supports broadcast access capability\n\tFlagLoopback                       // interface is a loopback interface\n\tFlagPointToPoint                   // interface belongs to a point-to-point link\n\tFlagMulticast                      // interface supports multicast access capability\n\tFlagRunning                        // interface is in running state\n)\nfunc (f Flags) String() string\n\ntype HardwareAddr []byte\n    A HardwareAddr represents a physical hardware address.\n\nfunc (a HardwareAddr) String() string\n\ntype IP []byte\n    An IP is a single IP address, a slice of bytes. Functions in this package\n    accept either 4-byte (IPv4) or 16-byte (IPv6) slices as input.\n\n    Note that in this documentation, referring to an IP address as an IPv4\n    address or an IPv6 address is a semantic property of the address, not just\n    the length of the byte slice: a 16-byte slice can still be an IPv4 address.\n\nfunc IPv4(a, b, c, d byte) IP\n    IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d.\n\nfunc ParseIP(s string) IP\n    ParseIP parses s as an IP address, returning the result. The string s can be\n    in IPv4 dotted decimal (\"192.0.2.1\"), IPv6 (\"2001:db8::68\"), or IPv4-mapped\n    IPv6 (\"::ffff:192.0.2.1\") form. If s is not a valid textual representation\n    of an IP address, ParseIP returns nil. The returned address is always 16\n    bytes, IPv4 addresses are returned in IPv4-mapped IPv6 form.\n\nfunc (ip IP) AppendText(b []byte) ([]byte, error)\n    AppendText implements the encoding.TextAppender interface. The encoding is\n    the same as returned by IP.String, with one exception: When len(ip) is zero,\n    it appends nothing.\n\nfunc (ip IP) DefaultMask() IPMask\n    DefaultMask returns the default IP mask for the IP address ip. Only IPv4\n    addresses have default masks; DefaultMask returns nil if ip is not a valid\n    IPv4 address.\n\nfunc (ip IP) Equal(x IP) bool\n    Equal reports whether ip and x are the same IP address. An IPv4 address and\n    that same address in IPv6 form are considered to be equal.\n\nfunc (ip IP) IsGlobalUnicast() bool\n    IsGlobalUnicast reports whether ip is a global unicast address.\n\n    The identification of global unicast addresses uses address type\n    identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the\n    exception of IPv4 directed broadcast addresses. It returns true even if ip\n    is in IPv4 private address space or local IPv6 unicast address space.\n\nfunc (ip IP) IsInterfaceLocalMulticast() bool\n    IsInterfaceLocalMulticast reports whether ip is an interface-local multicast\n    address.\n\nfunc (ip IP) IsLinkLocalMulticast() bool\n    IsLinkLocalMulticast reports whether ip is a link-local multicast address.\n\nfunc (ip IP) IsLinkLocalUnicast() bool\n    IsLinkLocalUnicast reports whether ip is a link-local unicast address.\n\nfunc (ip IP) IsLoopback() bool\n    IsLoopback reports whether ip is a loopback address.\n\nfunc (ip IP) IsMulticast() bool\n    IsMulticast reports whether ip is a multicast address.\n\nfunc (ip IP) IsPrivate() bool\n    IsPrivate reports whether ip is a private address, according to RFC 1918\n    (IPv4 addresses) and RFC 4193 (IPv6 addresses).\n\nfunc (ip IP) IsUnspecified() bool\n    IsUnspecified reports whether ip is an unspecified address, either the IPv4\n    address \"0.0.0.0\" or the IPv6 address \"::\".\n\nfunc (ip IP) MarshalText() ([]byte, error)\n    MarshalText implements the encoding.TextMarshaler interface. The encoding is\n    the same as returned by IP.String, with one exception: When len(ip) is zero,\n    it returns an empty slice.\n\nfunc (ip IP) Mask(mask IPMask) IP\n    Mask returns the result of masking the IP address ip with mask.\n\nfunc (ip IP) String() string\n    String returns the string form of the IP address ip. It returns one of 4\n    forms:\n      - \"<nil>\", if ip has length 0\n      - dotted decimal (\"192.0.2.1\"), if ip is an IPv4 or IP4-mapped IPv6\n        address\n      - IPv6 conforming to RFC 5952 (\"2001:db8::1\"), if ip is a valid IPv6\n        address\n      - the hexadecimal form of ip, without punctuation, if no other cases apply\n\nfunc (ip IP) To16() IP\n    To16 converts the IP address ip to a 16-byte representation. If ip is not an\n    IP address (it is the wrong length), To16 returns nil.\n\nfunc (ip IP) To4() IP\n    To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an\n    IPv4 address, To4 returns nil.\n\nfunc (ip *IP) UnmarshalText(text []byte) error\n    UnmarshalText implements the encoding.TextUnmarshaler interface. The IP\n    address is expected in a form accepted by ParseIP.\n\ntype IPAddr struct {\n\tIP   IP\n\tZone string // IPv6 scoped addressing zone\n}\n    IPAddr represents the address of an IP end point.\n\nfunc (a *IPAddr) Network() string\n    Network returns the address's network name, \"ip\".\n\nfunc (a *IPAddr) String() string\n\ntype IPConn struct {\n\t// Has unexported fields.\n}\n    IPConn is the implementation of the Conn and PacketConn interfaces for IP\n    network connections.\n\nfunc (c *IPConn) Close() error\n    Close closes the connection.\n\nfunc (c *IPConn) File() (f *os.File, err error)\n    File returns a copy of the underlying os.File. It is the caller's\n    responsibility to close f when finished. Closing c does not affect f,\n    and closing f does not affect c.\n\n    The returned os.File's file descriptor is different from the connection's.\n    Attempting to change properties of the original using this duplicate may or\n    may not have the desired effect.\n\n    On Windows, the returned os.File's file descriptor is not usable on other\n    processes.\n\nfunc (c *IPConn) LocalAddr() Addr\n    LocalAddr returns the local network address. The Addr returned is shared by\n    all invocations of LocalAddr, so do not modify it.\n\nfunc (c *IPConn) Read(b []byte) (int, error)\n    Read implements the Conn Read method.\n\nfunc (c *IPConn) ReadFrom(b []byte) (int, Addr, error)\n    ReadFrom implements the PacketConn ReadFrom method.\n\nfunc (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)\n    ReadFromIP acts like ReadFrom but returns an IPAddr.\n\nfunc (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)\n    ReadMsgIP reads a message from c, copying the payload into b and the\n    associated out-of-band data into oob. It returns the number of bytes copied\n    into b, the number of bytes copied into oob, the flags that were set on the\n    message and the source address of the message.\n\n    The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to\n    manipulate IP-level socket options in oob.\n\nfunc (c *IPConn) RemoteAddr() Addr\n    RemoteAddr returns the remote network address. The Addr returned is shared\n    by all invocations of RemoteAddr, so do not modify it.\n\nfunc (c *IPConn) SetDeadline(t time.Time) error\n    SetDeadline implements the Conn SetDeadline method.\n\nfunc (c *IPConn) SetReadBuffer(bytes int) error\n    SetReadBuffer sets the size of the operating system's receive buffer\n    associated with the connection.\n\nfunc (c *IPConn) SetReadDeadline(t time.Time) error\n    SetReadDeadline implements the Conn SetReadDeadline method.\n\nfunc (c *IPConn) SetWriteBuffer(bytes int) error\n    SetWriteBuffer sets the size of the operating system's transmit buffer\n    associated with the connection.\n\nfunc (c *IPConn) SetWriteDeadline(t time.Time) error\n    SetWriteDeadline implements the Conn SetWriteDeadline method.\n\nfunc (c *IPConn) SyscallConn() (syscall.RawConn, error)\n    SyscallConn returns a raw network connection. This implements the\n    syscall.Conn interface.\n\nfunc (c *IPConn) Write(b []byte) (int, error)\n    Write implements the Conn Write method.\n\nfunc (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)\n    WriteMsgIP writes a message to addr via c, copying the payload from b and\n    the associated out-of-band data from oob. It returns the number of payload\n    and out-of-band bytes written.\n\n    The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to\n    manipulate IP-level socket options in oob.\n\nfunc (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)\n    WriteTo implements the PacketConn WriteTo method.\n\nfunc (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)\n    WriteToIP acts like IPConn.WriteTo but takes an IPAddr.\n\ntype IPMask []byte\n    An IPMask is a bitmask that can be used to manipulate IP addresses for IP\n    addressing and routing.\n\n    See type IPNet and func ParseCIDR for details.\n\nfunc CIDRMask(ones, bits int) IPMask\n    CIDRMask returns an IPMask consisting of 'ones' 1 bits followed by 0s up\n    to a total length of 'bits' bits. For a mask of this form, CIDRMask is the\n    inverse of IPMask.Size.\n\nfunc IPv4Mask(a, b, c, d byte) IPMask\n    IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d.\n\nfunc (m IPMask) Size() (ones, bits int)\n    Size returns the number of leading ones and total bits in the mask. If the\n    mask is not in the canonical form--ones followed by zeros--then Size returns\n    0, 0.\n\nfunc (m IPMask) String() string\n    String returns the hexadecimal form of m, with no punctuation.\n\ntype IPNet struct {\n\tIP   IP     // network number\n\tMask IPMask // network mask\n}\n    An IPNet represents an IP network.\n\nfunc (n *IPNet) Contains(ip IP) bool\n    Contains reports whether the network includes ip.\n\nfunc (n *IPNet) Network() string\n    Network returns the address's network name, \"ip+net\".\n\nfunc (n *IPNet) String() string\n    String returns the CIDR notation of n like \"192.0.2.0/24\" or \"2001:db8::/48\"\n    as defined in RFC 4632 and RFC 4291. If the mask is not in the canonical\n    form, it returns the string which consists of an IP address, followed by a\n    slash character and a mask expressed as hexadecimal form with no punctuation\n    like \"198.51.100.0/c000ff00\".\n\ntype Interface struct {\n\tIndex        int          // positive integer that starts at one, zero is never used\n\tMTU          int          // maximum transmission unit\n\tName         string       // e.g., \"en0\", \"lo0\", \"eth0.100\"; may be the empty string\n\tHardwareAddr HardwareAddr // IEEE MAC-48, EUI-48 and EUI-64 form\n\tFlags        Flags        // e.g., FlagUp, FlagLoopback, FlagMulticast\n}\n    Interface represents a mapping between network interface name and index.\n    It also represents network interface facility information.\n\nfunc (ifi *Interface) Addrs() ([]Addr, error)\n    Addrs returns a list of unicast interface addresses for a specific\n    interface.\n\nfunc (ifi *Interface) MulticastAddrs() ([]Addr, error)\n    MulticastAddrs returns a list of multicast, joined group addresses for a\n    specific interface.\n\ntype InvalidAddrError string\n\nfunc (e InvalidAddrError) Error() string\n\nfunc (e InvalidAddrError) Temporary() bool\n\nfunc (e InvalidAddrError) Timeout() bool\n\ntype KeepAliveConfig struct {\n\t// If Enable is true, keep-alive probes are enabled.\n\tEnable bool\n\n\t// Idle is the time that the connection must be idle before\n\t// the first keep-alive probe is sent.\n\t// If zero, a default value of 15 seconds is used.\n\tIdle time.Duration\n\n\t// Interval is the time between keep-alive probes.\n\t// If zero, a default value of 15 seconds is used.\n\tInterval time.Duration\n\n\t// Count is the maximum number of keep-alive probes that\n\t// can go unanswered before dropping a connection.\n\t// If zero, a default value of 9 is used.\n\tCount int\n}\n    KeepAliveConfig contains TCP keep-alive options.\n\n    If the Idle, Interval, or Count fields are zero, a default value is chosen.\n    If a field is negative, the corresponding socket-level option will be left\n    unchanged.\n\n    Note that prior to Windows 10 version 1709, neither setting Idle and\n    Interval separately nor changing Count (which is usually 10) is supported.\n    Therefore, it's recommended to set both Idle and Interval to non-negative\n    values in conjunction with a -1 for Count on those old Windows if you intend\n    to customize the TCP keep-alive settings. By contrast, if only one of Idle\n    and Interval is set to a non-negative value, the other will be set to the\n    system default value, and ultimately, set both Idle and Interval to negative\n    values if you want to leave them unchanged.\n\n    Note that Solaris and its derivatives do not support setting Interval to a\n    non-negative value and Count to a negative value, or vice-versa.\n\ntype ListenConfig struct {\n\t// If Control is not nil, it is called after creating the network\n\t// connection but before binding it to the operating system.\n\t//\n\t// Network and address parameters passed to Control function are not\n\t// necessarily the ones passed to Listen. Calling Listen with TCP networks\n\t// will cause the Control function to be called with \"tcp4\" or \"tcp6\",\n\t// UDP networks become \"udp4\" or \"udp6\", IP networks become \"ip4\" or \"ip6\",\n\t// and other known networks are passed as-is.\n\tControl func(network, address string, c syscall.RawConn) error\n\n\t// KeepAlive specifies the keep-alive period for network\n\t// connections accepted by this listener.\n\t//\n\t// KeepAlive is ignored if KeepAliveConfig.Enable is true.\n\t//\n\t// If zero, keep-alive are enabled if supported by the protocol\n\t// and operating system. Network protocols or operating systems\n\t// that do not support keep-alive ignore this field.\n\t// If negative, keep-alive are disabled.\n\tKeepAlive time.Duration\n\n\t// KeepAliveConfig specifies the keep-alive probe configuration\n\t// for an active network connection, when supported by the\n\t// protocol and operating system.\n\t//\n\t// If KeepAliveConfig.Enable is true, keep-alive probes are enabled.\n\t// If KeepAliveConfig.Enable is false and KeepAlive is negative,\n\t// keep-alive probes are disabled.\n\tKeepAliveConfig KeepAliveConfig\n\n\t// Has unexported fields.\n}\n    ListenConfig contains options for listening to an address.\n\nfunc (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error)\n    Listen announces on the local network address.\n\n    See func Listen for a description of the network and address parameters.\n\n    The ctx argument is used while resolving the address on which to listen;\n    it does not affect the returned Listener.\n\nfunc (lc *ListenConfig) ListenPacket(ctx context.Context, network, address string) (PacketConn, error)\n    ListenPacket announces on the local network address.\n\n    See func ListenPacket for a description of the network and address\n    parameters.\n\n    The ctx argument is used while resolving the address on which to listen;\n    it does not affect the returned PacketConn.\n\nfunc (lc *ListenConfig) MultipathTCP() bool\n    MultipathTCP reports whether MPTCP will be used.\n\n    This method doesn't check if MPTCP is supported by the operating system or\n    not.\n\nfunc (lc *ListenConfig) SetMultipathTCP(use bool)\n    SetMultipathTCP directs the Listen method to use, or not use, MPTCP, if\n    supported by the operating system. This method overrides the system default\n    and the GODEBUG=multipathtcp=... setting if any.\n\n    If MPTCP is not available on the host or not supported by the client,\n    the Listen method will fall back to TCP.\n\ntype Listener interface {\n\t// Accept waits for and returns the next connection to the listener.\n\tAccept() (Conn, error)\n\n\t// Close closes the listener.\n\t// Any blocked Accept operations will be unblocked and return errors.\n\tClose() error\n\n\t// Addr returns the listener's network address.\n\tAddr() Addr\n}\n    A Listener is a generic network listener for stream-oriented protocols.\n\n    Multiple goroutines may invoke methods on a Listener simultaneously.\n\ntype MX struct {\n\tHost string\n\tPref uint16\n}\n    An MX represents a single DNS MX record.\n\ntype NS struct {\n\tHost string\n}\n    An NS represents a single DNS NS record.\n\ntype OpError struct {\n\t// Op is the operation which caused the error, such as\n\t// \"read\" or \"write\".\n\tOp string\n\n\t// Net is the network type on which this error occurred,\n\t// such as \"tcp\" or \"udp6\".\n\tNet string\n\n\t// For operations involving a remote network connection, like\n\t// Dial, Read, or Write, Source is the corresponding local\n\t// network address.\n\tSource Addr\n\n\t// Addr is the network address for which this error occurred.\n\t// For local operations, like Listen or SetDeadline, Addr is\n\t// the address of the local endpoint being manipulated.\n\t// For operations involving a remote network connection, like\n\t// Dial, Read, or Write, Addr is the remote address of that\n\t// connection.\n\tAddr Addr\n\n\t// Err is the error that occurred during the operation.\n\t// The Error method panics if the error is nil.\n\tErr error\n}\n    OpError is the error type usually returned by functions in the net package.\n    It describes the operation, network type, and address of an error.\n\nfunc (e *OpError) Error() string\n\nfunc (e *OpError) Temporary() bool\n\nfunc (e *OpError) Timeout() bool\n\nfunc (e *OpError) Unwrap() error\n\ntype PacketConn interface {\n\t// ReadFrom reads a packet from the connection,\n\t// copying the payload into p. It returns the number of\n\t// bytes copied into p and the return address that\n\t// was on the packet.\n\t// It returns the number of bytes read (0 <= n <= len(p))\n\t// and any error encountered. Callers should always process\n\t// the n > 0 bytes returned before considering the error err.\n\t// ReadFrom can be made to time out and return an error after a\n\t// fixed time limit; see SetDeadline and SetReadDeadline.\n\tReadFrom(p []byte) (n int, addr Addr, err error)\n\n\t// WriteTo writes a packet with payload p to addr.\n\t// WriteTo can be made to time out and return an Error after a\n\t// fixed time limit; see SetDeadline and SetWriteDeadline.\n\t// On packet-oriented connections, write timeouts are rare.\n\tWriteTo(p []byte, addr Addr) (n int, err error)\n\n\t// Close closes the connection.\n\t// Any blocked ReadFrom or WriteTo operations will be unblocked and return errors.\n\tClose() error\n\n\t// LocalAddr returns the local network address, if known.\n\tLocalAddr() Addr\n\n\t// SetDeadline sets the read and write deadlines associated\n\t// with the connection. It is equivalent to calling both\n\t// SetReadDeadline and SetWriteDeadline.\n\t//\n\t// A deadline is an absolute time after which I/O operations\n\t// fail instead of blocking. The deadline applies to all future\n\t// and pending I/O, not just the immediately following call to\n\t// Read or Write. After a deadline has been exceeded, the\n\t// connection can be refreshed by setting a deadline in the future.\n\t//\n\t// If the deadline is exceeded a call to Read or Write or to other\n\t// I/O methods will return an error that wraps os.ErrDeadlineExceeded.\n\t// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).\n\t// The error's Timeout method will return true, but note that there\n\t// are other possible errors for which the Timeout method will\n\t// return true even if the deadline has not been exceeded.\n\t//\n\t// An idle timeout can be implemented by repeatedly extending\n\t// the deadline after successful ReadFrom or WriteTo calls.\n\t//\n\t// A zero value for t means I/O operations will not time out.\n\tSetDeadline(t time.Time) error\n\n\t// SetReadDeadline sets the deadline for future ReadFrom calls\n\t// and any currently-blocked ReadFrom call.\n\t// A zero value for t means ReadFrom will not time out.\n\tSetReadDeadline(t time.Time) error\n\n\t// SetWriteDeadline sets the deadline for future WriteTo calls\n\t// and any currently-blocked WriteTo call.\n\t// Even if write times out, it may return n > 0, indicating that\n\t// some of the data was successfully written.\n\t// A zero value for t means WriteTo will not time out.\n\tSetWriteDeadline(t time.Time) error\n}\n    PacketConn is a generic packet-oriented network connection.\n\n    Multiple goroutines may invoke methods on a PacketConn simultaneously.\n\ntype ParseError struct {\n\t// Type is the type of string that was expected, such as\n\t// \"IP address\", \"CIDR address\".\n\tType string\n\n\t// Text is the malformed text string.\n\tText string\n}\n    A ParseError is the error type of literal network address parsers.\n\nfunc (e *ParseError) Error() string\n\nfunc (e *ParseError) Temporary() bool\n\nfunc (e *ParseError) Timeout() bool\n\ntype Resolver struct {\n\t// PreferGo controls whether Go's built-in DNS resolver is preferred\n\t// on platforms where it's available. It is equivalent to setting\n\t// GODEBUG=netdns=go, but scoped to just this resolver.\n\tPreferGo bool\n\n\t// StrictErrors controls the behavior of temporary errors\n\t// (including timeout, socket errors, and SERVFAIL) when using\n\t// Go's built-in resolver. For a query composed of multiple\n\t// sub-queries (such as an A+AAAA address lookup, or walking the\n\t// DNS search list), this option causes such errors to abort the\n\t// whole query instead of returning a partial result. This is\n\t// not enabled by default because it may affect compatibility\n\t// with resolvers that process AAAA queries incorrectly.\n\tStrictErrors bool\n\n\t// Dial optionally specifies an alternate dialer for use by\n\t// Go's built-in DNS resolver to make TCP and UDP connections\n\t// to DNS services. The host in the address parameter will\n\t// always be a literal IP address and not a host name, and the\n\t// port in the address parameter will be a literal port number\n\t// and not a service name.\n\t// If the Conn returned is also a PacketConn, sent and received DNS\n\t// messages must adhere to RFC 1035 section 4.2.1, \"UDP usage\".\n\t// Otherwise, DNS messages transmitted over Conn must adhere\n\t// to RFC 7766 section 5, \"Transport Protocol Selection\".\n\t// If nil, the default dialer is used.\n\tDial func(ctx context.Context, network, address string) (Conn, error)\n\n\t// Has unexported fields.\n}\n    A Resolver looks up names and numbers.\n\n    A nil *Resolver is equivalent to a zero Resolver.\n\nfunc (r *Resolver) LookupAddr(ctx context.Context, addr string) ([]string, error)\n    LookupAddr performs a reverse lookup for the given address, returning a list\n    of names mapping to that address.\n\n    The returned names are validated to be properly formatted\n    presentation-format domain names. If the response contains invalid names,\n    those records are filtered out and an error will be returned alongside the\n    remaining results, if any.\n\nfunc (r *Resolver) LookupCNAME(ctx context.Context, host string) (string, error)\n    LookupCNAME returns the canonical name for the given host. Callers that do\n    not care about the canonical name can call LookupHost or LookupIP directly;\n    both take care of resolving the canonical name as part of the lookup.\n\n    A canonical name is the final name after following zero or more CNAME\n    records. LookupCNAME does not return an error if host does not contain DNS\n    \"CNAME\" records, as long as host resolves to address records.\n\n    The returned canonical name is validated to be a properly formatted\n    presentation-format domain name.\n\nfunc (r *Resolver) LookupHost(ctx context.Context, host string) (addrs []string, err error)\n    LookupHost looks up the given host using the local resolver. It returns a\n    slice of that host's addresses.\n\nfunc (r *Resolver) LookupIP(ctx context.Context, network, host string) ([]IP, error)\n    LookupIP looks up host for the given network using the local resolver.\n    It returns a slice of that host's IP addresses of the type specified by\n    network. network must be one of \"ip\", \"ip4\" or \"ip6\".\n\nfunc (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)\n    LookupIPAddr looks up host using the local resolver. It returns a slice of\n    that host's IPv4 and IPv6 addresses.\n\nfunc (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error)\n    LookupMX returns the DNS MX records for the given domain name sorted by\n    preference.\n\n    The returned mail server names are validated to be properly formatted\n    presentation-format domain names, or numeric IP addresses. If the response\n    contains invalid names, those records are filtered out and an error will be\n    returned alongside the remaining results, if any.\n\nfunc (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error)\n    LookupNS returns the DNS NS records for the given domain name.\n\n    The returned name server names are validated to be properly formatted\n    presentation-format domain names. If the response contains invalid names,\n    those records are filtered out and an error will be returned alongside the\n    remaining results, if any.\n\nfunc (r *Resolver) LookupNetIP(ctx context.Context, network, host string) ([]netip.Addr, error)\n    LookupNetIP looks up host using the local resolver. It returns a slice of\n    that host's IP addresses of the type specified by network. The network must\n    be one of \"ip\", \"ip4\" or \"ip6\".\n\nfunc (r *Resolver) LookupPort(ctx context.Context, network, service string) (port int, err error)\n    LookupPort looks up the port for the given network and service.\n\n    The network must be one of \"tcp\", \"tcp4\", \"tcp6\", \"udp\", \"udp4\", \"udp6\" or\n    \"ip\".\n\nfunc (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (string, []*SRV, error)\n    LookupSRV tries to resolve an SRV query of the given service, protocol,\n    and domain name. The proto is \"tcp\" or \"udp\". The returned records are\n    sorted by priority and randomized by weight within a priority.\n\n    LookupSRV constructs the DNS name to look up following RFC 2782. That is,\n    it looks up _service._proto.name. To accommodate services publishing SRV\n    records under non-standard names, if both service and proto are empty\n    strings, LookupSRV looks up name directly.\n\n    The returned service names are validated to be properly formatted\n    presentation-format domain names. If the response contains invalid names,\n    those records are filtered out and an error will be returned alongside the\n    remaining results, if any.\n\nfunc (r *Resolver) LookupTXT(ctx context.Context, name string) ([]string, error)\n    LookupTXT returns the DNS TXT records for the given domain name.\n\n    If a DNS TXT record holds multiple strings, they are concatenated as a\n    single string.\n\ntype SRV struct {\n\tTarget   string\n\tPort     uint16\n\tPriority uint16\n\tWeight   uint16\n}\n    An SRV represents a single DNS SRV record.\n\ntype TCPAddr struct {\n\tIP   IP\n\tPort int\n\tZone string // IPv6 scoped addressing zone\n}\n    TCPAddr represents the address of a TCP end point.\n\nfunc TCPAddrFromAddrPort(addr netip.AddrPort) *TCPAddr\n    TCPAddrFromAddrPort returns addr as a TCPAddr. If addr.IsValid() is false,\n    then the returned TCPAddr will contain a nil IP field, indicating an address\n    family-agnostic unspecified address.\n\nfunc (a *TCPAddr) AddrPort() netip.AddrPort\n    AddrPort returns the TCPAddr a as a netip.AddrPort.\n\n    If a.Port does not fit in a uint16, it's silently truncated.\n\n    If a is nil, a zero value is returned.\n\nfunc (a *TCPAddr) Network() string\n    Network returns the address's network name, \"tcp\".\n\nfunc (a *TCPAddr) String() string\n\ntype TCPConn struct {\n\t// Has unexported fields.\n}\n    TCPConn is an implementation of the Conn interface for TCP network\n    connections.\n\nfunc (c *TCPConn) Close() error\n    Close closes the connection.\n\nfunc (c *TCPConn) CloseRead() error\n    CloseRead shuts down the reading side of the TCP connection. Most callers\n    should just use Close.\n\nfunc (c *TCPConn) CloseWrite() error\n    CloseWrite shuts down the writing side of the TCP connection. Most callers\n    should just use Close.\n\nfunc (c *TCPConn) File() (f *os.File, err error)\n    File returns a copy of the underlying os.File. It is the caller's\n    responsibility to close f when finished. Closing c does not affect f,\n    and closing f does not affect c.\n\n    The returned os.File's file descriptor is different from the connection's.\n    Attempting to change properties of the original using this duplicate may or\n    may not have the desired effect.\n\n    On Windows, the returned os.File's file descriptor is not usable on other\n    processes.\n\nfunc (c *TCPConn) LocalAddr() Addr\n    LocalAddr returns the local network address. The Addr returned is shared by\n    all invocations of LocalAddr, so do not modify it.\n\nfunc (c *TCPConn) MultipathTCP() (bool, error)\n    MultipathTCP reports whether the ongoing connection is using MPTCP.\n\n    If Multipath TCP is not supported by the host, by the other peer or\n    intentionally / accidentally filtered out by a device in between, a fallback\n    to TCP will be done. This method does its best to check if MPTCP is still\n    being used or not.\n\n    On Linux, more conditions are verified on kernels >= v5.16, improving the\n    results.\n\nfunc (c *TCPConn) Read(b []byte) (int, error)\n    Read implements the Conn Read method.\n\nfunc (c *TCPConn) ReadFrom(r io.Reader) (int64, error)\n    ReadFrom implements the io.ReaderFrom ReadFrom method.\n\nfunc (c *TCPConn) RemoteAddr() Addr\n    RemoteAddr returns the remote network address. The Addr returned is shared\n    by all invocations of RemoteAddr, so do not modify it.\n\nfunc (c *TCPConn) SetDeadline(t time.Time) error\n    SetDeadline implements the Conn SetDeadline method.\n\nfunc (c *TCPConn) SetKeepAlive(keepalive bool) error\n    SetKeepAlive sets whether the operating system should send keep-alive\n    messages on the connection.\n\nfunc (c *TCPConn) SetKeepAliveConfig(config KeepAliveConfig) error\n    SetKeepAliveConfig configures keep-alive messages sent by the operating\n    system.\n\nfunc (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error\n    SetKeepAlivePeriod sets the duration the connection needs to remain idle\n    before TCP starts sending keepalive probes.\n\n    Note that calling this method on Windows prior to Windows 10 version 1709\n    will reset the KeepAliveInterval to the default system value, which is\n    normally 1 second.\n\nfunc (c *TCPConn) SetLinger(sec int) error\n    SetLinger sets the behavior of Close on a connection which still has data\n    waiting to be sent or to be acknowledged.\n\n    If sec < 0 (the default), the operating system finishes sending the data in\n    the background.\n\n    If sec == 0, the operating system discards any unsent or unacknowledged\n    data.\n\n    If sec > 0, the data is sent in the background as with sec < 0. On some\n    operating systems including Linux, this may cause Close to block until all\n    data has been sent or discarded. On some operating systems after sec seconds\n    have elapsed any remaining unsent data may be discarded.\n\nfunc (c *TCPConn) SetNoDelay(noDelay bool) error\n    SetNoDelay controls whether the operating system should delay packet\n    transmission in hopes of sending fewer packets (Nagle's algorithm). The\n    default is true (no delay), meaning that data is sent as soon as possible\n    after a Write.\n\nfunc (c *TCPConn) SetReadBuffer(bytes int) error\n    SetReadBuffer sets the size of the operating system's receive buffer\n    associated with the connection.\n\nfunc (c *TCPConn) SetReadDeadline(t time.Time) error\n    SetReadDeadline implements the Conn SetReadDeadline method.\n\nfunc (c *TCPConn) SetWriteBuffer(bytes int) error\n    SetWriteBuffer sets the size of the operating system's transmit buffer\n    associated with the connection.\n\nfunc (c *TCPConn) SetWriteDeadline(t time.Time) error\n    SetWriteDeadline implements the Conn SetWriteDeadline method.\n\nfunc (c *TCPConn) SyscallConn() (syscall.RawConn, error)\n    SyscallConn returns a raw network connection. This implements the\n    syscall.Conn interface.\n\nfunc (c *TCPConn) Write(b []byte) (int, error)\n    Write implements the Conn Write method.\n\nfunc (c *TCPConn) WriteTo(w io.Writer) (int64, error)\n    WriteTo implements the io.WriterTo WriteTo method.\n\ntype TCPListener struct {\n\t// Has unexported fields.\n}\n    TCPListener is a TCP network listener. Clients should typically use\n    variables of type Listener instead of assuming TCP.\n\nfunc (l *TCPListener) Accept() (Conn, error)\n    Accept implements the Accept method in the Listener interface; it waits for\n    the next call and returns a generic Conn.\n\nfunc (l *TCPListener) AcceptTCP() (*TCPConn, error)\n    AcceptTCP accepts the next incoming call and returns the new connection.\n\nfunc (l *TCPListener) Addr() Addr\n    Addr returns the listener's network address, a *TCPAddr. The Addr returned\n    is shared by all invocations of Addr, so do not modify it.\n\nfunc (l *TCPListener) Close() error\n    Close stops listening on the TCP address. Already Accepted connections are\n    not closed.\n\nfunc (l *TCPListener) File() (f *os.File, err error)\n    File returns a copy of the underlying os.File. It is the caller's\n    responsibility to close f when finished. Closing l does not affect f,\n    and closing f does not affect l.\n\n    The returned os.File's file descriptor is different from the connection's.\n    Attempting to change properties of the original using this duplicate may or\n    may not have the desired effect.\n\n    On Windows, the returned os.File's file descriptor is not usable on other\n    processes.\n\nfunc (l *TCPListener) SetDeadline(t time.Time) error\n    SetDeadline sets the deadline associated with the listener. A zero time\n    value disables the deadline.\n\nfunc (l *TCPListener) SyscallConn() (syscall.RawConn, error)\n    SyscallConn returns a raw network connection. This implements the\n    syscall.Conn interface.\n\n    The returned RawConn only supports calling Control. Read and Write return an\n    error.\n\ntype UDPAddr struct {\n\tIP   IP\n\tPort int\n\tZone string // IPv6 scoped addressing zone\n}\n    UDPAddr represents the address of a UDP end point.\n\nfunc UDPAddrFromAddrPort(addr netip.AddrPort) *UDPAddr\n    UDPAddrFromAddrPort returns addr as a UDPAddr. If addr.IsValid() is false,\n    then the returned UDPAddr will contain a nil IP field, indicating an address\n    family-agnostic unspecified address.\n\nfunc (a *UDPAddr) AddrPort() netip.AddrPort\n    AddrPort returns the UDPAddr a as a netip.AddrPort.\n\n    If a.Port does not fit in a uint16, it's silently truncated.\n\n    If a is nil, a zero value is returned.\n\nfunc (a *UDPAddr) Network() string\n    Network returns the address's network name, \"udp\".\n\nfunc (a *UDPAddr) String() string\n\ntype UDPConn struct {\n\t// Has unexported fields.\n}\n    UDPConn is the implementation of the Conn and PacketConn interfaces for UDP\n    network connections.\n\nfunc (c *UDPConn) Close() error\n    Close closes the connection.\n\nfunc (c *UDPConn) File() (f *os.File, err error)\n    File returns a copy of the underlying os.File. It is the caller's\n    responsibility to close f when finished. Closing c does not affect f,\n    and closing f does not affect c.\n\n    The returned os.File's file descriptor is different from the connection's.\n    Attempting to change properties of the original using this duplicate may or\n    may not have the desired effect.\n\n    On Windows, the returned os.File's file descriptor is not usable on other\n    processes.\n\nfunc (c *UDPConn) LocalAddr() Addr\n    LocalAddr returns the local network address. The Addr returned is shared by\n    all invocations of LocalAddr, so do not modify it.\n\nfunc (c *UDPConn) Read(b []byte) (int, error)\n    Read implements the Conn Read method.\n\nfunc (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)\n    ReadFrom implements the PacketConn ReadFrom method.\n\nfunc (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)\n    ReadFromUDP acts like UDPConn.ReadFrom but returns a UDPAddr.\n\nfunc (c *UDPConn) ReadFromUDPAddrPort(b []byte) (n int, addr netip.AddrPort, err error)\n    ReadFromUDPAddrPort acts like ReadFrom but returns a netip.AddrPort.\n\n    If c is bound to an unspecified address, the returned netip.AddrPort's\n    address might be an IPv4-mapped IPv6 address. Use netip.Addr.Unmap to get\n    the address without the IPv6 prefix.\n\nfunc (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)\n    ReadMsgUDP reads a message from c, copying the payload into b and the\n    associated out-of-band data into oob. It returns the number of bytes copied\n    into b, the number of bytes copied into oob, the flags that were set on the\n    message and the source address of the message.\n\n    The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to\n    manipulate IP-level socket options in oob.\n\nfunc (c *UDPConn) ReadMsgUDPAddrPort(b, oob []byte) (n, oobn, flags int, addr netip.AddrPort, err error)\n    ReadMsgUDPAddrPort is like UDPConn.ReadMsgUDP but returns an netip.AddrPort\n    instead of a UDPAddr.\n\nfunc (c *UDPConn) RemoteAddr() Addr\n    RemoteAddr returns the remote network address. The Addr returned is shared\n    by all invocations of RemoteAddr, so do not modify it.\n\nfunc (c *UDPConn) SetDeadline(t time.Time) error\n    SetDeadline implements the Conn SetDeadline method.\n\nfunc (c *UDPConn) SetReadBuffer(bytes int) error\n    SetReadBuffer sets the size of the operating system's receive buffer\n    associated with the connection.\n\nfunc (c *UDPConn) SetReadDeadline(t time.Time) error\n    SetReadDeadline implements the Conn SetReadDeadline method.\n\nfunc (c *UDPConn) SetWriteBuffer(bytes int) error\n    SetWriteBuffer sets the size of the operating system's transmit buffer\n    associated with the connection.\n\nfunc (c *UDPConn) SetWriteDeadline(t time.Time) error\n    SetWriteDeadline implements the Conn SetWriteDeadline method.\n\nfunc (c *UDPConn) SyscallConn() (syscall.RawConn, error)\n    SyscallConn returns a raw network connection. This implements the\n    syscall.Conn interface.\n\nfunc (c *UDPConn) Write(b []byte) (int, error)\n    Write implements the Conn Write method.\n\nfunc (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)\n    WriteMsgUDP writes a message to addr via c if c isn't connected, or to\n    c's remote address if c is connected (in which case addr must be nil).\n    The payload is copied from b and the associated out-of-band data is copied\n    from oob. It returns the number of payload and out-of-band bytes written.\n\n    The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to\n    manipulate IP-level socket options in oob.\n\nfunc (c *UDPConn) WriteMsgUDPAddrPort(b, oob []byte, addr netip.AddrPort) (n, oobn int, err error)\n    WriteMsgUDPAddrPort is like UDPConn.WriteMsgUDP but takes a netip.AddrPort\n    instead of a UDPAddr.\n\nfunc (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)\n    WriteTo implements the PacketConn WriteTo method.\n\nfunc (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)\n    WriteToUDP acts like UDPConn.WriteTo but takes a UDPAddr.\n\nfunc (c *UDPConn) WriteToUDPAddrPort(b []byte, addr netip.AddrPort) (int, error)\n    WriteToUDPAddrPort acts like UDPConn.WriteTo but takes a netip.AddrPort.\n\ntype UnixAddr struct {\n\tName string\n\tNet  string\n}\n    UnixAddr represents the address of a Unix domain socket end point.\n\nfunc (a *UnixAddr) Network() string\n    Network returns the address's network name, \"unix\", \"unixgram\" or\n    \"unixpacket\".\n\nfunc (a *UnixAddr) String() string\n\ntype UnixConn struct {\n\t// Has unexported fields.\n}\n    UnixConn is an implementation of the Conn interface for connections to Unix\n    domain sockets.\n\nfunc (c *UnixConn) Close() error\n    Close closes the connection.\n\nfunc (c *UnixConn) CloseRead() error\n    CloseRead shuts down the reading side of the Unix domain connection.\n    Most callers should just use UnixConn.Close.\n\nfunc (c *UnixConn) CloseWrite() error\n    CloseWrite shuts down the writing side of the Unix domain connection.\n    Most callers should just use UnixConn.Close.\n\nfunc (c *UnixConn) File() (f *os.File, err error)\n    File returns a copy of the underlying os.File. It is the caller's\n    responsibility to close f when finished. Closing c does not affect f,\n    and closing f does not affect c.\n\n    The returned os.File's file descriptor is different from the connection's.\n    Attempting to change properties of the original using this duplicate may or\n    may not have the desired effect.\n\n    On Windows, the returned os.File's file descriptor is not usable on other\n    processes.\n\nfunc (c *UnixConn) LocalAddr() Addr\n    LocalAddr returns the local network address. The Addr returned is shared by\n    all invocations of LocalAddr, so do not modify it.\n\nfunc (c *UnixConn) Read(b []byte) (int, error)\n    Read implements the Conn Read method.\n\nfunc (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)\n    ReadFrom implements the PacketConn.ReadFrom method.\n\nfunc (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)\n    ReadFromUnix acts like UnixConn.ReadFrom but returns a UnixAddr.\n\nfunc (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)\n    ReadMsgUnix reads a message from c, copying the payload into b and the\n    associated out-of-band data into oob. It returns the number of bytes copied\n    into b, the number of bytes copied into oob, the flags that were set on the\n    message and the source address of the message.\n\n    Note that if len(b) == 0 and len(oob) > 0, this function will still read\n    (and discard) 1 byte from the connection.\n\nfunc (c *UnixConn) RemoteAddr() Addr\n    RemoteAddr returns the remote network address. The Addr returned is shared\n    by all invocations of RemoteAddr, so do not modify it.\n\nfunc (c *UnixConn) SetDeadline(t time.Time) error\n    SetDeadline implements the Conn SetDeadline method.\n\nfunc (c *UnixConn) SetReadBuffer(bytes int) error\n    SetReadBuffer sets the size of the operating system's receive buffer\n    associated with the connection.\n\nfunc (c *UnixConn) SetReadDeadline(t time.Time) error\n    SetReadDeadline implements the Conn SetReadDeadline method.\n\nfunc (c *UnixConn) SetWriteBuffer(bytes int) error\n    SetWriteBuffer sets the size of the operating system's transmit buffer\n    associated with the connection.\n\nfunc (c *UnixConn) SetWriteDeadline(t time.Time) error\n    SetWriteDeadline implements the Conn SetWriteDeadline method.\n\nfunc (c *UnixConn) SyscallConn() (syscall.RawConn, error)\n    SyscallConn returns a raw network connection. This implements the\n    syscall.Conn interface.\n\nfunc (c *UnixConn) Write(b []byte) (int, error)\n    Write implements the Conn Write method.\n\nfunc (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)\n    WriteMsgUnix writes a message to addr via c, copying the payload from b and\n    the associated out-of-band data from oob. It returns the number of payload\n    and out-of-band bytes written.\n\n    Note that if len(b) == 0 and len(oob) > 0, this function will still write 1\n    byte to the connection.\n\nfunc (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)\n    WriteTo implements the PacketConn.WriteTo method.\n\nfunc (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)\n    WriteToUnix acts like UnixConn.WriteTo but takes a UnixAddr.\n\ntype UnixListener struct {\n\t// Has unexported fields.\n}\n    UnixListener is a Unix domain socket listener. Clients should typically use\n    variables of type Listener instead of assuming Unix domain sockets.\n\nfunc (l *UnixListener) Accept() (Conn, error)\n    Accept implements the Accept method in the Listener interface. Returned\n    connections will be of type *UnixConn.\n\nfunc (l *UnixListener) AcceptUnix() (*UnixConn, error)\n    AcceptUnix accepts the next incoming call and returns the new connection.\n\nfunc (l *UnixListener) Addr() Addr\n    Addr returns the listener's network address. The Addr returned is shared by\n    all invocations of Addr, so do not modify it.\n\nfunc (l *UnixListener) Close() error\n    Close stops listening on the Unix address. Already accepted connections are\n    not closed.\n\nfunc (l *UnixListener) File() (f *os.File, err error)\n    File returns a copy of the underlying os.File. It is the caller's\n    responsibility to close f when finished. Closing l does not affect f,\n    and closing f does not affect l.\n\n    The returned os.File's file descriptor is different from the connection's.\n    Attempting to change properties of the original using this duplicate may or\n    may not have the desired effect.\n\n    On Windows, the returned os.File's file descriptor is not usable on other\n    processes.\n\nfunc (l *UnixListener) SetDeadline(t time.Time) error\n    SetDeadline sets the deadline associated with the listener. A zero time\n    value disables the deadline.\n\nfunc (l *UnixListener) SetUnlinkOnClose(unlink bool)\n    SetUnlinkOnClose sets whether the underlying socket file should be removed\n    from the file system when the listener is closed.\n\n    The default behavior is to unlink the socket file only when package net\n    created it. That is, when the listener and the underlying socket file were\n    created by a call to Listen or ListenUnix, then by default closing the\n    listener will remove the socket file. but if the listener was created by a\n    call to FileListener to use an already existing socket file, then by default\n    closing the listener will not remove the socket file.\n\nfunc (l *UnixListener) SyscallConn() (syscall.RawConn, error)\n    SyscallConn returns a raw network connection. This implements the\n    syscall.Conn interface.\n\n    The returned syscall.RawConn only supports calling Control. Read and Write\n    return an error.\n\ntype UnknownNetworkError string\n\nfunc (e UnknownNetworkError) Error() string\n\nfunc (e UnknownNetworkError) Temporary() bool\n\nfunc (e UnknownNetworkError) Timeout() bool\n\n\nBUG: On JS, the FileConn, FileListener and\nFilePacketConn functions are not implemented.\n\nBUG: On JS, methods and functions related to\nInterface are not implemented.\n\nBUG: On AIX, DragonFly BSD, NetBSD, OpenBSD, Plan 9 and\nSolaris, the MulticastAddrs method of Interface is not implemented.\n\nBUG: On every POSIX platform, reads from the \"ip4\" network\nusing the ReadFrom or ReadFromIP method might not return a complete\nIPv4 packet, including its header, even if there is space\navailable. This can occur even in cases where Read or ReadMsgIP\ncould return a complete packet. For this reason, it is recommended\nthat you do not use these methods if it is important to receive a\nfull packet.\n\nThe Go 1 compatibility guidelines make it impossible for us to\nchange the behavior of these methods; use Read or ReadMsgIP\ninstead.\n\nBUG: On JS and Plan 9, methods and functions related\nto IPConn are not implemented.\n\nBUG: On DragonFly BSD and OpenBSD, listening on the\n\"tcp\" and \"udp\" networks does not listen for both IPv4 and IPv6\nconnections. This is due to the fact that IPv4 traffic will not be\nrouted to an IPv6 socket - two separate sockets are required if\nboth address families are to be supported.\nSee inet6(4) for details.\n\nBUG: On Windows, the Write method of syscall.RawConn\ndoes not integrate with the runtime's network poller. It cannot\nwait for the connection to become writeable, and does not respect\ndeadlines. If the user-provided callback returns false, the Write\nmethod will fail immediately.\n\nBUG: On JS and Plan 9, the Control, Read and Write\nmethods of syscall.RawConn are not implemented.\n\nBUG: On JS, the File method of TCPConn and\nTCPListener is not implemented.\n\nBUG: On Plan 9, the ReadMsgUDP and\nWriteMsgUDP methods of UDPConn are not implemented.\n\nBUG: On JS, methods and functions related to UDPConn are not\nimplemented.\n\nBUG: On JS, WASIP1 and Plan 9, methods and functions related\nto UnixConn and UnixListener are not implemented.\n\nBUG: On Windows, methods and functions related to UnixConn\nand UnixListener don't work for \"unixgram\" and \"unixpacket\".\n\n"}, {"path": "stdlib/time-tzdata.md", "category": "stdlib", "name": "stdlib/time-tzdata", "content": "package tzdata // import \"time/tzdata\"\n\nPackage tzdata provides an embedded copy of the timezone database. If this\npackage is imported anywhere in the program, then if the time package cannot\nfind tzdata files on the system, it will use this embedded information.\n\nImporting this package will increase the size of a program by about 450 KB.\n\nThis package should normally be imported by a program's main package, not by a\nlibrary. Libraries normally shouldn't decide whether to include the timezone\ndatabase in a program.\n\nThis package will be automatically imported if you build with -tags timetzdata.\n"}, {"path": "stdlib/crypto-internal-cryptotest.md", "category": "stdlib", "name": "stdlib/crypto-internal-cryptotest", "content": "package cryptotest // import \"crypto/internal/cryptotest\"\n\n\nFUNCTIONS\n\nfunc FetchModule(t *testing.T, module, version string) string\n    FetchModule fetches the module at the given version and returns the\n    directory containing its source tree. It skips the test if fetching modules\n    is not possible in this environment.\n\nfunc NoExtraMethods(t *testing.T, ms interface{}, allowed ...string)\n    NoExtraMethods checks that the concrete type of *ms has no exported methods\n    beyond the methods of the interface type of *ms, and any others specified in\n    the allowed list.\n\n    These methods are accessible through interface upgrades, so they end up part\n    of the API even if undocumented per Hyrum's Law.\n\n    ms must be a pointer to a non-nil interface.\n\nfunc SkipTestAllocations(t *testing.T)\n    SkipTestAllocations skips the test if there are any factors that interfere\n    with allocation optimizations.\n\nfunc TestAEAD(t *testing.T, mAEAD MakeAEAD)\n    TestAEAD performs a set of tests on cipher.AEAD implementations, checking\n    the documented requirements of NonceSize, Overhead, Seal and Open.\n\nfunc TestAllImplementations(t *testing.T, pkg string, f func(t *testing.T))\n    TestAllImplementations runs the provided test function with each available\n    implementation of the package registered with crypto/internal/impl. If there\n    are no alternative implementations for pkg, f is invoked directly once.\n\nfunc TestBlock(t *testing.T, keySize int, mb MakeBlock)\n    TestBlock performs a set of tests on cipher.Block implementations, checking\n    the documented requirements of BlockSize, Encrypt, and Decrypt.\n\nfunc TestBlockMode(t *testing.T, block cipher.Block, makeEncrypter, makeDecrypter MakeBlockMode)\n    TestBlockMode performs a set of tests on cipher.BlockMode implementations,\n    checking the documented requirements of CryptBlocks.\n\nfunc TestHash(t *testing.T, mh MakeHash)\n    TestHash performs a set of tests on hash.Hash implementations, checking the\n    documented requirements of Write, Sum, Reset, Size, and BlockSize.\n\nfunc TestStream(t *testing.T, ms MakeStream)\n    TestStream performs a set of tests on cipher.Stream implementations,\n    checking the documented requirements of XORKeyStream.\n\nfunc TestStreamFromBlock(t *testing.T, block cipher.Block, blockMode func(b cipher.Block, iv []byte) cipher.Stream)\n    TestStreamFromBlock creates a Stream from a cipher.Block used in a\n    cipher.BlockMode. It addresses Issue 68377 by checking for a panic when the\n    BlockMode uses an IV with incorrect length. For a valid IV, it also runs all\n    TestStream tests on the resulting stream.\n\n\nTYPES\n\ntype MakeAEAD func() (cipher.AEAD, error)\n    MakeAEAD returns a cipher.AEAD instance.\n\n    Multiple calls to MakeAEAD must return equivalent instances, so for example\n    the key must be fixed.\n\ntype MakeBlock func(key []byte) (cipher.Block, error)\n\ntype MakeBlockMode func(b cipher.Block, iv []byte) cipher.BlockMode\n    MakeBlockMode returns a cipher.BlockMode instance. It expects len(iv) ==\n    b.BlockSize().\n\ntype MakeHash func() hash.Hash\n\ntype MakeStream func() cipher.Stream\n    MakeStream returns a cipher.Stream instance.\n\n    Multiple calls to MakeStream must return equivalent instances, so for\n    example the key and/or IV must be fixed.\n\n"}, {"path": "stdlib/encoding-asn1.md", "category": "stdlib", "name": "stdlib/encoding-asn1", "content": "package asn1 // import \"encoding/asn1\"\n\nPackage asn1 implements parsing of DER-encoded ASN.1 data structures, as defined\nin ITU-T Rec X.690.\n\nSee also \u201cA Layman's Guide to a Subset of ASN.1, BER, and DER,\u201d\nhttp://luca.ntop.org/Teaching/Appunti/asn1.html.\n\nCONSTANTS\n\nconst (\n\tTagBoolean         = 1\n\tTagInteger         = 2\n\tTagBitString       = 3\n\tTagOctetString     = 4\n\tTagNull            = 5\n\tTagOID             = 6\n\tTagEnum            = 10\n\tTagUTF8String      = 12\n\tTagSequence        = 16\n\tTagSet             = 17\n\tTagNumericString   = 18\n\tTagPrintableString = 19\n\tTagT61String       = 20\n\tTagIA5String       = 22\n\tTagUTCTime         = 23\n\tTagGeneralizedTime = 24\n\tTagGeneralString   = 27\n\tTagBMPString       = 30\n)\n    ASN.1 tags represent the type of the following object.\n\nconst (\n\tClassUniversal       = 0\n\tClassApplication     = 1\n\tClassContextSpecific = 2\n\tClassPrivate         = 3\n)\n    ASN.1 class types represent the namespace of the tag.\n\n\nVARIABLES\n\nvar NullBytes = []byte{TagNull, 0}\n    NullBytes contains bytes representing the DER-encoded ASN.1 NULL type.\n\nvar NullRawValue = RawValue{Tag: TagNull}\n    NullRawValue is a RawValue with its Tag set to the ASN.1 NULL type tag (5).\n\n\nFUNCTIONS\n\nfunc Marshal(val any) ([]byte, error)\n    Marshal returns the ASN.1 encoding of val.\n\n    In addition to the struct tags recognized by Unmarshal, the following can be\n    used:\n\n        ia5:         causes strings to be marshaled as ASN.1, IA5String values\n        omitempty:   causes empty slices to be skipped\n        printable:   causes strings to be marshaled as ASN.1, PrintableString values\n        utf8:        causes strings to be marshaled as ASN.1, UTF8String values\n        numeric:     causes strings to be marshaled as ASN.1, NumericString values\n        utc:         causes time.Time to be marshaled as ASN.1, UTCTime values\n        generalized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values\n\nfunc MarshalWithParams(val any, params string) ([]byte, error)\n    MarshalWithParams allows field parameters to be specified for the top-level\n    element. The form of the params is the same as the field tags.\n\nfunc Unmarshal(b []byte, val any) (rest []byte, err error)\n    Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect\n    package to fill in an arbitrary value pointed at by val. Because Unmarshal\n    uses the reflect package, the structs being written to must use upper case\n    field names. If val is nil or not a pointer, Unmarshal returns an error.\n\n    After parsing b, any bytes that were leftover and not used to fill val will\n    be returned in rest. When parsing a SEQUENCE into a struct, any trailing\n    elements of the SEQUENCE that do not have matching fields in val will not be\n    included in rest, as these are considered valid elements of the SEQUENCE and\n    not trailing data.\n\n      - An ASN.1 INTEGER can be written to an int, int32, int64, or *big.Int.\n        If the encoded value does not fit in the Go type, Unmarshal returns a\n        parse error.\n\n      - An ASN.1 BIT STRING can be written to a BitString.\n\n      - An ASN.1 OCTET STRING can be written to a []byte.\n\n      - An ASN.1 OBJECT IDENTIFIER can be written to an ObjectIdentifier.\n\n      - An ASN.1 ENUMERATED can be written to an Enumerated.\n\n      - An ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.\n\n      - An ASN.1 PrintableString, IA5String, or NumericString can be written to\n        a string.\n\n      - Any of the above ASN.1 values can be written to an interface{}.\n        The value stored in the interface has the corresponding Go type.\n        For integers, that type is int64.\n\n      - An ASN.1 SEQUENCE OF x or SET OF x can be written to a slice if an x can\n        be written to the slice's element type.\n\n      - An ASN.1 SEQUENCE or SET can be written to a struct if each of the\n        elements in the sequence can be written to the corresponding element in\n        the struct.\n\n    The following tags on struct fields have special meaning to Unmarshal:\n\n        application specifies that an APPLICATION tag is used\n        private     specifies that a PRIVATE tag is used\n        default:x   sets the default value for optional integer fields (only used if optional is also present)\n        explicit    specifies that an additional, explicit tag wraps the implicit one\n        optional    marks the field as ASN.1 OPTIONAL\n        set         causes a SET, rather than a SEQUENCE type to be expected\n        tag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\n\n    When decoding an ASN.1 value with an IMPLICIT tag into a string field,\n    Unmarshal will default to a PrintableString, which doesn't support\n    characters such as '@' and '&'. To force other encodings, use the following\n    tags:\n\n        ia5     causes strings to be unmarshaled as ASN.1 IA5String values\n        numeric causes strings to be unmarshaled as ASN.1 NumericString values\n        utf8    causes strings to be unmarshaled as ASN.1 UTF8String values\n\n    When decoding an ASN.1 value with an IMPLICIT tag into a time.Time field,\n    Unmarshal will default to a UTCTime, which doesn't support time zones or\n    fractional seconds. To force usage of GeneralizedTime, use the following\n    tag:\n\n        generalized causes time.Times to be unmarshaled as ASN.1 GeneralizedTime values\n\n    If the type of the first field of a structure is RawContent then the raw\n    ASN1 contents of the struct will be stored in it.\n\n    If the name of a slice type ends with \"SET\" then it's treated as if the\n    \"set\" tag was set on it. This results in interpreting the type as a SET OF\n    x rather than a SEQUENCE OF x. This can be used with nested slices where a\n    struct tag cannot be given.\n\n    Other ASN.1 types are not supported; if it encounters them, Unmarshal\n    returns a parse error.\n\nfunc UnmarshalWithParams(b []byte, val any, params string) (rest []byte, err error)\n    UnmarshalWithParams allows field parameters to be specified for the\n    top-level element. The form of the params is the same as the field tags.\n\n\nTYPES\n\ntype BitString struct {\n\tBytes     []byte // bits packed into bytes.\n\tBitLength int    // length in bits.\n}\n    BitString is the structure to use when you want an ASN.1 BIT STRING type.\n    A bit string is padded up to the nearest byte in memory and the number of\n    valid bits is recorded. Padding bits will be zero.\n\nfunc (b BitString) At(i int) int\n    At returns the bit at the given index. If the index is out of range it\n    returns 0.\n\nfunc (b BitString) RightAlign() []byte\n    RightAlign returns a slice where the padding bits are at the beginning.\n    The slice may share memory with the BitString.\n\ntype Enumerated int\n    An Enumerated is represented as a plain int.\n\ntype Flag bool\n    A Flag accepts any data and is set to true if present.\n\ntype ObjectIdentifier []int\n    An ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER.\n\nfunc (oi ObjectIdentifier) Equal(other ObjectIdentifier) bool\n    Equal reports whether oi and other represent the same identifier.\n\nfunc (oi ObjectIdentifier) String() string\n\ntype RawContent []byte\n    RawContent is used to signal that the undecoded, DER data needs to be\n    preserved for a struct. To use it, the first field of the struct must have\n    this type. It's an error for any of the other fields to have this type.\n\ntype RawValue struct {\n\tClass, Tag int\n\tIsCompound bool\n\tBytes      []byte\n\tFullBytes  []byte // includes the tag and length\n}\n    A RawValue represents an undecoded ASN.1 object.\n\ntype StructuralError struct {\n\tMsg string\n}\n    A StructuralError suggests that the ASN.1 data is valid, but the Go type\n    which is receiving it doesn't match.\n\nfunc (e StructuralError) Error() string\n\ntype SyntaxError struct {\n\tMsg string\n}\n    A SyntaxError suggests that the ASN.1 data is invalid.\n\nfunc (e SyntaxError) Error() string\n\n"}, {"path": "stdlib/net-http-internal-testcert.md", "category": "stdlib", "name": "stdlib/net-http-internal-testcert", "content": "package testcert // import \"net/http/internal/testcert\"\n\nPackage testcert contains a test-only localhost certificate.\n\nVARIABLES\n\nvar LocalhostCert = []byte(`-----BEGIN CERTIFICATE-----\nMIIDSDCCAjCgAwIBAgIQEP/md970HysdBTpuzDOf0DANBgkqhkiG9w0BAQsFADAS\nMRAwDgYDVQQKEwdBY21lIENvMCAXDTcwMDEwMTAwMDAwMFoYDzIwODQwMTI5MTYw\nMDAwWjASMRAwDgYDVQQKEwdBY21lIENvMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A\nMIIBCgKCAQEAxcl69ROJdxjN+MJZnbFrYxyQooADCsJ6VDkuMyNQIix/Hk15Nk/u\nFyBX1Me++aEpGmY3RIY4fUvELqT/srvAHsTXwVVSttMcY8pcAFmXSqo3x4MuUTG/\njCX3Vftj0r3EM5M8ImY1rzA/jqTTLJg00rD+DmuDABcqQvoXw/RV8w1yTRi5BPoH\nDFD/AWTt/YgMvk1l2Yq/xI8VbMUIpjBoGXxWsSevQ5i2s1mk9/yZzu0Ysp1tTlzD\nqOPa4ysFjBitdXiwfxjxtv5nXqOCP5rheKO0sWLk0fetMp1OV5JSJMAJw6c2ZMkl\nU2WMqAEpRjdE/vHfIuNg+yGaRRqI07NZRQIDAQABo4GXMIGUMA4GA1UdDwEB/wQE\nAwICpDATBgNVHSUEDDAKBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud\nDgQWBBQR5QIzmacmw78ZI1C4MXw7Q0wJ1jA9BgNVHREENjA0ggtleGFtcGxlLmNv\nbYINKi5leGFtcGxlLmNvbYcEfwAAAYcQAAAAAAAAAAAAAAAAAAAAATANBgkqhkiG\n9w0BAQsFAAOCAQEACrRNgiioUDzxQftd0fwOa6iRRcPampZRDtuaF68yNHoNWbOu\nLUwc05eOWxRq3iABGSk2xg+FXM3DDeW4HhAhCFptq7jbVZ+4Jj6HeJG9mYRatAxR\nY/dEpa0D0EHhDxxVg6UzKOXB355n0IetGE/aWvyTV9SiDs6QsaC57Q9qq1/mitx5\n2GFBoapol9L5FxCc77bztzK8CpLujkBi25Vk6GAFbl27opLfpyxkM+rX/T6MXCPO\n6/YBacNZ7ff1/57Etg4i5mNA6ubCpuc4Gi9oYqCNNohftr2lkJr7REdDR6OW0lsL\nrF7r4gUnKeC7mYIH1zypY7laskopiLFAfe96Kg==\n-----END CERTIFICATE-----`)\n    LocalhostCert is a PEM-encoded TLS cert with SAN IPs \"127.0.0.1\"\n    and \"[::1]\", expiring at Jan 29 16:00:00 2084 GMT. generated from\n    src/crypto/tls: go run generate_cert.go --rsa-bits 2048 --host\n    127.0.0.1,::1,example.com,*.example.com --ca --start-date \"Jan 1 00:00:00\n    1970\" --duration=1000000h\n\nvar LocalhostKey = []byte(testingKey(`-----BEGIN RSA TESTING KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDFyXr1E4l3GM34\nwlmdsWtjHJCigAMKwnpUOS4zI1AiLH8eTXk2T+4XIFfUx775oSkaZjdEhjh9S8Qu\npP+yu8AexNfBVVK20xxjylwAWZdKqjfHgy5RMb+MJfdV+2PSvcQzkzwiZjWvMD+O\npNMsmDTSsP4Oa4MAFypC+hfD9FXzDXJNGLkE+gcMUP8BZO39iAy+TWXZir/EjxVs\nxQimMGgZfFaxJ69DmLazWaT3/JnO7RiynW1OXMOo49rjKwWMGK11eLB/GPG2/mde\no4I/muF4o7SxYuTR960ynU5XklIkwAnDpzZkySVTZYyoASlGN0T+8d8i42D7IZpF\nGojTs1lFAgMBAAECggEAIYthUi1lFBDd5gG4Rzlu+BlBIn5JhcqkCqLEBiJIFfOr\n/4yuMRrvS3bNzqWt6xJ9MSAC4ZlN/VobRLnxL/QNymoiGYUKCT3Ww8nvPpPzR9OE\nsE68TUL9tJw/zZJcRMKwgvrGqSLimfq53MxxkE+kLdOc0v9C8YH8Re26mB5ZcWYa\n7YFyZQpKsQYnsmu/05cMbpOQrQWhtmIqRoyn8mG/par2s3NzjtpSE9NINyz26uFc\nk/3ovFJQIHkUmTS7KHD3BgY5vuCqP98HramYnOysJ0WoYgvSDNCWw3037s5CCwJT\ngCKuM+Ow6liFrj83RrdKBpm5QUGjfNpYP31o+QNP4QKBgQDSrUQ2XdgtAnibAV7u\n7kbxOxro0EhIKso0Y/6LbDQgcXgxLqltkmeqZgG8nC3Z793lhlSasz2snhzzooV5\n5fTy1y8ikXqjhG0nNkInFyOhsI0auE28CFoDowaQd+5cmCatpN4Grqo5PNRXxm1w\nHktfPEgoP11NNCFHvvN5fEKbbQKBgQDwVlOaV20IvW3IPq7cXZyiyabouFF9eTRo\nVJka1Uv+JtyvL2P0NKkjYHOdN8gRblWqxQtJoTNk020rVA4UP1heiXALy50gvj/p\nhMcybPTLYSPOhAGx838KIcvGR5oskP1aUCmFbFQzGELxhJ9diVVjxUtbG2DuwPKd\ntD9TLxT2OQKBgQCcdlHSjp+dzdgERmBa0ludjGfPv9/uuNizUBAbO6D690psPFtY\nJQMYaemgSd1DngEOFVWADt4e9M5Lose+YCoqr+UxpxmNlyv5kzJOFcFAs/4XeglB\nPHKdgNW/NVKxMc6H54l9LPr+x05sYdGlEtqnP/3W5jhEvhJ5Vjc8YiyVgQKBgQCl\nzwjyrGo+42GACy7cPYE5FeIfIDqoVByB9guC5bD98JXEDu/opQQjsgFRcBCJZhOY\nM0UsURiB8ROaFu13rpQq9KrmmF0ZH+g8FSzQbzcbsTLg4VXCDXmR5esOKowFPypr\nSm667BfTAGP++D5ya7MLmCv6+RKQ5XD8uEQQAaV2kQKBgAD8qeJuWIXZT0VKkQrn\nnIhgtzGERF/6sZdQGW2LxTbUDWG74AfFkkEbeBfwEkCZXY/xmnYqYABhvlSex8jU\nsupU6Eea21esIxIub2zv/Np0ojUb6rlqTPS4Ox1E27D787EJ3VOXpriSD10vyNnZ\njel6uj2FOP9g54s+GzlSVg/T\n-----END RSA TESTING KEY-----`))\n    LocalhostKey is the private key for LocalhostCert.\n\n"}, {"path": "stdlib/crypto-internal-hpke.md", "category": "stdlib", "name": "stdlib/crypto-internal-hpke", "content": "package hpke // import \"crypto/internal/hpke\"\n\n\nCONSTANTS\n\nconst (\n\tAEAD_AES_128_GCM      = 0x0001\n\tAEAD_AES_256_GCM      = 0x0002\n\tAEAD_ChaCha20Poly1305 = 0x0003\n)\nconst DHKEM_X25519_HKDF_SHA256 = 0x0020\nconst KDF_HKDF_SHA256 = 0x0001\n\nVARIABLES\n\nvar SupportedAEADs = map[uint16]struct {\n\tkeySize   int\n\tnonceSize int\n\taead      func([]byte) (cipher.AEAD, error)\n}{\n\n\tAEAD_AES_128_GCM:      {keySize: 16, nonceSize: 12, aead: aesGCMNew},\n\tAEAD_AES_256_GCM:      {keySize: 32, nonceSize: 12, aead: aesGCMNew},\n\tAEAD_ChaCha20Poly1305: {keySize: chacha20poly1305.KeySize, nonceSize: chacha20poly1305.NonceSize, aead: chacha20poly1305.New},\n}\nvar SupportedKDFs = map[uint16]func() *hkdfKDF{\n\n\tKDF_HKDF_SHA256: func() *hkdfKDF { return &hkdfKDF{crypto.SHA256} },\n}\nvar SupportedKEMs = map[uint16]struct {\n\tcurve   ecdh.Curve\n\thash    crypto.Hash\n\tnSecret uint16\n}{\n\n\tDHKEM_X25519_HKDF_SHA256: {ecdh.X25519(), crypto.SHA256, 32},\n}\n\nFUNCTIONS\n\nfunc ParseHPKEPrivateKey(kemID uint16, bytes []byte) (*ecdh.PrivateKey, error)\nfunc ParseHPKEPublicKey(kemID uint16, bytes []byte) (*ecdh.PublicKey, error)\n\nTYPES\n\ntype AEADID uint16\n\ntype KDFID uint16\n\ntype KemID uint16\n\ntype Recipient struct {\n\t// Has unexported fields.\n}\n\nfunc SetupRecipient(kemID, kdfID, aeadID uint16, priv *ecdh.PrivateKey, info, encPubEph []byte) (*Recipient, error)\n\nfunc (r *Recipient) Open(aad, ciphertext []byte) ([]byte, error)\n\ntype Sender struct {\n\t// Has unexported fields.\n}\n\nfunc SetupSender(kemID, kdfID, aeadID uint16, pub *ecdh.PublicKey, info []byte) ([]byte, *Sender, error)\n\nfunc (s *Sender) Seal(aad, plaintext []byte) ([]byte, error)\n\n"}, {"path": "stdlib/crypto-rsa.md", "category": "stdlib", "name": "stdlib/crypto-rsa", "content": "package rsa // import \"crypto/rsa\"\n\nPackage rsa implements RSA encryption as specified in PKCS #1 and RFC 8017.\n\nRSA is a single, fundamental operation that is used in this package to implement\neither public-key encryption or public-key signatures.\n\nThe original specification for encryption and signatures with RSA is PKCS #1\nand the terms \"RSA encryption\" and \"RSA signatures\" by default refer to PKCS #1\nversion 1.5. However, that specification has flaws and new designs should use\nversion 2, usually called by just OAEP and PSS, where possible.\n\nTwo sets of interfaces are included in this package. When a more abstract\ninterface isn't necessary, there are functions for encrypting/decrypting with\nv1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract over the\npublic key primitive, the PrivateKey type implements the Decrypter and Signer\ninterfaces from the crypto package.\n\nOperations involving private keys are implemented using constant-time\nalgorithms, except for GenerateKey and for some operations involving deprecated\nmulti-prime keys.\n\n# Minimum key size\n\nGenerateKey returns an error if a key of less than 1024 bits is requested,\nand all Sign, Verify, Encrypt, and Decrypt methods return an error if used with\na key smaller than 1024 bits. Such keys are insecure and should not be used.\n\nThe rsa1024min=0 GODEBUG setting suppresses this error, but we recommend doing\nso only in tests, if necessary. Tests can set this option using testing.T.Setenv\nor by including \"//go:debug rsa1024min=0\" in a *_test.go source file.\n\nAlternatively, see the GenerateKey (TestKey) example for a pregenerated\ntest-only 2048-bit key.\n\n[GenerateKey (TestKey)]: https://pkg.go.dev/crypto/rsa#example-GenerateKey-TestKey\n\nCONSTANTS\n\nconst (\n\t// PSSSaltLengthAuto causes the salt in a PSS signature to be as large\n\t// as possible when signing, and to be auto-detected when verifying.\n\t//\n\t// When signing in FIPS 140-3 mode, the salt length is capped at the length\n\t// of the hash function used in the signature.\n\tPSSSaltLengthAuto = 0\n\t// PSSSaltLengthEqualsHash causes the salt length to equal the length\n\t// of the hash used in the signature.\n\tPSSSaltLengthEqualsHash = -1\n)\n\nVARIABLES\n\nvar ErrDecryption = errors.New(\"crypto/rsa: decryption error\")\n    ErrDecryption represents a failure to decrypt a message. It is deliberately\n    vague to avoid adaptive attacks.\n\nvar ErrMessageTooLong = errors.New(\"crypto/rsa: message too long for RSA key size\")\n    ErrMessageTooLong is returned when attempting to encrypt or sign a message\n    which is too large for the size of the key. When using SignPSS, this can\n    also be returned if the size of the salt is too large.\n\nvar ErrVerification = errors.New(\"crypto/rsa: verification error\")\n    ErrVerification represents a failure to verify a signature. It is\n    deliberately vague to avoid adaptive attacks.\n\n\nFUNCTIONS\n\nfunc DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)\n    DecryptOAEP decrypts ciphertext using RSA-OAEP.\n\n    OAEP is parameterised by a hash function that is used as a random oracle.\n    Encryption and decryption of a given message must use the same hash function\n    and sha256.New() is a reasonable choice.\n\n    The random parameter is legacy and ignored, and it can be nil.\n\n    The label parameter must match the value given when encrypting. See\n    EncryptOAEP for details.\n\nfunc DecryptPKCS1v15(random io.Reader, priv *PrivateKey, ciphertext []byte) ([]byte, error)\n    DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from\n    PKCS #1 v1.5. The random parameter is legacy and ignored, and it can be nil.\n\n    Note that whether this function returns an error or not discloses\n    secret information. If an attacker can cause this function to run\n    repeatedly and learn whether each instance returned an error then they\n    can decrypt and forge signatures as if they had the private key. See\n    DecryptPKCS1v15SessionKey for a way of solving this problem.\n\nfunc DecryptPKCS1v15SessionKey(random io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) error\n    DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding\n    scheme from PKCS #1 v1.5. The random parameter is legacy and ignored,\n    and it can be nil.\n\n    DecryptPKCS1v15SessionKey returns an error if the ciphertext is the wrong\n    length or if the ciphertext is greater than the public modulus. Otherwise,\n    no error is returned. If the padding is valid, the resulting plaintext\n    message is copied into key. Otherwise, key is unchanged. These alternatives\n    occur in constant time. It is intended that the user of this function\n    generate a random session key beforehand and continue the protocol with the\n    resulting value.\n\n    Note that if the session key is too small then it may be possible for an\n    attacker to brute-force it. If they can do that then they can learn whether\n    a random value was used (because it'll be different for the same ciphertext)\n    and thus whether the padding was correct. This also defeats the point of\n    this function. Using at least a 16-byte key will protect against this\n    attack.\n\n    This method implements protections against Bleichenbacher chosen ciphertext\n    attacks [0] described in RFC 3218 Section 2.3.2 [1]. While these\n    protections make a Bleichenbacher attack significantly more difficult,\n    the protections are only effective if the rest of the protocol which uses\n    DecryptPKCS1v15SessionKey is designed with these considerations in mind. In\n    particular, if any subsequent operations which use the decrypted session key\n    leak any information about the key (e.g. whether it is a static or random\n    key) then the mitigations are defeated. This method must be used extremely\n    carefully, and typically should only be used when absolutely necessary for\n    compatibility with an existing protocol (such as TLS) that is designed with\n    these properties in mind.\n\n      - [0] \u201cChosen Ciphertext Attacks Against Protocols Based on the RSA\n        Encryption Standard PKCS #1\u201d, Daniel Bleichenbacher, Advances in\n        Cryptology (Crypto '98)\n      - [1] RFC 3218, Preventing the Million Message Attack on CMS,\n        https://www.rfc-editor.org/rfc/rfc3218.html\n\nfunc EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error)\n    EncryptOAEP encrypts the given message with RSA-OAEP.\n\n    OAEP is parameterised by a hash function that is used as a random oracle.\n    Encryption and decryption of a given message must use the same hash function\n    and sha256.New() is a reasonable choice.\n\n    The random parameter is used as a source of entropy to ensure that\n    encrypting the same message twice doesn't result in the same ciphertext.\n    Most applications should use crypto/rand.Reader as random.\n\n    The label parameter may contain arbitrary data that will not be encrypted,\n    but which gives important context to the message. For example, if a given\n    public key is used to encrypt two types of messages then distinct label\n    values could be used to ensure that a ciphertext for one purpose cannot be\n    used for another by an attacker. If not required it can be empty.\n\n    The message must be no longer than the length of the public modulus minus\n    twice the hash length, minus a further 2.\n\nfunc EncryptPKCS1v15(random io.Reader, pub *PublicKey, msg []byte) ([]byte, error)\n    EncryptPKCS1v15 encrypts the given message with RSA and the padding scheme\n    from PKCS #1 v1.5. The message must be no longer than the length of the\n    public modulus minus 11 bytes.\n\n    The random parameter is used as a source of entropy to ensure that\n    encrypting the same message twice doesn't result in the same ciphertext.\n    Most applications should use crypto/rand.Reader as random. Note that the\n    returned ciphertext does not depend deterministically on the bytes read from\n    random, and may change between calls and/or between versions.\n\n    WARNING: use of this function to encrypt plaintexts other than session keys\n    is dangerous. Use RSA OAEP in new protocols.\n\nfunc SignPKCS1v15(random io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) ([]byte, error)\n    SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN\n    from RSA PKCS #1 v1.5. Note that hashed must be the result of hashing the\n    input message using the given hash function. If hash is zero, hashed is\n    signed directly. This isn't advisable except for interoperability.\n\n    The random parameter is legacy and ignored, and it can be nil.\n\n    This function is deterministic. Thus, if the set of possible messages is\n    small, an attacker may be able to build a map from messages to signatures\n    and identify the signed messages. As ever, signatures provide authenticity,\n    not confidentiality.\n\nfunc SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte, opts *PSSOptions) ([]byte, error)\n    SignPSS calculates the signature of digest using PSS.\n\n    digest must be the result of hashing the input message using the given hash\n    function. The opts argument may be nil, in which case sensible defaults are\n    used. If opts.Hash is set, it overrides hash.\n\n    The signature is randomized depending on the message, key, and salt size,\n    using bytes from rand. Most applications should use crypto/rand.Reader as\n    rand.\n\nfunc VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error\n    VerifyPKCS1v15 verifies an RSA PKCS #1 v1.5 signature. hashed is the result\n    of hashing the input message using the given hash function and sig is\n    the signature. A valid signature is indicated by returning a nil error.\n    If hash is zero then hashed is used directly. This isn't advisable except\n    for interoperability.\n\n    The inputs are not considered confidential, and may leak through timing side\n    channels, or if an attacker has control of part of the inputs.\n\nfunc VerifyPSS(pub *PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts *PSSOptions) error\n    VerifyPSS verifies a PSS signature.\n\n    A valid signature is indicated by returning a nil error. digest must be\n    the result of hashing the input message using the given hash function.\n    The opts argument may be nil, in which case sensible defaults are used.\n    opts.Hash is ignored.\n\n    The inputs are not considered confidential, and may leak through timing side\n    channels, or if an attacker has control of part of the inputs.\n\n\nTYPES\n\ntype CRTValue struct {\n\tExp   *big.Int // D mod (prime-1).\n\tCoeff *big.Int // R\u00b7Coeff \u2261 1 mod Prime.\n\tR     *big.Int // product of primes prior to this (inc p and q).\n}\n    CRTValue contains the precomputed Chinese remainder theorem values.\n\ntype OAEPOptions struct {\n\t// Hash is the hash function that will be used when generating the mask.\n\tHash crypto.Hash\n\n\t// MGFHash is the hash function used for MGF1.\n\t// If zero, Hash is used instead.\n\tMGFHash crypto.Hash\n\n\t// Label is an arbitrary byte string that must be equal to the value\n\t// used when encrypting.\n\tLabel []byte\n}\n    OAEPOptions is an interface for passing options to OAEP decryption using the\n    crypto.Decrypter interface.\n\ntype PKCS1v15DecryptOptions struct {\n\t// SessionKeyLen is the length of the session key that is being\n\t// decrypted. If not zero, then a padding error during decryption will\n\t// cause a random plaintext of this length to be returned rather than\n\t// an error. These alternatives happen in constant time.\n\tSessionKeyLen int\n}\n    PKCS1v15DecryptOptions is for passing options to PKCS #1 v1.5 decryption\n    using the crypto.Decrypter interface.\n\ntype PSSOptions struct {\n\t// SaltLength controls the length of the salt used in the PSS signature. It\n\t// can either be a positive number of bytes, or one of the special\n\t// PSSSaltLength constants.\n\tSaltLength int\n\n\t// Hash is the hash function used to generate the message digest. If not\n\t// zero, it overrides the hash function passed to SignPSS. It's required\n\t// when using PrivateKey.Sign.\n\tHash crypto.Hash\n}\n    PSSOptions contains options for creating and verifying PSS signatures.\n\nfunc (opts *PSSOptions) HashFunc() crypto.Hash\n    HashFunc returns opts.Hash so that PSSOptions implements crypto.SignerOpts.\n\ntype PrecomputedValues struct {\n\tDp, Dq *big.Int // D mod (P-1) (or mod Q-1)\n\tQinv   *big.Int // Q^-1 mod P\n\n\t// CRTValues is used for the 3rd and subsequent primes. Due to a\n\t// historical accident, the CRT for the first two primes is handled\n\t// differently in PKCS #1 and interoperability is sufficiently\n\t// important that we mirror this.\n\t//\n\t// Deprecated: These values are still filled in by Precompute for\n\t// backwards compatibility but are not used. Multi-prime RSA is very rare,\n\t// and is implemented by this package without CRT optimizations to limit\n\t// complexity.\n\tCRTValues []CRTValue\n\n\t// Has unexported fields.\n}\n\ntype PrivateKey struct {\n\tPublicKey            // public part.\n\tD         *big.Int   // private exponent\n\tPrimes    []*big.Int // prime factors of N, has >= 2 elements.\n\n\t// Precomputed contains precomputed values that speed up RSA operations,\n\t// if available. It must be generated by calling PrivateKey.Precompute and\n\t// must not be modified.\n\tPrecomputed PrecomputedValues\n}\n    A PrivateKey represents an RSA key\n\nfunc GenerateKey(random io.Reader, bits int) (*PrivateKey, error)\n    GenerateKey generates a random RSA private key of the given bit size.\n\n    If bits is less than 1024, GenerateKey returns an error. See the \"Minimum\n    key size\" section for further details.\n\n    Most applications should use crypto/rand.Reader as rand. Note that the\n    returned key does not depend deterministically on the bytes read from rand,\n    and may change between calls and/or between versions.\n\n[Minimum key size]: https://pkg.go.dev/crypto/rsa#hdr-Minimum_key_size\n\nfunc GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey, error)\n    GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit\n    size and the given random source.\n\n    Table 1 in \"On the Security of Multi-prime RSA\" suggests maximum numbers of\n    primes for a given bit size.\n\n    Although the public keys are compatible (actually, indistinguishable) from\n    the 2-prime case, the private keys are not. Thus it may not be possible to\n    export multi-prime private keys in certain formats or to subsequently import\n    them into other code.\n\n    This package does not implement CRT optimizations for multi-prime RSA,\n    so the keys with more than two primes will have worse performance.\n\n    Deprecated: The use of this function with a number of primes different\n    from two is not recommended for the above security, compatibility, and\n    performance reasons. Use GenerateKey instead.\n\n[On the Security of Multi-prime RSA]: http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n\nfunc (priv *PrivateKey) Decrypt(rand io.Reader, ciphertext []byte, opts crypto.DecrypterOpts) (plaintext []byte, err error)\n    Decrypt decrypts ciphertext with priv. If opts is nil or of type\n    *PKCS1v15DecryptOptions then PKCS #1 v1.5 decryption is performed. Otherwise\n    opts must have type *OAEPOptions and OAEP decryption is done.\n\nfunc (priv *PrivateKey) Equal(x crypto.PrivateKey) bool\n    Equal reports whether priv and x have equivalent values. It ignores\n    Precomputed values.\n\nfunc (priv *PrivateKey) Precompute()\n    Precompute performs some calculations that speed up private key operations\n    in the future. It is safe to run on non-validated private keys.\n\nfunc (priv *PrivateKey) Public() crypto.PublicKey\n    Public returns the public key corresponding to priv.\n\nfunc (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error)\n    Sign signs digest with priv, reading randomness from rand. If opts is a\n    *PSSOptions then the PSS algorithm will be used, otherwise PKCS #1 v1.5\n    will be used. digest must be the result of hashing the input message using\n    opts.HashFunc().\n\n    This method implements crypto.Signer, which is an interface to support\n    keys where the private part is kept in, for example, a hardware module.\n    Common uses should use the Sign* functions in this package directly.\n\nfunc (priv *PrivateKey) Validate() error\n    Validate performs basic sanity checks on the key. It returns nil if the key\n    is valid, or else an error describing a problem.\n\n    It runs faster on valid keys if run after PrivateKey.Precompute.\n\ntype PublicKey struct {\n\tN *big.Int // modulus\n\tE int      // public exponent\n}\n    A PublicKey represents the public part of an RSA key.\n\n    The values of N and E are not considered confidential, and may leak through\n    side channels, or could be mathematically derived from other public values.\n\nfunc (pub *PublicKey) Equal(x crypto.PublicKey) bool\n    Equal reports whether pub and x have the same value.\n\nfunc (pub *PublicKey) Size() int\n    Size returns the modulus size in bytes. Raw signatures and ciphertexts for\n    or by this public key will have the same size.\n\n"}, {"path": "stdlib/crypto-rand.md", "category": "stdlib", "name": "stdlib/crypto-rand", "content": "package rand // import \"crypto/rand\"\n\nPackage rand implements a cryptographically secure random number generator.\n\nVARIABLES\n\nvar Reader io.Reader\n    Reader is a global, shared instance of a cryptographically secure random\n    number generator. It is safe for concurrent use.\n\n      - On Linux, FreeBSD, Dragonfly, and Solaris, Reader uses getrandom(2).\n      - On legacy Linux (< 3.17), Reader opens /dev/urandom on first use.\n      - On macOS, iOS, and OpenBSD Reader, uses arc4random_buf(3).\n      - On NetBSD, Reader uses the kern.arandom sysctl.\n      - On Windows, Reader uses the ProcessPrng API.\n      - On js/wasm, Reader uses the Web Crypto API.\n      - On wasip1/wasm, Reader uses random_get.\n\n    In FIPS 140-3 mode, the output passes through an SP 800-90A Rev.\n    1 Deterministric Random Bit Generator (DRBG).\n\n\nFUNCTIONS\n\nfunc Int(rand io.Reader, max *big.Int) (n *big.Int, err error)\n    Int returns a uniform random value in [0, max). It panics if max <= 0,\n    and returns an error if rand.Read returns one.\n\nfunc Prime(rand io.Reader, bits int) (*big.Int, error)\n    Prime returns a number of the given bit length that is prime with high\n    probability. Prime will return error for any error returned by rand.Read or\n    if bits < 2.\n\nfunc Read(b []byte) (n int, err error)\n    Read fills b with cryptographically secure random bytes. It never returns an\n    error, and always fills b entirely.\n\n    Read calls io.ReadFull on Reader and crashes the program irrecoverably if\n    an error is returned. The default Reader uses operating system APIs that are\n    documented to never return an error on all but legacy Linux systems.\n\nfunc Text() string\n    Text returns a cryptographically random string using the standard RFC\n    4648 base32 alphabet for use when a secret string, token, password, or\n    other text is needed. The result contains at least 128 bits of randomness,\n    enough to prevent brute force guessing attacks and to make the likelihood\n    of collisions vanishingly small. A future version may return longer texts as\n    needed to maintain those properties.\n\n"}, {"path": "stdlib/internal-filepathlite.md", "category": "stdlib", "name": "stdlib/internal-filepathlite", "content": "package filepathlite // import \"internal/filepathlite\"\n\nPackage filepathlite implements a subset of path/filepath, only using packages\nwhich may be imported by \"os\".\n\nTests for these functions are in path/filepath.\n\nCONSTANTS\n\nconst (\n\tSeparator     = '/' // OS-specific path separator\n\tListSeparator = ':' // OS-specific path list separator\n)\n\nFUNCTIONS\n\nfunc Base(path string) string\n    Base is filepath.Base.\n\nfunc Clean(path string) string\n    Clean is filepath.Clean.\n\nfunc Dir(path string) string\n    Dir is filepath.Dir.\n\nfunc Ext(path string) string\n    Ext is filepath.Ext.\n\nfunc FromSlash(path string) string\n    FromSlash is filepath.FromSlash.\n\nfunc IsAbs(path string) bool\n    IsAbs reports whether the path is absolute.\n\nfunc IsLocal(path string) bool\n    IsLocal is filepath.IsLocal.\n\nfunc IsPathSeparator(c uint8) bool\nfunc Localize(path string) (string, error)\n    Localize is filepath.Localize.\n\nfunc Split(path string) (dir, file string)\n    Split is filepath.Split.\n\nfunc ToSlash(path string) string\n    ToSlash is filepath.ToSlash.\n\nfunc VolumeName(path string) string\n    VolumeName is filepath.VolumeName.\n\nfunc VolumeNameLen(path string) int\n    VolumeNameLen returns the length of the leading volume name on Windows.\n    It returns 0 elsewhere.\n\n"}, {"path": "stdlib/vendor-golang.org-x-crypto-cryptobyte-asn1.md", "category": "stdlib", "name": "stdlib/vendor-golang.org-x-crypto-cryptobyte-asn1", "content": ""}, {"path": "stdlib/crypto-internal-fips140-sha3.md", "category": "stdlib", "name": "stdlib/crypto-internal-fips140-sha3", "content": "package sha3 // import \"crypto/internal/fips140/sha3\"\n\nPackage sha3 implements the SHA-3 fixed-output-length hash functions and the\nSHAKE variable-output-length functions defined by FIPS 202, as well as the\ncSHAKE extendable-output-length functions defined by SP 800-185.\n\n[FIPS 202]: https://doi.org/10.6028/NIST.FIPS.202\n[SP 800-185]: https://doi.org/10.6028/NIST.SP.800-185\n\nTYPES\n\ntype Digest struct {\n\t// Has unexported fields.\n}\n\nfunc New224() *Digest\n    New224 returns a new Digest computing the SHA3-224 hash.\n\nfunc New256() *Digest\n    New256 returns a new Digest computing the SHA3-256 hash.\n\nfunc New384() *Digest\n    New384 returns a new Digest computing the SHA3-384 hash.\n\nfunc New512() *Digest\n    New512 returns a new Digest computing the SHA3-512 hash.\n\nfunc NewLegacyKeccak256() *Digest\n    NewLegacyKeccak256 returns a new Digest computing the legacy, non-standard\n    Keccak-256 hash.\n\nfunc NewLegacyKeccak512() *Digest\n    NewLegacyKeccak512 returns a new Digest computing the legacy, non-standard\n    Keccak-512 hash.\n\nfunc (d *Digest) AppendBinary(b []byte) ([]byte, error)\n\nfunc (d *Digest) BlockSize() int\n    BlockSize returns the rate of sponge underlying this hash function.\n\nfunc (d *Digest) Clone() *Digest\n\nfunc (d *Digest) MarshalBinary() ([]byte, error)\n\nfunc (d *Digest) Reset()\n    Reset resets the Digest to its initial state.\n\nfunc (d *Digest) Size() int\n    Size returns the output size of the hash function in bytes.\n\nfunc (d *Digest) Sum(b []byte) []byte\n    Sum appends the current hash to b and returns the resulting slice. It does\n    not change the underlying hash state.\n\nfunc (d *Digest) UnmarshalBinary(b []byte) error\n\nfunc (d *Digest) Write(p []byte) (n int, err error)\n    Write absorbs more data into the hash's state.\n\ntype SHAKE struct {\n\t// Has unexported fields.\n}\n\nfunc NewCShake128(N, S []byte) *SHAKE\n    NewCShake128 creates a new cSHAKE128 XOF.\n\n    N is used to define functions based on cSHAKE, it can be empty when\n    plain cSHAKE is desired. S is a customization byte string used for domain\n    separation. When N and S are both empty, this is equivalent to NewShake128.\n\nfunc NewCShake256(N, S []byte) *SHAKE\n    NewCShake256 creates a new cSHAKE256 XOF.\n\n    N is used to define functions based on cSHAKE, it can be empty when\n    plain cSHAKE is desired. S is a customization byte string used for domain\n    separation. When N and S are both empty, this is equivalent to NewShake256.\n\nfunc NewShake128() *SHAKE\n    NewShake128 creates a new SHAKE128 XOF.\n\nfunc NewShake256() *SHAKE\n    NewShake256 creates a new SHAKE256 XOF.\n\nfunc (s *SHAKE) AppendBinary(b []byte) ([]byte, error)\n\nfunc (s *SHAKE) BlockSize() int\n\nfunc (s *SHAKE) Clone() *SHAKE\n    Clone returns a copy of the SHAKE context in its current state.\n\nfunc (s *SHAKE) MarshalBinary() ([]byte, error)\n\nfunc (s *SHAKE) Read(out []byte) (n int, err error)\n\nfunc (s *SHAKE) Reset()\n    Reset resets the hash to initial state.\n\nfunc (s *SHAKE) Size() int\n\nfunc (s *SHAKE) Sum(in []byte) []byte\n    Sum appends a portion of output to b and returns the resulting slice.\n    The output length is selected to provide full-strength generic security:\n    32 bytes for SHAKE128 and 64 bytes for SHAKE256. It does not change the\n    underlying state. It panics if any output has already been read.\n\nfunc (s *SHAKE) UnmarshalBinary(b []byte) error\n\nfunc (s *SHAKE) Write(p []byte) (n int, err error)\n    Write absorbs more data into the hash's state. It panics if any output has\n    already been read.\n\n"}, {"path": "stdlib/internal-coverage-test.md", "category": "stdlib", "name": "stdlib/internal-coverage-test", "content": ""}, {"path": "stdlib/internal-unsafeheader.md", "category": "stdlib", "name": "stdlib/internal-unsafeheader", "content": "package unsafeheader // import \"internal/unsafeheader\"\n\nPackage unsafeheader contains header declarations for the Go runtime's slice and\nstring implementations.\n\nThis package allows packages that cannot import \"reflect\" to use types that are\ntested to be equivalent to reflect.SliceHeader and reflect.StringHeader.\n\nTYPES\n\ntype Slice struct {\n\tData unsafe.Pointer\n\tLen  int\n\tCap  int\n}\n    Slice is the runtime representation of a slice. It cannot be used safely or\n    portably and its representation may change in a later release.\n\n    Unlike reflect.SliceHeader, its Data field is sufficient to guarantee the\n    data it references will not be garbage collected.\n\ntype String struct {\n\tData unsafe.Pointer\n\tLen  int\n}\n    String is the runtime representation of a string. It cannot be used safely\n    or portably and its representation may change in a later release.\n\n    Unlike reflect.StringHeader, its Data field is sufficient to guarantee the\n    data it references will not be garbage collected.\n\n"}, {"path": "stdlib/internal-diff.md", "category": "stdlib", "name": "stdlib/internal-diff", "content": "package diff // import \"internal/diff\"\n\n\nFUNCTIONS\n\nfunc Diff(oldName string, old []byte, newName string, new []byte) []byte\n    Diff returns an anchored diff of the two texts old and new in the \u201cunified\n    diff\u201d format. If old and new are identical, Diff returns a nil slice (no\n    output).\n\n    Unix diff implementations typically look for a diff with the smallest\n    number of lines inserted and removed, which can in the worst case take\n    time quadratic in the number of lines in the texts. As a result, many\n    implementations either can be made to run for a long time or cut off the\n    search after a predetermined amount of work.\n\n    In contrast, this implementation looks for a diff with the smallest number\n    of \u201cunique\u201d lines inserted and removed, where unique means a line that\n    appears just once in both old and new. We call this an \u201canchored diff\u201d\n    because the unique lines anchor the chosen matching regions. An anchored\n    diff is usually clearer than a standard diff, because the algorithm does\n    not try to reuse unrelated blank lines or closing braces. The algorithm also\n    guarantees to run in O(n log n) time instead of the standard O(n\u00b2) time.\n\n    Some systems call this approach a \u201cpatience diff,\u201d named for the\n    \u201cpatience sorting\u201d algorithm, itself named for a solitaire card game.\n    We avoid that name for two reasons. First, the name has been used for\n    a few different variants of the algorithm, so it is imprecise. Second,\n    the name is frequently interpreted as meaning that you have to wait longer\n    (to be patient) for the diff, meaning that it is a slower algorithm, when in\n    fact the algorithm is faster than the standard one.\n\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# Go Language Specification\nVersion: unknown\n\nSource: https://go.dev/ref/spec\n\n\nSee: https://go.dev/ref/spec\n"}, {"path": "linters/golangci-lint/staticcheck.md", "category": "linters", "name": "linters/golangci-lint/staticcheck", "content": "# staticcheck\n\nSee: https://golangci-lint.run/docs/linters/staticcheck/\n"}, {"path": "linters/golangci-lint/interfacebloat.md", "category": "linters", "name": "linters/golangci-lint/interfacebloat", "content": "# interfacebloat\n\nSee: https://golangci-lint.run/docs/linters/interfacebloat/\n"}, {"path": "linters/golangci-lint/nonamedreturns.md", "category": "linters", "name": "linters/golangci-lint/nonamedreturns", "content": "# nonamedreturns\n\nSee: https://golangci-lint.run/docs/linters/nonamedreturns/\n"}, {"path": "linters/golangci-lint/goheader.md", "category": "linters", "name": "linters/golangci-lint/goheader", "content": "# goheader\n\nSee: https://golangci-lint.run/docs/linters/goheader/\n"}, {"path": "linters/golangci-lint/godoclint.md", "category": "linters", "name": "linters/golangci-lint/godoclint", "content": "# godoclint\n\nSee: https://golangci-lint.run/docs/linters/godoclint/\n"}, {"path": "linters/golangci-lint/exhaustive.md", "category": "linters", "name": "linters/golangci-lint/exhaustive", "content": "# exhaustive\n\nSee: https://golangci-lint.run/docs/linters/exhaustive/\n"}, {"path": "linters/golangci-lint/recvcheck.md", "category": "linters", "name": "linters/golangci-lint/recvcheck", "content": "# recvcheck\n\nSee: https://golangci-lint.run/docs/linters/recvcheck/\n"}, {"path": "linters/golangci-lint/grouper.md", "category": "linters", "name": "linters/golangci-lint/grouper", "content": "# grouper\n\nSee: https://golangci-lint.run/docs/linters/grouper/\n"}, {"path": "linters/golangci-lint/unqueryvet.md", "category": "linters", "name": "linters/golangci-lint/unqueryvet", "content": "# unqueryvet\n\nSee: https://golangci-lint.run/docs/linters/unqueryvet/\n"}, {"path": "linters/golangci-lint/sqlclosecheck.md", "category": "linters", "name": "linters/golangci-lint/sqlclosecheck", "content": "# sqlclosecheck\n\nSee: https://golangci-lint.run/docs/linters/sqlclosecheck/\n"}, {"path": "linters/golangci-lint/perfsprint.md", "category": "linters", "name": "linters/golangci-lint/perfsprint", "content": "# perfsprint\n\nSee: https://golangci-lint.run/docs/linters/perfsprint/\n"}, {"path": "linters/golangci-lint/fatcontext.md", "category": "linters", "name": "linters/golangci-lint/fatcontext", "content": "# fatcontext\n\nSee: https://golangci-lint.run/docs/linters/fatcontext/\n"}, {"path": "linters/golangci-lint/cyclop.md", "category": "linters", "name": "linters/golangci-lint/cyclop", "content": "# cyclop\n\nSee: https://golangci-lint.run/docs/linters/cyclop/\n"}, {"path": "linters/golangci-lint/nolintlint.md", "category": "linters", "name": "linters/golangci-lint/nolintlint", "content": "# nolintlint\n\nSee: https://golangci-lint.run/docs/linters/nolintlint/\n"}, {"path": "linters/golangci-lint/ginkgolinter.md", "category": "linters", "name": "linters/golangci-lint/ginkgolinter", "content": "# ginkgolinter\n\nSee: https://golangci-lint.run/docs/linters/ginkgolinter/\n"}, {"path": "linters/golangci-lint/gosmopolitan.md", "category": "linters", "name": "linters/golangci-lint/gosmopolitan", "content": "# gosmopolitan\n\nSee: https://golangci-lint.run/docs/linters/gosmopolitan/\n"}, {"path": "linters/golangci-lint/govet.md", "category": "linters", "name": "linters/golangci-lint/govet", "content": "# govet\n\nSee: https://golangci-lint.run/docs/linters/govet/\n"}, {"path": "linters/golangci-lint/overview.md", "category": "linters", "name": "linters/golangci-lint/overview", "content": "# golangci-lint Rules (from .golangci.yml)\nVersion: unknown\n\nSource: https://golangci-lint.run/usage/linters/\n\n\nSource: https://raw.githubusercontent.com/maratori/golangci-lint-config/main/.golangci.yml\n\n## Enabled\n- asasalint\n- asciicheck\n- bidichk\n- bodyclose\n- canonicalheader\n- copyloopvar\n- cyclop\n- depguard\n- dupl\n- durationcheck\n- embeddedstructfieldcheck\n- errcheck\n- errname\n- errorlint\n- exhaustive\n- exptostd\n- fatcontext\n- forbidigo\n- funcorder\n- funlen\n- gocheckcompilerdirectives\n- gochecknoglobals\n- gochecknoinits\n- gochecksumtype\n- gocognit\n- goconst\n- gocritic\n- gocyclo\n- godoclint\n- godot\n- gomoddirectives\n- goprintffuncname\n- gosec\n- govet\n- iface\n- ineffassign\n- intrange\n- iotamixing\n- loggercheck\n- makezero\n- mirror\n- mnd\n- modernize\n- musttag\n- nakedret\n- nestif\n- nilerr\n- nilnesserr\n- nilnil\n- noctx\n- nolintlint\n- nonamedreturns\n- nosprintfhostport\n- perfsprint\n- predeclared\n- promlinter\n- protogetter\n- reassign\n- recvcheck\n- revive\n- rowserrcheck\n- sloglint\n- spancheck\n- sqlclosecheck\n- staticcheck\n- testableexamples\n- testifylint\n- testpackage\n- tparallel\n- unconvert\n- unparam\n- unqueryvet\n- unused\n- usestdlibvars\n- usetesting\n- wastedassign\n- whitespace\n\n## Optional\n- arangolint\n- decorder\n- exhaustruct\n- ginkgolinter\n- godox\n- goheader\n- inamedparam\n- interfacebloat\n- ireturn\n- noinlineerr\n- prealloc\n- tagalign\n- varnamelen\n- wrapcheck\n- zerologlint\n\n## Disabled\n- containedctx\n- contextcheck\n- dogsled\n- dupword\n- err113\n- errchkjson\n- forcetypeassert\n- gomodguard\n- gosmopolitan\n- grouper\n- importas\n- lll\n- maintidx\n- misspell\n- nlreturn\n- paralleltest\n- tagliatelle\n- thelper\n- wsl\n- wsl_v5\n"}, {"path": "linters/golangci-lint/nilnesserr.md", "category": "linters", "name": "linters/golangci-lint/nilnesserr", "content": "# nilnesserr\n\nSee: https://golangci-lint.run/docs/linters/nilnesserr/\n"}, {"path": "linters/golangci-lint/testableexamples.md", "category": "linters", "name": "linters/golangci-lint/testableexamples", "content": "# testableexamples\n\nSee: https://golangci-lint.run/docs/linters/testableexamples/\n"}, {"path": "linters/golangci-lint/godox.md", "category": "linters", "name": "linters/golangci-lint/godox", "content": "# godox\n\nSee: https://golangci-lint.run/docs/linters/godox/\n"}, {"path": "linters/golangci-lint/dogsled.md", "category": "linters", "name": "linters/golangci-lint/dogsled", "content": "# dogsled\n\nSee: https://golangci-lint.run/docs/linters/dogsled/\n"}, {"path": "linters/golangci-lint/decorder.md", "category": "linters", "name": "linters/golangci-lint/decorder", "content": "# decorder\n\nSee: https://golangci-lint.run/docs/linters/decorder/\n"}, {"path": "linters/golangci-lint/predeclared.md", "category": "linters", "name": "linters/golangci-lint/predeclared", "content": "# predeclared\n\nSee: https://golangci-lint.run/docs/linters/predeclared/\n"}, {"path": "linters/golangci-lint/iotamixing.md", "category": "linters", "name": "linters/golangci-lint/iotamixing", "content": "# iotamixing\n\nSee: https://golangci-lint.run/docs/linters/iotamixing/\n"}, {"path": "linters/golangci-lint/goprintffuncname.md", "category": "linters", "name": "linters/golangci-lint/goprintffuncname", "content": "# goprintffuncname\n\nSee: https://golangci-lint.run/docs/linters/goprintffuncname/\n"}, {"path": "linters/golangci-lint/paralleltest.md", "category": "linters", "name": "linters/golangci-lint/paralleltest", "content": "# paralleltest\n\nSee: https://golangci-lint.run/docs/linters/paralleltest/\n"}, {"path": "linters/golangci-lint/inamedparam.md", "category": "linters", "name": "linters/golangci-lint/inamedparam", "content": "# inamedparam\n\nSee: https://golangci-lint.run/docs/linters/inamedparam/\n"}, {"path": "linters/golangci-lint/rowserrcheck.md", "category": "linters", "name": "linters/golangci-lint/rowserrcheck", "content": "# rowserrcheck\n\nSee: https://golangci-lint.run/docs/linters/rowserrcheck/\n"}, {"path": "linters/golangci-lint/unparam.md", "category": "linters", "name": "linters/golangci-lint/unparam", "content": "# unparam\n\nSee: https://golangci-lint.run/docs/linters/unparam/\n"}, {"path": "linters/golangci-lint/mnd.md", "category": "linters", "name": "linters/golangci-lint/mnd", "content": "# mnd\n\nSee: https://golangci-lint.run/docs/linters/mnd/\n"}, {"path": "linters/golangci-lint/bodyclose.md", "category": "linters", "name": "linters/golangci-lint/bodyclose", "content": "# bodyclose\n\nSee: https://golangci-lint.run/docs/linters/bodyclose/\n"}, {"path": "linters/golangci-lint/misspell.md", "category": "linters", "name": "linters/golangci-lint/misspell", "content": "# misspell\n\nSee: https://golangci-lint.run/docs/linters/misspell/\n"}, {"path": "linters/golangci-lint/noctx.md", "category": "linters", "name": "linters/golangci-lint/noctx", "content": "# noctx\n\nSee: https://golangci-lint.run/docs/linters/noctx/\n"}, {"path": "linters/golangci-lint/copyloopvar.md", "category": "linters", "name": "linters/golangci-lint/copyloopvar", "content": "# copyloopvar\n\nSee: https://golangci-lint.run/docs/linters/copyloopvar/\n"}, {"path": "linters/golangci-lint/gochecknoinits.md", "category": "linters", "name": "linters/golangci-lint/gochecknoinits", "content": "# gochecknoinits\n\nSee: https://golangci-lint.run/docs/linters/gochecknoinits/\n"}, {"path": "linters/golangci-lint/promlinter.md", "category": "linters", "name": "linters/golangci-lint/promlinter", "content": "# promlinter\n\nSee: https://golangci-lint.run/docs/linters/promlinter/\n"}, {"path": "linters/golangci-lint/errcheck.md", "category": "linters", "name": "linters/golangci-lint/errcheck", "content": "# errcheck\n\nSee: https://golangci-lint.run/docs/linters/errcheck/\n"}, {"path": "linters/golangci-lint/funlen.md", "category": "linters", "name": "linters/golangci-lint/funlen", "content": "# funlen\n\nSee: https://golangci-lint.run/docs/linters/funlen/\n"}, {"path": "linters/golangci-lint/unused.md", "category": "linters", "name": "linters/golangci-lint/unused", "content": "# unused\n\nSee: https://golangci-lint.run/docs/linters/unused/\n"}, {"path": "linters/golangci-lint/whitespace.md", "category": "linters", "name": "linters/golangci-lint/whitespace", "content": "# whitespace\n\nSee: https://golangci-lint.run/docs/linters/whitespace/\n"}, {"path": "linters/golangci-lint/varnamelen.md", "category": "linters", "name": "linters/golangci-lint/varnamelen", "content": "# varnamelen\n\nSee: https://golangci-lint.run/docs/linters/varnamelen/\n"}, {"path": "linters/golangci-lint/gocheckcompilerdirectives.md", "category": "linters", "name": "linters/golangci-lint/gocheckcompilerdirectives", "content": "# gocheckcompilerdirectives\n\nSee: https://golangci-lint.run/docs/linters/gocheckcompilerdirectives/\n"}, {"path": "linters/golangci-lint/intrange.md", "category": "linters", "name": "linters/golangci-lint/intrange", "content": "# intrange\n\nSee: https://golangci-lint.run/docs/linters/intrange/\n"}, {"path": "linters/golangci-lint/durationcheck.md", "category": "linters", "name": "linters/golangci-lint/durationcheck", "content": "# durationcheck\n\nSee: https://golangci-lint.run/docs/linters/durationcheck/\n"}, {"path": "linters/golangci-lint/forbidigo.md", "category": "linters", "name": "linters/golangci-lint/forbidigo", "content": "# forbidigo\n\nSee: https://golangci-lint.run/docs/linters/forbidigo/\n"}, {"path": "linters/golangci-lint/canonicalheader.md", "category": "linters", "name": "linters/golangci-lint/canonicalheader", "content": "# canonicalheader\n\nSee: https://golangci-lint.run/docs/linters/canonicalheader/\n"}, {"path": "linters/golangci-lint/bidichk.md", "category": "linters", "name": "linters/golangci-lint/bidichk", "content": "# bidichk\n\nSee: https://golangci-lint.run/docs/linters/bidichk/\n"}, {"path": "linters/golangci-lint/usetesting.md", "category": "linters", "name": "linters/golangci-lint/usetesting", "content": "# usetesting\n\nSee: https://golangci-lint.run/docs/linters/usetesting/\n"}, {"path": "linters/golangci-lint/ireturn.md", "category": "linters", "name": "linters/golangci-lint/ireturn", "content": "# ireturn\n\nSee: https://golangci-lint.run/docs/linters/ireturn/\n"}, {"path": "linters/golangci-lint/arangolint.md", "category": "linters", "name": "linters/golangci-lint/arangolint", "content": "# arangolint\n\nSee: https://golangci-lint.run/docs/linters/arangolint/\n"}, {"path": "linters/golangci-lint/errname.md", "category": "linters", "name": "linters/golangci-lint/errname", "content": "# errname\n\nSee: https://golangci-lint.run/docs/linters/errname/\n"}, {"path": "linters/golangci-lint/exptostd.md", "category": "linters", "name": "linters/golangci-lint/exptostd", "content": "# exptostd\n\nSee: https://golangci-lint.run/docs/linters/exptostd/\n"}, {"path": "linters/golangci-lint/gochecknoglobals.md", "category": "linters", "name": "linters/golangci-lint/gochecknoglobals", "content": "# gochecknoglobals\n\nSee: https://golangci-lint.run/docs/linters/gochecknoglobals/\n"}, {"path": "linters/golangci-lint/gomodguard.md", "category": "linters", "name": "linters/golangci-lint/gomodguard", "content": "# gomodguard\n\nSee: https://golangci-lint.run/docs/linters/gomodguard/\n"}, {"path": "linters/golangci-lint/errchkjson.md", "category": "linters", "name": "linters/golangci-lint/errchkjson", "content": "# errchkjson\n\nSee: https://golangci-lint.run/docs/linters/errchkjson/\n"}, {"path": "linters/golangci-lint/nestif.md", "category": "linters", "name": "linters/golangci-lint/nestif", "content": "# nestif\n\nSee: https://golangci-lint.run/docs/linters/nestif/\n"}, {"path": "linters/golangci-lint/forcetypeassert.md", "category": "linters", "name": "linters/golangci-lint/forcetypeassert", "content": "# forcetypeassert\n\nSee: https://golangci-lint.run/docs/linters/forcetypeassert/\n"}, {"path": "linters/golangci-lint/nakedret.md", "category": "linters", "name": "linters/golangci-lint/nakedret", "content": "# nakedret\n\nSee: https://golangci-lint.run/docs/linters/nakedret/\n"}, {"path": "linters/golangci-lint/protogetter.md", "category": "linters", "name": "linters/golangci-lint/protogetter", "content": "# protogetter\n\nSee: https://golangci-lint.run/docs/linters/protogetter/\n"}, {"path": "linters/golangci-lint/gomoddirectives.md", "category": "linters", "name": "linters/golangci-lint/gomoddirectives", "content": "# gomoddirectives\n\nSee: https://golangci-lint.run/docs/linters/gomoddirectives/\n"}, {"path": "linters/golangci-lint/noinlineerr.md", "category": "linters", "name": "linters/golangci-lint/noinlineerr", "content": "# noinlineerr\n\nSee: https://golangci-lint.run/docs/linters/noinlineerr/\n"}, {"path": "linters/golangci-lint/usestdlibvars.md", "category": "linters", "name": "linters/golangci-lint/usestdlibvars", "content": "# usestdlibvars\n\nSee: https://golangci-lint.run/docs/linters/usestdlibvars/\n"}, {"path": "linters/golangci-lint/modernize.md", "category": "linters", "name": "linters/golangci-lint/modernize", "content": "# modernize\n\nSee: https://golangci-lint.run/docs/linters/modernize/\n"}, {"path": "linters/golangci-lint/depguard.md", "category": "linters", "name": "linters/golangci-lint/depguard", "content": "# depguard\n\nSee: https://golangci-lint.run/docs/linters/depguard/\n"}, {"path": "linters/golangci-lint/gocognit.md", "category": "linters", "name": "linters/golangci-lint/gocognit", "content": "# gocognit\n\nSee: https://golangci-lint.run/docs/linters/gocognit/\n"}, {"path": "linters/golangci-lint/gocyclo.md", "category": "linters", "name": "linters/golangci-lint/gocyclo", "content": "# gocyclo\n\nSee: https://golangci-lint.run/docs/linters/gocyclo/\n"}, {"path": "linters/golangci-lint/gochecksumtype.md", "category": "linters", "name": "linters/golangci-lint/gochecksumtype", "content": "# gochecksumtype\n\nSee: https://golangci-lint.run/docs/linters/gochecksumtype/\n"}, {"path": "linters/golangci-lint/config.md", "category": "linters", "name": "linters/golangci-lint/config", "content": "# golangci-lint Config (.golangci.yml)\n\nSource: https://raw.githubusercontent.com/maratori/golangci-lint-config/main/.golangci.yml\n\n```yaml\n# This file is licensed under the terms of the MIT license https://opensource.org/license/mit\n# Copyright (c) 2021-2025 Marat Reimers\n\n## Golden config for golangci-lint v2.7.2\n#\n# This is the best config for golangci-lint based on my experience and opinion.\n# It is very strict, but not extremely strict.\n# Feel free to adapt it to suit your needs.\n# If this config helps you, please consider keeping a link to this repo (see the next comment).\n\n# Based on https://github.com/maratori/golangci-lint-config\n\nversion: \"2\"\n\nissues:\n  # Maximum count of issues with the same text.\n  # Set to 0 to disable.\n  # Default: 3\n  max-same-issues: 50\n\nformatters:\n  enable:\n    - goimports # checks if the code and import statements are formatted according to the 'goimports' command\n    - golines # checks if code is formatted, and fixes long lines\n\n    ## you may want to enable\n    #- gci # checks if code and import statements are formatted, with additional rules\n    #- gofmt # checks if the code is formatted according to 'gofmt' command\n    #- gofumpt # enforces a stricter format than 'gofmt', while being backwards compatible\n    #- swaggo # formats swaggo comments\n\n  # All settings can be found here https://github.com/golangci/golangci-lint/blob/HEAD/.golangci.reference.yml\n  settings:\n    goimports:\n      # A list of prefixes, which, if set, checks import paths\n      # with the given prefixes are grouped after 3rd-party packages.\n      # Default: []\n      local-prefixes:\n        - github.com/my/project\n\n    golines:\n      # Target maximum line length.\n      # Default: 100\n      max-len: 120\n\nlinters:\n  enable:\n    - asasalint # checks for pass []any as any in variadic func(...any)\n    - asciicheck # checks that your code does not contain non-ASCII identifiers\n    - bidichk # checks for dangerous unicode character sequences\n    - bodyclose # checks whether HTTP response body is closed successfully\n    - canonicalheader # checks whether net/http.Header uses canonical header\n    - copyloopvar # detects places where loop variables are copied (Go 1.22+)\n    - cyclop # checks function and package cyclomatic complexity\n    - depguard # checks if package imports are in a list of acceptable packages\n    - dupl # tool for code clone detection\n    - durationcheck # checks for two durations multiplied together\n    - embeddedstructfieldcheck # checks embedded types in structs\n    - errcheck # checking for unchecked errors, these unchecked errors can be critical bugs in some cases\n    - errname # checks that sentinel errors are prefixed with the Err and error types are suffixed with the Error\n    - errorlint # finds code that will cause problems with the error wrapping scheme introduced in Go 1.13\n    - exhaustive # checks exhaustiveness of enum switch statements\n    - exptostd # detects functions from golang.org/x/exp/ that can be replaced by std functions\n    - fatcontext # detects nested contexts in loops\n    - forbidigo # forbids identifiers\n    - funcorder # checks the order of functions, methods, and constructors\n    - funlen # tool for detection of long functions\n    - gocheckcompilerdirectives # validates go compiler directive comments (//go:)\n    - gochecknoglobals # checks that no global variables exist\n    - gochecknoinits # checks that no init functions are present in Go code\n    - gochecksumtype # checks exhaustiveness on Go \"sum types\"\n    - gocognit # computes and checks the cognitive complexity of functions\n    - goconst # finds repeated strings that could be replaced by a constant\n    - gocritic # provides diagnostics that check for bugs, performance and style issues\n    - gocyclo # computes and checks the cyclomatic complexity of functions\n    - godoclint # checks Golang's documentation practice\n    - godot # checks if comments end in a period\n    - gomoddirectives # manages the use of 'replace', 'retract', and 'excludes' directives in go.mod\n    - goprintffuncname # checks that printf-like functions are named with f at the end\n    - gosec # inspects source code for security problems\n    - govet # reports suspicious constructs, such as Printf calls whose arguments do not align with the format string\n    - iface # checks the incorrect use of interfaces, helping developers avoid interface pollution\n    - ineffassign # detects when assignments to existing variables are not used\n    - intrange # finds places where for loops could make use of an integer range\n    - iotamixing # checks if iotas are being used in const blocks with other non-iota declarations\n    - loggercheck # checks key value pairs for common logger libraries (kitlog,klog,logr,zap)\n    - makezero # finds slice declarations with non-zero initial length\n    - mirror # reports wrong mirror patterns of bytes/strings usage\n    - mnd # detects magic numbers\n    - modernize # suggests simplifications to Go code, using modern language and library features\n    - musttag # enforces field tags in (un)marshaled structs\n    - nakedret # finds naked returns in functions greater than a specified function length\n    - nestif # reports deeply nested if statements\n    - nilerr # finds the code that returns nil even if it checks that the error is not nil\n    - nilnesserr # reports that it checks for err != nil, but it returns a different nil value error (powered by nilness and nilerr)\n    - nilnil # checks that there is no simultaneous return of nil error and an invalid value\n    - noctx # finds sending http request without context.Context\n    - nolintlint # reports ill-formed or insufficient nolint directives\n    - nonamedreturns # reports all named returns\n    - nosprintfhostport # checks for misuse of Sprintf to construct a host with port in a URL\n    - perfsprint # checks that fmt.Sprintf can be replaced with a faster alternative\n    - predeclared # finds code that shadows one of Go's predeclared identifiers\n    - promlinter # checks Prometheus metrics naming via promlint\n    - protogetter # reports direct reads from proto message fields when getters should be used\n    - reassign # checks that package variables are not reassigned\n    - recvcheck # checks for receiver type consistency\n    - revive # fast, configurable, extensible, flexible, and beautiful linter for Go, drop-in replacement of golint\n    - rowserrcheck # checks whether Err of rows is checked successfully\n    - sloglint # ensure consistent code style when using log/slog\n    - spancheck # checks for mistakes with OpenTelemetry/Census spans\n    - sqlclosecheck # checks that sql.Rows and sql.Stmt are closed\n    - staticcheck # is a go vet on steroids, applying a ton of static analysis checks\n    - testableexamples # checks if examples are testable (have an expected output)\n    - testifylint # checks usage of github.com/stretchr/testify\n    - testpackage # makes you use a separate _test package\n    - tparallel # detects inappropriate usage of t.Parallel() method in your Go test codes\n    - unconvert # removes unnecessary type conversions\n    - unparam # reports unused function parameters\n    - unqueryvet # detects SELECT * in SQL queries and SQL builders, encouraging explicit column selection\n    - unused # checks for unused constants, variables, functions and types\n    - usestdlibvars # detects the possibility to use variables/constants from the Go standard library\n    - usetesting # reports uses of functions with replacement inside the testing package\n    - wastedassign # finds wasted assignment statements\n    - whitespace # detects leading and trailing whitespace\n\n    ## you may want to enable\n    #- arangolint # opinionated best practices for arangodb client\n    #- decorder # checks declaration order and count of types, constants, variables and functions\n    #- exhaustruct # [highly recommend to enable] checks if all structure fields are initialized\n    #- ginkgolinter # [if you use ginkgo/gomega] enforces standards of using ginkgo and gomega\n    #- godox # detects usage of FIXME, TODO and other keywords inside comments\n    #- goheader # checks is file header matches to pattern\n    #- inamedparam # [great idea, but too strict, need to ignore a lot of cases by default] reports interfaces with unnamed method parameters\n    #- interfacebloat # checks the number of methods inside an interface\n    #- ireturn # accept interfaces, return concrete types\n    #- noinlineerr # disallows inline error handling `if err := ...; err != nil {`\n    #- prealloc # [premature optimization, but can be used in some cases] finds slice declarations that could potentially be preallocated\n    #- tagalign # checks that struct tags are well aligned\n    #- varnamelen # [great idea, but too many false positives] checks that the length of a variable's name matches its scope\n    #- wrapcheck # checks that errors returned from external packages are wrapped\n    #- zerologlint # detects the wrong usage of zerolog that a user forgets to dispatch zerolog.Event\n\n    ## disabled\n    #- containedctx # detects struct contained context.Context field\n    #- contextcheck # [too many false positives] checks the function whether use a non-inherited context\n    #- dogsled # checks assignments with too many blank identifiers (e.g. x, _, _, _, := f())\n    #- dupword # [useless without config] checks for duplicate words in the source code\n    #- err113 # [too strict] checks the errors handling expressions\n    #- errchkjson # [don't see profit + I'm against of omitting errors like in the first example https://github.com/breml/errchkjson] checks types passed to the json encoding functions. Reports unsupported types and optionally reports occasions, where the check for the returned error can be omitted\n    #- forcetypeassert # [replaced by errcheck] finds forced type assertions\n    #- gomodguard # [use more powerful depguard] allow and block lists linter for direct Go module dependencies\n    #- gosmopolitan # reports certain i18n/l10n anti-patterns in your Go codebase\n    #- grouper # analyzes expression groups\n    #- importas # enforces consistent import aliases\n    #- lll # [replaced by golines] reports long lines\n    #- maintidx # measures the maintainability index of each function\n    #- misspell # [useless] finds commonly misspelled English words in comments\n    #- nlreturn # [too strict and mostly code is not more readable] checks for a new line before return and branch statements to increase code clarity\n    #- paralleltest # [too many false positives] detects missing usage of t.Parallel() method in your Go test\n    #- tagliatelle # checks the struct tags\n    #- thelper # detects golang test helpers without t.Helper() call and checks the consistency of test helpers\n    #- wsl # [too strict and mostly code is not more readable] whitespace linter forces you to use empty lines\n    #- wsl_v5 # [too strict and mostly code is not more readable] add or remove empty lines\n\n  # All settings can be found here https://github.com/golangci/golangci-lint/blob/HEAD/.golangci.reference.yml\n  settings:\n    cyclop:\n      # The maximal code complexity to report.\n      # Default: 10\n      max-complexity: 30\n      # The maximal average package complexity.\n      # If it's higher than 0.0 (float) the check is enabled.\n      # Default: 0.0\n      package-average: 10.0\n\n    depguard:\n      # Rules to apply.\n      #\n      # Variables:\n      # - File Variables\n      #   Use an exclamation mark `!` to negate a variable.\n      #   Example: `!$test` matches any file that is not a go test file.\n      #\n      #   `$all` - matches all go files\n      #   `$test` - matches all go test files\n      #\n      # - Package Variables\n      #\n      #   `$gostd` - matches all of go's standard library (Pulled from `GOROOT`)\n      #\n      # Default (applies if no custom rules are defined): Only allow $gostd in all files.\n      rules:\n        \"deprecated\":\n          # List of file globs that will match this list of settings to compare against.\n          # By default, if a path is relative, it is relative to the directory where the golangci-lint command is executed.\n          # The placeholder '${base-path}' is substituted with a path relative to the mode defined with `run.relative-path-mode`.\n          # The placeholder '${config-path}' is substituted with a path relative to the configuration file.\n          # Default: $all\n          files:\n            - \"$all\"\n          # List of packages that are not allowed.\n          # Entries can be a variable (starting with $), a string prefix, or an exact match (if ending with $).\n          # Default: []\n          deny:\n            - pkg: github.com/golang/protobuf\n              desc: Use google.golang.org/protobuf instead, see https://developers.google.com/protocol-buffers/docs/reference/go/faq#modules\n            - pkg: github.com/satori/go.uuid\n              desc: Use github.com/google/uuid instead, satori's package is not maintained\n            - pkg: github.com/gofrs/uuid$\n              desc: Use github.com/gofrs/uuid/v5 or later, it was not a go module before v5\n        \"non-test files\":\n          files:\n            - \"!$test\"\n          deny:\n            - pkg: math/rand$\n              desc: Use math/rand/v2 instead, see https://go.dev/blog/randv2\n        \"non-main files\":\n          files:\n            - \"!**/main.go\"\n          deny:\n            - pkg: log$\n              desc: Use log/slog instead, see https://go.dev/blog/slog\n\n    embeddedstructfieldcheck:\n      # Checks that sync.Mutex and sync.RWMutex are not used as embedded fields.\n      # Default: false\n      forbid-mutex: true\n\n    errcheck:\n      # Report about not checking of errors in type assertions: `a := b.(MyStruct)`.\n      # Such cases aren't reported by default.\n      # Default: false\n      check-type-assertions: true\n\n    exhaustive:\n      # Program elements to check for exhaustiveness.\n      # Default: [ switch ]\n      check:\n        - switch\n        - map\n\n    exhaustruct:\n      # List of regular expressions to match type names that should be excluded from processing.\n      # Anonymous structs can be matched by '<anonymous>' alias.\n      # Has precedence over `include`.\n      # Each regular expression must match the full type name, including package path.\n      # For example, to match type `net/http.Cookie` regular expression should be `.*/http\\.Cookie`,\n      # but not `http\\.Cookie`.\n      # Default: []\n      exclude:\n        # std libs\n        - ^net/http.Client$\n        - ^net/http.Cookie$\n        - ^net/http.Request$\n        - ^net/http.Response$\n        - ^net/http.Server$\n        - ^net/http.Transport$\n        - ^net/url.URL$\n        - ^os/exec.Cmd$\n        - ^reflect.StructField$\n        # public libs\n        - ^github.com/Shopify/sarama.Config$\n        - ^github.com/Shopify/sarama.ProducerMessage$\n        - ^github.com/mitchellh/mapstructure.DecoderConfig$\n        - ^github.com/prometheus/client_golang/.+Opts$\n        - ^github.com/spf13/cobra.Command$\n        - ^github.com/spf13/cobra.CompletionOptions$\n        - ^github.com/stretchr/testify/mock.Mock$\n        - ^github.com/testcontainers/testcontainers-go.+Request$\n        - ^github.com/testcontainers/testcontainers-go.FromDockerfile$\n        - ^golang.org/x/tools/go/analysis.Analyzer$\n        - ^google.golang.org/protobuf/.+Options$\n        - ^gopkg.in/yaml.v3.Node$\n      # Allows empty structures in return statements.\n      # Default: false\n      allow-empty-returns: true\n\n    funcorder:\n      # Checks if the exported methods of a structure are placed before the non-exported ones.\n      # Default: true\n      struct-method: false\n\n    funlen:\n      # Checks the number of lines in a function.\n      # If lower than 0, disable the check.\n      # Default: 60\n      lines: 100\n      # Checks the number of statements in a function.\n      # If lower than 0, disable the check.\n      # Default: 40\n      statements: 50\n\n    gochecksumtype:\n      # Presence of `default` case in switch statements satisfies exhaustiveness, if all members are not listed.\n      # Default: true\n      default-signifies-exhaustive: false\n\n    gocognit:\n      # Minimal code complexity to report.\n      # Default: 30 (but we recommend 10-20)\n      min-complexity: 20\n\n    gocritic:\n      # Settings passed to gocritic.\n      # The settings key is the name of a supported gocritic checker.\n      # The list of supported checkers can be found at https://go-critic.com/overview.\n      settings:\n        captLocal:\n          # Whether to restrict checker to params only.\n          # Default: true\n          paramsOnly: false\n        underef:\n          # Whether to skip (*x).method() calls where x is a pointer receiver.\n          # Default: true\n          skipRecvDeref: false\n\n    godoclint:\n      # List of rules to enable in addition to the default set.\n      # Default: empty\n      enable:\n        # Assert no unused link in godocs.\n        # https://github.com/godoc-lint/godoc-lint?tab=readme-ov-file#no-unused-link\n        - no-unused-link\n\n    govet:\n      # Enable all analyzers.\n      # Default: false\n      enable-all: true\n      # Disable analyzers by name.\n      # Run `GL_DEBUG=govet golangci-lint run --enable=govet` to see default, all available analyzers, and enabled analyzers.\n      # Default: []\n      disable:\n        - fieldalignment # too strict\n      # Settings per analyzer.\n      settings:\n        shadow:\n          # Whether to be strict about shadowing; can be noisy.\n          # Default: false\n          strict: true\n\n    inamedparam:\n      # Skips check for interface methods with only a single parameter.\n      # Default: false\n      skip-single-param: true\n\n    mnd:\n      # List of function patterns to exclude from analysis.\n      # Values always ignored: `time.Date`,\n      # `strconv.FormatInt`, `strconv.FormatUint`, `strconv.FormatFloat`,\n      # `strconv.ParseInt`, `strconv.ParseUint`, `strconv.ParseFloat`.\n      # Default: []\n      ignored-functions:\n        - args.Error\n        - flag.Arg\n        - flag.Duration.*\n        - flag.Float.*\n        - flag.Int.*\n        - flag.Uint.*\n        - os.Chmod\n        - os.Mkdir.*\n        - os.OpenFile\n        - os.WriteFile\n        - prometheus.ExponentialBuckets.*\n        - prometheus.LinearBuckets\n\n    nakedret:\n      # Make an issue if func has more lines of code than this setting, and it has naked returns.\n      # Default: 30\n      max-func-lines: 0\n\n    nolintlint:\n      # Exclude following linters from requiring an explanation.\n      # Default: []\n      allow-no-explanation: [ funlen, gocognit, golines ]\n      # Enable to require an explanation of nonzero length after each nolint directive.\n      # Default: false\n      require-explanation: true\n      # Enable to require nolint directives to mention the specific linter being suppressed.\n      # Default: false\n      require-specific: true\n\n    perfsprint:\n      # Optimizes into strings concatenation.\n      # Default: true\n      strconcat: false\n\n    reassign:\n      # Patterns for global variable names that are checked for reassignment.\n      # See https://github.com/curioswitch/go-reassign#usage\n      # Default: [\"EOF\", \"Err.*\"]\n      patterns:\n        - \".*\"\n\n    rowserrcheck:\n      # database/sql is always checked.\n      # Default: []\n      packages:\n        - github.com/jmoiron/sqlx\n\n    sloglint:\n      # Enforce not using global loggers.\n      # Values:\n      # - \"\": disabled\n      # - \"all\": report all global loggers\n      # - \"default\": report only the default slog logger\n      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#no-global\n      # Default: \"\"\n      no-global: all\n      # Enforce using methods that accept a context.\n      # Values:\n      # - \"\": disabled\n      # - \"all\": report all contextless calls\n      # - \"scope\": report only if a context exists in the scope of the outermost function\n      # https://github.com/go-simpler/sloglint?tab=readme-ov-file#context-only\n      # Default: \"\"\n      context: scope\n\n    staticcheck:\n      # SAxxxx checks in https://staticcheck.dev/docs/configuration/options/#checks\n      # Example (to disable some checks): [ \"all\", \"-SA1000\", \"-SA1001\"]\n      # Default: [\"all\", \"-ST1000\", \"-ST1003\", \"-ST1016\", \"-ST1020\", \"-ST1021\", \"-ST1022\"]\n      checks:\n        - all\n        # Incorrect or missing package comment.\n        # https://staticcheck.dev/docs/checks/#ST1000\n        - -ST1000\n        # Use consistent method receiver names.\n        # https://staticcheck.dev/docs/checks/#ST1016\n        - -ST1016\n        # Omit embedded fields from selector expression.\n        # https://staticcheck.dev/docs/checks/#QF1008\n        - -QF1008\n\n    usetesting:\n      # Enable/disable `os.TempDir()` detections.\n      # Default: false\n      os-temp-dir: true\n\n  exclusions:\n    # Log a warning if an exclusion rule is unused.\n    # Default: false\n    warn-unused: true\n    # Predefined exclusion rules.\n    # Default: []\n    presets:\n      - std-error-handling\n      - common-false-positives\n    # Excluding configuration per-path, per-linter, per-text and per-source.\n    rules:\n      - source: 'TODO'\n        linters: [ godot ]\n      - text: 'should have a package comment'\n        linters: [ revive ]\n      - text: 'exported \\S+ \\S+ should have comment( \\(or a comment on this block\\))? or be unexported'\n        linters: [ revive ]\n      - text: 'package comment should be of the form \".+\"'\n        source: '// ?(nolint|TODO)'\n        linters: [ revive ]\n      - text: 'comment on exported \\S+ \\S+ should be of the form \".+\"'\n        source: '// ?(nolint|TODO)'\n        linters: [ revive, staticcheck ]\n      - path: '_test\\.go'\n        linters:\n          - bodyclose\n          - dupl\n          - errcheck\n          - funlen\n          - goconst\n          - gosec\n          - noctx\n          - wrapcheck\n```\n"}, {"path": "linters/golangci-lint/importas.md", "category": "linters", "name": "linters/golangci-lint/importas", "content": "# importas\n\nSee: https://golangci-lint.run/docs/linters/importas/\n"}, {"path": "linters/golangci-lint/asciicheck.md", "category": "linters", "name": "linters/golangci-lint/asciicheck", "content": "# asciicheck\n\nSee: https://golangci-lint.run/docs/linters/asciicheck/\n"}, {"path": "linters/golangci-lint/reassign.md", "category": "linters", "name": "linters/golangci-lint/reassign", "content": "# reassign\n\nSee: https://golangci-lint.run/docs/linters/reassign/\n"}, {"path": "linters/golangci-lint/mirror.md", "category": "linters", "name": "linters/golangci-lint/mirror", "content": "# mirror\n\nSee: https://golangci-lint.run/docs/linters/mirror/\n"}, {"path": "linters/golangci-lint/unconvert.md", "category": "linters", "name": "linters/golangci-lint/unconvert", "content": "# unconvert\n\nSee: https://golangci-lint.run/docs/linters/unconvert/\n"}, {"path": "linters/golangci-lint/asasalint.md", "category": "linters", "name": "linters/golangci-lint/asasalint", "content": "# asasalint\n\nSee: https://golangci-lint.run/docs/linters/asasalint/\n"}, {"path": "linters/golangci-lint/funcorder.md", "category": "linters", "name": "linters/golangci-lint/funcorder", "content": "# funcorder\n\nSee: https://golangci-lint.run/docs/linters/funcorder/\n"}, {"path": "linters/golangci-lint/revive.md", "category": "linters", "name": "linters/golangci-lint/revive", "content": "# revive\n\nSee: https://golangci-lint.run/docs/linters/revive/\n"}, {"path": "linters/golangci-lint/thelper.md", "category": "linters", "name": "linters/golangci-lint/thelper", "content": "# thelper\n\nSee: https://golangci-lint.run/docs/linters/thelper/\n"}, {"path": "linters/golangci-lint/nilerr.md", "category": "linters", "name": "linters/golangci-lint/nilerr", "content": "# nilerr\n\nSee: https://golangci-lint.run/docs/linters/nilerr/\n"}, {"path": "linters/golangci-lint/godot.md", "category": "linters", "name": "linters/golangci-lint/godot", "content": "# godot\n\nSee: https://golangci-lint.run/docs/linters/godot/\n"}, {"path": "linters/golangci-lint/contextcheck.md", "category": "linters", "name": "linters/golangci-lint/contextcheck", "content": "# contextcheck\n\nSee: https://golangci-lint.run/docs/linters/contextcheck/\n"}, {"path": "linters/golangci-lint/tagalign.md", "category": "linters", "name": "linters/golangci-lint/tagalign", "content": "# tagalign\n\nSee: https://golangci-lint.run/docs/linters/tagalign/\n"}, {"path": "linters/golangci-lint/musttag.md", "category": "linters", "name": "linters/golangci-lint/musttag", "content": "# musttag\n\nSee: https://golangci-lint.run/docs/linters/musttag/\n"}, {"path": "linters/golangci-lint/err113.md", "category": "linters", "name": "linters/golangci-lint/err113", "content": "# err113\n\nSee: https://golangci-lint.run/docs/linters/err113/\n"}, {"path": "linters/golangci-lint/wrapcheck.md", "category": "linters", "name": "linters/golangci-lint/wrapcheck", "content": "# wrapcheck\n\nSee: https://golangci-lint.run/docs/linters/wrapcheck/\n"}, {"path": "linters/golangci-lint/testifylint.md", "category": "linters", "name": "linters/golangci-lint/testifylint", "content": "# testifylint\n\nSee: https://golangci-lint.run/docs/linters/testifylint/\n"}, {"path": "linters/golangci-lint/containedctx.md", "category": "linters", "name": "linters/golangci-lint/containedctx", "content": "# containedctx\n\nSee: https://golangci-lint.run/docs/linters/containedctx/\n"}, {"path": "linters/golangci-lint/wastedassign.md", "category": "linters", "name": "linters/golangci-lint/wastedassign", "content": "# wastedassign\n\nSee: https://golangci-lint.run/docs/linters/wastedassign/\n"}, {"path": "linters/golangci-lint/sloglint.md", "category": "linters", "name": "linters/golangci-lint/sloglint", "content": "# sloglint\n\nSee: https://golangci-lint.run/docs/linters/sloglint/\n"}, {"path": "linters/golangci-lint/tagliatelle.md", "category": "linters", "name": "linters/golangci-lint/tagliatelle", "content": "# tagliatelle\n\nSee: https://golangci-lint.run/docs/linters/tagliatelle/\n"}, {"path": "linters/golangci-lint/maintidx.md", "category": "linters", "name": "linters/golangci-lint/maintidx", "content": "# maintidx\n\nSee: https://golangci-lint.run/docs/linters/maintidx/\n"}, {"path": "linters/golangci-lint/testpackage.md", "category": "linters", "name": "linters/golangci-lint/testpackage", "content": "# testpackage\n\nSee: https://golangci-lint.run/docs/linters/testpackage/\n"}, {"path": "linters/golangci-lint/nlreturn.md", "category": "linters", "name": "linters/golangci-lint/nlreturn", "content": "# nlreturn\n\nSee: https://golangci-lint.run/docs/linters/nlreturn/\n"}, {"path": "linters/golangci-lint/gosec.md", "category": "linters", "name": "linters/golangci-lint/gosec", "content": "# gosec\n\nSee: https://golangci-lint.run/docs/linters/gosec/\n"}, {"path": "linters/golangci-lint/loggercheck.md", "category": "linters", "name": "linters/golangci-lint/loggercheck", "content": "# loggercheck\n\nSee: https://golangci-lint.run/docs/linters/loggercheck/\n"}, {"path": "linters/golangci-lint/spancheck.md", "category": "linters", "name": "linters/golangci-lint/spancheck", "content": "# spancheck\n\nSee: https://golangci-lint.run/docs/linters/spancheck/\n"}, {"path": "linters/golangci-lint/tparallel.md", "category": "linters", "name": "linters/golangci-lint/tparallel", "content": "# tparallel\n\nSee: https://golangci-lint.run/docs/linters/tparallel/\n"}, {"path": "linters/golangci-lint/exhaustruct.md", "category": "linters", "name": "linters/golangci-lint/exhaustruct", "content": "# exhaustruct\n\nSee: https://golangci-lint.run/docs/linters/exhaustruct/\n"}, {"path": "linters/golangci-lint/errorlint.md", "category": "linters", "name": "linters/golangci-lint/errorlint", "content": "# errorlint\n\nSee: https://golangci-lint.run/docs/linters/errorlint/\n"}, {"path": "linters/golangci-lint/goconst.md", "category": "linters", "name": "linters/golangci-lint/goconst", "content": "# goconst\n\nSee: https://golangci-lint.run/docs/linters/goconst/\n"}, {"path": "linters/golangci-lint/wsl_v5.md", "category": "linters", "name": "linters/golangci-lint/wsl_v5", "content": "# wsl_v5\n\nSee: https://golangci-lint.run/docs/linters/wsl_v5/\n"}, {"path": "linters/golangci-lint/prealloc.md", "category": "linters", "name": "linters/golangci-lint/prealloc", "content": "# prealloc\n\nSee: https://golangci-lint.run/docs/linters/prealloc/\n"}, {"path": "linters/golangci-lint/gocritic.md", "category": "linters", "name": "linters/golangci-lint/gocritic", "content": "# gocritic\n\nSee: https://golangci-lint.run/docs/linters/gocritic/\n"}, {"path": "linters/golangci-lint/nilnil.md", "category": "linters", "name": "linters/golangci-lint/nilnil", "content": "# nilnil\n\nSee: https://golangci-lint.run/docs/linters/nilnil/\n"}, {"path": "linters/golangci-lint/dupl.md", "category": "linters", "name": "linters/golangci-lint/dupl", "content": "# dupl\n\nSee: https://golangci-lint.run/docs/linters/dupl/\n"}, {"path": "linters/golangci-lint/wsl.md", "category": "linters", "name": "linters/golangci-lint/wsl", "content": "# wsl\n\nSee: https://golangci-lint.run/docs/linters/wsl/\n"}, {"path": "linters/golangci-lint/zerologlint.md", "category": "linters", "name": "linters/golangci-lint/zerologlint", "content": "# zerologlint\n\nSee: https://golangci-lint.run/docs/linters/zerologlint/\n"}, {"path": "linters/golangci-lint/embeddedstructfieldcheck.md", "category": "linters", "name": "linters/golangci-lint/embeddedstructfieldcheck", "content": "# embeddedstructfieldcheck\n\nSee: https://golangci-lint.run/docs/linters/embeddedstructfieldcheck/\n"}, {"path": "linters/golangci-lint/nosprintfhostport.md", "category": "linters", "name": "linters/golangci-lint/nosprintfhostport", "content": "# nosprintfhostport\n\nSee: https://golangci-lint.run/docs/linters/nosprintfhostport/\n"}, {"path": "linters/golangci-lint/ineffassign.md", "category": "linters", "name": "linters/golangci-lint/ineffassign", "content": "# ineffassign\n\nSee: https://golangci-lint.run/docs/linters/ineffassign/\n"}, {"path": "linters/golangci-lint/iface.md", "category": "linters", "name": "linters/golangci-lint/iface", "content": "# iface\n\nSee: https://golangci-lint.run/docs/linters/iface/\n"}, {"path": "linters/golangci-lint/lll.md", "category": "linters", "name": "linters/golangci-lint/lll", "content": "# lll\n\nSee: https://golangci-lint.run/docs/linters/lll/\n"}, {"path": "linters/golangci-lint/makezero.md", "category": "linters", "name": "linters/golangci-lint/makezero", "content": "# makezero\n\nSee: https://golangci-lint.run/docs/linters/makezero/\n"}, {"path": "linters/golangci-lint/dupword.md", "category": "linters", "name": "linters/golangci-lint/dupword", "content": "# dupword\n\nSee: https://golangci-lint.run/docs/linters/dupword/\n"}]}
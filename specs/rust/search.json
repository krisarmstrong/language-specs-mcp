{"language": "rust", "generatedAt": "2026-01-06T18:23:22.376741+00:00", "entries": [{"path": "generation-checklist.md", "category": "spec", "name": "generation-checklist", "content": "# Rust Generation Checklist\n\n**Read this BEFORE writing Rust code. The compiler catches a lot, but these patterns matter.**\n\n## Critical: You Must Do These\n\n### 1. Use `?` for Error Propagation\n```rust\n// BAD - verbose\nlet file = match File::open(path) {\n    Ok(f) => f,\n    Err(e) => return Err(e),\n};\n\n// GOOD - idiomatic\nlet file = File::open(path)?;\n```\n\n### 2. Prefer `&str` Over `String` in Function Parameters\n```rust\n// BAD - forces allocation\nfn greet(name: String) { }\n\n// GOOD - accepts both String and &str\nfn greet(name: &str) { }\n```\n\n### 3. Use `impl Trait` for Return Types When Appropriate\n```rust\n// GOOD - hides concrete type, flexible\nfn make_iter() -> impl Iterator<Item = i32> {\n    (0..10).filter(|x| x % 2 == 0)\n}\n```\n\n### 4. Derive Common Traits\n```rust\n// GOOD - derive what you need\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\nstruct User {\n    id: u64,\n    name: String,\n}\n```\n\n### 5. Use `Option` and `Result`, Not Sentinel Values\n```rust\n// BAD - sentinel value\nfn find_index(items: &[i32], target: i32) -> i32 {\n    // returns -1 if not found\n}\n\n// GOOD - explicit optionality\nfn find_index(items: &[i32], target: i32) -> Option<usize> {\n    items.iter().position(|&x| x == target)\n}\n```\n\n## Important: Strong Recommendations\n\n### 6. Use `if let` and `while let` for Single-Pattern Matching\n```rust\n// BAD - verbose for single pattern\nmatch optional_value {\n    Some(v) => println!(\"{}\", v),\n    None => {}\n}\n\n// GOOD - concise\nif let Some(v) = optional_value {\n    println!(\"{}\", v);\n}\n```\n\n### 7. Prefer Iterators Over Index Loops\n```rust\n// BAD - C-style loop\nfor i in 0..items.len() {\n    process(items[i]);\n}\n\n// GOOD - iterator\nfor item in &items {\n    process(item);\n}\n\n// GOOD - with index if needed\nfor (i, item) in items.iter().enumerate() {\n    process(i, item);\n}\n```\n\n### 8. Use `collect()` with Type Annotation\n```rust\n// GOOD - explicit collection type\nlet names: Vec<String> = users.iter().map(|u| u.name.clone()).collect();\n\n// Also GOOD - turbofish\nlet names = users.iter().map(|u| u.name.clone()).collect::<Vec<_>>();\n```\n\n### 9. Use `Default` Trait for Struct Initialization\n```rust\n#[derive(Default)]\nstruct Config {\n    timeout: u64,\n    retries: u32,\n}\n\n// GOOD - partial initialization\nlet config = Config {\n    timeout: 30,\n    ..Default::default()\n};\n```\n\n### 10. Clone Sparingly, Borrow When Possible\n```rust\n// BAD - unnecessary clone\nfn process(data: Vec<u8>) {\n    let copy = data.clone();  // Why?\n}\n\n// GOOD - borrow if you don't need ownership\nfn process(data: &[u8]) { }\n```\n\n## Ownership & Lifetimes\n\n### 11. Use References for Read-Only Access\n```rust\n// BAD - takes ownership unnecessarily\nfn print_length(s: String) {\n    println!(\"{}\", s.len());\n}\n\n// GOOD - borrows\nfn print_length(s: &str) {\n    println!(\"{}\", s.len());\n}\n```\n\n### 12. Use `Cow` for Optional Ownership\n```rust\nuse std::borrow::Cow;\n\n// GOOD - avoids allocation when not needed\nfn process(input: &str) -> Cow<str> {\n    if needs_modification(input) {\n        Cow::Owned(modify(input))\n    } else {\n        Cow::Borrowed(input)\n    }\n}\n```\n\n### 13. Avoid Lifetime Annotations When Elision Works\n```rust\n// Lifetime elision handles this - don't add annotations\nfn first_word(s: &str) -> &str { }\n\n// Only add when compiler requires it\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str { }\n```\n\n## Error Handling\n\n### 14. Use `thiserror` for Library Errors\n```rust\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum DataError {\n    #[error(\"invalid format: {0}\")]\n    InvalidFormat(String),\n    #[error(\"io error\")]\n    Io(#[from] std::io::Error),\n}\n```\n\n### 15. Use `anyhow` for Application Errors\n```rust\nuse anyhow::{Context, Result};\n\nfn read_config() -> Result<Config> {\n    let content = std::fs::read_to_string(\"config.toml\")\n        .context(\"failed to read config file\")?;\n    toml::from_str(&content)\n        .context(\"failed to parse config\")\n}\n```\n\n## Safety & Performance\n\n### 16. Avoid `unwrap()` in Production Code\n```rust\n// BAD - panics on None/Err\nlet value = map.get(\"key\").unwrap();\n\n// GOOD - handle the case\nlet value = map.get(\"key\").ok_or_else(|| anyhow!(\"key not found\"))?;\n\n// GOOD - provide default\nlet value = map.get(\"key\").unwrap_or(&default);\n```\n\n### 17. Use `#[must_use]` for Important Return Values\n```rust\n#[must_use]\nfn validate(input: &str) -> bool {\n    // Caller must check the return value\n}\n```\n\n### 18. Prefer `Vec::with_capacity` When Size Is Known\n```rust\n// BAD - multiple reallocations\nlet mut items = Vec::new();\nfor i in 0..1000 {\n    items.push(i);\n}\n\n// GOOD - single allocation\nlet mut items = Vec::with_capacity(1000);\nfor i in 0..1000 {\n    items.push(i);\n}\n```\n\n---\n\n**Quick Reference - Copy This Mental Model:**\n- Use `?` for error propagation\n- `&str` params, `String` when ownership needed\n- Derive Debug, Clone, PartialEq at minimum\n- `Option`/`Result` not sentinels\n- `if let` for single patterns\n- Iterators over index loops\n- Borrow don't clone when possible\n- `thiserror` for libs, `anyhow` for apps\n- No `unwrap()` in production\n- Pre-allocate when size known\n"}, {"path": "patterns/idioms.md", "category": "patterns", "name": "patterns/idioms", "content": "# Rust Idioms\n\n## Prefer iterators over indexing\n\n```rust\nfor item in items.iter() {\n    // ...\n}\n```\n\n## Use `Result` and `?` for error propagation\n\n```rust\nlet data = read_to_string(path)?;\n```\n\n## Favor borrowing over cloning\n"}, {"path": "patterns/anti-patterns.md", "category": "patterns", "name": "patterns/anti-patterns", "content": "# Rust Anti-Patterns\n\nCommon mistakes and code smells to avoid in Rust code.\n\n## Overusing .unwrap() and .expect()\n\n```rust\n// BAD - Panics on None/Err\nlet value = some_option.unwrap();\nlet result = fallible_operation().unwrap();\n\n// GOOD - Handle the error\nlet value = some_option.ok_or(MyError::NotFound)?;\nlet result = fallible_operation()?;\n\n// GOOD - Provide context with expect in main/tests only\nlet config = load_config().expect(\"Failed to load config file\");\n```\n\n## Clone to Satisfy Borrow Checker\n\n```rust\n// BAD - Unnecessary clone to avoid borrow issues\nfn process(data: &Vec<String>) {\n    let cloned = data.clone();  // Expensive!\n    for item in cloned {\n        println!(\"{}\", item);\n    }\n}\n\n// GOOD - Work with references\nfn process(data: &[String]) {\n    for item in data {\n        println!(\"{}\", item);\n    }\n}\n```\n\n## Using String When &str Suffices\n\n```rust\n// BAD - Requires allocation\nfn greet(name: String) {\n    println!(\"Hello, {}\", name);\n}\ngreet(\"World\".to_string());  // Unnecessary allocation\n\n// GOOD - Accept reference\nfn greet(name: &str) {\n    println!(\"Hello, {}\", name);\n}\ngreet(\"World\");  // No allocation\n```\n\n## Ignoring Clippy Warnings\n\n```rust\n// BAD - Clippy warns about this\nif vec.len() > 0 { }\n\n// GOOD - Idiomatic\nif !vec.is_empty() { }\n\n// BAD - Manual implementation exists in std\nlet sum: i32 = vec.iter().fold(0, |acc, x| acc + x);\n\n// GOOD - Use built-in\nlet sum: i32 = vec.iter().sum();\n```\n\n## Using Vec When Slice Works\n\n```rust\n// BAD - Requires owned Vec\nfn sum(numbers: Vec<i32>) -> i32 {\n    numbers.iter().sum()\n}\n\n// GOOD - Accept slice, more flexible\nfn sum(numbers: &[i32]) -> i32 {\n    numbers.iter().sum()\n}\n\n// Can call with Vec, array, or slice\nsum(&vec![1, 2, 3]);\nsum(&[1, 2, 3]);\n```\n\n## Not Using Entry API for Maps\n\n```rust\nuse std::collections::HashMap;\n\n// BAD - Double lookup\nlet mut map: HashMap<String, i32> = HashMap::new();\nif !map.contains_key(\"key\") {\n    map.insert(\"key\".to_string(), 0);\n}\n*map.get_mut(\"key\").unwrap() += 1;\n\n// GOOD - Single lookup with entry API\n*map.entry(\"key\".to_string()).or_insert(0) += 1;\n```\n\n## Blocking in Async Code\n\n```rust\n// BAD - Blocks the async runtime\nasync fn read_file(path: &str) -> String {\n    std::fs::read_to_string(path).unwrap()  // Blocking!\n}\n\n// GOOD - Use async file operations\nasync fn read_file(path: &str) -> std::io::Result<String> {\n    tokio::fs::read_to_string(path).await\n}\n\n// OR spawn blocking task\nasync fn read_file(path: &str) -> std::io::Result<String> {\n    let path = path.to_string();\n    tokio::task::spawn_blocking(move || {\n        std::fs::read_to_string(path)\n    }).await?\n}\n```\n\n## Mutex Poisoning Panic\n\n```rust\nuse std::sync::Mutex;\n\n// BAD - Panics if mutex was poisoned\nlet data = mutex.lock().unwrap();\n\n// GOOD - Handle poisoning\nlet data = mutex.lock().unwrap_or_else(|poisoned| {\n    poisoned.into_inner()\n});\n\n// OR use parking_lot which doesn't poison\nuse parking_lot::Mutex;\nlet data = mutex.lock();  // Never panics from poisoning\n```\n\n## Creating References to Packed Fields\n\n```rust\n// BAD - Undefined behavior\n#[repr(packed)]\nstruct Packed {\n    a: u8,\n    b: u32,\n}\n\nlet p = Packed { a: 1, b: 2 };\nlet r = &p.b;  // UB! Unaligned reference\n\n// GOOD - Copy the value\nlet b = { p.b };  // Copy, then use\n```\n\n## Using mem::forget to Prevent Drop\n\n```rust\nuse std::mem;\n\n// BAD - Resource leak, not drop-safe\nlet file = File::open(\"data.txt\")?;\nmem::forget(file);  // File handle leaked!\n\n// GOOD - Use ManuallyDrop for explicit control\nuse std::mem::ManuallyDrop;\nlet file = ManuallyDrop::new(File::open(\"data.txt\")?);\n// Explicitly drop when ready\nManuallyDrop::into_inner(file);\n```\n\n## Returning References to Local Variables\n\n```rust\n// BAD - Won't compile, but shows the intent\nfn get_string() -> &str {\n    let s = String::from(\"hello\");\n    &s  // Error: returns reference to local\n}\n\n// GOOD - Return owned value\nfn get_string() -> String {\n    String::from(\"hello\")\n}\n\n// OR use 'static lifetime for constants\nfn get_string() -> &'static str {\n    \"hello\"\n}\n```\n\n## Unneeded Collect Into Vec\n\n```rust\n// BAD - Allocates intermediate Vec\nlet doubled: i32 = vec![1, 2, 3]\n    .iter()\n    .map(|x| x * 2)\n    .collect::<Vec<_>>()  // Unnecessary!\n    .iter()\n    .sum();\n\n// GOOD - Chain iterators directly\nlet doubled: i32 = vec![1, 2, 3]\n    .iter()\n    .map(|x| x * 2)\n    .sum();\n```\n\n## Large Structs on Stack\n\n```rust\n// BAD - Large array on stack\nstruct BigData {\n    buffer: [u8; 10_000_000],  // 10MB on stack!\n}\n\nlet data = BigData { buffer: [0; 10_000_000] };  // Stack overflow risk\n\n// GOOD - Use Box for heap allocation\nstruct BigData {\n    buffer: Box<[u8]>,\n}\n\nlet data = BigData {\n    buffer: vec![0u8; 10_000_000].into_boxed_slice(),\n};\n```\n\n## Not Using derive When Appropriate\n\n```rust\n// BAD - Manual implementations\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Clone for Point {\n    fn clone(&self) -> Self {\n        Point { x: self.x, y: self.y }\n    }\n}\n\nimpl PartialEq for Point {\n    fn eq(&self, other: &Self) -> bool {\n        self.x == other.x && self.y == other.y\n    }\n}\n\n// GOOD - Use derive\n#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n```\n\n## Using String for Errors\n\n```rust\n// BAD - Loses error context\nfn read_config() -> Result<Config, String> {\n    let content = std::fs::read_to_string(\"config.toml\")\n        .map_err(|e| e.to_string())?;\n    // ...\n}\n\n// GOOD - Use proper error types\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\nenum ConfigError {\n    #[error(\"failed to read config file: {0}\")]\n    Io(#[from] std::io::Error),\n    #[error(\"invalid config format: {0}\")]\n    Parse(#[from] toml::de::Error),\n}\n\nfn read_config() -> Result<Config, ConfigError> {\n    let content = std::fs::read_to_string(\"config.toml\")?;\n    // ...\n}\n```\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# Rust Formatters\n\n## rustfmt\n\nSee: https://github.com/rust-lang/rustfmt\n"}, {"path": "formatters/rustfmt.md", "category": "formatters", "name": "formatters/rustfmt", "content": "[rust-lang](/rust-lang)/[rustfmt](/rust-lang/rustfmt)Public\n\n- [Notifications](/login?return_to=%2Frust-lang%2Frustfmt)You must be signed in to change notification settings\n- [Fork\n    976](/login?return_to=%2Frust-lang%2Frustfmt)\n- [Star\n          6.7k](/login?return_to=%2Frust-lang%2Frustfmt)\n\n- [Code](/rust-lang/rustfmt)\n- [Issues\n          697](/rust-lang/rustfmt/issues)\n- [Pull requests\n          207](/rust-lang/rustfmt/pulls)\n- [Discussions](/rust-lang/rustfmt/discussions)\n- [Actions](/rust-lang/rustfmt/actions)\n- [Projects\n          0](/rust-lang/rustfmt/projects)\n- [Wiki](/rust-lang/rustfmt/wiki)\n- \n\n### \n\n[Security\n          \n  \n  \n    \n  \n    \n      \n\n              Uh oh!\n\n              There was an error while loading. Please reload this page](/rust-lang/rustfmt/security).\n\n- [Insights](/rust-lang/rustfmt/pulse)\n\nAdditional navigation options\n\n- [Code](/rust-lang/rustfmt)\n- [Issues](/rust-lang/rustfmt/issues)\n- [Pull requests](/rust-lang/rustfmt/pulls)\n- [Discussions](/rust-lang/rustfmt/discussions)\n- [Actions](/rust-lang/rustfmt/actions)\n- [Projects](/rust-lang/rustfmt/projects)\n- [Wiki](/rust-lang/rustfmt/wiki)\n- [Security](/rust-lang/rustfmt/security)\n- [Insights](/rust-lang/rustfmt/pulse)\n"}, {"path": "stdlib/overview.md", "category": "stdlib", "name": "stdlib/overview", "content": "# Crate stdCopy item path\n\n1.0.0 \u00b7 [Source](../src/std/lib.rs.html#1-767)Expand description\n\n## [\u00a7](#the-rust-standard-library)The Rust Standard Library\n\nThe Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the [broader Rust\necosystem](https://crates.io). It offers core types, like [Vec<T>](vec/struct.Vec.html) and [Option<T>](option/enum.Option.html), library-defined [operations on language\nprimitives](#primitives), [standard macros](#macros), [I/O](io/index.html) and [multithreading](thread/index.html), among [many other things](#what-is-in-the-standard-library-documentation).\n\n`std` is available to all Rust crates by default. Therefore, the standard library can be accessed in [use](../book/ch07-02-defining-modules-to-control-scope-and-privacy.html) statements through the path `std`, as in [use std::env](env/index.html).\n\n## [\u00a7](#how-to-read-this-documentation)How to read this documentation\n\nIf you already know the name of what you are looking for, the fastest way to find it is to use the [search\nbutton](#) at the top of the page.\n\nOtherwise, you may want to jump to one of these useful sections:\n\n- [std::* modules](#modules)\n- [Primitive types](#primitives)\n- [Standard macros](#macros)\n- [The Rust Prelude](prelude/index.html)\n\nIf this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don\u2019t want to miss, so read on for a tour of the standard library and its documentation!\n\nOnce you are familiar with the contents of the standard library you may begin to find the verbosity of the prose distracting. At this stage in your development you may want to press the \u201c Summary\u201d button near the top of the page to collapse it into a more skimmable view.\n\nWhile you are looking at the top of the page, also notice the \u201cSource\u201d link. Rust\u2019s API documentation comes with the source code and you are encouraged to read it. The standard library source is generally high quality and a peek behind the curtains is often enlightening.\n\n## [\u00a7](#what-is-in-the-standard-library-documentation)What is in the standard library documentation?\n\nFirst of all, The Rust Standard Library is divided into a number of focused modules, [all listed further down this page](#modules). These modules are the bedrock upon which all of Rust is forged, and they have mighty names like [std::slice](slice/index.html) and [std::cmp](cmp/index.html). Modules\u2019 documentation typically includes an overview of the module along with examples, and are a smart place to start familiarizing yourself with the library.\n\nSecond, implicit methods on [primitive types](../book/ch03-02-data-types.html) are documented here. This can be a source of confusion for two reasons:\n\n1. While primitives are implemented by the compiler, the standard library implements methods directly on the primitive types (and it is the only library that does so), which are [documented in the section on\nprimitives](#primitives).\n2. The standard library exports many modules with the same name as primitive types. These define additional items related to the primitive type, but not the all-important methods.\n\nSo for example there is a [page for the primitive type\nchar](primitive.char.html) that lists all the methods that can be called on characters (very useful), and there is a [page for the module\nstd::char](char/index.html) that documents iterator and error types created by these methods (rarely useful).\n\nNote the documentation for the primitives [str](primitive.str.html) and [[T]](primitive.slice.html) (also called \u2018slice\u2019). Many method calls on [String](string/struct.String.html) and [Vec<T>](vec/struct.Vec.html) are actually calls to methods on [str](primitive.str.html) and [[T]](primitive.slice.html) respectively, via [deref\ncoercions](../book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods).\n\nThird, the standard library defines [The Rust Prelude](prelude/index.html), a small collection of items - mostly traits - that are imported into every module of every crate. The traits in the prelude are pervasive, making the prelude documentation a good entry point to learning about the library.\n\nAnd finally, the standard library exports a number of standard macros, and [lists them on this page](#macros) (technically, not all of the standard macros are defined by the standard library - some are defined by the compiler - but they are documented here the same). Like the prelude, the standard macros are imported by default into all crates.\n\n## [\u00a7](#contributing-changes-to-the-documentation)Contributing changes to the documentation\n\nCheck out the Rust contribution guidelines [here](https://rustc-dev-guide.rust-lang.org/contributing.html#writing-documentation). The source for this documentation can be found on [GitHub](https://github.com/rust-lang/rust) in the \u2018library/std/\u2019 directory. To contribute changes, make sure you read the guidelines first, then submit pull-requests for your suggested changes.\n\nContributions are appreciated! If you see a part of the docs that can be improved, submit a PR, or chat with us first on [Zulip](https://rust-lang.zulipchat.com/) #docs.\n\n## [\u00a7](#a-tour-of-the-rust-standard-library)A Tour of The Rust Standard Library\n\nThe rest of this crate documentation is dedicated to pointing out notable features of The Rust Standard Library.\n\n### [\u00a7](#containers-and-collections)Containers and collections\n\nThe [option](option/index.html) and [result](result/index.html) modules define optional and error-handling types, [Option<T>](option/enum.Option.html) and [Result<T, E>](result/enum.Result.html). The [iter](iter/index.html) module defines Rust\u2019s iterator trait, [Iterator](iter/trait.Iterator.html), which works with the [for](../book/ch03-05-control-flow.html#looping-through-a-collection-with-for) loop to access collections.\n\nThe standard library exposes three common ways to deal with contiguous regions of memory:\n\n- [Vec<T>](vec/struct.Vec.html) - A heap-allocated vector that is resizable at runtime.\n- [[T; N]](primitive.array.html) - An inline array with a fixed size at compile time.\n- [[T]](primitive.slice.html) - A dynamically sized slice into any other kind of contiguous storage, whether heap-allocated or not.\n\nSlices can only be handled through some kind of pointer, and as such come in many flavors such as:\n\n- `&[T]` - shared slice\n- `&mut [T]` - mutable slice\n- [Box<[T]>](boxed/index.html) - owned slice\n\n[str](primitive.str.html), a UTF-8 string slice, is a primitive type, and the standard library defines many methods for it. Rust [str](primitive.str.html)s are typically accessed as immutable references: `&str`. Use the owned [String](string/struct.String.html) for building and mutating strings.\n\nFor converting to strings use the [format!](macro.format.html) macro, and for converting from strings use the [FromStr](str/trait.FromStr.html) trait.\n\nData may be shared by placing it in a reference-counted box or the [Rc](rc/struct.Rc.html) type, and if further contained in a [Cell](cell/struct.Cell.html) or [RefCell](cell/struct.RefCell.html), may be mutated as well as shared. Likewise, in a concurrent setting it is common to pair an atomically-reference-counted box, [Arc](sync/struct.Arc.html), with a [Mutex](sync/struct.Mutex.html) to get the same effect.\n\nThe [collections](collections/index.html) module defines maps, sets, linked lists and other typical collection types, including the common [HashMap<K, V>](collections/struct.HashMap.html).\n\n### [\u00a7](#platform-abstractions-and-io)Platform abstractions and I/O\n\nBesides basic data types, the standard library is largely concerned with abstracting over differences in common platforms, most notably Windows and Unix derivatives.\n\nCommon types of I/O, including [files](fs/struct.File.html), [TCP](net/struct.TcpStream.html), and [UDP](net/struct.UdpSocket.html), are defined in the [io](io/index.html), [fs](fs/index.html), and [net](net/index.html) modules.\n\nThe [thread](thread/index.html) module contains Rust\u2019s threading abstractions. [sync](sync/index.html) contains further primitive shared memory types, including [atomic](sync/atomic/index.html), [mpmc](sync/mpmc/index.html) and [mpsc](sync/mpsc/index.html), which contains the channel types for message passing.\n\n## [\u00a7](#use-before-and-after-main)Use before and after `main()`\n\nMany parts of the standard library are expected to work before and after `main()`; but this is not guaranteed or ensured by tests. It is recommended that you write your own tests and run them on each platform you wish to support. This means that use of `std` before/after main, especially of features that interact with the OS or global state, is exempted from stability and portability guarantees and instead only provided on a best-effort basis. Nevertheless bug reports are appreciated.\n\nOn the other hand `core` and `alloc` are most likely to work in such environments with the caveat that any hookable behavior such as panics, oom handling or allocators will also depend on the compatibility of the hooks.\n\nSome features may also behave differently outside main, e.g. stdio could become unbuffered, some panics might turn into aborts, backtraces might not get symbolicated or similar.\n\nNon-exhaustive list of known limitations:\n\n- after-main use of thread-locals, which also affects additional features: \n\n  - [thread::current()](thread/fn.current.html)\n\n- under UNIX, before main, file descriptors 0, 1, and 2 may be unchanged (they are guaranteed to be open during main, and are opened to /dev/null O_RDWR if they weren\u2019t open on program start)\n\n## Primitive Types[\u00a7](#primitives)\n\n[array](primitive.array.html)A fixed-size array, denoted `[T; N]`, for the element type, `T`, and the non-negative compile-time constant size, `N`.[bool](primitive.bool.html)The boolean type.[char](primitive.char.html)A character type.[f32](primitive.f32.html)A 32-bit floating-point type (specifically, the \u201cbinary32\u201d type defined in IEEE 754-2008).[f64](primitive.f64.html)A 64-bit floating-point type (specifically, the \u201cbinary64\u201d type defined in IEEE 754-2008).[fn](primitive.fn.html)Function pointers, like `fn(usize) -> bool`.[i8](primitive.i8.html)The 8-bit signed integer type.[i16](primitive.i16.html)The 16-bit signed integer type.[i32](primitive.i32.html)The 32-bit signed integer type.[i64](primitive.i64.html)The 64-bit signed integer type.[i128](primitive.i128.html)The 128-bit signed integer type.[isize](primitive.isize.html)The pointer-sized signed integer type.[pointer](primitive.pointer.html)Raw, unsafe pointers, `*const T`, and `*mut T`.[reference](primitive.reference.html)References, `&T` and `&mut T`.[slice](primitive.slice.html)A dynamically-sized view into a contiguous sequence, `[T]`.[str](primitive.str.html)String slices.[tuple](primitive.tuple.html)A finite heterogeneous sequence, `(T, U, ..)`.[u8](primitive.u8.html)The 8-bit unsigned integer type.[u16](primitive.u16.html)The 16-bit unsigned integer type.[u32](primitive.u32.html)The 32-bit unsigned integer type.[u64](primitive.u64.html)The 64-bit unsigned integer type.[u128](primitive.u128.html)The 128-bit unsigned integer type.[unit](primitive.unit.html)The `()` type, also called \u201cunit\u201d.[usize](primitive.usize.html)The pointer-sized unsigned integer type.[f16](primitive.f16.html)ExperimentalA 16-bit floating-point type (specifically, the \u201cbinary16\u201d type defined in IEEE 754-2008).[f128](primitive.f128.html)ExperimentalA 128-bit floating-point type (specifically, the \u201cbinary128\u201d type defined in IEEE 754-2008).[never](primitive.never.html)ExperimentalThe `!` type, also called \u201cnever\u201d.\n\n## Modules[\u00a7](#modules)\n\n[alloc](alloc/index.html)Memory allocation APIs.[any](any/index.html)Utilities for dynamic typing or type reflection.[arch](arch/index.html)SIMD and vendor intrinsics module.[array](array/index.html)Utilities for the array primitive type.[ascii](ascii/index.html)Operations on ASCII strings and characters.[backtrace](backtrace/index.html)Support for capturing a stack backtrace of an OS thread[borrow](borrow/index.html)A module for working with borrowed data.[boxed](boxed/index.html)The `Box<T>` type for heap allocation.[cell](cell/index.html)Shareable mutable containers.[char](char/index.html)Utilities for the `char` primitive type.[clone](clone/index.html)The `Clone` trait for types that cannot be \u2018implicitly copied\u2019.[cmp](cmp/index.html)Utilities for comparing and ordering values.[collections](collections/index.html)Collection types.[convert](convert/index.html)Traits for conversions between types.[default](default/index.html)The `Default` trait for types with a default value.[env](env/index.html)Inspection and manipulation of the process\u2019s environment.[error](error/index.html)Interfaces for working with Errors.[f32](f32/index.html)Constants for the `f32` single-precision floating point type.[f64](f64/index.html)Constants for the `f64` double-precision floating point type.[ffi](ffi/index.html)Utilities related to FFI bindings.[fmt](fmt/index.html)Utilities for formatting and printing `String`s.[fs](fs/index.html)Filesystem manipulation operations.[future](future/index.html)Asynchronous basic functionality.[hash](hash/index.html)Generic hashing support.[hint](hint/index.html)Hints to compiler that affects how code should be emitted or optimized.[i8](i8/index.html)Deprecation plannedRedundant constants module for the [i8 primitive type](primitive.i8.html).[i16](i16/index.html)Deprecation plannedRedundant constants module for the [i16 primitive type](primitive.i16.html).[i32](i32/index.html)Deprecation plannedRedundant constants module for the [i32 primitive type](primitive.i32.html).[i64](i64/index.html)Deprecation plannedRedundant constants module for the [i64 primitive type](primitive.i64.html).[i128](i128/index.html)Deprecation plannedRedundant constants module for the [i128 primitive type](primitive.i128.html).[io](io/index.html)Traits, helpers, and type definitions for core I/O functionality.[isize](isize/index.html)Deprecation plannedRedundant constants module for the [isize primitive type](primitive.isize.html).[iter](iter/index.html)Composable external iteration.[marker](marker/index.html)Primitive traits and types representing basic properties of types.[mem](mem/index.html)Basic functions for dealing with memory.[net](net/index.html)Networking primitives for TCP/UDP communication.[num](num/index.html)Additional functionality for numerics.[ops](ops/index.html)Overloadable operators.[option](option/index.html)Optional values.[os](os/index.html)OS-specific functionality.[panic](panic/index.html)Panic support in the standard library.[path](path/index.html)Cross-platform path manipulation.[pin](pin/index.html)Types that pin data to a location in memory.[prelude](prelude/index.html)The Rust Prelude[primitive](primitive/index.html)This module reexports the primitive types to allow usage that is not possibly shadowed by other declared types.[process](process/index.html)A module for working with processes.[ptr](ptr/index.html)Manually manage memory through raw pointers.[rc](rc/index.html)Single-threaded reference-counting pointers. \u2018Rc\u2019 stands for \u2018Reference Counted\u2019.[result](result/index.html)Error handling with the `Result` type.[slice](slice/index.html)Utilities for the slice primitive type.[str](str/index.html)Utilities for the `str` primitive type.[string](string/index.html)A UTF-8\u2013encoded, growable string.[sync](sync/index.html)Useful synchronization primitives.[task](task/index.html)Types and Traits for working with asynchronous tasks.[thread](thread/index.html)Native threads.[time](time/index.html)Temporal quantification.[u8](u8/index.html)Deprecation plannedRedundant constants module for the [u8 primitive type](primitive.u8.html).[u16](u16/index.html)Deprecation plannedRedundant constants module for the [u16 primitive type](primitive.u16.html).[u32](u32/index.html)Deprecation plannedRedundant constants module for the [u32 primitive type](primitive.u32.html).[u64](u64/index.html)Deprecation plannedRedundant constants module for the [u64 primitive type](primitive.u64.html).[u128](u128/index.html)Deprecation plannedRedundant constants module for the [u128 primitive type](primitive.u128.html).[usize](usize/index.html)Deprecation plannedRedundant constants module for the [usize primitive type](primitive.usize.html).[vec](vec/index.html)A contiguous growable array type with heap-allocated contents, written `Vec<T>`.[assert_matches](assert_matches/index.html)ExperimentalUnstable module containing the unstable `assert_matches` macro.[async_iter](async_iter/index.html)ExperimentalComposable asynchronous iteration.[autodiff](autodiff/index.html)ExperimentalThis module provides support for automatic differentiation.[bstr](bstr/index.html)ExperimentalThe `ByteStr` and `ByteString` types and trait implementations.[f16](f16/index.html)ExperimentalConstants for the `f16` half-precision floating point type.[f128](f128/index.html)ExperimentalConstants for the `f128` quadruple-precision floating point type.[from](from/index.html)ExperimentalUnstable module containing the unstable `From` derive macro.[intrinsics](intrinsics/index.html)ExperimentalCompiler intrinsics.[pat](pat/index.html)ExperimentalHelper module for exporting the `pattern_type` macro[random](random/index.html)ExperimentalRandom value generation.[range](range/index.html)ExperimentalExperimental replacement range types[simd](simd/index.html)ExperimentalPortable SIMD module.[unsafe_binder](unsafe_binder/index.html)ExperimentalOperators used to turn types into unsafe binders and back.\n\n## Macros[\u00a7](#macros)\n\n[assert](macro.assert.html)Asserts that a boolean expression is `true` at runtime.[assert_eq](macro.assert_eq.html)Asserts that two expressions are equal to each other (using [PartialEq](cmp/trait.PartialEq.html)).[assert_ne](macro.assert_ne.html)Asserts that two expressions are not equal to each other (using [PartialEq](cmp/trait.PartialEq.html)).[cfg](macro.cfg.html)Evaluates boolean combinations of configuration flags at compile-time.[column](macro.column.html)Expands to the column number at which it was invoked.[compile_error](macro.compile_error.html)Causes compilation to fail with the given error message when encountered.[concat](macro.concat.html)Concatenates literals into a static string slice.[dbg](macro.dbg.html)Prints and returns the value of a given expression for quick and dirty debugging.[debug_assert](macro.debug_assert.html)Asserts that a boolean expression is `true` at runtime.[debug_assert_eq](macro.debug_assert_eq.html)Asserts that two expressions are equal to each other.[debug_assert_ne](macro.debug_assert_ne.html)Asserts that two expressions are not equal to each other.[env](macro.env.html)Inspects an environment variable at compile time.[eprint](macro.eprint.html)Prints to the standard error.[eprintln](macro.eprintln.html)Prints to the standard error, with a newline.[file](macro.file.html)Expands to the file name in which it was invoked.[format](macro.format.html)Creates a `String` using interpolation of runtime expressions.[format_args](macro.format_args.html)Constructs parameters for the other string-formatting macros.[include](macro.include.html)Parses a file as an expression or an item according to the context.[include_bytes](macro.include_bytes.html)Includes a file as a reference to a byte array.[include_str](macro.include_str.html)Includes a UTF-8 encoded file as a string.[is_x86_feature_detected](macro.is_x86_feature_detected.html)A macro to test at runtime whether a CPU feature is available on x86/x86-64 platforms.[line](macro.line.html)Expands to the line number on which it was invoked.[matches](macro.matches.html)Returns whether the given expression matches the provided pattern.[module_path](macro.module_path.html)Expands to a string that represents the current module path.[option_env](macro.option_env.html)Optionally inspects an environment variable at compile time.[panic](macro.panic.html)Panics the current thread.[print](macro.print.html)Prints to the standard output.[println](macro.println.html)Prints to the standard output, with a newline.[stringify](macro.stringify.html)Stringifies its arguments.[thread_local](macro.thread_local.html)Declare a new thread local storage key of type [std::thread::LocalKey](thread/struct.LocalKey.html).[todo](macro.todo.html)Indicates unfinished code.[try](macro.try.html)DeprecatedUnwraps a result or propagates its error.[unimplemented](macro.unimplemented.html)Indicates unimplemented code by panicking with a message of \u201cnot implemented\u201d.[unreachable](macro.unreachable.html)Indicates unreachable code.[vec](macro.vec.html)Creates a [Vec](vec/struct.Vec.html) containing the arguments.[write](macro.write.html)Writes formatted data into a buffer.[writeln](macro.writeln.html)Writes formatted data into a buffer, with a newline appended.[cfg_select](macro.cfg_select.html)ExperimentalSelects code at compile-time based on `cfg` predicates.[concat_bytes](macro.concat_bytes.html)ExperimentalConcatenates literals into a byte slice.[const_format_args](macro.const_format_args.html)ExperimentalSame as [format_args](macro.format_args.html), but can be used in some const contexts.[log_syntax](macro.log_syntax.html)ExperimentalPrints passed tokens into the standard output.[trace_macros](macro.trace_macros.html)ExperimentalEnables or disables tracing functionality used for debugging other macros.\n\n## Keywords[\u00a7](#keywords)\n\n[SelfTy](keyword.SelfTy.html)The implementing type within a [trait](keyword.trait.html) or [impl](keyword.impl.html) block, or the current type within a type definition.[as](keyword.as.html)Cast between types, rename an import, or qualify paths to associated items.[async](keyword.async.html)Returns a [Future](future/trait.Future.html) instead of blocking the current thread.[await](keyword.await.html)Suspend execution until the result of a [Future](future/trait.Future.html) is ready.[become](keyword.become.html)Perform a tail-call of a function.[break](keyword.break.html)Exit early from a loop or labelled block.[const](keyword.const.html)Compile-time constants, compile-time blocks, compile-time evaluable functions, and raw pointers.[continue](keyword.continue.html)Skip to the next iteration of a loop.[crate](keyword.crate.html)A Rust binary or library.[dyn](keyword.dyn.html)`dyn` is a prefix of a [trait object](../book/ch17-02-trait-objects.html)\u2019s type.[else](keyword.else.html)What expression to evaluate when an [if](keyword.if.html) condition evaluates to [false](keyword.false.html).[enum](keyword.enum.html)A type that can be any one of several variants.[extern](keyword.extern.html)Link to or import external code.[false](keyword.false.html)A value of type [bool](primitive.bool.html) representing logical false.[fn](keyword.fn.html)A function or function pointer.[for](keyword.for.html)Iteration with [in](keyword.in.html), trait implementation with [impl](keyword.impl.html), or [higher-ranked trait bounds](../reference/trait-bounds.html#higher-ranked-trait-bounds) (`for<'a>`).[if](keyword.if.html)Evaluate a block if a condition holds.[impl](keyword.impl.html)Implementations of functionality for a type, or a type implementing some functionality.[in](keyword.in.html)Iterate over a series of values with [for](keyword.for.html).[let](keyword.let.html)Bind a value to a variable.[loop](keyword.loop.html)Loop indefinitely.[match](keyword.match.html)Control flow based on pattern matching.[mod](keyword.mod.html)Organize code into [modules](../reference/items/modules.html).[move](keyword.move.html)Capture a [closure](../book/ch13-01-closures.html)\u2019s environment by value.[mut](keyword.mut.html)A mutable variable, reference, or pointer.[pub](keyword.pub.html)Make an item visible to others.[ref](keyword.ref.html)Bind by reference during pattern matching.[return](keyword.return.html)Returns a value from a function.[self](keyword.self.html)The receiver of a method, or the current module.[static](keyword.static.html)A static item is a value which is valid for the entire duration of your program (a `'static` lifetime).[struct](keyword.struct.html)A type that is composed of other types.[super](keyword.super.html)The parent of the current [module](../reference/items/modules.html).[trait](keyword.trait.html)A common interface for a group of types.[true](keyword.true.html)A value of type [bool](primitive.bool.html) representing logical true.[type](keyword.type.html)Define an [alias](../reference/items/type-aliases.html) for an existing type.[union](keyword.union.html)The [Rust equivalent of a C-style union](../reference/items/unions.html).[unsafe](keyword.unsafe.html)Code or interfaces whose [memory safety](../book/ch19-01-unsafe-rust.html) cannot be verified by the type system.[use](keyword.use.html)Import or rename items from other crates or modules, use values under ergonomic clones semantic, or specify precise capturing with `use<..>`.[where](keyword.where.html)Add constraints that must be upheld to use an item.[while](keyword.while.html)Loop while a condition is upheld.\n"}, {"path": "stdlib/collections.md", "category": "stdlib", "name": "stdlib/collections", "content": "# Rust Collections (std::collections)\n\n## Vec<T>\n\nGrowable array. Most common collection.\n\n```rust\n// Create\nlet mut vec: Vec<i32> = Vec::new();\nlet vec = vec![1, 2, 3];\nlet vec = Vec::with_capacity(100);\nlet vec: Vec<i32> = (0..10).collect();\n\n// Access\nvec[0];                     // panics if out of bounds\nvec.get(0);                 // Option<&T>\nvec.get_mut(0);             // Option<&mut T>\nvec.first();                // Option<&T>\nvec.last();                 // Option<&T>\n\n// Modify\nvec.push(4);\nvec.pop();                  // Option<T>\nvec.insert(0, value);       // O(n)\nvec.remove(0);              // O(n)\nvec.swap_remove(0);         // O(1), doesn't preserve order\nvec.clear();\nvec.truncate(5);\nvec.resize(10, default);\nvec.extend([4, 5, 6]);\n\n// Slicing\nlet slice = &vec[1..3];\nvec.split_at(2);            // (&[T], &[T])\nvec.split_first();          // Option<(&T, &[T])>\nvec.chunks(2);              // iterator of slices\nvec.windows(2);             // sliding window iterator\n\n// Iteration\nfor item in &vec { }        // borrow\nfor item in &mut vec { }    // mutable borrow\nfor item in vec { }         // consume\n\n// Sorting\nvec.sort();                 // stable sort\nvec.sort_unstable();        // faster, not stable\nvec.sort_by(|a, b| b.cmp(a));  // custom comparator\nvec.sort_by_key(|x| x.len());\n\n// Searching\nvec.contains(&value);\nvec.binary_search(&value);  // Result<usize, usize>\nvec.iter().position(|x| *x == value);\nvec.iter().find(|x| **x > 5);\n\n// Deduplication\nvec.dedup();                // consecutive duplicates\nvec.dedup_by_key(|x| x.id);\n\n// Capacity\nvec.len();\nvec.is_empty();\nvec.capacity();\nvec.shrink_to_fit();\nvec.reserve(100);\n```\n\n## HashMap<K, V>\n\nHash table. O(1) average operations.\n\n```rust\nuse std::collections::HashMap;\n\n// Create\nlet mut map: HashMap<String, i32> = HashMap::new();\nlet map = HashMap::with_capacity(100);\nlet map: HashMap<_, _> = vec![(\"a\", 1), (\"b\", 2)].into_iter().collect();\n\n// Access\nmap.get(\"key\");             // Option<&V>\nmap.get_mut(\"key\");         // Option<&mut V>\nmap[\"key\"];                 // panics if missing\nmap.contains_key(\"key\");\n\n// Modify\nmap.insert(\"key\", 42);      // Option<V> (old value)\nmap.remove(\"key\");          // Option<V>\nmap.clear();\n\n// Entry API (key-based modification)\nmap.entry(\"key\").or_insert(0);\nmap.entry(\"key\").or_insert_with(|| expensive_computation());\nmap.entry(\"key\").and_modify(|v| *v += 1).or_insert(0);\n\n*map.entry(\"word\").or_insert(0) += 1;  // word counting\n\n// Iteration\nfor (key, value) in &map { }\nfor (key, value) in &mut map { }\nfor key in map.keys() { }\nfor value in map.values() { }\nfor value in map.values_mut() { }\nmap.iter().filter(|(k, v)| v > &&0);\n\n// Capacity\nmap.len();\nmap.is_empty();\nmap.capacity();\nmap.shrink_to_fit();\nmap.reserve(100);\n```\n\n## HashSet<T>\n\nHash set. Unique elements, O(1) operations.\n\n```rust\nuse std::collections::HashSet;\n\n// Create\nlet mut set: HashSet<i32> = HashSet::new();\nlet set: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n\n// Modify\nset.insert(42);             // bool (true if new)\nset.remove(&42);            // bool\nset.take(&42);              // Option<T>\nset.clear();\n\n// Query\nset.contains(&42);\nset.get(&42);               // Option<&T>\n\n// Set operations\nlet union = a.union(&b);\nlet intersection = a.intersection(&b);\nlet difference = a.difference(&b);\nlet symmetric_diff = a.symmetric_difference(&b);\n\na.is_subset(&b);\na.is_superset(&b);\na.is_disjoint(&b);\n```\n\n## BTreeMap<K, V> and BTreeSet<T>\n\nSorted collections. O(log n) operations.\n\n```rust\nuse std::collections::{BTreeMap, BTreeSet};\n\nlet mut map: BTreeMap<String, i32> = BTreeMap::new();\nlet mut set: BTreeSet<i32> = BTreeSet::new();\n\n// Same API as HashMap/HashSet plus:\n\n// Range operations\nfor (k, v) in map.range(\"a\"..\"z\") { }\nfor (k, v) in map.range(..=\"m\") { }\n\n// First/Last\nmap.first_key_value();      // Option<(&K, &V)>\nmap.last_key_value();\nmap.pop_first();            // Option<(K, V)>\nmap.pop_last();\n\nset.first();                // Option<&T>\nset.last();\nset.pop_first();            // Option<T>\nset.pop_last();\n```\n\n## VecDeque<T>\n\nDouble-ended queue. O(1) push/pop at both ends.\n\n```rust\nuse std::collections::VecDeque;\n\nlet mut deque: VecDeque<i32> = VecDeque::new();\nlet deque = VecDeque::from([1, 2, 3]);\n\n// Both ends\ndeque.push_front(0);\ndeque.push_back(4);\ndeque.pop_front();          // Option<T>\ndeque.pop_back();           // Option<T>\ndeque.front();              // Option<&T>\ndeque.back();               // Option<&T>\n\n// Random access\ndeque[0];\ndeque.get(0);\n\n// Rotation\ndeque.rotate_left(2);\ndeque.rotate_right(2);\n\n// Convert\nlet vec: Vec<i32> = deque.into();\nlet (front, back) = deque.as_slices();\ndeque.make_contiguous();    // &mut [T]\n```\n\n## BinaryHeap<T>\n\nMax-heap / priority queue.\n\n```rust\nuse std::collections::BinaryHeap;\n\nlet mut heap = BinaryHeap::new();\nlet heap = BinaryHeap::from([3, 1, 4, 1, 5]);\n\nheap.push(42);\nheap.pop();                 // Option<T> - removes max\nheap.peek();                // Option<&T> - view max\nheap.peek_mut();            // Option<PeekMut<T>>\n\n// Drain in sorted order\nwhile let Some(max) = heap.pop() {\n    println!(\"{}\", max);\n}\n\n// Min-heap using Reverse\nuse std::cmp::Reverse;\nlet mut min_heap = BinaryHeap::new();\nmin_heap.push(Reverse(5));\nmin_heap.push(Reverse(1));\nlet Reverse(min) = min_heap.pop().unwrap();  // 1\n```\n\n## LinkedList<T>\n\nDoubly-linked list. Rarely needed (Vec usually better).\n\n```rust\nuse std::collections::LinkedList;\n\nlet mut list = LinkedList::new();\n\nlist.push_front(1);\nlist.push_back(2);\nlist.pop_front();\nlist.pop_back();\nlist.front();\nlist.back();\n\n// Append another list\nlist.append(&mut other);\n\n// Split\nlet second_half = list.split_off(5);\n```\n\n## String\n\nUTF-8 encoded growable string.\n\n```rust\n// Create\nlet mut s = String::new();\nlet s = String::from(\"hello\");\nlet s = \"hello\".to_string();\nlet s = format!(\"{} {}\", \"hello\", \"world\");\nlet s = String::with_capacity(100);\n\n// Modify\ns.push('!');\ns.push_str(\" world\");\ns.insert(0, 'H');\ns.insert_str(0, \"Hello \");\ns.pop();                    // Option<char>\ns.remove(0);                // char (panics if not char boundary)\ns.truncate(5);\ns.clear();\ns += \" suffix\";\n\n// Access\ns.len();                    // bytes, not chars!\ns.is_empty();\ns.chars().count();          // character count\ns.as_str();                 // &str\ns.as_bytes();               // &[u8]\ns.chars();                  // iterator of char\ns.bytes();                  // iterator of u8\n\n// Slicing (must be at char boundaries!)\n&s[0..5];                   // panics if not valid UTF-8 boundary\n\n// Searching\ns.contains(\"ell\");\ns.starts_with(\"He\");\ns.ends_with(\"lo\");\ns.find(\"ll\");               // Option<usize>\ns.rfind(\"l\");\ns.matches(\"l\").count();\n\n// Transformations\ns.to_uppercase();\ns.to_lowercase();\ns.trim();\ns.trim_start();\ns.trim_end();\ns.replace(\"old\", \"new\");\ns.replacen(\"old\", \"new\", 2);\n\n// Splitting\ns.split(' ');               // iterator\ns.split_whitespace();\ns.lines();\ns.split_once(':');          // Option<(&str, &str)>\n\n// Parsing\nlet n: i32 = s.parse().unwrap();\nlet n: i32 = s.parse()?;    // in function returning Result\n```\n\n## Iterators\n\n```rust\n// Creating iterators\nvec.iter();                 // &T\nvec.iter_mut();             // &mut T\nvec.into_iter();            // T (consumes)\n\n// Adapters\niter.map(|x| x * 2)\n    .filter(|x| *x > 5)\n    .take(10)\n    .skip(2)\n    .enumerate()            // (index, value)\n    .zip(other)\n    .chain(other)\n    .flatten()              // Iterator<Item=Iterator<T>> -> Iterator<T>\n    .flat_map(|x| vec![x, x])\n    .peekable()\n    .skip_while(|x| **x < 5)\n    .take_while(|x| **x < 10)\n    .step_by(2)\n    .rev()                  // requires DoubleEndedIterator\n    .cycle()                // infinite\n    .cloned()               // &T -> T (if T: Clone)\n    .copied()               // &T -> T (if T: Copy)\n    .inspect(|x| println!(\"{:?}\", x))\n    .fuse();                // stops after first None\n\n// Consumers\niter.collect::<Vec<_>>();\niter.count();\niter.sum::<i32>();\niter.product::<i32>();\niter.fold(0, |acc, x| acc + x);\niter.reduce(|a, b| a + b);  // Option<T>\niter.for_each(|x| println!(\"{}\", x));\niter.any(|x| x > 5);\niter.all(|x| x > 0);\niter.find(|x| **x > 5);     // Option<&T>\niter.position(|x| *x > 5);  // Option<usize>\niter.max();\niter.min();\niter.max_by_key(|x| x.len());\niter.partition::<Vec<_>, _>(|x| *x > 5);\n\n// Comparison\niter.eq(other);\niter.cmp(other);\niter.partial_cmp(other);\n```\n"}, {"path": "stdlib/io.md", "category": "stdlib", "name": "stdlib/io", "content": "# Rust I/O (std::io and std::fs)\n\n## File Operations (std::fs)\n\n```rust\nuse std::fs;\nuse std::fs::File;\nuse std::io::{Read, Write, BufRead, BufReader, BufWriter};\nuse std::path::Path;\n\n// Read entire file\nlet content = fs::read_to_string(\"file.txt\")?;\nlet bytes = fs::read(\"file.bin\")?;\n\n// Write entire file\nfs::write(\"file.txt\", \"Hello, World!\")?;\nfs::write(\"file.bin\", &bytes)?;\n\n// File operations\nfs::copy(\"src.txt\", \"dst.txt\")?;\nfs::rename(\"old.txt\", \"new.txt\")?;\nfs::remove_file(\"file.txt\")?;\nfs::create_dir(\"dirname\")?;\nfs::create_dir_all(\"path/to/dir\")?;\nfs::remove_dir(\"dirname\")?;\nfs::remove_dir_all(\"dirname\")?;\n\n// Metadata\nlet metadata = fs::metadata(\"file.txt\")?;\nmetadata.len();                 // file size in bytes\nmetadata.is_file();\nmetadata.is_dir();\nmetadata.modified()?;           // SystemTime\nmetadata.created()?;\n\n// Read directory\nfor entry in fs::read_dir(\".\")? {\n    let entry = entry?;\n    let path = entry.path();\n    let name = entry.file_name();\n    let metadata = entry.metadata()?;\n}\n\n// Canonicalize path\nlet absolute = fs::canonicalize(\"relative/path\")?;\n```\n\n## File Handles\n\n```rust\nuse std::fs::{File, OpenOptions};\nuse std::io::{Read, Write, Seek, SeekFrom};\n\n// Open for reading\nlet mut file = File::open(\"file.txt\")?;\n\n// Create for writing (truncates)\nlet mut file = File::create(\"file.txt\")?;\n\n// Open with options\nlet file = OpenOptions::new()\n    .read(true)\n    .write(true)\n    .create(true)\n    .append(true)\n    .truncate(false)\n    .open(\"file.txt\")?;\n\n// Reading\nlet mut contents = String::new();\nfile.read_to_string(&mut contents)?;\n\nlet mut buffer = [0u8; 1024];\nlet bytes_read = file.read(&mut buffer)?;\nlet bytes = file.read_exact(&mut buffer)?;  // fills buffer or errors\n\n// Writing\nfile.write_all(b\"Hello\")?;\nlet bytes_written = file.write(b\"Hello\")?;\nfile.flush()?;\n\n// Seeking\nfile.seek(SeekFrom::Start(0))?;      // from beginning\nfile.seek(SeekFrom::End(-10))?;      // from end\nfile.seek(SeekFrom::Current(5))?;    // from current position\nlet pos = file.stream_position()?;   // current position\n\n// File size\nlet size = file.metadata()?.len();\nfile.set_len(1024)?;                 // truncate/extend\n```\n\n## Buffered I/O\n\n```rust\nuse std::io::{BufReader, BufWriter, BufRead, Write};\n\n// Buffered reading\nlet file = File::open(\"file.txt\")?;\nlet reader = BufReader::new(file);\n\n// Read lines\nfor line in reader.lines() {\n    let line = line?;\n    println!(\"{}\", line);\n}\n\n// Read until delimiter\nlet mut buf = String::new();\nreader.read_line(&mut buf)?;\n\nlet mut bytes = Vec::new();\nreader.read_until(b'\\n', &mut bytes)?;\n\n// Buffered writing\nlet file = File::create(\"file.txt\")?;\nlet mut writer = BufWriter::new(file);\nwriter.write_all(b\"Hello\\n\")?;\nwriter.flush()?;\n// automatically flushes on drop\n```\n\n## Standard I/O\n\n```rust\nuse std::io::{self, Read, Write, BufRead};\n\n// Read from stdin\nlet mut input = String::new();\nio::stdin().read_line(&mut input)?;\n\n// With lock (more efficient for multiple reads)\nlet stdin = io::stdin();\nlet mut handle = stdin.lock();\nfor line in handle.lines() {\n    println!(\"{}\", line?);\n}\n\n// Write to stdout\nio::stdout().write_all(b\"Hello\\n\")?;\nprint!(\"Hello\");\nprintln!(\"World\");\neprint!(\"Error: \");       // to stderr\neprintln!(\"Details\");     // to stderr with newline\n\n// With lock\nlet stdout = io::stdout();\nlet mut handle = stdout.lock();\nwriteln!(handle, \"Hello\")?;\n\n// Flush\nio::stdout().flush()?;\n```\n\n## Path Operations (std::path)\n\n```rust\nuse std::path::{Path, PathBuf};\n\n// Create paths\nlet path = Path::new(\"file.txt\");\nlet path = Path::new(\"/absolute/path\");\nlet mut path_buf = PathBuf::new();\npath_buf.push(\"dir\");\npath_buf.push(\"file.txt\");\n\n// Path components\npath.file_name();           // Option<&OsStr>\npath.file_stem();           // filename without extension\npath.extension();           // Option<&OsStr>\npath.parent();              // Option<&Path>\n\n// Path manipulation\nlet joined = path.join(\"subdir\").join(\"file.txt\");\npath_buf.set_file_name(\"other.txt\");\npath_buf.set_extension(\"md\");\n\n// Path queries\npath.exists();\npath.is_file();\npath.is_dir();\npath.is_absolute();\npath.is_relative();\n\n// Path conversion\npath.to_str();              // Option<&str>\npath.to_string_lossy();     // Cow<str>\npath.display();             // for printing\nlet path_buf = path.to_path_buf();\nlet os_str = path.as_os_str();\n\n// Iterate components\nfor component in path.components() {\n    match component {\n        Component::Prefix(prefix) => { }\n        Component::RootDir => { }\n        Component::CurDir => { }       // .\n        Component::ParentDir => { }    // ..\n        Component::Normal(name) => { }\n    }\n}\n\n// Ancestors\nfor ancestor in path.ancestors() {\n    println!(\"{:?}\", ancestor);\n}\n```\n\n## Error Handling\n\n```rust\nuse std::io::{self, Error, ErrorKind};\n\n// Creating errors\nlet error = Error::new(ErrorKind::NotFound, \"file not found\");\nlet error = Error::last_os_error();\n\n// Error kinds\nmatch error.kind() {\n    ErrorKind::NotFound => { }\n    ErrorKind::PermissionDenied => { }\n    ErrorKind::AlreadyExists => { }\n    ErrorKind::WouldBlock => { }\n    ErrorKind::InvalidInput => { }\n    ErrorKind::InvalidData => { }\n    ErrorKind::TimedOut => { }\n    ErrorKind::Interrupted => { }\n    ErrorKind::UnexpectedEof => { }\n    _ => { }\n}\n\n// Common pattern\nfn read_file(path: &str) -> io::Result<String> {\n    let content = fs::read_to_string(path)?;\n    Ok(content)\n}\n```\n\n## Cursor (in-memory I/O)\n\n```rust\nuse std::io::{Cursor, Read, Write, Seek, SeekFrom};\n\n// Read from bytes\nlet data = b\"Hello, World!\";\nlet mut cursor = Cursor::new(data);\nlet mut buf = [0u8; 5];\ncursor.read(&mut buf)?;\n\n// Write to Vec\nlet mut cursor = Cursor::new(Vec::new());\ncursor.write_all(b\"Hello\")?;\nlet bytes = cursor.into_inner();\n\n// Seek\ncursor.seek(SeekFrom::Start(0))?;\ncursor.position();          // current position\ncursor.set_position(5);\n```\n\n## Copy and Transfer\n\n```rust\nuse std::io::{copy, Read, Write};\n\n// Copy between streams\nlet mut src = File::open(\"source.txt\")?;\nlet mut dst = File::create(\"dest.txt\")?;\nlet bytes_copied = io::copy(&mut src, &mut dst)?;\n\n// Read/Write adapters\nlet limited = file.take(1024);      // read at most 1024 bytes\nlet chained = file1.chain(file2);   // read file1 then file2\n```\n\n## Temporary Files\n\n```rust\nuse std::env;\n\n// Temp directory\nlet temp_dir = env::temp_dir();\n\n// Using tempfile crate (recommended)\nuse tempfile::{tempfile, NamedTempFile, tempdir};\n\nlet file = tempfile()?;              // anonymous temp file\nlet named = NamedTempFile::new()?;   // temp file with path\nlet dir = tempdir()?;                // temp directory\n\n// Files are deleted on drop\n```\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# Rust Reference\nVersion: 1.92.0\n\nSource: https://doc.rust-lang.org/reference/\n\n\nSee: https://doc.rust-lang.org/reference/\n"}, {"path": "linters/clippy/single_match.md", "category": "linters", "name": "linters/clippy/single_match", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/vec_resize_to_zero.md", "category": "linters", "name": "linters/clippy/vec_resize_to_zero", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/pub_with_shorthand.md", "category": "linters", "name": "linters/clippy/pub_with_shorthand", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/boxed_local.md", "category": "linters", "name": "linters/clippy/boxed_local", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_locals.md", "category": "linters", "name": "linters/clippy/redundant_locals", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/uninit_vec.md", "category": "linters", "name": "linters/clippy/uninit_vec", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_debug_formatting.md", "category": "linters", "name": "linters/clippy/unnecessary_debug_formatting", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/single_match_else.md", "category": "linters", "name": "linters/clippy/single_match_else", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/infallible_try_from.md", "category": "linters", "name": "linters/clippy/infallible_try_from", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/print_literal.md", "category": "linters", "name": "linters/clippy/print_literal", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/permissions_set_readonly_false.md", "category": "linters", "name": "linters/clippy/permissions_set_readonly_false", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/no_effect_underscore_binding.md", "category": "linters", "name": "linters/clippy/no_effect_underscore_binding", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/explicit_auto_deref.md", "category": "linters", "name": "linters/clippy/explicit_auto_deref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/type_id_on_box.md", "category": "linters", "name": "linters/clippy/type_id_on_box", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_let_else.md", "category": "linters", "name": "linters/clippy/manual_let_else", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/coerce_container_to_any.md", "category": "linters", "name": "linters/clippy/coerce_container_to_any", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/macro_use_imports.md", "category": "linters", "name": "linters/clippy/macro_use_imports", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/transmute_ptr_to_ref.md", "category": "linters", "name": "linters/clippy/transmute_ptr_to_ref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/index_refutable_slice.md", "category": "linters", "name": "linters/clippy/index_refutable_slice", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/should_implement_trait.md", "category": "linters", "name": "linters/clippy/should_implement_trait", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_pass_by_ref_mut.md", "category": "linters", "name": "linters/clippy/needless_pass_by_ref_mut", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/identity_op.md", "category": "linters", "name": "linters/clippy/identity_op", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/chars_next_cmp.md", "category": "linters", "name": "linters/clippy/chars_next_cmp", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_iter_cloned.md", "category": "linters", "name": "linters/clippy/redundant_iter_cloned", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_assert.md", "category": "linters", "name": "linters/clippy/manual_assert", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/from_over_into.md", "category": "linters", "name": "linters/clippy/from_over_into", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_cloned_collect.md", "category": "linters", "name": "linters/clippy/iter_cloned_collect", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/string_add.md", "category": "linters", "name": "linters/clippy/string_add", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/empty_line_after_doc_comments.md", "category": "linters", "name": "linters/clippy/empty_line_after_doc_comments", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/print_stdout.md", "category": "linters", "name": "linters/clippy/print_stdout", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/float_arithmetic.md", "category": "linters", "name": "linters/clippy/float_arithmetic", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/char_lit_as_u8.md", "category": "linters", "name": "linters/clippy/char_lit_as_u8", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_non_exhaustive.md", "category": "linters", "name": "linters/clippy/manual_non_exhaustive", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_cast.md", "category": "linters", "name": "linters/clippy/unnecessary_cast", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/should_panic_without_expect.md", "category": "linters", "name": "linters/clippy/should_panic_without_expect", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/explicit_write.md", "category": "linters", "name": "linters/clippy/explicit_write", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/same_length_and_capacity.md", "category": "linters", "name": "linters/clippy/same_length_and_capacity", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/result_filter_map.md", "category": "linters", "name": "linters/clippy/result_filter_map", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_return.md", "category": "linters", "name": "linters/clippy/needless_return", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/too_long_first_doc_paragraph.md", "category": "linters", "name": "linters/clippy/too_long_first_doc_paragraph", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/misrefactored_assign_op.md", "category": "linters", "name": "linters/clippy/misrefactored_assign_op", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_next_back.md", "category": "linters", "name": "linters/clippy/manual_next_back", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/excessive_precision.md", "category": "linters", "name": "linters/clippy/excessive_precision", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mod_module_files.md", "category": "linters", "name": "linters/clippy/mod_module_files", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cmp_owned.md", "category": "linters", "name": "linters/clippy/cmp_owned", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/get_first.md", "category": "linters", "name": "linters/clippy/get_first", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/implied_bounds_in_impls.md", "category": "linters", "name": "linters/clippy/implied_bounds_in_impls", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_is_variant_and.md", "category": "linters", "name": "linters/clippy/manual_is_variant_and", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_match.md", "category": "linters", "name": "linters/clippy/needless_match", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_borrow.md", "category": "linters", "name": "linters/clippy/needless_borrow", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unused_io_amount.md", "category": "linters", "name": "linters/clippy/unused_io_amount", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_errors_doc.md", "category": "linters", "name": "linters/clippy/missing_errors_doc", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cargo_common_metadata.md", "category": "linters", "name": "linters/clippy/cargo_common_metadata", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mut_mutex_lock.md", "category": "linters", "name": "linters/clippy/mut_mutex_lock", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_const_for_fn.md", "category": "linters", "name": "linters/clippy/missing_const_for_fn", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/misaligned_transmute.md", "category": "linters", "name": "linters/clippy/misaligned_transmute", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/useless_asref.md", "category": "linters", "name": "linters/clippy/useless_asref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/return_and_then.md", "category": "linters", "name": "linters/clippy/return_and_then", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/from_iter_instead_of_collect.md", "category": "linters", "name": "linters/clippy/from_iter_instead_of_collect", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/equatable_if_let.md", "category": "linters", "name": "linters/clippy/equatable_if_let", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/reversed_empty_ranges.md", "category": "linters", "name": "linters/clippy/reversed_empty_ranges", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/nonsensical_open_options.md", "category": "linters", "name": "linters/clippy/nonsensical_open_options", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/option_as_ref_cloned.md", "category": "linters", "name": "linters/clippy/option_as_ref_cloned", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_try_fold.md", "category": "linters", "name": "linters/clippy/manual_try_fold", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious_op_assign_impl.md", "category": "linters", "name": "linters/clippy/suspicious_op_assign_impl", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/wildcard_in_or_patterns.md", "category": "linters", "name": "linters/clippy/wildcard_in_or_patterns", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/neg_multiply.md", "category": "linters", "name": "linters/clippy/neg_multiply", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/default_trait_access.md", "category": "linters", "name": "linters/clippy/default_trait_access", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/module_name_repetitions.md", "category": "linters", "name": "linters/clippy/module_name_repetitions", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/zero_sized_map_values.md", "category": "linters", "name": "linters/clippy/zero_sized_map_values", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cast_enum_truncation.md", "category": "linters", "name": "linters/clippy/cast_enum_truncation", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/macro_metavars_in_unsafe.md", "category": "linters", "name": "linters/clippy/macro_metavars_in_unsafe", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unstable_as_mut_slice.md", "category": "linters", "name": "linters/clippy/unstable_as_mut_slice", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/assigning_clones.md", "category": "linters", "name": "linters/clippy/assigning_clones", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_range_contains.md", "category": "linters", "name": "linters/clippy/manual_range_contains", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/match_overlapping_arm.md", "category": "linters", "name": "linters/clippy/match_overlapping_arm", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/bool_to_int_with_if.md", "category": "linters", "name": "linters/clippy/bool_to_int_with_if", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/large_stack_frames.md", "category": "linters", "name": "linters/clippy/large_stack_frames", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/doc_lazy_continuation.md", "category": "linters", "name": "linters/clippy/doc_lazy_continuation", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_midpoint.md", "category": "linters", "name": "linters/clippy/manual_midpoint", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_bitwise_bool.md", "category": "linters", "name": "linters/clippy/needless_bitwise_bool", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/overview.md", "category": "linters", "name": "linters/clippy/overview", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unit_return_expecting_ord.md", "category": "linters", "name": "linters/clippy/unit_return_expecting_ord", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/infallible_destructuring_match.md", "category": "linters", "name": "linters/clippy/infallible_destructuring_match", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/empty_loop.md", "category": "linters", "name": "linters/clippy/empty_loop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/impl_trait_in_params.md", "category": "linters", "name": "linters/clippy/impl_trait_in_params", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/no_effect_replace.md", "category": "linters", "name": "linters/clippy/no_effect_replace", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/to_digit_is_some.md", "category": "linters", "name": "linters/clippy/to_digit_is_some", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/err_expect.md", "category": "linters", "name": "linters/clippy/err_expect", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/obfuscated_if_else.md", "category": "linters", "name": "linters/clippy/obfuscated_if_else", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_strip.md", "category": "linters", "name": "linters/clippy/manual_strip", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/size_of_ref.md", "category": "linters", "name": "linters/clippy/size_of_ref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/bool_comparison.md", "category": "linters", "name": "linters/clippy/bool_comparison", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/chars_last_cmp.md", "category": "linters", "name": "linters/clippy/chars_last_cmp", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/drain_collect.md", "category": "linters", "name": "linters/clippy/drain_collect", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/assertions_on_result_states.md", "category": "linters", "name": "linters/clippy/assertions_on_result_states", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/inherent_to_string_shadow_display.md", "category": "linters", "name": "linters/clippy/inherent_to_string_shadow_display", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/reserve_after_initialization.md", "category": "linters", "name": "linters/clippy/reserve_after_initialization", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/four_forward_slashes.md", "category": "linters", "name": "linters/clippy/four_forward_slashes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_continue.md", "category": "linters", "name": "linters/clippy/needless_continue", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_feature_names.md", "category": "linters", "name": "linters/clippy/redundant_feature_names", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/swap_ptr_to_ref.md", "category": "linters", "name": "linters/clippy/swap_ptr_to_ref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/comparison_chain.md", "category": "linters", "name": "linters/clippy/comparison_chain", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/almost_swapped.md", "category": "linters", "name": "linters/clippy/almost_swapped", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_struct_initialization.md", "category": "linters", "name": "linters/clippy/unnecessary_struct_initialization", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unreadable_literal.md", "category": "linters", "name": "linters/clippy/unreadable_literal", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/print_in_format_impl.md", "category": "linters", "name": "linters/clippy/print_in_format_impl", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/module_inception.md", "category": "linters", "name": "linters/clippy/module_inception", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/min_max.md", "category": "linters", "name": "linters/clippy/min_max", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/zombie_processes.md", "category": "linters", "name": "linters/clippy/zombie_processes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/semicolon_if_nothing_returned.md", "category": "linters", "name": "linters/clippy/semicolon_if_nothing_returned", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/int_plus_one.md", "category": "linters", "name": "linters/clippy/int_plus_one", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unused_collect.md", "category": "linters", "name": "linters/clippy/unused_collect", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/create_dir.md", "category": "linters", "name": "linters/clippy/create_dir", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_character_iteration.md", "category": "linters", "name": "linters/clippy/needless_character_iteration", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/option_map_unit_fn.md", "category": "linters", "name": "linters/clippy/option_map_unit_fn", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/must_use_candidate.md", "category": "linters", "name": "linters/clippy/must_use_candidate", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_div_ceil.md", "category": "linters", "name": "linters/clippy/manual_div_ceil", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/flat_map_identity.md", "category": "linters", "name": "linters/clippy/flat_map_identity", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/integer_division_remainder_used.md", "category": "linters", "name": "linters/clippy/integer_division_remainder_used", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_main_separator_str.md", "category": "linters", "name": "linters/clippy/manual_main_separator_str", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_find.md", "category": "linters", "name": "linters/clippy/manual_find", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/useless_attribute.md", "category": "linters", "name": "linters/clippy/useless_attribute", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_async_fn.md", "category": "linters", "name": "linters/clippy/manual_async_fn", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/zero_prefixed_literal.md", "category": "linters", "name": "linters/clippy/zero_prefixed_literal", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/for_kv_map.md", "category": "linters", "name": "linters/clippy/for_kv_map", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/let_and_return.md", "category": "linters", "name": "linters/clippy/let_and_return", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ref_as_ptr.md", "category": "linters", "name": "linters/clippy/ref_as_ptr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ignored_unit_patterns.md", "category": "linters", "name": "linters/clippy/ignored_unit_patterns", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/path_buf_push_overwrite.md", "category": "linters", "name": "linters/clippy/path_buf_push_overwrite", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/match_as_ref.md", "category": "linters", "name": "linters/clippy/match_as_ref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/trait_duplication_in_bounds.md", "category": "linters", "name": "linters/clippy/trait_duplication_in_bounds", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unneeded_struct_pattern.md", "category": "linters", "name": "linters/clippy/unneeded_struct_pattern", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/pub_enum_variant_names.md", "category": "linters", "name": "linters/clippy/pub_enum_variant_names", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/branches_sharing_code.md", "category": "linters", "name": "linters/clippy/branches_sharing_code", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/disallowed_macros.md", "category": "linters", "name": "linters/clippy/disallowed_macros", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_option_take.md", "category": "linters", "name": "linters/clippy/needless_option_take", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/join_absolute_paths.md", "category": "linters", "name": "linters/clippy/join_absolute_paths", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/inconsistent_struct_constructor.md", "category": "linters", "name": "linters/clippy/inconsistent_struct_constructor", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/readonly_write_lock.md", "category": "linters", "name": "linters/clippy/readonly_write_lock", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ptr_arg.md", "category": "linters", "name": "linters/clippy/ptr_arg", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/doc_suspicious_footnotes.md", "category": "linters", "name": "linters/clippy/doc_suspicious_footnotes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_is_infinite.md", "category": "linters", "name": "linters/clippy/manual_is_infinite", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_else.md", "category": "linters", "name": "linters/clippy/needless_else", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/inverted_saturating_sub.md", "category": "linters", "name": "linters/clippy/inverted_saturating_sub", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/inconsistent_digit_grouping.md", "category": "linters", "name": "linters/clippy/inconsistent_digit_grouping", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/uninlined_format_args.md", "category": "linters", "name": "linters/clippy/uninlined_format_args", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mem_replace_with_uninit.md", "category": "linters", "name": "linters/clippy/mem_replace_with_uninit", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/wildcard_imports.md", "category": "linters", "name": "linters/clippy/wildcard_imports", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/type_complexity.md", "category": "linters", "name": "linters/clippy/type_complexity", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious_else_formatting.md", "category": "linters", "name": "linters/clippy/suspicious_else_formatting", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_string_new.md", "category": "linters", "name": "linters/clippy/manual_string_new", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cognitive_complexity.md", "category": "linters", "name": "linters/clippy/cognitive_complexity", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/match_bool.md", "category": "linters", "name": "linters/clippy/match_bool", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_is_multiple_of.md", "category": "linters", "name": "linters/clippy/manual_is_multiple_of", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/doc_nested_refdefs.md", "category": "linters", "name": "linters/clippy/doc_nested_refdefs", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/maybe_infinite_iter.md", "category": "linters", "name": "linters/clippy/maybe_infinite_iter", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_as_bytes.md", "category": "linters", "name": "linters/clippy/needless_as_bytes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/match_wild_err_arm.md", "category": "linters", "name": "linters/clippy/match_wild_err_arm", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/error_impl_error.md", "category": "linters", "name": "linters/clippy/error_impl_error", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/from_str_radix_10.md", "category": "linters", "name": "linters/clippy/from_str_radix_10", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/default_constructed_unit_structs.md", "category": "linters", "name": "linters/clippy/default_constructed_unit_structs", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_at_rest_pattern.md", "category": "linters", "name": "linters/clippy/redundant_at_rest_pattern", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cast_possible_wrap.md", "category": "linters", "name": "linters/clippy/cast_possible_wrap", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/get_unwrap.md", "category": "linters", "name": "linters/clippy/get_unwrap", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/large_types_passed_by_value.md", "category": "linters", "name": "linters/clippy/large_types_passed_by_value", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_flatten.md", "category": "linters", "name": "linters/clippy/manual_flatten", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/str_to_string.md", "category": "linters", "name": "linters/clippy/str_to_string", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/format_collect.md", "category": "linters", "name": "linters/clippy/format_collect", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/verbose_bit_mask.md", "category": "linters", "name": "linters/clippy/verbose_bit_mask", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/duplicate_underscore_argument.md", "category": "linters", "name": "linters/clippy/duplicate_underscore_argument", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mutable_key_type.md", "category": "linters", "name": "linters/clippy/mutable_key_type", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/println_empty_string.md", "category": "linters", "name": "linters/clippy/println_empty_string", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/useless_nonzero_new_unchecked.md", "category": "linters", "name": "linters/clippy/useless_nonzero_new_unchecked", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/renamed_function_params.md", "category": "linters", "name": "linters/clippy/renamed_function_params", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unused_format_specs.md", "category": "linters", "name": "linters/clippy/unused_format_specs", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/derivable_impls.md", "category": "linters", "name": "linters/clippy/derivable_impls", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/map_entry.md", "category": "linters", "name": "linters/clippy/map_entry", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/option_map_or_none.md", "category": "linters", "name": "linters/clippy/option_map_or_none", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/incompatible_msrv.md", "category": "linters", "name": "linters/clippy/incompatible_msrv", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/disallowed_types.md", "category": "linters", "name": "linters/clippy/disallowed_types", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/similar_names.md", "category": "linters", "name": "linters/clippy/similar_names", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_type_annotations.md", "category": "linters", "name": "linters/clippy/redundant_type_annotations", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/format_in_format_args.md", "category": "linters", "name": "linters/clippy/format_in_format_args", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/filter_next.md", "category": "linters", "name": "linters/clippy/filter_next", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/box_collection.md", "category": "linters", "name": "linters/clippy/box_collection", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/fn_to_numeric_cast_any.md", "category": "linters", "name": "linters/clippy/fn_to_numeric_cast_any", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_borrowed_reference.md", "category": "linters", "name": "linters/clippy/needless_borrowed_reference", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/should_assert_eq.md", "category": "linters", "name": "linters/clippy/should_assert_eq", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/from_raw_with_void_ptr.md", "category": "linters", "name": "linters/clippy/from_raw_with_void_ptr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/rc_clone_in_vec_init.md", "category": "linters", "name": "linters/clippy/rc_clone_in_vec_init", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/useless_let_if_seq.md", "category": "linters", "name": "linters/clippy/useless_let_if_seq", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/significant_drop_tightening.md", "category": "linters", "name": "linters/clippy/significant_drop_tightening", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_with_drain.md", "category": "linters", "name": "linters/clippy/iter_with_drain", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/separated_literal_suffix.md", "category": "linters", "name": "linters/clippy/separated_literal_suffix", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unwrap_in_result.md", "category": "linters", "name": "linters/clippy/unwrap_in_result", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ptr_offset_with_cast.md", "category": "linters", "name": "linters/clippy/ptr_offset_with_cast", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/string_add_assign.md", "category": "linters", "name": "linters/clippy/string_add_assign", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/single_char_pattern.md", "category": "linters", "name": "linters/clippy/single_char_pattern", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/range_minus_one.md", "category": "linters", "name": "linters/clippy/range_minus_one", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_const_for_thread_local.md", "category": "linters", "name": "linters/clippy/missing_const_for_thread_local", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/path_ends_with_ext.md", "category": "linters", "name": "linters/clippy/path_ends_with_ext", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/lines_filter_map_ok.md", "category": "linters", "name": "linters/clippy/lines_filter_map_ok", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/doc_link_with_quotes.md", "category": "linters", "name": "linters/clippy/doc_link_with_quotes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/map_flatten.md", "category": "linters", "name": "linters/clippy/map_flatten", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/inline_fn_without_body.md", "category": "linters", "name": "linters/clippy/inline_fn_without_body", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/collapsible_else_if.md", "category": "linters", "name": "linters/clippy/collapsible_else_if", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/single_range_in_vec_init.md", "category": "linters", "name": "linters/clippy/single_range_in_vec_init", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/duplicated_attributes.md", "category": "linters", "name": "linters/clippy/duplicated_attributes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_raw_string_hashes.md", "category": "linters", "name": "linters/clippy/needless_raw_string_hashes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_map_on_constructor.md", "category": "linters", "name": "linters/clippy/unnecessary_map_on_constructor", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/extend_with_drain.md", "category": "linters", "name": "linters/clippy/extend_with_drain", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/empty_structs_with_brackets.md", "category": "linters", "name": "linters/clippy/empty_structs_with_brackets", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/pointer_format.md", "category": "linters", "name": "linters/clippy/pointer_format", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/question_mark.md", "category": "linters", "name": "linters/clippy/question_mark", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/wrong_self_convention.md", "category": "linters", "name": "linters/clippy/wrong_self_convention", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/enum_clike_unportable_variant.md", "category": "linters", "name": "linters/clippy/enum_clike_unportable_variant", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unneeded_wildcard_pattern.md", "category": "linters", "name": "linters/clippy/unneeded_wildcard_pattern", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/if_same_then_else.md", "category": "linters", "name": "linters/clippy/if_same_then_else", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/repr_packed_without_abi.md", "category": "linters", "name": "linters/clippy/repr_packed_without_abi", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/skip_while_next.md", "category": "linters", "name": "linters/clippy/skip_while_next", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/enum_glob_use.md", "category": "linters", "name": "linters/clippy/enum_glob_use", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_assert_message.md", "category": "linters", "name": "linters/clippy/missing_assert_message", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_first_then_check.md", "category": "linters", "name": "linters/clippy/unnecessary_first_then_check", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/serde_api_misuse.md", "category": "linters", "name": "linters/clippy/serde_api_misuse", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/len_without_is_empty.md", "category": "linters", "name": "linters/clippy/len_without_is_empty", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/deprecated_clippy_cfg_attr.md", "category": "linters", "name": "linters/clippy/deprecated_clippy_cfg_attr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/char_indices_as_byte_indices.md", "category": "linters", "name": "linters/clippy/char_indices_as_byte_indices", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/uninit_assumed_init.md", "category": "linters", "name": "linters/clippy/uninit_assumed_init", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/expect_fun_call.md", "category": "linters", "name": "linters/clippy/expect_fun_call", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/as_conversions.md", "category": "linters", "name": "linters/clippy/as_conversions", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/invalid_upcast_comparisons.md", "category": "linters", "name": "linters/clippy/invalid_upcast_comparisons", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/await_holding_lock.md", "category": "linters", "name": "linters/clippy/await_holding_lock", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_memcpy.md", "category": "linters", "name": "linters/clippy/manual_memcpy", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_pattern_matching.md", "category": "linters", "name": "linters/clippy/redundant_pattern_matching", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/shadow_reuse.md", "category": "linters", "name": "linters/clippy/shadow_reuse", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_ok_or.md", "category": "linters", "name": "linters/clippy/manual_ok_or", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/semicolon_inside_block.md", "category": "linters", "name": "linters/clippy/semicolon_inside_block", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/pedantic.md", "category": "linters", "name": "linters/clippy/pedantic", "content": "# Clippy Pedantic Lints\n\nMore opinionated lints. Default: allow. Enable with:\n\n```rust\n#![warn(clippy::pedantic)]\n```\n\n## bool_to_int_with_if\n\nConverting bool to int with if.\n\n```rust\n// BAD\nif condition { 1 } else { 0 }\n\n// GOOD\ni32::from(condition)\ncondition as i32\n```\n\n## borrow_as_ptr\n\nBorrow then cast to pointer.\n\n```rust\n// BAD\nlet ptr = &x as *const _;\n\n// GOOD\nlet ptr = std::ptr::addr_of!(x);\n```\n\n## case_sensitive_file_extension_comparisons\n\nCase-sensitive extension comparison.\n\n```rust\n// BAD\npath.extension() == Some(\"TXT\")  // misses \"txt\"\n\n// GOOD\npath.extension()\n    .map(|e| e.eq_ignore_ascii_case(\"txt\"))\n    .unwrap_or(false)\n```\n\n## cast_lossless\n\nCast that could be lossless.\n\n```rust\n// BAD\nlet x = small as u64;\n\n// GOOD\nlet x = u64::from(small);\n```\n\n## cast_possible_truncation\n\nCast that may truncate.\n\n```rust\n// BAD\nlet x = big as u8;  // may truncate\n\n// GOOD\nlet x = u8::try_from(big)?;\nlet x = big.try_into()?;\n```\n\n## cast_possible_wrap\n\nCast that may wrap.\n\n```rust\n// BAD\nlet signed = unsigned as i32;  // may wrap\n\n// GOOD\nlet signed = i32::try_from(unsigned)?;\n```\n\n## cast_precision_loss\n\nFloat cast losing precision.\n\n```rust\n// BAD\nlet f = big_int as f32;  // loses precision for large values\n\n// GOOD - be explicit about precision loss\n#[allow(clippy::cast_precision_loss)]\nlet f = big_int as f32;\n```\n\n## cast_sign_loss\n\nCast losing sign.\n\n```rust\n// BAD\nlet unsigned = signed as u32;  // negative becomes large positive\n\n// GOOD\nlet unsigned = u32::try_from(signed)?;\n```\n\n## checked_conversions\n\nUnchecked numeric conversions.\n\n```rust\n// BAD\nlet y = x as u16;\n\n// GOOD\nlet y = u16::try_from(x)?;\n```\n\n## cloned_instead_of_copied\n\nUsing cloned() on Copy type.\n\n```rust\n// BAD\niter.cloned()  // where items are Copy\n\n// GOOD\niter.copied()\n```\n\n## cognitive_complexity\n\nFunction too complex.\n\n```rust\n// BAD - high cyclomatic/cognitive complexity\nfn complex() {\n    if a {\n        if b {\n            for x in items {\n                if c {\n                    match d {\n                        // ...\n                    }\n                }\n            }\n        }\n    }\n}\n\n// GOOD - extract functions\nfn complex() {\n    if a && b {\n        process_items();\n    }\n}\n```\n\n## copy_iterator\n\nIterator implementing Copy.\n\n```rust\n// BAD - Copy iterators can be accidentally advanced\n#[derive(Copy)]\nstruct MyIter { pos: usize }\n\n// GOOD - iterators should be Clone, not Copy\n#[derive(Clone)]\nstruct MyIter { pos: usize }\n```\n\n## doc_markdown\n\nCode in docs without backticks.\n\n```rust\n// BAD\n/// This function uses HashMap.\n\n// GOOD\n/// This function uses `HashMap`.\n```\n\n## empty_enum\n\nEmpty enum.\n\n```rust\n// BAD (unless intentional as never type)\nenum Empty {}\n\n// GOOD - use never type\nfn never_returns() -> ! {\n    loop {}\n}\n```\n\n## enum_glob_use\n\nGlob import of enum.\n\n```rust\n// BAD\nuse MyEnum::*;\n\n// GOOD\nuse MyEnum::{Variant1, Variant2};\n```\n\n## expl_impl_clone_on_copy\n\nExplicit Clone on Copy type.\n\n```rust\n// BAD\n#[derive(Copy)]\nstruct Foo(i32);\n\nimpl Clone for Foo {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\n// GOOD\n#[derive(Copy, Clone)]\nstruct Foo(i32);\n```\n\n## explicit_deref_methods\n\nCalling deref() explicitly.\n\n```rust\n// BAD\n(*x).deref()\nx.deref().deref()\n\n// GOOD\n&**x\n```\n\n## explicit_into_iter_loop\n\nExplicit into_iter() in loop.\n\n```rust\n// BAD\nfor x in vec.into_iter() { }\n\n// GOOD\nfor x in vec { }\n```\n\n## filter_map_next\n\nfilter_map + next.\n\n```rust\n// BAD\niter.filter_map(f).next()\n\n// GOOD\niter.find_map(f)\n```\n\n## fn_params_excessive_bools\n\nToo many bool parameters.\n\n```rust\n// BAD\nfn configure(a: bool, b: bool, c: bool, d: bool) { }\n\n// GOOD - use struct or builder\nstruct Config { a: bool, b: bool, c: bool, d: bool }\nfn configure(config: Config) { }\n```\n\n## if_not_else\n\nif !condition with else.\n\n```rust\n// BAD\nif !condition {\n    foo();\n} else {\n    bar();\n}\n\n// GOOD\nif condition {\n    bar();\n} else {\n    foo();\n}\n```\n\n## implicit_hasher\n\nGeneric over hasher but using default.\n\n```rust\n// BAD\nfn foo(map: &HashMap<K, V>) { }\n\n// GOOD - generic over hasher\nfn foo<S: BuildHasher>(map: &HashMap<K, V, S>) { }\n```\n\n## inconsistent_struct_constructor\n\nStruct fields in different order than definition.\n\n```rust\nstruct Foo { a: i32, b: i32, c: i32 }\n\n// BAD\nFoo { c: 3, a: 1, b: 2 }\n\n// GOOD\nFoo { a: 1, b: 2, c: 3 }\n```\n\n## inefficient_to_string\n\nUsing to_string() on Display type.\n\n```rust\n// BAD\nformat!(\"{}\", x).len()\n\n// GOOD\nx.to_string().len()\n```\n\n## inline_always\n\nUsing #[inline(always)].\n\n```rust\n// BAD - usually let compiler decide\n#[inline(always)]\nfn small() { }\n\n// GOOD\n#[inline]\nfn small() { }\n```\n\n## items_after_statements\n\nItems after statements.\n\n```rust\n// BAD\nfn foo() {\n    let x = 1;\n    struct Bar;  // item after statement\n}\n\n// GOOD\nfn foo() {\n    struct Bar;\n    let x = 1;\n}\n```\n\n## iter_not_returning_iterator\n\niter() not returning Iterator.\n\n```rust\n// BAD\nimpl Foo {\n    fn iter(&self) -> Vec<&Item> { }\n}\n\n// GOOD\nimpl Foo {\n    fn iter(&self) -> impl Iterator<Item = &Item> { }\n}\n```\n\n## large_digit_groups\n\nLarge digit groups.\n\n```rust\n// BAD\nlet x = 1_000_0000;\n\n// GOOD\nlet x = 10_000_000;\n```\n\n## large_types_passed_by_value\n\nLarge types passed by value.\n\n```rust\n// BAD\nfn process(data: [u8; 1024]) { }\n\n// GOOD\nfn process(data: &[u8; 1024]) { }\n```\n\n## linkedlist\n\nUsing LinkedList.\n\n```rust\n// BAD - usually slower than Vec\nlet list: LinkedList<T> = LinkedList::new();\n\n// GOOD - prefer Vec or VecDeque\nlet vec: Vec<T> = Vec::new();\nlet deque: VecDeque<T> = VecDeque::new();\n```\n\n## manual_assert\n\nManual panic with condition.\n\n```rust\n// BAD\nif !condition {\n    panic!(\"message\");\n}\n\n// GOOD\nassert!(condition, \"message\");\n```\n\n## manual_instant_elapsed\n\nManual instant elapsed calculation.\n\n```rust\n// BAD\nlet elapsed = Instant::now().duration_since(start);\n\n// GOOD\nlet elapsed = start.elapsed();\n```\n\n## manual_let_else\n\nManual let else pattern.\n\n```rust\n// BAD\nlet x = match opt {\n    Some(x) => x,\n    None => return,\n};\n\n// GOOD (Rust 1.65+)\nlet Some(x) = opt else { return };\n```\n\n## manual_string_new\n\nManual String::new().\n\n```rust\n// BAD\nlet s = String::from(\"\");\nlet s = \"\".to_string();\n\n// GOOD\nlet s = String::new();\n```\n\n## map_unwrap_or\n\nmap + unwrap_or.\n\n```rust\n// BAD\nopt.map(f).unwrap_or(default)\n\n// GOOD\nopt.map_or(default, f)\n```\n\n## match_bool\n\nMatch on boolean.\n\n```rust\n// BAD\nmatch b {\n    true => foo(),\n    false => bar(),\n}\n\n// GOOD\nif b { foo() } else { bar() }\n```\n\n## match_on_vec_items\n\nMatching on Vec items by index.\n\n```rust\n// BAD\nmatch vec[0] {\n    x => { }\n}\n\n// GOOD\nmatch vec.first() {\n    Some(x) => { }\n    None => { }\n}\n```\n\n## match_same_arms\n\nMatch arms with same body.\n\n```rust\n// BAD\nmatch x {\n    A => foo(),\n    B => foo(),\n    C => bar(),\n}\n\n// GOOD\nmatch x {\n    A | B => foo(),\n    C => bar(),\n}\n```\n\n## match_wildcard_for_single_variants\n\nWildcard for single remaining variant.\n\n```rust\n// BAD\nmatch opt {\n    Some(x) => x,\n    _ => 0,  // only None left\n}\n\n// GOOD\nmatch opt {\n    Some(x) => x,\n    None => 0,\n}\n```\n\n## maybe_infinite_iter\n\nPotentially infinite iterator.\n\n```rust\n// BAD\n(0..).filter(f).collect::<Vec<_>>();  // may never terminate\n\n// GOOD\n(0..100).filter(f).collect::<Vec<_>>();\n```\n\n## missing_const_for_fn\n\nFunction could be const.\n\n```rust\n// BAD\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n// GOOD\nconst fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n```\n\n## missing_errors_doc\n\nMissing # Errors in doc.\n\n```rust\n// BAD\n/// Does something.\nfn fallible() -> Result<(), Error> { }\n\n// GOOD\n/// Does something.\n///\n/// # Errors\n/// Returns `Err` if something fails.\nfn fallible() -> Result<(), Error> { }\n```\n\n## missing_panics_doc\n\nMissing # Panics in doc.\n\n```rust\n// BAD\n/// Gets value.\nfn get(idx: usize) -> &T {\n    &self.data[idx]  // may panic\n}\n\n// GOOD\n/// Gets value.\n///\n/// # Panics\n/// Panics if index is out of bounds.\nfn get(idx: usize) -> &T {\n    &self.data[idx]\n}\n```\n\n## module_name_repetitions\n\nType name repeats module name.\n\n```rust\n// BAD\nmod foo {\n    struct FooBar;\n}\n\n// GOOD\nmod foo {\n    struct Bar;\n}\n```\n\n## must_use_candidate\n\nFunction should be #[must_use].\n\n```rust\n// BAD\nfn compute() -> i32 { 42 }\n\n// GOOD\n#[must_use]\nfn compute() -> i32 { 42 }\n```\n\n## needless_continue\n\nUnnecessary continue.\n\n```rust\n// BAD\nfor x in iter {\n    if condition {\n        foo();\n    } else {\n        continue;\n    }\n}\n\n// GOOD\nfor x in iter {\n    if condition {\n        foo();\n    }\n}\n```\n\n## needless_for_each\n\nUnnecessary for_each.\n\n```rust\n// BAD\niter.for_each(|x| println!(\"{}\", x));\n\n// GOOD\nfor x in iter {\n    println!(\"{}\", x);\n}\n```\n\n## needless_pass_by_value\n\nUnnecessary ownership.\n\n```rust\n// BAD\nfn foo(s: String) {\n    println!(\"{}\", s);\n}\n\n// GOOD\nfn foo(s: &str) {\n    println!(\"{}\", s);\n}\n```\n\n## no_effect_underscore_binding\n\nBinding with no effect.\n\n```rust\n// BAD\nlet _x = expensive();  // computed but unused\n\n// GOOD\nlet _ = expensive();  // if intentionally discarding\n// Or remove if not needed\n```\n\n## option_option\n\nOption<Option<T>>.\n\n```rust\n// BAD\nfn foo() -> Option<Option<i32>> { }\n\n// GOOD - flatten or use different representation\nfn foo() -> Option<i32> { }\n```\n\n## range_minus_one\n\nRange with minus one.\n\n```rust\n// BAD\nfor i in 0..len - 1 { }\n\n// GOOD\nfor i in 0..len.saturating_sub(1) { }\nfor i in 0..=len.saturating_sub(1) { }\n```\n\n## range_plus_one\n\nRange with plus one.\n\n```rust\n// BAD\nfor i in 0..len + 1 { }\n\n// GOOD\nfor i in 0..=len { }\n```\n\n## redundant_closure_for_method_calls\n\nRedundant closure for method.\n\n```rust\n// BAD\niter.map(|x| x.to_string())\n\n// GOOD\niter.map(ToString::to_string)\n```\n\n## ref_binding_to_reference\n\nRef binding on reference.\n\n```rust\n// BAD\nlet ref x = &y;\n\n// GOOD\nlet x = &y;\n```\n\n## return_self_not_must_use\n\nBuilder method not #[must_use].\n\n```rust\n// BAD\nfn with_name(mut self, name: &str) -> Self {\n    self.name = name.into();\n    self\n}\n\n// GOOD\n#[must_use]\nfn with_name(mut self, name: &str) -> Self {\n    self.name = name.into();\n    self\n}\n```\n\n## semicolon_if_nothing_returned\n\nMissing semicolon on unit return.\n\n```rust\n// BAD\nfn foo() {\n    bar()  // returns (), missing semicolon\n}\n\n// GOOD\nfn foo() {\n    bar();\n}\n```\n\n## similar_names\n\nSimilar variable names.\n\n```rust\n// BAD\nlet item = get();\nlet items = vec![];\n\n// GOOD - more distinct names\nlet current_item = get();\nlet all_items = vec![];\n```\n\n## single_match_else\n\nSingle match with else.\n\n```rust\n// BAD\nmatch opt {\n    Some(x) => foo(x),\n    _ => bar(),\n}\n\n// GOOD\nif let Some(x) = opt {\n    foo(x);\n} else {\n    bar();\n}\n```\n\n## string_add_assign\n\nUsing + for string append.\n\n```rust\n// BAD\ns = s + &other;\n\n// GOOD\ns += &other;\ns.push_str(&other);\n```\n\n## struct_excessive_bools\n\nStruct with many bools.\n\n```rust\n// BAD\nstruct Config {\n    a: bool,\n    b: bool,\n    c: bool,\n    d: bool,\n}\n\n// GOOD - use bitflags or enum\nbitflags! {\n    struct ConfigFlags: u32 {\n        const A = 1;\n        const B = 2;\n        const C = 4;\n        const D = 8;\n    }\n}\n```\n\n## too_many_arguments\n\nToo many function arguments.\n\n```rust\n// BAD\nfn configure(a: i32, b: i32, c: i32, d: i32, e: i32, f: i32, g: i32) { }\n\n// GOOD\nstruct Config { a: i32, b: i32, c: i32, d: i32, e: i32, f: i32, g: i32 }\nfn configure(config: Config) { }\n```\n\n## too_many_lines\n\nFunction too long.\n\n```rust\n// Keep functions under ~100 lines\n// Extract helper functions\n```\n\n## trivially_copy_pass_by_ref\n\nCopy type passed by reference.\n\n```rust\n// BAD\nfn foo(x: &i32) { }\n\n// GOOD - small Copy types by value\nfn foo(x: i32) { }\n```\n\n## type_repetition_in_bounds\n\nRepeated type in bounds.\n\n```rust\n// BAD\nfn foo<T: Clone + Clone>() { }\n\n// GOOD\nfn foo<T: Clone>() { }\n```\n\n## unicode_not_nfc\n\nNon-NFC unicode.\n\n```rust\n// BAD\nlet s = \"caf\u00e9\";  // might use combining characters\n\n// GOOD - normalize\nlet s = \"caf\u00e9\";  // precomposed \u00e9\n```\n\n## uninlined_format_args\n\nFormat args not inlined.\n\n```rust\n// BAD\nprintln!(\"{}\", x);\nformat!(\"{}\", y);\n\n// GOOD (Rust 1.58+)\nprintln!(\"{x}\");\nformat!(\"{y}\");\n```\n\n## unnecessary_join\n\nUnnecessary join.\n\n```rust\n// BAD\n[\"a\", \"b\"].join(\"\")\n\n// GOOD\n[\"a\", \"b\"].concat()\n```\n\n## unnecessary_wraps\n\nUnnecessary Option/Result wrapping.\n\n```rust\n// BAD - always returns Some/Ok\nfn foo() -> Option<i32> {\n    Some(42)\n}\n\n// GOOD\nfn foo() -> i32 {\n    42\n}\n```\n\n## unnested_or_patterns\n\nUn-nested or patterns.\n\n```rust\n// BAD\nmatch x {\n    A(a) | B(a) => { }\n}\n\n// GOOD\nmatch x {\n    A(a) | B(a) => { }\n}\n```\n\n## unreadable_literal\n\nLarge number without separators.\n\n```rust\n// BAD\nlet x = 1000000;\n\n// GOOD\nlet x = 1_000_000;\n```\n\n## unused_async\n\nAsync function without await.\n\n```rust\n// BAD\nasync fn foo() {\n    sync_operation();\n}\n\n// GOOD\nfn foo() {\n    sync_operation();\n}\n```\n\n## unused_self\n\nUnused self parameter.\n\n```rust\n// BAD\nimpl Foo {\n    fn bar(&self) {\n        println!(\"hello\");\n    }\n}\n\n// GOOD - make it associated function\nimpl Foo {\n    fn bar() {\n        println!(\"hello\");\n    }\n}\n```\n\n## used_underscore_binding\n\nUsing underscore binding.\n\n```rust\n// BAD\nlet _x = 5;\nprintln!(\"{}\", _x);  // underscore prefix means unused!\n\n// GOOD\nlet x = 5;\nprintln!(\"{}\", x);\n```\n\n## wildcard_imports\n\nWildcard imports.\n\n```rust\n// BAD\nuse std::collections::*;\n\n// GOOD\nuse std::collections::{HashMap, HashSet};\n```\n"}, {"path": "linters/clippy/mixed_read_write_in_expression.md", "category": "linters", "name": "linters/clippy/mixed_read_write_in_expression", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_lifetimes.md", "category": "linters", "name": "linters/clippy/needless_lifetimes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_test_prefix.md", "category": "linters", "name": "linters/clippy/redundant_test_prefix", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cast_ptr_alignment.md", "category": "linters", "name": "linters/clippy/cast_ptr_alignment", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/octal_escapes.md", "category": "linters", "name": "linters/clippy/octal_escapes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/precedence.md", "category": "linters", "name": "linters/clippy/precedence", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mut_from_ref.md", "category": "linters", "name": "linters/clippy/mut_from_ref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/derived_hash_with_manual_eq.md", "category": "linters", "name": "linters/clippy/derived_hash_with_manual_eq", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/let_underscore_lock.md", "category": "linters", "name": "linters/clippy/let_underscore_lock", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_fields_in_debug.md", "category": "linters", "name": "linters/clippy/missing_fields_in_debug", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/collapsible_match.md", "category": "linters", "name": "linters/clippy/collapsible_match", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/tuple_array_conversions.md", "category": "linters", "name": "linters/clippy/tuple_array_conversions", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ok_expect.md", "category": "linters", "name": "linters/clippy/ok_expect", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_min_or_max.md", "category": "linters", "name": "linters/clippy/unnecessary_min_or_max", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/decimal_literal_representation.md", "category": "linters", "name": "linters/clippy/decimal_literal_representation", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_closure.md", "category": "linters", "name": "linters/clippy/redundant_closure", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious_open_options.md", "category": "linters", "name": "linters/clippy/suspicious_open_options", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/pub_without_shorthand.md", "category": "linters", "name": "linters/clippy/pub_without_shorthand", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/bind_instead_of_map.md", "category": "linters", "name": "linters/clippy/bind_instead_of_map", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_dangling_ptr.md", "category": "linters", "name": "linters/clippy/manual_dangling_ptr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/field_scoped_visibility_modifiers.md", "category": "linters", "name": "linters/clippy/field_scoped_visibility_modifiers", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_hash_one.md", "category": "linters", "name": "linters/clippy/manual_hash_one", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/bad_bit_mask.md", "category": "linters", "name": "linters/clippy/bad_bit_mask", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/lint_groups_priority.md", "category": "linters", "name": "linters/clippy/lint_groups_priority", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/struct_excessive_bools.md", "category": "linters", "name": "linters/clippy/struct_excessive_bools", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/option_map_or_err_ok.md", "category": "linters", "name": "linters/clippy/option_map_or_err_ok", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/await_holding_refcell_ref.md", "category": "linters", "name": "linters/clippy/await_holding_refcell_ref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/writeln_empty_string.md", "category": "linters", "name": "linters/clippy/writeln_empty_string", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_retain.md", "category": "linters", "name": "linters/clippy/manual_retain", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_static_lifetimes.md", "category": "linters", "name": "linters/clippy/redundant_static_lifetimes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/option_filter_map.md", "category": "linters", "name": "linters/clippy/option_filter_map", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/clear_with_drain.md", "category": "linters", "name": "linters/clippy/clear_with_drain", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_docs_in_private_items.md", "category": "linters", "name": "linters/clippy/missing_docs_in_private_items", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/map_unwrap_or.md", "category": "linters", "name": "linters/clippy/map_unwrap_or", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/map_all_any_identity.md", "category": "linters", "name": "linters/clippy/map_all_any_identity", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/borrowed_box.md", "category": "linters", "name": "linters/clippy/borrowed_box", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/main_recursion.md", "category": "linters", "name": "linters/clippy/main_recursion", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/disallowed_script_idents.md", "category": "linters", "name": "linters/clippy/disallowed_script_idents", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_unwrap.md", "category": "linters", "name": "linters/clippy/unnecessary_unwrap", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_join.md", "category": "linters", "name": "linters/clippy/unnecessary_join", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_raw_strings.md", "category": "linters", "name": "linters/clippy/needless_raw_strings", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_maybe_sized.md", "category": "linters", "name": "linters/clippy/needless_maybe_sized", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/duplicate_mod.md", "category": "linters", "name": "linters/clippy/duplicate_mod", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_slice_fill.md", "category": "linters", "name": "linters/clippy/manual_slice_fill", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_as_str.md", "category": "linters", "name": "linters/clippy/redundant_as_str", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_borrows_for_generic_args.md", "category": "linters", "name": "linters/clippy/needless_borrows_for_generic_args", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/little_endian_bytes.md", "category": "linters", "name": "linters/clippy/little_endian_bytes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/transmute_ptr_to_ptr.md", "category": "linters", "name": "linters/clippy/transmute_ptr_to_ptr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/pattern_type_mismatch.md", "category": "linters", "name": "linters/clippy/pattern_type_mismatch", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/regex_macro.md", "category": "linters", "name": "linters/clippy/regex_macro", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_option_as_deref.md", "category": "linters", "name": "linters/clippy/needless_option_as_deref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/string_from_utf8_as_bytes.md", "category": "linters", "name": "linters/clippy/string_from_utf8_as_bytes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/zero_divided_by_zero.md", "category": "linters", "name": "linters/clippy/zero_divided_by_zero", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/deref_by_slicing.md", "category": "linters", "name": "linters/clippy/deref_by_slicing", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/match_ref_pats.md", "category": "linters", "name": "linters/clippy/match_ref_pats", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious.md", "category": "linters", "name": "linters/clippy/suspicious", "content": "# Clippy Suspicious Lints\n\nLints that detect very suspicious code patterns.\n\n## almost_complete_range\n\nAlmost complete range.\n\n```rust\n// BAD\n'a'..'z'  // missing 'z'!\n'A'..'Z'\n\n// GOOD\n'a'..='z'\n'A'..='Z'\n```\n\n## arc_with_non_send_sync\n\nArc with non-Send/Sync type.\n\n```rust\n// BAD - Arc is for thread-safe sharing\nArc::new(Rc::new(5));  // Rc is not Send/Sync\n\n// GOOD\nArc::new(5);  // i32 is Send + Sync\n```\n\n## await_holding_lock\n\nHolding lock across await.\n\n```rust\n// BAD\nasync fn foo(mutex: &Mutex<i32>) {\n    let guard = mutex.lock().unwrap();\n    bar().await;  // lock held during await!\n}\n\n// GOOD\nasync fn foo(mutex: &Mutex<i32>) {\n    {\n        let guard = mutex.lock().unwrap();\n        // use guard\n    }  // guard dropped\n    bar().await;\n}\n```\n\n## await_holding_refcell_ref\n\nHolding RefCell borrow across await.\n\n```rust\n// BAD\nasync fn foo(cell: &RefCell<i32>) {\n    let borrow = cell.borrow();\n    bar().await;  // borrow held during await!\n}\n\n// GOOD\nasync fn foo(cell: &RefCell<i32>) {\n    let value = *cell.borrow();\n    bar().await;\n}\n```\n\n## blanket_clippy_restriction_lints\n\nEnabling all restriction lints.\n\n```rust\n// BAD - too aggressive\n#![warn(clippy::restriction)]\n\n// GOOD - enable specific ones\n#![warn(clippy::unwrap_used)]\n#![warn(clippy::expect_used)]\n```\n\n## cast_abs_to_unsigned\n\nCasting abs() result to unsigned.\n\n```rust\n// BAD - abs(i32::MIN) overflows\nlet x = (value.abs()) as u32;\n\n// GOOD\nlet x = value.unsigned_abs();\n```\n\n## cast_enum_constructor\n\nCasting enum constructor.\n\n```rust\n// BAD\nlet f = Some as fn(i32) -> Option<i32>;\n\n// GOOD\nlet f: fn(i32) -> Option<i32> = Some;\n```\n\n## cast_enum_truncation\n\nEnum cast may truncate.\n\n```rust\n// BAD\n#[repr(u32)]\nenum Big { A = 1000 }\nlet x = Big::A as u8;  // truncates!\n\n// GOOD\nlet x = Big::A as u32;\n```\n\n## cast_nan_to_int\n\nCasting NaN to int.\n\n```rust\n// BAD\nlet x = f64::NAN as i32;  // undefined!\n\n// GOOD\nlet x = if f.is_nan() { 0 } else { f as i32 };\n```\n\n## cast_slice_different_sizes\n\nCasting slice to different-sized type.\n\n```rust\n// BAD\nlet bytes: &[u8] = &[1, 2, 3, 4];\nlet ints: &[u32] = unsafe { \n    std::slice::from_raw_parts(bytes.as_ptr() as *const u32, bytes.len())\n};  // wrong length!\n\n// GOOD - calculate correct length\nlet ints: &[u32] = unsafe {\n    std::slice::from_raw_parts(\n        bytes.as_ptr() as *const u32,\n        bytes.len() / std::mem::size_of::<u32>()\n    )\n};\n```\n\n## compare_self\n\nComparing self to self.\n\n```rust\n// BAD\nimpl PartialEq for Foo {\n    fn eq(&self, other: &Self) -> bool {\n        self == self  // comparing to self!\n    }\n}\n\n// GOOD\nimpl PartialEq for Foo {\n    fn eq(&self, other: &Self) -> bool {\n        self.value == other.value\n    }\n}\n```\n\n## const_is_empty\n\nUsing is_empty on const.\n\n```rust\n// BAD - always same result\nconst EMPTY: &str = \"\";\nif EMPTY.is_empty() { }  // always true\n\n// Remove the check or use runtime value\n```\n\n## crate_in_macro_def\n\nUsing $crate incorrectly.\n\n```rust\n// BAD\nmacro_rules! foo {\n    () => { crate::bar() };  // breaks when used from other crates\n}\n\n// GOOD\nmacro_rules! foo {\n    () => { $crate::bar() };\n}\n```\n\n## drop_non_drop\n\nCalling drop on non-Drop type.\n\n```rust\n// BAD - no effect\nlet x = 5;\ndrop(x);  // i32 doesn't implement Drop\n\n// Just let it go out of scope\n```\n\n## duplicate_mod\n\nDuplicate module declaration.\n\n```rust\n// BAD\nmod foo;\nmod foo;  // duplicate\n\n// GOOD\nmod foo;\n```\n\n## empty_loop\n\nEmpty loop body.\n\n```rust\n// BAD - busy loop\nloop {}\n\n// GOOD - hint or yield\nloop {\n    std::hint::spin_loop();\n}\n```\n\n## float_equality_without_abs\n\nFloat comparison without abs.\n\n```rust\n// BAD\n(a - b) < f64::EPSILON  // wrong if a < b\n\n// GOOD\n(a - b).abs() < f64::EPSILON\n```\n\n## for_loops_over_fallibles\n\nLooping over Option/Result.\n\n```rust\n// BAD\nfor x in Some(5) { }\nfor x in Ok::<_, ()>(5) { }\n\n// GOOD\nif let Some(x) = opt { }\nif let Ok(x) = result { }\n```\n\n## from_raw_with_void_ptr\n\nfrom_raw with void pointer.\n\n```rust\n// BAD\nlet boxed = unsafe { Box::from_raw(ptr as *mut ()) };\n\n// Cast to correct type\nlet boxed = unsafe { Box::from_raw(ptr as *mut Actual) };\n```\n\n## get_unwrap\n\nUsing get().unwrap().\n\n```rust\n// BAD\nlet x = vec.get(0).unwrap();\nlet x = map.get(&key).unwrap();\n\n// GOOD\nlet x = &vec[0];\nlet x = &map[&key];\n\n// Or handle None\nlet x = vec.get(0)?;\n```\n\n## ineffective_open_options\n\nOpen options that cancel out.\n\n```rust\n// BAD\nFile::options()\n    .write(true)\n    .write(false)  // cancels previous!\n    .open(path)?;\n```\n\n## iter_out_of_bounds\n\nIterator index out of bounds.\n\n```rust\n// BAD\nlet arr = [1, 2, 3];\narr.iter().skip(10).next();  // always None\n```\n\n## let_underscore_future\n\nDropping future without awaiting.\n\n```rust\n// BAD\nlet _ = async_fn();  // never runs!\n\n// GOOD\nasync_fn().await;\n```\n\n## let_underscore_must_use\n\nDropping must_use value.\n\n```rust\n// BAD\nlet _ = mutex.lock();  // lock immediately dropped!\n\n// GOOD\nlet _guard = mutex.lock();\n```\n\n## mismatched_target_os\n\nWrong target_os value.\n\n```rust\n// BAD\n#[cfg(target_os = \"linux\")]  // lowercase\n#[cfg(target_os = \"MacOS\")]  // should be \"macos\"\n\n// GOOD\n#[cfg(target_os = \"linux\")]\n#[cfg(target_os = \"macos\")]\n```\n\n## multi_assignments\n\nMultiple assignments in one statement.\n\n```rust\n// BAD\na = b = c;  // confusing\n\n// GOOD\nb = c;\na = b;\n```\n\n## mut_from_ref\n\nMutable from immutable reference.\n\n```rust\n// BAD\nfn foo(&self) -> &mut T {\n    unsafe { &mut *self.ptr }  // suspicious\n}\n\n// GOOD - if mutation needed, take &mut self\nfn foo(&mut self) -> &mut T {\n    unsafe { &mut *self.ptr }\n}\n```\n\n## mutable_key_type\n\nMutable type as map key.\n\n```rust\n// BAD - mutating key breaks map\nlet mut map: HashMap<Vec<i32>, i32> = HashMap::new();\n\n// GOOD - use immutable key type\nlet mut map: HashMap<String, i32> = HashMap::new();\n```\n\n## no_effect\n\nStatement with no effect.\n\n```rust\n// BAD\n0;\nx + 1;  // result discarded\n\n// GOOD\nlet _ = x + 1;  // explicitly discard\nx += 1;  // or modify\n```\n\n## no_mangle_with_rust_abi\n\n#[no_mangle] with Rust ABI.\n\n```rust\n// BAD - Rust ABI is unstable\n#[no_mangle]\nfn foo() { }\n\n// GOOD - specify C ABI for FFI\n#[no_mangle]\nextern \"C\" fn foo() { }\n```\n\n## non_canonical_clone_impl\n\nClone impl that doesn't use clone.\n\n```rust\n// BAD\nimpl Clone for Foo {\n    fn clone(&self) -> Self {\n        Self { x: self.x }  // manual copy\n    }\n}\n\n// GOOD\nimpl Clone for Foo {\n    fn clone(&self) -> Self {\n        *self  // or derive\n    }\n}\n```\n\n## non_canonical_partial_ord_impl\n\nPartialOrd without using cmp.\n\n```rust\n// BAD\nimpl PartialOrd for Foo {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        if self.x < other.x { Some(Ordering::Less) }\n        else if self.x > other.x { Some(Ordering::Greater) }\n        else { Some(Ordering::Equal) }\n    }\n}\n\n// GOOD\nimpl PartialOrd for Foo {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        self.x.partial_cmp(&other.x)\n    }\n}\n```\n\n## path_ends_with_ext\n\nPath ends_with for extension.\n\n```rust\n// BAD\npath.to_str().unwrap().ends_with(\".txt\")\n\n// GOOD\npath.extension() == Some(OsStr::new(\"txt\"))\n```\n\n## print_in_format_impl\n\nPrinting in format implementation.\n\n```rust\n// BAD\nimpl Display for Foo {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        println!(\"debug\");  // side effect in formatting!\n        write!(f, \"{}\", self.x)\n    }\n}\n\n// GOOD - no side effects\nimpl Display for Foo {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.x)\n    }\n}\n```\n\n## suspicious_arithmetic_impl\n\nSuspicious arithmetic trait impl.\n\n```rust\n// BAD\nimpl Add for Foo {\n    fn add(self, other: Self) -> Self {\n        Self { x: self.x - other.x }  // subtraction in Add!\n    }\n}\n\n// GOOD\nimpl Add for Foo {\n    fn add(self, other: Self) -> Self {\n        Self { x: self.x + other.x }\n    }\n}\n```\n\n## suspicious_assignment_formatting\n\nSuspicious spacing around assignment.\n\n```rust\n// BAD - looks like ==\nif a =b { }\n\n// GOOD\nif a = b { }  // (though this is also suspicious)\nif a == b { }\n```\n\n## suspicious_command_arg_space\n\nSpace in command argument.\n\n```rust\n// BAD\nCommand::new(\"ls\").arg(\"-la /tmp\");  // one arg with space\n\n// GOOD\nCommand::new(\"ls\").args([\"-la\", \"/tmp\"]);  // separate args\n```\n\n## suspicious_doc_comments\n\nSuspicious doc comment position.\n\n```rust\n// BAD\nfn foo() {\n    /// This documents nothing\n    let x = 5;\n}\n\n// GOOD\n/// This documents foo\nfn foo() {\n    // This is a regular comment\n    let x = 5;\n}\n```\n\n## suspicious_else_formatting\n\nSuspicious else formatting.\n\n```rust\n// BAD\nif a {\n}\nelse {  // else on separate line\n}\n\n// GOOD\nif a {\n} else {\n}\n```\n\n## suspicious_map\n\nSuspicious map usage.\n\n```rust\n// BAD\nopt.map(|_| foo());  // map for side effect\n\n// GOOD\nif opt.is_some() {\n    foo();\n}\n```\n\n## suspicious_op_assign_impl\n\nSuspicious op-assign implementation.\n\n```rust\n// BAD\nimpl AddAssign for Foo {\n    fn add_assign(&mut self, other: Self) {\n        *self = Self { x: self.x - other.x };  // subtraction!\n    }\n}\n\n// GOOD\nimpl AddAssign for Foo {\n    fn add_assign(&mut self, other: Self) {\n        self.x += other.x;\n    }\n}\n```\n\n## suspicious_to_owned\n\nSuspicious to_owned call.\n\n```rust\n// BAD\nlet s: String = string.to_owned().to_owned();\n\n// GOOD\nlet s: String = string.to_owned();\n```\n\n## suspicious_unary_op_formatting\n\nSuspicious unary op formatting.\n\n```rust\n// BAD\nlet x =- 1;  // looks like x = -1, but is x -= 1 typo?\n\n// GOOD\nlet x = -1;\n```\n\n## swap_ptr_to_ref\n\nSwapping via pointers.\n\n```rust\n// BAD\nunsafe {\n    let temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n// GOOD\nstd::mem::swap(a, b);\n```\n\n## type_id_on_box\n\nCalling type_id on Box.\n\n```rust\n// BAD\nlet id = box_any.type_id();  // type_id of Box, not contents\n\n// GOOD\nlet id = (*box_any).type_id();\n```\n\n## unconditional_recursion\n\nFunction always recurses.\n\n```rust\n// BAD\nfn foo() {\n    foo();  // infinite recursion\n}\n\n// Add base case\nfn foo(n: u32) {\n    if n == 0 { return; }\n    foo(n - 1);\n}\n```\n\n## unnecessary_result_map_or_else\n\nUnnecessary result mapping.\n\n```rust\n// BAD\nresult.map_or_else(|e| Err(e), |v| Ok(v))\n\n// GOOD\nresult\n```\n\n## unusual_byte_groupings\n\nUnusual numeric groupings.\n\n```rust\n// BAD\nlet x = 0x1_23_456;  // inconsistent grouping\n\n// GOOD\nlet x = 0x12_34_56;  // consistent pairs\nlet x = 0x123_456;   // consistent triplets\n```\n"}, {"path": "linters/clippy/single_option_map.md", "category": "linters", "name": "linters/clippy/single_option_map", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_wraps.md", "category": "linters", "name": "linters/clippy/unnecessary_wraps", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/transmute_bytes_to_str.md", "category": "linters", "name": "linters/clippy/transmute_bytes_to_str", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_literal_bound.md", "category": "linters", "name": "linters/clippy/unnecessary_literal_bound", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unsafe_vector_initialization.md", "category": "linters", "name": "linters/clippy/unsafe_vector_initialization", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/min_ident_chars.md", "category": "linters", "name": "linters/clippy/min_ident_chars", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/non_send_fields_in_send_ty.md", "category": "linters", "name": "linters/clippy/non_send_fields_in_send_ty", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/empty_drop.md", "category": "linters", "name": "linters/clippy/empty_drop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_inline_in_public_items.md", "category": "linters", "name": "linters/clippy/missing_inline_in_public_items", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/default_numeric_fallback.md", "category": "linters", "name": "linters/clippy/default_numeric_fallback", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/crate_in_macro_def.md", "category": "linters", "name": "linters/clippy/crate_in_macro_def", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/map_err_ignore.md", "category": "linters", "name": "linters/clippy/map_err_ignore", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/expl_impl_clone_on_copy.md", "category": "linters", "name": "linters/clippy/expl_impl_clone_on_copy", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_skip_zero.md", "category": "linters", "name": "linters/clippy/iter_skip_zero", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ineffective_bit_mask.md", "category": "linters", "name": "linters/clippy/ineffective_bit_mask", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/set_contains_or_insert.md", "category": "linters", "name": "linters/clippy/set_contains_or_insert", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_splitn.md", "category": "linters", "name": "linters/clippy/needless_splitn", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/panic_in_result_fn.md", "category": "linters", "name": "linters/clippy/panic_in_result_fn", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/significant_drop_in_scrutinee.md", "category": "linters", "name": "linters/clippy/significant_drop_in_scrutinee", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_owned_empty_strings.md", "category": "linters", "name": "linters/clippy/unnecessary_owned_empty_strings", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/result_map_unit_fn.md", "category": "linters", "name": "linters/clippy/result_map_unit_fn", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unit_hash.md", "category": "linters", "name": "linters/clippy/unit_hash", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/absurd_extreme_comparisons.md", "category": "linters", "name": "linters/clippy/absurd_extreme_comparisons", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/map_clone.md", "category": "linters", "name": "linters/clippy/map_clone", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/result_map_or_into_option.md", "category": "linters", "name": "linters/clippy/result_map_or_into_option", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unseparated_literal_suffix.md", "category": "linters", "name": "linters/clippy/unseparated_literal_suffix", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/as_pointer_underscore.md", "category": "linters", "name": "linters/clippy/as_pointer_underscore", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unsafe_derive_deserialize.md", "category": "linters", "name": "linters/clippy/unsafe_derive_deserialize", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ref_option.md", "category": "linters", "name": "linters/clippy/ref_option", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious_operation_groupings.md", "category": "linters", "name": "linters/clippy/suspicious_operation_groupings", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/possible_missing_comma.md", "category": "linters", "name": "linters/clippy/possible_missing_comma", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/possible_missing_else.md", "category": "linters", "name": "linters/clippy/possible_missing_else", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/used_underscore_items.md", "category": "linters", "name": "linters/clippy/used_underscore_items", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/implicit_saturating_add.md", "category": "linters", "name": "linters/clippy/implicit_saturating_add", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_safety_doc.md", "category": "linters", "name": "linters/clippy/unnecessary_safety_doc", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mem_replace_with_default.md", "category": "linters", "name": "linters/clippy/mem_replace_with_default", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/zero_ptr.md", "category": "linters", "name": "linters/clippy/zero_ptr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_clamp.md", "category": "linters", "name": "linters/clippy/manual_clamp", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_field_names.md", "category": "linters", "name": "linters/clippy/redundant_field_names", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_operation.md", "category": "linters", "name": "linters/clippy/unnecessary_operation", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ptr_cast_constness.md", "category": "linters", "name": "linters/clippy/ptr_cast_constness", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/filetype_is_file.md", "category": "linters", "name": "linters/clippy/filetype_is_file", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_sort_by.md", "category": "linters", "name": "linters/clippy/unnecessary_sort_by", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/multiple_bound_locations.md", "category": "linters", "name": "linters/clippy/multiple_bound_locations", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/borrow_as_ptr.md", "category": "linters", "name": "linters/clippy/borrow_as_ptr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/write_with_newline.md", "category": "linters", "name": "linters/clippy/write_with_newline", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/zero_repeat_side_effects.md", "category": "linters", "name": "linters/clippy/zero_repeat_side_effects", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/nonminimal_bool.md", "category": "linters", "name": "linters/clippy/nonminimal_bool", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/out_of_bounds_indexing.md", "category": "linters", "name": "linters/clippy/out_of_bounds_indexing", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/let_with_type_underscore.md", "category": "linters", "name": "linters/clippy/let_with_type_underscore", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/never_loop.md", "category": "linters", "name": "linters/clippy/never_loop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/sliced_string_as_bytes.md", "category": "linters", "name": "linters/clippy/sliced_string_as_bytes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/type_repetition_in_bounds.md", "category": "linters", "name": "linters/clippy/type_repetition_in_bounds", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_self_imports.md", "category": "linters", "name": "linters/clippy/unnecessary_self_imports", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/infinite_iter.md", "category": "linters", "name": "linters/clippy/infinite_iter", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/seek_from_current.md", "category": "linters", "name": "linters/clippy/seek_from_current", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/builtin_type_shadow.md", "category": "linters", "name": "linters/clippy/builtin_type_shadow", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/extra_unused_type_parameters.md", "category": "linters", "name": "linters/clippy/extra_unused_type_parameters", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/extend_from_slice.md", "category": "linters", "name": "linters/clippy/extend_from_slice", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/bytes_nth.md", "category": "linters", "name": "linters/clippy/bytes_nth", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/double_parens.md", "category": "linters", "name": "linters/clippy/double_parens", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mem_forget.md", "category": "linters", "name": "linters/clippy/mem_forget", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_rem_euclid.md", "category": "linters", "name": "linters/clippy/manual_rem_euclid", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/str_split_at_newline.md", "category": "linters", "name": "linters/clippy/str_split_at_newline", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_is_power_of_two.md", "category": "linters", "name": "linters/clippy/manual_is_power_of_two", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/large_const_arrays.md", "category": "linters", "name": "linters/clippy/large_const_arrays", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/self_named_constructors.md", "category": "linters", "name": "linters/clippy/self_named_constructors", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/replace_box.md", "category": "linters", "name": "linters/clippy/replace_box", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/while_float.md", "category": "linters", "name": "linters/clippy/while_float", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/todo.md", "category": "linters", "name": "linters/clippy/todo", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/single_char_add_str.md", "category": "linters", "name": "linters/clippy/single_char_add_str", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/useless_transmute.md", "category": "linters", "name": "linters/clippy/useless_transmute", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_nth_zero.md", "category": "linters", "name": "linters/clippy/iter_nth_zero", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/used_underscore_binding.md", "category": "linters", "name": "linters/clippy/used_underscore_binding", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/duration_subsec.md", "category": "linters", "name": "linters/clippy/duration_subsec", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/question_mark_used.md", "category": "linters", "name": "linters/clippy/question_mark_used", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/performance.md", "category": "linters", "name": "linters/clippy/performance", "content": "# Clippy Performance Lints\n\nLints that detect slow code.\n\n## box_collection\n\nBoxing a Vec or String is unnecessary.\n\n```rust\n// BAD\nlet v: Box<Vec<i32>> = Box::new(vec![1, 2, 3]);\nlet s: Box<String> = Box::new(\"hello\".into());\n\n// GOOD - already heap allocated\nlet v: Vec<i32> = vec![1, 2, 3];\nlet s: String = \"hello\".into();\n\n// Use Box<[T]> or Box<str> if you want fixed size\nlet v: Box<[i32]> = vec![1, 2, 3].into_boxed_slice();\nlet s: Box<str> = \"hello\".into();\n```\n\n## boxed_local\n\nBoxing a local that doesn't escape.\n\n```rust\n// BAD\nfn foo() {\n    let boxed = Box::new(5);\n    println!(\"{}\", boxed);\n}\n\n// GOOD\nfn foo() {\n    let value = 5;\n    println!(\"{}\", value);\n}\n```\n\n## cmp_owned\n\nCreating owned value for comparison.\n\n```rust\n// BAD\nif s.to_string() == \"hello\" { }\nif s.to_lowercase() == \"hello\" { }\n\n// GOOD\nif s == \"hello\" { }\nif s.eq_ignore_ascii_case(\"hello\") { }\n```\n\n## collapsible_str_replace\n\nMultiple str::replace calls.\n\n```rust\n// BAD\nlet s = s.replace(\"a\", \"\").replace(\"b\", \"\").replace(\"c\", \"\");\n\n// GOOD - single pass with array (Rust 1.58+)\nlet s = s.replace(['a', 'b', 'c'], \"\");\n```\n\n## expect_fun_call\n\nDynamic string in expect().\n\n```rust\n// BAD - allocates even on success\nopt.expect(&format!(\"failed for {}\", id));\n\n// GOOD\nopt.unwrap_or_else(|| panic!(\"failed for {}\", id));\n```\n\n## extend_with_drain\n\nUsing extend with drain.\n\n```rust\n// BAD\nv1.extend(v2.drain(..));\n\n// GOOD\nv1.append(&mut v2);\n```\n\n## filter_map_identity\n\nfilter_map with identity.\n\n```rust\n// BAD\niter.filter_map(|x| x)\n\n// GOOD\niter.flatten()\n```\n\n## flat_map_option\n\nflat_map on Option.\n\n```rust\n// BAD\niter.flat_map(|x| x.ok())\n\n// GOOD\niter.filter_map(|x| x.ok())\n```\n\n## iter_nth\n\nIterating to get nth element.\n\n```rust\n// BAD\nlet x = iter.skip(5).next();\n\n// GOOD\nlet x = iter.nth(5);\n```\n\n## iter_overeager_cloned\n\nClone before filtering.\n\n```rust\n// BAD - clones everything including filtered\niter.cloned().filter(|x| x.is_some())\n\n// GOOD - only clone what passes filter\niter.filter(|x| x.is_some()).cloned()\n```\n\n## large_const_arrays\n\nLarge array as const.\n\n```rust\n// BAD - duplicated at each use site\nconst BIG: [u8; 1000000] = [0; 1000000];\n\n// GOOD - single copy in static\nstatic BIG: [u8; 1000000] = [0; 1000000];\n```\n\n## large_enum_variant\n\nEnum with significantly different variant sizes.\n\n```rust\n// BAD\nenum Foo {\n    Small(i32),\n    Large([u8; 1000]),  // makes all Foos 1000+ bytes\n}\n\n// GOOD - box the large variant\nenum Foo {\n    Small(i32),\n    Large(Box<[u8; 1000]>),\n}\n```\n\n## manual_memcpy\n\nManual byte-by-byte copy.\n\n```rust\n// BAD\nfor i in 0..len {\n    dst[i] = src[i];\n}\n\n// GOOD\ndst[..len].copy_from_slice(&src[..len]);\n```\n\n## manual_str_repeat\n\nManual string repetition.\n\n```rust\n// BAD\nlet mut s = String::new();\nfor _ in 0..n {\n    s.push_str(\"hello\");\n}\n\n// GOOD\nlet s = \"hello\".repeat(n);\n```\n\n## map_entry\n\nMap lookup then insert.\n\n```rust\n// BAD\nif !map.contains_key(&key) {\n    map.insert(key, value);\n}\n\n// GOOD\nmap.entry(key).or_insert(value);\n\n// With computation\nmap.entry(key).or_insert_with(|| compute_value());\n```\n\n## missing_spin_loop\n\nBusy loop without spin_loop_hint.\n\n```rust\n// BAD - wastes CPU\nwhile flag.load(Ordering::Relaxed) {\n    // busy wait\n}\n\n// GOOD\nwhile flag.load(Ordering::Relaxed) {\n    std::hint::spin_loop();\n}\n```\n\n## needless_collect\n\nCollecting iterator just to iterate again.\n\n```rust\n// BAD\nlet v: Vec<_> = iter.collect();\nfor x in v { }\n\n// GOOD\nfor x in iter { }\n```\n\n## or_fun_call\n\nExpensive call in or().\n\n```rust\n// BAD - always allocates\nopt.or(Some(String::new()))\n\n// GOOD - lazy evaluation\nopt.or_else(|| Some(String::new()))\n```\n\n## redundant_allocation\n\nRedundant wrapper like Rc<Box<T>>.\n\n```rust\n// BAD\nlet x: Rc<Box<i32>> = Rc::new(Box::new(5));\nlet y: Box<Rc<i32>> = Box::new(Rc::new(5));\n\n// GOOD\nlet x: Rc<i32> = Rc::new(5);\nlet y: Box<i32> = Box::new(5);\n```\n\n## redundant_clone\n\nCloning value that doesn't need it.\n\n```rust\n// BAD\nlet s = s.clone();\ndrop(s);\n\n// GOOD\ndrop(s);  // can drop without clone if not used after\n```\n\n## single_char_pattern\n\nString pattern for single char.\n\n```rust\n// BAD\ns.contains(\"x\");\ns.split(\"x\");\ns.starts_with(\"x\");\n\n// GOOD\ns.contains('x');\ns.split('x');\ns.starts_with('x');\n```\n\n## slow_vector_initialization\n\nSlow vector initialization pattern.\n\n```rust\n// BAD\nlet mut v = Vec::with_capacity(n);\nfor _ in 0..n {\n    v.push(0);\n}\n\n// GOOD\nlet v = vec![0; n];\n\n// Or\nlet v: Vec<i32> = std::iter::repeat(0).take(n).collect();\n```\n\n## stable_sort_primitive\n\nStable sort on primitives.\n\n```rust\n// BAD - stable sort is slower\nlet mut v: Vec<i32> = vec![3, 1, 2];\nv.sort();\n\n// GOOD - unstable is fine for primitives\nv.sort_unstable();\n```\n\n## to_string_in_format_args\n\nto_string in format macro.\n\n```rust\n// BAD - unnecessary allocation\nprintln!(\"{}\", x.to_string());\n\n// GOOD\nprintln!(\"{}\", x);\n```\n\n## unnecessary_to_owned\n\nUnnecessary to_owned/to_string.\n\n```rust\n// BAD\nlet s = string.to_owned();\ntakes_ref(&s);\n\n// GOOD\ntakes_ref(&string);\n```\n\n## useless_vec\n\nVec where array/slice works.\n\n```rust\n// BAD\nfor x in vec![1, 2, 3] { }\n\n// GOOD\nfor x in [1, 2, 3] { }\nfor x in &[1, 2, 3] { }\n```\n\n## vec_init_then_push\n\nInit empty Vec then push.\n\n```rust\n// BAD\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\nv.push(3);\n\n// GOOD\nlet v = vec![1, 2, 3];\n```\n\n## waker_clone_wake\n\nClone then wake Waker.\n\n```rust\n// BAD\nwaker.clone().wake();\n\n// GOOD\nwaker.wake_by_ref();\n// or\nwaker.wake();  // if you're done with it\n```\n\n## write_with_newline\n\nwrite! with trailing newline.\n\n```rust\n// BAD\nwrite!(f, \"hello\\n\")?;\n\n// GOOD\nwriteln!(f, \"hello\")?;\n```\n"}, {"path": "linters/clippy/unsafe_removed_from_name.md", "category": "linters", "name": "linters/clippy/unsafe_removed_from_name", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_repeat_n.md", "category": "linters", "name": "linters/clippy/manual_repeat_n", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/legacy_numeric_constants.md", "category": "linters", "name": "linters/clippy/legacy_numeric_constants", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/double_must_use.md", "category": "linters", "name": "linters/clippy/double_must_use", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/approx_constant.md", "category": "linters", "name": "linters/clippy/approx_constant", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cloned_ref_to_slice_refs.md", "category": "linters", "name": "linters/clippy/cloned_ref_to_slice_refs", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/exhaustive_enums.md", "category": "linters", "name": "linters/clippy/exhaustive_enums", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/same_name_method.md", "category": "linters", "name": "linters/clippy/same_name_method", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_type_cast.md", "category": "linters", "name": "linters/clippy/needless_type_cast", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/write_literal.md", "category": "linters", "name": "linters/clippy/write_literal", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious_doc_comments.md", "category": "linters", "name": "linters/clippy/suspicious_doc_comments", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/range_plus_one.md", "category": "linters", "name": "linters/clippy/range_plus_one", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/clone_on_ref_ptr.md", "category": "linters", "name": "linters/clippy/clone_on_ref_ptr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_panics_doc.md", "category": "linters", "name": "linters/clippy/missing_panics_doc", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_overeager_cloned.md", "category": "linters", "name": "linters/clippy/iter_overeager_cloned", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/doc_markdown.md", "category": "linters", "name": "linters/clippy/doc_markdown", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/comparison_to_empty.md", "category": "linters", "name": "linters/clippy/comparison_to_empty", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/non_std_lazy_statics.md", "category": "linters", "name": "linters/clippy/non_std_lazy_statics", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_is_finite.md", "category": "linters", "name": "linters/clippy/manual_is_finite", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/non_zero_suggestions.md", "category": "linters", "name": "linters/clippy/non_zero_suggestions", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/bytes_count_to_len.md", "category": "linters", "name": "linters/clippy/bytes_count_to_len", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mismatching_type_param_order.md", "category": "linters", "name": "linters/clippy/mismatching_type_param_order", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/doc_overindented_list_items.md", "category": "linters", "name": "linters/clippy/doc_overindented_list_items", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/exit.md", "category": "linters", "name": "linters/clippy/exit", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/io_other_error.md", "category": "linters", "name": "linters/clippy/io_other_error", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/eager_transmute.md", "category": "linters", "name": "linters/clippy/eager_transmute", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/wrong_transmute.md", "category": "linters", "name": "linters/clippy/wrong_transmute", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_transmute_annotations.md", "category": "linters", "name": "linters/clippy/missing_transmute_annotations", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unicode_not_nfc.md", "category": "linters", "name": "linters/clippy/unicode_not_nfc", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cast_sign_loss.md", "category": "linters", "name": "linters/clippy/cast_sign_loss", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_bits.md", "category": "linters", "name": "linters/clippy/manual_bits", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_filter_map.md", "category": "linters", "name": "linters/clippy/unnecessary_filter_map", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_instant_elapsed.md", "category": "linters", "name": "linters/clippy/manual_instant_elapsed", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/empty_line_after_outer_attr.md", "category": "linters", "name": "linters/clippy/empty_line_after_outer_attr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/while_immutable_condition.md", "category": "linters", "name": "linters/clippy/while_immutable_condition", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cfg_not_test.md", "category": "linters", "name": "linters/clippy/cfg_not_test", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mem_replace_option_with_some.md", "category": "linters", "name": "linters/clippy/mem_replace_option_with_some", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_range_loop.md", "category": "linters", "name": "linters/clippy/needless_range_loop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/float_equality_without_abs.md", "category": "linters", "name": "linters/clippy/float_equality_without_abs", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ref_binding_to_reference.md", "category": "linters", "name": "linters/clippy/ref_binding_to_reference", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/repeat_vec_with_capacity.md", "category": "linters", "name": "linters/clippy/repeat_vec_with_capacity", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/useless_format.md", "category": "linters", "name": "linters/clippy/useless_format", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_nth.md", "category": "linters", "name": "linters/clippy/iter_nth", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/match_same_arms.md", "category": "linters", "name": "linters/clippy/match_same_arms", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/transmutes_expressible_as_ptr_casts.md", "category": "linters", "name": "linters/clippy/transmutes_expressible_as_ptr_casts", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/filter_map_bool_then.md", "category": "linters", "name": "linters/clippy/filter_map_bool_then", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/pointers_in_nomem_asm_block.md", "category": "linters", "name": "linters/clippy/pointers_in_nomem_asm_block", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/doc_paragraphs_missing_punctuation.md", "category": "linters", "name": "linters/clippy/doc_paragraphs_missing_punctuation", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/tabs_in_doc_comments.md", "category": "linters", "name": "linters/clippy/tabs_in_doc_comments", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_fallible_conversions.md", "category": "linters", "name": "linters/clippy/unnecessary_fallible_conversions", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unreachable.md", "category": "linters", "name": "linters/clippy/unreachable", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/semicolon_outside_block.md", "category": "linters", "name": "linters/clippy/semicolon_outside_block", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious_splitn.md", "category": "linters", "name": "linters/clippy/suspicious_splitn", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/pub_use.md", "category": "linters", "name": "linters/clippy/pub_use", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cast_possible_truncation.md", "category": "linters", "name": "linters/clippy/cast_possible_truncation", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/enum_variant_names.md", "category": "linters", "name": "linters/clippy/enum_variant_names", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_closure_call.md", "category": "linters", "name": "linters/clippy/redundant_closure_call", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/large_stack_arrays.md", "category": "linters", "name": "linters/clippy/large_stack_arrays", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cast_slice_from_raw_parts.md", "category": "linters", "name": "linters/clippy/cast_slice_from_raw_parts", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/async_yields_async.md", "category": "linters", "name": "linters/clippy/async_yields_async", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/replace_consts.md", "category": "linters", "name": "linters/clippy/replace_consts", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_ilog2.md", "category": "linters", "name": "linters/clippy/manual_ilog2", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/allow_attributes_without_reason.md", "category": "linters", "name": "linters/clippy/allow_attributes_without_reason", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_next_slice.md", "category": "linters", "name": "linters/clippy/iter_next_slice", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mutex_atomic.md", "category": "linters", "name": "linters/clippy/mutex_atomic", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/items_after_test_module.md", "category": "linters", "name": "linters/clippy/items_after_test_module", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_is_ascii_check.md", "category": "linters", "name": "linters/clippy/manual_is_ascii_check", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_closure_for_method_calls.md", "category": "linters", "name": "linters/clippy/redundant_closure_for_method_calls", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/too_many_arguments.md", "category": "linters", "name": "linters/clippy/too_many_arguments", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/into_iter_without_iter.md", "category": "linters", "name": "linters/clippy/into_iter_without_iter", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/or_then_unwrap.md", "category": "linters", "name": "linters/clippy/or_then_unwrap", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/expect_used.md", "category": "linters", "name": "linters/clippy/expect_used", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/result_unit_err.md", "category": "linters", "name": "linters/clippy/result_unit_err", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnested_or_patterns.md", "category": "linters", "name": "linters/clippy/unnested_or_patterns", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/string_slice.md", "category": "linters", "name": "linters/clippy/string_slice", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/byte_char_slices.md", "category": "linters", "name": "linters/clippy/byte_char_slices", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/seek_to_start_instead_of_rewind.md", "category": "linters", "name": "linters/clippy/seek_to_start_instead_of_rewind", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/std_instead_of_core.md", "category": "linters", "name": "linters/clippy/std_instead_of_core", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_pass_by_value.md", "category": "linters", "name": "linters/clippy/needless_pass_by_value", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_get_then_check.md", "category": "linters", "name": "linters/clippy/unnecessary_get_then_check", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/big_endian_bytes.md", "category": "linters", "name": "linters/clippy/big_endian_bytes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/volatile_composites.md", "category": "linters", "name": "linters/clippy/volatile_composites", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/doc_include_without_cfg.md", "category": "linters", "name": "linters/clippy/doc_include_without_cfg", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_bool_assign.md", "category": "linters", "name": "linters/clippy/needless_bool_assign", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/declare_interior_mutable_const.md", "category": "linters", "name": "linters/clippy/declare_interior_mutable_const", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/precedence_bits.md", "category": "linters", "name": "linters/clippy/precedence_bits", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ref_patterns.md", "category": "linters", "name": "linters/clippy/ref_patterns", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/naive_bytecount.md", "category": "linters", "name": "linters/clippy/naive_bytecount", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/rest_pat_in_fully_bound_structs.md", "category": "linters", "name": "linters/clippy/rest_pat_in_fully_bound_structs", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_find_map.md", "category": "linters", "name": "linters/clippy/manual_find_map", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/overly_complex_bool_expr.md", "category": "linters", "name": "linters/clippy/overly_complex_bool_expr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/format_push_string.md", "category": "linters", "name": "linters/clippy/format_push_string", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/crosspointer_transmute.md", "category": "linters", "name": "linters/clippy/crosspointer_transmute", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/large_digit_groups.md", "category": "linters", "name": "linters/clippy/large_digit_groups", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/partialeq_ne_impl.md", "category": "linters", "name": "linters/clippy/partialeq_ne_impl", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/empty_enums.md", "category": "linters", "name": "linters/clippy/empty_enums", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/op_ref.md", "category": "linters", "name": "linters/clippy/op_ref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unused_peekable.md", "category": "linters", "name": "linters/clippy/unused_peekable", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/deref_addrof.md", "category": "linters", "name": "linters/clippy/deref_addrof", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/waker_clone_wake.md", "category": "linters", "name": "linters/clippy/waker_clone_wake", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mut_mut.md", "category": "linters", "name": "linters/clippy/mut_mut", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_spin_loop.md", "category": "linters", "name": "linters/clippy/missing_spin_loop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/wildcard_enum_match_arm.md", "category": "linters", "name": "linters/clippy/wildcard_enum_match_arm", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/blanket_clippy_restriction_lints.md", "category": "linters", "name": "linters/clippy/blanket_clippy_restriction_lints", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/debug_assert_with_mut_call.md", "category": "linters", "name": "linters/clippy/debug_assert_with_mut_call", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/use_self.md", "category": "linters", "name": "linters/clippy/use_self", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/filter_map_identity.md", "category": "linters", "name": "linters/clippy/filter_map_identity", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mistyped_literal_suffixes.md", "category": "linters", "name": "linters/clippy/mistyped_literal_suffixes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/match_str_case_mismatch.md", "category": "linters", "name": "linters/clippy/match_str_case_mismatch", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_unwrap_or.md", "category": "linters", "name": "linters/clippy/manual_unwrap_or", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/await_holding_invalid_type.md", "category": "linters", "name": "linters/clippy/await_holding_invalid_type", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/negative_feature_names.md", "category": "linters", "name": "linters/clippy/negative_feature_names", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/single_char_lifetime_names.md", "category": "linters", "name": "linters/clippy/single_char_lifetime_names", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/non_canonical_clone_impl.md", "category": "linters", "name": "linters/clippy/non_canonical_clone_impl", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/search_is_some.md", "category": "linters", "name": "linters/clippy/search_is_some", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unwrap_used.md", "category": "linters", "name": "linters/clippy/unwrap_used", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unused_unit.md", "category": "linters", "name": "linters/clippy/unused_unit", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/option_env_unwrap.md", "category": "linters", "name": "linters/clippy/option_env_unwrap", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/wildcard_dependencies.md", "category": "linters", "name": "linters/clippy/wildcard_dependencies", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/to_string_trait_impl.md", "category": "linters", "name": "linters/clippy/to_string_trait_impl", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/single_call_fn.md", "category": "linters", "name": "linters/clippy/single_call_fn", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/explicit_iter_loop.md", "category": "linters", "name": "linters/clippy/explicit_iter_loop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unused_result_ok.md", "category": "linters", "name": "linters/clippy/unused_result_ok", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cast_enum_constructor.md", "category": "linters", "name": "linters/clippy/cast_enum_constructor", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/doc_comment_double_space_linebreaks.md", "category": "linters", "name": "linters/clippy/doc_comment_double_space_linebreaks", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_pub_self.md", "category": "linters", "name": "linters/clippy/needless_pub_self", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_map.md", "category": "linters", "name": "linters/clippy/manual_map", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/vec_init_then_push.md", "category": "linters", "name": "linters/clippy/vec_init_then_push", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious_map.md", "category": "linters", "name": "linters/clippy/suspicious_map", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/no_mangle_with_rust_abi.md", "category": "linters", "name": "linters/clippy/no_mangle_with_rust_abi", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_semicolon.md", "category": "linters", "name": "linters/clippy/unnecessary_semicolon", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/bool_assert_comparison.md", "category": "linters", "name": "linters/clippy/bool_assert_comparison", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious_unary_op_formatting.md", "category": "linters", "name": "linters/clippy/suspicious_unary_op_formatting", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/must_use_unit.md", "category": "linters", "name": "linters/clippy/must_use_unit", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_contains.md", "category": "linters", "name": "linters/clippy/manual_contains", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/field_reassign_with_default.md", "category": "linters", "name": "linters/clippy/field_reassign_with_default", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_filter_is_ok.md", "category": "linters", "name": "linters/clippy/iter_filter_is_ok", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_inspect.md", "category": "linters", "name": "linters/clippy/manual_inspect", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/non_octal_unix_permissions.md", "category": "linters", "name": "linters/clippy/non_octal_unix_permissions", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/explicit_counter_loop.md", "category": "linters", "name": "linters/clippy/explicit_counter_loop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/deprecated_cfg_attr.md", "category": "linters", "name": "linters/clippy/deprecated_cfg_attr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/case_sensitive_file_extension_comparisons.md", "category": "linters", "name": "linters/clippy/case_sensitive_file_extension_comparisons", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_not_returning_iterator.md", "category": "linters", "name": "linters/clippy/iter_not_returning_iterator", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unchecked_time_subtraction.md", "category": "linters", "name": "linters/clippy/unchecked_time_subtraction", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/future_not_send.md", "category": "linters", "name": "linters/clippy/future_not_send", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/style.md", "category": "linters", "name": "linters/clippy/style", "content": "# Clippy Style Lints\n\nCode style and conventions.\n\n## assertions_on_constants\n\nAssert on constant condition.\n\n```rust\n// BAD\nassert!(true);\ndebug_assert!(false);\n\n// Remove or use compile-time check\nconst_assert!(CONDITION);\n```\n\n## assign_op_pattern\n\nManual compound assignment.\n\n```rust\n// BAD\nx = x + 1;\nx = x * 2;\n\n// GOOD\nx += 1;\nx *= 2;\n```\n\n## bool_assert_comparison\n\nAssert with bool comparison.\n\n```rust\n// BAD\nassert_eq!(result, true);\nassert_eq!(result, false);\n\n// GOOD\nassert!(result);\nassert!(!result);\n```\n\n## blocks_in_conditions\n\nComplex blocks in if conditions.\n\n```rust\n// BAD\nif { let x = get(); x > 0 } { }\n\n// GOOD\nlet x = get();\nif x > 0 { }\n```\n\n## borrow_interior_mutable_const\n\nBorrowing interior mutable const.\n\n```rust\n// BAD\nconst CELL: Cell<i32> = Cell::new(0);\nlet x = &CELL;  // each use gets fresh Cell!\n\n// GOOD\nstatic CELL: Cell<i32> = Cell::new(0);\nlet x = &CELL;  // same Cell each time\n```\n\n## builtin_type_shadow\n\nShadowing builtin types.\n\n```rust\n// BAD\nfn foo<u32>(x: u32) { }  // u32 is type parameter, not primitive!\n\n// GOOD\nfn foo<T>(x: T) { }\nfn foo(x: u32) { }  // actually uses primitive\n```\n\n## clone_on_ref_ptr\n\nCalling clone() on Rc/Arc.\n\n```rust\n// BAD - looks like deep clone\nlet b = a.clone();\n\n// GOOD - explicit reference clone\nlet b = Rc::clone(&a);\nlet b = Arc::clone(&a);\n```\n\n## cmp_null\n\nComparing to null pointer.\n\n```rust\n// BAD\nif ptr == std::ptr::null() { }\n\n// GOOD\nif ptr.is_null() { }\n```\n\n## collapsible_if\n\nNested if can be combined.\n\n```rust\n// BAD\nif a {\n    if b {\n        do_something();\n    }\n}\n\n// GOOD\nif a && b {\n    do_something();\n}\n```\n\n## collapsible_else_if\n\nElse with only if inside.\n\n```rust\n// BAD\nif a {\n} else {\n    if b {\n    }\n}\n\n// GOOD\nif a {\n} else if b {\n}\n```\n\n## comparison_to_empty\n\nComparing to empty collection.\n\n```rust\n// BAD\nif s == \"\" { }\nif v == vec![] { }\n\n// GOOD\nif s.is_empty() { }\nif v.is_empty() { }\n```\n\n## default_trait_access\n\nUsing Default::default() when type has default().\n\n```rust\n// BAD\nlet x: Vec<i32> = Default::default();\n\n// GOOD\nlet x: Vec<i32> = Vec::default();\nlet x = Vec::<i32>::default();\n\n// Or just new() if available\nlet x: Vec<i32> = Vec::new();\n```\n\n## double_neg\n\nDouble negation.\n\n```rust\n// BAD\nlet x = --y;\n\n// GOOD\nlet x = y;\n```\n\n## explicit_auto_deref\n\nExplicit deref when auto-deref works.\n\n```rust\n// BAD\nlet x: &i32 = &*y;\n\n// GOOD\nlet x: &i32 = y;\n```\n\n## explicit_iter_loop\n\nExplicit iter() in for loop.\n\n```rust\n// BAD\nfor x in vec.iter() { }\nfor x in vec.iter_mut() { }\n\n// GOOD\nfor x in &vec { }\nfor x in &mut vec { }\n```\n\n## field_reassign_with_default\n\nReassigning default fields.\n\n```rust\n// BAD\nlet mut x = Foo::default();\nx.field1 = 1;\nx.field2 = 2;\n\n// GOOD\nlet x = Foo {\n    field1: 1,\n    field2: 2,\n    ..Default::default()\n};\n```\n\n## for_kv_map\n\nIterating map for keys or values only.\n\n```rust\n// BAD\nfor (k, _) in &map { }\nfor (_, v) in &map { }\n\n// GOOD\nfor k in map.keys() { }\nfor v in map.values() { }\n```\n\n## from_over_into\n\nImplementing Into instead of From.\n\n```rust\n// BAD\nimpl Into<String> for Foo {\n    fn into(self) -> String { }\n}\n\n// GOOD\nimpl From<Foo> for String {\n    fn from(foo: Foo) -> String { }\n}\n```\n\n## implicit_clone\n\nUsing to_owned/to_vec for clone.\n\n```rust\n// BAD\nlet s = original.to_owned();\nlet v = original.to_vec();\n\n// GOOD\nlet s = original.clone();\nlet v = original.clone();\n```\n\n## infallible_destructuring_match\n\nMatch on infallible pattern.\n\n```rust\n// BAD\nlet Foo { x } = match foo {\n    Foo { x } => Foo { x },\n};\n\n// GOOD\nlet Foo { x } = foo;\n```\n\n## inherent_to_string\n\nInherent to_string when Display exists.\n\n```rust\n// BAD\nimpl Foo {\n    fn to_string(&self) -> String { }\n}\n\n// GOOD - just implement Display\nimpl Display for Foo {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result { }\n}\n```\n\n## into_iter_on_ref\n\ninto_iter() on reference.\n\n```rust\n// BAD\n(&vec).into_iter()\n\n// GOOD\nvec.iter()\n```\n\n## is_digit_ascii_radix\n\nis_digit with ascii radix.\n\n```rust\n// BAD\nc.is_digit(10)\nc.is_digit(16)\n\n// GOOD\nc.is_ascii_digit()\nc.is_ascii_hexdigit()\n```\n\n## just_underscores_and_digits\n\nVariable name is only underscores and digits.\n\n```rust\n// BAD\nlet _1 = 1;\nlet __2__ = 2;\n\n// GOOD\nlet count_1 = 1;\nlet value_2 = 2;\n```\n\n## len_without_is_empty\n\nlen() without is_empty().\n\n```rust\n// BAD\nimpl Foo {\n    fn len(&self) -> usize { }\n}\n\n// GOOD\nimpl Foo {\n    fn len(&self) -> usize { }\n    fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n}\n```\n\n## len_zero\n\nUsing len() == 0.\n\n```rust\n// BAD\nif s.len() == 0 { }\nif s.len() != 0 { }\n\n// GOOD\nif s.is_empty() { }\nif !s.is_empty() { }\n```\n\n## let_and_return\n\nLet then immediate return.\n\n```rust\n// BAD\nlet result = compute();\nresult\n\n// GOOD\ncompute()\n```\n\n## manual_map\n\nManual Option/Result mapping.\n\n```rust\n// BAD\nmatch opt {\n    Some(x) => Some(x.len()),\n    None => None,\n}\n\n// GOOD\nopt.map(|x| x.len())\n```\n\n## manual_ok_or\n\nManual ok_or pattern.\n\n```rust\n// BAD\nmatch opt {\n    Some(x) => Ok(x),\n    None => Err(e),\n}\n\n// GOOD\nopt.ok_or(e)\n```\n\n## manual_range_contains\n\nManual range check.\n\n```rust\n// BAD\nx >= 0 && x < 10\n\n// GOOD\n(0..10).contains(&x)\n```\n\n## manual_unwrap_or\n\nManual unwrap_or pattern.\n\n```rust\n// BAD\nmatch opt {\n    Some(x) => x,\n    None => default,\n}\n\n// GOOD\nopt.unwrap_or(default)\n```\n\n## match_bool\n\nMatch on bool.\n\n```rust\n// BAD\nmatch condition {\n    true => foo(),\n    false => bar(),\n}\n\n// GOOD\nif condition { foo() } else { bar() }\n```\n\n## match_like_matches_macro\n\nMatch that returns bool.\n\n```rust\n// BAD\nmatch x {\n    Some(_) => true,\n    None => false,\n}\n\n// GOOD\nmatches!(x, Some(_))\n```\n\n## match_overlapping_arm\n\nMatch arms that overlap.\n\n```rust\n// BAD\nmatch x {\n    0..=10 => foo(),\n    5..=15 => bar(),  // 5-10 overlaps!\n    _ => baz(),\n}\n```\n\n## match_ref_pats\n\nMatch with ref patterns.\n\n```rust\n// BAD\nmatch &x {\n    &Some(ref y) => { }\n    _ => { }\n}\n\n// GOOD\nmatch x {\n    Some(ref y) => { }\n    _ => { }\n}\n```\n\n## match_result_ok\n\nMatch on Result to get Ok.\n\n```rust\n// BAD\nmatch result {\n    Ok(x) => Some(x),\n    Err(_) => None,\n}\n\n// GOOD\nresult.ok()\n```\n\n## match_single_binding\n\nMatch with single binding.\n\n```rust\n// BAD\nmatch (a, b) {\n    (x, y) => foo(x, y),\n}\n\n// GOOD\nlet (x, y) = (a, b);\nfoo(x, y);\n```\n\n## match_wild_err_arm\n\nMatch with wildcard in Err arm.\n\n```rust\n// BAD\nmatch result {\n    Ok(x) => x,\n    Err(_) => default,  // ignores error!\n}\n\n// GOOD\nresult.unwrap_or(default)\n// Or handle the error\n```\n\n## needless_borrow\n\nUnnecessary borrow.\n\n```rust\n// BAD\nlet x = &1;\ntakes_ref(&x);  // double reference\n\n// GOOD\ntakes_ref(x);\n```\n\n## needless_return\n\nUnnecessary return keyword.\n\n```rust\n// BAD\nfn foo() -> i32 {\n    return 42;\n}\n\n// GOOD\nfn foo() -> i32 {\n    42\n}\n```\n\n## new_ret_no_self\n\nnew() that doesn't return Self.\n\n```rust\n// BAD\nimpl Foo {\n    fn new() -> Bar { }\n}\n\n// GOOD\nimpl Foo {\n    fn new() -> Self { }\n    fn new() -> Foo { }\n}\n```\n\n## new_without_default\n\nnew() without Default impl.\n\n```rust\n// BAD\nimpl Foo {\n    fn new() -> Self { }\n}\n\n// GOOD\nimpl Foo {\n    fn new() -> Self { }\n}\n\nimpl Default for Foo {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n```\n\n## op_ref\n\nReference operand.\n\n```rust\n// BAD\nlet x = &a + &b;\n\n// GOOD\nlet x = a + b;\n```\n\n## option_map_unit_fn\n\nmap() returning unit.\n\n```rust\n// BAD\nopt.map(|x| println!(\"{}\", x));\n\n// GOOD\nif let Some(x) = opt {\n    println!(\"{}\", x);\n}\n```\n\n## ptr_arg\n\n&Vec or &String as argument.\n\n```rust\n// BAD\nfn foo(v: &Vec<i32>) { }\nfn bar(s: &String) { }\n\n// GOOD\nfn foo(v: &[i32]) { }\nfn bar(s: &str) { }\n```\n\n## question_mark\n\nManual ? operator pattern.\n\n```rust\n// BAD\nmatch opt {\n    Some(x) => x,\n    None => return None,\n}\n\n// GOOD\nopt?\n```\n\n## redundant_closure\n\nClosure that just calls function.\n\n```rust\n// BAD\niter.map(|x| foo(x))\n\n// GOOD\niter.map(foo)\n```\n\n## redundant_field_names\n\nRedundant field name in struct literal.\n\n```rust\n// BAD\nFoo { x: x, y: y }\n\n// GOOD\nFoo { x, y }\n```\n\n## redundant_pattern_matching\n\nUnnecessary pattern matching.\n\n```rust\n// BAD\nif let Some(_) = opt { }\nif let Ok(_) = result { }\n\n// GOOD\nif opt.is_some() { }\nif result.is_ok() { }\n```\n\n## redundant_static_lifetimes\n\nUnnecessary 'static lifetime.\n\n```rust\n// BAD\nconst S: &'static str = \"hello\";\nstatic S: &'static str = \"hello\";\n\n// GOOD\nconst S: &str = \"hello\";\nstatic S: &str = \"hello\";\n```\n\n## self_named_constructors\n\nConstructor named new_self.\n\n```rust\n// BAD\nimpl Foo {\n    fn new_foo() -> Foo { }\n}\n\n// GOOD\nimpl Foo {\n    fn new() -> Self { }\n}\n```\n\n## single_match\n\nSingle-arm match.\n\n```rust\n// BAD\nmatch opt {\n    Some(x) => foo(x),\n    _ => { }\n}\n\n// GOOD\nif let Some(x) = opt {\n    foo(x);\n}\n```\n\n## string_lit_as_bytes\n\nString literal to bytes.\n\n```rust\n// BAD\n\"hello\".as_bytes()\n\n// GOOD\nb\"hello\"\n```\n\n## tabs_in_doc_comments\n\nTabs in documentation.\n\n```rust\n// BAD (contains tab)\n/// \tindented with tab\n\n// GOOD\n///     indented with spaces\n```\n\n## to_digit_is_some\n\nto_digit().is_some() instead of is_digit().\n\n```rust\n// BAD\nc.to_digit(10).is_some()\n\n// GOOD\nc.is_digit(10)\n```\n\n## toplevel_ref_arg\n\nref in top-level pattern.\n\n```rust\n// BAD\nfn foo(ref x: String) { }\n\n// GOOD\nfn foo(x: &String) { }\n```\n\n## unnecessary_fold\n\nfold that could be a specialized method.\n\n```rust\n// BAD\niter.fold(0, |acc, x| acc + x)\niter.fold(true, |acc, x| acc && x)\n\n// GOOD\niter.sum()\niter.all(|x| x)\n```\n\n## unnecessary_mut_passed\n\nMutable reference passed to function that doesn't need it.\n\n```rust\n// BAD\nfn foo(x: &i32) { }\nfoo(&mut value);\n\n// GOOD\nfoo(&value);\n```\n\n## wrong_self_convention\n\nSelf convention violation.\n\n```rust\n// BAD - is_* should take &self\nfn is_empty(self) -> bool { }\n\n// BAD - to_* should take &self  \nfn to_string(&mut self) -> String { }\n\n// BAD - into_* should take self\nfn into_vec(&self) -> Vec<T> { }\n\n// GOOD\nfn is_empty(&self) -> bool { }\nfn to_string(&self) -> String { }\nfn into_vec(self) -> Vec<T> { }\n```\n"}, {"path": "linters/clippy/suspicious_xor_used_as_pow.md", "category": "linters", "name": "linters/clippy/suspicious_xor_used_as_pow", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ip_constant.md", "category": "linters", "name": "linters/clippy/ip_constant", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cast_precision_loss.md", "category": "linters", "name": "linters/clippy/cast_precision_loss", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/fn_to_numeric_cast_with_truncation.md", "category": "linters", "name": "linters/clippy/fn_to_numeric_cast_with_truncation", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_split_once.md", "category": "linters", "name": "linters/clippy/manual_split_once", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/single_element_loop.md", "category": "linters", "name": "linters/clippy/single_element_loop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/same_item_push.md", "category": "linters", "name": "linters/clippy/same_item_push", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ptr_eq.md", "category": "linters", "name": "linters/clippy/ptr_eq", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/wrong_pub_self_convention.md", "category": "linters", "name": "linters/clippy/wrong_pub_self_convention", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/std_instead_of_alloc.md", "category": "linters", "name": "linters/clippy/std_instead_of_alloc", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cmp_null.md", "category": "linters", "name": "linters/clippy/cmp_null", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/large_include_file.md", "category": "linters", "name": "linters/clippy/large_include_file", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/trailing_empty_array.md", "category": "linters", "name": "linters/clippy/trailing_empty_array", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_late_init.md", "category": "linters", "name": "linters/clippy/needless_late_init", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/map_collect_result_unit.md", "category": "linters", "name": "linters/clippy/map_collect_result_unit", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/new_without_default.md", "category": "linters", "name": "linters/clippy/new_without_default", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/collapsible_str_replace.md", "category": "linters", "name": "linters/clippy/collapsible_str_replace", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/is_digit_ascii_radix.md", "category": "linters", "name": "linters/clippy/is_digit_ascii_radix", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_find_map.md", "category": "linters", "name": "linters/clippy/unnecessary_find_map", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/temporary_assignment.md", "category": "linters", "name": "linters/clippy/temporary_assignment", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_rotate.md", "category": "linters", "name": "linters/clippy/manual_rotate", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/transmute_int_to_non_zero.md", "category": "linters", "name": "linters/clippy/transmute_int_to_non_zero", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious_to_owned.md", "category": "linters", "name": "linters/clippy/suspicious_to_owned", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/print_with_newline.md", "category": "linters", "name": "linters/clippy/print_with_newline", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/print_stderr.md", "category": "linters", "name": "linters/clippy/print_stderr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/invalid_regex.md", "category": "linters", "name": "linters/clippy/invalid_regex", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/else_if_without_else.md", "category": "linters", "name": "linters/clippy/else_if_without_else", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_map_or.md", "category": "linters", "name": "linters/clippy/unnecessary_map_or", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/as_ptr_cast_mut.md", "category": "linters", "name": "linters/clippy/as_ptr_cast_mut", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/fn_params_excessive_bools.md", "category": "linters", "name": "linters/clippy/fn_params_excessive_bools", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/use_debug.md", "category": "linters", "name": "linters/clippy/use_debug", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_enforced_import_renames.md", "category": "linters", "name": "linters/clippy/missing_enforced_import_renames", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_range_patterns.md", "category": "linters", "name": "linters/clippy/manual_range_patterns", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iterator_step_by_zero.md", "category": "linters", "name": "linters/clippy/iterator_step_by_zero", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/fn_to_numeric_cast.md", "category": "linters", "name": "linters/clippy/fn_to_numeric_cast", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/borrow_deref_ref.md", "category": "linters", "name": "linters/clippy/borrow_deref_ref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/no_effect.md", "category": "linters", "name": "linters/clippy/no_effect", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_next_loop.md", "category": "linters", "name": "linters/clippy/iter_next_loop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/transmute_undefined_repr.md", "category": "linters", "name": "linters/clippy/transmute_undefined_repr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/doc_broken_link.md", "category": "linters", "name": "linters/clippy/doc_broken_link", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/non_ascii_literal.md", "category": "linters", "name": "linters/clippy/non_ascii_literal", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/only_used_in_recursion.md", "category": "linters", "name": "linters/clippy/only_used_in_recursion", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/self_named_module_files.md", "category": "linters", "name": "linters/clippy/self_named_module_files", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/pub_underscore_fields.md", "category": "linters", "name": "linters/clippy/pub_underscore_fields", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/let_underscore_must_use.md", "category": "linters", "name": "linters/clippy/let_underscore_must_use", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unit_cmp.md", "category": "linters", "name": "linters/clippy/unit_cmp", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/dbg_macro.md", "category": "linters", "name": "linters/clippy/dbg_macro", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/try_err.md", "category": "linters", "name": "linters/clippy/try_err", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_lazy_evaluations.md", "category": "linters", "name": "linters/clippy/unnecessary_lazy_evaluations", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_ok_err.md", "category": "linters", "name": "linters/clippy/manual_ok_err", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/partial_pub_fields.md", "category": "linters", "name": "linters/clippy/partial_pub_fields", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/trim_split_whitespace.md", "category": "linters", "name": "linters/clippy/trim_split_whitespace", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/host_endian_bytes.md", "category": "linters", "name": "linters/clippy/host_endian_bytes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/same_functions_in_if_condition.md", "category": "linters", "name": "linters/clippy/same_functions_in_if_condition", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/arbitrary_source_item_ordering.md", "category": "linters", "name": "linters/clippy/arbitrary_source_item_ordering", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/const_is_empty.md", "category": "linters", "name": "linters/clippy/const_is_empty", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/modulo_arithmetic.md", "category": "linters", "name": "linters/clippy/modulo_arithmetic", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_doctest_main.md", "category": "linters", "name": "linters/clippy/needless_doctest_main", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_result_map_or_else.md", "category": "linters", "name": "linters/clippy/unnecessary_result_map_or_else", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/absolute_paths.md", "category": "linters", "name": "linters/clippy/absolute_paths", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/panicking_overflow_checks.md", "category": "linters", "name": "linters/clippy/panicking_overflow_checks", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/arc_with_non_send_sync.md", "category": "linters", "name": "linters/clippy/arc_with_non_send_sync", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/tests_outside_test_module.md", "category": "linters", "name": "linters/clippy/tests_outside_test_module", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_async_block.md", "category": "linters", "name": "linters/clippy/redundant_async_block", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/transmuting_null.md", "category": "linters", "name": "linters/clippy/transmuting_null", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/collapsible_if.md", "category": "linters", "name": "linters/clippy/collapsible_if", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/single_component_path_imports.md", "category": "linters", "name": "linters/clippy/single_component_path_imports", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/useless_vec.md", "category": "linters", "name": "linters/clippy/useless_vec", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/test_attr_in_doctest.md", "category": "linters", "name": "linters/clippy/test_attr_in_doctest", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_kv_map.md", "category": "linters", "name": "linters/clippy/iter_kv_map", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_unwrap_or_default.md", "category": "linters", "name": "linters/clippy/manual_unwrap_or_default", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/into_iter_on_ref.md", "category": "linters", "name": "linters/clippy/into_iter_on_ref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_while_let_some.md", "category": "linters", "name": "linters/clippy/manual_while_let_some", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_pattern_char_comparison.md", "category": "linters", "name": "linters/clippy/manual_pattern_char_comparison", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/swap_with_temporary.md", "category": "linters", "name": "linters/clippy/swap_with_temporary", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/let_underscore_future.md", "category": "linters", "name": "linters/clippy/let_underscore_future", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unused_async.md", "category": "linters", "name": "linters/clippy/unused_async", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/undocumented_unsafe_blocks.md", "category": "linters", "name": "linters/clippy/undocumented_unsafe_blocks", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_without_into_iter.md", "category": "linters", "name": "linters/clippy/iter_without_into_iter", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/deprecated_semver.md", "category": "linters", "name": "linters/clippy/deprecated_semver", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/float_cmp_const.md", "category": "linters", "name": "linters/clippy/float_cmp_const", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/struct_field_names.md", "category": "linters", "name": "linters/clippy/struct_field_names", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/invisible_characters.md", "category": "linters", "name": "linters/clippy/invisible_characters", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/recursive_format_impl.md", "category": "linters", "name": "linters/clippy/recursive_format_impl", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/size_of_in_element_count.md", "category": "linters", "name": "linters/clippy/size_of_in_element_count", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mem_replace_option_with_none.md", "category": "linters", "name": "linters/clippy/mem_replace_option_with_none", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_ignore_case_cmp.md", "category": "linters", "name": "linters/clippy/manual_ignore_case_cmp", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/indexing_slicing.md", "category": "linters", "name": "linters/clippy/indexing_slicing", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/multi_assignments.md", "category": "linters", "name": "linters/clippy/multi_assignments", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_over_hash_type.md", "category": "linters", "name": "linters/clippy/iter_over_hash_type", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_ifs.md", "category": "linters", "name": "linters/clippy/needless_ifs", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/panicking_unwrap.md", "category": "linters", "name": "linters/clippy/panicking_unwrap", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unstable_as_slice.md", "category": "linters", "name": "linters/clippy/unstable_as_slice", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mixed_attributes_style.md", "category": "linters", "name": "linters/clippy/mixed_attributes_style", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/implicit_clone.md", "category": "linters", "name": "linters/clippy/implicit_clone", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/clone_on_copy.md", "category": "linters", "name": "linters/clippy/clone_on_copy", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ptr_offset_by_literal.md", "category": "linters", "name": "linters/clippy/ptr_offset_by_literal", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/self_assignment.md", "category": "linters", "name": "linters/clippy/self_assignment", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/blocks_in_conditions.md", "category": "linters", "name": "linters/clippy/blocks_in_conditions", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unused_self.md", "category": "linters", "name": "linters/clippy/unused_self", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_else.md", "category": "linters", "name": "linters/clippy/redundant_else", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/string_extend_chars.md", "category": "linters", "name": "linters/clippy/string_extend_chars", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/strlen_on_c_strings.md", "category": "linters", "name": "linters/clippy/strlen_on_c_strings", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_asserts_for_indexing.md", "category": "linters", "name": "linters/clippy/missing_asserts_for_indexing", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/vec_box.md", "category": "linters", "name": "linters/clippy/vec_box", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/box_default.md", "category": "linters", "name": "linters/clippy/box_default", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/string_to_string.md", "category": "linters", "name": "linters/clippy/string_to_string", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/confusing_method_to_numeric_cast.md", "category": "linters", "name": "linters/clippy/confusing_method_to_numeric_cast", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/repeat_once.md", "category": "linters", "name": "linters/clippy/repeat_once", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_mut_passed.md", "category": "linters", "name": "linters/clippy/unnecessary_mut_passed", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/as_underscore.md", "category": "linters", "name": "linters/clippy/as_underscore", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/drop_non_drop.md", "category": "linters", "name": "linters/clippy/drop_non_drop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/init_numbered_fields.md", "category": "linters", "name": "linters/clippy/init_numbered_fields", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/inline_asm_x86_intel_syntax.md", "category": "linters", "name": "linters/clippy/inline_asm_x86_intel_syntax", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_safety_doc.md", "category": "linters", "name": "linters/clippy/missing_safety_doc", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ifs_same_cond.md", "category": "linters", "name": "linters/clippy/ifs_same_cond", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/not_unsafe_ptr_arg_deref.md", "category": "linters", "name": "linters/clippy/not_unsafe_ptr_arg_deref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unimplemented.md", "category": "linters", "name": "linters/clippy/unimplemented", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/elidable_lifetime_names.md", "category": "linters", "name": "linters/clippy/elidable_lifetime_names", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unusual_byte_groupings.md", "category": "linters", "name": "linters/clippy/unusual_byte_groupings", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/too_many_lines.md", "category": "linters", "name": "linters/clippy/too_many_lines", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/inspect_for_each.md", "category": "linters", "name": "linters/clippy/inspect_for_each", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/items_after_statements.md", "category": "linters", "name": "linters/clippy/items_after_statements", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/match_wildcard_for_single_variants.md", "category": "linters", "name": "linters/clippy/match_wildcard_for_single_variants", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/range_step_by_zero.md", "category": "linters", "name": "linters/clippy/range_step_by_zero", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/uninhabited_references.md", "category": "linters", "name": "linters/clippy/uninhabited_references", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/inline_asm_x86_att_syntax.md", "category": "linters", "name": "linters/clippy/inline_asm_x86_att_syntax", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/nonstandard_macro_braces.md", "category": "linters", "name": "linters/clippy/nonstandard_macro_braces", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/float_cmp.md", "category": "linters", "name": "linters/clippy/float_cmp", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/neg_cmp_op_on_partial_ord.md", "category": "linters", "name": "linters/clippy/neg_cmp_op_on_partial_ord", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unwrap_or_default.md", "category": "linters", "name": "linters/clippy/unwrap_or_default", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/multiple_inherent_impl.md", "category": "linters", "name": "linters/clippy/multiple_inherent_impl", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/filter_map_next.md", "category": "linters", "name": "linters/clippy/filter_map_next", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_guards.md", "category": "linters", "name": "linters/clippy/redundant_guards", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_question_mark.md", "category": "linters", "name": "linters/clippy/needless_question_mark", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/if_then_some_else_none.md", "category": "linters", "name": "linters/clippy/if_then_some_else_none", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/zst_offset.md", "category": "linters", "name": "linters/clippy/zst_offset", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_allocation.md", "category": "linters", "name": "linters/clippy/redundant_allocation", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/transmute_int_to_bool.md", "category": "linters", "name": "linters/clippy/transmute_int_to_bool", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_filter.md", "category": "linters", "name": "linters/clippy/manual_filter", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/let_underscore_untyped.md", "category": "linters", "name": "linters/clippy/let_underscore_untyped", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/match_result_ok.md", "category": "linters", "name": "linters/clippy/match_result_ok", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/checked_conversions.md", "category": "linters", "name": "linters/clippy/checked_conversions", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unit_arg.md", "category": "linters", "name": "linters/clippy/unit_arg", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/alloc_instead_of_core.md", "category": "linters", "name": "linters/clippy/alloc_instead_of_core", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/explicit_deref_methods.md", "category": "linters", "name": "linters/clippy/explicit_deref_methods", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/useless_conversion.md", "category": "linters", "name": "linters/clippy/useless_conversion", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/many_single_char_names.md", "category": "linters", "name": "linters/clippy/many_single_char_names", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_bool.md", "category": "linters", "name": "linters/clippy/needless_bool", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/derive_ord_xor_partial_ord.md", "category": "linters", "name": "linters/clippy/derive_ord_xor_partial_ord", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/short_circuit_statement.md", "category": "linters", "name": "linters/clippy/short_circuit_statement", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unbuffered_bytes.md", "category": "linters", "name": "linters/clippy/unbuffered_bytes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/match_single_binding.md", "category": "linters", "name": "linters/clippy/match_single_binding", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/double_ended_iterator_last.md", "category": "linters", "name": "linters/clippy/double_ended_iterator_last", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_clone.md", "category": "linters", "name": "linters/clippy/redundant_clone", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suboptimal_flops.md", "category": "linters", "name": "linters/clippy/suboptimal_flops", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/decimal_bitwise_operands.md", "category": "linters", "name": "linters/clippy/decimal_bitwise_operands", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_slicing.md", "category": "linters", "name": "linters/clippy/redundant_slicing", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_pattern.md", "category": "linters", "name": "linters/clippy/redundant_pattern", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_parens_on_range_literals.md", "category": "linters", "name": "linters/clippy/needless_parens_on_range_literals", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ineffective_open_options.md", "category": "linters", "name": "linters/clippy/ineffective_open_options", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_for_each.md", "category": "linters", "name": "linters/clippy/needless_for_each", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/disallowed_names.md", "category": "linters", "name": "linters/clippy/disallowed_names", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_str_repeat.md", "category": "linters", "name": "linters/clippy/manual_str_repeat", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/upper_case_acronyms.md", "category": "linters", "name": "linters/clippy/upper_case_acronyms", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/new_ret_no_self.md", "category": "linters", "name": "linters/clippy/new_ret_no_self", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cloned_instead_of_copied.md", "category": "linters", "name": "linters/clippy/cloned_instead_of_copied", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_to_owned.md", "category": "linters", "name": "linters/clippy/unnecessary_to_owned", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/infinite_loop.md", "category": "linters", "name": "linters/clippy/infinite_loop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unsound_collection_transmute.md", "category": "linters", "name": "linters/clippy/unsound_collection_transmute", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/read_zero_byte_vec.md", "category": "linters", "name": "linters/clippy/read_zero_byte_vec", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/redundant_pub_crate.md", "category": "linters", "name": "linters/clippy/redundant_pub_crate", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/misnamed_getters.md", "category": "linters", "name": "linters/clippy/misnamed_getters", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/option_option.md", "category": "linters", "name": "linters/clippy/option_option", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/default_union_representation.md", "category": "linters", "name": "linters/clippy/default_union_representation", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/disallowed_methods.md", "category": "linters", "name": "linters/clippy/disallowed_methods", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_option_as_slice.md", "category": "linters", "name": "linters/clippy/manual_option_as_slice", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/stable_sort_primitive.md", "category": "linters", "name": "linters/clippy/stable_sort_primitive", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/inherent_to_string.md", "category": "linters", "name": "linters/clippy/inherent_to_string", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/len_zero.md", "category": "linters", "name": "linters/clippy/len_zero", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/multiple_crate_versions.md", "category": "linters", "name": "linters/clippy/multiple_crate_versions", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/useless_concat.md", "category": "linters", "name": "linters/clippy/useless_concat", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/range_zip_with_len.md", "category": "linters", "name": "linters/clippy/range_zip_with_len", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/implicit_hasher.md", "category": "linters", "name": "linters/clippy/implicit_hasher", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/result_large_err.md", "category": "linters", "name": "linters/clippy/result_large_err", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ref_option_ref.md", "category": "linters", "name": "linters/clippy/ref_option_ref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/flat_map_option.md", "category": "linters", "name": "linters/clippy/flat_map_option", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/assign_op_pattern.md", "category": "linters", "name": "linters/clippy/assign_op_pattern", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/owned_cow.md", "category": "linters", "name": "linters/clippy/owned_cow", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/non_minimal_cfg.md", "category": "linters", "name": "linters/clippy/non_minimal_cfg", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_filter_map.md", "category": "linters", "name": "linters/clippy/manual_filter_map", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/regex_creation_in_loops.md", "category": "linters", "name": "linters/clippy/regex_creation_in_loops", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/lossy_float_literal.md", "category": "linters", "name": "linters/clippy/lossy_float_literal", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_swap.md", "category": "linters", "name": "linters/clippy/manual_swap", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/rc_mutex.md", "category": "linters", "name": "linters/clippy/rc_mutex", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/exhaustive_structs.md", "category": "linters", "name": "linters/clippy/exhaustive_structs", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/option_as_ref_deref.md", "category": "linters", "name": "linters/clippy/option_as_ref_deref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cast_slice_different_sizes.md", "category": "linters", "name": "linters/clippy/cast_slice_different_sizes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/string_lit_as_bytes.md", "category": "linters", "name": "linters/clippy/string_lit_as_bytes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/excessive_nesting.md", "category": "linters", "name": "linters/clippy/excessive_nesting", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/slow_vector_initialization.md", "category": "linters", "name": "linters/clippy/slow_vector_initialization", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/default_instead_of_iter_empty.md", "category": "linters", "name": "linters/clippy/default_instead_of_iter_empty", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/empty_enum_variants_with_brackets.md", "category": "linters", "name": "linters/clippy/empty_enum_variants_with_brackets", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unused_rounding.md", "category": "linters", "name": "linters/clippy/unused_rounding", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/string_lit_chars_any.md", "category": "linters", "name": "linters/clippy/string_lit_chars_any", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/borrow_interior_mutable_const.md", "category": "linters", "name": "linters/clippy/borrow_interior_mutable_const", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/diverging_sub_expression.md", "category": "linters", "name": "linters/clippy/diverging_sub_expression", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/to_string_in_format_args.md", "category": "linters", "name": "linters/clippy/to_string_in_format_args", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/eq_op.md", "category": "linters", "name": "linters/clippy/eq_op", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/transmute_null_to_fn.md", "category": "linters", "name": "linters/clippy/transmute_null_to_fn", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mutex_integer.md", "category": "linters", "name": "linters/clippy/mutex_integer", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/map_with_unused_argument_over_ranges.md", "category": "linters", "name": "linters/clippy/map_with_unused_argument_over_ranges", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/verbose_file_reads.md", "category": "linters", "name": "linters/clippy/verbose_file_reads", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/arithmetic_side_effects.md", "category": "linters", "name": "linters/clippy/arithmetic_side_effects", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/shadow_unrelated.md", "category": "linters", "name": "linters/clippy/shadow_unrelated", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_collect.md", "category": "linters", "name": "linters/clippy/needless_collect", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/if_let_mutex.md", "category": "linters", "name": "linters/clippy/if_let_mutex", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious_command_arg_space.md", "category": "linters", "name": "linters/clippy/suspicious_command_arg_space", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/allow_attributes.md", "category": "linters", "name": "linters/clippy/allow_attributes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/if_not_else.md", "category": "linters", "name": "linters/clippy/if_not_else", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cast_lossless.md", "category": "linters", "name": "linters/clippy/cast_lossless", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_safety_comment.md", "category": "linters", "name": "linters/clippy/unnecessary_safety_comment", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/partialeq_to_none.md", "category": "linters", "name": "linters/clippy/partialeq_to_none", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/trivial_regex.md", "category": "linters", "name": "linters/clippy/trivial_regex", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/panic.md", "category": "linters", "name": "linters/clippy/panic", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_abs_diff.md", "category": "linters", "name": "linters/clippy/manual_abs_diff", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/imprecise_flops.md", "category": "linters", "name": "linters/clippy/imprecise_flops", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/just_underscores_and_digits.md", "category": "linters", "name": "linters/clippy/just_underscores_and_digits", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/impl_hash_borrow_with_str_and_bytes.md", "category": "linters", "name": "linters/clippy/impl_hash_borrow_with_str_and_bytes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/assign_ops.md", "category": "linters", "name": "linters/clippy/assign_ops", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/match_like_matches_macro.md", "category": "linters", "name": "linters/clippy/match_like_matches_macro", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_c_str_literals.md", "category": "linters", "name": "linters/clippy/manual_c_str_literals", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/forget_non_drop.md", "category": "linters", "name": "linters/clippy/forget_non_drop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/double_comparisons.md", "category": "linters", "name": "linters/clippy/double_comparisons", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/large_futures.md", "category": "linters", "name": "linters/clippy/large_futures", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_out_of_bounds.md", "category": "linters", "name": "linters/clippy/iter_out_of_bounds", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/derive_partial_eq_without_eq.md", "category": "linters", "name": "linters/clippy/derive_partial_eq_without_eq", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cast_nan_to_int.md", "category": "linters", "name": "linters/clippy/cast_nan_to_int", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/impossible_comparisons.md", "category": "linters", "name": "linters/clippy/impossible_comparisons", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/while_let_loop.md", "category": "linters", "name": "linters/clippy/while_let_loop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/non_canonical_partial_ord_impl.md", "category": "linters", "name": "linters/clippy/non_canonical_partial_ord_impl", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unused_trait_names.md", "category": "linters", "name": "linters/clippy/unused_trait_names", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_fold.md", "category": "linters", "name": "linters/clippy/unnecessary_fold", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/explicit_into_iter_loop.md", "category": "linters", "name": "linters/clippy/explicit_into_iter_loop", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/get_last_with_len.md", "category": "linters", "name": "linters/clippy/get_last_with_len", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/or_fun_call.md", "category": "linters", "name": "linters/clippy/or_fun_call", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/missing_trait_methods.md", "category": "linters", "name": "linters/clippy/missing_trait_methods", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/implicit_saturating_sub.md", "category": "linters", "name": "linters/clippy/implicit_saturating_sub", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unneeded_field_pattern.md", "category": "linters", "name": "linters/clippy/unneeded_field_pattern", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_option_map_or_else.md", "category": "linters", "name": "linters/clippy/unnecessary_option_map_or_else", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/read_line_without_trim.md", "category": "linters", "name": "linters/clippy/read_line_without_trim", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_count.md", "category": "linters", "name": "linters/clippy/iter_count", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/doc_link_code.md", "category": "linters", "name": "linters/clippy/doc_link_code", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_slice_size_calculation.md", "category": "linters", "name": "linters/clippy/manual_slice_size_calculation", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/implicit_return.md", "category": "linters", "name": "linters/clippy/implicit_return", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/literal_string_with_formatting_args.md", "category": "linters", "name": "linters/clippy/literal_string_with_formatting_args", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_clippy_cfg.md", "category": "linters", "name": "linters/clippy/unnecessary_clippy_cfg", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/pathbuf_init_then_push.md", "category": "linters", "name": "linters/clippy/pathbuf_init_then_push", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/assertions_on_constants.md", "category": "linters", "name": "linters/clippy/assertions_on_constants", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/copy_iterator.md", "category": "linters", "name": "linters/clippy/copy_iterator", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/option_if_let_else.md", "category": "linters", "name": "linters/clippy/option_if_let_else", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_skip_next.md", "category": "linters", "name": "linters/clippy/iter_skip_next", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/map_identity.md", "category": "linters", "name": "linters/clippy/map_identity", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/correctness.md", "category": "linters", "name": "linters/clippy/correctness", "content": "# Clippy Correctness Lints\n\nLints that detect code that is likely wrong. Default: deny.\n\n## approx_constant\n\nUse standard math constants.\n\n```rust\n// BAD\nlet pi = 3.14159265358979;\nlet e = 2.71828;\n\n// GOOD\nuse std::f64::consts::{PI, E};\nlet pi = PI;\nlet e = E;\n```\n\n## derive_ord_xor_partial_ord\n\nOrd and PartialOrd must agree.\n\n```rust\n// BAD - derived Ord might differ from manual PartialOrd\n#[derive(Ord, PartialEq, Eq)]\nstruct Foo {\n    a: i32,\n}\n\nimpl PartialOrd for Foo {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        // custom implementation\n    }\n}\n\n// GOOD - derive both or implement both\n#[derive(PartialEq, Eq, PartialOrd, Ord)]\nstruct Foo {\n    a: i32,\n}\n```\n\n## enum_clike_unportable_variant\n\nC-like enum variants must fit in target int.\n\n```rust\n// BAD on 32-bit\n#[repr(isize)]\nenum Foo {\n    A = 0x1_0000_0000,  // overflow on 32-bit\n}\n\n// GOOD\n#[repr(i64)]\nenum Foo {\n    A = 0x1_0000_0000,\n}\n```\n\n## eq_op\n\nComparing identical operands.\n\n```rust\n// BAD\nif x == x { }\nassert!(y != y);\n\n// GOOD\nif x == y { }\n```\n\n## erasing_op\n\nOperation that always produces same result.\n\n```rust\n// BAD\nlet _ = x * 0;  // always 0\nlet _ = x & 0;  // always 0\nlet _ = x | !0; // always !0\n\n// GOOD - if intentional, assign directly\nlet _ = 0;\n```\n\n## fn_address_comparisons\n\nComparing function pointers is unreliable.\n\n```rust\n// BAD\nif foo as fn() == bar as fn() { }\n\n// GOOD - use function identity some other way\n```\n\n## if_let_mutex\n\nLock held across await point.\n\n```rust\n// BAD\nif let Some(x) = mutex.lock().unwrap().as_ref() {\n    async_op().await;  // lock held during await!\n}\n\n// GOOD\nlet value = {\n    let guard = mutex.lock().unwrap();\n    guard.as_ref().cloned()\n};\nif let Some(x) = value {\n    async_op().await;\n}\n```\n\n## ifs_same_cond\n\nMultiple if branches with same condition.\n\n```rust\n// BAD\nif x > 0 {\n    foo();\n} else if x > 0 {  // same condition!\n    bar();\n}\n\n// GOOD\nif x > 0 {\n    foo();\n} else if x < 0 {\n    bar();\n}\n```\n\n## impl_hash_borrow_with_str_and_bytes\n\nHash implementations must be consistent.\n\n```rust\n// BAD - Hash and Borrow<str> disagree\nimpl Hash for Foo {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.0.as_bytes().hash(state);  // hashes bytes\n    }\n}\n\nimpl Borrow<str> for Foo {\n    fn borrow(&self) -> &str {\n        &self.0  // borrows as str - different hash!\n    }\n}\n```\n\n## impossible_comparisons\n\nComparison that's always true or false.\n\n```rust\n// BAD\nlet x: u32 = get_value();\nif x < 0 { }  // always false - u32 can't be negative\n\n// GOOD\nlet x: i32 = get_value();\nif x < 0 { }\n```\n\n## ineffective_bit_mask\n\nBit mask has no effect.\n\n```rust\n// BAD\nif (x & 1 == 2) { }  // impossible - x & 1 is 0 or 1\n\n// GOOD\nif (x & 2 == 2) { }\n```\n\n## infinite_iter\n\nIterator that never terminates.\n\n```rust\n// BAD\nlet _ = (0..).collect::<Vec<_>>();  // infinite!\n\n// GOOD\nlet _ = (0..100).collect::<Vec<_>>();\n```\n\n## inherent_to_string_shadow_display\n\nto_string() shadows Display.\n\n```rust\n// BAD\nstruct Foo;\n\nimpl Foo {\n    fn to_string(&self) -> String {\n        \"foo\".into()\n    }\n}\n\nimpl Display for Foo {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        write!(f, \"different\")  // this won't be used by to_string()!\n    }\n}\n\n// GOOD - just implement Display\nimpl Display for Foo {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        write!(f, \"foo\")\n    }\n}\n```\n\n## invalid_regex\n\nInvalid regular expression.\n\n```rust\n// BAD\nRegex::new(\"(unclosed\");\nRegex::new(\"[invalid\");\n\n// GOOD\nRegex::new(r\"valid\\s+regex\")?;\n```\n\n## iter_next_loop\n\nUsing .next() in for loop.\n\n```rust\n// BAD - consumes extra element\nfor x in iter.next() { }\n\n// GOOD\nfor x in iter { }\n```\n\n## iter_skip_next\n\n.skip(n).next() should be .nth(n).\n\n```rust\n// BAD\niter.skip(5).next()\n\n// GOOD\niter.nth(5)\n```\n\n## let_underscore_lock\n\nDropping lock guard immediately.\n\n```rust\n// BAD - lock released immediately!\nlet _ = mutex.lock().unwrap();\n// critical section here is NOT protected\n\n// GOOD - hold the guard\nlet _guard = mutex.lock().unwrap();\n// critical section IS protected\n```\n\n## match_ref_pats\n\nMatch on reference with ref patterns.\n\n```rust\n// BAD\nmatch &x {\n    &Some(ref y) => { }\n    &None => { }\n}\n\n// GOOD\nmatch x {\n    Some(ref y) => { }\n    None => { }\n}\n\n// Or match on reference directly\nmatch &x {\n    Some(y) => { }  // y is &T\n    None => { }\n}\n```\n\n## min_max\n\nmin/max with swapped arguments.\n\n```rust\n// BAD\nstd::cmp::min(10, std::cmp::max(x, 10))  // always 10\n\n// GOOD - clamp\nx.clamp(5, 10)\n```\n\n## misrefactored_assign_op\n\nAssignment operator misuse.\n\n```rust\n// BAD - probably meant +=\na = a + b;\n\n// GOOD\na += b;\n```\n\n## modulo_one\n\nModulo 1 is always 0.\n\n```rust\n// BAD\nlet remainder = x % 1;  // always 0\n\n// Remove or fix the operation\n```\n\n## never_loop\n\nLoop that never loops.\n\n```rust\n// BAD\nloop {\n    break;  // only runs once\n}\n\n// GOOD\nif condition {\n    do_something();\n}\n```\n\n## non_octal_unix_permissions\n\nInvalid unix permissions.\n\n```rust\n// BAD\nfs::set_permissions(path, Permissions::from_mode(644));  // not octal!\n\n// GOOD\nfs::set_permissions(path, Permissions::from_mode(0o644));\n```\n\n## nonsensical_open_options\n\nConflicting file open options.\n\n```rust\n// BAD\nFile::options()\n    .read(true)\n    .truncate(true)  // truncate requires write!\n    .open(path)?;\n\n// GOOD\nFile::options()\n    .write(true)\n    .truncate(true)\n    .open(path)?;\n```\n\n## not_unsafe_ptr_arg_deref\n\nDereferencing pointer in safe function.\n\n```rust\n// BAD\nfn foo(ptr: *const i32) {\n    unsafe { *ptr }  // caller can't guarantee validity\n}\n\n// GOOD - mark function unsafe\nunsafe fn foo(ptr: *const i32) -> i32 {\n    *ptr\n}\n```\n\n## option_env_unwrap\n\nPanicking on missing env var.\n\n```rust\n// BAD - panics if not set at compile time\nlet key = option_env!(\"API_KEY\").unwrap();\n\n// GOOD - handle missing\nlet key = option_env!(\"API_KEY\").unwrap_or(\"default\");\n\n// Or use env! if required\nlet key = env!(\"API_KEY\");  // compile error if missing\n```\n\n## out_of_bounds_indexing\n\nIndex out of bounds.\n\n```rust\n// BAD\nlet arr = [1, 2, 3];\nlet x = arr[3];  // out of bounds!\n\n// GOOD\nlet x = arr.get(3);  // returns None\n```\n\n## panicking_unwrap\n\nUnwrap on value that's guaranteed to panic.\n\n```rust\n// BAD\nlet x: Option<i32> = None;\nx.unwrap();  // guaranteed panic\n\n// GOOD\nlet x: Option<i32> = Some(5);\nx.unwrap();  // OK\n```\n\n## recursive_format_impl\n\nInfinite recursion in format implementation.\n\n```rust\n// BAD\nimpl Display for Foo {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        write!(f, \"{}\", self)  // infinite recursion!\n    }\n}\n\n// GOOD\nimpl Display for Foo {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.value)\n    }\n}\n```\n\n## size_of_in_element_count\n\nWrong use of size_of in allocation.\n\n```rust\n// BAD\nlet ptr = alloc(Layout::from_size_align(\n    n * std::mem::size_of::<T>() * std::mem::size_of::<T>(),  // doubled!\n    align\n)?);\n\n// GOOD\nlet ptr = alloc(Layout::from_size_align(\n    n * std::mem::size_of::<T>(),\n    align\n)?);\n```\n\n## transmute_null\n\nTransmuting null.\n\n```rust\n// BAD\nlet null: *const i32 = std::mem::transmute(0usize);\n\n// GOOD\nlet null: *const i32 = std::ptr::null();\n```\n\n## unit_cmp\n\nComparing unit values.\n\n```rust\n// BAD\nif foo() == bar() { }  // both return ()\n\n// GOOD\nfoo();\nbar();\n```\n\n## unit_hash\n\nHashing unit type.\n\n```rust\n// BAD\nlet mut hasher = DefaultHasher::new();\n().hash(&mut hasher);  // useless\n```\n\n## while_immutable_condition\n\nCondition never changes in loop.\n\n```rust\n// BAD\nlet cond = true;\nwhile cond {  // infinite loop!\n    do_something();\n}\n\n// GOOD\nlet mut cond = true;\nwhile cond {\n    do_something();\n    cond = check();\n}\n```\n\n## wrong_transmute\n\nTransmute between incompatible types.\n\n```rust\n// BAD\nlet x: i32 = std::mem::transmute([0u8; 2]);  // size mismatch!\n\n// GOOD\nlet x: i32 = std::mem::transmute([0u8; 4]);\n```\n\n## zst_offset\n\nOffset on zero-sized type.\n\n```rust\n// BAD\nlet ptr: *const () = &();\nlet ptr2 = ptr.offset(1);  // meaningless for ZST\n\n// Don't use offset with ZSTs\n```\n"}, {"path": "linters/clippy/redundant_comparisons.md", "category": "linters", "name": "linters/clippy/redundant_comparisons", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious_arithmetic_impl.md", "category": "linters", "name": "linters/clippy/suspicious_arithmetic_impl", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unconditional_recursion.md", "category": "linters", "name": "linters/clippy/unconditional_recursion", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/cast_abs_to_unsigned.md", "category": "linters", "name": "linters/clippy/cast_abs_to_unsigned", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/extra_unused_lifetimes.md", "category": "linters", "name": "linters/clippy/extra_unused_lifetimes", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/while_let_on_iterator.md", "category": "linters", "name": "linters/clippy/while_let_on_iterator", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/shadow_same.md", "category": "linters", "name": "linters/clippy/shadow_same", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_on_empty_collections.md", "category": "linters", "name": "linters/clippy/iter_on_empty_collections", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_on_single_items.md", "category": "linters", "name": "linters/clippy/iter_on_single_items", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/inline_always.md", "category": "linters", "name": "linters/clippy/inline_always", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unused_enumerate_index.md", "category": "linters", "name": "linters/clippy/unused_enumerate_index", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/match_on_vec_items.md", "category": "linters", "name": "linters/clippy/match_on_vec_items", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_return_with_question_mark.md", "category": "linters", "name": "linters/clippy/needless_return_with_question_mark", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/self_only_used_in_recursion.md", "category": "linters", "name": "linters/clippy/self_only_used_in_recursion", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_update.md", "category": "linters", "name": "linters/clippy/needless_update", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ignore_without_reason.md", "category": "linters", "name": "linters/clippy/ignore_without_reason", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/ptr_as_ptr.md", "category": "linters", "name": "linters/clippy/ptr_as_ptr", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/erasing_op.md", "category": "linters", "name": "linters/clippy/erasing_op", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/empty_docs.md", "category": "linters", "name": "linters/clippy/empty_docs", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/let_unit_value.md", "category": "linters", "name": "linters/clippy/let_unit_value", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/inefficient_to_string.md", "category": "linters", "name": "linters/clippy/inefficient_to_string", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/multiple_unsafe_ops_per_block.md", "category": "linters", "name": "linters/clippy/multiple_unsafe_ops_per_block", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/return_self_not_must_use.md", "category": "linters", "name": "linters/clippy/return_self_not_must_use", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/almost_complete_range.md", "category": "linters", "name": "linters/clippy/almost_complete_range", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/iter_filter_is_some.md", "category": "linters", "name": "linters/clippy/iter_filter_is_some", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/toplevel_ref_arg.md", "category": "linters", "name": "linters/clippy/toplevel_ref_arg", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/manual_saturating_arithmetic.md", "category": "linters", "name": "linters/clippy/manual_saturating_arithmetic", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/linkedlist.md", "category": "linters", "name": "linters/clippy/linkedlist", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_box_returns.md", "category": "linters", "name": "linters/clippy/unnecessary_box_returns", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/fallible_impl_from.md", "category": "linters", "name": "linters/clippy/fallible_impl_from", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/collection_is_never_read.md", "category": "linters", "name": "linters/clippy/collection_is_never_read", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/suspicious_assignment_formatting.md", "category": "linters", "name": "linters/clippy/suspicious_assignment_formatting", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/needless_arbitrary_self_type.md", "category": "linters", "name": "linters/clippy/needless_arbitrary_self_type", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/unnecessary_literal_unwrap.md", "category": "linters", "name": "linters/clippy/unnecessary_literal_unwrap", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/large_enum_variant.md", "category": "linters", "name": "linters/clippy/large_enum_variant", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/trivially_copy_pass_by_ref.md", "category": "linters", "name": "linters/clippy/trivially_copy_pass_by_ref", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/complexity.md", "category": "linters", "name": "linters/clippy/complexity", "content": "# Clippy Complexity Lints\n\nLints for overcomplicated code that can be simplified.\n\n## bind_instead_of_map\n\nUsing and_then/or_else when map suffices.\n\n```rust\n// BAD\nopt.and_then(|x| Some(x + 1))\nresult.or_else(|_| Err(default_err))\n\n// GOOD\nopt.map(|x| x + 1)\nresult.map_err(|_| default_err)\n```\n\n## bool_comparison\n\nComparing boolean to literal.\n\n```rust\n// BAD\nif b == true { }\nif b == false { }\n\n// GOOD\nif b { }\nif !b { }\n```\n\n## borrow_deref_ref\n\nBorrowing then dereferencing then referencing.\n\n```rust\n// BAD\nlet y = &*&x;\n\n// GOOD\nlet y = &x;\n```\n\n## bytes_count_to_len\n\nUsing bytes().count() on string.\n\n```rust\n// BAD\ns.bytes().count()\n\n// GOOD\ns.len()\n```\n\n## char_lit_as_u8\n\nCasting char literal to u8.\n\n```rust\n// BAD\nlet b = 'a' as u8;\n\n// GOOD\nlet b = b'a';\n```\n\n## clone_on_copy\n\nCalling clone on Copy type.\n\n```rust\n// BAD\nlet y = x.clone();  // x: i32\n\n// GOOD\nlet y = x;  // just copy\n```\n\n## crosspointer_transmute\n\nTransmuting between pointer and non-pointer.\n\n```rust\n// BAD\nlet ptr: *const i32 = unsafe { std::mem::transmute(x) };\n\n// GOOD\nlet ptr = &x as *const i32;\n```\n\n## derivable_impls\n\nImplementation that could be derived.\n\n```rust\n// BAD\nimpl Default for Foo {\n    fn default() -> Self {\n        Self { x: 0, y: String::new() }\n    }\n}\n\n// GOOD\n#[derive(Default)]\nstruct Foo {\n    x: i32,\n    y: String,\n}\n```\n\n## diverging_sub_expression\n\nDiverging expression in non-diverging context.\n\n```rust\n// BAD\nlet x = if condition { 1 } else { panic!() };\n\n// GOOD - make it clear this is intentional\nlet x = if condition { 1 } else { unreachable!() };\n```\n\n## double_comparisons\n\nRedundant double comparisons.\n\n```rust\n// BAD\nx < y || x == y\n\n// GOOD\nx <= y\n```\n\n## double_parens\n\nUnnecessary double parentheses.\n\n```rust\n// BAD\n((x))\nfoo((bar))\n\n// GOOD\n(x)\nfoo(bar)\n```\n\n## duration_subsec\n\nGetting subsec then converting.\n\n```rust\n// BAD\nduration.subsec_nanos() as u64 / 1_000_000\n\n// GOOD\nduration.subsec_millis()\n```\n\n## excessive_nesting\n\nToo much nesting.\n\n```rust\n// BAD\nfn foo() {\n    if a {\n        if b {\n            for x in items {\n                if c {\n                    match d {\n                        // ...\n                    }\n                }\n            }\n        }\n    }\n}\n\n// GOOD - extract functions, use early returns\nfn foo() {\n    if !a || !b { return; }\n    for x in items {\n        process_item(x);\n    }\n}\n```\n\n## explicit_counter_loop\n\nManual counter in for loop.\n\n```rust\n// BAD\nlet mut i = 0;\nfor x in items {\n    println!(\"{}: {}\", i, x);\n    i += 1;\n}\n\n// GOOD\nfor (i, x) in items.iter().enumerate() {\n    println!(\"{}: {}\", i, x);\n}\n```\n\n## explicit_write\n\nUsing write! to stdout/stderr.\n\n```rust\n// BAD\nwrite!(std::io::stdout(), \"hello\")?;\nwrite!(std::io::stderr(), \"error\")?;\n\n// GOOD\nprint!(\"hello\");\neprint!(\"error\");\n```\n\n## extra_unused_lifetimes\n\nUnnecessary lifetime parameters.\n\n```rust\n// BAD\nfn foo<'a>(x: &i32) -> &i32 { x }\n\n// GOOD\nfn foo(x: &i32) -> &i32 { x }\n```\n\n## extra_unused_type_parameters\n\nUnnecessary type parameters.\n\n```rust\n// BAD\nfn foo<T>(x: i32) -> i32 { x }\n\n// GOOD\nfn foo(x: i32) -> i32 { x }\n```\n\n## filter_map_bool_then\n\nUsing filter_map with bool::then.\n\n```rust\n// BAD\niter.filter_map(|x| (x > 0).then(|| x))\n\n// GOOD\niter.filter(|x| *x > 0)\n```\n\n## filter_next\n\nUsing filter + next.\n\n```rust\n// BAD\niter.filter(|x| x.is_valid()).next()\n\n// GOOD\niter.find(|x| x.is_valid())\n```\n\n## flat_map_identity\n\nUsing flat_map with identity.\n\n```rust\n// BAD\niter.flat_map(|x| x)\n\n// GOOD\niter.flatten()\n```\n\n## get_first\n\nUsing get(0).\n\n```rust\n// BAD\nvec.get(0)\n\n// GOOD\nvec.first()\n```\n\n## get_last_with_len\n\nUsing get(len - 1).\n\n```rust\n// BAD\nvec.get(vec.len() - 1)\n\n// GOOD\nvec.last()\n```\n\n## identity_op\n\nIdentity operation.\n\n```rust\n// BAD\nx + 0\nx * 1\nx / 1\n\n// GOOD - remove the operation\nx\n```\n\n## if_same_then_else\n\nIf branches with identical bodies.\n\n```rust\n// BAD\nif condition {\n    foo();\n} else {\n    foo();\n}\n\n// GOOD\nfoo();\n```\n\n## int_plus_one\n\nUsing n + 1 in comparison.\n\n```rust\n// BAD\nif x >= y + 1 { }\nif x + 1 <= y { }\n\n// GOOD\nif x > y { }\nif x < y { }\n```\n\n## iter_count\n\nUsing iter().count() on collection.\n\n```rust\n// BAD\nvec.iter().count()\n\n// GOOD\nvec.len()\n```\n\n## iter_kv_map\n\nIterating map for transformation.\n\n```rust\n// BAD\nmap.iter().map(|(k, _)| k.clone()).collect()\n\n// GOOD\nmap.keys().cloned().collect()\n```\n\n## iter_skip_zero\n\nSkipping zero elements.\n\n```rust\n// BAD\niter.skip(0)\n\n// Remove the skip\niter\n```\n\n## manual_filter\n\nManual filter pattern.\n\n```rust\n// BAD\nmatch opt {\n    Some(x) if predicate(x) => Some(x),\n    _ => None,\n}\n\n// GOOD\nopt.filter(|x| predicate(x))\n```\n\n## manual_filter_map\n\nManual filter_map pattern.\n\n```rust\n// BAD\niter.filter(|x| x.is_some()).map(|x| x.unwrap())\n\n// GOOD\niter.filter_map(|x| x)\niter.flatten()\n```\n\n## manual_find\n\nManual find pattern.\n\n```rust\n// BAD\nfor x in iter {\n    if predicate(&x) {\n        return Some(x);\n    }\n}\nNone\n\n// GOOD\niter.find(|x| predicate(x))\n```\n\n## manual_find_map\n\nManual find_map pattern.\n\n```rust\n// BAD\nfor x in iter {\n    if let Some(y) = transform(x) {\n        return Some(y);\n    }\n}\nNone\n\n// GOOD\niter.find_map(transform)\n```\n\n## manual_flatten\n\nManual flatten pattern.\n\n```rust\n// BAD\niter.filter_map(|x| x)\n\n// GOOD\niter.flatten()\n```\n\n## manual_is_ascii_check\n\nManual ASCII check.\n\n```rust\n// BAD\nc >= 'a' && c <= 'z'\nc >= '0' && c <= '9'\n\n// GOOD\nc.is_ascii_lowercase()\nc.is_ascii_digit()\n```\n\n## manual_is_finite\n\nManual finite check.\n\n```rust\n// BAD\n!x.is_nan() && !x.is_infinite()\n\n// GOOD\nx.is_finite()\n```\n\n## manual_is_infinite\n\nManual infinite check.\n\n```rust\n// BAD\nx == f64::INFINITY || x == f64::NEG_INFINITY\n\n// GOOD\nx.is_infinite()\n```\n\n## manual_main_separator_str\n\nManual path separator.\n\n```rust\n// BAD\n#[cfg(windows)]\nconst SEP: &str = \"\\\\\";\n#[cfg(not(windows))]\nconst SEP: &str = \"/\";\n\n// GOOD\nstd::path::MAIN_SEPARATOR_STR\n```\n\n## manual_next_back\n\nManual reverse iteration.\n\n```rust\n// BAD\niter.rev().next()\n\n// GOOD\niter.next_back()\n```\n\n## manual_ok_or\n\nManual ok_or pattern.\n\n```rust\n// BAD\nmatch opt {\n    Some(x) => Ok(x),\n    None => Err(e),\n}\n\n// GOOD\nopt.ok_or(e)\n```\n\n## manual_range_patterns\n\nManual range check.\n\n```rust\n// BAD\nmatches!(x, 1 | 2 | 3 | 4 | 5)\n\n// GOOD\nmatches!(x, 1..=5)\n```\n\n## manual_saturating_arithmetic\n\nManual saturating arithmetic.\n\n```rust\n// BAD\nif x > i32::MAX - y { i32::MAX } else { x + y }\n\n// GOOD\nx.saturating_add(y)\n```\n\n## manual_slice_size_calculation\n\nManual slice size calculation.\n\n```rust\n// BAD\nstd::mem::size_of::<T>() * slice.len()\n\n// GOOD\nstd::mem::size_of_val(slice)\n```\n\n## manual_split_once\n\nManual split_once pattern.\n\n```rust\n// BAD\nlet mut parts = s.splitn(2, '=');\nlet key = parts.next()?;\nlet value = parts.next()?;\n\n// GOOD\nlet (key, value) = s.split_once('=')?;\n```\n\n## manual_str_repeat\n\nManual string repeat.\n\n```rust\n// BAD\nlet mut s = String::new();\nfor _ in 0..n {\n    s.push_str(\"x\");\n}\n\n// GOOD\nlet s = \"x\".repeat(n);\n```\n\n## manual_strip\n\nManual strip pattern.\n\n```rust\n// BAD\nif s.starts_with(\"prefix\") {\n    &s[\"prefix\".len()..]\n}\n\n// GOOD\ns.strip_prefix(\"prefix\")\n```\n\n## manual_try_fold\n\nManual try_fold pattern.\n\n```rust\n// BAD\nlet mut acc = init;\nfor x in iter {\n    acc = f(acc, x)?;\n}\nOk(acc)\n\n// GOOD\niter.try_fold(init, f)\n```\n\n## manual_unwrap_or_default\n\nManual unwrap_or_default.\n\n```rust\n// BAD\nmatch opt {\n    Some(x) => x,\n    None => Default::default(),\n}\n\n// GOOD\nopt.unwrap_or_default()\n```\n\n## manual_while_let_some\n\nManual while let Some.\n\n```rust\n// BAD\nloop {\n    let Some(x) = iter.next() else { break };\n    // ...\n}\n\n// GOOD\nwhile let Some(x) = iter.next() {\n    // ...\n}\n```\n\n## map_flatten\n\nUsing map + flatten.\n\n```rust\n// BAD\niter.map(f).flatten()\n\n// GOOD\niter.flat_map(f)\n```\n\n## map_identity\n\nMapping with identity.\n\n```rust\n// BAD\niter.map(|x| x)\n\n// Remove the map\niter\n```\n\n## match_as_ref\n\nMatch instead of as_ref.\n\n```rust\n// BAD\nmatch opt {\n    Some(ref x) => Some(x),\n    None => None,\n}\n\n// GOOD\nopt.as_ref()\n```\n\n## match_likelyhood_any_default\n\nMatch with all wildcards.\n\n```rust\n// BAD\nmatch x {\n    _ if condition => foo(),\n    _ => bar(),\n}\n\n// GOOD\nif condition { foo() } else { bar() }\n```\n\n## match_single_binding\n\nMatch with single binding.\n\n```rust\n// BAD\nmatch (a, b) {\n    (x, y) => x + y,\n}\n\n// GOOD\nlet (x, y) = (a, b);\nx + y\n```\n\n## needless_arbitrary_self_type\n\nUnnecessary explicit self type.\n\n```rust\n// BAD\nfn foo(self: Self) { }\nfn bar(self: &Self) { }\nfn baz(self: &mut Self) { }\n\n// GOOD\nfn foo(self) { }\nfn bar(&self) { }\nfn baz(&mut self) { }\n```\n\n## needless_bool\n\nNeedless bool operations.\n\n```rust\n// BAD\nif condition { true } else { false }\nif condition { false } else { true }\n\n// GOOD\ncondition\n!condition\n```\n\n## needless_bool_assign\n\nNeedless bool assignment.\n\n```rust\n// BAD\nif condition {\n    x = true;\n} else {\n    x = false;\n}\n\n// GOOD\nx = condition;\n```\n\n## needless_borrowed_reference\n\nNeedless borrowed reference.\n\n```rust\n// BAD\nlet &ref x = &y;\n\n// GOOD\nlet x = &y;\n```\n\n## needless_if\n\nNeedless if.\n\n```rust\n// BAD\nif condition { }\n\n// Remove or add body\n```\n\n## needless_lifetimes\n\nUnnecessary lifetime annotations.\n\n```rust\n// BAD\nfn foo<'a>(x: &'a str) -> &'a str { x }\n\n// GOOD - elision works\nfn foo(x: &str) -> &str { x }\n```\n\n## needless_match\n\nNeedless match.\n\n```rust\n// BAD\nmatch result {\n    Ok(x) => Ok(x),\n    Err(e) => Err(e),\n}\n\n// GOOD\nresult\n```\n\n## needless_option_as_deref\n\nNeedless as_deref on owned Option.\n\n```rust\n// BAD\nSome(String::new()).as_deref()\n\n// GOOD\nSome(String::new()).as_ref().map(|s| s.as_str())\n```\n\n## needless_option_take\n\nNeedless take on owned Option.\n\n```rust\n// BAD\nlet x = opt.take();\n// opt never used again\n\n// GOOD\nlet x = opt;\n```\n\n## needless_question_mark\n\nUnnecessary question mark.\n\n```rust\n// BAD\nfn foo() -> Result<i32, Error> {\n    Ok(bar()?)\n}\n\n// GOOD\nfn foo() -> Result<i32, Error> {\n    bar()\n}\n```\n\n## needless_splitn\n\nSplitn when split suffices.\n\n```rust\n// BAD\ns.splitn(100, ',')\n\n// GOOD\ns.split(',')\n```\n\n## needless_update\n\nStruct update with no actual update.\n\n```rust\n// BAD\nFoo { x: 1, ..other }  // where other.x is overwritten\n\n// GOOD\nFoo { x: 1, y: other.y }\n```\n\n## neg_cmp_op_on_partial_ord\n\nNegating comparison on partial ord.\n\n```rust\n// BAD\n!(x < y)  // not same as x >= y for partial ord!\n\n// GOOD\nx >= y || x.partial_cmp(&y).is_none()\n```\n\n## no_effect\n\nNo effect statement.\n\n```rust\n// BAD\nx + 1;  // discarded\n0;\n\n// Remove or use result\nlet _ = x + 1;\n```\n\n## nonminimal_bool\n\nNon-minimal boolean expression.\n\n```rust\n// BAD\n!a || !b\n!(a && b && c)\n\n// GOOD\n!(a && b)\n!a || !b || !c\n```\n\n## only_used_in_recursion\n\nParameter only used in recursive call.\n\n```rust\n// BAD\nfn foo(x: i32, depth: i32) {\n    foo(x, depth + 1);\n}\n\n// Consider removing or using the parameter\n```\n\n## option_as_ref_deref\n\nOption as_ref then map deref.\n\n```rust\n// BAD\nopt.as_ref().map(|x| x.as_str())\n\n// GOOD\nopt.as_deref()\n```\n\n## option_filter_map\n\nOption filter then map.\n\n```rust\n// BAD\nopt.filter(|x| predicate(x)).map(|x| transform(x))\n\n// GOOD (sometimes)\nopt.and_then(|x| predicate(&x).then(|| transform(x)))\n```\n\n## option_map_or_none\n\nOption map_or with None.\n\n```rust\n// BAD\nopt.map_or(None, |x| Some(x + 1))\n\n// GOOD\nopt.map(|x| x + 1)\n```\n\n## option_map_unit_fn\n\nMap returning unit.\n\n```rust\n// BAD\nopt.map(|x| println!(\"{}\", x));\n\n// GOOD\nif let Some(x) = opt {\n    println!(\"{}\", x);\n}\n```\n\n## or_then_unwrap\n\nor_else then unwrap.\n\n```rust\n// BAD\nopt.or_else(|| Some(default)).unwrap()\n\n// GOOD\nopt.unwrap_or_else(|| default)\nopt.unwrap_or(default)\n```\n\n## partialeq_ne_impl\n\nImplementing ne when eq suffices.\n\n```rust\n// BAD\nimpl PartialEq for Foo {\n    fn eq(&self, other: &Self) -> bool { self.x == other.x }\n    fn ne(&self, other: &Self) -> bool { self.x != other.x }  // unnecessary\n}\n\n// GOOD - ne has default impl\nimpl PartialEq for Foo {\n    fn eq(&self, other: &Self) -> bool { self.x == other.x }\n}\n```\n\n## precedence\n\nPrecedence confusion.\n\n```rust\n// BAD\na << 1 + b  // means a << (1 + b)\n\n// GOOD - explicit parens\n(a << 1) + b\na << (1 + b)\n```\n\n## ptr_offset_with_cast\n\nPointer offset with cast.\n\n```rust\n// BAD\nptr.offset(n as isize)\n\n// GOOD\nptr.add(n)  // for unsigned\nptr.sub(n)  // for subtraction\n```\n\n## range_minus_one\n\nRange with minus one.\n\n```rust\n// BAD\nfor i in 0..n - 1 { }\n\n// GOOD\nfor i in 0..n.saturating_sub(1) { }\nfor i in 0..=n.saturating_sub(1) { }\n```\n\n## range_plus_one\n\nRange with plus one.\n\n```rust\n// BAD\nfor i in 0..n + 1 { }\n\n// GOOD\nfor i in 0..=n { }\n```\n\n## range_zip_with_len\n\nZipping range with len.\n\n```rust\n// BAD\n(0..vec.len()).zip(&vec)\n\n// GOOD\nvec.iter().enumerate()\n```\n\n## redundant_as_str\n\nRedundant as_str.\n\n```rust\n// BAD\nstring.as_str().len()\n\n// GOOD\nstring.len()\n```\n\n## redundant_async_block\n\nRedundant async block.\n\n```rust\n// BAD\nasync { future.await }\n\n// GOOD\nfuture\n```\n\n## redundant_at_rest_pattern\n\nRedundant @ rest pattern.\n\n```rust\n// BAD\nlet [first, rest @ ..] = slice;\n// rest never used\n\n// GOOD\nlet [first, ..] = slice;\n```\n\n## redundant_closure_call\n\nCalling closure immediately.\n\n```rust\n// BAD\n(|| 5)()\n\n// GOOD\n5\n```\n\n## redundant_else\n\nRedundant else after control flow.\n\n```rust\n// BAD\nif condition {\n    return x;\n} else {\n    y\n}\n\n// GOOD\nif condition {\n    return x;\n}\ny\n```\n\n## redundant_guards\n\nRedundant match guards.\n\n```rust\n// BAD\nmatch x {\n    y if y == 5 => { }\n    _ => { }\n}\n\n// GOOD\nmatch x {\n    5 => { }\n    _ => { }\n}\n```\n\n## redundant_pattern\n\nRedundant pattern.\n\n```rust\n// BAD\nmatch x {\n    Foo { a: a, b: b } => { }\n}\n\n// GOOD\nmatch x {\n    Foo { a, b } => { }\n}\n```\n\n## redundant_slicing\n\nRedundant slicing.\n\n```rust\n// BAD\n&slice[..]\n&*string\n\n// GOOD\nslice\n&string\n```\n\n## ref_in_deref\n\nRef in deref.\n\n```rust\n// BAD\n(*&x).foo()\n\n// GOOD\nx.foo()\n```\n\n## repeat_once\n\nRepeat once.\n\n```rust\n// BAD\n\"x\".repeat(1)\niter::repeat(x).take(1)\n\n// GOOD\n\"x\".to_string()\niter::once(x)\n```\n\n## reserve_after_initialization\n\nReserve after initialization.\n\n```rust\n// BAD\nlet mut vec = Vec::new();\nvec.reserve(100);\n\n// GOOD\nlet mut vec = Vec::with_capacity(100);\n```\n\n## result_filter_map\n\nResult filter then map.\n\n```rust\n// BAD\nresult.ok().and_then(|x| predicate(&x).then(|| transform(x)))\n\n// GOOD\nresult.ok().filter(predicate).map(transform)\n```\n\n## result_map_or_into_option\n\nResult map_or into Option.\n\n```rust\n// BAD\nresult.map_or(None, Some)\n\n// GOOD\nresult.ok()\n```\n\n## search_is_some\n\nSearch then is_some.\n\n```rust\n// BAD\niter.find(predicate).is_some()\n\n// GOOD\niter.any(predicate)\n```\n\n## seek_from_current\n\nSeek from current.\n\n```rust\n// BAD\nfile.seek(SeekFrom::Current(0))\n\n// GOOD\nfile.stream_position()\n```\n\n## seek_to_start_instead_of_rewind\n\nSeek to start.\n\n```rust\n// BAD\nfile.seek(SeekFrom::Start(0))\n\n// GOOD\nfile.rewind()\n```\n\n## short_circuit_statement\n\nShort circuit in statement.\n\n```rust\n// BAD\ncondition && foo();\ncondition || bar();\n\n// GOOD\nif condition { foo(); }\nif !condition { bar(); }\n```\n\n## single_element_loop\n\nLoop over single element.\n\n```rust\n// BAD\nfor x in [only_one] { }\nfor x in std::iter::once(only_one) { }\n\n// GOOD\nlet x = only_one;\n```\n\n## skip_while_next\n\nskip_while + next.\n\n```rust\n// BAD\niter.skip_while(f).next()\n\n// GOOD\niter.find(|x| !f(x))\n```\n\n## string_extend_chars\n\nExtending string with chars.\n\n```rust\n// BAD\nstring.extend(other.chars())\n\n// GOOD\nstring.push_str(&other)\n```\n\n## strlen_on_c_strings\n\nstrlen on CString.\n\n```rust\n// BAD\nunsafe { libc::strlen(cstring.as_ptr()) }\n\n// GOOD\ncstring.as_bytes().len()\n```\n\n## temporary_assignment\n\nAssignment to temporary.\n\n```rust\n// BAD\nFoo::default().x = 5;  // immediately dropped\n\n// GOOD\nlet mut foo = Foo::default();\nfoo.x = 5;\n```\n\n## too_many_arguments\n\nToo many function arguments.\n\n```rust\n// BAD (default threshold: 7)\nfn foo(a: i32, b: i32, c: i32, d: i32, e: i32, f: i32, g: i32, h: i32) { }\n\n// GOOD - use struct\nstruct Config { a: i32, b: i32, ... }\nfn foo(config: Config) { }\n```\n\n## transmute_bytes_to_str\n\nTransmute bytes to str.\n\n```rust\n// BAD\nunsafe { std::mem::transmute::<&[u8], &str>(bytes) }\n\n// GOOD\nstd::str::from_utf8(bytes)?\nstd::str::from_utf8_unchecked(bytes)  // if guaranteed valid\n```\n\n## transmute_float_to_int\n\nTransmute float to int.\n\n```rust\n// BAD\nunsafe { std::mem::transmute::<f32, u32>(f) }\n\n// GOOD\nf.to_bits()\n```\n\n## transmute_int_to_bool\n\nTransmute int to bool.\n\n```rust\n// BAD\nunsafe { std::mem::transmute::<u8, bool>(x) }\n\n// GOOD\nx != 0\n```\n\n## transmute_int_to_char\n\nTransmute int to char.\n\n```rust\n// BAD\nunsafe { std::mem::transmute::<u32, char>(x) }\n\n// GOOD\nchar::from_u32(x)?\nchar::from_u32_unchecked(x)  // if guaranteed valid\n```\n\n## transmute_int_to_float\n\nTransmute int to float.\n\n```rust\n// BAD\nunsafe { std::mem::transmute::<u32, f32>(x) }\n\n// GOOD\nf32::from_bits(x)\n```\n\n## transmute_num_to_bytes\n\nTransmute number to bytes.\n\n```rust\n// BAD\nunsafe { std::mem::transmute::<i32, [u8; 4]>(x) }\n\n// GOOD\nx.to_ne_bytes()\n```\n\n## transmute_ptr_to_ref\n\nTransmute pointer to reference.\n\n```rust\n// BAD\nunsafe { std::mem::transmute::<*const T, &T>(ptr) }\n\n// GOOD\nunsafe { &*ptr }\n```\n\n## transmuting_null\n\nTransmuting null.\n\n```rust\n// BAD\nlet null: &T = unsafe { std::mem::transmute(std::ptr::null::<T>()) };\n\n// This is UB - don't create null references\n```\n\n## trim_split_whitespace\n\nTrim then split_whitespace.\n\n```rust\n// BAD\ns.trim().split_whitespace()\n\n// GOOD - split_whitespace already ignores leading/trailing\ns.split_whitespace()\n```\n\n## type_complexity\n\nType too complex.\n\n```rust\n// BAD\nfn foo() -> Box<dyn Fn(&mut HashMap<String, Vec<Option<Result<i32, Error>>>>) -> bool> { }\n\n// GOOD - use type alias\ntype Handler = Box<dyn Fn(&mut State) -> bool>;\nfn foo() -> Handler { }\n```\n\n## unit_arg\n\nUnit argument.\n\n```rust\n// BAD\nfoo(())\nbar(println!(\"hello\"))\n\n// GOOD\nfoo()\nprintln!(\"hello\");\nbar()\n```\n\n## unnecessary_cast\n\nUnnecessary cast.\n\n```rust\n// BAD\nlet x = 5i32 as i32;\n\n// GOOD\nlet x = 5i32;\n```\n\n## unnecessary_filter_map\n\nfilter_map when filter or map suffices.\n\n```rust\n// BAD\niter.filter_map(|x| if x > 0 { Some(x) } else { None })\n\n// GOOD\niter.filter(|x| *x > 0)\n```\n\n## unnecessary_find_map\n\nfind_map when find or map suffices.\n\n```rust\n// BAD\niter.find_map(|x| if x > 0 { Some(x) } else { None })\n\n// GOOD\niter.find(|x| *x > 0)\n```\n\n## unnecessary_fold\n\nFold when specialized method exists.\n\n```rust\n// BAD\niter.fold(true, |acc, x| acc && predicate(x))\niter.fold(false, |acc, x| acc || predicate(x))\n\n// GOOD\niter.all(predicate)\niter.any(predicate)\n```\n\n## unnecessary_lazy_evaluations\n\nLazy evaluation when not needed.\n\n```rust\n// BAD\nopt.unwrap_or_else(|| 5)\nresult.unwrap_or_else(|_| default)\n\n// GOOD\nopt.unwrap_or(5)\nresult.unwrap_or(default)\n```\n\n## unnecessary_literal_unwrap\n\nUnwrapping literal.\n\n```rust\n// BAD\nSome(5).unwrap()\nOk::<_, ()>(5).unwrap()\n\n// GOOD\n5\n```\n\n## unnecessary_map_on_constructor\n\nMap on constructor.\n\n```rust\n// BAD\nSome(x).map(Some)\nOk(x).map(Ok)\n\n// GOOD\nSome(Some(x))\nOk(Ok(x))\n```\n\n## unnecessary_operation\n\nOperation with no effect.\n\n```rust\n// BAD\nx + 0\nx * 1\n\n// GOOD - remove operation\nx\n```\n\n## unnecessary_sort_by\n\nUnnecessary sort_by.\n\n```rust\n// BAD\nvec.sort_by(|a, b| a.cmp(b))\n\n// GOOD\nvec.sort()\n```\n\n## unnecessary_to_owned\n\nUnnecessary to_owned.\n\n```rust\n// BAD\ns.to_owned().as_str()\n\n// GOOD\ns\n```\n\n## unnecessary_unwrap\n\nUnnecessary unwrap after is_some.\n\n```rust\n// BAD\nif opt.is_some() {\n    let x = opt.unwrap();\n}\n\n// GOOD\nif let Some(x) = opt {\n}\n```\n\n## unneeded_wildcard_pattern\n\nUnneeded wildcard.\n\n```rust\n// BAD\nlet (x, _) = (1, 2);  // if _ never used\n\n// GOOD\nlet (x, ..) = (1, 2);\n```\n\n## unusable_partial_ord_impl\n\nPartialOrd not usable.\n\n```rust\n// BAD\nimpl PartialOrd for Foo {\n    fn partial_cmp(&self, _: &Self) -> Option<Ordering> {\n        None  // always None is useless\n    }\n}\n```\n\n## unused_format_specs\n\nUnused format specs.\n\n```rust\n// BAD\nformat!(\"{:?}\", 5)  // :? has no effect on integers\n\n// GOOD\nformat!(\"{}\", 5)\n```\n\n## unused_io_amount\n\nIgnoring IO amount.\n\n```rust\n// BAD\nfile.read(&mut buf)?;  // doesn't check how much was read\n\n// GOOD\nlet n = file.read(&mut buf)?;\n// or use read_exact\nfile.read_exact(&mut buf)?;\n```\n\n## useless_asref\n\nUseless as_ref.\n\n```rust\n// BAD\nopt.as_ref().cloned()\n\n// GOOD\nopt.clone()\n```\n\n## useless_conversion\n\nUseless type conversion.\n\n```rust\n// BAD\nlet s: String = String::from(s);\n\n// GOOD\nlet s = s;\n```\n\n## useless_format\n\nUseless format!.\n\n```rust\n// BAD\nformat!(\"{}\", s)\n\n// GOOD\ns.to_string()\n```\n\n## useless_transmute\n\nUseless transmute.\n\n```rust\n// BAD\nunsafe { std::mem::transmute::<i32, i32>(x) }\n\n// GOOD\nx\n```\n\n## useless_vec\n\nVec where array works.\n\n```rust\n// BAD\nvec![1, 2, 3].into_iter()\n\n// GOOD\n[1, 2, 3].into_iter()\n```\n\n## vec_box\n\nVec of Box.\n\n```rust\n// BAD\nVec<Box<T>>\n\n// GOOD - Box adds unnecessary indirection\nVec<T>\n```\n\n## vec_init_then_push\n\nInit then push.\n\n```rust\n// BAD\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\n\n// GOOD\nlet v = vec![1, 2];\n```\n\n## verbose_bit_mask\n\nVerbose bit mask.\n\n```rust\n// BAD\nx & 0b1111 == 0\n\n// GOOD\nx.trailing_zeros() >= 4\n```\n\n## while_let_on_iterator\n\nwhile let on iterator.\n\n```rust\n// BAD\nwhile let Some(x) = iter.next() { }\n\n// GOOD\nfor x in iter { }\n```\n\n## wildcard_in_or_patterns\n\nWildcard in or pattern.\n\n```rust\n// BAD\nmatch x {\n    A | B | _ => { }\n}\n\n// GOOD\nmatch x {\n    _ => { }\n}\n```\n\n## zero_divided_by_something\n\nZero divided by something.\n\n```rust\n// BAD\n0 / x\n\n// GOOD\n0\n```\n\n## zero_prefixed_literal\n\nZero-prefixed literal.\n\n```rust\n// BAD\nlet x = 0123;  // not octal in Rust!\n\n// GOOD\nlet x = 123;   // decimal\nlet x = 0o123; // octal\n```\n"}, {"path": "linters/clippy/integer_division.md", "category": "linters", "name": "linters/clippy/integer_division", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mut_range_bound.md", "category": "linters", "name": "linters/clippy/mut_range_bound", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/rc_buffer.md", "category": "linters", "name": "linters/clippy/rc_buffer", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/modulo_one.md", "category": "linters", "name": "linters/clippy/modulo_one", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}, {"path": "linters/clippy/mixed_case_hex_literals.md", "category": "linters", "name": "linters/clippy/mixed_case_hex_literals", "content": "## absolute_paths [\u00b6](#absolute_paths)\ud83d\udccbrestrictionallow\n\n### What it does\n\nChecks for usage of items through absolute paths, like `std::env::current_dir`.\n\n### Why restrict this?\n\nMany codebases have their own style when it comes to importing, but one that is seldom used is using absolute paths everywhere. This is generally considered unidiomatic, and you should add a `use` statement.\n\nThe default maximum segments (2) is pretty strict, you may want to increase this in `clippy.toml`.\n\nNote: One exception to this is code from macro expansion - this does not lint such cases, as using absolute paths is the proper way of referencing items in one.\n\n### Known issues\n\nThere are currently a few cases which are not caught by this lint:\n\n- Macro calls. e.g. `path::to::macro!()`\n- Derive macros. e.g. `#[derive(path::to::macro)]`\n- Attribute macros. e.g. `#[path::to::macro]`\n\n### Example\n\n```\nlet x = std::f64::consts::PI;\n```\n\nUse any of the below instead, or anything else:\n\n```\nuse std::f64;\nuse std::f64::consts;\nuse std::f64::consts::PI;\nlet x = f64::consts::PI;\nlet x = consts::PI;\nlet x = PI;\nuse std::f64::consts as f64_consts;\nlet x = f64_consts::PI;\n```\n\n### Configuration\n\n- \n\n`absolute-paths-allowed-crates`: Which crates to allow absolute paths from\n\n(default: `[]`)\n\n- \n\n`absolute-paths-max-segments`: The maximum number of segments a path can have before being linted, anything above this will be linted.\n\n(default: `2`)\n\nApplicability: Unspecified[(?)](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint_defs/enum.Applicability.html#variants)Added in: 1.73.0[Related Issues](https://github.com/rust-lang/rust-clippy/issues?q=is%3Aissue+absolute_paths)[View Source](https://github.com/rust-lang/rust-clippy/blob/master/clippy_lints/src/absolute_paths.rs#L13)\n"}]}
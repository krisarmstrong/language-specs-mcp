{"language": "csharp", "generatedAt": "2026-01-05T15:15:54.733115+00:00", "entries": [{"path": "patterns/idioms.md", "category": "patterns", "name": "patterns/idioms", "content": "# C# Idioms\n\n## Use async/await for I/O\n\nPrefer async APIs for network and disk operations.\n\n## Prefer `using` declarations for disposal\n\n```csharp\nusing var stream = File.OpenRead(path);\n```\n\n## Embrace nullable reference types\n\nEnable nullable and use `string?` when values can be null.\n\n## Use records for immutable data\n\n```csharp\npublic record User(string Id, string Name);\n```\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# C# Formatters\n\n## dotnet format\n\nSee: https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-format\n"}, {"path": "formatters/dotnet-format.md", "category": "formatters", "name": "formatters/dotnet-format", "content": "# dotnet format Options\n\nSee: https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-format\n"}, {"path": "stdlib/overview.md", "category": "stdlib", "name": "stdlib/overview", "content": "# .NET API Reference\n\nSee: https://learn.microsoft.com/en-us/dotnet/api/\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# C# Language Specification\nVersion: unknown\n\nSource: https://learn.microsoft.com/en-us/dotnet/\n\nSource: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/\n\n\nSee: https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/\n"}, {"path": "linters/overview.md", "category": "linters", "name": "linters/overview", "content": "# Roslyn Analyzers Overview\n\n.NET compiler platform analyzers for C#.\n\n## Built-in Analyzers\n\n### Code Analysis (CA)\n\nDesign, globalization, performance, security rules.\n\n```xml\n<!-- .editorconfig -->\n[*.cs]\ndotnet_analyzer_diagnostic.category-Performance.severity = warning\ndotnet_analyzer_diagnostic.category-Security.severity = error\n```\n\n### Code Style (IDE)\n\nFormatting, naming, expression-level preferences.\n\n```xml\n[*.cs]\n# Prefer var\ncsharp_style_var_for_built_in_types = true:suggestion\ncsharp_style_var_when_type_is_apparent = true:suggestion\n\n# Prefer expression body\ncsharp_style_expression_bodied_methods = when_on_single_line:suggestion\n\n# Prefer pattern matching\ncsharp_style_pattern_matching_over_is_with_cast_check = true:warning\n```\n\n## Configuration\n\n### .editorconfig\n\n```ini\nroot = true\n\n[*.cs]\n# Analyzer severity\ndotnet_diagnostic.CA1000.severity = warning\ndotnet_diagnostic.CA2000.severity = error\n\n# Bulk configuration\ndotnet_analyzer_diagnostic.severity = warning\ndotnet_code_quality.severity = warning\n\n# Code style\ndotnet_style_qualification_for_field = false:suggestion\ndotnet_style_qualification_for_property = false:suggestion\ndotnet_style_predefined_type_for_locals_parameters_members = true:warning\n\n# Naming\ndotnet_naming_rule.private_fields_should_be_camel_case.severity = warning\ndotnet_naming_rule.private_fields_should_be_camel_case.symbols = private_fields\ndotnet_naming_rule.private_fields_should_be_camel_case.style = camel_case_style\n\ndotnet_naming_symbols.private_fields.applicable_kinds = field\ndotnet_naming_symbols.private_fields.applicable_accessibilities = private\n\ndotnet_naming_style.camel_case_style.capitalization = camel_case\ndotnet_naming_style.camel_case_style.required_prefix = _\n```\n\n### Project Configuration\n\n```xml\n<!-- .csproj -->\n<PropertyGroup>\n    <AnalysisLevel>latest</AnalysisLevel>\n    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>\n    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>\n    <Nullable>enable</Nullable>\n</PropertyGroup>\n\n<ItemGroup>\n    <PackageReference Include=\"Microsoft.CodeAnalysis.NetAnalyzers\" Version=\"8.0.0\">\n        <PrivateAssets>all</PrivateAssets>\n        <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>\n    </PackageReference>\n</ItemGroup>\n```\n\n## Suppression\n\n```csharp\n// Inline suppression\n#pragma warning disable CA1000\npublic static void Method() { }\n#pragma warning restore CA1000\n\n// Attribute suppression\n[SuppressMessage(\"Design\", \"CA1000:DoNotDeclareStaticMembersOnGenericTypes\")]\npublic static void Method() { }\n\n// Global suppression (GlobalSuppressions.cs)\n[assembly: SuppressMessage(\"Design\", \"CA1000\", Scope = \"member\", Target = \"~M:MyClass.Method\")]\n```\n\n## Rule Categories\n\n| Category | Prefix | Description |\n|----------|--------|-------------|\n| Design | CA1xxx | API design |\n| Globalization | CA1300-1399 | Culture issues |\n| Performance | CA1800-1899 | Performance |\n| Security | CA2xxx | Security |\n| Usage | CA2200-2299 | Proper API usage |\n| Reliability | CA2000-2099 | Reliability |\n| Naming | CA1700-1799 | Naming |\n"}, {"path": "linters/dotnet-analyzers/overview.md", "category": "linters", "name": "linters/dotnet-analyzers/overview", "content": "# .NET Code Analysis Overview\nVersion: unknown\n\nSource: https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview\n\n\nSee: https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview\n"}, {"path": "linters/dotnet-analyzers/quality-rules.md", "category": "linters", "name": "linters/dotnet-analyzers/quality-rules", "content": "# .NET Quality Rules\n\nSee: https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/\n"}, {"path": "linters/stylecop/overview.md", "category": "linters", "name": "linters/stylecop/overview", "content": "# stylecop-analyzers Version\nVersion: unknown\n\nSource: https://github.com/DotNetAnalyzers/StyleCopAnalyzers\n\n\nStyleCop.Analyzers provides warnings that indicate style and consistency rule violations in C# code. The warnings are organized into rule areas such as documentation, layout, naming, ordering, readability, spacing, and so forth. Each warning signifies a violation of a style or consistency rule. This section provides an explanation of each of the default StyleCop.Analyzers rules. \n\n### Rule areas\n**[Special Rules (SA0000-)](documentation/SpecialRules.md)**\n\nRules which provide special functionality like workarounds, configuration errors, etc.\n\n**[Spacing Rules (SA1000-)](documentation/SpacingRules.md)**\n\nRules which enforce spacing requirements around keywords and symbols in the code.\n\n**[Readability Rules (SA1100-)](documentation/ReadabilityRules.md)**\n\nRules which ensure that the code is well-formatted and readable.\n\n**[Ordering Rules (SA1200-)](documentation/OrderingRules.md)**\n\nRules which enforce a standard ordering scheme for code contents.\n\n**[Naming Rules (SA1300-)](documentation/NamingRules.md)**\n\nRules which enforce naming requirements for members, types, and variables.\n\n**[Maintainability Rules (SA1400-)](documentation/MaintainabilityRules.md)**\n\nRules which improve code maintainability.\n\n**[Layout Rules (SA1500-)](documentation/LayoutRules.md)**\n\nRules which enforce code layout and line spacing.\n\n**[Documentation Rules (SA1600-)](documentation/DocumentationRules.md)**\n\nRules which verify the content and formatting of code documentation.\n\n**[Alternative Rules (SX0000-)](documentation/AlternativeRules.md)**\n\nRules which offer a non-standard extension to the default StyleCop behavior.\n\n### Additional documentation\n**[Configuration](documentation/Configuration.md)**\n\nDescribes the configuration options for StyleCop.Analyzers\n\n**[How to enable the configuration](documentation/EnableConfiguration.md)**\n\nDescribes how to enable the **stylecop.json** file for usage.\n\n**[Known changes](documentation/KnownChanges.md)**\n\nDescribes the known differences between StyleCop Analyzers and StyleCop Classic.\n"}, {"path": "linters/rules.md", "category": "linters", "name": "linters/rules", "content": "# Roslyn Analyzer Rules\n\n## Design Rules (CA1xxx)\n\n### CA1000: Do not declare static members on generic types\n\n```csharp\n// BAD\npublic class Cache<T>\n{\n    public static void Clear() { }  // confusing: Cache<int>.Clear() vs Cache<string>.Clear()\n}\n\n// GOOD\npublic class Cache<T>\n{\n    public void Clear() { }\n}\n\n// Or non-generic companion\npublic static class Cache\n{\n    public static void ClearAll() { }\n}\n```\n\n### CA1002: Do not expose generic lists\n\n```csharp\n// BAD\npublic class Order\n{\n    public List<Item> Items { get; } = new();\n}\n\n// GOOD\npublic class Order\n{\n    public IReadOnlyList<Item> Items => _items;\n    private readonly List<Item> _items = new();\n}\n```\n\n### CA1010: Collections should implement generic interface\n\n```csharp\n// BAD\npublic class ItemCollection : IEnumerable\n{\n    public IEnumerator GetEnumerator() { }\n}\n\n// GOOD\npublic class ItemCollection : IEnumerable<Item>\n{\n    public IEnumerator<Item> GetEnumerator() { }\n    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n}\n```\n\n### CA1018: Mark attributes with AttributeUsageAttribute\n\n```csharp\n// BAD\npublic class MyAttribute : Attribute { }\n\n// GOOD\n[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\npublic class MyAttribute : Attribute { }\n```\n\n### CA1028: Enum storage should be Int32\n\n```csharp\n// BAD - without justification\npublic enum Status : byte { }\n\n// GOOD - default\npublic enum Status { }\n\n// OK - when memory/interop matters\n[Flags]\npublic enum Permissions : byte { }\n```\n\n### CA1031: Do not catch general exception types\n\n```csharp\n// BAD\ntry { Process(); }\ncatch (Exception) { }\n\n// GOOD\ntry { Process(); }\ncatch (IOException ex)\n{\n    _logger.LogError(ex, \"IO error\");\n}\ncatch (InvalidOperationException ex)\n{\n    _logger.LogError(ex, \"Invalid operation\");\n}\n```\n\n### CA1051: Do not declare visible instance fields\n\n```csharp\n// BAD\npublic class Person\n{\n    public string Name;\n}\n\n// GOOD\npublic class Person\n{\n    public string Name { get; set; }\n}\n```\n\n### CA1052: Static holder types should be sealed/static\n\n```csharp\n// BAD\npublic class StringHelper\n{\n    public static string Trim(string s) => s?.Trim();\n}\n\n// GOOD\npublic static class StringHelper\n{\n    public static string Trim(string s) => s?.Trim();\n}\n```\n\n## Globalization Rules (CA13xx)\n\n### CA1303: Do not pass literals as localized parameters\n\n```csharp\n// BAD\nMessageBox.Show(\"Operation failed\");\n\n// GOOD\nMessageBox.Show(Resources.OperationFailed);\n```\n\n### CA1304: Specify CultureInfo\n\n```csharp\n// BAD\nstring lower = text.ToLower();\n\n// GOOD\nstring lower = text.ToLower(CultureInfo.CurrentCulture);\n// Or for invariant\nstring lower = text.ToLowerInvariant();\n```\n\n### CA1305: Specify IFormatProvider\n\n```csharp\n// BAD\nstring formatted = number.ToString();\n\n// GOOD\nstring formatted = number.ToString(CultureInfo.InvariantCulture);\n```\n\n### CA1310: Specify StringComparison for correctness\n\n```csharp\n// BAD\nif (text.StartsWith(\"prefix\")) { }\n\n// GOOD\nif (text.StartsWith(\"prefix\", StringComparison.Ordinal)) { }\nif (text.StartsWith(\"prefix\", StringComparison.OrdinalIgnoreCase)) { }\n```\n\n## Performance Rules (CA18xx)\n\n### CA1802: Use literals where appropriate\n\n```csharp\n// BAD\nprivate static readonly string Prefix = \"app_\";\n\n// GOOD - compile-time constant\nprivate const string Prefix = \"app_\";\n```\n\n### CA1805: Do not initialize unnecessarily\n\n```csharp\n// BAD\nprivate int _count = 0;  // default value\nprivate bool _flag = false;\nprivate string? _name = null;\n\n// GOOD\nprivate int _count;\nprivate bool _flag;\nprivate string? _name;\n```\n\n### CA1806: Do not ignore method results\n\n```csharp\n// BAD\n\"hello\".ToUpper();  // result ignored\n\n// GOOD\nstring upper = \"hello\".ToUpper();\n```\n\n### CA1812: Avoid uninstantiated internal classes\n\n```csharp\n// BAD - never instantiated\ninternal class Helper\n{\n    public static void DoWork() { }\n}\n\n// GOOD - make static\ninternal static class Helper\n{\n    public static void DoWork() { }\n}\n```\n\n### CA1822: Mark members as static\n\n```csharp\n// BAD\npublic class Calculator\n{\n    public int Add(int a, int b) => a + b;  // doesn't use 'this'\n}\n\n// GOOD\npublic class Calculator\n{\n    public static int Add(int a, int b) => a + b;\n}\n```\n\n### CA1825: Avoid zero-length array allocations\n\n```csharp\n// BAD\nreturn new string[0];\n\n// GOOD\nreturn Array.Empty<string>();\n```\n\n### CA1826: Use property instead of Linq Enumerable method\n\n```csharp\n// BAD\nif (array.Count() > 0) { }\nvar first = list.First();\n\n// GOOD\nif (array.Length > 0) { }\nvar first = list[0];\n```\n\n### CA1829: Use Length/Count property instead of Enumerable.Count method\n\n```csharp\n// BAD\nif (list.Count() > 0) { }\n\n// GOOD\nif (list.Count > 0) { }\n```\n\n### CA1834: Consider using StringBuilder.Append(char) for single-character strings\n\n```csharp\n// BAD\nsb.Append(\",\");\n\n// GOOD\nsb.Append(',');\n```\n\n### CA1845: Use span-based 'string.Concat'\n\n```csharp\n// BAD\nstring result = s.Substring(0, 5) + s.Substring(10, 5);\n\n// GOOD\nstring result = string.Concat(s.AsSpan(0, 5), s.AsSpan(10, 5));\n```\n\n### CA1846: Prefer AsSpan over Substring\n\n```csharp\n// BAD\nint.Parse(text.Substring(0, 5));\n\n// GOOD\nint.Parse(text.AsSpan(0, 5));\n```\n\n## Security Rules (CA2xxx)\n\n### CA2000: Dispose objects before losing scope\n\n```csharp\n// BAD\npublic void Process()\n{\n    var stream = new FileStream(path, FileMode.Open);\n    // might throw before disposal\n}\n\n// GOOD\npublic void Process()\n{\n    using var stream = new FileStream(path, FileMode.Open);\n    // disposed automatically\n}\n```\n\n### CA2007: Do not directly await a Task\n\n```csharp\n// BAD (in library code)\nawait SomeAsync();\n\n// GOOD\nawait SomeAsync().ConfigureAwait(false);\n```\n\n### CA2012: Use ValueTasks correctly\n\n```csharp\n// BAD - awaiting twice\nvar task = GetValueTaskAsync();\nawait task;\nawait task;  // undefined behavior!\n\n// GOOD - await once\nvar result = await GetValueTaskAsync();\n```\n\n### CA2016: Forward the CancellationToken parameter\n\n```csharp\n// BAD\npublic async Task ProcessAsync(CancellationToken cancellationToken)\n{\n    await DoWorkAsync();  // doesn't pass token\n}\n\n// GOOD\npublic async Task ProcessAsync(CancellationToken cancellationToken)\n{\n    await DoWorkAsync(cancellationToken);\n}\n```\n\n### CA2200: Rethrow to preserve stack details\n\n```csharp\n// BAD - loses stack trace\ncatch (Exception ex)\n{\n    throw ex;\n}\n\n// GOOD - preserves stack trace\ncatch (Exception ex)\n{\n    // log or handle\n    throw;\n}\n```\n\n### CA2208: Instantiate argument exceptions correctly\n\n```csharp\n// BAD - wrong parameter order\nthrow new ArgumentNullException(\"Value cannot be null\", nameof(value));\n\n// GOOD\nthrow new ArgumentNullException(nameof(value), \"Value cannot be null\");\n\n// Better\nthrow new ArgumentNullException(nameof(value));\n```\n\n## Usage Rules (CA22xx)\n\n### CA2211: Non-constant fields should not be visible\n\n```csharp\n// BAD\npublic static int Counter;\n\n// GOOD\nprivate static int _counter;\npublic static int Counter => _counter;\n```\n\n### CA2213: Disposable fields should be disposed\n\n```csharp\n// BAD\npublic class Service : IDisposable\n{\n    private readonly Stream _stream = new MemoryStream();\n    \n    public void Dispose() { }  // doesn't dispose _stream\n}\n\n// GOOD\npublic void Dispose()\n{\n    _stream?.Dispose();\n}\n```\n\n### CA2214: Do not call overridable methods in constructors\n\n```csharp\n// BAD\npublic class Base\n{\n    public Base()\n    {\n        Initialize();  // virtual call\n    }\n    \n    protected virtual void Initialize() { }\n}\n\n// GOOD\npublic class Base\n{\n    protected virtual void Initialize() { }\n}\n\npublic class Derived : Base\n{\n    public Derived()\n    {\n        Initialize();  // called in derived class\n    }\n}\n```\n\n### CA2225: Operator overloads have named alternates\n\n```csharp\n// Provide named method for languages without operator overloading\npublic static Money operator +(Money a, Money b) => a.Add(b);\n\npublic Money Add(Money other) => new(Amount + other.Amount);\n```\n\n### CA2227: Collection properties should be read only\n\n```csharp\n// BAD\npublic List<Item> Items { get; set; }\n\n// GOOD\npublic List<Item> Items { get; } = new();\n\n// Or\npublic IReadOnlyList<Item> Items => _items;\n```\n\n### CA2234: Pass System.Uri objects instead of strings\n\n```csharp\n// BAD\nclient.GetAsync(\"https://api.example.com\");\n\n// GOOD\nclient.GetAsync(new Uri(\"https://api.example.com\"));\n```\n\n### CA2245: Do not assign a property to itself\n\n```csharp\n// BAD\nthis.Name = Name;  // assigns parameter to itself\n\n// GOOD\nthis.Name = name;\n```\n\n### CA2246: Do not assign a symbol and its member in the same statement\n\n```csharp\n// BAD\nobj = obj.Something;  // confusing\n\n// GOOD\nvar result = obj.Something;\nobj = result;\n```\n\n## Code Style Rules (IDE)\n\n### IDE0001-0004: Simplify names\n\n```csharp\n// BAD\nSystem.Console.WriteLine();\nthis.field = value;\n\n// GOOD\nConsole.WriteLine();  // with using\nfield = value;        // when unambiguous\n```\n\n### IDE0017: Use object initializers\n\n```csharp\n// BAD\nvar person = new Person();\nperson.Name = \"Alice\";\nperson.Age = 30;\n\n// GOOD\nvar person = new Person\n{\n    Name = \"Alice\",\n    Age = 30\n};\n```\n\n### IDE0028: Use collection initializers\n\n```csharp\n// BAD\nvar list = new List<int>();\nlist.Add(1);\nlist.Add(2);\n\n// GOOD\nvar list = new List<int> { 1, 2 };\n```\n\n### IDE0057: Use range operator\n\n```csharp\n// BAD\nvar sub = text.Substring(1, text.Length - 1);\n\n// GOOD\nvar sub = text[1..];\n```\n\n### IDE0090: Simplify new expression\n\n```csharp\n// BAD\nList<int> list = new List<int>();\n\n// GOOD\nList<int> list = new();\n```\n"}]}
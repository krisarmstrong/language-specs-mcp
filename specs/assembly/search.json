{"language": "assembly", "generatedAt": "2026-01-05T20:16:18.912519+00:00", "entries": [{"path": "arm32.md", "category": "spec", "name": "arm32", "content": "# ARM Architecture Reference Manual (ARMv7-A)\n\nSee: https://developer.arm.com/documentation/ddi0406/latest\n"}, {"path": "patterns/idioms.md", "category": "patterns", "name": "patterns/idioms", "content": "# Assembly Idioms\n\n## Follow the ABI\n\n- Preserve callee-saved registers.\n- Keep the stack aligned per ABI requirements.\n- Use the correct calling convention for the platform.\n\n## Prefer Clear Register Usage\n\n- Minimize register aliasing.\n- Use comments to document register roles in non-trivial routines.\n"}, {"path": "wasm.md", "category": "spec", "name": "wasm", "content": "# WebAssembly Core Specification\n\nSee: https://webassembly.github.io/spec/core/\n"}, {"path": "aarch64.md", "category": "spec", "name": "aarch64", "content": "# AArch64 Architecture Reference Manual (ARMv8-A)\n\nSee: https://developer.arm.com/documentation/ddi0487/latest\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# Assembly Formatters\n\nThere is no widely adopted formatter for assembly across architectures.\n"}, {"path": "stdlib/overview.md", "category": "stdlib", "name": "stdlib/overview", "content": "# Assembly ABI and Platform References\n\nAssembly has no standard library, but ABI and calling convention references are essential.\n\n## System V AMD64 ABI (Linux/macOS)\n\nSee: https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf\n\n## Microsoft x64 Calling Convention\n\nSee: https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# assembly Specification\nVersion: living\n\nSource: https://webassembly.github.io/spec/core/\nSource: https://riscv.org/technical/specifications/\nSource: https://developer.arm.com/documentation/ddi0487/latest\nSource: https://www.felixcloutier.com/x86/\n\n"}, {"path": "linters/overview.md", "category": "linters", "name": "linters/overview", "content": "# Assembly Linting\n\nThere is no widely adopted, language-agnostic linter for assembly.\n\n## Recommendations\n\n- Enable strict warnings in your assembler (NASM/YASM/GAS/LLVM).\n- Use disassemblers and static analysis tools for verification.\n- Consider formatters like asmfmt for consistent style.\n"}, {"path": "arm64.md", "category": "spec", "name": "arm64", "content": "# ARM64 (AArch64) Assembly Reference\n\n## Registers\n\n### General Purpose\n\n| Register | Alias | Purpose |\n|----------|-------|---------|\n| X0-X7 | - | Arguments/results, caller-saved |\n| X8 | XR | Indirect result location |\n| X9-X15 | - | Temporary, caller-saved |\n| X16-X17 | IP0-IP1 | Intra-procedure scratch |\n| X18 | PR | Platform register (reserved) |\n| X19-X28 | - | Callee-saved |\n| X29 | FP | Frame pointer |\n| X30 | LR | Link register (return address) |\n| SP | - | Stack pointer |\n| XZR | - | Zero register (reads as 0, writes ignored) |\n| PC | - | Program counter (not directly accessible) |\n\n### 32-bit Aliases\n\nW0-W30 = lower 32 bits of X0-X30\nWZR = 32-bit zero register\nWSP = 32-bit stack pointer\n\n### Special Registers\n\n```asm\n// System registers (EL0 accessible)\nMRS X0, NZCV        // Condition flags\nMSR NZCV, X0\n\n// PSTATE flags\nN - Negative\nZ - Zero  \nC - Carry\nV - Overflow\n```\n\n### SIMD/FP Registers\n\n```asm\n// 128-bit vector registers\nV0-V31\n\n// Scalar views\nB0-B31   // 8-bit\nH0-H31   // 16-bit\nS0-S31   // 32-bit (single)\nD0-D31   // 64-bit (double)\nQ0-Q31   // 128-bit (quad)\n```\n\n## Calling Convention (AAPCS64)\n\n```asm\n// Arguments: X0-X7 (integer), V0-V7 (float)\n// Return: X0 (and X1 for 128-bit)\n// Caller-saved: X0-X18, V0-V7, V16-V31\n// Callee-saved: X19-X28, V8-V15\n// Stack: 16-byte aligned\n\n// Function prologue\nmy_func:\n    stp x29, x30, [sp, #-16]!  // Push FP and LR\n    mov x29, sp                  // Set frame pointer\n\n// Function epilogue\n    ldp x29, x30, [sp], #16     // Pop FP and LR\n    ret\n```\n\n## Addressing Modes\n\n```asm\n// Immediate offset\nLDR X0, [X1]            // Base\nLDR X0, [X1, #8]        // Base + offset\nLDR X0, [X1, #-8]       // Base - offset\n\n// Register offset\nLDR X0, [X1, X2]        // Base + register\nLDR X0, [X1, X2, LSL #3] // Base + (register << 3)\n\n// Pre-indexed (update base)\nLDR X0, [X1, #8]!       // X1 += 8, then load\n\n// Post-indexed (update base)\nLDR X0, [X1], #8        // Load, then X1 += 8\n\n// PC-relative\nLDR X0, label           // PC-relative literal\nADR X0, label           // PC-relative address\nADRP X0, label          // PC-relative page address\n```\n\n## Data Movement\n\n```asm\n// Move\nMOV X0, X1              // Register to register\nMOV X0, #42             // Immediate (16-bit)\nMOV X0, #0xFFFF0000     // Immediate with shift\nMOVN X0, #0             // Move NOT\nMOVZ X0, #0x1234        // Move with zero\nMOVK X0, #0x5678, LSL #16  // Move keep\n\n// Load/Store\nLDR X0, [X1]            // Load 64-bit\nLDRB W0, [X1]           // Load byte (zero extend)\nLDRH W0, [X1]           // Load halfword\nLDRSB X0, [X1]          // Load byte (sign extend)\nLDRSH X0, [X1]          // Load halfword (sign extend)\nLDRSW X0, [X1]          // Load word (sign extend)\n\nSTR X0, [X1]            // Store 64-bit\nSTRB W0, [X1]           // Store byte\nSTRH W0, [X1]           // Store halfword\n\n// Load/Store pair\nLDP X0, X1, [X2]        // Load pair\nSTP X0, X1, [X2]        // Store pair\n\n// Exclusive access (atomics)\nLDXR X0, [X1]           // Load exclusive\nSTXR W2, X0, [X1]       // Store exclusive (W2 = status)\n```\n\n## Arithmetic\n\n```asm\n// Addition/Subtraction\nADD X0, X1, X2          // X0 = X1 + X2\nADD X0, X1, #42         // X0 = X1 + 42\nADDS X0, X1, X2         // Add, set flags\nSUB X0, X1, X2          // Subtract\nSUBS X0, X1, X2         // Subtract, set flags\nADC X0, X1, X2          // Add with carry\nSBC X0, X1, X2          // Subtract with carry\nNEG X0, X1              // Negate\n\n// Multiplication\nMUL X0, X1, X2          // X0 = X1 * X2 (low 64 bits)\nSMULL X0, W1, W2        // Signed multiply long\nUMULL X0, W1, W2        // Unsigned multiply long\nSMULH X0, X1, X2        // Signed multiply high\nUMULH X0, X1, X2        // Unsigned multiply high\nMADD X0, X1, X2, X3     // X0 = X3 + X1 * X2\nMSUB X0, X1, X2, X3     // X0 = X3 - X1 * X2\n\n// Division\nSDIV X0, X1, X2         // Signed divide\nUDIV X0, X1, X2         // Unsigned divide\n```\n\n## Bitwise Operations\n\n```asm\n// Logical\nAND X0, X1, X2          // Bitwise AND\nORR X0, X1, X2          // Bitwise OR\nEOR X0, X1, X2          // Bitwise XOR\nBIC X0, X1, X2          // Bit clear (AND NOT)\nORN X0, X1, X2          // OR NOT\nEON X0, X1, X2          // XOR NOT\nMVN X0, X1              // NOT\n\n// Shifts\nLSL X0, X1, #4          // Logical shift left\nLSR X0, X1, #4          // Logical shift right\nASR X0, X1, #4          // Arithmetic shift right\nROR X0, X1, #4          // Rotate right\n\n// Bit manipulation\nCLZ X0, X1              // Count leading zeros\nRBIT X0, X1             // Reverse bits\nREV X0, X1              // Reverse bytes\nREV16 X0, X1            // Reverse bytes in halfwords\nREV32 X0, X1            // Reverse bytes in words\n```\n\n## Comparison and Branching\n\n```asm\n// Compare\nCMP X0, X1              // Compare (SUBS, discard result)\nCMP X0, #42             // Compare with immediate\nCMN X0, X1              // Compare negative (ADDS)\nTST X0, X1              // Test bits (ANDS)\nTST X0, #0xFF           // Test with immediate\n\n// Conditional branch\nB.EQ label              // Branch if equal (Z=1)\nB.NE label              // Branch if not equal (Z=0)\nB.LT label              // Branch if less than (signed)\nB.LE label              // Branch if less or equal\nB.GT label              // Branch if greater than\nB.GE label              // Branch if greater or equal\nB.LO label              // Branch if lower (unsigned, C=0)\nB.LS label              // Branch if lower or same\nB.HI label              // Branch if higher (unsigned)\nB.HS label              // Branch if higher or same (C=1)\nB.MI label              // Branch if minus (N=1)\nB.PL label              // Branch if plus (N=0)\nB.VS label              // Branch if overflow (V=1)\nB.VC label              // Branch if no overflow\n\n// Unconditional branch\nB label                 // Branch\nBL label                // Branch with link (call)\nBR X0                   // Branch to register\nBLR X0                  // Branch with link to register\nRET                     // Return (BR X30)\n\n// Compare and branch\nCBZ X0, label           // Branch if zero\nCBNZ X0, label          // Branch if not zero\nTBZ X0, #5, label       // Test bit and branch if zero\nTBNZ X0, #5, label      // Test bit and branch if not zero\n```\n\n## Conditional Operations\n\n```asm\n// Conditional select\nCSEL X0, X1, X2, EQ     // X0 = (EQ) ? X1 : X2\nCSINC X0, X1, X2, NE    // X0 = (NE) ? X1 : X2+1\nCSINV X0, X1, X2, LT    // X0 = (LT) ? X1 : ~X2\nCSNEG X0, X1, X2, GT    // X0 = (GT) ? X1 : -X2\n\n// Conditional increment/negate\nCINC X0, X1, EQ         // X0 = (EQ) ? X1+1 : X1\nCNEG X0, X1, EQ         // X0 = (EQ) ? -X1 : X1\nCSET X0, EQ             // X0 = (EQ) ? 1 : 0\nCSETM X0, EQ            // X0 = (EQ) ? -1 : 0\n```\n\n## SIMD/NEON\n\n```asm\n// Load/Store\nLD1 {V0.16B}, [X0]      // Load 16 bytes\nLD1 {V0.8H}, [X0]       // Load 8 halfwords\nLD1 {V0.4S}, [X0]       // Load 4 singles\nLD1 {V0.2D}, [X0]       // Load 2 doubles\nST1 {V0.16B}, [X0]      // Store\n\n// Arithmetic\nADD V0.4S, V1.4S, V2.4S // Vector add\nSUB V0.4S, V1.4S, V2.4S // Vector subtract\nMUL V0.4S, V1.4S, V2.4S // Vector multiply\nFADD V0.4S, V1.4S, V2.4S // Float add\nFMUL V0.4S, V1.4S, V2.4S // Float multiply\n\n// Comparison\nCMEQ V0.4S, V1.4S, V2.4S // Compare equal\nCMGT V0.4S, V1.4S, V2.4S // Compare greater than\n```\n\n## System Instructions\n\n```asm\n// Memory barriers\nDMB SY                  // Data memory barrier\nDSB SY                  // Data synchronization barrier\nISB                     // Instruction synchronization barrier\n\n// Cache operations\nDC CVAC, X0             // Clean data cache\nIC IVAU, X0             // Invalidate instruction cache\n\n// System calls\nSVC #0                  // Supervisor call (syscall)\nHVC #0                  // Hypervisor call\nSMC #0                  // Secure monitor call\n\n// Hints\nNOP                     // No operation\nWFE                     // Wait for event\nWFI                     // Wait for interrupt\nSEV                     // Send event\nYIELD                   // Yield\n```\n\n## Common Patterns\n\n### Function Call\n\n```asm\n// Call function with 4 arguments\nMOV X0, #1              // arg1\nMOV X1, #2              // arg2\nMOV X2, #3              // arg3\nMOV X3, #4              // arg4\nBL function\n\n// Save/restore callee-saved registers\nfunc:\n    STP X29, X30, [SP, #-32]!\n    STP X19, X20, [SP, #16]\n    MOV X29, SP\n    \n    // function body\n    \n    LDP X19, X20, [SP, #16]\n    LDP X29, X30, [SP], #32\n    RET\n```\n\n### Loop\n\n```asm\n// for (int i = 0; i < n; i++)\n    MOV X19, #0         // i = 0\nloop:\n    CMP X19, X20        // i < n?\n    B.GE done\n    \n    // loop body\n    \n    ADD X19, X19, #1    // i++\n    B loop\ndone:\n```\n\n### System Call (Linux)\n\n```asm\n// write(1, message, length)\nMOV X0, #1              // fd = stdout\nADR X1, message         // buffer\nMOV X2, #13             // length\nMOV X8, #64             // syscall: write\nSVC #0\n\n// exit(0)\nMOV X0, #0              // status\nMOV X8, #93             // syscall: exit\nSVC #0\n```\n"}, {"path": "x86-64.md", "category": "spec", "name": "x86-64", "content": "# x86-64 Instruction Set Reference\n\nSee: https://www.felixcloutier.com/x86/\n"}, {"path": "riscv.md", "category": "spec", "name": "riscv", "content": "# RISC-V Specifications\n\nSee: https://riscv.org/technical/specifications/\n"}]}
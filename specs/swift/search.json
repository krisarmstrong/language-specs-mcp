{"language": "swift", "generatedAt": "2026-01-05T20:16:25.156592+00:00", "entries": [{"path": "patterns/idioms.md", "category": "patterns", "name": "patterns/idioms", "content": "# Swift Idioms\n\n## Prefer value types\n\nUse structs by default; use classes when identity is required.\n\n## Use optionals explicitly\n\n```swift\nlet value: String?\n```\n\n## Favor protocol-oriented design\n"}, {"path": "formatters/swift-format.md", "category": "formatters", "name": "formatters/swift-format", "content": "# swift-format Options\nVersion: unknown\n\nSource: https://github.com/apple/swift-format/blob/main/Documentation/Configuration.md\n\n\nSee: https://github.com/apple/swift-format/blob/main/Documentation/Configuration.md\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# Swift Formatters\n\n## swift-format\n\nSee: https://github.com/apple/swift-format\n"}, {"path": "stdlib/overview.md", "category": "stdlib", "name": "stdlib/overview", "content": "# Swift Standard Library\n\nSee: https://developer.apple.com/documentation/swift/swift_standard_library\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# The Swift Programming Language\nVersion: unknown\n\nSource: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/\n\n\nSee: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/\n"}, {"path": "linters/swiftlint/overview.md", "category": "linters", "name": "linters/swiftlint/overview", "content": "# SwiftLint Rules\nVersion: unknown\n\nSource: https://realm.github.io/SwiftLint/rule-directory.html\n\n\nSee: https://realm.github.io/SwiftLint/rule-directory.html\n"}, {"path": "linters/swiftlint/rules.md", "category": "linters", "name": "linters/swiftlint/rules", "content": "# SwiftLint Rules\n\n## Style Rules\n\n### closure_parameter_position\n\nClosure parameters should be on same line as opening brace.\n\n```swift\n// BAD\ndoSomething {\n    param in\n    print(param)\n}\n\n// GOOD\ndoSomething { param in\n    print(param)\n}\n```\n\n### colon\n\nColon spacing rules.\n\n```swift\n// BAD\nlet dict:Dictionary<String,Int> = [:]\nfunc foo(bar :Int) { }\n\n// GOOD\nlet dict: Dictionary<String, Int> = [:]\nfunc foo(bar: Int) { }\n```\n\n### comma\n\nNo space before comma, one space after.\n\n```swift\n// BAD\nlet arr = [1 ,2 ,3]\nlet arr = [1,2,3]\n\n// GOOD\nlet arr = [1, 2, 3]\n```\n\n### control_statement\n\nNo parentheses around conditions.\n\n```swift\n// BAD\nif (condition) { }\nwhile (condition) { }\nswitch (value) { }\n\n// GOOD\nif condition { }\nwhile condition { }\nswitch value { }\n```\n\n### empty_parentheses_with_trailing_closure\n\nNo empty parentheses with trailing closure.\n\n```swift\n// BAD\narray.map() { $0 * 2 }\n\n// GOOD\narray.map { $0 * 2 }\n```\n\n### implicit_getter\n\nRead-only computed properties don't need get.\n\n```swift\n// BAD\nvar computed: Int {\n    get {\n        return 0\n    }\n}\n\n// GOOD\nvar computed: Int {\n    return 0\n}\n```\n\n### leading_whitespace\n\nFiles shouldn't start with whitespace.\n\n### mark\n\nMARK comments should be formatted correctly.\n\n```swift\n// BAD\n//MARK: Section\n// MARK:Section\n// MARK :Section\n\n// GOOD\n// MARK: - Section\n// MARK: Section\n```\n\n### opening_brace\n\nOpening brace on same line with one space.\n\n```swift\n// BAD\nif condition\n{\n}\nfunc foo(){}\n\n// GOOD\nif condition {\n}\nfunc foo() {\n}\n```\n\n### operator_usage_whitespace\n\nOperators should have spacing.\n\n```swift\n// BAD\nlet sum=1+2\nlet range = 1...10\n\n// GOOD\nlet sum = 1 + 2\nlet range = 1...10  // exception for range operators\n```\n\n### return_arrow_whitespace\n\nSpacing around return arrow.\n\n```swift\n// BAD\nfunc foo()->Int { }\nfunc bar()-> Int { }\n\n// GOOD\nfunc foo() -> Int { }\n```\n\n### sorted_imports\n\nImports should be sorted.\n\n```swift\n// BAD\nimport UIKit\nimport Foundation\nimport CoreData\n\n// GOOD\nimport CoreData\nimport Foundation\nimport UIKit\n```\n\n### statement_position\n\nelse/catch on same line as closing brace.\n\n```swift\n// BAD\nif condition {\n}\nelse {\n}\n\n// GOOD\nif condition {\n} else {\n}\n```\n\n### trailing_comma\n\nTrailing commas in arrays/dictionaries.\n\n```swift\n// Depends on configuration\n// With trailing_comma enabled:\nlet array = [\n    1,\n    2,\n    3,  // trailing comma\n]\n```\n\n### trailing_newline\n\nFiles should end with single newline.\n\n### trailing_semicolon\n\nNo trailing semicolons.\n\n```swift\n// BAD\nlet x = 1;\n\n// GOOD\nlet x = 1\n```\n\n### trailing_whitespace\n\nNo trailing whitespace on lines.\n\n### vertical_whitespace\n\nLimit consecutive empty lines.\n\n```swift\n// BAD\nfunc foo() {\n\n\n    doSomething()\n}\n\n// GOOD\nfunc foo() {\n    doSomething()\n}\n```\n\n## Lint Rules\n\n### class_delegate_protocol\n\nDelegate protocols should be class-only.\n\n```swift\n// BAD\nprotocol MyDelegate {\n    func didUpdate()\n}\n\n// GOOD\nprotocol MyDelegate: AnyObject {\n    func didUpdate()\n}\n```\n\n### closing_brace\n\nClosing brace shouldn't have blank line before.\n\n### computed_accessors_order\n\nGet should come before set.\n\n```swift\n// BAD\nvar value: Int {\n    set { _value = newValue }\n    get { _value }\n}\n\n// GOOD\nvar value: Int {\n    get { _value }\n    set { _value = newValue }\n}\n```\n\n### empty_enum_arguments\n\nDon't specify empty arguments in enum cases.\n\n```swift\n// BAD\nswitch result {\ncase .success():\n    break\n}\n\n// GOOD\nswitch result {\ncase .success:\n    break\n}\n```\n\n### empty_parameters\n\nUse Void -> instead of () ->.\n\n```swift\n// BAD\nlet closure: () -> Int\n\n// GOOD\nlet closure: Void -> Int\n```\n\n### empty_string\n\nPrefer isEmpty over comparison to \"\".\n\n```swift\n// BAD\nif string == \"\" { }\nif string != \"\" { }\n\n// GOOD\nif string.isEmpty { }\nif !string.isEmpty { }\n```\n\n### force_cast\n\nAvoid force casting.\n\n```swift\n// BAD\nlet x = object as! String\n\n// GOOD\nif let x = object as? String { }\nguard let x = object as? String else { return }\n```\n\n### force_try\n\nAvoid force try.\n\n```swift\n// BAD\nlet result = try! riskyOperation()\n\n// GOOD\ndo {\n    let result = try riskyOperation()\n} catch {\n    handleError(error)\n}\n```\n\n### force_unwrapping\n\nAvoid force unwrapping.\n\n```swift\n// BAD\nlet value = optional!\n\n// GOOD\nif let value = optional { }\nguard let value = optional else { return }\nlet value = optional ?? defaultValue\n```\n\n### implicit_return\n\nPrefer implicit return in single-expression functions.\n\n```swift\n// BAD\nvar computed: Int {\n    return 0\n}\n\nfunc double(_ x: Int) -> Int {\n    return x * 2\n}\n\n// GOOD\nvar computed: Int { 0 }\n\nfunc double(_ x: Int) -> Int { x * 2 }\n```\n\n### legacy_cggeometry_functions\n\nUse modern CGRect methods.\n\n```swift\n// BAD\nCGRectGetWidth(rect)\nCGRectGetHeight(rect)\n\n// GOOD\nrect.width\nrect.height\n```\n\n### legacy_constant\n\nUse modern constant syntax.\n\n```swift\n// BAD\nCGPointZero\nCGSizeZero\nCGRectZero\n\n// GOOD\nCGPoint.zero\nCGSize.zero\nCGRect.zero\n```\n\n### legacy_constructor\n\nUse Swift constructors.\n\n```swift\n// BAD\nCGPointMake(1, 2)\nCGSizeMake(10, 20)\nCGRectMake(0, 0, 100, 100)\n\n// GOOD\nCGPoint(x: 1, y: 2)\nCGSize(width: 10, height: 20)\nCGRect(x: 0, y: 0, width: 100, height: 100)\n```\n\n### multiple_closures_with_trailing_closure\n\nDon't use trailing closure with multiple closures.\n\n```swift\n// BAD\nanimate(duration: 0.3) {\n    // animations\n} completion: { _ in\n    // completion\n}\n\n// GOOD\nanimate(\n    duration: 0.3,\n    animations: {\n        // animations\n    },\n    completion: { _ in\n        // completion\n    }\n)\n```\n\n### notification_center_detachment\n\nUnregister from NotificationCenter in deinit.\n\n```swift\n// GOOD\ndeinit {\n    NotificationCenter.default.removeObserver(self)\n}\n```\n\n### private_outlet\n\nIBOutlets should be private.\n\n```swift\n// BAD\n@IBOutlet weak var label: UILabel!\n\n// GOOD\n@IBOutlet private weak var label: UILabel!\n```\n\n### private_unit_test\n\nUnit test methods/properties should be private.\n\n### redundant_discardable_let\n\nDon't use let _ = when function returns discardable result.\n\n```swift\n// BAD\nlet _ = doSomething()\n\n// GOOD\n_ = doSomething()\n// Or if return value is truly unused:\ndoSomething()\n```\n\n### redundant_nil_coalescing\n\nDon't use ?? nil.\n\n```swift\n// BAD\nlet x = optional ?? nil\n\n// GOOD\nlet x = optional\n```\n\n### redundant_optional_initialization\n\nDon't explicitly initialize optionals to nil.\n\n```swift\n// BAD\nvar name: String? = nil\n\n// GOOD\nvar name: String?\n```\n\n### redundant_set_access_control\n\nDon't specify set access if same as get.\n\n```swift\n// BAD\nprivate(set) private var value: Int\n\n// GOOD\nprivate var value: Int\n```\n\n### redundant_string_enum_value\n\nDon't specify enum raw value if same as case name.\n\n```swift\n// BAD\nenum Direction: String {\n    case north = \"north\"\n    case south = \"south\"\n}\n\n// GOOD\nenum Direction: String {\n    case north\n    case south\n}\n```\n\n### redundant_void_return\n\nDon't specify Void return type.\n\n```swift\n// BAD\nfunc doSomething() -> Void { }\nfunc doSomething() -> () { }\n\n// GOOD\nfunc doSomething() { }\n```\n\n### self_in_property_initialization\n\nDon't use self in property initialization.\n\n```swift\n// BAD\nclass Foo {\n    var bar = self.baz()  // self not available yet\n}\n```\n\n### shorthand_operator\n\nUse shorthand operators.\n\n```swift\n// BAD\ncount = count + 1\ncount = count - 1\n\n// GOOD\ncount += 1\ncount -= 1\n```\n\n### syntactic_sugar\n\nUse syntactic sugar for types.\n\n```swift\n// BAD\nlet array: Array<Int>\nlet dict: Dictionary<String, Int>\nlet optional: Optional<String>\n\n// GOOD\nlet array: [Int]\nlet dict: [String: Int]\nlet optional: String?\n```\n\n### todo\n\nTODO/FIXME comments trigger warnings.\n\n```swift\n// TODO: This triggers a warning\n// FIXME: This too\n```\n\n### unavailable_function\n\nUnavailable functions should have body with fatalError.\n\n```swift\n@available(*, unavailable)\nfunc deprecated() {\n    fatalError()\n}\n```\n\n### unneeded_break_in_switch\n\nDon't use break in non-empty switch cases.\n\n```swift\n// BAD\nswitch value {\ncase 0:\n    doSomething()\n    break\ndefault:\n    break\n}\n\n// GOOD\nswitch value {\ncase 0:\n    doSomething()\ndefault:\n    break  // OK in empty case\n}\n```\n\n### unused_closure_parameter\n\nReplace unused closure parameters with _.\n\n```swift\n// BAD\narray.map { item in 0 }\n\n// GOOD\narray.map { _ in 0 }\n```\n\n### unused_enumerated\n\nDon't use enumerated() if only using index or element.\n\n```swift\n// BAD - not using index\nfor (_, item) in array.enumerated() { }\n\n// BAD - not using element\nfor (index, _) in array.enumerated() { }\n\n// GOOD\nfor item in array { }\nfor index in array.indices { }\n```\n\n### unused_optional_binding\n\nDon't use optional binding just to discard.\n\n```swift\n// BAD\nif let _ = optional { }\n\n// GOOD\nif optional != nil { }\n```\n\n### valid_ibinspectable\n\nIBInspectable must have explicit type.\n\n```swift\n// BAD\n@IBInspectable var color = UIColor.red\n\n// GOOD\n@IBInspectable var color: UIColor = .red\n```\n\n### void_return\n\nUse Void instead of ().\n\n```swift\n// BAD\nfunc foo() -> () { }\n\n// GOOD\nfunc foo() -> Void { }\nfunc foo() { }  // best\n```\n\n### weak_delegate\n\nDelegates should be weak.\n\n```swift\n// BAD\nvar delegate: MyDelegate?\n\n// GOOD\nweak var delegate: MyDelegate?\n```\n\n## Metrics\n\n### cyclomatic_complexity\n\nFunction complexity limit.\n\n```swift\n// Configure threshold\ncyclomatic_complexity:\n  warning: 10\n  error: 20\n```\n\n### file_length\n\nFile line count limit.\n\n### function_body_length\n\nFunction line count limit.\n\n### function_parameter_count\n\nParameter count limit.\n\n### line_length\n\nLine character count limit.\n\n### nesting\n\nType/statement nesting limit.\n\n### type_body_length\n\nType line count limit.\n\n## Opt-in Rules\n\n### array_init\n\nUse Array(seq) instead of seq.map { $0 }.\n\n```swift\n// BAD\nlet array = sequence.map { $0 }\n\n// GOOD\nlet array = Array(sequence)\n```\n\n### attributes\n\nAttribute placement rules.\n\n### closure_body_length\n\nClosure line count limit.\n\n### closure_end_indentation\n\nClosure end should align with start.\n\n### collection_alignment\n\nElements in multiline collections should align.\n\n### conditional_returns_on_newline\n\nConditional return should be on separate line.\n\n```swift\n// BAD\nguard condition else { return }\n\n// GOOD\nguard condition else {\n    return\n}\n```\n\n### contains_over_filter_count\n\nUse contains instead of filter.count.\n\n```swift\n// BAD\narray.filter { $0 == target }.count > 0\n\n// GOOD\narray.contains { $0 == target }\n```\n\n### contains_over_filter_is_empty\n\nUse contains instead of filter.isEmpty.\n\n```swift\n// BAD\narray.filter { $0 == target }.isEmpty\n\n// GOOD\n!array.contains { $0 == target }\n```\n\n### contains_over_first_not_nil\n\nUse contains instead of first != nil.\n\n```swift\n// BAD\narray.first { $0 == target } != nil\n\n// GOOD\narray.contains { $0 == target }\n```\n\n### discouraged_object_literal\n\nAvoid #colorLiteral and #imageLiteral.\n\n### empty_collection_literal\n\nUse isEmpty instead of == [].\n\n```swift\n// BAD\nif array == [] { }\n\n// GOOD\nif array.isEmpty { }\n```\n\n### empty_count\n\nUse isEmpty instead of count == 0.\n\n```swift\n// BAD\nif array.count == 0 { }\n\n// GOOD\nif array.isEmpty { }\n```\n\n### empty_xctest_method\n\nTest methods shouldn't be empty.\n\n### enum_case_associated_values_count\n\nLimit associated values per case.\n\n### expiring_todo\n\nTODOs with dates trigger errors after expiry.\n\n```swift\n// TODO: [2024-01-01] Fix this before release\n```\n\n### explicit_acl\n\nRequire explicit access control.\n\n### explicit_enum_raw_value\n\nRequire explicit raw values.\n\n### explicit_init\n\nDon't call .init explicitly.\n\n```swift\n// BAD\nlet x = Foo.init()\n\n// GOOD\nlet x = Foo()\n```\n\n### explicit_self\n\nRequire self for instance members.\n\n### explicit_top_level_acl\n\nTop-level declarations need access control.\n\n### explicit_type_interface\n\nProperties need type annotation.\n\n### extension_access_modifier\n\nExtension access modifier rules.\n\n### fallthrough\n\nAvoid fallthrough.\n\n### fatal_error_message\n\nfatalError needs message.\n\n```swift\n// BAD\nfatalError()\n\n// GOOD\nfatalError(\"Unexpected state\")\n```\n\n### file_header\n\nFile header format rules.\n\n### file_name\n\nFile name should match type name.\n\n### file_name_no_space\n\nNo spaces in file names.\n\n### file_types_order\n\nOrdering of types in file.\n\n### first_where\n\nUse first(where:) instead of filter.first.\n\n```swift\n// BAD\narray.filter { $0.isValid }.first\n\n// GOOD\narray.first { $0.isValid }\n```\n\n### flatmap_over_map_reduce\n\nUse flatMap instead of map.reduce.\n\n### for_where\n\nUse for-where instead of if inside for.\n\n```swift\n// BAD\nfor item in array {\n    if item.isValid {\n        process(item)\n    }\n}\n\n// GOOD\nfor item in array where item.isValid {\n    process(item)\n}\n```\n\n### force_unwrapping\n\n(also in lint rules above)\n\n### function_default_parameter_at_end\n\nDefault parameters should be at end.\n\n```swift\n// BAD\nfunc foo(a: Int = 0, b: Int) { }\n\n// GOOD\nfunc foo(b: Int, a: Int = 0) { }\n```\n\n### ibinspectable_in_extension\n\nNo IBInspectable in extensions.\n\n### identical_operands\n\nDon't compare identical operands.\n\n```swift\n// BAD\nif x == x { }\n```\n\n### implicit_return\n\n(also in lint rules above)\n\n### implicitly_unwrapped_optional\n\nAvoid implicitly unwrapped optionals.\n\n```swift\n// BAD\nvar name: String!\n\n// GOOD\nvar name: String?\n```\n\n### indentation_width\n\nConsistent indentation.\n\n### joined_default_parameter\n\nUse default separator for joined().\n\n```swift\n// BAD\narray.joined(separator: \"\")\n\n// GOOD\narray.joined()\n```\n\n### last_where\n\nUse last(where:) instead of filter.last.\n\n### legacy_multiple\n\nUse isMultiple(of:).\n\n```swift\n// BAD\nx % 2 == 0\n\n// GOOD\nx.isMultiple(of: 2)\n```\n\n### legacy_random\n\nUse Swift random.\n\n```swift\n// BAD\narc4random()\narc4random_uniform(10)\n\n// GOOD\nInt.random(in: 0..<10)\n```\n\n### let_var_whitespace\n\nBlank line after let/var declarations.\n\n### literal_expression_end_indentation\n\nLiteral closing should align with opening.\n\n### lower_acl_than_parent\n\nChild access can't exceed parent.\n\n### missing_docs\n\nPublic declarations need documentation.\n\n### modifier_order\n\nConsistent modifier order.\n\n### multiline_arguments\n\nFunction call arguments on separate lines.\n\n### multiline_arguments_brackets\n\nBrackets on separate lines for multiline.\n\n### multiline_function_chains\n\nEach chain call on separate line.\n\n### multiline_literal_brackets\n\nBrackets on separate lines for multiline literals.\n\n### multiline_parameters\n\nParameters on separate lines.\n\n### multiline_parameters_brackets\n\nBrackets on separate lines.\n\n### nimble_operator\n\nUse Nimble operator matchers.\n\n### no_extension_access_modifier\n\nNo access modifiers on extensions.\n\n### no_fallthrough_only\n\nDon't use fallthrough as only statement.\n\n### no_grouping_extension\n\nNo extensions that only add same-module conformance.\n\n### nslocalizedstring_key\n\nNSLocalizedString key must be static string.\n\n### nslocalizedstring_require_bundle\n\nNSLocalizedString needs bundle.\n\n### number_separator\n\nUse _ for number grouping.\n\n```swift\n// BAD\nlet million = 1000000\n\n// GOOD\nlet million = 1_000_000\n```\n\n### object_literal\n\nUse object literals.\n\n### operator_whitespace\n\nOperator declaration spacing.\n\n### optional_enum_case_matching\n\nMatch optional enum without ?.\n\n```swift\n// BAD\nswitch optional {\ncase .some(.value)?:\n    break\n}\n\n// GOOD\nswitch optional {\ncase .value:\n    break\n}\n```\n\n### overridden_super_call\n\nOverride must call super.\n\n### override_in_extension\n\nDon't override in extensions.\n\n### pattern_matching_keywords\n\nKeywords in pattern matching.\n\n### prefer_nimble\n\nPrefer Nimble matchers over XCTAssert.\n\n### prefer_self_in_static_references\n\nUse Self instead of type name.\n\n```swift\n// BAD\nclass Foo {\n    static func create() -> Foo { }\n}\n\n// GOOD\nclass Foo {\n    static func create() -> Self { }\n}\n```\n\n### prefer_self_type_over_type_of_self\n\nUse Self instead of type(of: self).\n\n### prefer_zero_over_explicit_init\n\nUse .zero over explicit init.\n\n```swift\n// BAD\nCGPoint(x: 0, y: 0)\nCGRect(x: 0, y: 0, width: 0, height: 0)\n\n// GOOD\nCGPoint.zero\nCGRect.zero\n```\n\n### prefixed_toplevel_constant\n\nTop-level constants should have prefix.\n\n### private_action\n\nIBActions should be private.\n\n### private_outlet\n\n(also in lint rules above)\n\n### private_subject\n\nCombine subjects should be private.\n\n### prohibited_interface_builder\n\nAvoid Interface Builder.\n\n### prohibited_super_call\n\nDon't call super in certain methods.\n\n### quick_discouraged_call\n\nAvoid function calls in Quick describes.\n\n### quick_discouraged_focused_test\n\nNo focused Quick tests.\n\n### quick_discouraged_pending_test\n\nNo pending Quick tests.\n\n### raw_value_for_camel_cased_codable_enum\n\nCamel case enums need raw values for Codable.\n\n### reduce_boolean\n\nUse allSatisfy/contains instead of reduce for bools.\n\n```swift\n// BAD\narray.reduce(true) { $0 && $1.isValid }\n\n// GOOD\narray.allSatisfy { $0.isValid }\n```\n\n### reduce_into\n\nUse reduce(into:) for efficiency.\n\n```swift\n// BAD\narray.reduce([]) { $0 + [$1] }\n\n// GOOD\narray.reduce(into: []) { $0.append($1) }\n```\n\n### redundant_objc_attribute\n\nDon't use @objc when implied.\n\n### redundant_type_annotation\n\nDon't specify type when inferrable.\n\n```swift\n// BAD\nlet name: String = \"Alice\"\n\n// GOOD\nlet name = \"Alice\"\n```\n\n### required_deinit\n\nClasses should have deinit.\n\n### required_enum_case\n\nProtocol enums need certain cases.\n\n### single_test_class\n\nOne test class per file.\n\n### sorted_first_last\n\nUse min/max instead of sorted.first/last.\n\n```swift\n// BAD\narray.sorted().first\narray.sorted().last\n\n// GOOD\narray.min()\narray.max()\n```\n\n### static_operator\n\nOperators should be static.\n\n### strict_fileprivate\n\nPrefer private over fileprivate.\n\n### strong_iboutlet\n\nOutlets shouldn't be weak.\n\n### switch_case_on_newline\n\nCase body on new line.\n\n### toggle_bool\n\nUse toggle().\n\n```swift\n// BAD\nflag = !flag\n\n// GOOD\nflag.toggle()\n```\n\n### trailing_closure\n\nUse trailing closure when possible.\n\n### type_contents_order\n\nOrder of type contents.\n\n### typesafe_array_init\n\nUse type-safe array init.\n\n### unavailable_condition\n\nUse #unavailable.\n\n```swift\n// BAD\nif #available(iOS 15, *) { } else { old() }\n\n// GOOD\nif #unavailable(iOS 15) { old() }\n```\n\n### unneeded_parentheses_in_closure_argument\n\nNo parentheses for single closure param.\n\n```swift\n// BAD\narray.map({ (item) in item })\n\n// GOOD\narray.map({ item in item })\narray.map { $0 }\n```\n\n### unowned_variable_capture\n\nPrefer weak over unowned.\n\n### untyped_error_in_catch\n\nCatch should have typed error.\n\n```swift\n// BAD\ncatch { }\n\n// GOOD\ncatch let error { }\ncatch let error as MyError { }\n```\n\n### unused_declaration\n\nUnused private declarations.\n\n### unused_import\n\nUnused imports.\n\n### vertical_parameter_alignment\n\nParameters should align.\n\n### vertical_parameter_alignment_on_call\n\nCall arguments should align.\n\n### vertical_whitespace_between_cases\n\nBlank line between switch cases.\n\n### vertical_whitespace_closing_braces\n\nNo blank line before closing brace.\n\n### vertical_whitespace_opening_braces\n\nNo blank line after opening brace.\n\n### xct_specific_matcher\n\nUse specific XCT matchers.\n\n```swift\n// BAD\nXCTAssertTrue(x == y)\n\n// GOOD\nXCTAssertEqual(x, y)\n```\n\n### yoda_condition\n\nAvoid Yoda conditions.\n\n```swift\n// BAD\nif 5 == x { }\n\n// GOOD\nif x == 5 { }\n```\n"}]}
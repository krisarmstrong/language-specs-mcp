{"language": "python", "generatedAt": "2026-01-05T20:16:24.882500+00:00", "entries": [{"path": "pep8.md", "category": "spec", "name": "pep8", "content": "# PEP 8 - Python Style Guide (Summary)\n\n## Indentation\n\n- Use 4 spaces per indentation level\n- Never mix tabs and spaces\n\n## Maximum Line Length\n\n- Limit lines to 79 characters (code)\n- Limit lines to 72 characters (docstrings/comments)\n- Can extend to 99 for teams that agree\n\n## Imports\n\n```python\n# Standard library\nimport os\nimport sys\n\n# Third party\nimport numpy as np\nimport pandas as pd\n\n# Local\nfrom mypackage import mymodule\n```\n\n- One import per line\n- Absolute imports preferred\n- Avoid wildcard imports (`from x import *`)\n\n## Whitespace\n\n```python\n# GOOD\nspam(ham[1], {eggs: 2})\nfoo = (0,)\nif x == 4: print(x, y); x, y = y, x\n\n# BAD\nspam( ham[ 1 ], { eggs: 2 } )\nfoo = (0, )\nif x == 4 : print(x , y) ; x , y = y , x\n```\n\n## Naming Conventions\n\n| Type | Convention |\n|------|------------|\n| Modules | `lowercase_with_underscores` |\n| Classes | `CapWords` |\n| Functions | `lowercase_with_underscores` |\n| Variables | `lowercase_with_underscores` |\n| Constants | `UPPERCASE_WITH_UNDERSCORES` |\n| Private | `_single_leading_underscore` |\n| \"Mangled\" | `__double_leading_underscore` |\n\n## Type Hints (PEP 484)\n\n```python\ndef greeting(name: str) -> str:\n    return f\"Hello, {name}\"\n\ndef process(items: list[int]) -> dict[str, int]:\n    return {\"count\": len(items)}\n```\n"}, {"path": "patterns/idioms.md", "category": "patterns", "name": "patterns/idioms", "content": "# Python Idiomatic Patterns (3.10+)\n\n## Type Hints (Always Use)\n\n```python\n# BAD\ndef process(data):\n    return data.get(\"value\")\n\n# GOOD\ndef process(data: dict[str, Any]) -> str | None:\n    return data.get(\"value\")\n```\n\n## Match Statements (3.10+)\n\n```python\ndef handle_response(response: Response) -> str:\n    match response.status:\n        case 200:\n            return response.body\n        case 404:\n            raise NotFoundError()\n        case 500:\n            raise ServerError()\n        case _:\n            raise UnknownError(response.status)\n```\n\n## Dataclasses\n\n```python\nfrom dataclasses import dataclass\n\n# BAD - boilerplate\nclass User:\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n    \n    def __repr__(self):\n        return f\"User(name={self.name!r}, age={self.age})\"\n\n# GOOD\n@dataclass\nclass User:\n    name: str\n    age: int\n```\n\n## Context Managers\n\n```python\n# File handling\nwith open(\"file.txt\") as f:\n    content = f.read()\n\n# Multiple contexts\nwith (\n    open(\"input.txt\") as infile,\n    open(\"output.txt\", \"w\") as outfile,\n):\n    outfile.write(infile.read())\n\n# Custom context manager\nfrom contextlib import contextmanager\n\n@contextmanager\ndef timer():\n    start = time.time()\n    yield\n    print(f\"Elapsed: {time.time() - start:.2f}s\")\n```\n\n## List/Dict/Set Comprehensions\n\n```python\n# List\nsquares = [x**2 for x in range(10)]\n\n# Dict\ncounts = {word: len(word) for word in words}\n\n# Set\nunique_lengths = {len(word) for word in words}\n\n# Generator (memory efficient)\nsquares_gen = (x**2 for x in range(10))\n```\n\n## Walrus Operator (3.8+)\n\n```python\n# Read until empty\nwhile (line := file.readline()):\n    process(line)\n\n# Check and use\nif (match := pattern.search(text)):\n    print(match.group())\n```\n\n## f-strings (Always Use)\n\n```python\n# BAD\n\"Hello, \" + name + \"!\"\n\"Hello, {}!\".format(name)\n\"Hello, %s!\" % name\n\n# GOOD\nf\"Hello, {name}!\"\nf\"Value: {value:.2f}\"\nf\"Debug: {obj=}\"  # Shows 'obj=<value>'\n```\n\n## Exception Handling\n\n```python\n# Specific exceptions\ntry:\n    value = data[\"key\"]\nexcept KeyError:\n    value = default\n\n# Exception groups (3.11+)\ntry:\n    async with asyncio.TaskGroup() as tg:\n        tg.create_task(task1())\n        tg.create_task(task2())\nexcept* ValueError as eg:\n    for exc in eg.exceptions:\n        handle(exc)\n```\n\n## Pathlib (Not os.path)\n\n```python\n# BAD\nimport os\npath = os.path.join(base, \"subdir\", \"file.txt\")\nif os.path.exists(path):\n    with open(path) as f:\n        pass\n\n# GOOD\nfrom pathlib import Path\npath = Path(base) / \"subdir\" / \"file.txt\"\nif path.exists():\n    content = path.read_text()\n```\n\n## Enum\n\n```python\nfrom enum import Enum, auto\n\nclass Status(Enum):\n    PENDING = auto()\n    RUNNING = auto()\n    COMPLETE = auto()\n    FAILED = auto()\n\ndef handle(status: Status) -> None:\n    match status:\n        case Status.PENDING:\n            start()\n        case Status.COMPLETE:\n            cleanup()\n```\n\n## functools\n\n```python\nfrom functools import cache, lru_cache, partial\n\n@cache  # Unbounded cache\ndef fibonacci(n: int) -> int:\n    if n < 2:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\n@lru_cache(maxsize=128)  # Bounded cache\ndef expensive(x: int) -> int:\n    return compute(x)\n```\n"}, {"path": "formatters/ruff.md", "category": "formatters", "name": "formatters/ruff", "content": ".. Ruff [ruff](https://github.com/astral-sh/ruff)\n\n- [Overview](..)\n- [Tutorial](../tutorial/)\n- [Installing Ruff](../installation/)\n- [The Ruff Linter](../linter/)\n-  The Ruff Formatter [The Ruff Formatter](./) Table of contents \n\n  - [ruff format](#ruff-format)\n  - [Philosophy](#philosophy)\n  - [Configuration](#configuration)\n  - [Docstring formatting](#docstring-formatting)\n  - [Format suppression](#format-suppression)\n  - [Conflicting lint rules](#conflicting-lint-rules)\n  - [Exit codes](#exit-codes)\n  - [Style Guide](#style-guide)\n\n    - [Intentional deviations](#intentional-deviations)\n    - [Preview style](#preview-style)\n    - [F-string formatting](#f-string-formatting)\n\n      - [Quotes](#quotes)\n      - [Line breaks](#line-breaks)\n      - [Fluent layout for method chains](#fluent-layout-for-method-chains)\n\n  - [Sorting imports](#sorting-imports)\n\n-  Editors  Editors \n\n  - [Editor Integration](../editors/)\n  - [Setup](../editors/setup/)\n  - [Features](../editors/features/)\n  - [Settings](../editors/settings/)\n  - [Migrating from ruff-lsp](../editors/migration/)\n\n- [Configuring Ruff](../configuration/)\n- [Preview](../preview/)\n- [Rules](../rules/)\n- [Settings](../settings/)\n- [Versioning](../versioning/)\n- [Integrations](../integrations/)\n- [FAQ](../faq/)\n- [Contributing](../contributing/)\n\n# [The Ruff Formatter](#the-ruff-formatter)\n\nThe Ruff formatter is an extremely fast Python code formatter designed as a drop-in replacement for [Black](https://pypi.org/project/black/), available as part of the `ruff` CLI via `ruff format`.\n\n## [ruff format](#ruff-format)\n\n`ruff format` is the primary entrypoint to the formatter. It accepts a list of files or directories, and formats all discovered Python files:\n\n```\n#__codelineno-0-1ruff format                   # Format all files in the current directory.\n#__codelineno-0-2ruff format path/to/code/     # Format all files in `path/to/code` (and any subdirectories).\n#__codelineno-0-3ruff format path/to/file.py   # Format a single file.\n```\n\nSimilar to Black, running `ruff format /path/to/file.py` will format the given file or directory in-place, while `ruff format --check /path/to/file.py` will avoid writing any formatted files back, and instead exit with a non-zero status code upon detecting any unformatted files.\n\nFor the full list of supported options, run `ruff format --help`.\n\n## [Philosophy](#philosophy)\n\nThe initial goal of the Ruff formatter is not to innovate on code style, but rather, to innovate on performance, and provide a unified toolchain across Ruff's linter, formatter, and any and all future tools.\n\nAs such, the formatter is designed as a drop-in replacement for [Black](https://github.com/psf/black), but with an excessive focus on performance and direct integration with Ruff. Given Black's popularity within the Python ecosystem, targeting Black compatibility ensures that formatter adoption is minimally disruptive for the vast majority of projects.\n\nSpecifically, the formatter is intended to emit near-identical output when run over existing Black-formatted code. When run over extensive Black-formatted projects like Django and Zulip, > 99.9% of lines are formatted identically. (See: [Style Guide](#style-guide).)\n\nGiven this focus on Black compatibility, the formatter thus adheres to [Black's (stable) code style](https://black.readthedocs.io/en/stable/the_black_code_style/current_style.html), which aims for \"consistency, generality, readability and reducing git diffs\". To give you a sense for the enforced code style, here's an example:\n\n```\n#__codelineno-1-1# Input\n#__codelineno-1-2def _make_ssl_transport(\n#__codelineno-1-3    rawsock, protocol, sslcontext, waiter=None,\n#__codelineno-1-4    *, server_side=False, server_hostname=None,\n#__codelineno-1-5    extra=None, server=None,\n#__codelineno-1-6    ssl_handshake_timeout=None,\n#__codelineno-1-7    call_connection_made=True):\n#__codelineno-1-8    '''Make an SSL transport.'''\n#__codelineno-1-9    if waiter is None:\n#__codelineno-1-10      waiter = Future(loop=loop)\n#__codelineno-1-11\n#__codelineno-1-12    if extra is None:\n#__codelineno-1-13      extra = {}\n#__codelineno-1-14\n#__codelineno-1-15    ...\n#__codelineno-1-16\n#__codelineno-1-17# Ruff\n#__codelineno-1-18def _make_ssl_transport(\n#__codelineno-1-19    rawsock,\n#__codelineno-1-20    protocol,\n#__codelineno-1-21    sslcontext,\n#__codelineno-1-22    waiter=None,\n#__codelineno-1-23    *,\n#__codelineno-1-24    server_side=False,\n#__codelineno-1-25    server_hostname=None,\n#__codelineno-1-26    extra=None,\n#__codelineno-1-27    server=None,\n#__codelineno-1-28    ssl_handshake_timeout=None,\n#__codelineno-1-29    call_connection_made=True,\n#__codelineno-1-30):\n#__codelineno-1-31    \"\"\"Make an SSL transport.\"\"\"\n#__codelineno-1-32    if waiter is None:\n#__codelineno-1-33        waiter = Future(loop=loop)\n#__codelineno-1-34\n#__codelineno-1-35    if extra is None:\n#__codelineno-1-36        extra = {}\n#__codelineno-1-37\n#__codelineno-1-38    ...\n```\n\nLike Black, the Ruff formatter does not support extensive code style configuration; however, unlike Black, it does support configuring the desired quote style, indent style, line endings, and more. (See: [Configuration](#configuration).)\n\nWhile the formatter is designed to be a drop-in replacement for Black, it is not intended to be used interchangeably with Black on an ongoing basis, as the formatter does differ from Black in a few conscious ways (see: [Known deviations](black/)). In general, deviations are limited to cases in which Ruff's behavior was deemed more consistent, or significantly simpler to support (with negligible end-user impact) given the differences in the underlying implementations between Black and Ruff.\n\nGoing forward, the Ruff Formatter will support Black's preview style under Ruff's own [preview](../preview/) mode.\n\n## [Configuration](#configuration)\n\nThe Ruff Formatter exposes a small set of configuration options, some of which are also supported by Black (like line width), some of which are unique to Ruff (like quote, indentation style and formatting code examples in docstrings).\n\nFor example, to configure the formatter to use single quotes, format code examples in docstrings, a line width of 100, and tab indentation, add the following to your configuration file:\n\npyproject.tomlruff.toml\n\n```\n#__codelineno-2-1[tool.ruff]\n#__codelineno-2-2line-length = 100\n#__codelineno-2-3\n#__codelineno-2-4[tool.ruff.format]\n#__codelineno-2-5quote-style = \"single\"\n#__codelineno-2-6indent-style = \"tab\"\n#__codelineno-2-7docstring-code-format = true\n```\n\n```\n#__codelineno-3-1line-length = 100\n#__codelineno-3-2\n#__codelineno-3-3[format]\n#__codelineno-3-4quote-style = \"single\"\n#__codelineno-3-5indent-style = \"tab\"\n#__codelineno-3-6docstring-code-format = true\n```\n\nFor the full list of supported settings, see [Settings](../settings/#format). For more on configuring Ruff via `pyproject.toml`, see [Configuring Ruff](../configuration/).\n\nGiven the focus on Black compatibility (and unlike formatters like [YAPF](https://github.com/google/yapf)), Ruff does not currently expose any other configuration options.\n\n## [Docstring formatting](#docstring-formatting)\n\nThe Ruff formatter provides an opt-in feature for automatically formatting Python code examples in docstrings. The Ruff formatter currently recognizes code examples in the following formats:\n\n- The Python [doctest](https://docs.python.org/3/library/doctest.html) format.\n- CommonMark [fenced code blocks](https://spec.commonmark.org/0.30/#fenced-code-blocks) with the following info strings: `python`, `py`, `python3`, or `py3`. Fenced code blocks without an info string are assumed to be Python code examples and also formatted.\n- reStructuredText [literal blocks](https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html#literal-blocks). While literal blocks may contain things other than Python, this is meant to reflect a long-standing convention in the Python ecosystem where literal blocks often contain Python code.\n- reStructuredText [`code-block` and `sourcecode` directives]. As with Markdown, the language names recognized for Python are `python`, `py`, `python3`, or `py3`.\n\nIf a code example is recognized and treated as Python, the Ruff formatter will automatically skip it if the code does not parse as valid Python or if the reformatted code would produce an invalid Python program.\n\nUsers may also configure the line length limit used for reformatting Python code examples in docstrings. The default is a special value, `dynamic`, which instructs the formatter to respect the line length limit setting for the surrounding Python code. The `dynamic` setting ensures that even when code examples are found inside indented docstrings, the line length limit configured for the surrounding Python code will not be exceeded. Users may also configure a fixed line length limit for code examples in docstrings.\n\nFor example, this configuration shows how to enable docstring code formatting with a fixed line length limit:\n\npyproject.tomlruff.toml\n\n```\n#__codelineno-4-1[tool.ruff.format]\n#__codelineno-4-2docstring-code-format = true\n#__codelineno-4-3docstring-code-line-length = 20\n```\n\n```\n#__codelineno-5-1[format]\n#__codelineno-5-2docstring-code-format = true\n#__codelineno-5-3docstring-code-line-length = 20\n```\n\nWith the above configuration, this code:\n\n```\n#__codelineno-6-1def f(x):\n#__codelineno-6-2    '''\n#__codelineno-6-3    Something about `f`. And an example:\n#__codelineno-6-4\n#__codelineno-6-5    .. code-block:: python\n#__codelineno-6-6\n#__codelineno-6-7        foo, bar, quux = this_is_a_long_line(lion, hippo, lemur, bear)\n#__codelineno-6-8    '''\n#__codelineno-6-9    pass\n```\n\n... will be reformatted (assuming the rest of the options are set to their defaults) as:\n\n```\n#__codelineno-7-1def f(x):\n#__codelineno-7-2    \"\"\"\n#__codelineno-7-3    Something about `f`. And an example:\n#__codelineno-7-4\n#__codelineno-7-5    .. code-block:: python\n#__codelineno-7-6\n#__codelineno-7-7        (\n#__codelineno-7-8            foo,\n#__codelineno-7-9            bar,\n#__codelineno-7-10            quux,\n#__codelineno-7-11        ) = this_is_a_long_line(\n#__codelineno-7-12            lion,\n#__codelineno-7-13            hippo,\n#__codelineno-7-14            lemur,\n#__codelineno-7-15            bear,\n#__codelineno-7-16        )\n#__codelineno-7-17    \"\"\"\n#__codelineno-7-18    pass\n```\n\n## [Format suppression](#format-suppression)\n\nLike Black, Ruff supports `# fmt: on`, `# fmt: off`, and `# fmt: skip` pragma comments, which can be used to temporarily disable formatting for a given code block.\n\n`# fmt: on` and `# fmt: off` comments are enforced at the statement level:\n\n```\n#__codelineno-8-1# fmt: off\n#__codelineno-8-2not_formatted=3\n#__codelineno-8-3also_not_formatted=4\n#__codelineno-8-4# fmt: on\n```\n\nAs such, adding `# fmt: on` and `# fmt: off` comments within expressions will have no effect. In the following example, both list entries will be formatted, despite the `# fmt: off`:\n\n```\n#__codelineno-9-1[\n#__codelineno-9-2    # fmt: off\n#__codelineno-9-3    '1',\n#__codelineno-9-4    # fmt: on\n#__codelineno-9-5    '2',\n#__codelineno-9-6]\n```\n\nInstead, apply the `# fmt: off` comment to the entire statement:\n\n```\n#__codelineno-10-1# fmt: off\n#__codelineno-10-2[\n#__codelineno-10-3    '1',\n#__codelineno-10-4    '2',\n#__codelineno-10-5]\n#__codelineno-10-6# fmt: on\n```\n\nLike Black, Ruff will also recognize [YAPF](https://github.com/google/yapf)'s `# yapf: disable` and `# yapf: enable` pragma comments, which are treated equivalently to `# fmt: off` and `# fmt: on`, respectively.\n\n`# fmt: skip` comments suppress formatting for a preceding statement, case header, decorator, function definition, or class definition:\n\n```\n#__codelineno-11-1if True:\n#__codelineno-11-2    pass\n#__codelineno-11-3elif False: # fmt: skip\n#__codelineno-11-4    pass\n#__codelineno-11-5\n#__codelineno-11-6@Test\n#__codelineno-11-7@Test2 # fmt: skip\n#__codelineno-11-8def test(): ...\n#__codelineno-11-9\n#__codelineno-11-10a = [1, 2, 3, 4, 5] # fmt: skip\n#__codelineno-11-11\n#__codelineno-11-12def test(a, b, c, d, e, f) -> int: # fmt: skip\n#__codelineno-11-13    pass\n```\n\nAs such, adding an `# fmt: skip` comment at the end of an expression will have no effect. In the following example, the list entry `'1'` will be formatted, despite the `# fmt: skip`:\n\n```\n#__codelineno-12-1a = call(\n#__codelineno-12-2    [\n#__codelineno-12-3        '1',  # fmt: skip\n#__codelineno-12-4        '2',\n#__codelineno-12-5    ],\n#__codelineno-12-6    b\n#__codelineno-12-7)\n```\n\nInstead, apply the `# fmt: skip` comment to the entire statement:\n\n```\n#__codelineno-13-1a = call(\n#__codelineno-13-2  [\n#__codelineno-13-3    '1',\n#__codelineno-13-4    '2',\n#__codelineno-13-5  ],\n#__codelineno-13-6  b\n#__codelineno-13-7)  # fmt: skip\n```\n\n## [Conflicting lint rules](#conflicting-lint-rules)\n\nRuff's formatter is designed to be used alongside the linter. However, the linter includes some rules that, when enabled, can cause conflicts with the formatter, leading to unexpected behavior. When configured appropriately, the goal of Ruff's formatter-linter compatibility is such that running the formatter should never introduce new lint errors.\n\nWhen using Ruff as a formatter, we recommend avoiding the following lint rules:\n\n- [tab-indentation](../rules/tab-indentation/) (`W191`)\n- [indentation-with-invalid-multiple](../rules/indentation-with-invalid-multiple/) (`E111`)\n- [indentation-with-invalid-multiple-comment](../rules/indentation-with-invalid-multiple-comment/) (`E114`)\n- [over-indented](../rules/over-indented/) (`E117`)\n- [docstring-tab-indentation](../rules/docstring-tab-indentation/) (`D206`)\n- [triple-single-quotes](../rules/triple-single-quotes/) (`D300`)\n- [bad-quotes-inline-string](../rules/bad-quotes-inline-string/) (`Q000`)\n- [bad-quotes-multiline-string](../rules/bad-quotes-multiline-string/) (`Q001`)\n- [bad-quotes-docstring](../rules/bad-quotes-docstring/) (`Q002`)\n- [avoidable-escaped-quote](../rules/avoidable-escaped-quote/) (`Q003`)\n- [missing-trailing-comma](../rules/missing-trailing-comma/) (`COM812`)\n- [prohibited-trailing-comma](../rules/prohibited-trailing-comma/) (`COM819`)\n- [multi-line-implicit-string-concatenation](../rules/multi-line-implicit-string-concatenation/) (`ISC002`) if used without `ISC001` and `flake8-implicit-str-concat.allow-multiline = false`\n\nWhile the [line-too-long](../rules/line-too-long/) (`E501`) rule can be used alongside the formatter, the formatter only makes a best-effort attempt to wrap lines at the configured [line-length](../settings/#line-length). As such, formatted code may exceed the line length, leading to [line-too-long](../rules/line-too-long/) (`E501`) errors.\n\nNone of the above are included in Ruff's default configuration. However, if you've enabled any of these rules or their parent categories (like `Q`), we recommend disabling them via the linter's [lint.ignore](../settings/#lint_ignore) setting.\n\nSimilarly, we recommend avoiding the following isort settings, which are incompatible with the formatter's treatment of import statements when set to non-default values:\n\n- [force-single-line](../settings/#lint_isort_force-single-line)\n- [force-wrap-aliases](../settings/#lint_isort_force-wrap-aliases)\n- [lines-after-imports](../settings/#lint_isort_lines-after-imports)\n- [lines-between-types](../settings/#lint_isort_lines-between-types)\n- [split-on-trailing-comma](../settings/#lint_isort_split-on-trailing-comma)\n\nIf you've configured any of these settings to take on non-default values, we recommend removing them from your Ruff configuration.\n\nWhen an incompatible lint rule or setting is enabled, `ruff format` will emit a warning. If your `ruff format` is free of warnings, you're good to go!\n\n## [Exit codes](#exit-codes)\n\n`ruff format` exits with the following status codes:\n\n- `0` if Ruff terminates successfully, regardless of whether any files were formatted.\n- `2` if Ruff terminates abnormally due to invalid configuration, invalid CLI options, or an internal error.\n\nMeanwhile, `ruff format --check` exits with the following status codes:\n\n- `0` if Ruff terminates successfully, and no files would be formatted if `--check` were not specified.\n- `1` if Ruff terminates successfully, and one or more files would be formatted if `--check` were not specified.\n- `2` if Ruff terminates abnormally due to invalid configuration, invalid CLI options, or an internal error.\n\n## [Style Guide](#style-guide)\n\nThe formatter is designed to be a drop-in replacement for [Black](https://github.com/psf/black). This section documents the areas where the Ruff formatter goes beyond Black in terms of code style.\n\n### [Intentional deviations](#intentional-deviations)\n\nWhile the Ruff formatter aims to be a drop-in replacement for Black, it does differ from Black in a few known ways. Some of these differences emerge from conscious attempts to improve upon Black's code style, while others fall out of differences in the underlying implementations.\n\nFor a complete enumeration of these intentional deviations, see [Known deviations](black/).\n\nUnintentional deviations from Black are tracked in the [issue tracker](https://github.com/astral-sh/ruff/issues?q=is%3Aopen+is%3Aissue+label%3Aformatter). If you've identified a new deviation, please [file an issue](https://github.com/astral-sh/ruff/issues/new).\n\n### [Preview style](#preview-style)\n\nSimilar to [Black](https://black.readthedocs.io/en/stable/the_black_code_style/future_style.html#preview-style), Ruff implements formatting changes under the [preview](https://docs.astral.sh/ruff/settings/#format_preview) flag, promoting them to stable through minor releases, in accordance with our [versioning policy](https://github.com/astral-sh/ruff/discussions/6998#discussioncomment-7016766).\n\n### [F-string formatting](#f-string-formatting)\n\nStabilized in Ruff 0.9.0\n\nUnlike Black, Ruff formats the expression parts of f-strings which are the parts inside the curly braces `{...}`. This is a [known deviation](black/#f-strings) from Black.\n\nRuff employs several heuristics to determine how an f-string should be formatted which are detailed below.\n\n#### [Quotes](#quotes)\n\nRuff will use the [configured quote style](../settings/#format_quote-style) for the f-string expression unless doing so would result in invalid syntax for the target Python version or requires more backslash escapes than the original expression. Specifically, Ruff will preserve the original quote style for the following cases:\n\nWhen the target Python version is < 3.12 and a [self-documenting f-string](https://realpython.com/python-f-strings/#self-documenting-expressions-for-debugging) contains a string literal with the [configured quote style](../settings/#format_quote-style):\n\n```\n#__codelineno-14-1# format.quote-style = \"double\"\n#__codelineno-14-2\n#__codelineno-14-3f'{10 + len(\"hello\")=}'\n#__codelineno-14-4# This f-string cannot be formatted as follows when targeting Python < 3.12\n#__codelineno-14-5f\"{10 + len(\"hello\")=}\"\n```\n\nWhen the target Python version is < 3.12 and an f-string contains any triple-quoted string, byte or f-string literal that contains the [configured quote style](../settings/#format_quote-style):\n\n```\n#__codelineno-15-1# format.quote-style = \"double\"\n#__codelineno-15-2\n#__codelineno-15-3f'{\"\"\"nested \" \"\"\"}'\n#__codelineno-15-4# This f-string cannot be formatted as follows when targeting Python < 3.12\n#__codelineno-15-5f\"{'''nested \" '''}\"\n```\n\nFor all target Python versions, when a [self-documenting f-string](https://realpython.com/python-f-strings/#self-documenting-expressions-for-debugging) contains an expression between the curly braces (`{...}`) with a format specifier containing the [configured quote style](../settings/#format_quote-style):\n\n```\n#__codelineno-16-1# format.quote-style = \"double\"\n#__codelineno-16-2\n#__codelineno-16-3f'{1=:\"foo}'\n#__codelineno-16-4# This f-string cannot be formatted as follows for all target Python versions\n#__codelineno-16-5f\"{1=:\"foo}\"\n```\n\nFor nested f-strings, Ruff alternates quote styles, starting with the [configured quote style](../settings/#format_quote-style) for the outermost f-string. For example, consider the following f-string:\n\n```\n#__codelineno-17-1# format.quote-style = \"double\"\n#__codelineno-17-2\n#__codelineno-17-3f\"outer f-string {f\"nested f-string {f\"another nested f-string\"} end\"} end\"\n```\n\nRuff formats it as:\n\n```\n#__codelineno-18-1f\"outer f-string {f'nested f-string {f\"another nested f-string\"} end'} end\"\n```\n\n#### [Line breaks](#line-breaks)\n\nStarting with Python 3.12 ([PEP 701](https://peps.python.org/pep-0701/)), the expression parts of an f-string can span multiple lines. Ruff needs to decide when to introduce a line break in an f-string expression. This depends on the semantic content of the expression parts of an f-string - for example, introducing a line break in the middle of a natural-language sentence is undesirable. Since Ruff doesn't have enough information to make that decision, it adopts a heuristic similar to [Prettier](https://prettier.io/docs/en/next/rationale.html#template-literals): it will only split the expression parts of an f-string across multiple lines if there was already a line break within any of the expression parts.\n\nFor example, the following code:\n\n```\n#__codelineno-19-1f\"this f-string has a multiline expression {\n#__codelineno-19-2  ['red', 'green', 'blue', 'yellow',]} and does not fit within the line length\"\n```\n\n... is formatted as:\n\n```\n#__codelineno-20-1# The list expression is split across multiple lines because of the trailing comma\n#__codelineno-20-2f\"this f-string has a multiline expression {\n#__codelineno-20-3    [\n#__codelineno-20-4        'red',\n#__codelineno-20-5        'green',\n#__codelineno-20-6        'blue',\n#__codelineno-20-7        'yellow',\n#__codelineno-20-8    ]\n#__codelineno-20-9} and does not fit within the line length\"\n```\n\nBut, the following will not be split across multiple lines even though it exceeds the line length:\n\n```\n#__codelineno-21-1f\"this f-string has a multiline expression {['red', 'green', 'blue', 'yellow']} and does not fit within the line length\"\n```\n\nIf you want Ruff to split an f-string across multiple lines, ensure there's a linebreak somewhere within the `{...}` parts of an f-string.\n\n#### [Fluent layout for method chains](#fluent-layout-for-method-chains)\n\nAt times, when developers write long chains of methods on an object, such as\n\n```\n#__codelineno-22-1x = df.filter(cond).agg(func).merge(other)\n```\n\nthe intent is to perform a sequence of transformations or operations on a fixed object of interest - in this example, the object `df`. Assuming the assigned expression exceeds the `line-length`, this preview style will format the above as:\n\n```\n#__codelineno-23-1x = (\n#__codelineno-23-2    df\n#__codelineno-23-3    .filter(cond)\n#__codelineno-23-4    .agg(func)\n#__codelineno-23-5    .merge(other)\n#__codelineno-23-6)\n```\n\nThis deviates from the stable formatting, and also from Black, both of which would produce:\n\n```\n#__codelineno-24-1x = (\n#__codelineno-24-2    df.filter(cond)\n#__codelineno-24-3    .agg(func)\n#__codelineno-24-4    .merge(other)\n#__codelineno-24-5)\n```\n\nBoth the stable and preview formatting are variants of something called a fluent layout.\n\nIn general, this preview style differs from the stable style only at the first attribute that precedes a call or subscript. The preview formatting breaks before this attribute, while the stable formatting breaks after the call or subscript.\n\n## [Sorting imports](#sorting-imports)\n\nCurrently, the Ruff formatter does not sort imports. In order to both sort imports and format, call the Ruff linter and then the formatter:\n\n```\n#__codelineno-25-1ruff check --select I --fix\n#__codelineno-25-2ruff format\n```\n\nA unified command for both linting and formatting is [planned](https://github.com/astral-sh/ruff/issues/8232).\n\n Back to top\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# Python Formatters\n\nPython formatting is typically handled by `black` (opinionated formatting) or `ruff format` (fast formatting with lint integration).\n\n## black\n- Opinionated, stable formatting with minimal configuration.\n\n## ruff format\n- Formatter backed by the Ruff toolchain, aligned with Ruff lint rules.\n"}, {"path": "formatters/black.md", "category": "formatters", "name": "formatters/black", "content": "# The basics[\u00b6](#the-basics)\nVersion: unknown\n\nSource: https://black.readthedocs.io/en/stable/usage_and_configuration/the_basics.html\n\n\nFoundational knowledge on using and configuring Black.\n\nBlack is a well-behaved Unix-style command-line tool:\n\n- \n\nit does nothing if it finds no sources to format;\n\n- \n\nit will read from standard input and write to standard output if `-` is used as the filename;\n\n- \n\nit only outputs messages to users on standard error;\n\n- \n\nexits with code 0 unless an internal error occurred or a CLI option prompted it.\n\n## Usage[\u00b6](#usage)\n\nBlack will reformat entire files in place. To get started right away with sensible defaults:\n\n```\nblack {source_file_or_directory}\n```\n\nYou can run Black as a package if running it as a script doesn\u2019t work:\n\n```\npython -m black {source_file_or_directory}\n```\n\n### Ignoring sections[\u00b6](#ignoring-sections)\n\nBlack will not reformat lines that contain `# fmt: skip` or blocks that start with `# fmt: off` and end with `# fmt: on`. `# fmt: skip` can be mixed with other pragmas/comments either with multiple comments (e.g. `# fmt: skip # pylint # noqa`) or as a semicolon separated list (e.g. `# fmt: skip; pylint; noqa`). `# fmt: on/off` must be on the same level of indentation and in the same block, meaning no unindents beyond the initial indentation level between them. Black also recognizes [YAPF](https://github.com/google/yapf)\u2019s block comments to the same effect, as a courtesy for straddling code.\n\n### Command line options[\u00b6](#command-line-options)\n\nThe CLI options of Black can be displayed by running `black --help`. All options are also covered in more detail below.\n\nWhile Black has quite a few knobs these days, it is still opinionated so style options are deliberately limited and rarely added.\n\nNote that all command-line options listed above can also be configured using a `pyproject.toml` file (more on that below).\n\n#### `-h`, `--help`[\u00b6](#h-help)\n\nShow available command-line options and exit.\n\n#### `-c`, `--code`[\u00b6](#c-code)\n\nFormat the code passed in as a string.\n\n```\n$ black --code \"print ( 'hello, world' )\"\nprint(\"hello, world\")\n```\n\n#### `-l`, `--line-length`[\u00b6](#l-line-length)\n\nHow many characters per line to allow. The default is 88.\n\nSee also [the style documentation](../the_black_code_style/current_style.html#labels-line-length).\n\n#### `-t`, `--target-version`[\u00b6](#t-target-version)\n\nPython versions that should be supported by Black\u2019s output. You can run `black --help` and look for the `--target-version` option to see the full list of supported versions. You should include all versions that your code supports. If you support Python 3.11 through 3.13, you should write:\n\n```\n$ black -t py311 -t py312 -t py313\n```\n\nIn a [configuration file](#configuration-via-a-file), you can write:\n\n```\ntarget-version = [\"py311\", \"py312\", \"py313\"]\n```\n\nBy default, Black will infer target versions from the project metadata in `pyproject.toml`, specifically the `[project.requires-python]` field. If this does not yield conclusive results, Black will use per-file auto-detection.\n\nBlack uses this option to decide what grammar to use to parse your code. In addition, it may use it to decide what style to use. For example, support for a trailing comma after `*args` in a function call was added in Python 3.5, so Black will add this comma only if the target versions are all Python 3.5 or higher:\n\n```\n$ black --line-length=10 --target-version=py35 -c 'f(a, *args)'\nf(\n    a,\n    *args,\n)\n$ black --line-length=10 --target-version=py34 -c 'f(a, *args)'\nf(\n    a,\n    *args\n)\n$ black --line-length=10 --target-version=py34 --target-version=py35 -c 'f(a, *args)'\nf(\n    a,\n    *args\n)\n```\n\n#### `--pyi`[\u00b6](#pyi)\n\nFormat all input files like typing stubs regardless of file extension. This is useful when piping source on standard input.\n\n#### `--ipynb`[\u00b6](#ipynb)\n\nFormat all input files like Jupyter Notebooks regardless of file extension. This is useful when piping source on standard input.\n\n#### `--python-cell-magics`[\u00b6](#python-cell-magics)\n\nWhen processing Jupyter Notebooks, add the given magic to the list of known python- magics. Useful for formatting cells with custom python magics.\n\n#### `-x, --skip-source-first-line`[\u00b6](#x-skip-source-first-line)\n\nSkip the first line of the source code.\n\n#### `-S, --skip-string-normalization`[\u00b6](#s-skip-string-normalization)\n\nBy default, Black uses double quotes for all strings and normalizes string prefixes, as described in [the style documentation](../the_black_code_style/current_style.html#labels-strings). If this option is given, strings are left unchanged instead.\n\n#### `-C, --skip-magic-trailing-comma`[\u00b6](#c-skip-magic-trailing-comma)\n\nBy default, Black uses existing trailing commas as an indication that short lines should be left separate, as described in [the style documentation](../the_black_code_style/current_style.html#labels-magic-trailing-comma). If this option is given, the magic trailing comma is ignored.\n\n#### `--preview`[\u00b6](#preview)\n\nEnable potentially disruptive style changes that we expect to add to Black\u2019s main functionality in the next major release. Use this if you want a taste of what next year\u2019s style will look like.\n\nRead more about [our preview style](../the_black_code_style/future_style.html#labels-preview-style).\n\nThere is no guarantee on the code style produced by this flag across releases.\n\n#### `--unstable`[\u00b6](#unstable)\n\nEnable all style changes in `--preview`, plus additional changes that we would like to make eventually, but that have known issues that need to be fixed before they can move back to the `--preview` style. Use this if you want to experiment with these changes and help fix issues with them.\n\nThere is no guarantee on the code style produced by this flag across releases.\n\n#### `--enable-unstable-feature`[\u00b6](#enable-unstable-feature)\n\nEnable specific features from the `--unstable` style. See [the preview style documentation](../the_black_code_style/future_style.html#labels-unstable-features) for the list of supported features. This flag can only be used when `--preview` is enabled. Users are encouraged to use this flag if they use `--preview` style and a feature that affects their code is moved from the `--preview` to the `--unstable` style, but they want to avoid the thrash from undoing this change.\n\nThere are no guarantees on the behavior of these features, or even their existence, across releases.\n\n#### `--check`[\u00b6](#check)\n\nDon\u2019t write the files back, just return the status. Black will exit with:\n\n- \n\ncode 0 if nothing would change;\n\n- \n\ncode 1 if some files would be reformatted; or\n\n- \n\ncode 123 if there was an internal error\n\nIf used in combination with `--quiet` then only the exit code will be returned, unless there was an internal error.\n\n```\n$ black test.py --check\nAll done! \u2728 \ud83c\udf70 \u2728\n1 file would be left unchanged.\n$ echo $?\n0\n\n$ black test.py --check\nwould reformat test.py\nOh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\n1 file would be reformatted.\n$ echo $?\n1\n\n$ black test.py --check\nerror: cannot format test.py: INTERNAL ERROR: Black produced code that is not equivalent to the source.  Please report a bug on https://github.com/psf/black/issues.  This diff might be helpful: /tmp/blk_kjdr1oog.log\nOh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\n1 file would fail to reformat.\n$ echo $?\n123\n```\n\n#### `--diff`[\u00b6](#diff)\n\nDon\u2019t write the files back, just output a diff to indicate what changes Black would\u2019ve made. They are printed to stdout so capturing them is simple.\n\nIf you\u2019d like colored diffs, you can enable them with `--color`.\n\n```\n$ black test.py --diff\n--- test.py     2021-03-08 22:23:40.848954+00:00\n+++ test.py     2021-03-08 22:23:47.126319+00:00\n@@ -1 +1 @@\n-print ( 'hello, world' )\n+print(\"hello, world\")\nwould reformat test.py\nAll done! \u2728 \ud83c\udf70 \u2728\n1 file would be reformatted.\n```\n\n#### `--no-cache`[\u00b6](#no-cache)\n\nDo not consult or update Black\u2019s per-user cache during this run. When `--no-cache` is specified, Black will perform fresh analysis for all files and will neither read from nor write to the cache. This is helpful for reproducing formatting results from a clean run, debugging cache-related issues, or ensuring CI executes a fresh formatting analysis every time.\n\n#### `--color` / `--no-color`[\u00b6](#color-no-color)\n\nShow (or do not show) colored diff. Only applies when `--diff` is given.\n\n#### `--line-ranges`[\u00b6](#line-ranges)\n\nWhen specified, Black will try its best to only format these lines.\n\nThis option can be specified multiple times, and a union of the lines will be formatted. Each range must be specified as two integers connected by a `-`: `<START>-<END>`. The `<START>` and `<END>` integer indices are 1-based and inclusive on both ends.\n\nBlack may still format lines outside of the ranges for multi-line statements. Formatting more than one file or any ipynb files with this option is not supported. This option cannot be specified in the `pyproject.toml` config.\n\nExample: `black --line-ranges=1-10 --line-ranges=21-30 test.py` will format lines from `1` to `10` and `21` to `30`.\n\nThis option is mainly for editor integrations, such as \u201cFormat Selection\u201d.\n\nNote\n\nDue to [#4052](https://github.com/psf/black/issues/4052), `--line-ranges` might format extra lines outside of the ranges when there are unformatted lines with the exact formatted content next to the requested lines. It also disables Black\u2019s formatting stability check in `--safe` mode.\n\n#### `--fast` / `--safe`[\u00b6](#fast-safe)\n\nBy default, Black performs [an AST safety check](../the_black_code_style/current_style.html#labels-ast-changes) after formatting your code. The `--fast` flag turns off this check and the `--safe` flag explicitly enables it.\n\n#### `--required-version`[\u00b6](#required-version)\n\nRequire a specific version of Black to be running. This is useful for ensuring that all contributors to your project are using the same version, because different versions of Black may format code a little differently. This option can be set in a configuration file for consistent results across environments.\n\n```\n$ black --version\nblack, 25.12.0 (compiled: yes)\n$ black --required-version 25.12.0 -c \"format = 'this'\"\nformat = \"this\"\n$ black --required-version 31.5b2 -c \"still = 'beta?!'\"\nOh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5 The required version does not match the running version!\n```\n\nYou can also pass just the major version:\n\n```\n$ black --required-version 22 -c \"format = 'this'\"\nformat = \"this\"\n$ black --required-version 31 -c \"still = 'beta?!'\"\nOh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5 The required version does not match the running version!\n```\n\nBecause of our [stability policy](../the_black_code_style/index.html), this will guarantee stable formatting, but still allow you to take advantage of improvements that do not affect formatting.\n\n#### `--exclude`[\u00b6](#exclude)\n\nA regular expression that matches files and directories that should be excluded on recursive searches. An empty value means no paths are excluded. Use forward slashes for directories on all platforms (Windows, too). By default, Black also ignores all paths listed in `.gitignore`. Changing this value will override all default exclusions.\n\nDefault Exclusions: `['.direnv', '.eggs', '.git', '.hg', '.ipynb_checkpoints',\u00a0 '.mypy_cache', '.nox', '.pytest_cache', '.ruff_cache', '.tox', '.svn', '.venv', '.vscode',\u00a0 '__pypackages__', '_build', 'buck-out', 'build', 'dist', 'venv']`\n\nIf the regular expression contains newlines, it is treated as a [verbose regular expression](https://docs.python.org/3/library/re.html#re.VERBOSE). This is typically useful when setting these options in a `pyproject.toml` configuration file; see [Configuration format](#configuration-format) for more information.\n\n#### `--extend-exclude`[\u00b6](#extend-exclude)\n\nLike `--exclude`, but adds additional files and directories on top of the default values instead of overriding them.\n\n#### `--force-exclude`[\u00b6](#force-exclude)\n\nLike `--exclude`, but files and directories matching this regex will be excluded even when they are passed explicitly as arguments. This is useful when invoking Black programmatically on changed files, such as in a pre-commit hook or editor plugin.\n\n#### `--stdin-filename`[\u00b6](#stdin-filename)\n\nThe name of the file when passing it through stdin. Useful to make sure Black will respect the `--force-exclude` option on some editors that rely on using stdin.\n\n#### `--include`[\u00b6](#include)\n\nA regular expression that matches files and directories that should be included on recursive searches. An empty value means all files are included regardless of the name. Use forward slashes for directories on all platforms (Windows, too). Overrides all exclusions, including from `.gitignore` and command line options.\n\nDefault Inclusions: `['.pyi', '.ipynb']`\n\n#### `-W`, `--workers`[\u00b6](#w-workers)\n\nWhen Black formats multiple files, it may use a process pool to speed up formatting. This option controls the number of parallel workers. This can also be specified via the `BLACK_NUM_WORKERS` environment variable. Defaults to the number of CPUs in the system.\n\n#### `-q`, `--quiet`[\u00b6](#q-quiet)\n\nStop emitting all non-critical output. Error messages will still be emitted (which can silenced by `2>/dev/null`).\n\n```\n$ black src/ -q\nerror: cannot format src/black_primer/cli.py: Cannot parse: 5:6: mport asyncio\n```\n\n#### `-v`, `--verbose`[\u00b6](#v-verbose)\n\nEmit messages about files that were not changed or were ignored due to exclusion patterns. If Black is using a configuration file, a message detailing which one it is using will be emitted.\n\n```\n$ black src/ -v\nUsing configuration from /tmp/pyproject.toml.\nsrc/blib2to3 ignored: matches the --extend-exclude regular expression\nsrc/_black_version.py wasn't modified on disk since last run.\nsrc/black/__main__.py wasn't modified on disk since last run.\nerror: cannot format src/black_primer/cli.py: Cannot parse: 5:6: mport asyncio\nreformatted src/black_primer/lib.py\nreformatted src/blackd/__init__.py\nreformatted src/black/__init__.py\nOh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\n3 files reformatted, 2 files left unchanged, 1 file failed to reformat\n```\n\n#### `--version`[\u00b6](#version)\n\nYou can check the version of Black you have installed using the `--version` flag.\n\n```\n$ black --version\nblack, 25.12.0\n```\n\n#### `--config`[\u00b6](#config)\n\nRead configuration options from a configuration file. See [below](#configuration-via-a-file) for more details on the configuration file.\n\n### Environment variable options[\u00b6](#environment-variable-options)\n\nBlack supports the following configuration via environment variables.\n\n#### `BLACK_CACHE_DIR`[\u00b6](#black-cache-dir)\n\nThe directory where Black should store its cache.\n\n#### `BLACK_NUM_WORKERS`[\u00b6](#black-num-workers)\n\nThe number of parallel workers Black should use. The command line option `-W` / `--workers` takes precedence over this environment variable.\n\n### Code input alternatives[\u00b6](#code-input-alternatives)\n\nBlack supports formatting code via stdin, with the result being printed to stdout. Just let Black know with `-` as the path.\n\n```\n$ echo \"print ( 'hello, world' )\" | black -\nprint(\"hello, world\")\nreformatted -\nAll done! \u2728 \ud83c\udf70 \u2728\n1 file reformatted.\n```\n\nTip: if you need Black to treat stdin input as a file passed directly via the CLI, use `--stdin-filename`. Useful to make sure Black will respect the `--force-exclude` option on some editors that rely on using stdin.\n\nYou can also pass code as a string using the `--code` option.\n\n### Writeback and reporting[\u00b6](#writeback-and-reporting)\n\nBy default Black reformats the files given and/or found in place. Sometimes you need Black to just tell you what it would do without actually rewriting the Python files.\n\nThere\u2019s two variations to this mode that are independently enabled by their respective flags:\n\n- \n\n`--check` (exit with code 1 if any file would be reformatted)\n\n- \n\n`--diff` (print a diff instead of reformatting files)\n\nBoth variations can be enabled at once.\n\n### Output verbosity[\u00b6](#output-verbosity)\n\nBlack in general tries to produce the right amount of output, balancing between usefulness and conciseness. By default, Black emits files modified and error messages, plus a short summary.\n\n```\n$ black src/\nerror: cannot format src/black_primer/cli.py: Cannot parse: 5:6: mport asyncio\nreformatted src/black_primer/lib.py\nreformatted src/blackd/__init__.py\nreformatted src/black/__init__.py\nOh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\n3 files reformatted, 2 files left unchanged, 1 file failed to reformat.\n```\n\nThe `--quiet` and `--verbose` flags control output verbosity.\n\n## Configuration via a file[\u00b6](#configuration-via-a-file)\n\nBlack is able to read project-specific default values for its command line options from a `pyproject.toml` file. This is especially useful for specifying custom `--include` and `--exclude`/`--force-exclude`/`--extend-exclude` patterns for your project.\n\nPro-tip: If you\u2019re asking yourself \u201cDo I need to configure anything?\u201d the answer is \u201cNo\u201d. Black is all about sensible defaults. Applying those defaults will have your code in compliance with many other Black formatted projects.\n\n### What on Earth is a `pyproject.toml` file?[\u00b6](#what-on-earth-is-a-pyproject-toml-file)\n\n[PEP 518](https://www.python.org/dev/peps/pep-0518/) defines `pyproject.toml` as a configuration file to store build system requirements for Python projects. With the help of tools like [Poetry](https://python-poetry.org/), [Flit](https://flit.readthedocs.io/en/latest/), or [Hatch](https://hatch.pypa.io/latest/) it can fully replace the need for `setup.py` and `setup.cfg` files.\n\n### Where Black looks for the file[\u00b6](#where-black-looks-for-the-file)\n\nBy default Black looks for `pyproject.toml` containing a `[tool.black]` section starting from the common base directory of all files and directories passed on the command line. If it\u2019s not there, it looks in parent directories. It stops looking when it finds the file, or a `.git` directory, or a `.hg` directory, or the root of the file system, whichever comes first.\n\nIf you\u2019re formatting standard input, Black will look for configuration starting from the current working directory.\n\nYou can use a \u201cglobal\u201d configuration, stored in a specific location in your home directory. This will be used as a fallback configuration, that is, it will be used if and only if Black doesn\u2019t find any configuration as mentioned above. Depending on your operating system, this configuration file should be stored as:\n\n- \n\nWindows: `~\\.black`\n\n- \n\nUnix-like (Linux, MacOS, etc.): `$XDG_CONFIG_HOME/black` (`~/.config/black` if the `XDG_CONFIG_HOME` environment variable is not set)\n\nNote that these are paths to the TOML file itself (meaning that they shouldn\u2019t be named as `pyproject.toml`), not directories where you store the configuration (i.e., `black`/`.black` is the file to create and add your configuration options to, in the `~/.config/` directory). Here, `~` refers to the path to your home directory. On Windows, this will be something like `C:\\\\Users\\UserName`.\n\nYou can also explicitly specify the path to a particular file that you want with `--config`. In this situation Black will not look for any other file.\n\nIf you\u2019re running with `--verbose`, you will see a message if a file was found and used.\n\nPlease note `blackd` will not use `pyproject.toml` configuration.\n\n### Configuration format[\u00b6](#configuration-format)\n\nAs the file extension suggests, `pyproject.toml` is a [TOML](https://github.com/toml-lang/toml) file. It contains separate sections for different tools. Black is using the `[tool.black]` section. The option keys are the same as long names of options on the command line.\n\nNote that you have to use single-quoted strings in TOML for regular expressions. It\u2019s the equivalent of r-strings in Python. Multiline strings are treated as verbose regular expressions by Black. Use `[ ]` to denote a significant space character.\n\nExample `pyproject.toml`\n\n```\n[tool.black]\nline-length = 88\ntarget-version = ['py37']\ninclude = '\\.pyi?$'\n# 'extend-exclude' excludes files or directories in addition to the defaults\nextend-exclude = '''\n# A regex preceded with ^/ will apply only to files and directories\n# in the root of the project.\n(\n  ^/foo.py    # exclude a file named foo.py in the root of the project\n  | .*_pb2.py  # exclude autogenerated Protocol Buffer files anywhere in the project\n)\n'''\n```\n\n### Lookup hierarchy[\u00b6](#lookup-hierarchy)\n\nCommand-line options have defaults that you can see in `--help`. A `pyproject.toml` can override those defaults. Finally, options provided by the user on the command line override both.\n\nBlack will only ever use one `pyproject.toml` file during an entire run. It doesn\u2019t look for multiple files, and doesn\u2019t compose configuration from different levels of the file hierarchy.\n\n## Next steps[\u00b6](#next-steps)\n\nA good next step would be configuring auto-discovery so `black .` is all you need instead of laborously listing every file or directory. You can get started by heading over to [File collection and discovery](file_collection_and_discovery.html).\n\nAnother good choice would be setting up an [integration with your editor](../integrations/editors.html) of choice or with [pre-commit for source version control](../integrations/source_version_control.html).\n"}, {"path": "stdlib/overview.md", "category": "stdlib", "name": "stdlib/overview", "content": "# Python Standard Library Quick Reference\n\n## Essential Modules\n\n| Module | Purpose |\n|--------|---------|\n| `pathlib` | File paths (use over os.path) |\n| `json` | JSON encoding/decoding |\n| `dataclasses` | Data containers |\n| `typing` | Type hints |\n| `collections` | Specialized containers |\n| `itertools` | Iterator utilities |\n| `functools` | Higher-order functions |\n| `contextlib` | Context manager utilities |\n| `asyncio` | Async I/O |\n| `logging` | Logging facility |\n| `re` | Regular expressions |\n| `datetime` | Date and time |\n| `enum` | Enumerations |\n| `abc` | Abstract base classes |\n\n## Type Hints (typing module)\n\n```python\nfrom typing import Any, TypeVar, Generic\nfrom collections.abc import Callable, Iterator, Mapping\n\n# Basic\nx: int = 1\ny: str | None = None\nz: list[int] = [1, 2, 3]\n\n# Callable\nHandler = Callable[[Request], Response]\n\n# Generic\nT = TypeVar(\"T\")\n\nclass Stack(Generic[T]):\n    def push(self, item: T) -> None: ...\n    def pop(self) -> T: ...\n```\n\n## Collections\n\n```python\nfrom collections import defaultdict, Counter, deque, namedtuple\n\n# defaultdict - auto-initialize missing keys\ncounts = defaultdict(int)\ncounts[\"a\"] += 1\n\n# Counter - count occurrences\nc = Counter(\"abracadabra\")\nc.most_common(3)  # [('a', 5), ('b', 2), ('r', 2)]\n\n# deque - efficient double-ended queue\nd = deque(maxlen=3)\nd.append(1)\nd.appendleft(0)\n\n# namedtuple (prefer dataclass for new code)\nPoint = namedtuple(\"Point\", [\"x\", \"y\"])\n```\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# Python 3.14 Language Specification\nVersion: unknown\n\nSource: https://docs.python.org/3.14/\n\n\n## Keywords\n\n```python\nFalse       await       else        import      pass\nNone        break       except      in          raise\nTrue        class       finally     is          return\nand         continue    for         lambda      try\nas          def         from        nonlocal    while\nassert      del         global      not         with\nasync       elif        if          or          yield\nmatch       case        type        _\n```\n\n## Basic Types\n\n### Numeric Types\n\n```python\nint         # arbitrary precision integer\nfloat       # IEEE 754 double precision\ncomplex     # complex number (3+4j)\nbool        # True or False (subclass of int)\n```\n\n### Sequence Types\n\n```python\nstr         # immutable text sequence\nbytes       # immutable byte sequence\nbytearray   # mutable byte sequence\nlist        # mutable sequence\ntuple       # immutable sequence\nrange       # immutable sequence of numbers\n```\n\n### Set Types\n\n```python\nset         # mutable unordered collection of unique items\nfrozenset   # immutable set\n```\n\n### Mapping Types\n\n```python\ndict        # mutable key-value mapping\n```\n\n### None Type\n\n```python\nNone        # singleton null value\n```\n\n## Type Annotations (PEP 484, 604)\n\n### Basic Annotations\n\n```python\nx: int = 1\nname: str = \"hello\"\nvalues: list[int] = [1, 2, 3]\nmapping: dict[str, int] = {\"a\": 1}\n```\n\n### Optional and Union (3.10+)\n\n```python\n# Old style\nfrom typing import Optional, Union\nx: Optional[int] = None\ny: Union[int, str] = 1\n\n# New style (3.10+)\nx: int | None = None\ny: int | str = 1\n```\n\n### Callable\n\n```python\nfrom collections.abc import Callable\n\nHandler = Callable[[int, str], bool]\n\ndef process(handler: Handler) -> None:\n    result = handler(1, \"hello\")\n```\n\n### Generic Types\n\n```python\nfrom typing import TypeVar, Generic\n\nT = TypeVar(\"T\")\n\nclass Stack(Generic[T]):\n    def __init__(self) -> None:\n        self._items: list[T] = []\n    \n    def push(self, item: T) -> None:\n        self._items.append(item)\n    \n    def pop(self) -> T:\n        return self._items.pop()\n```\n\n### Type Alias (3.12+)\n\n```python\n# Old style\nIntList = list[int]\n\n# New style (3.12+)\ntype IntList = list[int]\ntype Point = tuple[int, int]\n```\n\n## Functions\n\n### Basic Functions\n\n```python\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\n# Default arguments\ndef greet(name: str = \"World\") -> str:\n    return f\"Hello, {name}!\"\n\n# *args and **kwargs\ndef log(*args: object, **kwargs: object) -> None:\n    print(*args, **kwargs)\n```\n\n### Lambda\n\n```python\nsquare = lambda x: x ** 2\nadd = lambda a, b: a + b\n```\n\n### Decorators\n\n```python\nfrom functools import wraps\n\ndef logged(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__}\")\n        return func(*args, **kwargs)\n    return wrapper\n\n@logged\ndef process(data: str) -> None:\n    pass\n```\n\n### Generators\n\n```python\ndef countdown(n: int):\n    while n > 0:\n        yield n\n        n -= 1\n\n# Generator expression\nsquares = (x ** 2 for x in range(10))\n```\n\n## Classes\n\n### Basic Class\n\n```python\nclass Point:\n    def __init__(self, x: int, y: int) -> None:\n        self.x = x\n        self.y = y\n    \n    def distance(self, other: \"Point\") -> float:\n        return ((self.x - other.x) ** 2 + (self.y - other.y) ** 2) ** 0.5\n    \n    def __repr__(self) -> str:\n        return f\"Point({self.x}, {self.y})\"\n```\n\n### Dataclasses\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: int\n    y: int\n    \n@dataclass(frozen=True)\nclass ImmutablePoint:\n    x: int\n    y: int\n\n@dataclass\nclass Config:\n    host: str = \"localhost\"\n    port: int = 8080\n    debug: bool = False\n```\n\n### Inheritance\n\n```python\nclass Animal:\n    def speak(self) -> str:\n        raise NotImplementedError\n\nclass Dog(Animal):\n    def speak(self) -> str:\n        return \"Woof!\"\n\n# Multiple inheritance\nclass Flying:\n    def fly(self) -> None:\n        pass\n\nclass Bird(Animal, Flying):\n    def speak(self) -> str:\n        return \"Chirp!\"\n```\n\n### Properties\n\n```python\nclass Circle:\n    def __init__(self, radius: float) -> None:\n        self._radius = radius\n    \n    @property\n    def radius(self) -> float:\n        return self._radius\n    \n    @radius.setter\n    def radius(self, value: float) -> None:\n        if value < 0:\n            raise ValueError(\"Radius must be positive\")\n        self._radius = value\n    \n    @property\n    def area(self) -> float:\n        return 3.14159 * self._radius ** 2\n```\n\n### Class Methods and Static Methods\n\n```python\nclass Date:\n    def __init__(self, year: int, month: int, day: int) -> None:\n        self.year = year\n        self.month = month\n        self.day = day\n    \n    @classmethod\n    def from_string(cls, date_string: str) -> \"Date\":\n        year, month, day = map(int, date_string.split(\"-\"))\n        return cls(year, month, day)\n    \n    @staticmethod\n    def is_valid(year: int, month: int, day: int) -> bool:\n        return 1 <= month <= 12 and 1 <= day <= 31\n```\n\n## Control Flow\n\n### Match Statement (3.10+)\n\n```python\nmatch command:\n    case \"quit\":\n        return\n    case \"help\":\n        show_help()\n    case [\"move\", direction]:\n        move(direction)\n    case {\"action\": action, \"target\": target}:\n        perform(action, target)\n    case _:\n        print(\"Unknown command\")\n\n# With guards\nmatch point:\n    case Point(x, y) if x == y:\n        print(\"On diagonal\")\n    case Point(x, y):\n        print(f\"At ({x}, {y})\")\n```\n\n### Exception Handling\n\n```python\ntry:\n    result = risky_operation()\nexcept ValueError as e:\n    handle_value_error(e)\nexcept (TypeError, KeyError) as e:\n    handle_other(e)\nexcept Exception as e:\n    logger.exception(\"Unexpected error\")\n    raise\nelse:\n    # Only runs if no exception\n    process(result)\nfinally:\n    # Always runs\n    cleanup()\n```\n\n### Exception Groups (3.11+)\n\n```python\ntry:\n    async with asyncio.TaskGroup() as tg:\n        tg.create_task(task1())\n        tg.create_task(task2())\nexcept* ValueError as eg:\n    for exc in eg.exceptions:\n        handle(exc)\nexcept* TypeError as eg:\n    for exc in eg.exceptions:\n        handle(exc)\n```\n\n## Context Managers\n\n```python\n# Using with statement\nwith open(\"file.txt\") as f:\n    content = f.read()\n\n# Multiple context managers\nwith (\n    open(\"input.txt\") as infile,\n    open(\"output.txt\", \"w\") as outfile,\n):\n    outfile.write(infile.read())\n\n# Custom context manager (class)\nclass Timer:\n    def __enter__(self):\n        self.start = time.time()\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.elapsed = time.time() - self.start\n        return False  # Don't suppress exceptions\n\n# Custom context manager (decorator)\nfrom contextlib import contextmanager\n\n@contextmanager\ndef timer():\n    start = time.time()\n    yield\n    print(f\"Elapsed: {time.time() - start:.2f}s\")\n```\n\n## Async/Await\n\n```python\nimport asyncio\n\nasync def fetch(url: str) -> str:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            return await response.text()\n\nasync def main() -> None:\n    # Concurrent execution\n    results = await asyncio.gather(\n        fetch(\"https://example.com/1\"),\n        fetch(\"https://example.com/2\"),\n        fetch(\"https://example.com/3\"),\n    )\n    \n    # Task groups (3.11+)\n    async with asyncio.TaskGroup() as tg:\n        task1 = tg.create_task(fetch(url1))\n        task2 = tg.create_task(fetch(url2))\n    # All tasks complete here\n\nasyncio.run(main())\n```\n\n### Async Generators\n\n```python\nasync def countdown(n: int):\n    while n > 0:\n        yield n\n        await asyncio.sleep(1)\n        n -= 1\n\nasync def main():\n    async for i in countdown(5):\n        print(i)\n```\n\n## Comprehensions\n\n```python\n# List comprehension\nsquares = [x ** 2 for x in range(10)]\nevens = [x for x in range(20) if x % 2 == 0]\n\n# Dict comprehension\nword_lengths = {word: len(word) for word in words}\n\n# Set comprehension\nunique_lengths = {len(word) for word in words}\n\n# Generator expression\nsum_squares = sum(x ** 2 for x in range(10))\n\n# Nested comprehension\nmatrix = [[i * j for j in range(5)] for i in range(5)]\n```\n\n## Walrus Operator (3.8+)\n\n```python\n# Assignment expression\nif (n := len(data)) > 10:\n    print(f\"Too long: {n}\")\n\n# In loops\nwhile (line := file.readline()):\n    process(line)\n\n# In comprehensions\nresults = [y for x in data if (y := transform(x)) is not None]\n```\n\n## F-Strings\n\n```python\nname = \"Alice\"\nage = 30\n\n# Basic\nprint(f\"Hello, {name}!\")\n\n# Expressions\nprint(f\"Next year: {age + 1}\")\n\n# Formatting\nprint(f\"Value: {value:.2f}\")\nprint(f\"Hex: {num:#x}\")\nprint(f\"Padded: {name:>10}\")\n\n# Debug (3.8+)\nprint(f\"{name=}\")  # prints: name='Alice'\nprint(f\"{age=}\")   # prints: age=30\n```\n\n## Structural Pattern Matching (3.10+)\n\n```python\n# Literal patterns\nmatch status:\n    case 200:\n        return \"OK\"\n    case 404:\n        return \"Not Found\"\n    case 500:\n        return \"Server Error\"\n\n# Class patterns\nmatch event:\n    case Click(x=x, y=y):\n        handle_click(x, y)\n    case KeyPress(key=\"q\"):\n        quit()\n\n# Sequence patterns\nmatch command:\n    case [\"move\", *directions]:\n        for d in directions:\n            move(d)\n    case [\"quit\"]:\n        return\n\n# Mapping patterns\nmatch config:\n    case {\"debug\": True, **rest}:\n        enable_debug(rest)\n    case {\"host\": host, \"port\": port}:\n        connect(host, port)\n\n# Guard patterns\nmatch point:\n    case Point(x, y) if x == y:\n        print(\"On diagonal\")\n```\n"}, {"path": "linters/ruff/pyupgrade.md", "category": "linters", "name": "linters/ruff/pyupgrade", "content": "# Ruff - pyupgrade Rules (UP)\n\nModernize Python code to newer syntax.\n\n## UP001: Remove __metaclass__ = type\n\n```python\n# BAD (Python 2)\nclass Foo:\n    __metaclass__ = type\n\n# GOOD (Python 3)\nclass Foo:\n    pass\n```\n\n## UP003: Use type(...) instead of type(...)\n\n```python\n# BAD\ntype(\"Foo\", (object,), {})\n\n# GOOD (if dynamic class needed)\ntype(\"Foo\", (), {})\n```\n\n## UP004: Remove useless object inheritance\n\n```python\n# BAD\nclass Foo(object):\n    pass\n\n# GOOD\nclass Foo:\n    pass\n```\n\n## UP005: Replace deprecated unittest aliases\n\n```python\n# BAD\nself.assertEquals(a, b)\nself.assertNotEquals(a, b)\n\n# GOOD\nself.assertEqual(a, b)\nself.assertNotEqual(a, b)\n```\n\n## UP006: Use type instead of Type for builtin\n\n```python\n# BAD (Python 3.9+)\nfrom typing import List, Dict, Tuple\n\ndef foo(x: List[int]) -> Dict[str, int]:\n    pass\n\n# GOOD\ndef foo(x: list[int]) -> dict[str, int]:\n    pass\n```\n\n## UP007: Use X | Y instead of Union\n\n```python\n# BAD (Python 3.10+)\nfrom typing import Union, Optional\n\ndef foo(x: Union[int, str]) -> Optional[str]:\n    pass\n\n# GOOD\ndef foo(x: int | str) -> str | None:\n    pass\n```\n\n## UP008: Use super() without arguments\n\n```python\n# BAD\nclass Foo(Bar):\n    def __init__(self):\n        super(Foo, self).__init__()\n\n# GOOD\nclass Foo(Bar):\n    def __init__(self):\n        super().__init__()\n```\n\n## UP009: UTF-8 encoding declaration is unnecessary\n\n```python\n# BAD (Python 3 default is UTF-8)\n# -*- coding: utf-8 -*-\n\n# GOOD - remove it\n```\n\n## UP010: Remove unnecessary __future__ imports\n\n```python\n# BAD (Python 3)\nfrom __future__ import print_function\nfrom __future__ import division\n\n# GOOD - remove them (already default in Python 3)\n```\n\n## UP011: Remove unnecessary parentheses in class definition\n\n```python\n# BAD\nclass Foo():\n    pass\n\n# GOOD\nclass Foo:\n    pass\n```\n\n## UP012: Use f-string instead of format\n\n```python\n# BAD\n\"Hello {}\".format(name)\n\"Hello {name}\".format(name=name)\n\n# GOOD\nf\"Hello {name}\"\n```\n\n## UP013: Use TypedDict class syntax\n\n```python\n# BAD\nMyDict = TypedDict(\"MyDict\", {\"a\": int, \"b\": str})\n\n# GOOD\nclass MyDict(TypedDict):\n    a: int\n    b: str\n```\n\n## UP014: Use NamedTuple class syntax\n\n```python\n# BAD\nPoint = namedtuple(\"Point\", [\"x\", \"y\"])\n\n# GOOD\nclass Point(NamedTuple):\n    x: int\n    y: int\n```\n\n## UP015: Remove redundant open mode\n\n```python\n# BAD\nopen(\"file\", \"r\")\nopen(\"file\", mode=\"r\")\n\n# GOOD\nopen(\"file\")\n```\n\n## UP017: Use datetime.UTC\n\n```python\n# BAD (Python 3.11+)\nimport datetime\ndatetime.timezone.utc\n\n# GOOD\nimport datetime\ndatetime.UTC\n```\n\n## UP018: Remove native literal\n\n```python\n# BAD\nstr(\"hello\")\nint(42)\nfloat(3.14)\nbool(True)\n\n# GOOD\n\"hello\"\n42\n3.14\nTrue\n```\n\n## UP024: Replace aliased error with original\n\n```python\n# BAD\ntry:\n    pass\nexcept IOError:  # alias for OSError\n    pass\n\n# GOOD\ntry:\n    pass\nexcept OSError:\n    pass\n```\n\n## UP025: Remove unicode literal prefix\n\n```python\n# BAD (Python 3)\nu\"hello\"\nu'world'\n\n# GOOD\n\"hello\"\n\"world\"\n```\n\n## UP026: Replace deprecated mock imports\n\n```python\n# BAD\nfrom mock import Mock\n\n# GOOD\nfrom unittest.mock import Mock\n```\n\n## UP027: Unpack list comprehension\n\n```python\n# BAD\n[*[x for x in items]]\n\n# GOOD\n[x for x in items]\n```\n\n## UP028: Use yield from\n\n```python\n# BAD\nfor item in iterable:\n    yield item\n\n# GOOD\nyield from iterable\n```\n\n## UP029: Remove unnecessary default encoding\n\n```python\n# BAD\n\"hello\".encode(\"utf-8\")\nb\"hello\".decode(\"utf-8\")\n\n# GOOD\n\"hello\".encode()\nb\"hello\".decode()\n```\n\n## UP030: Use implicit format spec\n\n```python\n# BAD\n\"{0}\".format(value)\n\"{0:}\".format(value)\n\n# GOOD\n\"{}\".format(value)\nf\"{value}\"\n```\n\n## UP031: Use f-string instead of % formatting\n\n```python\n# BAD\n\"Hello %s\" % name\n\"Hello %(name)s\" % {\"name\": name}\n\n# GOOD\nf\"Hello {name}\"\n```\n\n## UP032: Use f-string instead of .format\n\n```python\n# BAD\n\"Hello {}\".format(name)\n\n# GOOD\nf\"Hello {name}\"\n```\n\n## UP033: Use @functools.cache\n\n```python\n# BAD (Python 3.9+)\n@functools.lru_cache(maxsize=None)\ndef expensive():\n    pass\n\n# GOOD\n@functools.cache\ndef expensive():\n    pass\n```\n\n## UP034: Use exponentiation operator\n\n```python\n# BAD\npow(2, 3)\n\n# GOOD\n2 ** 3\n```\n\n## UP035: Deprecated imports\n\n```python\n# BAD (Python 3.9+)\nfrom typing import List, Dict, Tuple, Set\n\n# GOOD - use builtins\nlist, dict, tuple, set\n\n# BAD (Python 3.9+)\nfrom typing import Callable, Iterable\n\n# GOOD\nfrom collections.abc import Callable, Iterable\n```\n\n## UP036: Remove version block for old Python\n\n```python\n# BAD\nimport sys\nif sys.version_info >= (3, 0):\n    pass  # we're on Python 3 anyway\n\n# GOOD - remove version check\n```\n\n## UP037: Remove quotes from type annotation\n\n```python\n# BAD (with __future__ annotations)\ndef foo() -> \"int\":\n    pass\n\n# GOOD\ndef foo() -> int:\n    pass\n```\n\n## UP038: Use X | Y in isinstance\n\n```python\n# BAD (Python 3.10+)\nisinstance(x, (int, str))\n\n# GOOD\nisinstance(x, int | str)\n```\n\n## UP039: Unnecessary parentheses after class\n\n```python\n# BAD\nclass Foo(A, B,):\n\n# GOOD\nclass Foo(A, B):\n```\n\n## UP040: Use TypeAlias for type aliases\n\n```python\n# BAD (Python 3.10+)\nIntList = list[int]\n\n# GOOD\nIntList: TypeAlias = list[int]\n\n# BETTER (Python 3.12+)\ntype IntList = list[int]\n```\n\n## UP041: Replace timeout classes\n\n```python\n# BAD (Python 3.11+)\nasyncio.TimeoutError\n\n# GOOD\nTimeoutError\n```\n\n## UP043: Use root logging methods\n\n```python\n# BAD\nlogging.getLogger().warning(\"message\")\n\n# GOOD\nlogging.warning(\"message\")\n```\n"}, {"path": "linters/ruff/overview.md", "category": "linters", "name": "linters/ruff/overview", "content": "# Ruff Linter Rules\nVersion: unknown\n\nSource: https://docs.astral.sh/ruff/rules/\n\n\nRuff implements rules from:\n- Pyflakes (F)\n- pycodestyle (E, W)\n- isort (I)\n- pep8-naming (N)\n- pyupgrade (UP)\n- flake8-* plugins\n- pylint (PL)\n- ruff-specific (RUF)\n\n## Essential Rules\n\n| Code | Rule | Fix |\n|------|------|-----|\n| F401 | Unused import | Remove |\n| F841 | Unused variable | Remove or prefix with _ |\n| E501 | Line too long | Break line |\n| E711 | Comparison to None | Use `is None` |\n| E712 | Comparison to True/False | Use truthiness |\n| UP006 | Use `list` instead of `List` | Modernize |\n| UP007 | Use `X | Y` instead of `Union` | Modernize |\n\n## Configuration\n\n```toml\n# pyproject.toml\n[tool.ruff]\nline-length = 100\ntarget-version = \"py312\"\n\n[tool.ruff.lint]\nselect = [\n    \"E\",   # pycodestyle errors\n    \"W\",   # pycodestyle warnings\n    \"F\",   # pyflakes\n    \"I\",   # isort\n    \"UP\",  # pyupgrade\n    \"N\",   # pep8-naming\n    \"RUF\", # ruff-specific\n]\nignore = [\"E501\"]  # if you want longer lines\n```\n"}, {"path": "linters/ruff/pyflakes-pycodestyle.md", "category": "linters", "name": "linters/ruff/pyflakes-pycodestyle", "content": "# Ruff Linter - Complete Reference\n\nRuff is an extremely fast Python linter written in Rust. Implements 800+ rules from:\n- Pyflakes (F)\n- pycodestyle (E, W)\n- isort (I)\n- pep8-naming (N)\n- pyupgrade (UP)\n- flake8-bugbear (B)\n- flake8-comprehensions (C4)\n- flake8-simplify (SIM)\n- pylint (PL)\n- ruff-specific (RUF)\n\n## Configuration\n\n```toml\n# pyproject.toml\n[tool.ruff]\ntarget-version = \"py312\"\nline-length = 100\n\n[tool.ruff.lint]\nselect = [\n    \"E\",      # pycodestyle errors\n    \"W\",      # pycodestyle warnings\n    \"F\",      # Pyflakes\n    \"I\",      # isort\n    \"N\",      # pep8-naming\n    \"UP\",     # pyupgrade\n    \"B\",      # flake8-bugbear\n    \"C4\",     # flake8-comprehensions\n    \"SIM\",    # flake8-simplify\n    \"PL\",     # pylint\n    \"RUF\",    # ruff-specific\n    \"PERF\",   # performance\n    \"FURB\",   # refurb\n]\nignore = [\n    \"E501\",   # line too long (if you want)\n]\n\n[tool.ruff.lint.per-file-ignores]\n\"tests/*\" = [\"S101\"]  # allow assert in tests\n\"__init__.py\" = [\"F401\"]  # allow unused imports\n\n[tool.ruff.lint.isort]\nknown-first-party = [\"mypackage\"]\n```\n\n## Pyflakes (F) - Critical Errors\n\n### F401: Module imported but unused\n\n```python\n# BAD\nimport os  # never used\n\n# GOOD\nimport os\nos.getcwd()\n\n# Or explicit re-export\nfrom .module import helper as helper  # noqa: F401\n```\n\n### F402: Import shadowed by loop variable\n\n```python\n# BAD\nfrom os import path\nfor path in paths:  # shadows import!\n    print(path)\n\n# GOOD\nfrom os import path\nfor p in paths:\n    print(p)\n```\n\n### F403: `from module import *` used\n\n```python\n# BAD\nfrom os import *\n\n# GOOD\nfrom os import path, getcwd\n```\n\n### F405: Name may be undefined from star import\n\n```python\n# BAD\nfrom os import *\nprint(getcwd())  # undefined if * import fails\n\n# GOOD\nfrom os import getcwd\nprint(getcwd())\n```\n\n### F501-F509: Invalid format strings\n\n```python\n# F501: Invalid format string\n\"{\".format()  # missing closing brace\n\n# F502: Positional placeholder not needed\n\"{0}\".format(x, y)  # y unused\n\n# F504: % format unused argument\n\"%s\" % (x, y)  # y unused\n\n# F506: % format missing argument\n\"%s %s\" % (x,)  # missing second arg\n```\n\n### F521: `.format` invalid format string\n\n```python\n# BAD\n\"{0} {2}\".format(a, b)  # no {1}\n\n# GOOD\n\"{0} {1}\".format(a, b)\n```\n\n### F522: `.format` unused positional arguments\n\n```python\n# BAD\n\"{0}\".format(a, b, c)  # b, c unused\n\n# GOOD\n\"{0} {1} {2}\".format(a, b, c)\n```\n\n### F523: `.format` unused keyword arguments\n\n```python\n# BAD\n\"{name}\".format(name=x, unused=y)\n\n# GOOD\n\"{name}\".format(name=x)\n```\n\n### F601: Dictionary key literal duplicated\n\n```python\n# BAD\nd = {\"a\": 1, \"a\": 2}  # duplicate key\n\n# GOOD\nd = {\"a\": 1, \"b\": 2}\n```\n\n### F631: Assert tuple (always true)\n\n```python\n# BAD\nassert (condition, \"message\")  # always True!\n\n# GOOD\nassert condition, \"message\"\n```\n\n### F632: Use `==` to compare to string literal\n\n```python\n# BAD\nif x is \"hello\":  # identity, not equality\n\n# GOOD\nif x == \"hello\":\n```\n\n### F811: Redefinition of unused name\n\n```python\n# BAD\ndef foo(): pass\ndef foo(): pass  # redefines\n\n# GOOD\ndef foo_v1(): pass\ndef foo_v2(): pass\n```\n\n### F821: Undefined name\n\n```python\n# BAD\nprint(undefined_var)\n\n# GOOD\nundefined_var = \"defined\"\nprint(undefined_var)\n```\n\n### F823: Local variable referenced before assignment\n\n```python\n# BAD\ndef foo():\n    print(x)  # referenced before assignment\n    x = 1\n\n# GOOD\ndef foo():\n    x = 1\n    print(x)\n```\n\n### F841: Local variable assigned but never used\n\n```python\n# BAD\ndef foo():\n    x = compute()  # never used\n    return 5\n\n# GOOD\ndef foo():\n    _ = compute()  # explicit ignore\n    return 5\n```\n\n### F901: `raise NotImplemented` should be `NotImplementedError`\n\n```python\n# BAD\nraise NotImplemented  # type, not exception\n\n# GOOD\nraise NotImplementedError\n```\n\n## pycodestyle (E/W) - Style\n\n### E101: Indentation contains mixed spaces and tabs\n\n### E111: Indentation is not a multiple of four\n\n```python\n# BAD\nif True:\n   x = 1  # 3 spaces\n\n# GOOD\nif True:\n    x = 1  # 4 spaces\n```\n\n### E117: Over-indented\n\n### E122-E131: Continuation line issues\n\n### E201-E203: Whitespace issues\n\n```python\n# BAD\nspam( ham[ 1 ], { eggs: 2 } )\n\n# GOOD\nspam(ham[1], {eggs: 2})\n```\n\n### E225-E228: Missing whitespace around operator\n\n```python\n# BAD\nx=1\ny = x+1\n\n# GOOD\nx = 1\ny = x + 1\n```\n\n### E231: Missing whitespace after ','\n\n```python\n# BAD\nfunc(a,b,c)\n\n# GOOD\nfunc(a, b, c)\n```\n\n### E251: Unexpected spaces around keyword / parameter equals\n\n```python\n# BAD\ndef foo(x = 1):\n    pass\n\n# GOOD\ndef foo(x=1):\n    pass\n```\n\n### E262: Inline comment should start with '# '\n\n```python\n# BAD\nx = 1  #comment\n\n# GOOD\nx = 1  # comment\n```\n\n### E265: Block comment should start with '# '\n\n### E266: Too many leading '#' for block comment\n\n### E302: Expected 2 blank lines, found N\n\n### E303: Too many blank lines\n\n### E304: Blank lines found after function decorator\n\n### E305: Expected 2 blank lines after class or function definition\n\n### E401: Multiple imports on one line\n\n```python\n# BAD\nimport os, sys\n\n# GOOD\nimport os\nimport sys\n```\n\n### E402: Module level import not at top of file\n\n### E501: Line too long\n\n### E701-E704: Multiple statements on one line\n\n```python\n# BAD\nif x: return True\n\n# GOOD\nif x:\n    return True\n```\n\n### E711: Comparison to None\n\n```python\n# BAD\nif x == None:\nif x != None:\n\n# GOOD\nif x is None:\nif x is not None:\n```\n\n### E712: Comparison to True/False\n\n```python\n# BAD\nif x == True:\nif x == False:\n\n# GOOD\nif x:\nif not x:\n\n# Exception: pandas/numpy boolean indexing\ndf[df[\"col\"] == True]  # sometimes needed\n```\n\n### E713: Not in test\n\n```python\n# BAD\nif not x in collection:\n\n# GOOD\nif x not in collection:\n```\n\n### E714: Not is test\n\n```python\n# BAD\nif not x is None:\n\n# GOOD\nif x is not None:\n```\n\n### E721: Type comparison\n\n```python\n# BAD\nif type(x) == int:\n\n# GOOD\nif isinstance(x, int):\n```\n\n### E722: Bare except\n\n```python\n# BAD\ntry:\n    risky()\nexcept:\n    pass\n\n# GOOD\ntry:\n    risky()\nexcept Exception:\n    pass\n```\n\n### E731: Do not assign a lambda expression\n\n```python\n# BAD\nf = lambda x: x + 1\n\n# GOOD\ndef f(x):\n    return x + 1\n```\n\n### E741: Ambiguous variable name\n\n```python\n# BAD\nl = []  # looks like 1\nO = 0   # looks like 0\nI = 1   # looks like l\n\n# GOOD\nitems = []\nzero = 0\none = 1\n```\n\n### E902: Token error\n\n### E999: Syntax error\n\n### W291-W293: Trailing whitespace\n\n### W391: Blank line at end of file\n\n### W503: Line break before binary operator (ignored by default)\n\n### W504: Line break after binary operator\n\n### W505: Doc line too long\n"}, {"path": "linters/ruff/simplify.md", "category": "linters", "name": "linters/ruff/simplify", "content": "# flake8-simplify (SIM) - Simplification\n\nMakes code more readable by suggesting simpler alternatives.\n\n## Boolean Simplifications\n\n### SIM101: Use `any()` or `all()`\n\n```python\n# BAD\nif a or b or c:\nif a and b and c:\n\n# Consider\nif any([a, b, c]):\nif all([a, b, c]):\n```\n\n### SIM102: Use single `if` instead of nested\n\n```python\n# BAD\nif a:\n    if b:\n        do_something()\n\n# GOOD\nif a and b:\n    do_something()\n```\n\n### SIM103: Return boolean directly\n\n```python\n# BAD\nif condition:\n    return True\nreturn False\n\n# GOOD\nreturn condition\n\n# BAD\nif condition:\n    return True\nelse:\n    return False\n\n# GOOD\nreturn condition\n```\n\n### SIM105: Use `contextlib.suppress`\n\n```python\n# BAD\ntry:\n    do_something()\nexcept ValueError:\n    pass\n\n# GOOD\nfrom contextlib import suppress\nwith suppress(ValueError):\n    do_something()\n```\n\n### SIM107: Return from try with no finally\n\n```python\n# BAD\ntry:\n    return do_something()\nexcept:\n    return default\n\n# GOOD\ntry:\n    result = do_something()\nexcept:\n    result = default\nreturn result\n```\n\n### SIM108: Use ternary operator\n\n```python\n# BAD\nif condition:\n    x = a\nelse:\n    x = b\n\n# GOOD\nx = a if condition else b\n```\n\n### SIM109: Use `in` for multiple comparisons\n\n```python\n# BAD\nif x == a or x == b or x == c:\n\n# GOOD\nif x in (a, b, c):\n```\n\n### SIM110: Use `any()` with generator\n\n```python\n# BAD\nfor item in items:\n    if condition(item):\n        return True\nreturn False\n\n# GOOD\nreturn any(condition(item) for item in items)\n```\n\n### SIM111: Use `all()` with generator\n\n```python\n# BAD\nfor item in items:\n    if not condition(item):\n        return False\nreturn True\n\n# GOOD\nreturn all(condition(item) for item in items)\n```\n\n### SIM112: Use `os.environ.get` instead of `in` check\n\n```python\n# BAD\nif \"KEY\" in os.environ:\n    value = os.environ[\"KEY\"]\nelse:\n    value = default\n\n# GOOD\nvalue = os.environ.get(\"KEY\", default)\n```\n\n### SIM114: Combine `if` branches with same body\n\n```python\n# BAD\nif a:\n    do_something()\nelif b:\n    do_something()\n\n# GOOD\nif a or b:\n    do_something()\n```\n\n### SIM115: Use context manager for open\n\n```python\n# BAD\nf = open(\"file.txt\")\ncontent = f.read()\nf.close()\n\n# GOOD\nwith open(\"file.txt\") as f:\n    content = f.read()\n```\n\n### SIM116: Use dict instead of if/elif chain\n\n```python\n# BAD\nif key == \"a\":\n    return 1\nelif key == \"b\":\n    return 2\nelif key == \"c\":\n    return 3\n\n# GOOD\nmapping = {\"a\": 1, \"b\": 2, \"c\": 3}\nreturn mapping.get(key)\n```\n\n### SIM117: Use single `with` statement\n\n```python\n# BAD\nwith open(\"a\") as a:\n    with open(\"b\") as b:\n        pass\n\n# GOOD\nwith open(\"a\") as a, open(\"b\") as b:\n    pass\n```\n\n### SIM118: Use `key in dict` instead of `key in dict.keys()`\n\n```python\n# BAD\nif key in d.keys():\n\n# GOOD\nif key in d:\n```\n\n## Expression Simplifications\n\n### SIM201: Use `x != y` instead of `not x == y`\n\n```python\n# BAD\nif not a == b:\n\n# GOOD\nif a != b:\n```\n\n### SIM202: Use `x == y` instead of `not x != y`\n\n```python\n# BAD\nif not a != b:\n\n# GOOD\nif a == b:\n```\n\n### SIM208: Use `x` instead of `not not x`\n\n```python\n# BAD\nif not not condition:\n\n# GOOD\nif condition:\n```\n\n### SIM210: Use `bool()` instead of `True if x else False`\n\n```python\n# BAD\nresult = True if x else False\n\n# GOOD\nresult = bool(x)\n```\n\n### SIM211: Use `not x` instead of `False if x else True`\n\n```python\n# BAD\nresult = False if x else True\n\n# GOOD\nresult = not x\n```\n\n### SIM212: Use `b if b else a` instead of `a if not b else b`\n\n```python\n# BAD\nresult = a if not b else b\n\n# GOOD\nresult = b or a\n```\n\n### SIM220: Use `False` instead of `a and not a`\n\n### SIM221: Use `True` instead of `a or not a`\n\n### SIM222: Use `True` instead of `a or True`\n\n### SIM223: Use `False` instead of `a and False`\n\n## Statement Simplifications\n\n### SIM300: Use Yoda conditions\n\n```python\n# BAD\nif \"hello\" == x:\n\n# GOOD\nif x == \"hello\":\n```\n\n### SIM401: Use `dict.get` with default\n\n```python\n# BAD\nif key in d:\n    value = d[key]\nelse:\n    value = default\n\n# GOOD\nvalue = d.get(key, default)\n```\n\n### SIM904: Assign `dict` items directly\n\n```python\n# BAD\nd = {}\nd[\"key1\"] = value1\nd[\"key2\"] = value2\n\n# GOOD\nd = {\n    \"key1\": value1,\n    \"key2\": value2,\n}\n```\n\n### SIM905: Split static string\n\n```python\n# BAD\n\"a,b,c\".split(\",\")\n\n# GOOD\n[\"a\", \"b\", \"c\"]\n```\n\n### SIM910: Use `dict.get(key)` instead of `dict.get(key, None)`\n\n```python\n# BAD\nd.get(\"key\", None)\n\n# GOOD\nd.get(\"key\")\n```\n\n### SIM911: Use `zip()` instead of `zip(dict.keys(), dict.values())`\n\n```python\n# BAD\nzip(d.keys(), d.values())\n\n# GOOD\nd.items()\n```\n\n## Configuration\n\n```toml\n[tool.ruff.lint]\nselect = [\"SIM\"]\n```\n"}, {"path": "linters/ruff/pyflakes.md", "category": "linters", "name": "linters/ruff/pyflakes", "content": "# Ruff - Pyflakes Rules (F)\n\nPyflakes detects various errors in Python programs.\n\n## F401: Module imported but unused\n\n```python\n# BAD\nimport os  # never used\n\n# GOOD - remove unused import\n# Or use __all__ to indicate public API\n```\n\n## F402: Import shadowed by loop variable\n\n```python\n# BAD\nfrom os import path\nfor path in paths:  # shadows import\n    print(path)\n\n# GOOD\nfrom os import path as os_path\nfor p in paths:\n    print(p)\n```\n\n## F403: `from module import *` used\n\n```python\n# BAD\nfrom os import *\n\n# GOOD\nfrom os import path, getcwd\n```\n\n## F405: Name may be undefined from star import\n\n```python\n# BAD\nfrom os import *\ngetcwd()  # might not be defined\n\n# GOOD\nfrom os import getcwd\ngetcwd()\n```\n\n## F501-F509: Invalid printf-style format\n\n```python\n# BAD\n\"%s %s\" % (one,)  # F507: not enough args\n\"%(a)s\" % {\"b\": 1}  # F505: missing key\n\n# GOOD\n\"%s\" % (one,)\n\"%(a)s\" % {\"a\": 1}\n```\n\n## F521-F525: Invalid .format() calls\n\n```python\n# BAD\n\"{} {}\".format(1)  # F524: not enough args\n\"{0} {2}\".format(1, 2)  # F525: missing index 1\n\n# GOOD\n\"{} {}\".format(1, 2)\n\"{0} {1}\".format(1, 2)\n```\n\n## F601: Dictionary key literal repeated\n\n```python\n# BAD\n{\"a\": 1, \"a\": 2}  # duplicate key\n\n# GOOD\n{\"a\": 1, \"b\": 2}\n```\n\n## F602: Dictionary key variable repeated\n\n```python\n# BAD\nkey = \"a\"\n{key: 1, key: 2}\n\n# GOOD\n{key: 1, \"other\": 2}\n```\n\n## F621: Too many expressions in star-unpacking\n\n```python\n# BAD\na, *b, c, *d = values  # two starred expressions\n\n# GOOD\na, *b, c = values\n```\n\n## F631: Assert test is a tuple (always True)\n\n```python\n# BAD\nassert (condition, message)  # tuple is always truthy!\n\n# GOOD\nassert condition, message\n```\n\n## F632: Use == instead of is for comparison to literal\n\n```python\n# BAD\nif x is \"hello\":  # string interning unreliable\n\n# GOOD\nif x == \"hello\":\n```\n\n## F633: Invalid print statement syntax (Python 2)\n\n```python\n# BAD\nprint \"hello\"  # Python 2 syntax\n\n# GOOD\nprint(\"hello\")\n```\n\n## F634: If test is a tuple (always True)\n\n```python\n# BAD\nif (x, y):  # tuple is always truthy\n    ...\n\n# GOOD\nif x and y:\n    ...\n```\n\n## F701-F707: Syntax errors\n\n```python\n# F701: break outside loop\n# F702: continue outside loop\n# F704: yield outside function\n# F706: return outside function\n# F707: except: with other clauses\n```\n\n## F811: Redefinition of unused name\n\n```python\n# BAD\ndef foo():\n    pass\n\ndef foo():  # shadows previous\n    pass\n\n# GOOD\ndef foo_v1():\n    pass\n\ndef foo_v2():\n    pass\n```\n\n## F821: Undefined name\n\n```python\n# BAD\nprint(undefined_variable)\n\n# GOOD\ndefined_variable = 1\nprint(defined_variable)\n```\n\n## F822: Undefined name in __all__\n\n```python\n# BAD\n__all__ = [\"foo\", \"bar\"]  # bar doesn't exist\n\n# GOOD\ndef foo(): pass\ndef bar(): pass\n__all__ = [\"foo\", \"bar\"]\n```\n\n## F823: Local variable referenced before assignment\n\n```python\n# BAD\ndef foo():\n    print(x)  # referenced before assignment\n    x = 1\n\n# GOOD\ndef foo():\n    x = 1\n    print(x)\n```\n\n## F841: Local variable assigned but never used\n\n```python\n# BAD\ndef foo():\n    x = 1  # never used\n    return 2\n\n# GOOD\ndef foo():\n    return 2\n\n# Or underscore prefix for intentionally unused\ndef foo():\n    _x = 1  # explicitly unused\n    return 2\n```\n\n## F842: Local variable annotated but never used\n\n```python\n# BAD\ndef foo():\n    x: int  # annotated but never used\n\n# GOOD - remove it\n```\n\n## F901: raise NotImplemented should be NotImplementedError\n\n```python\n# BAD\nraise NotImplemented\n\n# GOOD\nraise NotImplementedError\n```\n"}, {"path": "linters/ruff/pylint.md", "category": "linters", "name": "linters/ruff/pylint", "content": "# Ruff - Pylint Rules (PL)\n\nRules from Pylint implemented in Ruff.\n\n## Convention (PLC)\n\n### PLC0105: TypeVar name mismatch\n\n```python\n# BAD\nT = TypeVar(\"U\")  # name doesn't match\n\n# GOOD\nT = TypeVar(\"T\")\n```\n\n### PLC0131: TypeAlias annotation in TypeVar\n\n```python\n# BAD\nT: TypeAlias = TypeVar(\"T\")\n\n# GOOD\nT = TypeVar(\"T\")\ntype MyAlias = int  # 3.12+\n```\n\n### PLC0132: TypeVar name doesn't match assignment\n\n```python\n# BAD\nMyType = TypeVar(\"T\")\n\n# GOOD\nT = TypeVar(\"T\")\nMyTypeVar = TypeVar(\"MyTypeVar\")\n```\n\n### PLC0205: Class __slots__ not iterable\n\n```python\n# BAD\nclass Foo:\n    __slots__ = \"x\"  # should be iterable\n\n# GOOD\nclass Foo:\n    __slots__ = (\"x\",)\n    # or\n    __slots__ = [\"x\"]\n```\n\n### PLC0208: Iteration over set with modification\n\n```python\n# BAD\nfor item in items:\n    items.add(new_item)  # modifying during iteration\n\n# GOOD\nfor item in list(items):\n    items.add(new_item)\n```\n\n### PLC0414: Useless import alias\n\n```python\n# BAD\nimport os as os\nfrom sys import path as path\n\n# GOOD\nimport os\nfrom sys import path\n```\n\n### PLC0415: Import outside top level\n\n```python\n# BAD\ndef foo():\n    import os  # should be at top\n\n# GOOD\nimport os\n\ndef foo():\n    os.getcwd()\n```\n\n### PLC2401: Non-ASCII name\n\n```python\n# BAD\n\u540d\u524d = \"value\"  # non-ASCII identifier\n\n# GOOD\nname = \"value\"\n```\n\n### PLC2801: Unnecessary dunder call\n\n```python\n# BAD\nx.__add__(y)\nx.__str__()\n\n# GOOD\nx + y\nstr(x)\n```\n\n### PLC3002: Unnecessary direct lambda call\n\n```python\n# BAD\n(lambda: 42)()\n\n# GOOD\n42\n```\n\n## Error (PLE)\n\n### PLE0100: __init__ returns non-None\n\n```python\n# BAD\nclass Foo:\n    def __init__(self):\n        return 42\n\n# GOOD\nclass Foo:\n    def __init__(self):\n        self.value = 42\n```\n\n### PLE0101: return in __init__\n\n```python\n# BAD\nclass Foo:\n    def __init__(self):\n        return self  # should return None\n\n# GOOD\nclass Foo:\n    def __init__(self):\n        pass\n```\n\n### PLE0116: continue in finally\n\n```python\n# BAD\ntry:\n    pass\nfinally:\n    continue  # undefined behavior\n\n# GOOD\ntry:\n    pass\nfinally:\n    pass\ncontinue\n```\n\n### PLE0117: nonlocal outside function\n\n```python\n# BAD\nnonlocal x  # at module level\n\n# GOOD\ndef outer():\n    x = 1\n    def inner():\n        nonlocal x\n        x = 2\n```\n\n### PLE0118: Used before assignment in try\n\n```python\n# BAD\ntry:\n    x = func()\nexcept:\n    pass\nprint(x)  # x might not be defined\n\n# GOOD\nx = None\ntry:\n    x = func()\nexcept:\n    pass\nif x is not None:\n    print(x)\n```\n\n### PLE0237: Non-slot assignment\n\n```python\n# BAD\nclass Foo:\n    __slots__ = (\"x\",)\n\nf = Foo()\nf.y = 1  # y not in slots\n\n# GOOD\nclass Foo:\n    __slots__ = (\"x\", \"y\")\n\nf = Foo()\nf.y = 1\n```\n\n### PLE0241: Duplicate base class\n\n```python\n# BAD\nclass Foo(Bar, Bar):  # duplicate\n    pass\n\n# GOOD\nclass Foo(Bar):\n    pass\n```\n\n### PLE0302: Unexpected special method signature\n\n```python\n# BAD\nclass Foo:\n    def __len__(self, x):  # __len__ takes no args\n        return 0\n\n# GOOD\nclass Foo:\n    def __len__(self):\n        return 0\n```\n\n### PLE0604: Invalid __all__ object\n\n```python\n# BAD\n__all__ = (func,)  # should be strings\n\n# GOOD\n__all__ = (\"func\",)\n```\n\n### PLE0605: Invalid __all__ item\n\n```python\n# BAD\n__all__ = [1, 2, 3]  # should be strings\n\n# GOOD\n__all__ = [\"foo\", \"bar\"]\n```\n\n### PLE1142: await outside async\n\n```python\n# BAD\ndef foo():\n    await something()  # not async\n\n# GOOD\nasync def foo():\n    await something()\n```\n\n### PLE1205: Too many arguments for logging\n\n```python\n# BAD\nlogging.info(\"value: %s %s\", value)  # missing argument\n\n# GOOD\nlogging.info(\"value: %s\", value)\n```\n\n### PLE1206: Not enough arguments for logging\n\n```python\n# BAD\nlogging.info(\"a: %s, b: %s\", a)  # missing b\n\n# GOOD\nlogging.info(\"a: %s, b: %s\", a, b)\n```\n\n### PLE1307: Bad string format type\n\n```python\n# BAD\n\"%d\" % \"string\"  # wants int\n\n# GOOD\n\"%s\" % \"string\"\n\"%d\" % 42\n```\n\n### PLE1310: Bad str/bytes strip call\n\n```python\n# BAD\n\"hello\".strip(\"helo\")  # strips chars, not substring!\n\n# GOOD\n\"hello\".removeprefix(\"he\")  # 3.9+\n\"hello\".removesuffix(\"lo\")\n```\n\n### PLE1507: Invalid envvar default\n\n```python\n# BAD\nos.getenv(\"KEY\", 123)  # default should be str\n\n# GOOD\nos.getenv(\"KEY\", \"default\")\n```\n\n### PLE2502: Bidirectional control character\n\n```python\n# BAD - contains invisible unicode\n# Trojan source attack\n```\n\n## Refactor (PLR)\n\n### PLR0124: Comparison with self\n\n```python\n# BAD\nif x == x:  # always True\n    pass\n\n# GOOD\nif x is not None:\n    pass\n```\n\n### PLR0133: Comparison of constants\n\n```python\n# BAD\nif 1 == 1:\n    pass\n\n# GOOD\nif True:\n    pass\n```\n\n### PLR0206: Property with parameters\n\n```python\n# BAD\nclass Foo:\n    @property\n    def bar(self, x):  # property can't have params\n        return x\n\n# GOOD\nclass Foo:\n    @property\n    def bar(self):\n        return self._bar\n```\n\n### PLR0402: Use from import\n\n```python\n# BAD\nimport os.path\nos.path.join(...)\n\n# GOOD\nfrom os import path\npath.join(...)\n\n# Or\nfrom os.path import join\njoin(...)\n```\n\n### PLR0904-0917: Complexity limits\n\n- PLR0904: Too many public methods\n- PLR0911: Too many return statements\n- PLR0912: Too many branches\n- PLR0913: Too many arguments\n- PLR0914: Too many local variables\n- PLR0915: Too many statements\n- PLR0916: Too many boolean expressions\n- PLR0917: Too many positional arguments\n\n```python\n# BAD - too complex\ndef foo(a, b, c, d, e, f, g, h):  # too many args\n    if a:\n        if b:\n            if c:  # too many branches\n                pass\n```\n\n### PLR1701: Repeated isinstance calls\n\n```python\n# BAD\nisinstance(x, int) or isinstance(x, str)\n\n# GOOD\nisinstance(x, (int, str))\n# Or 3.10+\nisinstance(x, int | str)\n```\n\n### PLR1711: Useless return\n\n```python\n# BAD\ndef foo():\n    return None  # implicit anyway\n\n# GOOD\ndef foo():\n    pass\n```\n\n### PLR1714: Repeated equality comparison\n\n```python\n# BAD\nif x == 1 or x == 2 or x == 3:\n    pass\n\n# GOOD\nif x in {1, 2, 3}:\n    pass\n```\n\n### PLR1722: Use sys.exit()\n\n```python\n# BAD\nexit()\nquit()\n\n# GOOD\nimport sys\nsys.exit()\n```\n\n### PLR2004: Magic value in comparison\n\n```python\n# BAD\nif age > 18:\n    pass\n\n# GOOD\nADULT_AGE = 18\nif age > ADULT_AGE:\n    pass\n```\n\n### PLR5501: Collapsible else-if\n\n```python\n# BAD\nif a:\n    pass\nelse:\n    if b:\n        pass\n\n# GOOD\nif a:\n    pass\nelif b:\n    pass\n```\n\n## Warning (PLW)\n\n### PLW0120: Useless else on loop\n\n```python\n# BAD\nfor x in items:\n    if condition:\n        break\nelse:  # only runs if no break\n    pass  # empty else\n\n# Remove empty else\nfor x in items:\n    if condition:\n        break\n```\n\n### PLW0127: Self-assignment\n\n```python\n# BAD\nx = x\n\n# Remove it\n```\n\n### PLW0128: Redeclared variable in assignment\n\n```python\n# BAD\nx, x = 1, 2  # x assigned twice\n\n# GOOD\nx, y = 1, 2\n```\n\n### PLW0129: Assert on string literal\n\n```python\n# BAD\nassert \"always true\"  # non-empty string is truthy\n\n# GOOD\nassert condition, \"message\"\n```\n\n### PLW0131: Named expression in except\n\n```python\n# BAD\ntry:\n    pass\nexcept (err := Exception):  # walrus in except\n    pass\n\n# GOOD\ntry:\n    pass\nexcept Exception as err:\n    pass\n```\n\n### PLW0406: Import self\n\n```python\n# BAD (in module foo.py)\nimport foo  # importing itself\n\n# Remove self-import\n```\n\n### PLW0602: Global without assignment\n\n```python\n# BAD\nx = 1\ndef foo():\n    global x  # x not assigned in function\n\n# GOOD - remove global if not needed\ndef foo():\n    print(x)  # reading is fine without global\n```\n\n### PLW0603: Global statement\n\n```python\n# BAD\ndef foo():\n    global x\n    x = 1\n\n# GOOD - return value instead\ndef foo():\n    return 1\n\nx = foo()\n```\n\n### PLW0711: Binary op exception\n\n```python\n# BAD\nexcept TypeError or ValueError:  # wrong!\n\n# GOOD\nexcept (TypeError, ValueError):\n```\n\n### PLW1508: Invalid envvar default\n\n```python\n# BAD\nos.environ.get(\"KEY\", None)  # None is already default\n\n# GOOD\nos.environ.get(\"KEY\")\nos.environ.get(\"KEY\", \"default\")\n```\n\n### PLW1509: Subprocess popen preexec_fn\n\n```python\n# BAD - unsafe in multithreaded code\nsubprocess.Popen(cmd, preexec_fn=fn)\n\n# GOOD - use start_new_session or other options\nsubprocess.Popen(cmd, start_new_session=True)\n```\n\n### PLW2901: Redefined loop name\n\n```python\n# BAD\nfor i in range(10):\n    for i in range(5):  # shadows outer i\n        pass\n\n# GOOD\nfor i in range(10):\n    for j in range(5):\n        pass\n```\n\n### PLW3301: Nested min/max\n\n```python\n# BAD\nmin(1, min(2, 3))\n\n# GOOD\nmin(1, 2, 3)\n```\n"}, {"path": "linters/ruff/comprehensions.md", "category": "linters", "name": "linters/ruff/comprehensions", "content": "# Ruff - flake8-comprehensions Rules (C4)\n\nWrite better comprehensions.\n\n## C400: Unnecessary generator - use list comprehension\n\n```python\n# BAD\nlist(x for x in iterable)\n\n# GOOD\n[x for x in iterable]\n```\n\n## C401: Unnecessary generator - use set comprehension\n\n```python\n# BAD\nset(x for x in iterable)\n\n# GOOD\n{x for x in iterable}\n```\n\n## C402: Unnecessary generator - use dict comprehension\n\n```python\n# BAD\ndict((k, v) for k, v in items)\n\n# GOOD\n{k: v for k, v in items}\n```\n\n## C403: Unnecessary list comprehension - use set\n\n```python\n# BAD\nset([x for x in iterable])\n\n# GOOD\n{x for x in iterable}\n```\n\n## C404: Unnecessary list comprehension - use dict\n\n```python\n# BAD\ndict([pair for pair in items])\n\n# GOOD\n{k: v for k, v in items}\n```\n\n## C405: Unnecessary literal - use set literal\n\n```python\n# BAD\nset([1, 2, 3])\nset((1, 2, 3))\n\n# GOOD\n{1, 2, 3}\n```\n\n## C406: Unnecessary literal - use dict literal\n\n```python\n# BAD\ndict([(1, 2), (3, 4)])\ndict(((1, 2), (3, 4)))\n\n# GOOD\n{1: 2, 3: 4}\n```\n\n## C408: Unnecessary dict/list/tuple call\n\n```python\n# BAD\ndict()\nlist()\ntuple()\n\n# GOOD\n{}\n[]\n()\n```\n\n## C409: Unnecessary list passed to tuple()\n\n```python\n# BAD\ntuple([1, 2, 3])\n\n# GOOD\n(1, 2, 3)\n```\n\n## C410: Unnecessary list passed to list()\n\n```python\n# BAD\nlist([1, 2, 3])\n\n# GOOD\n[1, 2, 3]\n```\n\n## C411: Unnecessary list call - use list literal\n\n```python\n# BAD\nlist([])\n\n# GOOD\n[]\n```\n\n## C413: Unnecessary list/reversed call around sorted()\n\n```python\n# BAD\nlist(sorted(iterable))\nreversed(sorted(iterable))\n\n# GOOD\nsorted(iterable)\nsorted(iterable, reverse=True)\n```\n\n## C414: Unnecessary double list/set/tuple/reversed/sorted\n\n```python\n# BAD\nlist(list(iterable))\nset(set(iterable))\nsorted(sorted(iterable))\n\n# GOOD\nlist(iterable)\nset(iterable)\nsorted(iterable)\n```\n\n## C415: Unnecessary subscript reversal\n\n```python\n# BAD\nset(iterable[::-1])\nsorted(iterable)[::-1]\n\n# GOOD\nset(iterable)\nsorted(iterable, reverse=True)\n```\n\n## C416: Unnecessary comprehension - use list/set/dict\n\n```python\n# BAD\n[x for x in iterable]  # identity comprehension\n{x for x in iterable}\n{k: v for k, v in items}\n\n# GOOD\nlist(iterable)\nset(iterable)\ndict(items)\n```\n\n## C417: Unnecessary map - use generator/comprehension\n\n```python\n# BAD\nmap(lambda x: x * 2, iterable)\nmap(str, numbers)\n\n# GOOD\n(x * 2 for x in iterable)\n[x * 2 for x in iterable]\n(str(n) for n in numbers)\n```\n\n## C418: Unnecessary dict passed to dict()\n\n```python\n# BAD\ndict({\"a\": 1})\n\n# GOOD\n{\"a\": 1}\n```\n\n## C419: Unnecessary comprehension in any/all\n\n```python\n# BAD\nany([x > 0 for x in items])\nall([x > 0 for x in items])\n\n# GOOD - use generator\nany(x > 0 for x in items)\nall(x > 0 for x in items)\n```\n"}, {"path": "linters/ruff/naming.md", "category": "linters", "name": "linters/ruff/naming", "content": "# Ruff - pep8-naming Rules (N)\n\nPEP 8 naming conventions.\n\n## N801: Class name should use CapWords\n\n```python\n# BAD\nclass my_class:\n    pass\n\nclass myClass:\n    pass\n\n# GOOD\nclass MyClass:\n    pass\n```\n\n## N802: Function name should be lowercase\n\n```python\n# BAD\ndef MyFunction():\n    pass\n\ndef myFunction():\n    pass\n\n# GOOD\ndef my_function():\n    pass\n```\n\n## N803: Argument name should be lowercase\n\n```python\n# BAD\ndef foo(myArg):\n    pass\n\n# GOOD\ndef foo(my_arg):\n    pass\n```\n\n## N804: First argument of classmethod should be 'cls'\n\n```python\n# BAD\nclass Foo:\n    @classmethod\n    def bar(self):\n        pass\n\n# GOOD\nclass Foo:\n    @classmethod\n    def bar(cls):\n        pass\n```\n\n## N805: First argument of method should be 'self'\n\n```python\n# BAD\nclass Foo:\n    def bar(this):\n        pass\n\n# GOOD\nclass Foo:\n    def bar(self):\n        pass\n```\n\n## N806: Variable in function should be lowercase\n\n```python\n# BAD\ndef foo():\n    MyVar = 1\n    return MyVar\n\n# GOOD\ndef foo():\n    my_var = 1\n    return my_var\n```\n\n## N807: Function name should not start/end with '__'\n\n```python\n# BAD\ndef __my_function__():\n    pass\n\n# GOOD\ndef my_function():\n    pass\n\n# OK - dunder methods in classes\nclass Foo:\n    def __init__(self):\n        pass\n```\n\n## N811: Constant imported as non-constant\n\n```python\n# BAD\nfrom math import PI as pi\n\n# GOOD\nfrom math import PI\n# or\nfrom math import PI as MY_PI\n```\n\n## N812: Lowercase imported as non-lowercase\n\n```python\n# BAD\nfrom os import path as PATH\n\n# GOOD\nfrom os import path\n```\n\n## N813: CamelCase imported as lowercase\n\n```python\n# BAD\nfrom typing import TypeVar as typevar\n\n# GOOD\nfrom typing import TypeVar\n```\n\n## N814: CamelCase imported as constant\n\n```python\n# BAD\nfrom typing import TypeVar as TYPE_VAR\n\n# GOOD\nfrom typing import TypeVar\n```\n\n## N815: mixedCase variable in class scope\n\n```python\n# BAD\nclass Foo:\n    myVar = 1\n\n# GOOD\nclass Foo:\n    my_var = 1\n```\n\n## N816: mixedCase variable in global scope\n\n```python\n# BAD\nmyGlobal = 1\n\n# GOOD\nmy_global = 1\nMY_CONSTANT = 1\n```\n\n## N817: CamelCase imported as acronym\n\n```python\n# BAD\nfrom collections import OrderedDict as OD\n\n# GOOD\nfrom collections import OrderedDict\n```\n\n## N818: Exception name should end in Error\n\n```python\n# BAD\nclass MyException(Exception):\n    pass\n\n# GOOD\nclass MyError(Exception):\n    pass\n\nclass ValidationError(Exception):\n    pass\n```\n\n## N999: Invalid module name\n\n```python\n# BAD filename: MyModule.py, my-module.py\n\n# GOOD filename: my_module.py\n```\n"}, {"path": "linters/ruff/security.md", "category": "linters", "name": "linters/ruff/security", "content": "# Ruff - Security Rules (S / flake8-bandit)\n\nSecurity-focused rules from Bandit.\n\n## S101: Use of assert\n\n```python\n# BAD - assert is stripped in optimized mode\nassert user.is_admin, \"Admin required\"\n\n# GOOD\nif not user.is_admin:\n    raise PermissionError(\"Admin required\")\n```\n\n**Note:** Allow in tests with per-file-ignores.\n\n## S102: Use of exec\n\n```python\n# BAD\nexec(user_code)\n\n# GOOD - avoid exec entirely\n# If absolutely needed, heavily sandbox\n```\n\n## S103: Chmod with permissive mask\n\n```python\n# BAD\nos.chmod(path, 0o777)\n\n# GOOD\nos.chmod(path, 0o600)\n```\n\n## S104: Binding to all interfaces\n\n```python\n# BAD\nsocket.bind((\"0.0.0.0\", 8080))\n\n# GOOD\nsocket.bind((\"127.0.0.1\", 8080))\n```\n\n## S105-S107: Hardcoded passwords\n\n```python\n# BAD\npassword = \"admin123\"\nsecret_key = \"supersecret\"\napi_key = \"sk-1234567890\"\n\n# GOOD\npassword = os.environ[\"PASSWORD\"]\nsecret_key = os.environ[\"SECRET_KEY\"]\napi_key = os.environ[\"API_KEY\"]\n```\n\n## S108: Hardcoded /tmp path\n\n```python\n# BAD\nwith open(\"/tmp/data.txt\", \"w\") as f:\n    f.write(data)\n\n# GOOD\nimport tempfile\nwith tempfile.NamedTemporaryFile(mode=\"w\", delete=False) as f:\n    f.write(data)\n```\n\n## S110: Try-except-pass\n\n```python\n# BAD - silently ignores errors\ntry:\n    risky()\nexcept Exception:\n    pass\n\n# GOOD\ntry:\n    risky()\nexcept Exception:\n    logger.exception(\"Failed\")\n```\n\n## S112: Try-except-continue\n\n```python\n# BAD - silently continues\nfor item in items:\n    try:\n        process(item)\n    except Exception:\n        continue\n\n# GOOD\nfor item in items:\n    try:\n        process(item)\n    except Exception:\n        logger.exception(\"Failed to process %s\", item)\n```\n\n## S113: Request without timeout\n\n```python\n# BAD\nrequests.get(url)\n\n# GOOD\nrequests.get(url, timeout=10)\n```\n\n## S301: Pickle unsafe\n\n```python\n# BAD\npickle.loads(user_data)  # arbitrary code execution!\n\n# GOOD - use safer alternatives\njson.loads(user_data)\n```\n\n## S302: Marshal unsafe\n\n```python\n# BAD\nmarshal.loads(user_data)\n\n# GOOD\njson.loads(user_data)\n```\n\n## S303-S304: Weak crypto\n\n```python\n# BAD\nimport md5\nimport sha\nhashlib.md5(data)\nhashlib.sha1(data)\n\n# GOOD\nhashlib.sha256(data)\nhashlib.sha3_256(data)\n```\n\n## S305: Weak cipher\n\n```python\n# BAD\nfrom Crypto.Cipher import DES\ncipher = DES.new(key)\n\n# GOOD\nfrom Crypto.Cipher import AES\ncipher = AES.new(key, AES.MODE_GCM)\n```\n\n## S306: mktemp is insecure\n\n```python\n# BAD\ntempfile.mktemp()\n\n# GOOD\ntempfile.mkstemp()\ntempfile.NamedTemporaryFile()\n```\n\n## S307: eval is dangerous\n\n```python\n# BAD\neval(user_input)\n\n# GOOD - use ast.literal_eval for data\nimport ast\nast.literal_eval(user_input)\n\n# Or parse specifically\njson.loads(user_input)\n```\n\n## S308: mark_safe without escaping\n\n```python\n# BAD (Django)\nmark_safe(user_input)\n\n# GOOD\nmark_safe(escape(user_input))\n```\n\n## S310: URL open suspicious\n\n```python\n# BAD - can be file:// or other schemes\nurllib.urlopen(user_url)\n\n# GOOD - validate scheme\nif user_url.startswith((\"http://\", \"https://\")):\n    urllib.urlopen(user_url)\n```\n\n## S311: Random not cryptographically secure\n\n```python\n# BAD for security\nimport random\ntoken = random.randint(0, 1000000)\n\n# GOOD\nimport secrets\ntoken = secrets.token_hex(32)\n```\n\n## S312: Telnet insecure\n\n```python\n# BAD\ntelnetlib.Telnet(host)\n\n# GOOD\n# Use SSH instead\n```\n\n## S314-S321: XML vulnerabilities\n\n```python\n# BAD - vulnerable to XXE\nxml.etree.ElementTree.parse(user_file)\nxml.dom.minidom.parse(user_file)\nxml.sax.parse(user_file)\n\n# GOOD - use defusedxml\nimport defusedxml.ElementTree as ET\nET.parse(user_file)\n```\n\n## S324: Insecure hash function\n\n```python\n# BAD\nhashlib.md5(password.encode())\n\n# GOOD for passwords\nimport bcrypt\nbcrypt.hashpw(password.encode(), bcrypt.gensalt())\n\n# Or\nfrom passlib.hash import argon2\nargon2.hash(password)\n```\n\n## S501: Request with verify=False\n\n```python\n# BAD - no SSL verification\nrequests.get(url, verify=False)\n\n# GOOD\nrequests.get(url, verify=True)\nrequests.get(url)  # verify=True is default\n```\n\n## S502: SSL with insecure version\n\n```python\n# BAD\nssl.SSLContext(ssl.PROTOCOL_SSLv3)\n\n# GOOD\nssl.create_default_context()\nssl.SSLContext(ssl.PROTOCOL_TLS)\n```\n\n## S506: YAML unsafe load\n\n```python\n# BAD - arbitrary code execution\nyaml.load(user_data)\nyaml.load(user_data, Loader=yaml.Loader)\n\n# GOOD\nyaml.safe_load(user_data)\n```\n\n## S507: SSH no host key verification\n\n```python\n# BAD\nclient.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n# GOOD\nclient.set_missing_host_key_policy(paramiko.RejectPolicy())\n# Or load known hosts\nclient.load_system_host_keys()\n```\n\n## S508-S509: Snmp insecure\n\n```python\n# BAD\nsnmp_community = \"public\"\n\n# GOOD - use SNMPv3 with auth\n```\n\n## S601: Shell injection via parameterized string\n\n```python\n# BAD\nsubprocess.call(\"ls \" + user_dir, shell=True)\n\n# GOOD\nsubprocess.call([\"ls\", user_dir])\n```\n\n## S602: Shell=True without literal\n\n```python\n# BAD\nsubprocess.call(cmd, shell=True)\n\n# GOOD\nsubprocess.call(cmd.split())\n# Or\nsubprocess.call(shlex.split(cmd))\n```\n\n## S603-S607: Subprocess without full path\n\n```python\n# BAD\nsubprocess.call([\"ls\"])\n\n# GOOD\nsubprocess.call([\"/bin/ls\"])\n```\n\n## S608: SQL injection\n\n```python\n# BAD\ncursor.execute(\"SELECT * FROM users WHERE id = \" + user_id)\ncursor.execute(f\"SELECT * FROM users WHERE id = {user_id}\")\n\n# GOOD\ncursor.execute(\"SELECT * FROM users WHERE id = ?\", (user_id,))\ncursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))\n```\n\n## S609: Wildcard injection\n\n```python\n# BAD\nos.system(\"rm -rf /tmp/*\")  # wildcard expansion\n\n# GOOD\nimport glob\nfor f in glob.glob(\"/tmp/*\"):\n    os.remove(f)\n```\n\n## S612: Logging sensitive info\n\n```python\n# BAD\nlogger.debug(f\"Password: {password}\")\n\n# GOOD\nlogger.debug(\"Password: [REDACTED]\")\n```\n\n## S701: Jinja2 autoescape off\n\n```python\n# BAD\njinja2.Environment(autoescape=False)\n\n# GOOD\njinja2.Environment(autoescape=True)\njinja2.Environment(autoescape=select_autoescape())\n```\n"}, {"path": "linters/ruff/bugbear.md", "category": "linters", "name": "linters/ruff/bugbear", "content": "# Ruff - flake8-bugbear Rules (B)\n\nOpinionated, bug-finding rules.\n\n## B002: Use of `**=` for assignment\n\n```python\n# BAD\nx =+ 1  # probably meant +=\n\n# GOOD\nx += 1\n```\n\n## B003: Assigning to os.environ doesn't clear\n\n```python\n# BAD\nos.environ = {\"PATH\": \"/bin\"}  # doesn't work as expected\n\n# GOOD\nos.environ.clear()\nos.environ.update({\"PATH\": \"/bin\"})\n```\n\n## B004: Using hasattr for __call__ is unreliable\n\n```python\n# BAD\nif hasattr(obj, \"__call__\"):\n    obj()\n\n# GOOD\nif callable(obj):\n    obj()\n```\n\n## B005: Using .strip() with multi-char string\n\n```python\n# BAD\n\"hello\".strip(\"he\")  # strips each char, not substring\n\n# GOOD\n\"hello\".removeprefix(\"he\")  # Python 3.9+\n\"hello\".lstrip(\"h\")\n```\n\n## B006: Mutable default argument\n\n```python\n# BAD - mutable default is shared!\ndef foo(items=[]):\n    items.append(1)\n    return items\n\nfoo()  # [1]\nfoo()  # [1, 1]  # same list!\n\n# GOOD\ndef foo(items=None):\n    if items is None:\n        items = []\n    items.append(1)\n    return items\n```\n\n## B007: Loop variable not used\n\n```python\n# BAD\nfor i in range(10):  # i not used\n    print(\"hello\")\n\n# GOOD\nfor _ in range(10):\n    print(\"hello\")\n```\n\n## B008: Function call in default argument\n\n```python\n# BAD - called once at definition time\ndef foo(now=datetime.now()):\n    return now\n\n# GOOD - called each invocation\ndef foo(now=None):\n    if now is None:\n        now = datetime.now()\n    return now\n```\n\n## B009: Do not call getattr with constant\n\n```python\n# BAD\ngetattr(obj, \"foo\")\n\n# GOOD\nobj.foo\n```\n\n## B010: Do not call setattr with constant\n\n```python\n# BAD\nsetattr(obj, \"foo\", value)\n\n# GOOD\nobj.foo = value\n```\n\n## B011: Do not assert False\n\n```python\n# BAD\nassert False, \"message\"\n\n# GOOD\nraise AssertionError(\"message\")\n```\n\n## B012: Return in finally\n\n```python\n# BAD - swallows exceptions\ntry:\n    risky()\nfinally:\n    return default  # exception lost!\n\n# GOOD\ntry:\n    return risky()\nexcept Exception:\n    return default\n```\n\n## B014: Redundant exception in except\n\n```python\n# BAD\nexcept (ValueError, ValueError):  # duplicate\n\n# GOOD\nexcept ValueError:\n```\n\n## B015: Useless comparison\n\n```python\n# BAD\nx == 5  # result discarded\n\n# GOOD\nresult = x == 5\nif x == 5:\n    ...\n```\n\n## B016: Raise literal\n\n```python\n# BAD\nraise \"error\"\n\n# GOOD\nraise ValueError(\"error\")\n```\n\n## B017: assertRaises(Exception)\n\n```python\n# BAD - too broad\nwith pytest.raises(Exception):\n    risky()\n\n# GOOD\nwith pytest.raises(ValueError):\n    risky()\n```\n\n## B018: Useless expression\n\n```python\n# BAD\n\"this does nothing\"\n42\n\n# GOOD - remove or assign\n# Unless it's a docstring\n```\n\n## B019: Use @functools.lru_cache with parentheses\n\n```python\n# BAD\n@functools.lru_cache\ndef expensive():\n    ...\n\n# GOOD\n@functools.lru_cache()\ndef expensive():\n    ...\n```\n\n## B020: Loop variable shadows outer\n\n```python\n# BAD\nitems = [1, 2, 3]\nfor items in [[4], [5]]:  # shadows outer items\n    print(items)\n\n# GOOD\nfor batch in [[4], [5]]:\n    print(batch)\n```\n\n## B023: Function in loop that uses loop variable\n\n```python\n# BAD - all functions use last value\nfuncs = []\nfor i in range(3):\n    funcs.append(lambda: i)\n# All return 2!\n\n# GOOD - capture value\nfuncs = []\nfor i in range(3):\n    funcs.append(lambda i=i: i)\n```\n\n## B024: Abstract class without abstract methods\n\n```python\n# BAD\nfrom abc import ABC\n\nclass Foo(ABC):  # no abstract methods\n    def bar(self):\n        pass\n\n# GOOD\nfrom abc import ABC, abstractmethod\n\nclass Foo(ABC):\n    @abstractmethod\n    def bar(self):\n        pass\n```\n\n## B025: try-except-pass\n\n```python\n# BAD\ntry:\n    risky()\nexcept Exception:\n    pass\n\n# GOOD - at least log\ntry:\n    risky()\nexcept Exception:\n    logger.exception(\"Failed\")\n```\n\n## B026: Star-argument unpacking after keyword argument\n\n```python\n# BAD\nfoo(a=1, *args)\n\n# GOOD\nfoo(*args, a=1)\n```\n\n## B028: No explicit stacklevel in warnings.warn\n\n```python\n# BAD\nwarnings.warn(\"deprecated\")\n\n# GOOD\nwarnings.warn(\"deprecated\", stacklevel=2)\n```\n\n## B029: except with empty tuple\n\n```python\n# BAD\nexcept ():\n    pass\n\n# GOOD\nexcept Exception:\n    pass\n```\n\n## B030: except with non-exception type\n\n```python\n# BAD\nexcept 42:\n    pass\n\n# GOOD\nexcept ValueError:\n    pass\n```\n\n## B031: Reusing groupby generator\n\n```python\n# BAD\nfor key, group in itertools.groupby(data, key_func):\n    groups[key] = group  # group is consumed by next iteration!\n\n# GOOD\nfor key, group in itertools.groupby(data, key_func):\n    groups[key] = list(group)\n```\n\n## B032: Unintentional type annotation\n\n```python\n# BAD\nx: int  # This is a type annotation with no value\n\n# GOOD (if you meant annotation)\nx: int = 0\n\n# GOOD (if you meant type comment)\nx = 0  # type: int\n```\n\n## B033: Duplicate set item\n\n```python\n# BAD\n{1, 2, 1}  # duplicate\n\n# GOOD\n{1, 2}\n```\n\n## B034: re.sub/split without flags\n\n```python\n# BAD - might match different than expected\nre.sub(\"pattern\", repl, string, count)\n\n# GOOD - explicit flags\nre.sub(\"pattern\", repl, string, count=count)\nre.sub(\"pattern\", repl, string, flags=re.IGNORECASE)\n```\n\n## B904: Raise without from in except handler\n\n```python\n# BAD - loses original traceback\nexcept ValueError:\n    raise RuntimeError(\"failed\")\n\n# GOOD\nexcept ValueError as e:\n    raise RuntimeError(\"failed\") from e\n\n# Or if intentionally suppressing\nexcept ValueError:\n    raise RuntimeError(\"failed\") from None\n```\n\n## B905: zip without explicit strict\n\n```python\n# BAD\nzip(a, b)  # silently truncates if different lengths\n\n# GOOD (Python 3.10+)\nzip(a, b, strict=True)\n```\n"}, {"path": "linters/pylint/overview.md", "category": "linters", "name": "linters/pylint/overview", "content": "# Messages[\u00b6](#messages)\nVersion: unknown\n\nSource: https://pylint.readthedocs.io/en/stable/user_guide/messages/index.html\n\n\n## Messages categories[\u00b6](#messages-categories)\n\nPylint can emit various messages. These are categorized according to categories corresponding to bit-encoded exit codes:\n\n- \n\n[Fatal](messages_overview.html#fatal-category) (1)\n\n- \n\n[Error](messages_overview.html#error-category) (2)\n\n- \n\n[Warning](messages_overview.html#warning-category) (4)\n\n- \n\n[Convention](messages_overview.html#convention-category) (8)\n\n- \n\n[Refactor](messages_overview.html#refactor-category) (16)\n\n- \n\n[Information](messages_overview.html#information-category) (NA)\n\nAn overview of these messages can be found in [Messages overview](messages_overview.html#messages-overview)\n\n## Disabling messages[\u00b6](#disabling-messages)\n\n`pylint` has an advanced message control for its checks, offering the ability to enable / disable a message either from the command line or from the configuration file, as well as from the code itself.\n\nFor more detail see [Messages control](message_control.html#message-control)\n"}, {"path": "linters/flake8/C901.md", "category": "linters", "name": "linters/flake8/C901", "content": "# C901\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/overview.md", "category": "linters", "name": "linters/flake8/overview", "content": "Error / Violation Codes \u2014 flake8 7.3.0 documentation[flake8](../index.html)\n\n- [Frequently Asked Questions](../faq.html)\n- [Glossary of Terms Used in Flake8 Documentation](../glossary.html)\n\n- [Using Flake8](index.html)\n\n  - [Invoking Flake8](invocation.html)\n  - [Configuring Flake8](configuration.html)\n  - [Full Listing of Options and Their Descriptions](options.html)\n  - [Error / Violation Codes](#)\n  - [Selecting and Ignoring Violations](violations.html)\n  - [Using Plugins For Fun and Profit](using-plugins.html)\n  - [Using Version Control Hooks](using-hooks.html)\n  - [Public Python API](python-api.html)\n\n- [Writing Plugins for Flake8](../plugin-development/index.html)\n\n- [Exploring Flake8\u2019s Internals](../internal/index.html)\n\n- [Release Notes and History](../release-notes/index.html)\n\n[flake8](../index.html)\n\n- ../index.html\n- [Using Flake8](index.html)\n- Error / Violation Codes\n- [View page source](../_sources/user/error-codes.rst.txt)\n\n# Error / Violation Codes[\uf0c1](#error-violation-codes)\nVersion: latest\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n\n\nFlake8 and its plugins assign a code to each message that we refer to as an [error code](../glossary.html#term-error-code) (or [violation](../glossary.html#term-violation)). Most plugins will list their error codes in their documentation or README.\n\nFlake8 installs `pycodestyle`, `pyflakes`, and `mccabe` by default and generates its own [error code](../glossary.html#term-error-code)s for `pyflakes`:\n\nCode\n\nExample Message\n\nF401\n\n`module` imported but unused\n\nF402\n\nimport `module` from line `N` shadowed by loop variable\n\nF403\n\n\u2018from `module` import *\u2019 used; unable to detect undefined names\n\nF404\n\nfuture import(s) `name` after other statements\n\nF405\n\n`name` may be undefined, or defined from star imports: `module`\n\nF406\n\n\u2018from `module` import *\u2019 only allowed at module level\n\nF407\n\nan undefined `__future__` feature name was imported\n\nF501\n\ninvalid `%` format literal\n\nF502\n\n`%` format expected mapping but got sequence\n\nF503\n\n`%` format expected sequence but got mapping\n\nF504\n\n`%` format unused named arguments\n\nF505\n\n`%` format missing named arguments\n\nF506\n\n`%` format mixed positional and named arguments\n\nF507\n\n`%` format mismatch of placeholder and argument count\n\nF508\n\n`%` format with `*` specifier requires a sequence\n\nF509\n\n`%` format with unsupported format character\n\nF521\n\n`.format(...)` invalid format string\n\nF522\n\n`.format(...)` unused named arguments\n\nF523\n\n`.format(...)` unused positional arguments\n\nF524\n\n`.format(...)` missing argument\n\nF525\n\n`.format(...)` mixing automatic and manual numbering\n\nF541\n\nf-string without any placeholders\n\nF542\n\nt-string without any placeholders\n\nF601\n\ndictionary key `name` repeated with different values\n\nF602\n\ndictionary key variable `name` repeated with different values\n\nF621\n\ntoo many expressions in an assignment with star-unpacking\n\nF622\n\ntwo or more starred expressions in an assignment `(a, *b, *c = d)`\n\nF631\n\nassertion test is a tuple, which is always `True`\n\nF632\n\nuse `==/!=` to compare `str`, `bytes`, and `int` literals\n\nF633\n\nuse of `>>` is invalid with `print` function\n\nF634\n\nif test is a tuple, which is always `True`\n\nF701\n\na `break` statement outside of a `while` or `for` loop\n\nF702\n\na `continue` statement outside of a `while` or `for` loop\n\nF704\n\na `yield` or `yield from` statement outside of a function\n\nF706\n\na `return` statement outside of a function/method\n\nF707\n\nan `except:` block as not the last exception handler\n\nF721\n\nsyntax error in doctest\n\nF722\n\nsyntax error in forward annotation\n\nF723\n\nsyntax error in type comment\n\nF811\n\nredefinition of unused `name` from line `N`\n\nF821\n\nundefined name `name`\n\nF822\n\nundefined name `name` in `__all__`\n\nF823\n\nlocal variable `name` \u2026 referenced before assignment\n\nF824\n\n`global name` / `nonlocal name` is unused: name is never assigned in scope\n\nF831\n\nduplicate argument `name` in function definition\n\nF841\n\nlocal variable `name` is assigned to but never used\n\nF901\n\n`raise NotImplemented` should be `raise NotImplementedError`\n\nWe also report one extra error: `E999`. We report `E999` when we fail to compile a file into an Abstract Syntax Tree for the plugins that require it.\n\n`mccabe` only ever reports one [violation](../glossary.html#term-violation) - `C901` based on the complexity value provided by the user.\n\nUsers should also reference [pycodestyle\u2019s list of error codes](https://pycodestyle.readthedocs.io/en/latest/intro.html#error-codes).\n\n[Previous](options.html)[Next](violations.html)\n\n\u00a9 Copyright 2016, Ian Stapleton Cordasco.\n\n Built with [Sphinx](https://www.sphinx-doc.org/) using a [theme](https://github.com/readthedocs/sphinx_rtd_theme) provided by [Read the Docs](https://readthedocs.org).\n"}, {"path": "linters/flake8/F405.md", "category": "linters", "name": "linters/flake8/F405", "content": "# F405\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F702.md", "category": "linters", "name": "linters/flake8/F702", "content": "# F702\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F811.md", "category": "linters", "name": "linters/flake8/F811", "content": "# F811\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F504.md", "category": "linters", "name": "linters/flake8/F504", "content": "# F504\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F524.md", "category": "linters", "name": "linters/flake8/F524", "content": "# F524\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F706.md", "category": "linters", "name": "linters/flake8/F706", "content": "# F706\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F541.md", "category": "linters", "name": "linters/flake8/F541", "content": "# F541\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F401.md", "category": "linters", "name": "linters/flake8/F401", "content": "# F401\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F831.md", "category": "linters", "name": "linters/flake8/F831", "content": "# F831\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F633.md", "category": "linters", "name": "linters/flake8/F633", "content": "# F633\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F821.md", "category": "linters", "name": "linters/flake8/F821", "content": "# F821\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F722.md", "category": "linters", "name": "linters/flake8/F722", "content": "# F722\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F525.md", "category": "linters", "name": "linters/flake8/F525", "content": "# F525\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F707.md", "category": "linters", "name": "linters/flake8/F707", "content": "# F707\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F622.md", "category": "linters", "name": "linters/flake8/F622", "content": "# F622\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/E999.md", "category": "linters", "name": "linters/flake8/E999", "content": "# E999\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F632.md", "category": "linters", "name": "linters/flake8/F632", "content": "# F632\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F723.md", "category": "linters", "name": "linters/flake8/F723", "content": "# F723\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F501.md", "category": "linters", "name": "linters/flake8/F501", "content": "# F501\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F404.md", "category": "linters", "name": "linters/flake8/F404", "content": "# F404\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F521.md", "category": "linters", "name": "linters/flake8/F521", "content": "# F521\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F602.md", "category": "linters", "name": "linters/flake8/F602", "content": "# F602\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F901.md", "category": "linters", "name": "linters/flake8/F901", "content": "# F901\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F841.md", "category": "linters", "name": "linters/flake8/F841", "content": "# F841\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F824.md", "category": "linters", "name": "linters/flake8/F824", "content": "# F824\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F505.md", "category": "linters", "name": "linters/flake8/F505", "content": "# F505\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F704.md", "category": "linters", "name": "linters/flake8/F704", "content": "# F704\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F621.md", "category": "linters", "name": "linters/flake8/F621", "content": "# F621\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F403.md", "category": "linters", "name": "linters/flake8/F403", "content": "# F403\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F502.md", "category": "linters", "name": "linters/flake8/F502", "content": "# F502\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F823.md", "category": "linters", "name": "linters/flake8/F823", "content": "# F823\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F631.md", "category": "linters", "name": "linters/flake8/F631", "content": "# F631\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F407.md", "category": "linters", "name": "linters/flake8/F407", "content": "# F407\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F522.md", "category": "linters", "name": "linters/flake8/F522", "content": "# F522\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F601.md", "category": "linters", "name": "linters/flake8/F601", "content": "# F601\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F506.md", "category": "linters", "name": "linters/flake8/F506", "content": "# F506\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F406.md", "category": "linters", "name": "linters/flake8/F406", "content": "# F406\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F701.md", "category": "linters", "name": "linters/flake8/F701", "content": "# F701\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F523.md", "category": "linters", "name": "linters/flake8/F523", "content": "# F523\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F507.md", "category": "linters", "name": "linters/flake8/F507", "content": "# F507\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F634.md", "category": "linters", "name": "linters/flake8/F634", "content": "# F634\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F542.md", "category": "linters", "name": "linters/flake8/F542", "content": "# F542\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F402.md", "category": "linters", "name": "linters/flake8/F402", "content": "# F402\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F503.md", "category": "linters", "name": "linters/flake8/F503", "content": "# F503\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F822.md", "category": "linters", "name": "linters/flake8/F822", "content": "# F822\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F721.md", "category": "linters", "name": "linters/flake8/F721", "content": "# F721\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F508.md", "category": "linters", "name": "linters/flake8/F508", "content": "# F508\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F509.md", "category": "linters", "name": "linters/flake8/F509", "content": "# F509\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/mypy/overview.md", "category": "linters", "name": "linters/mypy/overview", "content": "# Error codes enabled by default[\u00b6](#error-codes-enabled-by-default)\nVersion: latest\n\nSource: https://mypy.readthedocs.io/en/stable/error_code_list.html\n\n\nThis section documents various errors codes that mypy can generate with default options. See [Error codes](error_codes.html#error-codes) for general documentation about error codes. [Error codes for optional checks](error_code_list2.html#error-codes-optional) documents additional error codes that you can enable.\n\n## Check that attribute exists [attr-defined][\u00b6](#check-that-attribute-exists-attr-defined)\n\nMypy checks that an attribute is defined in the target class or module when using the dot operator. This applies to both getting and setting an attribute. New attributes are defined by assignments in the class body, or assignments to `self.x` in methods. These assignments don\u2019t generate `attr-defined` errors.\n\nExample:\n\n```\nclass Resource:\n    def __init__(self, name: str) -> None:\n        self.name = name\n\nr = Resource('x')\nprint(r.name)  # OK\nprint(r.id)  # Error: \"Resource\" has no attribute \"id\"  [attr-defined]\nr.id = 5  # Error: \"Resource\" has no attribute \"id\"  [attr-defined]\n```\n\nThis error code is also generated if an imported name is not defined in the module in a `from ... import` statement (as long as the target module can be found):\n\n```\n# Error: Module \"os\" has no attribute \"non_existent\"  [attr-defined]\nfrom os import non_existent\n```\n\nA reference to a missing attribute is given the `Any` type. In the above example, the type of `non_existent` will be `Any`, which can be important if you silence the error.\n\n## Check that attribute exists in each union item [union-attr][\u00b6](#check-that-attribute-exists-in-each-union-item-union-attr)\n\nIf you access the attribute of a value with a union type, mypy checks that the attribute is defined for every type in that union. Otherwise the operation can fail at runtime. This also applies to optional types.\n\nExample:\n\n```\nclass Cat:\n    def sleep(self) -> None: ...\n    def miaow(self) -> None: ...\n\nclass Dog:\n    def sleep(self) -> None: ...\n    def follow_me(self) -> None: ...\n\ndef func(animal: Cat | Dog) -> None:\n    # OK: 'sleep' is defined for both Cat and Dog\n    animal.sleep()\n    # Error: Item \"Cat\" of \"Cat | Dog\" has no attribute \"follow_me\"  [union-attr]\n    animal.follow_me()\n```\n\nYou can often work around these errors by using `assert isinstance(obj, ClassName)` or `assert obj is not None` to tell mypy that you know that the type is more specific than what mypy thinks.\n\n## Check that name is defined [name-defined][\u00b6](#check-that-name-is-defined-name-defined)\n\nMypy expects that all references to names have a corresponding definition in an active scope, such as an assignment, function definition or an import. This can catch missing definitions, missing imports, and typos.\n\nThis example accidentally calls `sort()` instead of [sorted()](https://docs.python.org/3/library/functions.html#sorted):\n\n```\nx = sort([3, 2, 4])  # Error: Name \"sort\" is not defined  [name-defined]\n```\n\n## Check that a variable is not used before it\u2019s defined [used-before-def][\u00b6](#check-that-a-variable-is-not-used-before-it-s-defined-used-before-def)\n\nMypy will generate an error if a name is used before it\u2019s defined. While the name-defined check will catch issues with names that are undefined, it will not flag if a variable is used and then defined later in the scope. used-before-def check will catch such cases.\n\nExample:\n\n```\nprint(x)  # Error: Name \"x\" is used before definition [used-before-def]\nx = 123\n```\n\n## Check arguments in calls [call-arg][\u00b6](#check-arguments-in-calls-call-arg)\n\nMypy expects that the number and names of arguments match the called function. Note that argument type checks have a separate error code `arg-type`.\n\nExample:\n\n```\ndef greet(name: str) -> None:\n     print('hello', name)\n\ngreet('jack')  # OK\ngreet('jill', 'jack')  # Error: Too many arguments for \"greet\"  [call-arg]\n```\n\n## Check argument types [arg-type][\u00b6](#check-argument-types-arg-type)\n\nMypy checks that argument types in a call match the declared argument types in the signature of the called function (if one exists).\n\nExample:\n\n```\ndef first(x: list[int]) -> int:\n    return x[0] if x else 0\n\nt = (5, 4)\n# Error: Argument 1 to \"first\" has incompatible type \"tuple[int, int]\";\n#        expected \"list[int]\"  [arg-type]\nprint(first(t))\n```\n\n## Check calls to overloaded functions [call-overload][\u00b6](#check-calls-to-overloaded-functions-call-overload)\n\nWhen you call an overloaded function, mypy checks that at least one of the signatures of the overload items match the argument types in the call.\n\nExample:\n\n```\nfrom typing import overload\n\n@overload\ndef inc_maybe(x: None) -> None: ...\n\n@overload\ndef inc_maybe(x: int) -> int: ...\n\ndef inc_maybe(x: int | None) -> int | None:\n     if x is None:\n         return None\n     else:\n         return x + 1\n\ninc_maybe(None)  # OK\ninc_maybe(5)  # OK\n\n# Error: No overload variant of \"inc_maybe\" matches argument type \"float\"  [call-overload]\ninc_maybe(1.2)\n```\n\n## Check validity of types [valid-type][\u00b6](#check-validity-of-types-valid-type)\n\nMypy checks that each type annotation and any expression that represents a type is a valid type. Examples of valid types include classes, union types, callable types, type aliases, and literal types. Examples of invalid types include bare integer literals, functions, variables, and modules.\n\nThis example incorrectly uses the function `log` as a type:\n\n```\ndef log(x: object) -> None:\n    print('log:', repr(x))\n\n# Error: Function \"t.log\" is not valid as a type  [valid-type]\ndef log_all(objs: list[object], f: log) -> None:\n    for x in objs:\n        f(x)\n```\n\nYou can use [Callable](https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable) as the type for callable objects:\n\n```\nfrom collections.abc import Callable\n\n# OK\ndef log_all(objs: list[object], f: Callable[[object], None]) -> None:\n    for x in objs:\n        f(x)\n```\n\n## Check the validity of a class\u2019s metaclass [metaclass][\u00b6](#check-the-validity-of-a-class-s-metaclass-metaclass)\n\nMypy checks whether the metaclass of a class is valid. The metaclass must be a subclass of `type`. Further, the class hierarchy must yield a consistent metaclass. For more details, see the [Python documentation](https://docs.python.org/3.13/reference/datamodel.html#determining-the-appropriate-metaclass)\n\nNote that mypy\u2019s metaclass checking is limited and may produce false-positives. See also [Gotchas and limitations of metaclass support](metaclasses.html#limitations).\n\nExample with an error:\n\n```\nclass GoodMeta(type):\n    pass\n\nclass BadMeta:\n    pass\n\nclass A1(metaclass=GoodMeta):  # OK\n    pass\n\nclass A2(metaclass=BadMeta):  # Error:  Metaclasses not inheriting from \"type\" are not supported  [metaclass]\n    pass\n```\n\n## Require annotation if variable type is unclear [var-annotated][\u00b6](#require-annotation-if-variable-type-is-unclear-var-annotated)\n\nIn some cases mypy can\u2019t infer the type of a variable without an explicit annotation. Mypy treats this as an error. This typically happens when you initialize a variable with an empty collection or `None`. If mypy can\u2019t infer the collection item type, mypy replaces any parts of the type it couldn\u2019t infer with `Any` and generates an error.\n\nExample with an error:\n\n```\nclass Bundle:\n    def __init__(self) -> None:\n        # Error: Need type annotation for \"items\"\n        #        (hint: \"items: list[<type>] = ...\")  [var-annotated]\n        self.items = []\n\nreveal_type(Bundle().items)  # list[Any]\n```\n\nTo address this, we add an explicit annotation:\n\n```\n class Bundle:\n     def __init__(self) -> None:\n         self.items: list[str] = []  # OK\n\nreveal_type(Bundle().items)  # list[str]\n```\n\n## Check validity of overrides [override][\u00b6](#check-validity-of-overrides-override)\n\nMypy checks that an overridden method or attribute is compatible with the base class. A method in a subclass must accept all arguments that the base class method accepts, and the return type must conform to the return type in the base class (Liskov substitution principle).\n\nArgument types can be more general is a subclass (i.e., they can vary contravariantly). The return type can be narrowed in a subclass (i.e., it can vary covariantly). It\u2019s okay to define additional arguments in a subclass method, as long all extra arguments have default values or can be left out (`*args`, for example).\n\nExample:\n\n```\nclass Base:\n    def method(self,\n               arg: int) -> int | None:\n        ...\n\nclass Derived(Base):\n    def method(self,\n               arg: int | str) -> int:  # OK\n        ...\n\nclass DerivedBad(Base):\n    # Error: Argument 1 of \"method\" is incompatible with \"Base\"  [override]\n    def method(self,\n               arg: bool) -> int:\n        ...\n```\n\n## Check that function returns a value [return][\u00b6](#check-that-function-returns-a-value-return)\n\nIf a function has a non-`None` return type, mypy expects that the function always explicitly returns a value (or raises an exception). The function should not fall off the end of the function, since this is often a bug.\n\nExample:\n\n```\n# Error: Missing return statement  [return]\ndef show(x: int) -> int:\n    print(x)\n\n# Error: Missing return statement  [return]\ndef pred1(x: int) -> int:\n    if x > 0:\n        return x - 1\n\n# OK\ndef pred2(x: int) -> int:\n    if x > 0:\n        return x - 1\n    else:\n        raise ValueError('not defined for zero')\n```\n\n## Check that functions don\u2019t have empty bodies outside stubs [empty-body][\u00b6](#check-that-functions-don-t-have-empty-bodies-outside-stubs-empty-body)\n\nThis error code is similar to the `[return]` code but is emitted specifically for functions and methods with empty bodies (if they are annotated with non-trivial return type). Such a distinction exists because in some contexts an empty body can be valid, for example for an abstract method or in a stub file. Also old versions of mypy used to unconditionally allow functions with empty bodies, so having a dedicated error code simplifies cross-version compatibility.\n\nNote that empty bodies are allowed for methods in protocols, and such methods are considered implicitly abstract:\n\n```\nfrom abc import abstractmethod\nfrom typing import Protocol\n\nclass RegularABC:\n    @abstractmethod\n    def foo(self) -> int:\n        pass  # OK\n    def bar(self) -> int:\n        pass  # Error: Missing return statement  [empty-body]\n\nclass Proto(Protocol):\n    def bar(self) -> int:\n        pass  # OK\n```\n\n## Check that return value is compatible [return-value][\u00b6](#check-that-return-value-is-compatible-return-value)\n\nMypy checks that the returned value is compatible with the type signature of the function.\n\nExample:\n\n```\ndef func(x: int) -> str:\n    # Error: Incompatible return value type (got \"int\", expected \"str\")  [return-value]\n    return x + 1\n```\n\n## Check types in assignment statement [assignment][\u00b6](#check-types-in-assignment-statement-assignment)\n\nMypy checks that the assigned expression is compatible with the assignment target (or targets).\n\nExample:\n\n```\nclass Resource:\n    def __init__(self, name: str) -> None:\n        self.name = name\n\nr = Resource('A')\n\nr.name = 'B'  # OK\n\n# Error: Incompatible types in assignment (expression has type \"int\",\n#        variable has type \"str\")  [assignment]\nr.name = 5\n```\n\n## Check that assignment target is not a method [method-assign][\u00b6](#check-that-assignment-target-is-not-a-method-method-assign)\n\nIn general, assigning to a method on class object or instance (a.k.a. monkey-patching) is ambiguous in terms of types, since Python\u2019s static type system cannot express the difference between bound and unbound callable types. Consider this example:\n\n```\nclass A:\n    def f(self) -> None: pass\n    def g(self) -> None: pass\n\ndef h(self: A) -> None: pass\n\nA.f = h  # Type of h is Callable[[A], None]\nA().f()  # This works\nA.f = A().g  # Type of A().g is Callable[[], None]\nA().f()  # ...but this also works at runtime\n```\n\nTo prevent the ambiguity, mypy will flag both assignments by default. If this error code is disabled, mypy will treat the assigned value in all method assignments as unbound, so only the second assignment will still generate an error.\n\nNote\n\nThis error code is a subcode of the more general `[assignment]` code.\n\n## Check type variable values [type-var][\u00b6](#check-type-variable-values-type-var)\n\nMypy checks that value of a type variable is compatible with a value restriction or the upper bound type.\n\nExample (Python 3.12 syntax):\n\n```\ndef add[T1: (int, float)](x: T1, y: T1) -> T1:\n    return x + y\n\nadd(4, 5.5)  # OK\n\n# Error: Value of type variable \"T1\" of \"add\" cannot be \"str\"  [type-var]\nadd('x', 'y')\n```\n\n## Check uses of various operators [operator][\u00b6](#check-uses-of-various-operators-operator)\n\nMypy checks that operands support a binary or unary operation, such as `+` or `~`. Indexing operations are so common that they have their own error code `index` (see below).\n\nExample:\n\n```\n# Error: Unsupported operand types for + (\"int\" and \"str\")  [operator]\n1 + 'x'\n```\n\n## Check indexing operations [index][\u00b6](#check-indexing-operations-index)\n\nMypy checks that the indexed value in indexing operation such as `x[y]` supports indexing, and that the index expression has a valid type.\n\nExample:\n\n```\na = {'x': 1, 'y': 2}\n\na['x']  # OK\n\n# Error: Invalid index type \"int\" for \"dict[str, int]\"; expected type \"str\"  [index]\nprint(a[1])\n\n# Error: Invalid index type \"bytes\" for \"dict[str, int]\"; expected type \"str\"  [index]\na[b'x'] = 4\n```\n\n## Check list items [list-item][\u00b6](#check-list-items-list-item)\n\nWhen constructing a list using `[item, ...]`, mypy checks that each item is compatible with the list type that is inferred from the surrounding context.\n\nExample:\n\n```\n# Error: List item 0 has incompatible type \"int\"; expected \"str\"  [list-item]\na: list[str] = [0]\n```\n\n## Check dict items [dict-item][\u00b6](#check-dict-items-dict-item)\n\nWhen constructing a dictionary using `{key: value, ...}` or `dict(key=value, ...)`, mypy checks that each key and value is compatible with the dictionary type that is inferred from the surrounding context.\n\nExample:\n\n```\n# Error: Dict entry 0 has incompatible type \"str\": \"str\"; expected \"str\": \"int\"  [dict-item]\nd: dict[str, int] = {'key': 'value'}\n```\n\n## Check TypedDict items [typeddict-item][\u00b6](#check-typeddict-items-typeddict-item)\n\nWhen constructing a TypedDict object, mypy checks that each key and value is compatible with the TypedDict type that is inferred from the surrounding context.\n\nWhen getting a TypedDict item, mypy checks that the key exists. When assigning to a TypedDict, mypy checks that both the key and the value are valid.\n\nExample:\n\n```\nfrom typing import TypedDict\n\nclass Point(TypedDict):\n    x: int\n    y: int\n\n# Error: Incompatible types (expression has type \"float\",\n#        TypedDict item \"x\" has type \"int\")  [typeddict-item]\np: Point = {'x': 1.2, 'y': 4}\n```\n\n## Check TypedDict Keys [typeddict-unknown-key][\u00b6](#check-typeddict-keys-typeddict-unknown-key)\n\nWhen constructing a TypedDict object, mypy checks whether the definition contains unknown keys, to catch invalid keys and misspellings. On the other hand, mypy will not generate an error when a previously constructed TypedDict value with extra keys is passed to a function as an argument, since TypedDict values support structural subtyping (\u201cstatic duck typing\u201d) and the keys are assumed to have been validated at the point of construction. Example:\n\n```\nfrom typing import TypedDict\n\nclass Point(TypedDict):\n    x: int\n    y: int\n\nclass Point3D(Point):\n    z: int\n\ndef add_x_coordinates(a: Point, b: Point) -> int:\n    return a[\"x\"] + b[\"x\"]\n\na: Point = {\"x\": 1, \"y\": 4}\nb: Point3D = {\"x\": 2, \"y\": 5, \"z\": 6}\n\nadd_x_coordinates(a, b)  # OK\n\n# Error: Extra key \"z\" for TypedDict \"Point\"  [typeddict-unknown-key]\nadd_x_coordinates(a, {\"x\": 1, \"y\": 4, \"z\": 5})\n```\n\nSetting a TypedDict item using an unknown key will also generate this error, since it could be a misspelling:\n\n```\na: Point = {\"x\": 1, \"y\": 2}\n# Error: Extra key \"z\" for TypedDict \"Point\"  [typeddict-unknown-key]\na[\"z\"] = 3\n```\n\nReading an unknown key will generate the more general (and serious) `typeddict-item` error, which is likely to result in an exception at runtime:\n\n```\na: Point = {\"x\": 1, \"y\": 2}\n# Error: TypedDict \"Point\" has no key \"z\"  [typeddict-item]\n_ = a[\"z\"]\n```\n\nNote\n\nThis error code is a subcode of the wider `[typeddict-item]` code.\n\n## Check that type of target is known [has-type][\u00b6](#check-that-type-of-target-is-known-has-type)\n\nMypy sometimes generates an error when it hasn\u2019t inferred any type for a variable being referenced. This can happen for references to variables that are initialized later in the source file, and for references across modules that form an import cycle. When this happens, the reference gets an implicit `Any` type.\n\nIn this example the definitions of `x` and `y` are circular:\n\n```\nclass Problem:\n    def set_x(self) -> None:\n        # Error: Cannot determine type of \"y\"  [has-type]\n        self.x = self.y\n\n    def set_y(self) -> None:\n        self.y = self.x\n```\n\nTo work around this error, you can add an explicit type annotation to the target variable or attribute. Sometimes you can also reorganize the code so that the definition of the variable is placed earlier than the reference to the variable in a source file. Untangling cyclic imports may also help.\n\nWe add an explicit annotation to the `y` attribute to work around the issue:\n\n```\nclass Problem:\n    def set_x(self) -> None:\n        self.x = self.y  # OK\n\n    def set_y(self) -> None:\n        self.y: int = self.x  # Added annotation here\n```\n\n## Check for an issue with imports [import][\u00b6](#check-for-an-issue-with-imports-import)\n\nMypy generates an error if it can\u2019t resolve an import statement. This is a parent error code of import-not-found and import-untyped\n\nSee [Missing imports](running_mypy.html#ignore-missing-imports) for how to work around these errors.\n\n## Check that import target can be found [import-not-found][\u00b6](#check-that-import-target-can-be-found-import-not-found)\n\nMypy generates an error if it can\u2019t find the source code or a stub file for an imported module.\n\nExample:\n\n```\n# Error: Cannot find implementation or library stub for module named \"m0dule_with_typo\"  [import-not-found]\nimport m0dule_with_typo\n```\n\nSee [Missing imports](running_mypy.html#ignore-missing-imports) for how to work around these errors.\n\n## Check that import target can be found [import-untyped][\u00b6](#check-that-import-target-can-be-found-import-untyped)\n\nMypy generates an error if it can find the source code for an imported module, but that module does not provide type annotations (via [PEP 561](installed_packages.html#installed-packages)).\n\nExample:\n\n```\n# Error: Library stubs not installed for \"bs4\"  [import-untyped]\nimport bs4\n# Error: Skipping analyzing \"no_py_typed\": module is installed, but missing library stubs or py.typed marker  [import-untyped]\nimport no_py_typed\n```\n\nIn some cases, these errors can be fixed by installing an appropriate stub package. See [Missing imports](running_mypy.html#ignore-missing-imports) for more details.\n\n## Check that each name is defined once [no-redef][\u00b6](#check-that-each-name-is-defined-once-no-redef)\n\nMypy may generate an error if you have multiple definitions for a name in the same namespace. The reason is that this is often an error, as the second definition may overwrite the first one. Also, mypy often can\u2019t be able to determine whether references point to the first or the second definition, which would compromise type checking.\n\nIf you silence this error, all references to the defined name refer to the first definition.\n\nExample:\n\n```\nclass A:\n    def __init__(self, x: int) -> None: ...\n\nclass A:  # Error: Name \"A\" already defined on line 1  [no-redef]\n    def __init__(self, x: str) -> None: ...\n\n# Error: Argument 1 to \"A\" has incompatible type \"str\"; expected \"int\"\n#        (the first definition wins!)\nA('x')\n```\n\n## Check that called function returns a value [func-returns-value][\u00b6](#check-that-called-function-returns-a-value-func-returns-value)\n\nMypy reports an error if you call a function with a `None` return type and don\u2019t ignore the return value, as this is usually (but not always) a programming error.\n\nIn this example, the `if f()` check is always false since `f` returns `None`:\n\n```\ndef f() -> None:\n    ...\n\n# OK: we don't do anything with the return value\nf()\n\n# Error: \"f\" does not return a value (it only ever returns None)  [func-returns-value]\nif f():\n     print(\"not false\")\n```\n\n## Check instantiation of abstract classes [abstract][\u00b6](#check-instantiation-of-abstract-classes-abstract)\n\nMypy generates an error if you try to instantiate an abstract base class (ABC). An abstract base class is a class with at least one abstract method or attribute. (See also [abc](https://docs.python.org/3/library/abc.html#module-abc) module documentation)\n\nSometimes a class is made accidentally abstract, often due to an unimplemented abstract method. In a case like this you need to provide an implementation for the method to make the class concrete (non-abstract).\n\nExample:\n\n```\nfrom abc import ABCMeta, abstractmethod\n\nclass Persistent(metaclass=ABCMeta):\n    @abstractmethod\n    def save(self) -> None: ...\n\nclass Thing(Persistent):\n    def __init__(self) -> None:\n        ...\n\n    ...  # No \"save\" method\n\n# Error: Cannot instantiate abstract class \"Thing\" with abstract attribute \"save\"  [abstract]\nt = Thing()\n```\n\n## Safe handling of abstract type object types [type-abstract][\u00b6](#safe-handling-of-abstract-type-object-types-type-abstract)\n\nMypy always allows instantiating (calling) type objects typed as `type[t]`, even if it is not known that `t` is non-abstract, since it is a common pattern to create functions that act as object factories (custom constructors). Therefore, to prevent issues described in the above section, when an abstract type object is passed where `type[t]` is expected, mypy will give an error. Example (Python 3.12 syntax):\n\n```\nfrom abc import ABCMeta, abstractmethod\n\nclass Config(metaclass=ABCMeta):\n    @abstractmethod\n    def get_value(self, attr: str) -> str: ...\n\ndef make_many[T](typ: type[T], n: int) -> list[T]:\n    return [typ() for _ in range(n)]  # This will raise if typ is abstract\n\n# Error: Only concrete class can be given where \"type[Config]\" is expected [type-abstract]\nmake_many(Config, 5)\n```\n\n## Check that call to an abstract method via super is valid [safe-super][\u00b6](#check-that-call-to-an-abstract-method-via-super-is-valid-safe-super)\n\nAbstract methods often don\u2019t have any default implementation, i.e. their bodies are just empty. Calling such methods in subclasses via `super()` will cause runtime errors, so mypy prevents you from doing so:\n\n```\nfrom abc import abstractmethod\nclass Base:\n    @abstractmethod\n    def foo(self) -> int: ...\nclass Sub(Base):\n    def foo(self) -> int:\n        return super().foo() + 1  # error: Call to abstract method \"foo\" of \"Base\" with\n                                  # trivial body via super() is unsafe  [safe-super]\nSub().foo()  # This will crash at runtime.\n```\n\nMypy considers the following as trivial bodies: a `pass` statement, a literal ellipsis `...`, a docstring, and a `raise NotImplementedError` statement.\n\n## Check the target of NewType [valid-newtype][\u00b6](#check-the-target-of-newtype-valid-newtype)\n\nThe target of a [NewType](https://docs.python.org/3/library/typing.html#typing.NewType) definition must be a class type. It can\u2019t be a union type, `Any`, or various other special types.\n\nYou can also get this error if the target has been imported from a module whose source mypy cannot find, since any such definitions are treated by mypy as values with `Any` types. Example:\n\n```\nfrom typing import NewType\n\n# The source for \"acme\" is not available for mypy\nfrom acme import Entity  # type: ignore\n\n# Error: Argument 2 to NewType(...) must be subclassable (got \"Any\")  [valid-newtype]\nUserEntity = NewType('UserEntity', Entity)\n```\n\nTo work around the issue, you can either give mypy access to the sources for `acme` or create a stub file for the module. See [Missing imports](running_mypy.html#ignore-missing-imports) for more information.\n\n## Check the return type of __exit__ [exit-return][\u00b6](#check-the-return-type-of-exit-exit-return)\n\nIf mypy can determine that [__exit__](https://docs.python.org/3/reference/datamodel.html#object.__exit__) always returns `False`, mypy checks that the return type is not`bool`. The boolean value of the return type affects which lines mypy thinks are reachable after a `with` statement, since any [__exit__](https://docs.python.org/3/reference/datamodel.html#object.__exit__) method that can return `True` may swallow exceptions. An imprecise return type can result in mysterious errors reported near `with` statements.\n\nTo fix this, use either `typing.Literal[False]` or `None` as the return type. Returning `None` is equivalent to returning `False` in this context, since both are treated as false values.\n\nExample:\n\n```\nclass MyContext:\n    ...\n    def __exit__(self, exc, value, tb) -> bool:  # Error\n        print('exit')\n        return False\n```\n\nThis produces the following output from mypy:\n\n```\nexample.py:3: error: \"bool\" is invalid as return type for \"__exit__\" that always returns False\nexample.py:3: note: Use \"typing_extensions.Literal[False]\" as the return type or change it to\n    \"None\"\nexample.py:3: note: If return type of \"__exit__\" implies that it may return True, the context\n    manager may swallow exceptions\n```\n\nYou can use `Literal[False]` to fix the error:\n\n```\nfrom typing import Literal\n\nclass MyContext:\n    ...\n    def __exit__(self, exc, value, tb) -> Literal[False]:  # OK\n        print('exit')\n        return False\n```\n\nYou can also use `None`:\n\n```\nclass MyContext:\n    ...\n    def __exit__(self, exc, value, tb) -> None:  # Also OK\n        print('exit')\n```\n\n## Check that naming is consistent [name-match][\u00b6](#check-that-naming-is-consistent-name-match)\n\nThe definition of a named tuple or a TypedDict must be named consistently when using the call-based syntax. Example:\n\n```\nfrom typing import NamedTuple\n\n# Error: First argument to namedtuple() should be \"Point2D\", not \"Point\"\nPoint2D = NamedTuple(\"Point\", [(\"x\", int), (\"y\", int)])\n```\n\n## Check that literal is used where expected [literal-required][\u00b6](#check-that-literal-is-used-where-expected-literal-required)\n\nThere are some places where only a (string) literal value is expected for the purposes of static type checking, for example a `TypedDict` key, or a `__match_args__` item. Providing a `str`-valued variable in such contexts will result in an error. Note that in many cases you can also use `Final` or `Literal` variables. Example:\n\n```\nfrom typing import Final, Literal, TypedDict\n\nclass Point(TypedDict):\n    x: int\n    y: int\n\ndef test(p: Point) -> None:\n    X: Final = \"x\"\n    p[X]  # OK\n\n    Y: Literal[\"y\"] = \"y\"\n    p[Y]  # OK\n\n    key = \"x\"  # Inferred type of key is `str`\n    # Error: TypedDict key must be a string literal;\n    #   expected one of (\"x\", \"y\")  [literal-required]\n    p[key]\n```\n\n## Check that overloaded functions have an implementation [no-overload-impl][\u00b6](#check-that-overloaded-functions-have-an-implementation-no-overload-impl)\n\nOverloaded functions outside of stub files must be followed by a non overloaded implementation.\n\n```\nfrom typing import overload\n\n@overload\ndef func(value: int) -> int:\n    ...\n\n@overload\ndef func(value: str) -> str:\n    ...\n\n# presence of required function below is checked\ndef func(value):\n    pass  # actual implementation\n```\n\n## Check that coroutine return value is used [unused-coroutine][\u00b6](#check-that-coroutine-return-value-is-used-unused-coroutine)\n\nMypy ensures that return values of async def functions are not ignored, as this is usually a programming error, as the coroutine won\u2019t be executed at the call site.\n\n```\nasync def f() -> None:\n    ...\n\nasync def g() -> None:\n    f()  # Error: missing await\n    await f()  # OK\n```\n\nYou can work around this error by assigning the result to a temporary, otherwise unused variable:\n\n```\n_ = f()  # No error\n```\n\n## Warn about top level await expressions [top-level-await][\u00b6](#warn-about-top-level-await-expressions-top-level-await)\n\nThis error code is separate from the general `[syntax]` errors, because in some environments (e.g. IPython) a top level `await` is allowed. In such environments a user may want to use `--disable-error-code=top-level-await`, which allows one to still have errors for other improper uses of `await`, for example:\n\n```\nasync def f() -> None:\n    ...\n\ntop = await f()  # Error: \"await\" outside function  [top-level-await]\n```\n\n## Warn about await expressions used outside of coroutines [await-not-async][\u00b6](#warn-about-await-expressions-used-outside-of-coroutines-await-not-async)\n\n`await` must be used inside a coroutine.\n\n```\nasync def f() -> None:\n    ...\n\ndef g() -> None:\n    await f()  # Error: \"await\" outside coroutine (\"async def\")  [await-not-async]\n```\n\n## Check types in assert_type [assert-type][\u00b6](#check-types-in-assert-type-assert-type)\n\nThe inferred type for an expression passed to `assert_type` must match the provided type.\n\n```\nfrom typing_extensions import assert_type\n\nassert_type([1], list[int])  # OK\n\nassert_type([1], list[str])  # Error\n```\n\n## Check that function isn\u2019t used in boolean context [truthy-function][\u00b6](#check-that-function-isn-t-used-in-boolean-context-truthy-function)\n\nFunctions will always evaluate to true in boolean contexts.\n\n```\ndef f():\n    ...\n\nif f:  # Error: Function \"Callable[[], Any]\" could always be true in boolean context  [truthy-function]\n    pass\n```\n\n## Check that string formatting/interpolation is type-safe [str-format][\u00b6](#check-that-string-formatting-interpolation-is-type-safe-str-format)\n\nMypy will check that f-strings, `str.format()` calls, and `%` interpolations are valid (when corresponding template is a literal string). This includes checking number and types of replacements, for example:\n\n```\n# Error: Cannot find replacement for positional format specifier 1 [str-format]\n\"{} and {}\".format(\"spam\")\n\"{} and {}\".format(\"spam\", \"eggs\")  # OK\n# Error: Not all arguments converted during string formatting [str-format]\n\"{} and {}\".format(\"spam\", \"eggs\", \"cheese\")\n\n# Error: Incompatible types in string interpolation\n# (expression has type \"float\", placeholder has type \"int\") [str-format]\n\"{:d}\".format(3.14)\n```\n\n## Check for implicit bytes coercions [str-bytes-safe][\u00b6](#check-for-implicit-bytes-coercions-str-bytes-safe)\n\nWarn about cases where a bytes object may be converted to a string in an unexpected manner.\n\n```\nb = b\"abc\"\n\n# Error: If x = b'abc' then f\"{x}\" or \"{}\".format(x) produces \"b'abc'\", not \"abc\".\n# If this is desired behavior, use f\"{x!r}\" or \"{!r}\".format(x).\n# Otherwise, decode the bytes [str-bytes-safe]\nprint(f\"The alphabet starts with {b}\")\n\n# Okay\nprint(f\"The alphabet starts with {b!r}\")  # The alphabet starts with b'abc'\nprint(f\"The alphabet starts with {b.decode('utf-8')}\")  # The alphabet starts with abc\n```\n\n## Check that overloaded functions don\u2019t overlap [overload-overlap][\u00b6](#check-that-overloaded-functions-don-t-overlap-overload-overlap)\n\nWarn if multiple `@overload` variants overlap in potentially unsafe ways. This guards against the following situation:\n\n```\nfrom typing import overload\n\nclass A: ...\nclass B(A): ...\n\n@overload\ndef foo(x: B) -> int: ...  # Error: Overloaded function signatures 1 and 2 overlap with incompatible return types  [overload-overlap]\n@overload\ndef foo(x: A) -> str: ...\ndef foo(x): ...\n\ndef takes_a(a: A) -> str:\n    return foo(a)\n\na: A = B()\nvalue = takes_a(a)\n# mypy will think that value is a str, but it could actually be an int\nreveal_type(value) # Revealed type is \"builtins.str\"\n```\n\nNote that in cases where you ignore this error, mypy will usually still infer the types you expect.\n\nSee [overloading](more_types.html#function-overloading) for more explanation.\n\n## Check for overload signatures that cannot match [overload-cannot-match][\u00b6](#check-for-overload-signatures-that-cannot-match-overload-cannot-match)\n\nWarn if an `@overload` variant can never be matched, because an earlier overload has a wider signature. For example, this can happen if the two overloads accept the same parameters and each parameter on the first overload has the same type or a wider type than the corresponding parameter on the second overload.\n\nExample:\n\n```\nfrom typing import overload, Union\n\n@overload\ndef process(response1: object, response2: object) -> object:\n    ...\n@overload\ndef process(response1: int, response2: int) -> int: # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader  [overload-cannot-match]\n    ...\n\ndef process(response1: object, response2: object) -> object:\n    return response1 + response2\n```\n\n## Notify about an annotation in an unchecked function [annotation-unchecked][\u00b6](#notify-about-an-annotation-in-an-unchecked-function-annotation-unchecked)\n\nSometimes a user may accidentally omit an annotation for a function, and mypy will not check the body of this function (unless one uses [--check-untyped-defs](command_line.html#cmdoption-mypy-check-untyped-defs) or [--disallow-untyped-defs](command_line.html#cmdoption-mypy-disallow-untyped-defs)). To avoid such situations go unnoticed, mypy will show a note, if there are any type annotations in an unchecked function:\n\n```\ndef test_assignment():  # \"-> None\" return annotation is missing\n    # Note: By default the bodies of untyped functions are not checked,\n    # consider using --check-untyped-defs [annotation-unchecked]\n    x: int = \"no way\"\n```\n\nNote that mypy will still exit with return code `0`, since such behaviour is specified by [PEP 484](https://peps.python.org/pep-0484/).\n\n## Decorator preceding property not supported [prop-decorator][\u00b6](#decorator-preceding-property-not-supported-prop-decorator)\n\nMypy does not yet support analysis of decorators that precede the property decorator. If the decorator does not preserve the declared type of the property, mypy will not infer the correct type for the declaration. If the decorator cannot be moved after the `@property` decorator, then you must use a type ignore comment:\n\n```\nclass MyClass:\n    @special  # type: ignore[prop-decorator]\n    @property\n    def magic(self) -> str:\n        return \"xyzzy\"\n```\n\nNote\n\nFor backward compatibility, this error code is a subcode of the generic `[misc]` code.\n\n## Report syntax errors [syntax][\u00b6](#report-syntax-errors-syntax)\n\nIf the code being checked is not syntactically valid, mypy issues a syntax error. Most, but not all, syntax errors are blocking errors: they can\u2019t be ignored with a `# type: ignore` comment.\n\n## ReadOnly key of a TypedDict is mutated [typeddict-readonly-mutated][\u00b6](#readonly-key-of-a-typeddict-is-mutated-typeddict-readonly-mutated)\n\nConsider this example:\n\n```\nfrom datetime import datetime\nfrom typing import TypedDict\nfrom typing_extensions import ReadOnly\n\nclass User(TypedDict):\n    username: ReadOnly[str]\n    last_active: datetime\n\nuser: User = {'username': 'foobar', 'last_active': datetime.now()}\nuser['last_active'] = datetime.now()  # ok\nuser['username'] = 'other'  # error: ReadOnly TypedDict key \"key\" TypedDict is mutated  [typeddict-readonly-mutated]\n```\n\n[PEP 705](https://peps.python.org/pep-0705) specifies how `ReadOnly` special form works for `TypedDict` objects.\n\n## Check that `TypeIs` narrows types [narrowed-type-not-subtype][\u00b6](#check-that-typeis-narrows-types-narrowed-type-not-subtype)\n\n[PEP 742](https://peps.python.org/pep-0742/) requires that when `TypeIs` is used, the narrowed type must be a subtype of the original type:\n\n```\nfrom typing_extensions import TypeIs\n\ndef f(x: int) -> TypeIs[str]:  # Error, str is not a subtype of int\n    ...\n\ndef g(x: object) -> TypeIs[str]:  # OK\n    ...\n```\n\n## String appears in a context which expects a TypeForm [maybe-unrecognized-str-typeform][\u00b6](#string-appears-in-a-context-which-expects-a-typeform-maybe-unrecognized-str-typeform)\n\nTypeForm literals may contain string annotations:\n\n```\ntypx1: TypeForm = str | None\ntypx2: TypeForm = 'str | None'  # OK\ntypx3: TypeForm = 'str' | None  # OK\n```\n\nHowever TypeForm literals containing a string annotation can only be recognized by mypy in the following locations:\n\n```\ntypx_var: TypeForm = 'str | None'  # assignment r-value\n\ndef func(typx_param: TypeForm) -> TypeForm:\n    return 'str | None'  # returned expression\n\nfunc('str | None')  # callable's argument\n```\n\nIf you try to use a string annotation in some other location which expects a TypeForm, the string value will always be treated as a `str` even if a `TypeForm` would be more appropriate and this error code will be generated:\n\n```\n# Error: TypeForm containing a string annotation cannot be recognized here. Surround with TypeForm(...) to recognize.  [maybe-unrecognized-str-typeform]\n# Error: List item 0 has incompatible type \"str\"; expected \"TypeForm[Any]\"  [list-item]\nlist_of_typx: list[TypeForm] = ['str | None', float]\n```\n\nFix the error by surrounding the entire type with `TypeForm(...)`:\n\n```\nlist_of_typx: list[TypeForm] = [TypeForm('str | None'), float]  # OK\n```\n\nSimilarly, if you try to use a string literal in a location which expects a TypeForm, this error code will be generated:\n\n```\ndict_of_typx = {'str_or_none': TypeForm(str | None)}\n# Error: TypeForm containing a string annotation cannot be recognized here. Surround with TypeForm(...) to recognize.  [maybe-unrecognized-str-typeform]\nlist_of_typx: list[TypeForm] = [dict_of_typx['str_or_none']]\n```\n\nFix the error by adding `# type: ignore[maybe-unrecognized-str-typeform]` to the line with the string literal:\n\n```\ndict_of_typx = {'str_or_none': TypeForm(str | None)}\nlist_of_typx: list[TypeForm] = [dict_of_typx['str_or_none']]  # type: ignore[maybe-unrecognized-str-typeform]\n```\n\n## Miscellaneous checks [misc][\u00b6](#miscellaneous-checks-misc)\n\nMypy performs numerous other, less commonly failing checks that don\u2019t have specific error codes. These use the `misc` error code. Other than being used for multiple unrelated errors, the `misc` error code is not special. For example, you can ignore all errors in this category by using `# type: ignore[misc]` comment. Since these errors are not expected to be common, it\u2019s unlikely that you\u2019ll see two different errors with the `misc` code on a single line \u2013 though this can certainly happen once in a while.\n\nNote\n\nFuture mypy versions will likely add new error codes for some errors that currently use the `misc` error code.\n"}, {"path": "linters/mypy/errors.md", "category": "linters", "name": "linters/mypy/errors", "content": "# mypy Error Codes\n\n## Type Errors\n\n### arg-type\n\nArgument has incompatible type.\n\n```python\n# BAD\ndef greet(name: str) -> str:\n    return f\"Hello, {name}\"\n\ngreet(42)  # error: Argument 1 has incompatible type \"int\"; expected \"str\"\n\n# GOOD\ngreet(\"Alice\")\n```\n\n### assignment\n\nIncompatible assignment.\n\n```python\n# BAD\nx: int = \"hello\"  # error: Incompatible types in assignment\n\n# GOOD\nx: int = 42\n```\n\n### call-arg\n\nToo many/few arguments.\n\n```python\n# BAD\ndef foo(a: int, b: int) -> int:\n    return a + b\n\nfoo(1)        # error: Missing positional argument \"b\"\nfoo(1, 2, 3)  # error: Too many arguments\n\n# GOOD\nfoo(1, 2)\n```\n\n### call-overload\n\nNo matching overload.\n\n```python\n# BAD\nfrom typing import overload\n\n@overload\ndef process(x: int) -> int: ...\n@overload\ndef process(x: str) -> str: ...\n\ndef process(x):\n    return x\n\nprocess([1, 2, 3])  # error: No overload variant matches\n\n# GOOD\nprocess(42)\nprocess(\"hello\")\n```\n\n### dict-item\n\nDict item has incompatible type.\n\n```python\n# BAD\nd: dict[str, int] = {\"a\": \"b\"}  # error: Dict entry has incompatible type\n\n# GOOD\nd: dict[str, int] = {\"a\": 1}\n```\n\n### index\n\nInvalid index type.\n\n```python\n# BAD\nlst: list[int] = [1, 2, 3]\nlst[\"0\"]  # error: Invalid index type \"str\"\n\n# GOOD\nlst[0]\n```\n\n### list-item\n\nList item has incompatible type.\n\n```python\n# BAD\nlst: list[int] = [1, \"two\", 3]  # error: List item has incompatible type\n\n# GOOD\nlst: list[int] = [1, 2, 3]\n```\n\n### operator\n\nUnsupported operand types.\n\n```python\n# BAD\n\"hello\" + 42  # error: Unsupported operand types for + (\"str\" and \"int\")\n\n# GOOD\n\"hello\" + str(42)\n```\n\n### return\n\nIncompatible return type.\n\n```python\n# BAD\ndef get_name() -> str:\n    return 42  # error: Incompatible return value type\n\n# GOOD\ndef get_name() -> str:\n    return \"Alice\"\n```\n\n### return-value\n\nReturn value expected.\n\n```python\n# BAD\ndef get_value() -> int:\n    print(\"no return\")  # error: Missing return statement\n\n# GOOD\ndef get_value() -> int:\n    return 42\n```\n\n### type-arg\n\nInvalid type argument.\n\n```python\n# BAD\nfrom typing import TypeVar\nT = TypeVar('T', bound=int)\n\ndef foo(x: T) -> T: ...\n\nfoo(\"hello\")  # error: Value of type variable \"T\" cannot be \"str\"\n\n# GOOD\nfoo(42)\n```\n\n### type-var\n\nInvalid type variable usage.\n\n```python\n# BAD\nfrom typing import TypeVar, Generic\nT = TypeVar('T')\n\nclass Foo(Generic[T]):\n    def bar(self) -> T:\n        return \"string\"  # error: Incompatible return value\n\n# GOOD\nclass Foo(Generic[T]):\n    def __init__(self, value: T) -> None:\n        self.value = value\n    \n    def bar(self) -> T:\n        return self.value\n```\n\n### union-attr\n\nAttribute not on all union members.\n\n```python\n# BAD\ndef process(x: int | str) -> None:\n    x.upper()  # error: \"int\" has no attribute \"upper\"\n\n# GOOD\ndef process(x: int | str) -> None:\n    if isinstance(x, str):\n        x.upper()\n```\n\n### var-annotated\n\nVariable needs type annotation.\n\n```python\n# BAD (with --disallow-untyped-defs)\ndef foo():\n    x = []  # error: Need type annotation for \"x\"\n    return x\n\n# GOOD\ndef foo() -> list[int]:\n    x: list[int] = []\n    return x\n```\n\n## Import Errors\n\n### import\n\nCannot find module.\n\n```python\n# BAD\nimport nonexistent_module  # error: Cannot find implementation or library stub\n\n# Fix: install the package or add type stubs\n# Or ignore: import nonexistent_module  # type: ignore[import]\n```\n\n### import-untyped\n\nImporting from untyped module.\n\n```python\n# BAD (with --disallow-untyped-imports)\nfrom untyped_lib import something  # error: Module has no type annotations\n\n# GOOD\nfrom untyped_lib import something  # type: ignore[import-untyped]\n# Or install type stubs: pip install types-untyped_lib\n```\n\n### no-redef\n\nName redefined.\n\n```python\n# BAD\ndef foo() -> int:\n    return 1\n\ndef foo() -> str:  # error: Name \"foo\" already defined\n    return \"hello\"\n\n# GOOD - use overload\nfrom typing import overload\n\n@overload\ndef foo(x: int) -> int: ...\n@overload\ndef foo(x: str) -> str: ...\n\ndef foo(x: int | str) -> int | str:\n    return x\n```\n\n## Function Errors\n\n### abstract\n\nAbstract method not implemented.\n\n```python\n# BAD\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def speak(self) -> str: ...\n\nclass Dog(Animal):  # error: Cannot instantiate abstract class\n    pass\n\n# GOOD\nclass Dog(Animal):\n    def speak(self) -> str:\n        return \"Woof\"\n```\n\n### override\n\nInvalid override.\n\n```python\n# BAD\nclass Base:\n    def foo(self, x: int) -> int:\n        return x\n\nclass Derived(Base):\n    def foo(self, x: str) -> str:  # error: Signature incompatible with supertype\n        return x\n\n# GOOD\nclass Derived(Base):\n    def foo(self, x: int) -> int:\n        return x * 2\n```\n\n### no-untyped-def\n\nFunction missing type annotations.\n\n```python\n# BAD (with --disallow-untyped-defs)\ndef add(a, b):  # error: Function is missing type annotations\n    return a + b\n\n# GOOD\ndef add(a: int, b: int) -> int:\n    return a + b\n```\n\n### no-untyped-call\n\nCalling untyped function.\n\n```python\n# BAD (with --disallow-untyped-calls)\ndef untyped(x):\n    return x\n\ndef typed(x: int) -> int:\n    return untyped(x)  # error: Call to untyped function in typed context\n\n# GOOD\ndef typed_untyped(x: int) -> int:\n    return x\n\ndef typed(x: int) -> int:\n    return typed_untyped(x)\n```\n\n## Class Errors\n\n### attr-defined\n\nAttribute not defined.\n\n```python\n# BAD\nclass Foo:\n    def __init__(self) -> None:\n        self.x = 1\n\nfoo = Foo()\nprint(foo.y)  # error: \"Foo\" has no attribute \"y\"\n\n# GOOD\nprint(foo.x)\n```\n\n### has-type\n\nCannot determine type of attribute.\n\n```python\n# BAD\nclass Foo:\n    x = None  # Cannot determine type\n\n# GOOD\nclass Foo:\n    x: int | None = None\n```\n\n### method-assign\n\nAssigning to method.\n\n```python\n# BAD\nclass Foo:\n    def bar(self) -> None: ...\n\nfoo = Foo()\nfoo.bar = lambda: None  # error: Cannot assign to a method\n\n# GOOD - use different attribute name\nfoo.custom_bar = lambda: None\n```\n\n### misc\n\nMiscellaneous errors.\n\n```python\n# Various errors that don't fit other categories\nclass Foo:\n    __slots__ = ['x']\n    y: int  # error: \"y\" not in __slots__\n```\n\n### name-defined\n\nName not defined.\n\n```python\n# BAD\nprint(undefined_var)  # error: Name \"undefined_var\" is not defined\n\n# GOOD\nundefined_var = \"now defined\"\nprint(undefined_var)\n```\n\n### safe-super\n\nUnsafe super() call.\n\n```python\n# BAD\nclass Foo:\n    @staticmethod\n    def bar() -> None:\n        super().baz()  # error: super() outside of method\n\n# GOOD\nclass Foo:\n    def bar(self) -> None:\n        super().baz()\n```\n\n### valid-type\n\nInvalid type.\n\n```python\n# BAD\nx: \"NonexistentType\"  # error: Name \"NonexistentType\" is not defined\n\n# GOOD\nfrom typing import Any\nx: Any  # or define the type\n```\n\n## Optional/None Errors\n\n### truthy-bool\n\nSuspicious boolean value.\n\n```python\n# BAD (with --strict-equality)\nfrom typing import Sequence\n\ndef foo(x: Sequence[int]) -> None:\n    if x:  # error: Sequence in boolean context\n        print(x)\n\n# GOOD - explicit check\ndef foo(x: Sequence[int]) -> None:\n    if len(x) > 0:\n        print(x)\n```\n\n### union-attr\n\nAttribute error on union.\n\n```python\n# BAD\ndef process(x: str | None) -> int:\n    return len(x)  # error: Item \"None\" has no attribute \"__len__\"\n\n# GOOD\ndef process(x: str | None) -> int:\n    if x is None:\n        return 0\n    return len(x)\n```\n\n### redundant-cast\n\nRedundant cast.\n\n```python\n# BAD\nfrom typing import cast\nx: int = 5\ny = cast(int, x)  # error: Redundant cast to \"int\"\n\n# GOOD\ny = x\n```\n\n### redundant-expr\n\nRedundant expression.\n\n```python\n# BAD\nx: int = 5\nif isinstance(x, int):  # error: Redundant isinstance call\n    pass\n\n# Remove redundant check\n```\n\n### unreachable\n\nUnreachable code.\n\n```python\n# BAD\ndef foo() -> int:\n    return 1\n    print(\"unreachable\")  # error: Statement is unreachable\n\n# GOOD\ndef foo() -> int:\n    print(\"before return\")\n    return 1\n```\n\n## Literal/Enum Errors\n\n### literal-required\n\nLiteral type required.\n\n```python\n# BAD\nfrom typing import Literal\n\ndef foo(x: Literal[\"a\", \"b\"]) -> None: ...\n\nvalue = \"a\"  # type is str\nfoo(value)  # error: Argument has incompatible type \"str\"; expected \"Literal['a', 'b']\"\n\n# GOOD\nvalue: Literal[\"a\", \"b\"] = \"a\"\nfoo(value)\n```\n\n### type-abstract\n\nCannot instantiate abstract type.\n\n```python\n# BAD\nfrom typing import Protocol\n\nclass Printable(Protocol):\n    def print(self) -> None: ...\n\nx = Printable()  # error: Cannot instantiate protocol class\n\n# GOOD\nclass Document:\n    def print(self) -> None:\n        print(\"Document\")\n\nx: Printable = Document()\n```\n\n## Strict Mode Errors\n\n### strict-equality\n\nInvalid equality comparison.\n\n```python\n# BAD (with --strict-equality)\nx: int = 5\nif x == \"5\":  # error: Non-overlapping equality check\n    pass\n\n# GOOD\nif str(x) == \"5\":\n    pass\n```\n\n### no-any-return\n\nReturning Any.\n\n```python\n# BAD (with --warn-return-any)\nfrom typing import Any\n\ndef foo() -> str:\n    x: Any = get_value()\n    return x  # error: Returning Any from function with declared return type \"str\"\n\n# GOOD\ndef foo() -> str:\n    x: Any = get_value()\n    return str(x)\n```\n\n### no-any-expr\n\nExpression has type Any.\n\n```python\n# BAD (with --disallow-any-expr)\nfrom typing import Any\nx: Any = 5\ny = x + 1  # error: Expression has type \"Any\"\n\n# GOOD\nx: int = 5\ny = x + 1\n```\n"}]}
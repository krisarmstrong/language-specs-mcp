{"language": "python", "generatedAt": "2026-01-05T15:15:58.812221+00:00", "entries": [{"path": "pep8.md", "category": "spec", "name": "pep8", "content": "# PEP 8 - Python Style Guide (Summary)\n\n## Indentation\n\n- Use 4 spaces per indentation level\n- Never mix tabs and spaces\n\n## Maximum Line Length\n\n- Limit lines to 79 characters (code)\n- Limit lines to 72 characters (docstrings/comments)\n- Can extend to 99 for teams that agree\n\n## Imports\n\n```python\n# Standard library\nimport os\nimport sys\n\n# Third party\nimport numpy as np\nimport pandas as pd\n\n# Local\nfrom mypackage import mymodule\n```\n\n- One import per line\n- Absolute imports preferred\n- Avoid wildcard imports (`from x import *`)\n\n## Whitespace\n\n```python\n# GOOD\nspam(ham[1], {eggs: 2})\nfoo = (0,)\nif x == 4: print(x, y); x, y = y, x\n\n# BAD\nspam( ham[ 1 ], { eggs: 2 } )\nfoo = (0, )\nif x == 4 : print(x , y) ; x , y = y , x\n```\n\n## Naming Conventions\n\n| Type | Convention |\n|------|------------|\n| Modules | `lowercase_with_underscores` |\n| Classes | `CapWords` |\n| Functions | `lowercase_with_underscores` |\n| Variables | `lowercase_with_underscores` |\n| Constants | `UPPERCASE_WITH_UNDERSCORES` |\n| Private | `_single_leading_underscore` |\n| \"Mangled\" | `__double_leading_underscore` |\n\n## Type Hints (PEP 484)\n\n```python\ndef greeting(name: str) -> str:\n    return f\"Hello, {name}\"\n\ndef process(items: list[int]) -> dict[str, int]:\n    return {\"count\": len(items)}\n```\n"}, {"path": "patterns/idioms.md", "category": "patterns", "name": "patterns/idioms", "content": "# Python Idiomatic Patterns (3.10+)\n\n## Type Hints (Always Use)\n\n```python\n# BAD\ndef process(data):\n    return data.get(\"value\")\n\n# GOOD\ndef process(data: dict[str, Any]) -> str | None:\n    return data.get(\"value\")\n```\n\n## Match Statements (3.10+)\n\n```python\ndef handle_response(response: Response) -> str:\n    match response.status:\n        case 200:\n            return response.body\n        case 404:\n            raise NotFoundError()\n        case 500:\n            raise ServerError()\n        case _:\n            raise UnknownError(response.status)\n```\n\n## Dataclasses\n\n```python\nfrom dataclasses import dataclass\n\n# BAD - boilerplate\nclass User:\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n    \n    def __repr__(self):\n        return f\"User(name={self.name!r}, age={self.age})\"\n\n# GOOD\n@dataclass\nclass User:\n    name: str\n    age: int\n```\n\n## Context Managers\n\n```python\n# File handling\nwith open(\"file.txt\") as f:\n    content = f.read()\n\n# Multiple contexts\nwith (\n    open(\"input.txt\") as infile,\n    open(\"output.txt\", \"w\") as outfile,\n):\n    outfile.write(infile.read())\n\n# Custom context manager\nfrom contextlib import contextmanager\n\n@contextmanager\ndef timer():\n    start = time.time()\n    yield\n    print(f\"Elapsed: {time.time() - start:.2f}s\")\n```\n\n## List/Dict/Set Comprehensions\n\n```python\n# List\nsquares = [x**2 for x in range(10)]\n\n# Dict\ncounts = {word: len(word) for word in words}\n\n# Set\nunique_lengths = {len(word) for word in words}\n\n# Generator (memory efficient)\nsquares_gen = (x**2 for x in range(10))\n```\n\n## Walrus Operator (3.8+)\n\n```python\n# Read until empty\nwhile (line := file.readline()):\n    process(line)\n\n# Check and use\nif (match := pattern.search(text)):\n    print(match.group())\n```\n\n## f-strings (Always Use)\n\n```python\n# BAD\n\"Hello, \" + name + \"!\"\n\"Hello, {}!\".format(name)\n\"Hello, %s!\" % name\n\n# GOOD\nf\"Hello, {name}!\"\nf\"Value: {value:.2f}\"\nf\"Debug: {obj=}\"  # Shows 'obj=<value>'\n```\n\n## Exception Handling\n\n```python\n# Specific exceptions\ntry:\n    value = data[\"key\"]\nexcept KeyError:\n    value = default\n\n# Exception groups (3.11+)\ntry:\n    async with asyncio.TaskGroup() as tg:\n        tg.create_task(task1())\n        tg.create_task(task2())\nexcept* ValueError as eg:\n    for exc in eg.exceptions:\n        handle(exc)\n```\n\n## Pathlib (Not os.path)\n\n```python\n# BAD\nimport os\npath = os.path.join(base, \"subdir\", \"file.txt\")\nif os.path.exists(path):\n    with open(path) as f:\n        pass\n\n# GOOD\nfrom pathlib import Path\npath = Path(base) / \"subdir\" / \"file.txt\"\nif path.exists():\n    content = path.read_text()\n```\n\n## Enum\n\n```python\nfrom enum import Enum, auto\n\nclass Status(Enum):\n    PENDING = auto()\n    RUNNING = auto()\n    COMPLETE = auto()\n    FAILED = auto()\n\ndef handle(status: Status) -> None:\n    match status:\n        case Status.PENDING:\n            start()\n        case Status.COMPLETE:\n            cleanup()\n```\n\n## functools\n\n```python\nfrom functools import cache, lru_cache, partial\n\n@cache  # Unbounded cache\ndef fibonacci(n: int) -> int:\n    if n < 2:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\n@lru_cache(maxsize=128)  # Bounded cache\ndef expensive(x: int) -> int:\n    return compute(x)\n```\n"}, {"path": "formatters/ruff.md", "category": "formatters", "name": "formatters/ruff", "content": "# ruff format Options\n\nSee: https://docs.astral.sh/ruff/formatter/\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# Python Formatters\n\n## black\n\nSee: https://black.readthedocs.io/en/stable/\n\n## ruff format\n\nSee: https://docs.astral.sh/ruff/formatter/\n"}, {"path": "formatters/black.md", "category": "formatters", "name": "formatters/black", "content": "# black Options\nVersion: unknown\n\nSource: https://black.readthedocs.io/en/stable/usage_and_configuration/the_basics.html\n\n\nSee: https://black.readthedocs.io/en/stable/usage_and_configuration/the_basics.html\n"}, {"path": "stdlib/overview.md", "category": "stdlib", "name": "stdlib/overview", "content": "# Python Standard Library Quick Reference\n\n## Essential Modules\n\n| Module | Purpose |\n|--------|---------|\n| `pathlib` | File paths (use over os.path) |\n| `json` | JSON encoding/decoding |\n| `dataclasses` | Data containers |\n| `typing` | Type hints |\n| `collections` | Specialized containers |\n| `itertools` | Iterator utilities |\n| `functools` | Higher-order functions |\n| `contextlib` | Context manager utilities |\n| `asyncio` | Async I/O |\n| `logging` | Logging facility |\n| `re` | Regular expressions |\n| `datetime` | Date and time |\n| `enum` | Enumerations |\n| `abc` | Abstract base classes |\n\n## Type Hints (typing module)\n\n```python\nfrom typing import Any, TypeVar, Generic\nfrom collections.abc import Callable, Iterator, Mapping\n\n# Basic\nx: int = 1\ny: str | None = None\nz: list[int] = [1, 2, 3]\n\n# Callable\nHandler = Callable[[Request], Response]\n\n# Generic\nT = TypeVar(\"T\")\n\nclass Stack(Generic[T]):\n    def push(self, item: T) -> None: ...\n    def pop(self) -> T: ...\n```\n\n## Collections\n\n```python\nfrom collections import defaultdict, Counter, deque, namedtuple\n\n# defaultdict - auto-initialize missing keys\ncounts = defaultdict(int)\ncounts[\"a\"] += 1\n\n# Counter - count occurrences\nc = Counter(\"abracadabra\")\nc.most_common(3)  # [('a', 5), ('b', 2), ('r', 2)]\n\n# deque - efficient double-ended queue\nd = deque(maxlen=3)\nd.append(1)\nd.appendleft(0)\n\n# namedtuple (prefer dataclass for new code)\nPoint = namedtuple(\"Point\", [\"x\", \"y\"])\n```\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# Python 3.14 Language Specification\nVersion: unknown\n\nSource: https://docs.python.org/3.14/\n\n\n## Keywords\n\n```python\nFalse       await       else        import      pass\nNone        break       except      in          raise\nTrue        class       finally     is          return\nand         continue    for         lambda      try\nas          def         from        nonlocal    while\nassert      del         global      not         with\nasync       elif        if          or          yield\nmatch       case        type        _\n```\n\n## Basic Types\n\n### Numeric Types\n\n```python\nint         # arbitrary precision integer\nfloat       # IEEE 754 double precision\ncomplex     # complex number (3+4j)\nbool        # True or False (subclass of int)\n```\n\n### Sequence Types\n\n```python\nstr         # immutable text sequence\nbytes       # immutable byte sequence\nbytearray   # mutable byte sequence\nlist        # mutable sequence\ntuple       # immutable sequence\nrange       # immutable sequence of numbers\n```\n\n### Set Types\n\n```python\nset         # mutable unordered collection of unique items\nfrozenset   # immutable set\n```\n\n### Mapping Types\n\n```python\ndict        # mutable key-value mapping\n```\n\n### None Type\n\n```python\nNone        # singleton null value\n```\n\n## Type Annotations (PEP 484, 604)\n\n### Basic Annotations\n\n```python\nx: int = 1\nname: str = \"hello\"\nvalues: list[int] = [1, 2, 3]\nmapping: dict[str, int] = {\"a\": 1}\n```\n\n### Optional and Union (3.10+)\n\n```python\n# Old style\nfrom typing import Optional, Union\nx: Optional[int] = None\ny: Union[int, str] = 1\n\n# New style (3.10+)\nx: int | None = None\ny: int | str = 1\n```\n\n### Callable\n\n```python\nfrom collections.abc import Callable\n\nHandler = Callable[[int, str], bool]\n\ndef process(handler: Handler) -> None:\n    result = handler(1, \"hello\")\n```\n\n### Generic Types\n\n```python\nfrom typing import TypeVar, Generic\n\nT = TypeVar(\"T\")\n\nclass Stack(Generic[T]):\n    def __init__(self) -> None:\n        self._items: list[T] = []\n    \n    def push(self, item: T) -> None:\n        self._items.append(item)\n    \n    def pop(self) -> T:\n        return self._items.pop()\n```\n\n### Type Alias (3.12+)\n\n```python\n# Old style\nIntList = list[int]\n\n# New style (3.12+)\ntype IntList = list[int]\ntype Point = tuple[int, int]\n```\n\n## Functions\n\n### Basic Functions\n\n```python\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\n# Default arguments\ndef greet(name: str = \"World\") -> str:\n    return f\"Hello, {name}!\"\n\n# *args and **kwargs\ndef log(*args: object, **kwargs: object) -> None:\n    print(*args, **kwargs)\n```\n\n### Lambda\n\n```python\nsquare = lambda x: x ** 2\nadd = lambda a, b: a + b\n```\n\n### Decorators\n\n```python\nfrom functools import wraps\n\ndef logged(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__}\")\n        return func(*args, **kwargs)\n    return wrapper\n\n@logged\ndef process(data: str) -> None:\n    pass\n```\n\n### Generators\n\n```python\ndef countdown(n: int):\n    while n > 0:\n        yield n\n        n -= 1\n\n# Generator expression\nsquares = (x ** 2 for x in range(10))\n```\n\n## Classes\n\n### Basic Class\n\n```python\nclass Point:\n    def __init__(self, x: int, y: int) -> None:\n        self.x = x\n        self.y = y\n    \n    def distance(self, other: \"Point\") -> float:\n        return ((self.x - other.x) ** 2 + (self.y - other.y) ** 2) ** 0.5\n    \n    def __repr__(self) -> str:\n        return f\"Point({self.x}, {self.y})\"\n```\n\n### Dataclasses\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: int\n    y: int\n    \n@dataclass(frozen=True)\nclass ImmutablePoint:\n    x: int\n    y: int\n\n@dataclass\nclass Config:\n    host: str = \"localhost\"\n    port: int = 8080\n    debug: bool = False\n```\n\n### Inheritance\n\n```python\nclass Animal:\n    def speak(self) -> str:\n        raise NotImplementedError\n\nclass Dog(Animal):\n    def speak(self) -> str:\n        return \"Woof!\"\n\n# Multiple inheritance\nclass Flying:\n    def fly(self) -> None:\n        pass\n\nclass Bird(Animal, Flying):\n    def speak(self) -> str:\n        return \"Chirp!\"\n```\n\n### Properties\n\n```python\nclass Circle:\n    def __init__(self, radius: float) -> None:\n        self._radius = radius\n    \n    @property\n    def radius(self) -> float:\n        return self._radius\n    \n    @radius.setter\n    def radius(self, value: float) -> None:\n        if value < 0:\n            raise ValueError(\"Radius must be positive\")\n        self._radius = value\n    \n    @property\n    def area(self) -> float:\n        return 3.14159 * self._radius ** 2\n```\n\n### Class Methods and Static Methods\n\n```python\nclass Date:\n    def __init__(self, year: int, month: int, day: int) -> None:\n        self.year = year\n        self.month = month\n        self.day = day\n    \n    @classmethod\n    def from_string(cls, date_string: str) -> \"Date\":\n        year, month, day = map(int, date_string.split(\"-\"))\n        return cls(year, month, day)\n    \n    @staticmethod\n    def is_valid(year: int, month: int, day: int) -> bool:\n        return 1 <= month <= 12 and 1 <= day <= 31\n```\n\n## Control Flow\n\n### Match Statement (3.10+)\n\n```python\nmatch command:\n    case \"quit\":\n        return\n    case \"help\":\n        show_help()\n    case [\"move\", direction]:\n        move(direction)\n    case {\"action\": action, \"target\": target}:\n        perform(action, target)\n    case _:\n        print(\"Unknown command\")\n\n# With guards\nmatch point:\n    case Point(x, y) if x == y:\n        print(\"On diagonal\")\n    case Point(x, y):\n        print(f\"At ({x}, {y})\")\n```\n\n### Exception Handling\n\n```python\ntry:\n    result = risky_operation()\nexcept ValueError as e:\n    handle_value_error(e)\nexcept (TypeError, KeyError) as e:\n    handle_other(e)\nexcept Exception as e:\n    logger.exception(\"Unexpected error\")\n    raise\nelse:\n    # Only runs if no exception\n    process(result)\nfinally:\n    # Always runs\n    cleanup()\n```\n\n### Exception Groups (3.11+)\n\n```python\ntry:\n    async with asyncio.TaskGroup() as tg:\n        tg.create_task(task1())\n        tg.create_task(task2())\nexcept* ValueError as eg:\n    for exc in eg.exceptions:\n        handle(exc)\nexcept* TypeError as eg:\n    for exc in eg.exceptions:\n        handle(exc)\n```\n\n## Context Managers\n\n```python\n# Using with statement\nwith open(\"file.txt\") as f:\n    content = f.read()\n\n# Multiple context managers\nwith (\n    open(\"input.txt\") as infile,\n    open(\"output.txt\", \"w\") as outfile,\n):\n    outfile.write(infile.read())\n\n# Custom context manager (class)\nclass Timer:\n    def __enter__(self):\n        self.start = time.time()\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.elapsed = time.time() - self.start\n        return False  # Don't suppress exceptions\n\n# Custom context manager (decorator)\nfrom contextlib import contextmanager\n\n@contextmanager\ndef timer():\n    start = time.time()\n    yield\n    print(f\"Elapsed: {time.time() - start:.2f}s\")\n```\n\n## Async/Await\n\n```python\nimport asyncio\n\nasync def fetch(url: str) -> str:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            return await response.text()\n\nasync def main() -> None:\n    # Concurrent execution\n    results = await asyncio.gather(\n        fetch(\"https://example.com/1\"),\n        fetch(\"https://example.com/2\"),\n        fetch(\"https://example.com/3\"),\n    )\n    \n    # Task groups (3.11+)\n    async with asyncio.TaskGroup() as tg:\n        task1 = tg.create_task(fetch(url1))\n        task2 = tg.create_task(fetch(url2))\n    # All tasks complete here\n\nasyncio.run(main())\n```\n\n### Async Generators\n\n```python\nasync def countdown(n: int):\n    while n > 0:\n        yield n\n        await asyncio.sleep(1)\n        n -= 1\n\nasync def main():\n    async for i in countdown(5):\n        print(i)\n```\n\n## Comprehensions\n\n```python\n# List comprehension\nsquares = [x ** 2 for x in range(10)]\nevens = [x for x in range(20) if x % 2 == 0]\n\n# Dict comprehension\nword_lengths = {word: len(word) for word in words}\n\n# Set comprehension\nunique_lengths = {len(word) for word in words}\n\n# Generator expression\nsum_squares = sum(x ** 2 for x in range(10))\n\n# Nested comprehension\nmatrix = [[i * j for j in range(5)] for i in range(5)]\n```\n\n## Walrus Operator (3.8+)\n\n```python\n# Assignment expression\nif (n := len(data)) > 10:\n    print(f\"Too long: {n}\")\n\n# In loops\nwhile (line := file.readline()):\n    process(line)\n\n# In comprehensions\nresults = [y for x in data if (y := transform(x)) is not None]\n```\n\n## F-Strings\n\n```python\nname = \"Alice\"\nage = 30\n\n# Basic\nprint(f\"Hello, {name}!\")\n\n# Expressions\nprint(f\"Next year: {age + 1}\")\n\n# Formatting\nprint(f\"Value: {value:.2f}\")\nprint(f\"Hex: {num:#x}\")\nprint(f\"Padded: {name:>10}\")\n\n# Debug (3.8+)\nprint(f\"{name=}\")  # prints: name='Alice'\nprint(f\"{age=}\")   # prints: age=30\n```\n\n## Structural Pattern Matching (3.10+)\n\n```python\n# Literal patterns\nmatch status:\n    case 200:\n        return \"OK\"\n    case 404:\n        return \"Not Found\"\n    case 500:\n        return \"Server Error\"\n\n# Class patterns\nmatch event:\n    case Click(x=x, y=y):\n        handle_click(x, y)\n    case KeyPress(key=\"q\"):\n        quit()\n\n# Sequence patterns\nmatch command:\n    case [\"move\", *directions]:\n        for d in directions:\n            move(d)\n    case [\"quit\"]:\n        return\n\n# Mapping patterns\nmatch config:\n    case {\"debug\": True, **rest}:\n        enable_debug(rest)\n    case {\"host\": host, \"port\": port}:\n        connect(host, port)\n\n# Guard patterns\nmatch point:\n    case Point(x, y) if x == y:\n        print(\"On diagonal\")\n```\n"}, {"path": "linters/ruff/pyupgrade.md", "category": "linters", "name": "linters/ruff/pyupgrade", "content": "# Ruff - pyupgrade Rules (UP)\n\nModernize Python code to newer syntax.\n\n## UP001: Remove __metaclass__ = type\n\n```python\n# BAD (Python 2)\nclass Foo:\n    __metaclass__ = type\n\n# GOOD (Python 3)\nclass Foo:\n    pass\n```\n\n## UP003: Use type(...) instead of type(...)\n\n```python\n# BAD\ntype(\"Foo\", (object,), {})\n\n# GOOD (if dynamic class needed)\ntype(\"Foo\", (), {})\n```\n\n## UP004: Remove useless object inheritance\n\n```python\n# BAD\nclass Foo(object):\n    pass\n\n# GOOD\nclass Foo:\n    pass\n```\n\n## UP005: Replace deprecated unittest aliases\n\n```python\n# BAD\nself.assertEquals(a, b)\nself.assertNotEquals(a, b)\n\n# GOOD\nself.assertEqual(a, b)\nself.assertNotEqual(a, b)\n```\n\n## UP006: Use type instead of Type for builtin\n\n```python\n# BAD (Python 3.9+)\nfrom typing import List, Dict, Tuple\n\ndef foo(x: List[int]) -> Dict[str, int]:\n    pass\n\n# GOOD\ndef foo(x: list[int]) -> dict[str, int]:\n    pass\n```\n\n## UP007: Use X | Y instead of Union\n\n```python\n# BAD (Python 3.10+)\nfrom typing import Union, Optional\n\ndef foo(x: Union[int, str]) -> Optional[str]:\n    pass\n\n# GOOD\ndef foo(x: int | str) -> str | None:\n    pass\n```\n\n## UP008: Use super() without arguments\n\n```python\n# BAD\nclass Foo(Bar):\n    def __init__(self):\n        super(Foo, self).__init__()\n\n# GOOD\nclass Foo(Bar):\n    def __init__(self):\n        super().__init__()\n```\n\n## UP009: UTF-8 encoding declaration is unnecessary\n\n```python\n# BAD (Python 3 default is UTF-8)\n# -*- coding: utf-8 -*-\n\n# GOOD - remove it\n```\n\n## UP010: Remove unnecessary __future__ imports\n\n```python\n# BAD (Python 3)\nfrom __future__ import print_function\nfrom __future__ import division\n\n# GOOD - remove them (already default in Python 3)\n```\n\n## UP011: Remove unnecessary parentheses in class definition\n\n```python\n# BAD\nclass Foo():\n    pass\n\n# GOOD\nclass Foo:\n    pass\n```\n\n## UP012: Use f-string instead of format\n\n```python\n# BAD\n\"Hello {}\".format(name)\n\"Hello {name}\".format(name=name)\n\n# GOOD\nf\"Hello {name}\"\n```\n\n## UP013: Use TypedDict class syntax\n\n```python\n# BAD\nMyDict = TypedDict(\"MyDict\", {\"a\": int, \"b\": str})\n\n# GOOD\nclass MyDict(TypedDict):\n    a: int\n    b: str\n```\n\n## UP014: Use NamedTuple class syntax\n\n```python\n# BAD\nPoint = namedtuple(\"Point\", [\"x\", \"y\"])\n\n# GOOD\nclass Point(NamedTuple):\n    x: int\n    y: int\n```\n\n## UP015: Remove redundant open mode\n\n```python\n# BAD\nopen(\"file\", \"r\")\nopen(\"file\", mode=\"r\")\n\n# GOOD\nopen(\"file\")\n```\n\n## UP017: Use datetime.UTC\n\n```python\n# BAD (Python 3.11+)\nimport datetime\ndatetime.timezone.utc\n\n# GOOD\nimport datetime\ndatetime.UTC\n```\n\n## UP018: Remove native literal\n\n```python\n# BAD\nstr(\"hello\")\nint(42)\nfloat(3.14)\nbool(True)\n\n# GOOD\n\"hello\"\n42\n3.14\nTrue\n```\n\n## UP024: Replace aliased error with original\n\n```python\n# BAD\ntry:\n    pass\nexcept IOError:  # alias for OSError\n    pass\n\n# GOOD\ntry:\n    pass\nexcept OSError:\n    pass\n```\n\n## UP025: Remove unicode literal prefix\n\n```python\n# BAD (Python 3)\nu\"hello\"\nu'world'\n\n# GOOD\n\"hello\"\n\"world\"\n```\n\n## UP026: Replace deprecated mock imports\n\n```python\n# BAD\nfrom mock import Mock\n\n# GOOD\nfrom unittest.mock import Mock\n```\n\n## UP027: Unpack list comprehension\n\n```python\n# BAD\n[*[x for x in items]]\n\n# GOOD\n[x for x in items]\n```\n\n## UP028: Use yield from\n\n```python\n# BAD\nfor item in iterable:\n    yield item\n\n# GOOD\nyield from iterable\n```\n\n## UP029: Remove unnecessary default encoding\n\n```python\n# BAD\n\"hello\".encode(\"utf-8\")\nb\"hello\".decode(\"utf-8\")\n\n# GOOD\n\"hello\".encode()\nb\"hello\".decode()\n```\n\n## UP030: Use implicit format spec\n\n```python\n# BAD\n\"{0}\".format(value)\n\"{0:}\".format(value)\n\n# GOOD\n\"{}\".format(value)\nf\"{value}\"\n```\n\n## UP031: Use f-string instead of % formatting\n\n```python\n# BAD\n\"Hello %s\" % name\n\"Hello %(name)s\" % {\"name\": name}\n\n# GOOD\nf\"Hello {name}\"\n```\n\n## UP032: Use f-string instead of .format\n\n```python\n# BAD\n\"Hello {}\".format(name)\n\n# GOOD\nf\"Hello {name}\"\n```\n\n## UP033: Use @functools.cache\n\n```python\n# BAD (Python 3.9+)\n@functools.lru_cache(maxsize=None)\ndef expensive():\n    pass\n\n# GOOD\n@functools.cache\ndef expensive():\n    pass\n```\n\n## UP034: Use exponentiation operator\n\n```python\n# BAD\npow(2, 3)\n\n# GOOD\n2 ** 3\n```\n\n## UP035: Deprecated imports\n\n```python\n# BAD (Python 3.9+)\nfrom typing import List, Dict, Tuple, Set\n\n# GOOD - use builtins\nlist, dict, tuple, set\n\n# BAD (Python 3.9+)\nfrom typing import Callable, Iterable\n\n# GOOD\nfrom collections.abc import Callable, Iterable\n```\n\n## UP036: Remove version block for old Python\n\n```python\n# BAD\nimport sys\nif sys.version_info >= (3, 0):\n    pass  # we're on Python 3 anyway\n\n# GOOD - remove version check\n```\n\n## UP037: Remove quotes from type annotation\n\n```python\n# BAD (with __future__ annotations)\ndef foo() -> \"int\":\n    pass\n\n# GOOD\ndef foo() -> int:\n    pass\n```\n\n## UP038: Use X | Y in isinstance\n\n```python\n# BAD (Python 3.10+)\nisinstance(x, (int, str))\n\n# GOOD\nisinstance(x, int | str)\n```\n\n## UP039: Unnecessary parentheses after class\n\n```python\n# BAD\nclass Foo(A, B,):\n\n# GOOD\nclass Foo(A, B):\n```\n\n## UP040: Use TypeAlias for type aliases\n\n```python\n# BAD (Python 3.10+)\nIntList = list[int]\n\n# GOOD\nIntList: TypeAlias = list[int]\n\n# BETTER (Python 3.12+)\ntype IntList = list[int]\n```\n\n## UP041: Replace timeout classes\n\n```python\n# BAD (Python 3.11+)\nasyncio.TimeoutError\n\n# GOOD\nTimeoutError\n```\n\n## UP043: Use root logging methods\n\n```python\n# BAD\nlogging.getLogger().warning(\"message\")\n\n# GOOD\nlogging.warning(\"message\")\n```\n"}, {"path": "linters/ruff/overview.md", "category": "linters", "name": "linters/ruff/overview", "content": "# Ruff Linter Rules\nVersion: unknown\n\nSource: https://docs.astral.sh/ruff/rules/\n\n\nRuff implements rules from:\n- Pyflakes (F)\n- pycodestyle (E, W)\n- isort (I)\n- pep8-naming (N)\n- pyupgrade (UP)\n- flake8-* plugins\n- pylint (PL)\n- ruff-specific (RUF)\n\n## Essential Rules\n\n| Code | Rule | Fix |\n|------|------|-----|\n| F401 | Unused import | Remove |\n| F841 | Unused variable | Remove or prefix with _ |\n| E501 | Line too long | Break line |\n| E711 | Comparison to None | Use `is None` |\n| E712 | Comparison to True/False | Use truthiness |\n| UP006 | Use `list` instead of `List` | Modernize |\n| UP007 | Use `X | Y` instead of `Union` | Modernize |\n\n## Configuration\n\n```toml\n# pyproject.toml\n[tool.ruff]\nline-length = 100\ntarget-version = \"py312\"\n\n[tool.ruff.lint]\nselect = [\n    \"E\",   # pycodestyle errors\n    \"W\",   # pycodestyle warnings\n    \"F\",   # pyflakes\n    \"I\",   # isort\n    \"UP\",  # pyupgrade\n    \"N\",   # pep8-naming\n    \"RUF\", # ruff-specific\n]\nignore = [\"E501\"]  # if you want longer lines\n```\n"}, {"path": "linters/ruff/pyflakes-pycodestyle.md", "category": "linters", "name": "linters/ruff/pyflakes-pycodestyle", "content": "# Ruff Linter - Complete Reference\n\nRuff is an extremely fast Python linter written in Rust. Implements 800+ rules from:\n- Pyflakes (F)\n- pycodestyle (E, W)\n- isort (I)\n- pep8-naming (N)\n- pyupgrade (UP)\n- flake8-bugbear (B)\n- flake8-comprehensions (C4)\n- flake8-simplify (SIM)\n- pylint (PL)\n- ruff-specific (RUF)\n\n## Configuration\n\n```toml\n# pyproject.toml\n[tool.ruff]\ntarget-version = \"py312\"\nline-length = 100\n\n[tool.ruff.lint]\nselect = [\n    \"E\",      # pycodestyle errors\n    \"W\",      # pycodestyle warnings\n    \"F\",      # Pyflakes\n    \"I\",      # isort\n    \"N\",      # pep8-naming\n    \"UP\",     # pyupgrade\n    \"B\",      # flake8-bugbear\n    \"C4\",     # flake8-comprehensions\n    \"SIM\",    # flake8-simplify\n    \"PL\",     # pylint\n    \"RUF\",    # ruff-specific\n    \"PERF\",   # performance\n    \"FURB\",   # refurb\n]\nignore = [\n    \"E501\",   # line too long (if you want)\n]\n\n[tool.ruff.lint.per-file-ignores]\n\"tests/*\" = [\"S101\"]  # allow assert in tests\n\"__init__.py\" = [\"F401\"]  # allow unused imports\n\n[tool.ruff.lint.isort]\nknown-first-party = [\"mypackage\"]\n```\n\n## Pyflakes (F) - Critical Errors\n\n### F401: Module imported but unused\n\n```python\n# BAD\nimport os  # never used\n\n# GOOD\nimport os\nos.getcwd()\n\n# Or explicit re-export\nfrom .module import helper as helper  # noqa: F401\n```\n\n### F402: Import shadowed by loop variable\n\n```python\n# BAD\nfrom os import path\nfor path in paths:  # shadows import!\n    print(path)\n\n# GOOD\nfrom os import path\nfor p in paths:\n    print(p)\n```\n\n### F403: `from module import *` used\n\n```python\n# BAD\nfrom os import *\n\n# GOOD\nfrom os import path, getcwd\n```\n\n### F405: Name may be undefined from star import\n\n```python\n# BAD\nfrom os import *\nprint(getcwd())  # undefined if * import fails\n\n# GOOD\nfrom os import getcwd\nprint(getcwd())\n```\n\n### F501-F509: Invalid format strings\n\n```python\n# F501: Invalid format string\n\"{\".format()  # missing closing brace\n\n# F502: Positional placeholder not needed\n\"{0}\".format(x, y)  # y unused\n\n# F504: % format unused argument\n\"%s\" % (x, y)  # y unused\n\n# F506: % format missing argument\n\"%s %s\" % (x,)  # missing second arg\n```\n\n### F521: `.format` invalid format string\n\n```python\n# BAD\n\"{0} {2}\".format(a, b)  # no {1}\n\n# GOOD\n\"{0} {1}\".format(a, b)\n```\n\n### F522: `.format` unused positional arguments\n\n```python\n# BAD\n\"{0}\".format(a, b, c)  # b, c unused\n\n# GOOD\n\"{0} {1} {2}\".format(a, b, c)\n```\n\n### F523: `.format` unused keyword arguments\n\n```python\n# BAD\n\"{name}\".format(name=x, unused=y)\n\n# GOOD\n\"{name}\".format(name=x)\n```\n\n### F601: Dictionary key literal duplicated\n\n```python\n# BAD\nd = {\"a\": 1, \"a\": 2}  # duplicate key\n\n# GOOD\nd = {\"a\": 1, \"b\": 2}\n```\n\n### F631: Assert tuple (always true)\n\n```python\n# BAD\nassert (condition, \"message\")  # always True!\n\n# GOOD\nassert condition, \"message\"\n```\n\n### F632: Use `==` to compare to string literal\n\n```python\n# BAD\nif x is \"hello\":  # identity, not equality\n\n# GOOD\nif x == \"hello\":\n```\n\n### F811: Redefinition of unused name\n\n```python\n# BAD\ndef foo(): pass\ndef foo(): pass  # redefines\n\n# GOOD\ndef foo_v1(): pass\ndef foo_v2(): pass\n```\n\n### F821: Undefined name\n\n```python\n# BAD\nprint(undefined_var)\n\n# GOOD\nundefined_var = \"defined\"\nprint(undefined_var)\n```\n\n### F823: Local variable referenced before assignment\n\n```python\n# BAD\ndef foo():\n    print(x)  # referenced before assignment\n    x = 1\n\n# GOOD\ndef foo():\n    x = 1\n    print(x)\n```\n\n### F841: Local variable assigned but never used\n\n```python\n# BAD\ndef foo():\n    x = compute()  # never used\n    return 5\n\n# GOOD\ndef foo():\n    _ = compute()  # explicit ignore\n    return 5\n```\n\n### F901: `raise NotImplemented` should be `NotImplementedError`\n\n```python\n# BAD\nraise NotImplemented  # type, not exception\n\n# GOOD\nraise NotImplementedError\n```\n\n## pycodestyle (E/W) - Style\n\n### E101: Indentation contains mixed spaces and tabs\n\n### E111: Indentation is not a multiple of four\n\n```python\n# BAD\nif True:\n   x = 1  # 3 spaces\n\n# GOOD\nif True:\n    x = 1  # 4 spaces\n```\n\n### E117: Over-indented\n\n### E122-E131: Continuation line issues\n\n### E201-E203: Whitespace issues\n\n```python\n# BAD\nspam( ham[ 1 ], { eggs: 2 } )\n\n# GOOD\nspam(ham[1], {eggs: 2})\n```\n\n### E225-E228: Missing whitespace around operator\n\n```python\n# BAD\nx=1\ny = x+1\n\n# GOOD\nx = 1\ny = x + 1\n```\n\n### E231: Missing whitespace after ','\n\n```python\n# BAD\nfunc(a,b,c)\n\n# GOOD\nfunc(a, b, c)\n```\n\n### E251: Unexpected spaces around keyword / parameter equals\n\n```python\n# BAD\ndef foo(x = 1):\n    pass\n\n# GOOD\ndef foo(x=1):\n    pass\n```\n\n### E262: Inline comment should start with '# '\n\n```python\n# BAD\nx = 1  #comment\n\n# GOOD\nx = 1  # comment\n```\n\n### E265: Block comment should start with '# '\n\n### E266: Too many leading '#' for block comment\n\n### E302: Expected 2 blank lines, found N\n\n### E303: Too many blank lines\n\n### E304: Blank lines found after function decorator\n\n### E305: Expected 2 blank lines after class or function definition\n\n### E401: Multiple imports on one line\n\n```python\n# BAD\nimport os, sys\n\n# GOOD\nimport os\nimport sys\n```\n\n### E402: Module level import not at top of file\n\n### E501: Line too long\n\n### E701-E704: Multiple statements on one line\n\n```python\n# BAD\nif x: return True\n\n# GOOD\nif x:\n    return True\n```\n\n### E711: Comparison to None\n\n```python\n# BAD\nif x == None:\nif x != None:\n\n# GOOD\nif x is None:\nif x is not None:\n```\n\n### E712: Comparison to True/False\n\n```python\n# BAD\nif x == True:\nif x == False:\n\n# GOOD\nif x:\nif not x:\n\n# Exception: pandas/numpy boolean indexing\ndf[df[\"col\"] == True]  # sometimes needed\n```\n\n### E713: Not in test\n\n```python\n# BAD\nif not x in collection:\n\n# GOOD\nif x not in collection:\n```\n\n### E714: Not is test\n\n```python\n# BAD\nif not x is None:\n\n# GOOD\nif x is not None:\n```\n\n### E721: Type comparison\n\n```python\n# BAD\nif type(x) == int:\n\n# GOOD\nif isinstance(x, int):\n```\n\n### E722: Bare except\n\n```python\n# BAD\ntry:\n    risky()\nexcept:\n    pass\n\n# GOOD\ntry:\n    risky()\nexcept Exception:\n    pass\n```\n\n### E731: Do not assign a lambda expression\n\n```python\n# BAD\nf = lambda x: x + 1\n\n# GOOD\ndef f(x):\n    return x + 1\n```\n\n### E741: Ambiguous variable name\n\n```python\n# BAD\nl = []  # looks like 1\nO = 0   # looks like 0\nI = 1   # looks like l\n\n# GOOD\nitems = []\nzero = 0\none = 1\n```\n\n### E902: Token error\n\n### E999: Syntax error\n\n### W291-W293: Trailing whitespace\n\n### W391: Blank line at end of file\n\n### W503: Line break before binary operator (ignored by default)\n\n### W504: Line break after binary operator\n\n### W505: Doc line too long\n"}, {"path": "linters/ruff/simplify.md", "category": "linters", "name": "linters/ruff/simplify", "content": "# flake8-simplify (SIM) - Simplification\n\nMakes code more readable by suggesting simpler alternatives.\n\n## Boolean Simplifications\n\n### SIM101: Use `any()` or `all()`\n\n```python\n# BAD\nif a or b or c:\nif a and b and c:\n\n# Consider\nif any([a, b, c]):\nif all([a, b, c]):\n```\n\n### SIM102: Use single `if` instead of nested\n\n```python\n# BAD\nif a:\n    if b:\n        do_something()\n\n# GOOD\nif a and b:\n    do_something()\n```\n\n### SIM103: Return boolean directly\n\n```python\n# BAD\nif condition:\n    return True\nreturn False\n\n# GOOD\nreturn condition\n\n# BAD\nif condition:\n    return True\nelse:\n    return False\n\n# GOOD\nreturn condition\n```\n\n### SIM105: Use `contextlib.suppress`\n\n```python\n# BAD\ntry:\n    do_something()\nexcept ValueError:\n    pass\n\n# GOOD\nfrom contextlib import suppress\nwith suppress(ValueError):\n    do_something()\n```\n\n### SIM107: Return from try with no finally\n\n```python\n# BAD\ntry:\n    return do_something()\nexcept:\n    return default\n\n# GOOD\ntry:\n    result = do_something()\nexcept:\n    result = default\nreturn result\n```\n\n### SIM108: Use ternary operator\n\n```python\n# BAD\nif condition:\n    x = a\nelse:\n    x = b\n\n# GOOD\nx = a if condition else b\n```\n\n### SIM109: Use `in` for multiple comparisons\n\n```python\n# BAD\nif x == a or x == b or x == c:\n\n# GOOD\nif x in (a, b, c):\n```\n\n### SIM110: Use `any()` with generator\n\n```python\n# BAD\nfor item in items:\n    if condition(item):\n        return True\nreturn False\n\n# GOOD\nreturn any(condition(item) for item in items)\n```\n\n### SIM111: Use `all()` with generator\n\n```python\n# BAD\nfor item in items:\n    if not condition(item):\n        return False\nreturn True\n\n# GOOD\nreturn all(condition(item) for item in items)\n```\n\n### SIM112: Use `os.environ.get` instead of `in` check\n\n```python\n# BAD\nif \"KEY\" in os.environ:\n    value = os.environ[\"KEY\"]\nelse:\n    value = default\n\n# GOOD\nvalue = os.environ.get(\"KEY\", default)\n```\n\n### SIM114: Combine `if` branches with same body\n\n```python\n# BAD\nif a:\n    do_something()\nelif b:\n    do_something()\n\n# GOOD\nif a or b:\n    do_something()\n```\n\n### SIM115: Use context manager for open\n\n```python\n# BAD\nf = open(\"file.txt\")\ncontent = f.read()\nf.close()\n\n# GOOD\nwith open(\"file.txt\") as f:\n    content = f.read()\n```\n\n### SIM116: Use dict instead of if/elif chain\n\n```python\n# BAD\nif key == \"a\":\n    return 1\nelif key == \"b\":\n    return 2\nelif key == \"c\":\n    return 3\n\n# GOOD\nmapping = {\"a\": 1, \"b\": 2, \"c\": 3}\nreturn mapping.get(key)\n```\n\n### SIM117: Use single `with` statement\n\n```python\n# BAD\nwith open(\"a\") as a:\n    with open(\"b\") as b:\n        pass\n\n# GOOD\nwith open(\"a\") as a, open(\"b\") as b:\n    pass\n```\n\n### SIM118: Use `key in dict` instead of `key in dict.keys()`\n\n```python\n# BAD\nif key in d.keys():\n\n# GOOD\nif key in d:\n```\n\n## Expression Simplifications\n\n### SIM201: Use `x != y` instead of `not x == y`\n\n```python\n# BAD\nif not a == b:\n\n# GOOD\nif a != b:\n```\n\n### SIM202: Use `x == y` instead of `not x != y`\n\n```python\n# BAD\nif not a != b:\n\n# GOOD\nif a == b:\n```\n\n### SIM208: Use `x` instead of `not not x`\n\n```python\n# BAD\nif not not condition:\n\n# GOOD\nif condition:\n```\n\n### SIM210: Use `bool()` instead of `True if x else False`\n\n```python\n# BAD\nresult = True if x else False\n\n# GOOD\nresult = bool(x)\n```\n\n### SIM211: Use `not x` instead of `False if x else True`\n\n```python\n# BAD\nresult = False if x else True\n\n# GOOD\nresult = not x\n```\n\n### SIM212: Use `b if b else a` instead of `a if not b else b`\n\n```python\n# BAD\nresult = a if not b else b\n\n# GOOD\nresult = b or a\n```\n\n### SIM220: Use `False` instead of `a and not a`\n\n### SIM221: Use `True` instead of `a or not a`\n\n### SIM222: Use `True` instead of `a or True`\n\n### SIM223: Use `False` instead of `a and False`\n\n## Statement Simplifications\n\n### SIM300: Use Yoda conditions\n\n```python\n# BAD\nif \"hello\" == x:\n\n# GOOD\nif x == \"hello\":\n```\n\n### SIM401: Use `dict.get` with default\n\n```python\n# BAD\nif key in d:\n    value = d[key]\nelse:\n    value = default\n\n# GOOD\nvalue = d.get(key, default)\n```\n\n### SIM904: Assign `dict` items directly\n\n```python\n# BAD\nd = {}\nd[\"key1\"] = value1\nd[\"key2\"] = value2\n\n# GOOD\nd = {\n    \"key1\": value1,\n    \"key2\": value2,\n}\n```\n\n### SIM905: Split static string\n\n```python\n# BAD\n\"a,b,c\".split(\",\")\n\n# GOOD\n[\"a\", \"b\", \"c\"]\n```\n\n### SIM910: Use `dict.get(key)` instead of `dict.get(key, None)`\n\n```python\n# BAD\nd.get(\"key\", None)\n\n# GOOD\nd.get(\"key\")\n```\n\n### SIM911: Use `zip()` instead of `zip(dict.keys(), dict.values())`\n\n```python\n# BAD\nzip(d.keys(), d.values())\n\n# GOOD\nd.items()\n```\n\n## Configuration\n\n```toml\n[tool.ruff.lint]\nselect = [\"SIM\"]\n```\n"}, {"path": "linters/ruff/pyflakes.md", "category": "linters", "name": "linters/ruff/pyflakes", "content": "# Ruff - Pyflakes Rules (F)\n\nPyflakes detects various errors in Python programs.\n\n## F401: Module imported but unused\n\n```python\n# BAD\nimport os  # never used\n\n# GOOD - remove unused import\n# Or use __all__ to indicate public API\n```\n\n## F402: Import shadowed by loop variable\n\n```python\n# BAD\nfrom os import path\nfor path in paths:  # shadows import\n    print(path)\n\n# GOOD\nfrom os import path as os_path\nfor p in paths:\n    print(p)\n```\n\n## F403: `from module import *` used\n\n```python\n# BAD\nfrom os import *\n\n# GOOD\nfrom os import path, getcwd\n```\n\n## F405: Name may be undefined from star import\n\n```python\n# BAD\nfrom os import *\ngetcwd()  # might not be defined\n\n# GOOD\nfrom os import getcwd\ngetcwd()\n```\n\n## F501-F509: Invalid printf-style format\n\n```python\n# BAD\n\"%s %s\" % (one,)  # F507: not enough args\n\"%(a)s\" % {\"b\": 1}  # F505: missing key\n\n# GOOD\n\"%s\" % (one,)\n\"%(a)s\" % {\"a\": 1}\n```\n\n## F521-F525: Invalid .format() calls\n\n```python\n# BAD\n\"{} {}\".format(1)  # F524: not enough args\n\"{0} {2}\".format(1, 2)  # F525: missing index 1\n\n# GOOD\n\"{} {}\".format(1, 2)\n\"{0} {1}\".format(1, 2)\n```\n\n## F601: Dictionary key literal repeated\n\n```python\n# BAD\n{\"a\": 1, \"a\": 2}  # duplicate key\n\n# GOOD\n{\"a\": 1, \"b\": 2}\n```\n\n## F602: Dictionary key variable repeated\n\n```python\n# BAD\nkey = \"a\"\n{key: 1, key: 2}\n\n# GOOD\n{key: 1, \"other\": 2}\n```\n\n## F621: Too many expressions in star-unpacking\n\n```python\n# BAD\na, *b, c, *d = values  # two starred expressions\n\n# GOOD\na, *b, c = values\n```\n\n## F631: Assert test is a tuple (always True)\n\n```python\n# BAD\nassert (condition, message)  # tuple is always truthy!\n\n# GOOD\nassert condition, message\n```\n\n## F632: Use == instead of is for comparison to literal\n\n```python\n# BAD\nif x is \"hello\":  # string interning unreliable\n\n# GOOD\nif x == \"hello\":\n```\n\n## F633: Invalid print statement syntax (Python 2)\n\n```python\n# BAD\nprint \"hello\"  # Python 2 syntax\n\n# GOOD\nprint(\"hello\")\n```\n\n## F634: If test is a tuple (always True)\n\n```python\n# BAD\nif (x, y):  # tuple is always truthy\n    ...\n\n# GOOD\nif x and y:\n    ...\n```\n\n## F701-F707: Syntax errors\n\n```python\n# F701: break outside loop\n# F702: continue outside loop\n# F704: yield outside function\n# F706: return outside function\n# F707: except: with other clauses\n```\n\n## F811: Redefinition of unused name\n\n```python\n# BAD\ndef foo():\n    pass\n\ndef foo():  # shadows previous\n    pass\n\n# GOOD\ndef foo_v1():\n    pass\n\ndef foo_v2():\n    pass\n```\n\n## F821: Undefined name\n\n```python\n# BAD\nprint(undefined_variable)\n\n# GOOD\ndefined_variable = 1\nprint(defined_variable)\n```\n\n## F822: Undefined name in __all__\n\n```python\n# BAD\n__all__ = [\"foo\", \"bar\"]  # bar doesn't exist\n\n# GOOD\ndef foo(): pass\ndef bar(): pass\n__all__ = [\"foo\", \"bar\"]\n```\n\n## F823: Local variable referenced before assignment\n\n```python\n# BAD\ndef foo():\n    print(x)  # referenced before assignment\n    x = 1\n\n# GOOD\ndef foo():\n    x = 1\n    print(x)\n```\n\n## F841: Local variable assigned but never used\n\n```python\n# BAD\ndef foo():\n    x = 1  # never used\n    return 2\n\n# GOOD\ndef foo():\n    return 2\n\n# Or underscore prefix for intentionally unused\ndef foo():\n    _x = 1  # explicitly unused\n    return 2\n```\n\n## F842: Local variable annotated but never used\n\n```python\n# BAD\ndef foo():\n    x: int  # annotated but never used\n\n# GOOD - remove it\n```\n\n## F901: raise NotImplemented should be NotImplementedError\n\n```python\n# BAD\nraise NotImplemented\n\n# GOOD\nraise NotImplementedError\n```\n"}, {"path": "linters/ruff/pylint.md", "category": "linters", "name": "linters/ruff/pylint", "content": "# Ruff - Pylint Rules (PL)\n\nRules from Pylint implemented in Ruff.\n\n## Convention (PLC)\n\n### PLC0105: TypeVar name mismatch\n\n```python\n# BAD\nT = TypeVar(\"U\")  # name doesn't match\n\n# GOOD\nT = TypeVar(\"T\")\n```\n\n### PLC0131: TypeAlias annotation in TypeVar\n\n```python\n# BAD\nT: TypeAlias = TypeVar(\"T\")\n\n# GOOD\nT = TypeVar(\"T\")\ntype MyAlias = int  # 3.12+\n```\n\n### PLC0132: TypeVar name doesn't match assignment\n\n```python\n# BAD\nMyType = TypeVar(\"T\")\n\n# GOOD\nT = TypeVar(\"T\")\nMyTypeVar = TypeVar(\"MyTypeVar\")\n```\n\n### PLC0205: Class __slots__ not iterable\n\n```python\n# BAD\nclass Foo:\n    __slots__ = \"x\"  # should be iterable\n\n# GOOD\nclass Foo:\n    __slots__ = (\"x\",)\n    # or\n    __slots__ = [\"x\"]\n```\n\n### PLC0208: Iteration over set with modification\n\n```python\n# BAD\nfor item in items:\n    items.add(new_item)  # modifying during iteration\n\n# GOOD\nfor item in list(items):\n    items.add(new_item)\n```\n\n### PLC0414: Useless import alias\n\n```python\n# BAD\nimport os as os\nfrom sys import path as path\n\n# GOOD\nimport os\nfrom sys import path\n```\n\n### PLC0415: Import outside top level\n\n```python\n# BAD\ndef foo():\n    import os  # should be at top\n\n# GOOD\nimport os\n\ndef foo():\n    os.getcwd()\n```\n\n### PLC2401: Non-ASCII name\n\n```python\n# BAD\n\u540d\u524d = \"value\"  # non-ASCII identifier\n\n# GOOD\nname = \"value\"\n```\n\n### PLC2801: Unnecessary dunder call\n\n```python\n# BAD\nx.__add__(y)\nx.__str__()\n\n# GOOD\nx + y\nstr(x)\n```\n\n### PLC3002: Unnecessary direct lambda call\n\n```python\n# BAD\n(lambda: 42)()\n\n# GOOD\n42\n```\n\n## Error (PLE)\n\n### PLE0100: __init__ returns non-None\n\n```python\n# BAD\nclass Foo:\n    def __init__(self):\n        return 42\n\n# GOOD\nclass Foo:\n    def __init__(self):\n        self.value = 42\n```\n\n### PLE0101: return in __init__\n\n```python\n# BAD\nclass Foo:\n    def __init__(self):\n        return self  # should return None\n\n# GOOD\nclass Foo:\n    def __init__(self):\n        pass\n```\n\n### PLE0116: continue in finally\n\n```python\n# BAD\ntry:\n    pass\nfinally:\n    continue  # undefined behavior\n\n# GOOD\ntry:\n    pass\nfinally:\n    pass\ncontinue\n```\n\n### PLE0117: nonlocal outside function\n\n```python\n# BAD\nnonlocal x  # at module level\n\n# GOOD\ndef outer():\n    x = 1\n    def inner():\n        nonlocal x\n        x = 2\n```\n\n### PLE0118: Used before assignment in try\n\n```python\n# BAD\ntry:\n    x = func()\nexcept:\n    pass\nprint(x)  # x might not be defined\n\n# GOOD\nx = None\ntry:\n    x = func()\nexcept:\n    pass\nif x is not None:\n    print(x)\n```\n\n### PLE0237: Non-slot assignment\n\n```python\n# BAD\nclass Foo:\n    __slots__ = (\"x\",)\n\nf = Foo()\nf.y = 1  # y not in slots\n\n# GOOD\nclass Foo:\n    __slots__ = (\"x\", \"y\")\n\nf = Foo()\nf.y = 1\n```\n\n### PLE0241: Duplicate base class\n\n```python\n# BAD\nclass Foo(Bar, Bar):  # duplicate\n    pass\n\n# GOOD\nclass Foo(Bar):\n    pass\n```\n\n### PLE0302: Unexpected special method signature\n\n```python\n# BAD\nclass Foo:\n    def __len__(self, x):  # __len__ takes no args\n        return 0\n\n# GOOD\nclass Foo:\n    def __len__(self):\n        return 0\n```\n\n### PLE0604: Invalid __all__ object\n\n```python\n# BAD\n__all__ = (func,)  # should be strings\n\n# GOOD\n__all__ = (\"func\",)\n```\n\n### PLE0605: Invalid __all__ item\n\n```python\n# BAD\n__all__ = [1, 2, 3]  # should be strings\n\n# GOOD\n__all__ = [\"foo\", \"bar\"]\n```\n\n### PLE1142: await outside async\n\n```python\n# BAD\ndef foo():\n    await something()  # not async\n\n# GOOD\nasync def foo():\n    await something()\n```\n\n### PLE1205: Too many arguments for logging\n\n```python\n# BAD\nlogging.info(\"value: %s %s\", value)  # missing argument\n\n# GOOD\nlogging.info(\"value: %s\", value)\n```\n\n### PLE1206: Not enough arguments for logging\n\n```python\n# BAD\nlogging.info(\"a: %s, b: %s\", a)  # missing b\n\n# GOOD\nlogging.info(\"a: %s, b: %s\", a, b)\n```\n\n### PLE1307: Bad string format type\n\n```python\n# BAD\n\"%d\" % \"string\"  # wants int\n\n# GOOD\n\"%s\" % \"string\"\n\"%d\" % 42\n```\n\n### PLE1310: Bad str/bytes strip call\n\n```python\n# BAD\n\"hello\".strip(\"helo\")  # strips chars, not substring!\n\n# GOOD\n\"hello\".removeprefix(\"he\")  # 3.9+\n\"hello\".removesuffix(\"lo\")\n```\n\n### PLE1507: Invalid envvar default\n\n```python\n# BAD\nos.getenv(\"KEY\", 123)  # default should be str\n\n# GOOD\nos.getenv(\"KEY\", \"default\")\n```\n\n### PLE2502: Bidirectional control character\n\n```python\n# BAD - contains invisible unicode\n# Trojan source attack\n```\n\n## Refactor (PLR)\n\n### PLR0124: Comparison with self\n\n```python\n# BAD\nif x == x:  # always True\n    pass\n\n# GOOD\nif x is not None:\n    pass\n```\n\n### PLR0133: Comparison of constants\n\n```python\n# BAD\nif 1 == 1:\n    pass\n\n# GOOD\nif True:\n    pass\n```\n\n### PLR0206: Property with parameters\n\n```python\n# BAD\nclass Foo:\n    @property\n    def bar(self, x):  # property can't have params\n        return x\n\n# GOOD\nclass Foo:\n    @property\n    def bar(self):\n        return self._bar\n```\n\n### PLR0402: Use from import\n\n```python\n# BAD\nimport os.path\nos.path.join(...)\n\n# GOOD\nfrom os import path\npath.join(...)\n\n# Or\nfrom os.path import join\njoin(...)\n```\n\n### PLR0904-0917: Complexity limits\n\n- PLR0904: Too many public methods\n- PLR0911: Too many return statements\n- PLR0912: Too many branches\n- PLR0913: Too many arguments\n- PLR0914: Too many local variables\n- PLR0915: Too many statements\n- PLR0916: Too many boolean expressions\n- PLR0917: Too many positional arguments\n\n```python\n# BAD - too complex\ndef foo(a, b, c, d, e, f, g, h):  # too many args\n    if a:\n        if b:\n            if c:  # too many branches\n                pass\n```\n\n### PLR1701: Repeated isinstance calls\n\n```python\n# BAD\nisinstance(x, int) or isinstance(x, str)\n\n# GOOD\nisinstance(x, (int, str))\n# Or 3.10+\nisinstance(x, int | str)\n```\n\n### PLR1711: Useless return\n\n```python\n# BAD\ndef foo():\n    return None  # implicit anyway\n\n# GOOD\ndef foo():\n    pass\n```\n\n### PLR1714: Repeated equality comparison\n\n```python\n# BAD\nif x == 1 or x == 2 or x == 3:\n    pass\n\n# GOOD\nif x in {1, 2, 3}:\n    pass\n```\n\n### PLR1722: Use sys.exit()\n\n```python\n# BAD\nexit()\nquit()\n\n# GOOD\nimport sys\nsys.exit()\n```\n\n### PLR2004: Magic value in comparison\n\n```python\n# BAD\nif age > 18:\n    pass\n\n# GOOD\nADULT_AGE = 18\nif age > ADULT_AGE:\n    pass\n```\n\n### PLR5501: Collapsible else-if\n\n```python\n# BAD\nif a:\n    pass\nelse:\n    if b:\n        pass\n\n# GOOD\nif a:\n    pass\nelif b:\n    pass\n```\n\n## Warning (PLW)\n\n### PLW0120: Useless else on loop\n\n```python\n# BAD\nfor x in items:\n    if condition:\n        break\nelse:  # only runs if no break\n    pass  # empty else\n\n# Remove empty else\nfor x in items:\n    if condition:\n        break\n```\n\n### PLW0127: Self-assignment\n\n```python\n# BAD\nx = x\n\n# Remove it\n```\n\n### PLW0128: Redeclared variable in assignment\n\n```python\n# BAD\nx, x = 1, 2  # x assigned twice\n\n# GOOD\nx, y = 1, 2\n```\n\n### PLW0129: Assert on string literal\n\n```python\n# BAD\nassert \"always true\"  # non-empty string is truthy\n\n# GOOD\nassert condition, \"message\"\n```\n\n### PLW0131: Named expression in except\n\n```python\n# BAD\ntry:\n    pass\nexcept (err := Exception):  # walrus in except\n    pass\n\n# GOOD\ntry:\n    pass\nexcept Exception as err:\n    pass\n```\n\n### PLW0406: Import self\n\n```python\n# BAD (in module foo.py)\nimport foo  # importing itself\n\n# Remove self-import\n```\n\n### PLW0602: Global without assignment\n\n```python\n# BAD\nx = 1\ndef foo():\n    global x  # x not assigned in function\n\n# GOOD - remove global if not needed\ndef foo():\n    print(x)  # reading is fine without global\n```\n\n### PLW0603: Global statement\n\n```python\n# BAD\ndef foo():\n    global x\n    x = 1\n\n# GOOD - return value instead\ndef foo():\n    return 1\n\nx = foo()\n```\n\n### PLW0711: Binary op exception\n\n```python\n# BAD\nexcept TypeError or ValueError:  # wrong!\n\n# GOOD\nexcept (TypeError, ValueError):\n```\n\n### PLW1508: Invalid envvar default\n\n```python\n# BAD\nos.environ.get(\"KEY\", None)  # None is already default\n\n# GOOD\nos.environ.get(\"KEY\")\nos.environ.get(\"KEY\", \"default\")\n```\n\n### PLW1509: Subprocess popen preexec_fn\n\n```python\n# BAD - unsafe in multithreaded code\nsubprocess.Popen(cmd, preexec_fn=fn)\n\n# GOOD - use start_new_session or other options\nsubprocess.Popen(cmd, start_new_session=True)\n```\n\n### PLW2901: Redefined loop name\n\n```python\n# BAD\nfor i in range(10):\n    for i in range(5):  # shadows outer i\n        pass\n\n# GOOD\nfor i in range(10):\n    for j in range(5):\n        pass\n```\n\n### PLW3301: Nested min/max\n\n```python\n# BAD\nmin(1, min(2, 3))\n\n# GOOD\nmin(1, 2, 3)\n```\n"}, {"path": "linters/ruff/comprehensions.md", "category": "linters", "name": "linters/ruff/comprehensions", "content": "# Ruff - flake8-comprehensions Rules (C4)\n\nWrite better comprehensions.\n\n## C400: Unnecessary generator - use list comprehension\n\n```python\n# BAD\nlist(x for x in iterable)\n\n# GOOD\n[x for x in iterable]\n```\n\n## C401: Unnecessary generator - use set comprehension\n\n```python\n# BAD\nset(x for x in iterable)\n\n# GOOD\n{x for x in iterable}\n```\n\n## C402: Unnecessary generator - use dict comprehension\n\n```python\n# BAD\ndict((k, v) for k, v in items)\n\n# GOOD\n{k: v for k, v in items}\n```\n\n## C403: Unnecessary list comprehension - use set\n\n```python\n# BAD\nset([x for x in iterable])\n\n# GOOD\n{x for x in iterable}\n```\n\n## C404: Unnecessary list comprehension - use dict\n\n```python\n# BAD\ndict([pair for pair in items])\n\n# GOOD\n{k: v for k, v in items}\n```\n\n## C405: Unnecessary literal - use set literal\n\n```python\n# BAD\nset([1, 2, 3])\nset((1, 2, 3))\n\n# GOOD\n{1, 2, 3}\n```\n\n## C406: Unnecessary literal - use dict literal\n\n```python\n# BAD\ndict([(1, 2), (3, 4)])\ndict(((1, 2), (3, 4)))\n\n# GOOD\n{1: 2, 3: 4}\n```\n\n## C408: Unnecessary dict/list/tuple call\n\n```python\n# BAD\ndict()\nlist()\ntuple()\n\n# GOOD\n{}\n[]\n()\n```\n\n## C409: Unnecessary list passed to tuple()\n\n```python\n# BAD\ntuple([1, 2, 3])\n\n# GOOD\n(1, 2, 3)\n```\n\n## C410: Unnecessary list passed to list()\n\n```python\n# BAD\nlist([1, 2, 3])\n\n# GOOD\n[1, 2, 3]\n```\n\n## C411: Unnecessary list call - use list literal\n\n```python\n# BAD\nlist([])\n\n# GOOD\n[]\n```\n\n## C413: Unnecessary list/reversed call around sorted()\n\n```python\n# BAD\nlist(sorted(iterable))\nreversed(sorted(iterable))\n\n# GOOD\nsorted(iterable)\nsorted(iterable, reverse=True)\n```\n\n## C414: Unnecessary double list/set/tuple/reversed/sorted\n\n```python\n# BAD\nlist(list(iterable))\nset(set(iterable))\nsorted(sorted(iterable))\n\n# GOOD\nlist(iterable)\nset(iterable)\nsorted(iterable)\n```\n\n## C415: Unnecessary subscript reversal\n\n```python\n# BAD\nset(iterable[::-1])\nsorted(iterable)[::-1]\n\n# GOOD\nset(iterable)\nsorted(iterable, reverse=True)\n```\n\n## C416: Unnecessary comprehension - use list/set/dict\n\n```python\n# BAD\n[x for x in iterable]  # identity comprehension\n{x for x in iterable}\n{k: v for k, v in items}\n\n# GOOD\nlist(iterable)\nset(iterable)\ndict(items)\n```\n\n## C417: Unnecessary map - use generator/comprehension\n\n```python\n# BAD\nmap(lambda x: x * 2, iterable)\nmap(str, numbers)\n\n# GOOD\n(x * 2 for x in iterable)\n[x * 2 for x in iterable]\n(str(n) for n in numbers)\n```\n\n## C418: Unnecessary dict passed to dict()\n\n```python\n# BAD\ndict({\"a\": 1})\n\n# GOOD\n{\"a\": 1}\n```\n\n## C419: Unnecessary comprehension in any/all\n\n```python\n# BAD\nany([x > 0 for x in items])\nall([x > 0 for x in items])\n\n# GOOD - use generator\nany(x > 0 for x in items)\nall(x > 0 for x in items)\n```\n"}, {"path": "linters/ruff/naming.md", "category": "linters", "name": "linters/ruff/naming", "content": "# Ruff - pep8-naming Rules (N)\n\nPEP 8 naming conventions.\n\n## N801: Class name should use CapWords\n\n```python\n# BAD\nclass my_class:\n    pass\n\nclass myClass:\n    pass\n\n# GOOD\nclass MyClass:\n    pass\n```\n\n## N802: Function name should be lowercase\n\n```python\n# BAD\ndef MyFunction():\n    pass\n\ndef myFunction():\n    pass\n\n# GOOD\ndef my_function():\n    pass\n```\n\n## N803: Argument name should be lowercase\n\n```python\n# BAD\ndef foo(myArg):\n    pass\n\n# GOOD\ndef foo(my_arg):\n    pass\n```\n\n## N804: First argument of classmethod should be 'cls'\n\n```python\n# BAD\nclass Foo:\n    @classmethod\n    def bar(self):\n        pass\n\n# GOOD\nclass Foo:\n    @classmethod\n    def bar(cls):\n        pass\n```\n\n## N805: First argument of method should be 'self'\n\n```python\n# BAD\nclass Foo:\n    def bar(this):\n        pass\n\n# GOOD\nclass Foo:\n    def bar(self):\n        pass\n```\n\n## N806: Variable in function should be lowercase\n\n```python\n# BAD\ndef foo():\n    MyVar = 1\n    return MyVar\n\n# GOOD\ndef foo():\n    my_var = 1\n    return my_var\n```\n\n## N807: Function name should not start/end with '__'\n\n```python\n# BAD\ndef __my_function__():\n    pass\n\n# GOOD\ndef my_function():\n    pass\n\n# OK - dunder methods in classes\nclass Foo:\n    def __init__(self):\n        pass\n```\n\n## N811: Constant imported as non-constant\n\n```python\n# BAD\nfrom math import PI as pi\n\n# GOOD\nfrom math import PI\n# or\nfrom math import PI as MY_PI\n```\n\n## N812: Lowercase imported as non-lowercase\n\n```python\n# BAD\nfrom os import path as PATH\n\n# GOOD\nfrom os import path\n```\n\n## N813: CamelCase imported as lowercase\n\n```python\n# BAD\nfrom typing import TypeVar as typevar\n\n# GOOD\nfrom typing import TypeVar\n```\n\n## N814: CamelCase imported as constant\n\n```python\n# BAD\nfrom typing import TypeVar as TYPE_VAR\n\n# GOOD\nfrom typing import TypeVar\n```\n\n## N815: mixedCase variable in class scope\n\n```python\n# BAD\nclass Foo:\n    myVar = 1\n\n# GOOD\nclass Foo:\n    my_var = 1\n```\n\n## N816: mixedCase variable in global scope\n\n```python\n# BAD\nmyGlobal = 1\n\n# GOOD\nmy_global = 1\nMY_CONSTANT = 1\n```\n\n## N817: CamelCase imported as acronym\n\n```python\n# BAD\nfrom collections import OrderedDict as OD\n\n# GOOD\nfrom collections import OrderedDict\n```\n\n## N818: Exception name should end in Error\n\n```python\n# BAD\nclass MyException(Exception):\n    pass\n\n# GOOD\nclass MyError(Exception):\n    pass\n\nclass ValidationError(Exception):\n    pass\n```\n\n## N999: Invalid module name\n\n```python\n# BAD filename: MyModule.py, my-module.py\n\n# GOOD filename: my_module.py\n```\n"}, {"path": "linters/ruff/security.md", "category": "linters", "name": "linters/ruff/security", "content": "# Ruff - Security Rules (S / flake8-bandit)\n\nSecurity-focused rules from Bandit.\n\n## S101: Use of assert\n\n```python\n# BAD - assert is stripped in optimized mode\nassert user.is_admin, \"Admin required\"\n\n# GOOD\nif not user.is_admin:\n    raise PermissionError(\"Admin required\")\n```\n\n**Note:** Allow in tests with per-file-ignores.\n\n## S102: Use of exec\n\n```python\n# BAD\nexec(user_code)\n\n# GOOD - avoid exec entirely\n# If absolutely needed, heavily sandbox\n```\n\n## S103: Chmod with permissive mask\n\n```python\n# BAD\nos.chmod(path, 0o777)\n\n# GOOD\nos.chmod(path, 0o600)\n```\n\n## S104: Binding to all interfaces\n\n```python\n# BAD\nsocket.bind((\"0.0.0.0\", 8080))\n\n# GOOD\nsocket.bind((\"127.0.0.1\", 8080))\n```\n\n## S105-S107: Hardcoded passwords\n\n```python\n# BAD\npassword = \"admin123\"\nsecret_key = \"supersecret\"\napi_key = \"sk-1234567890\"\n\n# GOOD\npassword = os.environ[\"PASSWORD\"]\nsecret_key = os.environ[\"SECRET_KEY\"]\napi_key = os.environ[\"API_KEY\"]\n```\n\n## S108: Hardcoded /tmp path\n\n```python\n# BAD\nwith open(\"/tmp/data.txt\", \"w\") as f:\n    f.write(data)\n\n# GOOD\nimport tempfile\nwith tempfile.NamedTemporaryFile(mode=\"w\", delete=False) as f:\n    f.write(data)\n```\n\n## S110: Try-except-pass\n\n```python\n# BAD - silently ignores errors\ntry:\n    risky()\nexcept Exception:\n    pass\n\n# GOOD\ntry:\n    risky()\nexcept Exception:\n    logger.exception(\"Failed\")\n```\n\n## S112: Try-except-continue\n\n```python\n# BAD - silently continues\nfor item in items:\n    try:\n        process(item)\n    except Exception:\n        continue\n\n# GOOD\nfor item in items:\n    try:\n        process(item)\n    except Exception:\n        logger.exception(\"Failed to process %s\", item)\n```\n\n## S113: Request without timeout\n\n```python\n# BAD\nrequests.get(url)\n\n# GOOD\nrequests.get(url, timeout=10)\n```\n\n## S301: Pickle unsafe\n\n```python\n# BAD\npickle.loads(user_data)  # arbitrary code execution!\n\n# GOOD - use safer alternatives\njson.loads(user_data)\n```\n\n## S302: Marshal unsafe\n\n```python\n# BAD\nmarshal.loads(user_data)\n\n# GOOD\njson.loads(user_data)\n```\n\n## S303-S304: Weak crypto\n\n```python\n# BAD\nimport md5\nimport sha\nhashlib.md5(data)\nhashlib.sha1(data)\n\n# GOOD\nhashlib.sha256(data)\nhashlib.sha3_256(data)\n```\n\n## S305: Weak cipher\n\n```python\n# BAD\nfrom Crypto.Cipher import DES\ncipher = DES.new(key)\n\n# GOOD\nfrom Crypto.Cipher import AES\ncipher = AES.new(key, AES.MODE_GCM)\n```\n\n## S306: mktemp is insecure\n\n```python\n# BAD\ntempfile.mktemp()\n\n# GOOD\ntempfile.mkstemp()\ntempfile.NamedTemporaryFile()\n```\n\n## S307: eval is dangerous\n\n```python\n# BAD\neval(user_input)\n\n# GOOD - use ast.literal_eval for data\nimport ast\nast.literal_eval(user_input)\n\n# Or parse specifically\njson.loads(user_input)\n```\n\n## S308: mark_safe without escaping\n\n```python\n# BAD (Django)\nmark_safe(user_input)\n\n# GOOD\nmark_safe(escape(user_input))\n```\n\n## S310: URL open suspicious\n\n```python\n# BAD - can be file:// or other schemes\nurllib.urlopen(user_url)\n\n# GOOD - validate scheme\nif user_url.startswith((\"http://\", \"https://\")):\n    urllib.urlopen(user_url)\n```\n\n## S311: Random not cryptographically secure\n\n```python\n# BAD for security\nimport random\ntoken = random.randint(0, 1000000)\n\n# GOOD\nimport secrets\ntoken = secrets.token_hex(32)\n```\n\n## S312: Telnet insecure\n\n```python\n# BAD\ntelnetlib.Telnet(host)\n\n# GOOD\n# Use SSH instead\n```\n\n## S314-S321: XML vulnerabilities\n\n```python\n# BAD - vulnerable to XXE\nxml.etree.ElementTree.parse(user_file)\nxml.dom.minidom.parse(user_file)\nxml.sax.parse(user_file)\n\n# GOOD - use defusedxml\nimport defusedxml.ElementTree as ET\nET.parse(user_file)\n```\n\n## S324: Insecure hash function\n\n```python\n# BAD\nhashlib.md5(password.encode())\n\n# GOOD for passwords\nimport bcrypt\nbcrypt.hashpw(password.encode(), bcrypt.gensalt())\n\n# Or\nfrom passlib.hash import argon2\nargon2.hash(password)\n```\n\n## S501: Request with verify=False\n\n```python\n# BAD - no SSL verification\nrequests.get(url, verify=False)\n\n# GOOD\nrequests.get(url, verify=True)\nrequests.get(url)  # verify=True is default\n```\n\n## S502: SSL with insecure version\n\n```python\n# BAD\nssl.SSLContext(ssl.PROTOCOL_SSLv3)\n\n# GOOD\nssl.create_default_context()\nssl.SSLContext(ssl.PROTOCOL_TLS)\n```\n\n## S506: YAML unsafe load\n\n```python\n# BAD - arbitrary code execution\nyaml.load(user_data)\nyaml.load(user_data, Loader=yaml.Loader)\n\n# GOOD\nyaml.safe_load(user_data)\n```\n\n## S507: SSH no host key verification\n\n```python\n# BAD\nclient.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\n# GOOD\nclient.set_missing_host_key_policy(paramiko.RejectPolicy())\n# Or load known hosts\nclient.load_system_host_keys()\n```\n\n## S508-S509: Snmp insecure\n\n```python\n# BAD\nsnmp_community = \"public\"\n\n# GOOD - use SNMPv3 with auth\n```\n\n## S601: Shell injection via parameterized string\n\n```python\n# BAD\nsubprocess.call(\"ls \" + user_dir, shell=True)\n\n# GOOD\nsubprocess.call([\"ls\", user_dir])\n```\n\n## S602: Shell=True without literal\n\n```python\n# BAD\nsubprocess.call(cmd, shell=True)\n\n# GOOD\nsubprocess.call(cmd.split())\n# Or\nsubprocess.call(shlex.split(cmd))\n```\n\n## S603-S607: Subprocess without full path\n\n```python\n# BAD\nsubprocess.call([\"ls\"])\n\n# GOOD\nsubprocess.call([\"/bin/ls\"])\n```\n\n## S608: SQL injection\n\n```python\n# BAD\ncursor.execute(\"SELECT * FROM users WHERE id = \" + user_id)\ncursor.execute(f\"SELECT * FROM users WHERE id = {user_id}\")\n\n# GOOD\ncursor.execute(\"SELECT * FROM users WHERE id = ?\", (user_id,))\ncursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))\n```\n\n## S609: Wildcard injection\n\n```python\n# BAD\nos.system(\"rm -rf /tmp/*\")  # wildcard expansion\n\n# GOOD\nimport glob\nfor f in glob.glob(\"/tmp/*\"):\n    os.remove(f)\n```\n\n## S612: Logging sensitive info\n\n```python\n# BAD\nlogger.debug(f\"Password: {password}\")\n\n# GOOD\nlogger.debug(\"Password: [REDACTED]\")\n```\n\n## S701: Jinja2 autoescape off\n\n```python\n# BAD\njinja2.Environment(autoescape=False)\n\n# GOOD\njinja2.Environment(autoescape=True)\njinja2.Environment(autoescape=select_autoescape())\n```\n"}, {"path": "linters/ruff/bugbear.md", "category": "linters", "name": "linters/ruff/bugbear", "content": "# Ruff - flake8-bugbear Rules (B)\n\nOpinionated, bug-finding rules.\n\n## B002: Use of `**=` for assignment\n\n```python\n# BAD\nx =+ 1  # probably meant +=\n\n# GOOD\nx += 1\n```\n\n## B003: Assigning to os.environ doesn't clear\n\n```python\n# BAD\nos.environ = {\"PATH\": \"/bin\"}  # doesn't work as expected\n\n# GOOD\nos.environ.clear()\nos.environ.update({\"PATH\": \"/bin\"})\n```\n\n## B004: Using hasattr for __call__ is unreliable\n\n```python\n# BAD\nif hasattr(obj, \"__call__\"):\n    obj()\n\n# GOOD\nif callable(obj):\n    obj()\n```\n\n## B005: Using .strip() with multi-char string\n\n```python\n# BAD\n\"hello\".strip(\"he\")  # strips each char, not substring\n\n# GOOD\n\"hello\".removeprefix(\"he\")  # Python 3.9+\n\"hello\".lstrip(\"h\")\n```\n\n## B006: Mutable default argument\n\n```python\n# BAD - mutable default is shared!\ndef foo(items=[]):\n    items.append(1)\n    return items\n\nfoo()  # [1]\nfoo()  # [1, 1]  # same list!\n\n# GOOD\ndef foo(items=None):\n    if items is None:\n        items = []\n    items.append(1)\n    return items\n```\n\n## B007: Loop variable not used\n\n```python\n# BAD\nfor i in range(10):  # i not used\n    print(\"hello\")\n\n# GOOD\nfor _ in range(10):\n    print(\"hello\")\n```\n\n## B008: Function call in default argument\n\n```python\n# BAD - called once at definition time\ndef foo(now=datetime.now()):\n    return now\n\n# GOOD - called each invocation\ndef foo(now=None):\n    if now is None:\n        now = datetime.now()\n    return now\n```\n\n## B009: Do not call getattr with constant\n\n```python\n# BAD\ngetattr(obj, \"foo\")\n\n# GOOD\nobj.foo\n```\n\n## B010: Do not call setattr with constant\n\n```python\n# BAD\nsetattr(obj, \"foo\", value)\n\n# GOOD\nobj.foo = value\n```\n\n## B011: Do not assert False\n\n```python\n# BAD\nassert False, \"message\"\n\n# GOOD\nraise AssertionError(\"message\")\n```\n\n## B012: Return in finally\n\n```python\n# BAD - swallows exceptions\ntry:\n    risky()\nfinally:\n    return default  # exception lost!\n\n# GOOD\ntry:\n    return risky()\nexcept Exception:\n    return default\n```\n\n## B014: Redundant exception in except\n\n```python\n# BAD\nexcept (ValueError, ValueError):  # duplicate\n\n# GOOD\nexcept ValueError:\n```\n\n## B015: Useless comparison\n\n```python\n# BAD\nx == 5  # result discarded\n\n# GOOD\nresult = x == 5\nif x == 5:\n    ...\n```\n\n## B016: Raise literal\n\n```python\n# BAD\nraise \"error\"\n\n# GOOD\nraise ValueError(\"error\")\n```\n\n## B017: assertRaises(Exception)\n\n```python\n# BAD - too broad\nwith pytest.raises(Exception):\n    risky()\n\n# GOOD\nwith pytest.raises(ValueError):\n    risky()\n```\n\n## B018: Useless expression\n\n```python\n# BAD\n\"this does nothing\"\n42\n\n# GOOD - remove or assign\n# Unless it's a docstring\n```\n\n## B019: Use @functools.lru_cache with parentheses\n\n```python\n# BAD\n@functools.lru_cache\ndef expensive():\n    ...\n\n# GOOD\n@functools.lru_cache()\ndef expensive():\n    ...\n```\n\n## B020: Loop variable shadows outer\n\n```python\n# BAD\nitems = [1, 2, 3]\nfor items in [[4], [5]]:  # shadows outer items\n    print(items)\n\n# GOOD\nfor batch in [[4], [5]]:\n    print(batch)\n```\n\n## B023: Function in loop that uses loop variable\n\n```python\n# BAD - all functions use last value\nfuncs = []\nfor i in range(3):\n    funcs.append(lambda: i)\n# All return 2!\n\n# GOOD - capture value\nfuncs = []\nfor i in range(3):\n    funcs.append(lambda i=i: i)\n```\n\n## B024: Abstract class without abstract methods\n\n```python\n# BAD\nfrom abc import ABC\n\nclass Foo(ABC):  # no abstract methods\n    def bar(self):\n        pass\n\n# GOOD\nfrom abc import ABC, abstractmethod\n\nclass Foo(ABC):\n    @abstractmethod\n    def bar(self):\n        pass\n```\n\n## B025: try-except-pass\n\n```python\n# BAD\ntry:\n    risky()\nexcept Exception:\n    pass\n\n# GOOD - at least log\ntry:\n    risky()\nexcept Exception:\n    logger.exception(\"Failed\")\n```\n\n## B026: Star-argument unpacking after keyword argument\n\n```python\n# BAD\nfoo(a=1, *args)\n\n# GOOD\nfoo(*args, a=1)\n```\n\n## B028: No explicit stacklevel in warnings.warn\n\n```python\n# BAD\nwarnings.warn(\"deprecated\")\n\n# GOOD\nwarnings.warn(\"deprecated\", stacklevel=2)\n```\n\n## B029: except with empty tuple\n\n```python\n# BAD\nexcept ():\n    pass\n\n# GOOD\nexcept Exception:\n    pass\n```\n\n## B030: except with non-exception type\n\n```python\n# BAD\nexcept 42:\n    pass\n\n# GOOD\nexcept ValueError:\n    pass\n```\n\n## B031: Reusing groupby generator\n\n```python\n# BAD\nfor key, group in itertools.groupby(data, key_func):\n    groups[key] = group  # group is consumed by next iteration!\n\n# GOOD\nfor key, group in itertools.groupby(data, key_func):\n    groups[key] = list(group)\n```\n\n## B032: Unintentional type annotation\n\n```python\n# BAD\nx: int  # This is a type annotation with no value\n\n# GOOD (if you meant annotation)\nx: int = 0\n\n# GOOD (if you meant type comment)\nx = 0  # type: int\n```\n\n## B033: Duplicate set item\n\n```python\n# BAD\n{1, 2, 1}  # duplicate\n\n# GOOD\n{1, 2}\n```\n\n## B034: re.sub/split without flags\n\n```python\n# BAD - might match different than expected\nre.sub(\"pattern\", repl, string, count)\n\n# GOOD - explicit flags\nre.sub(\"pattern\", repl, string, count=count)\nre.sub(\"pattern\", repl, string, flags=re.IGNORECASE)\n```\n\n## B904: Raise without from in except handler\n\n```python\n# BAD - loses original traceback\nexcept ValueError:\n    raise RuntimeError(\"failed\")\n\n# GOOD\nexcept ValueError as e:\n    raise RuntimeError(\"failed\") from e\n\n# Or if intentionally suppressing\nexcept ValueError:\n    raise RuntimeError(\"failed\") from None\n```\n\n## B905: zip without explicit strict\n\n```python\n# BAD\nzip(a, b)  # silently truncates if different lengths\n\n# GOOD (Python 3.10+)\nzip(a, b, strict=True)\n```\n"}, {"path": "linters/pylint/overview.md", "category": "linters", "name": "linters/pylint/overview", "content": "# Pylint Messages\nVersion: unknown\n\nSource: https://pylint.readthedocs.io/en/stable/user_guide/messages/index.html\n\n\nSee: https://pylint.readthedocs.io/en/stable/user_guide/messages/index.html\n"}, {"path": "linters/flake8/C901.md", "category": "linters", "name": "linters/flake8/C901", "content": "# C901\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/overview.md", "category": "linters", "name": "linters/flake8/overview", "content": "# Flake8 Error Codes\nVersion: latest\n\nSource: https://flake8.pycqa.org/en/latest/user/error-codes.html\n\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F405.md", "category": "linters", "name": "linters/flake8/F405", "content": "# F405\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F702.md", "category": "linters", "name": "linters/flake8/F702", "content": "# F702\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F811.md", "category": "linters", "name": "linters/flake8/F811", "content": "# F811\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F504.md", "category": "linters", "name": "linters/flake8/F504", "content": "# F504\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F524.md", "category": "linters", "name": "linters/flake8/F524", "content": "# F524\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F706.md", "category": "linters", "name": "linters/flake8/F706", "content": "# F706\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F541.md", "category": "linters", "name": "linters/flake8/F541", "content": "# F541\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F401.md", "category": "linters", "name": "linters/flake8/F401", "content": "# F401\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F831.md", "category": "linters", "name": "linters/flake8/F831", "content": "# F831\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F633.md", "category": "linters", "name": "linters/flake8/F633", "content": "# F633\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F821.md", "category": "linters", "name": "linters/flake8/F821", "content": "# F821\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F722.md", "category": "linters", "name": "linters/flake8/F722", "content": "# F722\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F525.md", "category": "linters", "name": "linters/flake8/F525", "content": "# F525\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F707.md", "category": "linters", "name": "linters/flake8/F707", "content": "# F707\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F622.md", "category": "linters", "name": "linters/flake8/F622", "content": "# F622\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/E999.md", "category": "linters", "name": "linters/flake8/E999", "content": "# E999\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F632.md", "category": "linters", "name": "linters/flake8/F632", "content": "# F632\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F723.md", "category": "linters", "name": "linters/flake8/F723", "content": "# F723\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F501.md", "category": "linters", "name": "linters/flake8/F501", "content": "# F501\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F404.md", "category": "linters", "name": "linters/flake8/F404", "content": "# F404\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F521.md", "category": "linters", "name": "linters/flake8/F521", "content": "# F521\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F602.md", "category": "linters", "name": "linters/flake8/F602", "content": "# F602\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F901.md", "category": "linters", "name": "linters/flake8/F901", "content": "# F901\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F841.md", "category": "linters", "name": "linters/flake8/F841", "content": "# F841\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F824.md", "category": "linters", "name": "linters/flake8/F824", "content": "# F824\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F505.md", "category": "linters", "name": "linters/flake8/F505", "content": "# F505\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F704.md", "category": "linters", "name": "linters/flake8/F704", "content": "# F704\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F621.md", "category": "linters", "name": "linters/flake8/F621", "content": "# F621\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F403.md", "category": "linters", "name": "linters/flake8/F403", "content": "# F403\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F502.md", "category": "linters", "name": "linters/flake8/F502", "content": "# F502\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F823.md", "category": "linters", "name": "linters/flake8/F823", "content": "# F823\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F631.md", "category": "linters", "name": "linters/flake8/F631", "content": "# F631\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F407.md", "category": "linters", "name": "linters/flake8/F407", "content": "# F407\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F522.md", "category": "linters", "name": "linters/flake8/F522", "content": "# F522\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F601.md", "category": "linters", "name": "linters/flake8/F601", "content": "# F601\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F506.md", "category": "linters", "name": "linters/flake8/F506", "content": "# F506\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F406.md", "category": "linters", "name": "linters/flake8/F406", "content": "# F406\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F701.md", "category": "linters", "name": "linters/flake8/F701", "content": "# F701\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F523.md", "category": "linters", "name": "linters/flake8/F523", "content": "# F523\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F507.md", "category": "linters", "name": "linters/flake8/F507", "content": "# F507\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F634.md", "category": "linters", "name": "linters/flake8/F634", "content": "# F634\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F542.md", "category": "linters", "name": "linters/flake8/F542", "content": "# F542\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F402.md", "category": "linters", "name": "linters/flake8/F402", "content": "# F402\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F503.md", "category": "linters", "name": "linters/flake8/F503", "content": "# F503\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F822.md", "category": "linters", "name": "linters/flake8/F822", "content": "# F822\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F721.md", "category": "linters", "name": "linters/flake8/F721", "content": "# F721\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F508.md", "category": "linters", "name": "linters/flake8/F508", "content": "# F508\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/flake8/F509.md", "category": "linters", "name": "linters/flake8/F509", "content": "# F509\n\nSee: https://flake8.pycqa.org/en/latest/user/error-codes.html\n"}, {"path": "linters/mypy/overview.md", "category": "linters", "name": "linters/mypy/overview", "content": "# mypy Error Codes\nVersion: latest\n\nSource: https://mypy.readthedocs.io/en/stable/error_code_list.html\n\n\nSee: https://mypy.readthedocs.io/en/stable/error_code_list.html\n"}, {"path": "linters/mypy/errors.md", "category": "linters", "name": "linters/mypy/errors", "content": "# mypy Error Codes\n\n## Type Errors\n\n### arg-type\n\nArgument has incompatible type.\n\n```python\n# BAD\ndef greet(name: str) -> str:\n    return f\"Hello, {name}\"\n\ngreet(42)  # error: Argument 1 has incompatible type \"int\"; expected \"str\"\n\n# GOOD\ngreet(\"Alice\")\n```\n\n### assignment\n\nIncompatible assignment.\n\n```python\n# BAD\nx: int = \"hello\"  # error: Incompatible types in assignment\n\n# GOOD\nx: int = 42\n```\n\n### call-arg\n\nToo many/few arguments.\n\n```python\n# BAD\ndef foo(a: int, b: int) -> int:\n    return a + b\n\nfoo(1)        # error: Missing positional argument \"b\"\nfoo(1, 2, 3)  # error: Too many arguments\n\n# GOOD\nfoo(1, 2)\n```\n\n### call-overload\n\nNo matching overload.\n\n```python\n# BAD\nfrom typing import overload\n\n@overload\ndef process(x: int) -> int: ...\n@overload\ndef process(x: str) -> str: ...\n\ndef process(x):\n    return x\n\nprocess([1, 2, 3])  # error: No overload variant matches\n\n# GOOD\nprocess(42)\nprocess(\"hello\")\n```\n\n### dict-item\n\nDict item has incompatible type.\n\n```python\n# BAD\nd: dict[str, int] = {\"a\": \"b\"}  # error: Dict entry has incompatible type\n\n# GOOD\nd: dict[str, int] = {\"a\": 1}\n```\n\n### index\n\nInvalid index type.\n\n```python\n# BAD\nlst: list[int] = [1, 2, 3]\nlst[\"0\"]  # error: Invalid index type \"str\"\n\n# GOOD\nlst[0]\n```\n\n### list-item\n\nList item has incompatible type.\n\n```python\n# BAD\nlst: list[int] = [1, \"two\", 3]  # error: List item has incompatible type\n\n# GOOD\nlst: list[int] = [1, 2, 3]\n```\n\n### operator\n\nUnsupported operand types.\n\n```python\n# BAD\n\"hello\" + 42  # error: Unsupported operand types for + (\"str\" and \"int\")\n\n# GOOD\n\"hello\" + str(42)\n```\n\n### return\n\nIncompatible return type.\n\n```python\n# BAD\ndef get_name() -> str:\n    return 42  # error: Incompatible return value type\n\n# GOOD\ndef get_name() -> str:\n    return \"Alice\"\n```\n\n### return-value\n\nReturn value expected.\n\n```python\n# BAD\ndef get_value() -> int:\n    print(\"no return\")  # error: Missing return statement\n\n# GOOD\ndef get_value() -> int:\n    return 42\n```\n\n### type-arg\n\nInvalid type argument.\n\n```python\n# BAD\nfrom typing import TypeVar\nT = TypeVar('T', bound=int)\n\ndef foo(x: T) -> T: ...\n\nfoo(\"hello\")  # error: Value of type variable \"T\" cannot be \"str\"\n\n# GOOD\nfoo(42)\n```\n\n### type-var\n\nInvalid type variable usage.\n\n```python\n# BAD\nfrom typing import TypeVar, Generic\nT = TypeVar('T')\n\nclass Foo(Generic[T]):\n    def bar(self) -> T:\n        return \"string\"  # error: Incompatible return value\n\n# GOOD\nclass Foo(Generic[T]):\n    def __init__(self, value: T) -> None:\n        self.value = value\n    \n    def bar(self) -> T:\n        return self.value\n```\n\n### union-attr\n\nAttribute not on all union members.\n\n```python\n# BAD\ndef process(x: int | str) -> None:\n    x.upper()  # error: \"int\" has no attribute \"upper\"\n\n# GOOD\ndef process(x: int | str) -> None:\n    if isinstance(x, str):\n        x.upper()\n```\n\n### var-annotated\n\nVariable needs type annotation.\n\n```python\n# BAD (with --disallow-untyped-defs)\ndef foo():\n    x = []  # error: Need type annotation for \"x\"\n    return x\n\n# GOOD\ndef foo() -> list[int]:\n    x: list[int] = []\n    return x\n```\n\n## Import Errors\n\n### import\n\nCannot find module.\n\n```python\n# BAD\nimport nonexistent_module  # error: Cannot find implementation or library stub\n\n# Fix: install the package or add type stubs\n# Or ignore: import nonexistent_module  # type: ignore[import]\n```\n\n### import-untyped\n\nImporting from untyped module.\n\n```python\n# BAD (with --disallow-untyped-imports)\nfrom untyped_lib import something  # error: Module has no type annotations\n\n# GOOD\nfrom untyped_lib import something  # type: ignore[import-untyped]\n# Or install type stubs: pip install types-untyped_lib\n```\n\n### no-redef\n\nName redefined.\n\n```python\n# BAD\ndef foo() -> int:\n    return 1\n\ndef foo() -> str:  # error: Name \"foo\" already defined\n    return \"hello\"\n\n# GOOD - use overload\nfrom typing import overload\n\n@overload\ndef foo(x: int) -> int: ...\n@overload\ndef foo(x: str) -> str: ...\n\ndef foo(x: int | str) -> int | str:\n    return x\n```\n\n## Function Errors\n\n### abstract\n\nAbstract method not implemented.\n\n```python\n# BAD\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def speak(self) -> str: ...\n\nclass Dog(Animal):  # error: Cannot instantiate abstract class\n    pass\n\n# GOOD\nclass Dog(Animal):\n    def speak(self) -> str:\n        return \"Woof\"\n```\n\n### override\n\nInvalid override.\n\n```python\n# BAD\nclass Base:\n    def foo(self, x: int) -> int:\n        return x\n\nclass Derived(Base):\n    def foo(self, x: str) -> str:  # error: Signature incompatible with supertype\n        return x\n\n# GOOD\nclass Derived(Base):\n    def foo(self, x: int) -> int:\n        return x * 2\n```\n\n### no-untyped-def\n\nFunction missing type annotations.\n\n```python\n# BAD (with --disallow-untyped-defs)\ndef add(a, b):  # error: Function is missing type annotations\n    return a + b\n\n# GOOD\ndef add(a: int, b: int) -> int:\n    return a + b\n```\n\n### no-untyped-call\n\nCalling untyped function.\n\n```python\n# BAD (with --disallow-untyped-calls)\ndef untyped(x):\n    return x\n\ndef typed(x: int) -> int:\n    return untyped(x)  # error: Call to untyped function in typed context\n\n# GOOD\ndef typed_untyped(x: int) -> int:\n    return x\n\ndef typed(x: int) -> int:\n    return typed_untyped(x)\n```\n\n## Class Errors\n\n### attr-defined\n\nAttribute not defined.\n\n```python\n# BAD\nclass Foo:\n    def __init__(self) -> None:\n        self.x = 1\n\nfoo = Foo()\nprint(foo.y)  # error: \"Foo\" has no attribute \"y\"\n\n# GOOD\nprint(foo.x)\n```\n\n### has-type\n\nCannot determine type of attribute.\n\n```python\n# BAD\nclass Foo:\n    x = None  # Cannot determine type\n\n# GOOD\nclass Foo:\n    x: int | None = None\n```\n\n### method-assign\n\nAssigning to method.\n\n```python\n# BAD\nclass Foo:\n    def bar(self) -> None: ...\n\nfoo = Foo()\nfoo.bar = lambda: None  # error: Cannot assign to a method\n\n# GOOD - use different attribute name\nfoo.custom_bar = lambda: None\n```\n\n### misc\n\nMiscellaneous errors.\n\n```python\n# Various errors that don't fit other categories\nclass Foo:\n    __slots__ = ['x']\n    y: int  # error: \"y\" not in __slots__\n```\n\n### name-defined\n\nName not defined.\n\n```python\n# BAD\nprint(undefined_var)  # error: Name \"undefined_var\" is not defined\n\n# GOOD\nundefined_var = \"now defined\"\nprint(undefined_var)\n```\n\n### safe-super\n\nUnsafe super() call.\n\n```python\n# BAD\nclass Foo:\n    @staticmethod\n    def bar() -> None:\n        super().baz()  # error: super() outside of method\n\n# GOOD\nclass Foo:\n    def bar(self) -> None:\n        super().baz()\n```\n\n### valid-type\n\nInvalid type.\n\n```python\n# BAD\nx: \"NonexistentType\"  # error: Name \"NonexistentType\" is not defined\n\n# GOOD\nfrom typing import Any\nx: Any  # or define the type\n```\n\n## Optional/None Errors\n\n### truthy-bool\n\nSuspicious boolean value.\n\n```python\n# BAD (with --strict-equality)\nfrom typing import Sequence\n\ndef foo(x: Sequence[int]) -> None:\n    if x:  # error: Sequence in boolean context\n        print(x)\n\n# GOOD - explicit check\ndef foo(x: Sequence[int]) -> None:\n    if len(x) > 0:\n        print(x)\n```\n\n### union-attr\n\nAttribute error on union.\n\n```python\n# BAD\ndef process(x: str | None) -> int:\n    return len(x)  # error: Item \"None\" has no attribute \"__len__\"\n\n# GOOD\ndef process(x: str | None) -> int:\n    if x is None:\n        return 0\n    return len(x)\n```\n\n### redundant-cast\n\nRedundant cast.\n\n```python\n# BAD\nfrom typing import cast\nx: int = 5\ny = cast(int, x)  # error: Redundant cast to \"int\"\n\n# GOOD\ny = x\n```\n\n### redundant-expr\n\nRedundant expression.\n\n```python\n# BAD\nx: int = 5\nif isinstance(x, int):  # error: Redundant isinstance call\n    pass\n\n# Remove redundant check\n```\n\n### unreachable\n\nUnreachable code.\n\n```python\n# BAD\ndef foo() -> int:\n    return 1\n    print(\"unreachable\")  # error: Statement is unreachable\n\n# GOOD\ndef foo() -> int:\n    print(\"before return\")\n    return 1\n```\n\n## Literal/Enum Errors\n\n### literal-required\n\nLiteral type required.\n\n```python\n# BAD\nfrom typing import Literal\n\ndef foo(x: Literal[\"a\", \"b\"]) -> None: ...\n\nvalue = \"a\"  # type is str\nfoo(value)  # error: Argument has incompatible type \"str\"; expected \"Literal['a', 'b']\"\n\n# GOOD\nvalue: Literal[\"a\", \"b\"] = \"a\"\nfoo(value)\n```\n\n### type-abstract\n\nCannot instantiate abstract type.\n\n```python\n# BAD\nfrom typing import Protocol\n\nclass Printable(Protocol):\n    def print(self) -> None: ...\n\nx = Printable()  # error: Cannot instantiate protocol class\n\n# GOOD\nclass Document:\n    def print(self) -> None:\n        print(\"Document\")\n\nx: Printable = Document()\n```\n\n## Strict Mode Errors\n\n### strict-equality\n\nInvalid equality comparison.\n\n```python\n# BAD (with --strict-equality)\nx: int = 5\nif x == \"5\":  # error: Non-overlapping equality check\n    pass\n\n# GOOD\nif str(x) == \"5\":\n    pass\n```\n\n### no-any-return\n\nReturning Any.\n\n```python\n# BAD (with --warn-return-any)\nfrom typing import Any\n\ndef foo() -> str:\n    x: Any = get_value()\n    return x  # error: Returning Any from function with declared return type \"str\"\n\n# GOOD\ndef foo() -> str:\n    x: Any = get_value()\n    return str(x)\n```\n\n### no-any-expr\n\nExpression has type Any.\n\n```python\n# BAD (with --disallow-any-expr)\nfrom typing import Any\nx: Any = 5\ny = x + 1  # error: Expression has type \"Any\"\n\n# GOOD\nx: int = 5\ny = x + 1\n```\n"}]}
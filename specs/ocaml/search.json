{"language": "ocaml", "generatedAt": "2026-01-06T18:23:22.316866+00:00", "entries": [{"path": "generation-checklist.md", "category": "spec", "name": "generation-checklist", "content": "# OCaml Generation Checklist\n\n**Read this BEFORE writing OCaml code. Let the type system work for you.**\n\n## Critical: You Must Do These\n\n### 1. Use Pattern Matching Exhaustively\n```ocaml\n(* BAD - non-exhaustive warning *)\nlet describe_status status =\n  match status with\n  | Active -> \"Active\"\n  | Pending -> \"Pending\"\n  (* Missing: Completed, Failed *)\n\n(* GOOD - exhaustive matching *)\nlet describe_status status =\n  match status with\n  | Active -> \"Active\"\n  | Pending -> \"Pending\"\n  | Completed -> \"Completed\"\n  | Failed -> \"Failed\"\n\n(* If you must have a catch-all, be explicit about intent *)\nlet describe_status status =\n  match status with\n  | Active -> \"Active\"\n  | Pending -> \"Pending\"\n  | _ -> \"Other\"  (* Document why this is OK *)\n```\n\n### 2. Use Option Instead of Exceptions for Expected Cases\n```ocaml\n(* BAD - exception for normal control flow *)\nlet find_user id =\n  if id_exists id then get_user id\n  else raise Not_found\n\n(* GOOD - Option for expected absence *)\nlet find_user id : user option =\n  if id_exists id then Some (get_user id)\n  else None\n\n(* Use Result for errors with information *)\nlet find_user id : (user, string) result =\n  if id_exists id then Ok (get_user id)\n  else Error (Printf.sprintf \"User %d not found\" id)\n```\n\n### 3. Make Invalid States Unrepresentable\n```ocaml\n(* BAD - allows invalid combinations *)\ntype user = {\n  name: string;\n  email: string option;\n  email_verified: bool;  (* What if email is None? *)\n}\n\n(* GOOD - impossible to have invalid state *)\ntype email_status =\n  | NoEmail\n  | Unverified of string\n  | Verified of string\n\ntype user = {\n  name: string;\n  email: email_status;\n}\n```\n\n### 4. Use Type Annotations for Module Boundaries\n```ocaml\n(* GOOD - explicit types at module boundaries *)\nmodule User : sig\n  type t\n  val create : string -> string -> t\n  val name : t -> string\n  val email : t -> string\nend = struct\n  type t = { name: string; email: string }\n  let create name email = { name; email }\n  let name u = u.name\n  let email u = u.email\nend\n```\n\n### 5. Avoid Mutable State When Possible\n```ocaml\n(* BAD - mutable accumulator *)\nlet sum_list lst =\n  let total = ref 0 in\n  List.iter (fun x -> total := !total + x) lst;\n  !total\n\n(* GOOD - functional fold *)\nlet sum_list lst =\n  List.fold_left ( + ) 0 lst\n\n(* BAD - in-place mutation *)\nlet arr = [| 1; 2; 3 |]\nlet () = arr.(0) <- 10\n\n(* GOOD - immutable data structures *)\nlet lst = [1; 2; 3]\nlet new_lst = 10 :: List.tl lst\n```\n\n## Important: Strong Recommendations\n\n### 6. Use Named Arguments for Clarity\n```ocaml\n(* BAD - unclear what each argument means *)\nlet create_user \"Alice\" \"alice@test.com\" true false 30\n\n(* GOOD - labeled arguments *)\nlet create_user ~name ~email ?(admin=false) ?(verified=false) ~age () =\n  { name; email; admin; verified; age }\n\nlet user = create_user\n  ~name:\"Alice\"\n  ~email:\"alice@test.com\"\n  ~verified:true\n  ~age:30\n  ()\n```\n\n### 7. Use the Pipeline Operator\n```ocaml\n(* BAD - nested function calls *)\nList.map String.uppercase_ascii (List.filter (fun s -> String.length s > 3) (String.split_on_char ' ' text))\n\n(* GOOD - pipeline operator |> *)\ntext\n|> String.split_on_char ' '\n|> List.filter (fun s -> String.length s > 3)\n|> List.map String.uppercase_ascii\n```\n\n### 8. Prefer Records Over Tuples for Multiple Values\n```ocaml\n(* BAD - tuple is unclear *)\nlet get_stats () = (42, 3.14, \"active\")  (* What do these mean? *)\n\n(* GOOD - record is self-documenting *)\ntype stats = {\n  count: int;\n  average: float;\n  status: string;\n}\n\nlet get_stats () = { count = 42; average = 3.14; status = \"active\" }\n```\n\n### 9. Use Variants for Finite Sets of Values\n```ocaml\n(* BAD - string for fixed set *)\nlet handle_status (status: string) =\n  if status = \"active\" then ...\n  else if status = \"pending\" then ...  (* Typo? Runtime error? *)\n\n(* GOOD - variant *)\ntype status = Active | Pending | Completed | Failed\n\nlet handle_status = function\n  | Active -> ...\n  | Pending -> ...\n  | Completed -> ...\n  | Failed -> ...  (* Compiler ensures all cases handled *)\n```\n\n### 10. Use GADTs for Type-Level Constraints\n```ocaml\n(* GOOD - type-safe expression evaluator *)\ntype _ expr =\n  | Int : int -> int expr\n  | Bool : bool -> bool expr\n  | Add : int expr * int expr -> int expr\n  | If : bool expr * 'a expr * 'a expr -> 'a expr\n\nlet rec eval : type a. a expr -> a = function\n  | Int n -> n\n  | Bool b -> b\n  | Add (e1, e2) -> eval e1 + eval e2\n  | If (cond, then_, else_) ->\n      if eval cond then eval then_ else eval else_\n\n(* Type error at compile time: *)\n(* eval (Add (Int 1, Bool true))  (* Won't compile! *) *)\n```\n\n## Functional Patterns\n\n### 11. Use `let*` and `let+` Syntax (OCaml 4.08+)\n```ocaml\n(* BAD - nested binds *)\nlet fetch_user_data id =\n  match find_user id with\n  | None -> None\n  | Some user ->\n      match find_profile user.id with\n      | None -> None\n      | Some profile -> Some (user, profile)\n\n(* GOOD - let* for monadic bind *)\nlet ( let* ) = Option.bind\nlet ( let+ ) opt f = Option.map f opt\n\nlet fetch_user_data id =\n  let* user = find_user id in\n  let* profile = find_profile user.id in\n  Some (user, profile)\n```\n\n### 12. Use `Result.bind` for Error Handling\n```ocaml\nlet ( let* ) = Result.bind\n\nlet process_data input =\n  let* validated = validate input in\n  let* parsed = parse validated in\n  let* transformed = transform parsed in\n  Ok transformed\n\n(* Handle at the boundary *)\nmatch process_data raw_input with\n| Ok result -> use_result result\n| Error msg -> log_error msg\n```\n\n### 13. Prefer `List.rev` Over Appending\n```ocaml\n(* BAD - O(n\u00b2) complexity *)\nlet rec map_bad f = function\n  | [] -> []\n  | x :: xs -> map_bad f xs @ [f x]\n\n(* GOOD - O(n) with accumulator *)\nlet map_good f lst =\n  let rec aux acc = function\n    | [] -> List.rev acc\n    | x :: xs -> aux (f x :: acc) xs\n  in\n  aux [] lst\n\n(* BEST - use standard library *)\nlet map_best f lst = List.map f lst\n```\n\n### 14. Use Modules for Namespacing and Abstraction\n```ocaml\n(* GOOD - module for related types and functions *)\nmodule Money : sig\n  type t\n  val of_cents : int -> t\n  val to_cents : t -> int\n  val add : t -> t -> t\n  val ( + ) : t -> t -> t\nend = struct\n  type t = int  (* cents *)\n  let of_cents x = x\n  let to_cents x = x\n  let add a b = a + b\n  let ( + ) = add\nend\n\n(* Usage *)\nlet total = Money.(of_cents 100 + of_cents 250)\n```\n\n## Performance\n\n### 15. Use Tail Recursion\n```ocaml\n(* BAD - not tail recursive (stack overflow on large lists) *)\nlet rec sum = function\n  | [] -> 0\n  | x :: xs -> x + sum xs  (* + is pending *)\n\n(* GOOD - tail recursive *)\nlet sum lst =\n  let rec aux acc = function\n    | [] -> acc\n    | x :: xs -> aux (acc + x) xs\n  in\n  aux 0 lst\n```\n\n### 16. Consider Hashtbl for Large Mutable Lookups\n```ocaml\n(* For immutable, small to medium: Map *)\nmodule StringMap = Map.Make(String)\nlet m = StringMap.(empty |> add \"key\" 42)\n\n(* For mutable, large datasets: Hashtbl *)\nlet h = Hashtbl.create 1000\nlet () = Hashtbl.add h \"key\" 42\nlet value = Hashtbl.find_opt h \"key\"\n```\n\n---\n\n**Quick Reference - Copy This Mental Model:**\n- Exhaustive pattern matching\n- Option/Result for expected absence/errors\n- Make invalid states unrepresentable\n- Type annotations at module boundaries\n- Immutable by default\n- Labeled arguments for clarity\n- Pipeline operator `|>`\n- Records over tuples\n- Variants for finite sets\n- `let*` syntax for monadic code\n- `List.rev` pattern for accumulation\n- Modules for abstraction\n- Tail recursion for lists\n"}, {"path": "patterns/idioms.md", "category": "patterns", "name": "patterns/idioms", "content": "# OCaml Idioms\n\n## Prefer pattern matching\n\nUse pattern matching for algebraic data types.\n\n## Use immutable data\n\nFavor immutability in core logic.\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# OCaml Formatters\n\nocamlformat is the standard formatter.\n\nSee: https://github.com/ocaml-ppx/ocamlformat\n"}, {"path": "stdlib/overview.md", "category": "stdlib", "name": "stdlib/overview", "content": "OCaml - The standard library\u2630\u2630The OCaml library\n\n- [The core library](core.html)\n- [The standard library](stdlib.html)\n- [The compiler front-end](parsing.html)\n- [The unix library: Unix system calls](libunix.html)\n- [The str library: regular expressions and string processing](libstr.html)\n- [The runtime_events library](runtime_events.html)\n- [The threads library](libthreads.html)\n- [The dynlink library: dynamic loading and linking of object files](libdynlink.html)\n- [Recently removed or moved libraries (Graphics, Bigarray, Num, LablTk)](old.html)\n\nhttps://ocaml.org/[Version 5.4](https://ocaml.org/releases/)[< The OCaml Manual](index.html)\n\n# Chapter 29 The standard library\n\nThis chapter describes the functions provided by the OCaml standard library. The modules from the standard library are automatically linked with the user\u2019s object code files by the ocamlc command. Hence, these modules can be used in standalone programs without having to add any .cmo file on the command line for the linking phase. Similarly, in interactive use, these globals can be used in toplevel phrases without having to load any .cmo file in memory.\n\nUnlike the core Stdlib module, submodules are not automatically \u201copened\u201d when compilation starts, or when the toplevel system is launched. Hence it is necessary to use qualified identifiers to refer to the functions provided by these modules, or to add open directives.\n\n- [Module Arg](api/Arg.html): parsing of command line arguments \n- [Module Array](api/Array.html): array operations \n- [Module ArrayLabels](api/ArrayLabels.html): array operations (with labels) \n- [Module Atomic](api/Atomic.html): atomic references \n- [Module Bigarray](api/Bigarray.html): large, multi-dimensional, numerical arrays \n- [Module Bool](api/Bool.html): boolean values \n- [Module Buffer](api/Buffer.html): extensible buffers \n- [Module Bytes](api/Bytes.html): byte sequences \n- [Module BytesLabels](api/BytesLabels.html): byte sequences (with labels) \n- [Module Callback](api/Callback.html): registering OCaml values with the C runtime \n- [Module Char](api/Char.html): character operations \n- [Module Complex](api/Complex.html): complex numbers \n- [Module Condition](api/Condition.html): condition variables to synchronize between threads \n- [Module Domain](api/Domain.html): Domain spawn/join and domain local variables \n- [Module Digest](api/Digest.html): MD5 message digest \n- [Module Dynarray](api/Dynarray.html): Dynamic arrays \n- [Module Iarray](api/Iarray.html): Immutable arrays \n- [Module Effect](api/Effect.html): deep and shallow effect handlers \n- [Module Either](api/Either.html): either values \n- [Module Ephemeron](api/Ephemeron.html): Ephemerons and weak hash table \n- [Module Filename](api/Filename.html): operations on file names \n- [Module Float](api/Float.html): floating-point numbers \n- [Module Format](api/Format.html): pretty printing \n- [Module Fun](api/Fun.html): function values \n- [Module Gc](api/Gc.html): memory management control and statistics; finalized values \n- [Module Hashtbl](api/Hashtbl.html): hash tables and hash functions \n- [Module In_channel](api/In_channel.html): input channels \n- [Module Int](api/Int.html): integers \n- [Module Int32](api/Int32.html): 32-bit integers \n- [Module Int64](api/Int64.html): 64-bit integers \n- [Module Lazy](api/Lazy.html): deferred computations \n- [Module Lexing](api/Lexing.html): the run-time library for lexers generated by ocamllex\n- [Module List](api/List.html): list operations \n- [Module ListLabels](api/ListLabels.html): list operations (with labels) \n- [Module Map](api/Map.html): association tables over ordered types \n- [Module Marshal](api/Marshal.html): marshaling of data structures \n- [Module MoreLabels](api/MoreLabels.html): include modules Hashtbl, Map and Set with labels \n- [Module Mutex](api/Mutex.html): locks for mutual exclusion \n- [Module Nativeint](api/Nativeint.html): processor-native integers \n- [Module Oo](api/Oo.html): object-oriented extension \n- [Module Option](api/Option.html): option values \n- [Module Out_channel](api/Out_channel.html): output channels \n- [Module Pair](api/Pair.html): pairs of values \n- [Module Parsing](api/Parsing.html): the run-time library for parsers generated by ocamlyacc\n- [Module Pqueue](api/Pqueue.html): priority queues \n- [Module Printexc](api/Printexc.html): facilities for printing exceptions \n- [Module Printf](api/Printf.html): formatting printing functions \n- [Module Queue](api/Queue.html): first-in first-out queues \n- [Module Random](api/Random.html): pseudo-random number generator (PRNG) \n- [Module Repr](api/Repr.html): functions defined on the low-level representation of values \n- [Module Result](api/Result.html): result values \n- [Module Scanf](api/Scanf.html): formatted input functions \n- [Module Seq](api/Seq.html): functional iterators \n- [Module Set](api/Set.html): sets over ordered types \n- [Module Semaphore](api/Semaphore.html): semaphores, another thread synchronization mechanism \n- [Module Stack](api/Stack.html): last-in first-out stacks \n- [Module StdLabels](api/StdLabels.html): include modules Array, List, String and Iarray with labels \n- [Module String](api/String.html): string operations \n- [Module StringLabels](api/StringLabels.html): string operations (with labels) \n- [Module Sys](api/Sys.html): system interface \n- [Module Type](api/Type.html): type introspection \n- [Module Uchar](api/Uchar.html): Unicode characters \n- [Module Unit](api/Unit.html): unit values \n- [Module Weak](api/Weak.html): arrays of weak pointers \n\n[\u00ab The core library](core.html)[The compiler front-end \u00bb](parsing.html)Copyright \u00a9 2025 Institut National de Recherche en Informatique et en Automatique\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# OCaml Manual\nVersion: unknown\n\nSource: https://ocaml.org/manual/\n\n\nSee: https://ocaml.org/manual/\n"}, {"path": "linters/overview.md", "category": "linters", "name": "linters/overview", "content": "# OCaml Linters\n\nA common linter is ocamlformat (formatting) and odoclint.\n\nSee:\n- https://github.com/ocaml-ppx/ocamlformat\n- https://github.com/ocaml/odoc\n"}]}
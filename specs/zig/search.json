{"language": "zig", "generatedAt": "2026-01-06T18:23:22.401025+00:00", "entries": [{"path": "generation-checklist.md", "category": "spec", "name": "generation-checklist", "content": "# Zig Generation Checklist\n\n**Read this BEFORE writing Zig code. Safety and explicit behavior are core values.**\n\n## Critical: You Must Do These\n\n### 1. Handle All Errors Explicitly\n```zig\n// BAD - ignoring error\nconst file = std.fs.cwd().openFile(\"data.txt\", .{}) catch unreachable;\n\n// GOOD - handle error explicitly\nconst file = std.fs.cwd().openFile(\"data.txt\", .{}) catch |err| {\n    std.debug.print(\"Failed to open file: {}\\n\", .{err});\n    return err;\n};\ndefer file.close();\n\n// GOOD - propagate with try\nconst file = try std.fs.cwd().openFile(\"data.txt\", .{});\n\n// GOOD - with error union return type\nfn readConfig() !Config {\n    const file = try std.fs.cwd().openFile(\"config.txt\", .{});\n    defer file.close();\n    // ...\n}\n```\n\n### 2. Use `defer` for Cleanup\n```zig\n// BAD - might forget to clean up\nfn process() !void {\n    const allocator = std.heap.page_allocator;\n    const buffer = try allocator.alloc(u8, 1024);\n\n    if (condition) return;  // Memory leak!\n\n    allocator.free(buffer);\n}\n\n// GOOD - defer ensures cleanup\nfn process() !void {\n    const allocator = std.heap.page_allocator;\n    const buffer = try allocator.alloc(u8, 1024);\n    defer allocator.free(buffer);\n\n    if (condition) return;  // Still freed!\n    // ... use buffer ...\n}\n```\n\n### 3. Use Proper Allocators\n```zig\n// BAD - using page allocator for small allocations\nconst allocator = std.heap.page_allocator;\nconst small = try allocator.alloc(u8, 16);  // Wasteful!\n\n// GOOD - choose appropriate allocator\n// For general purpose:\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\ndefer _ = gpa.deinit();\nconst allocator = gpa.allocator();\n\n// For arena (bulk allocation, single free):\nvar arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\ndefer arena.deinit();\nconst allocator = arena.allocator();\n\n// Accept allocator as parameter for flexibility\nfn createBuffer(allocator: std.mem.Allocator, size: usize) ![]u8 {\n    return try allocator.alloc(u8, size);\n}\n```\n\n### 4. Initialize All Variables\n```zig\n// BAD - undefined value\nvar x: i32 = undefined;\nif (condition) x = 5;\nstd.debug.print(\"{}\", .{x});  // Undefined behavior if !condition\n\n// GOOD - initialize or use optional\nvar x: i32 = 0;\nif (condition) x = 5;\n\n// GOOD - use optional for \"maybe has value\"\nvar x: ?i32 = null;\nif (condition) x = 5;\nif (x) |value| {\n    std.debug.print(\"{}\", .{value});\n}\n```\n\n### 5. Check Slice Bounds\n```zig\n// BAD - trusting index\nfn getItem(items: []const Item, index: usize) Item {\n    return items[index];  // Panics if out of bounds!\n}\n\n// GOOD - return optional or error\nfn getItem(items: []const Item, index: usize) ?Item {\n    if (index >= items.len) return null;\n    return items[index];\n}\n\n// GOOD - use slice range safely\nfn getSlice(data: []const u8, start: usize, end: usize) ?[]const u8 {\n    if (start > end or end > data.len) return null;\n    return data[start..end];\n}\n```\n\n## Important: Strong Recommendations\n\n### 6. Prefer Slices Over Pointers\n```zig\n// BAD - raw pointer loses length info\nfn process(ptr: [*]u8, len: usize) void { ... }\n\n// GOOD - slice includes length\nfn process(data: []u8) void { ... }\n\n// GOOD - const slice for read-only\nfn analyze(data: []const u8) void { ... }\n```\n\n### 7. Use Comptime for Zero-Cost Abstractions\n```zig\n// GOOD - compile-time evaluation\nfn multiplyMatrices(comptime N: usize, a: [N][N]f32, b: [N][N]f32) [N][N]f32 {\n    var result: [N][N]f32 = undefined;\n    inline for (0..N) |i| {\n        inline for (0..N) |j| {\n            var sum: f32 = 0;\n            inline for (0..N) |k| {\n                sum += a[i][k] * b[k][j];\n            }\n            result[i][j] = sum;\n        }\n    }\n    return result;\n}\n\n// GOOD - comptime string formatting\nconst message = std.fmt.comptimePrint(\"Version {}.{}\", .{ 1, 0 });\n```\n\n### 8. Use Enums and Tagged Unions\n```zig\n// GOOD - enum for fixed set of values\nconst Status = enum {\n    pending,\n    active,\n    completed,\n    failed,\n};\n\n// GOOD - tagged union for variants with data\nconst Result = union(enum) {\n    success: Data,\n    err: Error,\n    pending: void,\n};\n\nfn process(result: Result) void {\n    switch (result) {\n        .success => |data| handleSuccess(data),\n        .err => |e| handleError(e),\n        .pending => {},\n    }\n}\n```\n\n### 9. Use `std.ArrayList` for Dynamic Arrays\n```zig\n// GOOD - ArrayList for growing collections\nvar list = std.ArrayList(Item).init(allocator);\ndefer list.deinit();\n\ntry list.append(item1);\ntry list.append(item2);\n\nfor (list.items) |item| {\n    processItem(item);\n}\n```\n\n### 10. Prefer `orelse` for Optionals\n```zig\n// GOOD - orelse for default values\nconst value = maybe_value orelse default_value;\n\n// GOOD - orelse with block for complex fallback\nconst config = loadConfig() orelse {\n    std.debug.print(\"Using default config\\n\", .{});\n    return defaultConfig();\n};\n\n// GOOD - .? for unwrap when you're sure (use sparingly)\nconst definitely_has_value = optional.?;\n```\n\n## Testing\n\n### 11. Write Tests in the Same File\n```zig\nfn add(a: i32, b: i32) i32 {\n    return a + b;\n}\n\n// Tests are part of the module\ntest \"add positive numbers\" {\n    try std.testing.expectEqual(@as(i32, 5), add(2, 3));\n}\n\ntest \"add negative numbers\" {\n    try std.testing.expectEqual(@as(i32, -5), add(-2, -3));\n}\n\ntest \"add mixed\" {\n    try std.testing.expectEqual(@as(i32, 1), add(-2, 3));\n}\n\n// Run with: zig build test\n```\n\n### 12. Use Testing Allocator\n```zig\ntest \"no memory leaks\" {\n    var allocator = std.testing.allocator;\n\n    const buffer = try allocator.alloc(u8, 100);\n    defer allocator.free(buffer);\n\n    // Test code...\n    // Testing allocator will fail if any memory is not freed\n}\n```\n\n## Safety and Performance\n\n### 13. Use `@intCast` Carefully\n```zig\n// BAD - assuming value fits\nconst small: u8 = @intCast(big_value);  // Undefined behavior if > 255!\n\n// GOOD - check first or use saturating/wrapping\nconst small: u8 = std.math.cast(u8, big_value) orelse {\n    return error.ValueTooLarge;\n};\n\n// Or use saturating cast\nconst small: u8 = @truncate(@min(big_value, 255));\n```\n\n### 14. Prefer Explicit Over Implicit\n```zig\n// Zig philosophy: be explicit\n\n// Explicit error handling\nconst result = try riskyOperation();\n\n// Explicit null handling\nif (optional) |value| { ... }\n\n// Explicit type conversion\nconst float: f32 = @floatFromInt(integer);\n\n// Explicit overflow behavior\nconst sum = @addWithOverflow(a, b);\nif (sum[1] != 0) return error.Overflow;\n```\n\n### 15. Use `packed struct` Sparingly\n```zig\n// Regular struct - better alignment, faster access\nconst Normal = struct {\n    a: u8,\n    b: u32,\n    c: u8,\n};  // Size: 12 bytes (with padding)\n\n// Packed struct - exact layout, may be slower\nconst Packed = packed struct {\n    a: u8,\n    b: u32,\n    c: u8,\n};  // Size: 6 bytes (no padding)\n\n// Use packed only when you need:\n// - Exact memory layout for FFI\n// - Bit-level field access\n// - Memory-mapped I/O\n```\n\n---\n\n**Quick Reference - Copy This Mental Model:**\n- Handle all errors with `try` or `catch`\n- `defer` for cleanup\n- Choose appropriate allocator\n- Initialize all variables (no `undefined` leaking)\n- Check slice bounds\n- Slices over raw pointers\n- Comptime for zero-cost abstractions\n- Tagged unions for variants\n- `ArrayList` for dynamic arrays\n- `orelse` for optional defaults\n- Tests in the same file\n- Testing allocator catches leaks\n- Explicit type conversions\n- Check overflow explicitly\n"}, {"path": "patterns/idioms.md", "category": "patterns", "name": "patterns/idioms", "content": "# Zig Idioms\n\n## Prefer explicit error handling\n\nUse `try` and `catch` to propagate errors.\n\n## Use `defer` for cleanup\n\nKeep resource management explicit.\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# Zig Formatters\n\nUse the built-in formatter.\n\nSee: https://ziglang.org/documentation/master/#Formatting\n"}, {"path": "stdlib/overview.md", "category": "stdlib", "name": "stdlib/overview", "content": "Zig Documentation#\n\nLoading...\n\n# [[src]](#)\n\n```\n```\n\n## Parameters\n\n## Errors\n\nanyerror means the error set is known only at runtime.\n\n## Search Results\n\n## No Results Found\n\nPress escape to exit search and then '?' to see more options.\n\n## Fields\n\n## Types\n\n## Namespaces\n\n## Global Variables\n\n## Values\n\n## Functions\n\n## Error Sets\n\n## Example Usage\n\n```\n```\n\n## Source Code\n\n```\n```\n\n# Keyboard Shortcuts\n\n?Show this help dialogEscClear focus; close this dialogsFocus the search fielduGo to source code\u2191Move up in search results\u2193Move down in search results\u23ceGo to active search result\n\n# Errors\n\n```\n```\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# Zig Language Reference\nVersion: master\n\nSource: https://ziglang.org/documentation/master/\n\n\nSee: https://ziglang.org/documentation/master/\n"}, {"path": "linters/overview.md", "category": "linters", "name": "linters/overview", "content": "# Zig Linters\n\nThere is no official linter; rely on the compiler and zig fmt.\n"}]}
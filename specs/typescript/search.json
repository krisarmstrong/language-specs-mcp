{"language": "typescript", "generatedAt": "2026-01-05T20:16:25.164690+00:00", "entries": [{"path": "patterns/idioms.md", "category": "patterns", "name": "patterns/idioms", "content": "# TypeScript Idiomatic Patterns\n\n## Use explicit types for function signatures\n\n```typescript\n// BAD\nfunction process(data) {\n  return data.map(x => x.value);\n}\n\n// GOOD\nfunction process(data: Item[]): string[] {\n  return data.map((x) => x.value);\n}\n```\n\n## Never use `any`\n\n```typescript\n// BAD\nconst data: any = response.body;\n\n// GOOD\ninterface ResponseBody {\n  items: Item[];\n  total: number;\n}\nconst data: ResponseBody = response.body;\n\n// If truly unknown, use `unknown` and narrow\nconst data: unknown = response.body;\nif (isResponseBody(data)) {\n  // data is now ResponseBody\n}\n```\n\n## Use `readonly` for immutable data\n\n```typescript\ninterface Config {\n  readonly apiUrl: string;\n  readonly timeout: number;\n}\n```\n\n## Prefer interfaces over type aliases for objects\n\n```typescript\n// Prefer\ninterface User {\n  id: string;\n  name: string;\n}\n\n// Over\ntype User = {\n  id: string;\n  name: string;\n};\n```\n\n## Use discriminated unions\n\n```typescript\ninterface Success {\n  kind: \"success\";\n  data: Data;\n}\n\ninterface Failure {\n  kind: \"failure\";\n  error: Error;\n}\n\ntype Result = Success | Failure;\n\nfunction handle(result: Result) {\n  switch (result.kind) {\n    case \"success\":\n      return result.data;\n    case \"failure\":\n      throw result.error;\n  }\n}\n```\n\n## Use `satisfies` for type checking without widening\n\n```typescript\nconst config = {\n  apiUrl: \"https://api.example.com\",\n  timeout: 5000,\n} satisfies Config;\n```\n\n## Prefer `for...of` over `forEach`\n\n```typescript\n// BAD - can't break, can't await properly\nitems.forEach((item) => {\n  process(item);\n});\n\n// GOOD\nfor (const item of items) {\n  await process(item);\n}\n```\n\n## Use type guards\n\n```typescript\nfunction isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nfunction isUser(value: unknown): value is User {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"id\" in value &&\n    \"name\" in value\n  );\n}\n```\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# TypeScript Formatters\n\n## Prettier\n\nSee: https://prettier.io/docs/en/\n\n## Biome Format\n\nSee: https://biomejs.dev/formatter/\n"}, {"path": "formatters/biome.md", "category": "formatters", "name": "formatters/biome", "content": "# Biome Formatter Options\n\nSee: https://biomejs.dev/formatter/\n"}, {"path": "formatters/prettier.md", "category": "formatters", "name": "formatters/prettier", "content": "# Prettier Options\nVersion: unknown\n\nSource: https://prettier.io/docs/en/options.html\n\n\nSee: https://prettier.io/docs/en/options.html\n"}, {"path": "lib/type-inference.md", "category": "stdlib", "name": "lib/type-inference", "content": "# type-inference\n\nSee: https://www.typescriptlang.org/docs/handbook/type-inference.html\n"}, {"path": "lib/generics.md", "category": "stdlib", "name": "lib/generics", "content": "# generics\n\nSee: https://www.typescriptlang.org/docs/handbook/generics.html\n"}, {"path": "lib/classes.md", "category": "stdlib", "name": "lib/classes", "content": "# classes\n\nSee: https://www.typescriptlang.org/docs/handbook/classes.html\n"}, {"path": "lib/interfaces.md", "category": "stdlib", "name": "lib/interfaces", "content": "# interfaces\n\nSee: https://www.typescriptlang.org/docs/handbook/interfaces.html\n"}, {"path": "lib/functions.md", "category": "stdlib", "name": "lib/functions", "content": "# functions\n\nSee: https://www.typescriptlang.org/docs/handbook/functions.html\n"}, {"path": "lib/type-compatibility.md", "category": "stdlib", "name": "lib/type-compatibility", "content": "# type-compatibility\n\nSee: https://www.typescriptlang.org/docs/handbook/type-compatibility.html\n"}, {"path": "lib/basic-types.md", "category": "stdlib", "name": "lib/basic-types", "content": "# basic-types\n\nSee: https://www.typescriptlang.org/docs/handbook/basic-types.html\n"}, {"path": "lib/enums.md", "category": "stdlib", "name": "lib/enums", "content": "# enums\n\nSee: https://www.typescriptlang.org/docs/handbook/enums.html\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# TypeScript Language Specification\nVersion: unknown\n\nSource: https://www.typescriptlang.org/docs/handbook/\n\n\n## Basic Types\n\n```typescript\n// Primitives\nlet isDone: boolean = false;\nlet decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\nlet big: bigint = 100n;\nlet color: string = \"blue\";\nlet sym: symbol = Symbol(\"key\");\n\n// Arrays\nlet list: number[] = [1, 2, 3];\nlet list: Array<number> = [1, 2, 3];\nlet tuple: [string, number] = [\"hello\", 10];\n\n// Special types\nlet notSure: unknown = 4;\nlet nothing: void = undefined;\nlet u: undefined = undefined;\nlet n: null = null;\nlet neverReturns: never;  // function that never returns\n```\n\n## Type Annotations\n\n```typescript\n// Variables\nlet name: string = \"Alice\";\n\n// Functions\nfunction greet(name: string): string {\n    return `Hello, ${name}`;\n}\n\n// Arrow functions\nconst add = (a: number, b: number): number => a + b;\n\n// Optional parameters\nfunction greet(name: string, greeting?: string): string {\n    return `${greeting ?? \"Hello\"}, ${name}`;\n}\n\n// Default parameters\nfunction greet(name: string, greeting: string = \"Hello\"): string {\n    return `${greeting}, ${name}`;\n}\n\n// Rest parameters\nfunction sum(...numbers: number[]): number {\n    return numbers.reduce((a, b) => a + b, 0);\n}\n```\n\n## Interfaces\n\n```typescript\ninterface User {\n    id: number;\n    name: string;\n    email: string;\n    age?: number;  // optional\n    readonly createdAt: Date;  // readonly\n}\n\n// Extending interfaces\ninterface Admin extends User {\n    permissions: string[];\n}\n\n// Function types\ninterface SearchFunc {\n    (source: string, subString: string): boolean;\n}\n\n// Index signatures\ninterface StringMap {\n    [key: string]: string;\n}\n\n// Callable\ninterface Callable {\n    (arg: string): void;\n    property: string;\n}\n```\n\n## Type Aliases\n\n```typescript\ntype ID = string | number;\ntype Point = { x: number; y: number };\ntype Callback = (data: string) => void;\n\n// Generic type alias\ntype Container<T> = { value: T };\ntype Result<T, E> = { ok: true; value: T } | { ok: false; error: E };\n```\n\n## Union and Intersection Types\n\n```typescript\n// Union - either type\ntype StringOrNumber = string | number;\ntype Status = \"pending\" | \"approved\" | \"rejected\";\n\nfunction format(value: string | number): string {\n    if (typeof value === \"string\") {\n        return value.toUpperCase();\n    }\n    return value.toFixed(2);\n}\n\n// Intersection - both types\ntype Employee = Person & { employeeId: number };\n\ninterface Colorful {\n    color: string;\n}\ninterface Circle {\n    radius: number;\n}\ntype ColorfulCircle = Colorful & Circle;\n```\n\n## Literal Types\n\n```typescript\n// String literals\ntype Direction = \"north\" | \"south\" | \"east\" | \"west\";\n\n// Numeric literals\ntype DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;\n\n// Boolean literal\ntype True = true;\n\n// Template literal types\ntype EventName = `on${string}`;\ntype PropName = `get${Capitalize<string>}`;\n```\n\n## Generics\n\n```typescript\n// Generic function\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\n// Generic interface\ninterface Box<T> {\n    contents: T;\n}\n\n// Generic class\nclass Queue<T> {\n    private data: T[] = [];\n    \n    push(item: T): void {\n        this.data.push(item);\n    }\n    \n    pop(): T | undefined {\n        return this.data.shift();\n    }\n}\n\n// Generic constraints\ninterface HasLength {\n    length: number;\n}\n\nfunction logLength<T extends HasLength>(arg: T): number {\n    return arg.length;\n}\n\n// Multiple type parameters\nfunction pair<T, U>(first: T, second: U): [T, U] {\n    return [first, second];\n}\n\n// Default type parameters\ntype Container<T = string> = { value: T };\n```\n\n## Utility Types\n\n```typescript\n// Partial - all properties optional\ntype PartialUser = Partial<User>;\n\n// Required - all properties required\ntype RequiredUser = Required<User>;\n\n// Readonly - all properties readonly\ntype ReadonlyUser = Readonly<User>;\n\n// Pick - select properties\ntype UserPreview = Pick<User, \"id\" | \"name\">;\n\n// Omit - exclude properties\ntype UserWithoutEmail = Omit<User, \"email\">;\n\n// Record - construct object type\ntype UserMap = Record<string, User>;\n\n// Exclude - exclude from union\ntype NotNull = Exclude<string | null | undefined, null | undefined>;\n\n// Extract - extract from union\ntype JustStrings = Extract<string | number | boolean, string>;\n\n// NonNullable - remove null/undefined\ntype NotNullable = NonNullable<string | null>;\n\n// ReturnType - get function return type\ntype Returned = ReturnType<typeof someFunction>;\n\n// Parameters - get function parameters as tuple\ntype Params = Parameters<typeof someFunction>;\n\n// Awaited - unwrap Promise\ntype Data = Awaited<Promise<string>>;  // string\n```\n\n## Type Guards\n\n```typescript\n// typeof guard\nfunction process(value: string | number) {\n    if (typeof value === \"string\") {\n        // value is string here\n        return value.toUpperCase();\n    }\n    // value is number here\n    return value * 2;\n}\n\n// instanceof guard\nfunction logDate(value: Date | string) {\n    if (value instanceof Date) {\n        console.log(value.toISOString());\n    } else {\n        console.log(value);\n    }\n}\n\n// in guard\ninterface Fish {\n    swim: () => void;\n}\ninterface Bird {\n    fly: () => void;\n}\n\nfunction move(animal: Fish | Bird) {\n    if (\"swim\" in animal) {\n        animal.swim();\n    } else {\n        animal.fly();\n    }\n}\n\n// Custom type guard\nfunction isString(value: unknown): value is string {\n    return typeof value === \"string\";\n}\n\nfunction isUser(value: unknown): value is User {\n    return (\n        typeof value === \"object\" &&\n        value !== null &&\n        \"id\" in value &&\n        \"name\" in value\n    );\n}\n```\n\n## Discriminated Unions\n\n```typescript\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n\ninterface Square {\n    kind: \"square\";\n    sideLength: number;\n}\n\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\n\ntype Shape = Circle | Square | Rectangle;\n\nfunction area(shape: Shape): number {\n    switch (shape.kind) {\n        case \"circle\":\n            return Math.PI * shape.radius ** 2;\n        case \"square\":\n            return shape.sideLength ** 2;\n        case \"rectangle\":\n            return shape.width * shape.height;\n    }\n}\n```\n\n## Classes\n\n```typescript\nclass Animal {\n    // Properties\n    public name: string;\n    protected age: number;\n    private secret: string;\n    readonly species: string;\n    \n    // Static\n    static count = 0;\n    \n    // Constructor\n    constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n        this.secret = \"hidden\";\n        this.species = \"unknown\";\n        Animal.count++;\n    }\n    \n    // Methods\n    speak(): void {\n        console.log(`${this.name} makes a sound`);\n    }\n    \n    // Getters/setters\n    get info(): string {\n        return `${this.name}, age ${this.age}`;\n    }\n    \n    set nickname(value: string) {\n        this.name = value;\n    }\n}\n\n// Inheritance\nclass Dog extends Animal {\n    constructor(name: string, age: number) {\n        super(name, age);\n    }\n    \n    override speak(): void {\n        console.log(`${this.name} barks`);\n    }\n}\n\n// Abstract classes\nabstract class Shape {\n    abstract area(): number;\n    \n    describe(): string {\n        return `Area: ${this.area()}`;\n    }\n}\n\n// Implementing interfaces\ninterface Printable {\n    print(): void;\n}\n\nclass Document implements Printable {\n    print(): void {\n        console.log(\"Printing...\");\n    }\n}\n```\n\n## Enums\n\n```typescript\n// Numeric enum\nenum Direction {\n    Up,      // 0\n    Down,    // 1\n    Left,    // 2\n    Right,   // 3\n}\n\n// String enum\nenum Status {\n    Pending = \"PENDING\",\n    Approved = \"APPROVED\",\n    Rejected = \"REJECTED\",\n}\n\n// Const enum (inlined at compile time)\nconst enum Color {\n    Red,\n    Green,\n    Blue,\n}\n\n// Usage\nlet dir: Direction = Direction.Up;\nlet status: Status = Status.Pending;\n```\n\n## Modules\n\n```typescript\n// Export\nexport const PI = 3.14159;\nexport function add(a: number, b: number): number {\n    return a + b;\n}\nexport class Calculator {}\nexport type Result = { value: number };\nexport interface Config {}\n\n// Default export\nexport default class MyClass {}\n\n// Import\nimport { add, PI } from \"./math\";\nimport type { Result } from \"./math\";\nimport MyClass from \"./myclass\";\nimport * as math from \"./math\";\n\n// Re-export\nexport { add } from \"./math\";\nexport * from \"./utils\";\nexport type { Config } from \"./config\";\n```\n\n## Decorators\n\n```typescript\n// Class decorator\nfunction logged(constructor: Function) {\n    console.log(`Creating: ${constructor.name}`);\n}\n\n@logged\nclass MyClass {}\n\n// Method decorator\nfunction log(target: any, key: string, descriptor: PropertyDescriptor) {\n    const original = descriptor.value;\n    descriptor.value = function (...args: any[]) {\n        console.log(`Calling ${key}`);\n        return original.apply(this, args);\n    };\n}\n\nclass Calculator {\n    @log\n    add(a: number, b: number) {\n        return a + b;\n    }\n}\n\n// Property decorator\nfunction required(target: any, key: string) {\n    // validation logic\n}\n```\n\n## Conditional Types\n\n```typescript\n// Basic conditional\ntype IsString<T> = T extends string ? true : false;\n\n// Infer keyword\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\ntype ElementType<T> = T extends (infer E)[] ? E : never;\n\n// Distributive conditional types\ntype ToArray<T> = T extends any ? T[] : never;\ntype StrOrNumArray = ToArray<string | number>;  // string[] | number[]\n```\n\n## Mapped Types\n\n```typescript\n// Make all properties optional\ntype Partial<T> = {\n    [P in keyof T]?: T[P];\n};\n\n// Make all properties required\ntype Required<T> = {\n    [P in keyof T]-?: T[P];\n};\n\n// Make all properties readonly\ntype Readonly<T> = {\n    readonly [P in keyof T]: T[P];\n};\n\n// Custom mapped type\ntype Getters<T> = {\n    [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P];\n};\n```\n\n## Template Literal Types\n\n```typescript\ntype World = \"world\";\ntype Greeting = `hello ${World}`;  // \"hello world\"\n\ntype EmailLocale = \"welcome_email\" | \"email_heading\";\ntype FooterLocale = \"footer_title\" | \"footer_sendoff\";\ntype AllLocale = `${EmailLocale | FooterLocale}_id`;\n\n// With mapped types\ntype Getters<T> = {\n    [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n```\n\n## Satisfies Operator (4.9+)\n\n```typescript\n// Type-check without widening\nconst config = {\n    width: 100,\n    height: 200,\n} satisfies Record<string, number>;\n\n// config.width is still number, not string | number\n\n// Useful for complex object literals\ntype Colors = \"red\" | \"green\" | \"blue\";\nconst palette = {\n    red: [255, 0, 0],\n    green: \"#00ff00\",\n    blue: [0, 0, 255],\n} satisfies Record<Colors, string | number[]>;\n\n// palette.green is string, not string | number[]\n```\n\n## Const Assertions\n\n```typescript\n// as const makes everything readonly and literal\nconst config = {\n    endpoint: \"https://api.example.com\",\n    retries: 3,\n} as const;\n\n// config.endpoint is \"https://api.example.com\", not string\n// config.retries is 3, not number\n\nconst directions = [\"up\", \"down\"] as const;\n// directions is readonly [\"up\", \"down\"]\ntype Direction = (typeof directions)[number];  // \"up\" | \"down\"\n```\n"}, {"path": "linters/biome/noNonNullAssertion.md", "category": "linters", "name": "linters/biome/noNonNullAssertion", "content": "# noNonNullAssertion\n\nDisallow non-null assertions using the `!` postfix operator.\n\n## Why\n\nNon-null assertions bypass TypeScript's strict null checks and can cause runtime errors.\n\n## Invalid\n\n```typescript\nconst value = maybeNull!;\nobj.property!.method();\n```\n\n## Valid\n\n```typescript\nif (maybeNull !== null) {\n  const value = maybeNull;\n}\n\n// Or use optional chaining\nobj.property?.method();\n```\n"}, {"path": "linters/biome/overview.md", "category": "linters", "name": "linters/biome/overview", "content": "# Biome Linter - Complete Rules Reference\nVersion: unknown\n\nSource: https://biomejs.dev/linter/rules/\n\n\n**Source:** https://biomejs.dev/linter/\n\nBiome is a fast formatter and linter for JavaScript, TypeScript, JSX, JSON, CSS.\n\n## Rule Categories\n\n| Category | Purpose |\n|----------|---------|\n| correctness | Prevent bugs and incorrect behavior |\n| suspicious | Potentially problematic patterns |\n| style | Code style consistency |\n| complexity | Reduce cognitive complexity |\n| performance | Optimize runtime performance |\n| security | Prevent security vulnerabilities |\n| a11y | Accessibility in JSX |\n| nursery | Experimental rules |\n\n## Severity Levels\n\n- `error`: Fails CI, must fix\n- `warn`: Warning, should fix\n- `off`: Disabled\n\n## Configuration\n\n```json\n{\n  \"$schema\": \"https://biomejs.dev/schemas/2.3.10/schema.json\",\n  \"linter\": {\n    \"enabled\": true,\n    \"rules\": {\n      \"recommended\": true,\n      \"correctness\": {\n        \"noUnusedVariables\": \"error\"\n      }\n    }\n  }\n}\n```\n"}, {"path": "linters/biome/noUnusedVariables.md", "category": "linters", "name": "linters/biome/noUnusedVariables", "content": "# noUnusedVariables\n\nDisallow unused variables.\n\n## Why\n\nUnused variables are dead code and should be removed.\n\n## Invalid\n\n```typescript\nconst unused = 5;\n\nfunction fn(unusedParam: string) {\n  return \"hello\";\n}\n```\n\n## Valid\n\n```typescript\nconst used = 5;\nconsole.info(used);\n\nfunction fn(_ignoredParam: string) {\n  return \"hello\";\n}\n```\n\n## Note\n\nPrefix with underscore `_` to indicate intentionally unused.\n"}, {"path": "linters/biome/no-debugger.md", "category": "linters", "name": "linters/biome/no-debugger", "content": "# no-debugger\n\nSee: https://biomejs.dev/linter/rules/no-debugger\n"}, {"path": "linters/biome/schema.md", "category": "linters", "name": "linters/biome/schema", "content": "# Biome Schema Reference\n\nLatest schema:\n\nhttps://biomejs.dev/schemas/2.3.10/schema.json\n"}, {"path": "linters/biome/suspicious.md", "category": "linters", "name": "linters/biome/suspicious", "content": "# Biome Suspicious Rules\n\nRules that detect patterns that are likely bugs.\n\n## noApproximativeNumericConstant\n\nUse Math constants instead of approximations.\n\n```typescript\n// BAD\nconst pi = 3.14159;\nconst e = 2.718;\n\n// GOOD\nconst pi = Math.PI;\nconst e = Math.E;\n```\n\n## noArrayIndexKey\n\nCovered in correctness.\n\n## noAssignInExpressions\n\nPrevent accidental assignment in expressions.\n\n```typescript\n// BAD\nif (x = 1) {}  // probably meant ===\n\n// GOOD\nif (x === 1) {}\n\n// If intentional, be explicit\nif ((x = getValue())) {}\n```\n\n## noAsyncPromiseExecutor\n\nPromise executor shouldn't be async.\n\n```typescript\n// BAD\nnew Promise(async (resolve) => {\n  await something();\n  resolve();\n});\n\n// GOOD\nnew Promise((resolve) => {\n  something().then(resolve);\n});\n```\n\n## noCatchAssign\n\nDon't reassign catch parameter.\n\n```typescript\n// BAD\ntry {\n  // ...\n} catch (e) {\n  e = new Error(\"replaced\");  // don't do this\n}\n\n// GOOD\ntry {\n  // ...\n} catch (e) {\n  const wrapped = new Error(\"context\", { cause: e });\n  throw wrapped;\n}\n```\n\n## noClassAssign\n\nDon't reassign class declarations.\n\n```typescript\n// BAD\nclass Foo {}\nFoo = 1;\n\n// GOOD - use a variable if needed\nlet FooClass = class {};\nFooClass = class {};\n```\n\n## noCommentText\n\nPrevent comment-like text in JSX.\n\n```tsx\n// BAD\n<div>/* comment */</div>\n<div>// comment</div>\n\n// GOOD\n<div>{/* comment */}</div>\n```\n\n## noCompareNegZero\n\nComparing to -0 is almost always wrong.\n\n```typescript\n// BAD\nif (x === -0) {}\n\n// GOOD\nif (Object.is(x, -0)) {}\n```\n\n## noConfusingLabels\n\nLabels shouldn't conflict with scope.\n\n```typescript\n// BAD\nfunction foo() {\n  foo: {}  // same name as function\n}\n```\n\n## noConfusingVoidType\n\nvoid is only for return types.\n\n```typescript\n// BAD\nconst fn: () => void | number = () => {};\n\n// GOOD\nconst fn: () => void = () => {};\nconst fn: () => undefined | number = () => undefined;\n```\n\n## noConsole\n\nDon't leave console statements.\n\n```typescript\n// BAD\nconsole.log(\"debug\");\n\n// GOOD\nconsole.error(\"Error occurred\");  // OK\nconsole.warn(\"Warning\");          // OK\n\n// Or use a logger\nlogger.debug(\"debug\");\n```\n\nConfiguration:\n```json\n{\n  \"suspicious\": {\n    \"noConsole\": {\n      \"level\": \"warn\",\n      \"options\": {\n        \"allow\": [\"warn\", \"error\", \"info\", \"debug\"]\n      }\n    }\n  }\n}\n```\n\n## noConstEnum\n\nAvoid const enum (can't be used with isolatedModules).\n\n```typescript\n// BAD\nconst enum Color { Red, Green, Blue }\n\n// GOOD\nenum Color { Red, Green, Blue }\n// Or use string literals\ntype Color = \"red\" | \"green\" | \"blue\";\n```\n\n## noControlCharactersInRegex\n\nPrevent control characters in regex.\n\n```typescript\n// BAD\nconst re = /\\x00/;\n\n// GOOD\nconst re = /\\0/;  // null character if needed\n```\n\n## noDebugger\n\nRemove debugger statements.\n\n```typescript\n// BAD\ndebugger;\n\n// Remove it\n```\n\n## noDoubleEquals\n\nUse strict equality.\n\n```typescript\n// BAD\nif (x == y) {}\nif (x != y) {}\n\n// GOOD\nif (x === y) {}\nif (x !== y) {}\n```\n\n## noDuplicateCase\n\nPrevent duplicate switch cases.\n\n## noDuplicateClassMembers\n\nPrevent duplicate class members.\n\n```typescript\n// BAD\nclass Foo {\n  bar() {}\n  bar() {}  // duplicate!\n}\n```\n\n## noDuplicateJsxProps\n\nPrevent duplicate JSX props.\n\n```tsx\n// BAD\n<div id=\"a\" id=\"b\" />\n\n// GOOD\n<div id=\"a\" />\n```\n\n## noDuplicateObjectKeys\n\nPrevent duplicate object keys.\n\n```typescript\n// BAD\nconst obj = { a: 1, a: 2 };\n\n// GOOD\nconst obj = { a: 1, b: 2 };\n```\n\n## noDuplicateParameters\n\nPrevent duplicate function parameters.\n\n```typescript\n// BAD\nfunction foo(a, a) {}\n\n// GOOD\nfunction foo(a, b) {}\n```\n\n## noEmptyBlockStatements\n\nPrevent empty blocks.\n\n```typescript\n// BAD\nif (x) {\n}\n\n// GOOD\nif (x) {\n  // intentionally empty\n}\n```\n\n## noEmptyInterface\n\nPrevent empty interfaces.\n\n```typescript\n// BAD\ninterface Empty {}\n\n// GOOD\ninterface WithMember {\n  member: string;\n}\n\n// Or use type\ntype Empty = Record<string, never>;\n```\n\n## noExplicitAny\n\nDon't use any type.\n\n```typescript\n// BAD\nconst data: any = response;\nfunction fn(x: any): any {}\n\n// GOOD\nconst data: unknown = response;\nfunction fn(x: unknown): string {}\n\n// Or be specific\ninterface Data {\n  items: Item[];\n}\nconst data: Data = response;\n```\n\n## noExportsInTest\n\nDon't export from test files.\n\n```typescript\n// BAD (in .test.ts)\nexport function helper() {}\n\n// GOOD - keep test helpers in test file or separate non-test module\n```\n\n## noExtraNonNullAssertion\n\nRemove redundant non-null assertions.\n\n```typescript\n// BAD\nx!!!;\nx!?.y;\n\n// GOOD\nx!;\nx?.y;\n```\n\n## noFallthroughSwitchClause\n\nPrevent unintentional fallthrough.\n\n```typescript\n// BAD\nswitch (x) {\n  case 1:\n    doSomething();\n  case 2:  // falls through!\n    doMore();\n}\n\n// GOOD\nswitch (x) {\n  case 1:\n    doSomething();\n    break;\n  case 2:\n    doMore();\n}\n\n// Or explicit fallthrough comment\nswitch (x) {\n  case 1:\n    doSomething();\n    // fallthrough\n  case 2:\n    doMore();\n}\n```\n\n## noFunctionAssign\n\nDon't reassign function declarations.\n\n```typescript\n// BAD\nfunction foo() {}\nfoo = 1;\n```\n\n## noGlobalAssign\n\nDon't reassign globals.\n\n```typescript\n// BAD\nundefined = 1;\nObject = null;\n```\n\n## noGlobalIsFinite\n\nUse Number.isFinite instead.\n\n```typescript\n// BAD\nisFinite(\"1\");  // coerces to number\n\n// GOOD\nNumber.isFinite(1);\n```\n\n## noGlobalIsNan\n\nUse Number.isNaN instead.\n\n```typescript\n// BAD\nisNaN(\"x\");  // coerces\n\n// GOOD\nNumber.isNaN(x);\n```\n\n## noImplicitAnyLet\n\nRequire type on let without initializer.\n\n```typescript\n// BAD\nlet x;  // implicitly any\n\n// GOOD\nlet x: string;\nlet x = \"\";\n```\n\n## noImportAssign\n\nDon't reassign imports.\n\n```typescript\n// BAD\nimport { foo } from \"mod\";\nfoo = 1;\n```\n\n## noLabelVar\n\nLabels shouldn't match variable names.\n\n```typescript\n// BAD\nconst x = 1;\nx: {}\n```\n\n## noMisleadingCharacterClass\n\nPrevent confusing regex character classes.\n\n## noMisleadingInstantiation\n\nUse `new` properly.\n\n```typescript\n// BAD\nnew Symbol();\n\n// GOOD\nSymbol(\"desc\");\n```\n\n## noMisrefactoredShorthandAssign\n\nPrevent confusing compound assignment.\n\n```typescript\n// BAD\nx = x ?? 1;  // probably meant ??=\n\n// GOOD\nx ??= 1;\n```\n\n## noPrototypeBuiltins\n\nDon't call Object prototype methods directly.\n\n```typescript\n// BAD\nobj.hasOwnProperty(\"foo\");\n\n// GOOD\nObject.hasOwn(obj, \"foo\");\nObject.prototype.hasOwnProperty.call(obj, \"foo\");\n```\n\n## noRedeclare\n\nPrevent redeclaring variables.\n\n```typescript\n// BAD\nvar x = 1;\nvar x = 2;\n\n// GOOD\nlet x = 1;\nx = 2;\n```\n\n## noRedundantUseStrict\n\nRemove redundant \"use strict\".\n\n```typescript\n// BAD (in ESM or already-strict context)\n\"use strict\";\n\n// Just remove it - ESM is always strict\n```\n\n## noSelfCompare\n\nPrevent comparing value to itself.\n\n```typescript\n// BAD\nif (x === x) {}  // always true (except NaN)\n\n// If checking for NaN, use:\nif (Number.isNaN(x)) {}\n```\n\n## noShadowRestrictedNames\n\nDon't shadow restricted names.\n\n```typescript\n// BAD\nconst undefined = 1;\nconst NaN = 2;\nfunction eval() {}\n```\n\n## noSparseArray\n\nPrevent sparse arrays.\n\n```typescript\n// BAD\nconst arr = [1, , 3];  // sparse\n\n// GOOD\nconst arr = [1, undefined, 3];\n```\n\n## noThenProperty\n\nAvoid 'then' property (confuses async).\n\n```typescript\n// BAD\nconst obj = {\n  then: () => {}\n};\nawait obj;  // calls obj.then!\n\n// GOOD\nconst obj = {\n  resolve: () => {}\n};\n```\n\n## noUnsafeDeclarationMerging\n\nPrevent declaration merging issues.\n\n```typescript\n// BAD\ninterface Foo {\n  x: string;\n}\nclass Foo {  // merges with interface\n  y: number;\n}\n```\n\n## noUnsafeNegation\n\nPrevent confusing negation.\n\n```typescript\n// BAD\nif (!x in obj) {}  // negates x, not result\n\n// GOOD\nif (!(x in obj)) {}\n```\n\n## useAwait\n\nAsync functions must use await.\n\n```typescript\n// BAD\nasync function foo() {\n  return 1;  // no await\n}\n\n// GOOD\nasync function foo() {\n  return await getValue();\n}\n\n// Or don't make it async\nfunction foo() {\n  return 1;\n}\n```\n\n## useDefaultSwitchClauseLast\n\ndefault case should be last.\n\n```typescript\n// BAD\nswitch (x) {\n  default:\n    break;\n  case 1:\n    break;\n}\n\n// GOOD\nswitch (x) {\n  case 1:\n    break;\n  default:\n    break;\n}\n```\n\n## useGetterReturn\n\nGetters must return a value.\n\n```typescript\n// BAD\nconst obj = {\n  get foo() {\n    // no return!\n  }\n};\n\n// GOOD\nconst obj = {\n  get foo() {\n    return this._foo;\n  }\n};\n```\n\n## useIsArray\n\nUse Array.isArray not instanceof.\n\n```typescript\n// BAD\nif (x instanceof Array) {}\n\n// GOOD\nif (Array.isArray(x)) {}\n```\n\n## useNamespaceKeyword\n\nUse namespace not module.\n\n```typescript\n// BAD\nmodule Foo {}\n\n// GOOD\nnamespace Foo {}\n```\n\n## useValidTypeof\n\nValidate typeof comparisons.\n\n```typescript\n// BAD\ntypeof x === \"nunber\";  // typo\ntypeof x === \"null\";    // typeof returns \"object\" for null\n\n// GOOD\ntypeof x === \"number\";\nx === null;\n```\n"}, {"path": "linters/biome/performance.md", "category": "linters", "name": "linters/biome/performance", "content": "# Biome Performance Rules\n\nRules that help optimize runtime performance.\n\n## noAccumulatingSpread\n\nAvoid spread in accumulators (O(n\u00b2)).\n\n```typescript\n// BAD - O(n\u00b2) complexity\nconst result = items.reduce((acc, item) => ({\n  ...acc,\n  [item.id]: item\n}), {});\n\n// GOOD - O(n) complexity\nconst result: Record<string, Item> = {};\nfor (const item of items) {\n  result[item.id] = item;\n}\n\n// Or use Object.fromEntries\nconst result = Object.fromEntries(\n  items.map(item => [item.id, item])\n);\n```\n\n**Why:** Each spread copies the entire accumulator.\n\n## noBarrelFile\n\nAvoid barrel files (index.ts that re-exports).\n\n```typescript\n// BAD - barrel file (index.ts)\nexport { Foo } from \"./foo\";\nexport { Bar } from \"./bar\";\nexport { Baz } from \"./baz\";\n\n// GOOD - import directly\nimport { Foo } from \"./components/foo\";\nimport { Bar } from \"./components/bar\";\n```\n\n**Why:** Barrel files prevent tree-shaking and slow down builds.\n\n## noDelete\n\nAvoid delete operator.\n\n```typescript\n// BAD - deoptimizes object\ndelete obj.property;\n\n// GOOD - set to undefined\nobj.property = undefined;\n\n// Or use destructuring to omit\nconst { property, ...rest } = obj;\n```\n\n**Why:** delete changes object shape, causing V8 to deoptimize.\n\n## noReExportAll\n\nAvoid export * (re-export all).\n\n```typescript\n// BAD\nexport * from \"./module\";\n\n// GOOD\nexport { foo, bar } from \"./module\";\n```\n\n**Why:** Prevents tree-shaking, imports everything.\n"}, {"path": "linters/biome/a11y.md", "category": "linters", "name": "linters/biome/a11y", "content": "# Biome Accessibility Rules (a11y)\n\nRules for accessible JSX/React components.\n\n## noAccessKey\n\nDon't use accessKey prop.\n\n```tsx\n// BAD - inconsistent across browsers\n<button accessKey=\"s\">Save</button>\n\n// GOOD - rely on standard navigation\n<button>Save</button>\n```\n\n## noAriaHiddenOnFocusable\n\nDon't hide focusable elements from screen readers.\n\n```tsx\n// BAD\n<button aria-hidden=\"true\">Click</button>\n\n// GOOD\n<button>Click</button>\n<div aria-hidden=\"true\">Decorative</div>\n```\n\n## noAriaUnsupportedOnRole\n\nDon't use unsupported ARIA attributes.\n\n```tsx\n// BAD\n<img role=\"presentation\" alt=\"description\" />\n\n// GOOD\n<img role=\"presentation\" alt=\"\" />\n```\n\n## noAutofocus\n\nAvoid autofocus (disrupts screen readers).\n\n```tsx\n// BAD\n<input autoFocus />\n\n// GOOD\n<input />\n// Focus programmatically when appropriate\n```\n\n## noBlankTarget\n\nUse rel=\"noreferrer\" with target=\"_blank\".\n\n```tsx\n// BAD - security risk (tabnabbing)\n<a href={url} target=\"_blank\">Link</a>\n\n// GOOD\n<a href={url} target=\"_blank\" rel=\"noreferrer\">Link</a>\n```\n\n## noDistractingElements\n\nDon't use blink/marquee.\n\n```tsx\n// BAD\n<blink>Blinking text</blink>\n<marquee>Scrolling text</marquee>\n\n// GOOD - use CSS animations if needed\n<span className=\"highlight\">Important text</span>\n```\n\n## noHeaderScope\n\nScope attribute only on th elements.\n\n```tsx\n// BAD\n<td scope=\"row\">Data</td>\n\n// GOOD\n<th scope=\"row\">Header</th>\n<td>Data</td>\n```\n\n## noInteractiveElementToNoninteractiveRole\n\nDon't make interactive elements non-interactive.\n\n```tsx\n// BAD\n<button role=\"presentation\">Click</button>\n\n// GOOD\n<button>Click</button>\n<div role=\"presentation\">Decorative</div>\n```\n\n## noNoninteractiveElementToInteractiveRole\n\nDon't make non-interactive elements interactive via role.\n\n```tsx\n// BAD\n<div role=\"button\">Click me</div>\n\n// GOOD\n<button>Click me</button>\n// Or use proper accessibility\n<div \n  role=\"button\"\n  tabIndex={0}\n  onKeyDown={handleKeyDown}\n  onClick={handleClick}\n>\n  Click me\n</div>\n```\n\n## noNoninteractiveTabindex\n\nDon't add tabindex to non-interactive elements.\n\n```tsx\n// BAD\n<div tabIndex={0}>Text</div>\n\n// GOOD\n<button>Interactive</button>\n<div>Non-interactive</div>\n```\n\n## noPositiveTabindex\n\nDon't use positive tabindex values.\n\n```tsx\n// BAD - breaks natural tab order\n<button tabIndex={2}>Second</button>\n<button tabIndex={1}>First</button>\n\n// GOOD - use DOM order\n<button>First</button>\n<button>Second</button>\n```\n\n## noRedundantAlt\n\nDon't say \"image\" in alt text.\n\n```tsx\n// BAD\n<img alt=\"Image of a cat\" />\n<img alt=\"Photo: sunset\" />\n<img alt=\"Picture of dog\" />\n\n// GOOD\n<img alt=\"A cat sleeping\" />\n<img alt=\"Sunset over ocean\" />\n<img alt=\"Golden retriever playing\" />\n```\n\n## noRedundantRoles\n\nDon't specify implicit roles.\n\n```tsx\n// BAD - nav already has navigation role\n<nav role=\"navigation\">...</nav>\n<button role=\"button\">Click</button>\n<a href=\"#\" role=\"link\">Link</a>\n\n// GOOD\n<nav>...</nav>\n<button>Click</button>\n<a href=\"#\">Link</a>\n```\n\n## noSvgWithoutTitle\n\nSVGs need accessible names.\n\n```tsx\n// BAD\n<svg>\n  <circle />\n</svg>\n\n// GOOD\n<svg aria-label=\"Circle icon\">\n  <circle />\n</svg>\n\n// Or with title\n<svg>\n  <title>Circle icon</title>\n  <circle />\n</svg>\n\n// Decorative SVG\n<svg aria-hidden=\"true\">\n  <circle />\n</svg>\n```\n\n## useAltText\n\nImages need alt attribute.\n\n```tsx\n// BAD\n<img src=\"cat.jpg\" />\n\n// GOOD\n<img src=\"cat.jpg\" alt=\"A fluffy orange cat\" />\n\n// Decorative image\n<img src=\"decoration.jpg\" alt=\"\" />\n```\n\n## useAnchorContent\n\nLinks need accessible content.\n\n```tsx\n// BAD\n<a href=\"/about\"></a>\n<a href=\"/about\"><img src=\"icon.png\" /></a>\n\n// GOOD\n<a href=\"/about\">About Us</a>\n<a href=\"/about\">\n  <img src=\"icon.png\" alt=\"About Us\" />\n</a>\n<a href=\"/about\" aria-label=\"About Us\">\n  <img src=\"icon.png\" alt=\"\" />\n</a>\n```\n\n## useAriaActivedescendantWithTabindex\n\nActive descendant needs tabindex.\n\n```tsx\n// BAD\n<div aria-activedescendant=\"item1\">...</div>\n\n// GOOD\n<div aria-activedescendant=\"item1\" tabIndex={0}>...</div>\n```\n\n## useAriaPropsForRole\n\nRoles need required ARIA attributes.\n\n```tsx\n// BAD - checkbox needs aria-checked\n<div role=\"checkbox\">Option</div>\n\n// GOOD\n<div role=\"checkbox\" aria-checked={checked}>Option</div>\n// Or use native\n<input type=\"checkbox\" />\n```\n\n## useButtonType\n\nButtons need explicit type.\n\n```tsx\n// BAD - defaults to submit in forms\n<button>Click</button>\n\n// GOOD\n<button type=\"button\">Click</button>\n<button type=\"submit\">Submit</button>\n<button type=\"reset\">Reset</button>\n```\n\n## useFocusableInteractive\n\nInteractive elements must be focusable.\n\n```tsx\n// BAD\n<div onClick={handleClick}>Clickable</div>\n\n// GOOD\n<button onClick={handleClick}>Clickable</button>\n<div \n  role=\"button\" \n  tabIndex={0} \n  onClick={handleClick}\n  onKeyDown={handleKeyDown}\n>\n  Clickable\n</div>\n```\n\n## useHeadingContent\n\nHeadings need content.\n\n```tsx\n// BAD\n<h1></h1>\n<h2><img src=\"logo.png\" /></h2>\n\n// GOOD\n<h1>Page Title</h1>\n<h2><img src=\"logo.png\" alt=\"Company Name\" /></h2>\n```\n\n## useHtmlLang\n\nHTML element needs lang attribute.\n\n```tsx\n// BAD\n<html>...</html>\n\n// GOOD\n<html lang=\"en\">...</html>\n```\n\n## useIframeTitle\n\nIframes need title.\n\n```tsx\n// BAD\n<iframe src=\"...\" />\n\n// GOOD\n<iframe src=\"...\" title=\"Video player\" />\n```\n\n## useKeyWithClickEvents\n\nClick handlers need keyboard handlers.\n\n```tsx\n// BAD\n<div onClick={handleClick}>Clickable</div>\n\n// GOOD\n<button onClick={handleClick}>Clickable</button>\n// Or\n<div \n  onClick={handleClick}\n  onKeyDown={(e) => e.key === 'Enter' && handleClick(e)}\n  tabIndex={0}\n  role=\"button\"\n>\n  Clickable\n</div>\n```\n\n## useKeyWithMouseEvents\n\nMouse events need keyboard alternatives.\n\n```tsx\n// BAD\n<div onMouseOver={show} onMouseOut={hide}>Hover me</div>\n\n// GOOD\n<div \n  onMouseOver={show}\n  onMouseOut={hide}\n  onFocus={show}\n  onBlur={hide}\n  tabIndex={0}\n>\n  Hover or focus me\n</div>\n```\n\n## useMediaCaption\n\nMedia needs captions.\n\n```tsx\n// BAD\n<video src=\"video.mp4\" />\n<audio src=\"audio.mp3\" />\n\n// GOOD\n<video src=\"video.mp4\">\n  <track kind=\"captions\" src=\"captions.vtt\" />\n</video>\n```\n\n## useValidAnchor\n\nAnchors need valid href.\n\n```tsx\n// BAD\n<a href=\"#\">Click</a>\n<a href=\"javascript:void(0)\">Click</a>\n\n// GOOD\n<a href=\"/page\">Navigate</a>\n<button onClick={handleClick}>Click</button>\n```\n\n## useValidAriaProps\n\nUse valid ARIA attributes.\n\n```tsx\n// BAD\n<div aria-fake=\"value\">...</div>\n\n// GOOD\n<div aria-label=\"Description\">...</div>\n```\n\n## useValidAriaRole\n\nUse valid ARIA roles.\n\n```tsx\n// BAD\n<div role=\"fake\">...</div>\n\n// GOOD\n<div role=\"button\">...</div>\n<div role=\"navigation\">...</div>\n```\n\n## useValidAriaValues\n\nUse valid ARIA values.\n\n```tsx\n// BAD\n<div aria-hidden=\"yes\">...</div>\n\n// GOOD\n<div aria-hidden=\"true\">...</div>\n```\n\n## useValidLang\n\nUse valid language codes.\n\n```tsx\n// BAD\n<html lang=\"english\">...</html>\n\n// GOOD\n<html lang=\"en\">...</html>\n<html lang=\"en-US\">...</html>\n```\n"}, {"path": "linters/biome/nursery.md", "category": "linters", "name": "linters/biome/nursery", "content": "# Biome Nursery Lints\n\nExperimental rules that may be promoted to stable categories.\n\n## noApproximativeNumericConstant\n\nAvoid approximating built-in math constants.\n\n```typescript\n// BAD\nconst pi = 3.14159;\nconst e = 2.71828;\n\n// GOOD\nconst pi = Math.PI;\nconst e = Math.E;\n```\n\n## noCommonJs\n\nDisallow CommonJS require/exports.\n\n```typescript\n// BAD\nconst fs = require(\"fs\");\nmodule.exports = { foo };\n\n// GOOD\nimport fs from \"node:fs\";\nexport { foo };\n```\n\n## noConstantMathMinMaxClamp\n\nAvoid Math.min/max with constant that clamps nothing.\n\n```typescript\n// BAD\nMath.max(0, -5);  // always 0\nMath.min(100, 200);  // always 100\n\n// GOOD - dynamic values\nMath.max(0, userInput);\nMath.min(100, value);\n```\n\n## noDuplicateElseIf\n\nNo duplicate conditions in else-if.\n\n```typescript\n// BAD\nif (a) {\n} else if (b) {\n} else if (a) {  // duplicate!\n}\n\n// GOOD\nif (a) {\n} else if (b) {\n} else if (c) {\n}\n```\n\n## noDuplicateJsonKeys\n\nNo duplicate keys in JSON.\n\n```json\n// BAD\n{\n  \"name\": \"foo\",\n  \"name\": \"bar\"\n}\n\n// GOOD\n{\n  \"name\": \"foo\"\n}\n```\n\n## noEmptyBlockStatements\n\nNo empty block statements.\n\n```typescript\n// BAD\nif (condition) {\n}\n\ntry {\n} catch (e) {\n}\n\n// GOOD\nif (condition) {\n  doSomething();\n}\n\ntry {\n  riskyOp();\n} catch (e) {\n  handleError(e);\n}\n```\n\n## noEvolvingTypes\n\nDisallow variables that evolve type through reassignment.\n\n```typescript\n// BAD\nlet x = 1;      // number\nx = \"hello\";    // now string!\n\n// GOOD\nlet x: number | string = 1;\nx = \"hello\";\n```\n\n## noExcessiveNestedTestSuites\n\nLimit test suite nesting depth.\n\n```typescript\n// BAD\ndescribe(\"a\", () => {\n  describe(\"b\", () => {\n    describe(\"c\", () => {\n      describe(\"d\", () => {\n        describe(\"e\", () => {  // too deep\n          it(\"test\", () => {});\n        });\n      });\n    });\n  });\n});\n\n// GOOD - flatten\ndescribe(\"a > b > c\", () => {\n  it(\"test case\", () => {});\n});\n```\n\n## noFlatMapIdentity\n\nNo flatMap with identity function.\n\n```typescript\n// BAD\narr.flatMap(x => x);\n\n// GOOD\narr.flat();\n```\n\n## noGlobalAssign\n\nNo assigning to global objects.\n\n```typescript\n// BAD\nObject = null;\nArray = class {};\nwindow = {};\n\n// GOOD - don't modify globals\n```\n\n## noGlobalEval\n\nAvoid global eval.\n\n```typescript\n// BAD\neval(\"code\");\nnew Function(\"return 1\");\n\n// GOOD - avoid dynamic code execution\n```\n\n## noInvalidBuiltinInstantiation\n\nCorrect instantiation of builtins.\n\n```typescript\n// BAD\nnew Symbol(\"desc\");   // Symbol is not a constructor\nnew BigInt(1);        // BigInt is not a constructor\nSymbol.for(\"key\")();  // Symbol.for returns a symbol, not function\n\n// GOOD\nSymbol(\"desc\");\nBigInt(1);\nSymbol.for(\"key\");\n```\n\n## noInvalidNewBuiltin\n\nDon't use new with non-constructors.\n\n```typescript\n// BAD\nnew Symbol();\nnew BigInt();\n\n// GOOD\nSymbol();\nBigInt(1);\n```\n\n## noMissingGenericFamilyKeyword\n\nCSS font-family needs generic fallback.\n\n```css\n/* BAD */\n.foo {\n  font-family: \"Helvetica\";\n}\n\n/* GOOD */\n.foo {\n  font-family: \"Helvetica\", sans-serif;\n}\n```\n\n## noMissingVarFunction\n\nCSS custom properties need var().\n\n```css\n/* BAD */\n.foo {\n  color: --my-color;\n}\n\n/* GOOD */\n.foo {\n  color: var(--my-color);\n}\n```\n\n## noNodejsModules\n\nDisallow Node.js builtin modules.\n\n```typescript\n// BAD (in browser code)\nimport fs from \"fs\";\nimport path from \"path\";\n\n// GOOD - use browser-compatible alternatives\n```\n\n## noOctalEscape\n\nNo octal escape sequences in strings.\n\n```typescript\n// BAD\nconst str = \"\\251\";  // octal escape\n\n// GOOD\nconst str = \"\\u00A9\";  // unicode escape\nconst str = \"\u00a9\";       // literal\n```\n\n## noProcessEnv\n\nAvoid direct process.env access.\n\n```typescript\n// BAD\nconst key = process.env.API_KEY;\n\n// GOOD - centralize config\nimport { config } from \"./config\";\nconst key = config.apiKey;\n```\n\n## noRestrictedImports\n\nDisallow specific imports.\n\n```typescript\n// Configure in biome.json\n{\n  \"linter\": {\n    \"rules\": {\n      \"nursery\": {\n        \"noRestrictedImports\": {\n          \"level\": \"error\",\n          \"options\": {\n            \"paths\": {\n              \"lodash\": \"Use native methods instead\"\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n## noSecrets\n\nDetect hardcoded secrets.\n\n```typescript\n// BAD\nconst API_KEY = \"sk-1234567890abcdef\";\nconst password = \"hunter2\";\n\n// GOOD\nconst API_KEY = process.env.API_KEY;\n```\n\n## noSkippedTests\n\nNo skipped tests.\n\n```typescript\n// BAD\nit.skip(\"should work\", () => {});\nxit(\"should work\", () => {});\ntest.skip(\"should work\", () => {});\n\n// GOOD\nit(\"should work\", () => {});\n```\n\n## noStaticElementInteractions\n\nStatic elements shouldn't have handlers.\n\n```tsx\n// BAD\n<div onClick={handleClick}>Click me</div>\n\n// GOOD\n<button onClick={handleClick}>Click me</button>\n<div role=\"button\" tabIndex={0} onClick={handleClick}>Click me</div>\n```\n\n## noSubstr\n\nUse slice instead of substr.\n\n```typescript\n// BAD (deprecated)\nstr.substr(1, 3);\n\n// GOOD\nstr.slice(1, 4);\nstr.substring(1, 4);\n```\n\n## noThenProperty\n\nAvoid objects with 'then' property.\n\n```typescript\n// BAD - looks like a thenable\nconst obj = {\n  then: () => console.log(\"not a promise\"),\n};\nawait obj;  // calls obj.then()!\n\n// GOOD\nconst obj = {\n  handle: () => console.log(\"clear name\"),\n};\n```\n\n## noTypeOnlyImportAttributes\n\nNo import attributes on type-only imports.\n\n```typescript\n// BAD\nimport type { Foo } from \"./foo.json\" with { type: \"json\" };\n\n// GOOD\nimport type { Foo } from \"./types\";\nimport data from \"./foo.json\" with { type: \"json\" };\n```\n\n## noUndeclaredDependencies\n\nImport only declared dependencies.\n\n```typescript\n// BAD (if lodash not in package.json)\nimport _ from \"lodash\";\n\n// GOOD - add to package.json first\nnpm install lodash\n```\n\n## noUnknownFunction\n\nCSS: no unknown functions.\n\n```css\n/* BAD */\n.foo {\n  color: unknownfn(red);\n}\n\n/* GOOD */\n.foo {\n  color: rgb(255, 0, 0);\n}\n```\n\n## noUnknownMediaFeatureName\n\nCSS: valid media feature names.\n\n```css\n/* BAD */\n@media (unknown-feature: value) {}\n\n/* GOOD */\n@media (min-width: 768px) {}\n```\n\n## noUnknownProperty\n\nCSS: valid property names.\n\n```css\n/* BAD */\n.foo {\n  colour: red;\n}\n\n/* GOOD */\n.foo {\n  color: red;\n}\n```\n\n## noUnknownPseudoClassSelector\n\nCSS: valid pseudo-class selectors.\n\n```css\n/* BAD */\n.foo:hoverr {}\n\n/* GOOD */\n.foo:hover {}\n```\n\n## noUnknownSelectorPseudoElement\n\nCSS: valid pseudo-element selectors.\n\n```css\n/* BAD */\n.foo::beforee {}\n\n/* GOOD */\n.foo::before {}\n```\n\n## noUnknownUnit\n\nCSS: valid units.\n\n```css\n/* BAD */\n.foo {\n  width: 100pixels;\n}\n\n/* GOOD */\n.foo {\n  width: 100px;\n}\n```\n\n## noUnmatchableAnbSelector\n\nCSS: matchable An+B selectors.\n\n```css\n/* BAD */\n:nth-child(0n+0) {}  /* matches nothing */\n\n/* GOOD */\n:nth-child(2n+1) {}\n```\n\n## noUnusedFunctionParameters\n\nFlag unused function parameters.\n\n```typescript\n// BAD\nfunction foo(a, b, c) {  // c unused\n  return a + b;\n}\n\n// GOOD\nfunction foo(a, b, _c) {  // underscore indicates intentional\n  return a + b;\n}\n\nfunction foo(a, b) {\n  return a + b;\n}\n```\n\n## noUselessEscapeInRegex\n\nNo unnecessary regex escapes.\n\n```typescript\n// BAD\n/\\a/;  // 'a' doesn't need escaping\n/\\-/;  // '-' outside char class\n\n// GOOD\n/a/;\n/-/;\n/\\d/;  // 'd' needs escaping for digit\n```\n\n## noUselessStringConcat\n\nAvoid useless concatenation.\n\n```typescript\n// BAD\nconst s = \"hello\" + \"world\";\nconst s = `hello` + `world`;\n\n// GOOD\nconst s = \"helloworld\";\nconst s = `helloworld`;\n```\n\n## noUselessUndefinedInitialization\n\nDon't initialize to undefined.\n\n```typescript\n// BAD\nlet x = undefined;\nlet y: string | undefined = undefined;\n\n// GOOD\nlet x;\nlet y: string | undefined;\n```\n\n## noValueAtRule\n\nCSS: no @value (CSS Modules specific).\n\n```css\n/* BAD (use CSS variables instead) */\n@value primary: blue;\n\n/* GOOD */\n:root {\n  --primary: blue;\n}\n```\n\n## noYodaExpression\n\nNo Yoda conditions.\n\n```typescript\n// BAD\nif (5 === x) {}\nif (\"red\" === color) {}\n\n// GOOD\nif (x === 5) {}\nif (color === \"red\") {}\n```\n\n## useAdjacentOverloadSignatures\n\nGroup overload signatures together.\n\n```typescript\n// BAD\ninterface Foo {\n  foo(a: string): void;\n  bar(): void;\n  foo(a: number): void;  // separated from other foo\n}\n\n// GOOD\ninterface Foo {\n  foo(a: string): void;\n  foo(a: number): void;\n  bar(): void;\n}\n```\n\n## useAriaPropsSupportedByRole\n\nARIA props must match role.\n\n```tsx\n// BAD\n<div role=\"checkbox\" aria-invalid=\"true\" />\n\n// GOOD\n<div role=\"checkbox\" aria-checked=\"true\" />\n```\n\n## useArrayLiterals\n\nPrefer array literals.\n\n```typescript\n// BAD\nconst arr = new Array();\nconst arr = Array(1, 2, 3);\n\n// GOOD\nconst arr = [];\nconst arr = [1, 2, 3];\n```\n\n## useAtIndex\n\nUse at() for negative indexing.\n\n```typescript\n// BAD\narr[arr.length - 1];\nstr.charAt(str.length - 2);\n\n// GOOD\narr.at(-1);\nstr.at(-2);\n```\n\n## useCollapsedIf\n\nCollapse nested if statements.\n\n```typescript\n// BAD\nif (a) {\n  if (b) {\n    doSomething();\n  }\n}\n\n// GOOD\nif (a && b) {\n  doSomething();\n}\n```\n\n## useConsistentBuiltinInstantiation\n\nConsistent builtin construction.\n\n```typescript\n// BAD - inconsistent\nnew Object();\nBoolean(true);\nnew Array();\nString(\"hello\");\n\n// GOOD - pick one style consistently\n// Prefer literal syntax where possible\nconst obj = {};\nconst arr = [];\nconst str = \"hello\";\nconst bool = true;\n```\n\n## useConsistentCurlyBraces\n\nConsistent curly braces.\n\n```typescript\n// BAD - inconsistent\nif (a) doOne();\nif (b) {\n  doTwo();\n}\n\n// GOOD - consistent\nif (a) {\n  doOne();\n}\nif (b) {\n  doTwo();\n}\n```\n\n## useDateNow\n\nUse Date.now() for timestamps.\n\n```typescript\n// BAD\nnew Date().getTime();\nnew Date().valueOf();\n+new Date();\n\n// GOOD\nDate.now();\n```\n\n## useDefaultSwitchClause\n\nRequire default in switch.\n\n```typescript\n// BAD\nswitch (x) {\n  case 1: break;\n  case 2: break;\n}\n\n// GOOD\nswitch (x) {\n  case 1: break;\n  case 2: break;\n  default: break;\n}\n```\n\n## useDeprecatedReason\n\nRequire reason for @deprecated.\n\n```typescript\n// BAD\n/** @deprecated */\nfunction foo() {}\n\n// GOOD\n/** @deprecated Use bar() instead */\nfunction foo() {}\n```\n\n## useExplicitLengthCheck\n\nExplicit length comparisons.\n\n```typescript\n// BAD\nif (arr.length) {}\nif (!arr.length) {}\n\n// GOOD\nif (arr.length > 0) {}\nif (arr.length === 0) {}\n```\n\n## useFocusableInteractive\n\nInteractive elements must be focusable.\n\n```tsx\n// BAD\n<div onClick={handleClick}>Click</div>\n\n// GOOD\n<div onClick={handleClick} tabIndex={0}>Click</div>\n<button onClick={handleClick}>Click</button>\n```\n\n## useGenericFontNames\n\nCSS font stacks need generic family.\n\n```css\n/* BAD */\nbody {\n  font-family: \"Roboto\";\n}\n\n/* GOOD */\nbody {\n  font-family: \"Roboto\", sans-serif;\n}\n```\n\n## useImportExtensions\n\nRequire import extensions.\n\n```typescript\n// BAD\nimport { foo } from \"./foo\";\n\n// GOOD\nimport { foo } from \"./foo.js\";\nimport { foo } from \"./foo.ts\";\n```\n\n## useImportRestrictions\n\nControl import sources.\n\n```typescript\n// Configure allowed/disallowed import patterns\n// in biome.json\n```\n\n## useJsxCurlyBraceConvention\n\nConsistent JSX curly braces.\n\n```tsx\n// BAD - inconsistent\n<Component prop={\"value\"} />\n<Component prop=\"value\" />\n\n// GOOD - consistent\n<Component prop=\"value\" />\n```\n\n## useNumberToFixedDigitsArgument\n\ntoFixed needs argument.\n\n```typescript\n// BAD\nnum.toFixed();\n\n// GOOD\nnum.toFixed(2);\n```\n\n## useSemanticElements\n\nUse semantic HTML.\n\n```tsx\n// BAD\n<div role=\"navigation\">...</div>\n<div role=\"main\">...</div>\n<div role=\"article\">...</div>\n\n// GOOD\n<nav>...</nav>\n<main>...</main>\n<article>...</article>\n```\n\n## useSortedClasses\n\nSort Tailwind classes.\n\n```tsx\n// BAD\n<div className=\"p-4 flex bg-red-500 mt-2\" />\n\n// GOOD (sorted by Tailwind convention)\n<div className=\"flex mt-2 bg-red-500 p-4\" />\n```\n\n## useStrictMode\n\nRequire \"use strict\".\n\n```javascript\n// BAD (non-module)\nfunction foo() {}\n\n// GOOD\n\"use strict\";\nfunction foo() {}\n```\n\n## useTrimStartEnd\n\nUse trimStart/trimEnd.\n\n```typescript\n// BAD (deprecated)\nstr.trimLeft();\nstr.trimRight();\n\n// GOOD\nstr.trimStart();\nstr.trimEnd();\n```\n\n## useValidAutocomplete\n\nValid autocomplete values.\n\n```html\n<!-- BAD -->\n<input autocomplete=\"invalid\" />\n\n<!-- GOOD -->\n<input autocomplete=\"email\" />\n<input autocomplete=\"current-password\" />\n```\n"}, {"path": "linters/biome/style.md", "category": "linters", "name": "linters/biome/style", "content": "# Biome Style Rules\n\nRules that enforce consistent code style.\n\n## noArguments\n\nUse rest parameters instead of arguments.\n\n```typescript\n// BAD\nfunction foo() {\n  console.log(arguments);\n}\n\n// GOOD\nfunction foo(...args: unknown[]) {\n  console.log(args);\n}\n```\n\n## noCommaOperator\n\nPrevent comma operator.\n\n```typescript\n// BAD\nconst x = (1, 2, 3);  // x = 3, confusing\n\n// GOOD\nconst x = 3;\n```\n\n## noDefaultExport\n\nPrefer named exports.\n\n```typescript\n// BAD\nexport default function foo() {}\n\n// GOOD\nexport function foo() {}\n```\n\n## noImplicitBoolean\n\nRequire explicit boolean in JSX.\n\n```tsx\n// BAD\n<Input disabled />\n\n// GOOD\n<Input disabled={true} />\n```\n\n## noInferrableTypes\n\nRemove obvious type annotations.\n\n```typescript\n// BAD\nconst x: number = 1;\nconst s: string = \"hello\";\n\n// GOOD\nconst x = 1;\nconst s = \"hello\";\n\n// Keep when not inferrable\nconst x: number = getValue();\n```\n\n## noNamespace\n\nAvoid TypeScript namespaces.\n\n```typescript\n// BAD\nnamespace Foo {\n  export const x = 1;\n}\n\n// GOOD\nexport const x = 1;\n// Or use modules\n```\n\n## noNegationElse\n\nAvoid negated conditions with else.\n\n```typescript\n// BAD\nif (!condition) {\n  foo();\n} else {\n  bar();\n}\n\n// GOOD\nif (condition) {\n  bar();\n} else {\n  foo();\n}\n```\n\n## noNonNullAssertion\n\nAvoid non-null assertions.\n\n```typescript\n// BAD\nconst x = obj.maybeNull!;\nfunc()!;\n\n// GOOD\nif (obj.maybeNull) {\n  const x = obj.maybeNull;\n}\n\n// Or use optional chaining\nconst x = obj.maybeNull ?? defaultValue;\n```\n\n## noParameterAssign\n\nDon't reassign parameters.\n\n```typescript\n// BAD\nfunction foo(x: number) {\n  x = x + 1;  // modifies parameter\n  return x;\n}\n\n// GOOD\nfunction foo(x: number) {\n  const result = x + 1;\n  return result;\n}\n```\n\n## noParameterProperties\n\nAvoid parameter properties.\n\n```typescript\n// BAD\nclass Foo {\n  constructor(private x: number) {}\n}\n\n// GOOD\nclass Foo {\n  private x: number;\n  constructor(x: number) {\n    this.x = x;\n  }\n}\n```\n\n## noRestrictedGlobals\n\nBan specific global variables.\n\n```typescript\n// Configurable - can ban things like:\nevent;    // use event parameter instead\nname;     // shadows window.name\nlength;   // confusing\n```\n\n## noShoutyConstants\n\nAvoid all-caps for non-constants.\n\n```typescript\n// BAD\nlet MUTABLE_VALUE = 1;\nMUTABLE_VALUE = 2;\n\n// GOOD\nconst CONSTANT_VALUE = 1;\nlet mutableValue = 2;\n```\n\n## noUnusedTemplateLiteral\n\nUse string when template isn't needed.\n\n```typescript\n// BAD\nconst s = `no interpolation`;\n\n// GOOD\nconst s = \"no interpolation\";\n\n// OK - has interpolation\nconst s = `Hello ${name}`;\n```\n\n## noUselessElse\n\nRemove unnecessary else.\n\n```typescript\n// BAD\nfunction foo() {\n  if (x) {\n    return 1;\n  } else {\n    return 2;\n  }\n}\n\n// GOOD\nfunction foo() {\n  if (x) {\n    return 1;\n  }\n  return 2;\n}\n```\n\n## noVar\n\nUse let/const instead of var.\n\n```typescript\n// BAD\nvar x = 1;\n\n// GOOD\nconst x = 1;\nlet y = 2;\n```\n\n## useAsConstAssertion\n\nUse as const for literal types.\n\n```typescript\n// BAD\nconst x = { a: 1 } as { a: 1 };\n\n// GOOD\nconst x = { a: 1 } as const;\n```\n\n## useBlockStatements\n\nRequire braces for control statements.\n\n```typescript\n// BAD\nif (x) doSomething();\nfor (const x of arr) process(x);\n\n// GOOD\nif (x) {\n  doSomething();\n}\nfor (const x of arr) {\n  process(x);\n}\n```\n\n## useCollapsedElseIf\n\nUse else if not else { if.\n\n```typescript\n// BAD\nif (a) {\n} else {\n  if (b) {\n  }\n}\n\n// GOOD\nif (a) {\n} else if (b) {\n}\n```\n\n## useConst\n\nUse const when variable isn't reassigned.\n\n```typescript\n// BAD\nlet x = 1;\nconsole.log(x);  // x never reassigned\n\n// GOOD\nconst x = 1;\nconsole.log(x);\n```\n\n## useDefaultParameterLast\n\nDefault parameters should be last.\n\n```typescript\n// BAD\nfunction foo(a = 1, b: number) {}\n\n// GOOD\nfunction foo(b: number, a = 1) {}\n```\n\n## useEnumInitializers\n\nRequire explicit enum values.\n\n```typescript\n// BAD\nenum Color {\n  Red,    // 0\n  Green,  // 1\n  Blue,   // 2\n}\n\n// GOOD\nenum Color {\n  Red = 0,\n  Green = 1,\n  Blue = 2,\n}\n\n// Or string enum\nenum Color {\n  Red = \"red\",\n  Green = \"green\",\n  Blue = \"blue\",\n}\n```\n\n## useExponentiationOperator\n\nUse ** instead of Math.pow.\n\n```typescript\n// BAD\nMath.pow(2, 3);\n\n// GOOD\n2 ** 3;\n```\n\n## useExportType\n\nUse export type for type-only exports.\n\n```typescript\n// BAD\nexport { MyType } from \"./types\";\n\n// GOOD\nexport type { MyType } from \"./types\";\n```\n\n## useFilenamingConvention\n\nEnforce file naming conventions.\n\n```\n// BAD\nMyComponent.tsx\nmy_component.tsx\n\n// GOOD (with camelCase config)\nmyComponent.tsx\n\n// GOOD (with kebab-case config)\nmy-component.tsx\n```\n\n## useForOf\n\nUse for-of instead of for loop.\n\n```typescript\n// BAD\nfor (let i = 0; i < arr.length; i++) {\n  console.log(arr[i]);\n}\n\n// GOOD\nfor (const item of arr) {\n  console.log(item);\n}\n```\n\n## useFragmentSyntax\n\nUse <> instead of <Fragment>.\n\n```tsx\n// BAD\n<Fragment>\n  <Child />\n</Fragment>\n\n// GOOD\n<>\n  <Child />\n</>\n```\n\n## useImportType\n\nUse import type for type-only imports.\n\n```typescript\n// BAD\nimport { MyType } from \"./types\";\n\n// GOOD\nimport type { MyType } from \"./types\";\n\n// Mixed\nimport { getValue, type MyType } from \"./module\";\n```\n\n## useLiteralEnumMembers\n\nEnum members should be literals.\n\n```typescript\n// BAD\nconst value = 1;\nenum Foo {\n  A = value,  // computed\n}\n\n// GOOD\nenum Foo {\n  A = 1,\n  B = \"b\",\n}\n```\n\n## useNamingConvention\n\nEnforce naming conventions.\n\n```typescript\n// Default conventions:\nclass PascalCase {}\ninterface IPascalCase {}  // or without I\ntype PascalCase = {};\nconst camelCase = 1;\nconst SCREAMING_SNAKE_CASE = 1;  // const\nfunction camelCase() {}\n```\n\n## useNodejsImportProtocol\n\nUse node: protocol for Node imports.\n\n```typescript\n// BAD\nimport fs from \"fs\";\nimport path from \"path\";\n\n// GOOD\nimport fs from \"node:fs\";\nimport path from \"node:path\";\n```\n\n## useNumberNamespace\n\nUse Number methods instead of globals.\n\n```typescript\n// BAD\nparseInt(\"10\");\nparseFloat(\"3.14\");\nisNaN(x);\nisFinite(x);\n\n// GOOD\nNumber.parseInt(\"10\");\nNumber.parseFloat(\"3.14\");\nNumber.isNaN(x);\nNumber.isFinite(x);\n```\n\n## useNumericLiterals\n\nUse numeric literals not parseInt.\n\n```typescript\n// BAD\nparseInt(\"10\", 2);   // binary\nparseInt(\"10\", 8);   // octal\nparseInt(\"10\", 16);  // hex\n\n// GOOD\n0b10;  // binary\n0o10;  // octal\n0x10;  // hex\n```\n\n## useSelfClosingElements\n\nSelf-close empty elements.\n\n```tsx\n// BAD\n<div></div>\n<Component></Component>\n\n// GOOD\n<div />\n<Component />\n```\n\n## useShorthandArrayType\n\nUse T[] not Array<T>.\n\n```typescript\n// BAD\nconst arr: Array<string> = [];\n\n// GOOD\nconst arr: string[] = [];\n\n// OK for complex types\nconst arr: Array<string | number> = [];\n```\n\n## useShorthandAssign\n\nUse compound assignment.\n\n```typescript\n// BAD\nx = x + 1;\nx = x * 2;\nx = x ?? default;\n\n// GOOD\nx += 1;  // or x++\nx *= 2;\nx ??= default;\n```\n\n## useShorthandFunctionType\n\nUse function type shorthand.\n\n```typescript\n// BAD\ninterface Func {\n  (): void;\n}\n\n// GOOD\ntype Func = () => void;\n```\n\n## useSingleCaseStatement\n\nGroup single-case switches.\n\n```typescript\n// BAD\nswitch (x) {\n  case 1:\n    break;\n}\n\n// GOOD\nif (x === 1) {\n  // ...\n}\n```\n\n## useSingleVarDeclarator\n\nOne variable per declaration.\n\n```typescript\n// BAD\nlet a = 1, b = 2, c = 3;\n\n// GOOD\nlet a = 1;\nlet b = 2;\nlet c = 3;\n```\n\n## useTemplate\n\nUse template literals for concatenation.\n\n```typescript\n// BAD\nconst s = \"Hello \" + name + \"!\";\n\n// GOOD\nconst s = `Hello ${name}!`;\n```\n\n## useWhile\n\nUse while for simple loops.\n\n```typescript\n// BAD\nfor (; condition; ) {\n  doSomething();\n}\n\n// GOOD\nwhile (condition) {\n  doSomething();\n}\n```\n"}, {"path": "linters/biome/noExplicitAny.md", "category": "linters", "name": "linters/biome/noExplicitAny", "content": "# noExplicitAny\n\nDisallow the `any` type usage.\n\n## Why\n\nThe `any` type disables type checking and should be avoided.\n\n## Invalid\n\n```typescript\nlet x: any;\nfunction fn(param: any): any {}\n```\n\n## Valid\n\n```typescript\nlet x: unknown;\nfunction fn(param: unknown): string {}\n```\n\n## Fix\n\n1. Use a specific type if known\n2. Use `unknown` and narrow with type guards\n3. Use generics for flexible typing\n"}, {"path": "linters/biome/noConsole.md", "category": "linters", "name": "linters/biome/noConsole", "content": "# noConsole\n\nDisallow the use of `console`.\n\n## Why\n\nConsole statements are typically used for debugging and should not be in production code.\n\n## Invalid\n\n```typescript\nconsole.log(\"debug\");\n```\n\n## Valid\n\n```typescript\nconsole.error(\"Error occurred\");\nconsole.warn(\"Warning\");\nconsole.info(\"Info message\");\n\n// Or use a proper logger\nlogger.debug(\"debug\");\n```\n\n## Configuration\n\nAllow specific methods:\n\n```json\n{\n  \"noConsole\": {\n    \"level\": \"warn\",\n    \"options\": {\n      \"allow\": [\"warn\", \"error\", \"info\", \"debug\"]\n    }\n  }\n}\n```\n"}, {"path": "linters/biome/correctness.md", "category": "linters", "name": "linters/biome/correctness", "content": "# Biome Correctness Rules\n\nRules that prevent bugs and incorrect behavior.\n\n## noArrayIndexKey\n\nDon't use array index as key in React.\n\n```tsx\n// BAD - index as key\nitems.map((item, index) => <li key={index}>{item}</li>)\n\n// GOOD - unique id\nitems.map((item) => <li key={item.id}>{item.name}</li>)\n```\n\n**Why:** Reordering breaks component state.\n\n## noChildrenProp\n\nDon't pass children as props.\n\n```tsx\n// BAD\n<Component children={<span />} />\n\n// GOOD\n<Component>\n  <span />\n</Component>\n```\n\n## noConstAssign\n\nPrevent assignment to const variables.\n\n```typescript\n// BAD\nconst x = 1;\nx = 2;  // Error!\n\n// GOOD\nlet x = 1;\nx = 2;\n```\n\n## noConstructorReturn\n\nDon't return value from constructor.\n\n```typescript\n// BAD\nclass Foo {\n  constructor() {\n    return { bad: true };\n  }\n}\n\n// GOOD\nclass Foo {\n  bad: boolean;\n  constructor() {\n    this.bad = true;\n  }\n}\n```\n\n## noEmptyCharacterClassInRegex\n\nEmpty character class in regex is likely a bug.\n\n```typescript\n// BAD\nconst re = /[]/;  // matches nothing\n\n// GOOD\nconst re = /./;\n```\n\n## noEmptyPattern\n\nPrevent empty destructuring patterns.\n\n```typescript\n// BAD\nconst {} = obj;\nconst [] = arr;\n\n// GOOD\nconst { a, b } = obj;\nconst [first] = arr;\n```\n\n## noGlobalObjectCalls\n\nDon't call global objects as functions.\n\n```typescript\n// BAD\nMath();\nJSON();\nReflect();\n\n// GOOD\nMath.floor(1.5);\nJSON.parse(\"{}\");\n```\n\n## noInnerDeclarations\n\nPrevent declarations in nested blocks.\n\n```typescript\n// BAD\nif (condition) {\n  function foo() {}  // hoisting confusion\n}\n\n// GOOD\nfunction foo() {}\nif (condition) {\n  foo();\n}\n```\n\n## noInvalidConstructorSuper\n\nValidate super() calls in constructors.\n\n```typescript\n// BAD - missing super()\nclass Child extends Parent {\n  constructor() {\n    this.foo = 1;  // Error: must call super first\n  }\n}\n\n// GOOD\nclass Child extends Parent {\n  constructor() {\n    super();\n    this.foo = 1;\n  }\n}\n```\n\n## noInvalidNewBuiltin\n\nDon't use new with Symbol or BigInt.\n\n```typescript\n// BAD\nconst s = new Symbol(\"foo\");\nconst b = new BigInt(1);\n\n// GOOD\nconst s = Symbol(\"foo\");\nconst b = BigInt(1);\n```\n\n## noNewSymbol\n\nSame as above - Symbol is not a constructor.\n\n## noNonoctalDecimalEscape\n\nPrevent deprecated octal escapes.\n\n```typescript\n// BAD\n\"\\8\";\n\"\\9\";\n\n// GOOD\n\"8\";\n\"9\";\n```\n\n## noPrecisionLoss\n\nPrevent number literals that lose precision.\n\n```typescript\n// BAD\nconst x = 9007199254740993;  // loses precision\n\n// GOOD\nconst x = 9007199254740992n;  // BigInt\nconst x = 9007199254740992;   // safe integer\n```\n\n## noRenderReturnValue\n\nDon't use return value of ReactDOM.render.\n\n```tsx\n// BAD\nconst app = ReactDOM.render(<App />, root);\n\n// GOOD\nReactDOM.render(<App />, root);\n```\n\n## noSelfAssign\n\nPrevent self-assignment.\n\n```typescript\n// BAD\nx = x;\nobj.a = obj.a;\n\n// Remove the useless assignment\n```\n\n## noSetterReturn\n\nSetters should not return values.\n\n```typescript\n// BAD\nclass Foo {\n  set bar(value) {\n    return value;  // useless\n  }\n}\n\n// GOOD\nclass Foo {\n  set bar(value) {\n    this._bar = value;\n  }\n}\n```\n\n## noStringCaseMismatch\n\nPrevent impossible string comparisons.\n\n```typescript\n// BAD\ns.toLowerCase() === \"ABC\";  // always false\n\n// GOOD\ns.toLowerCase() === \"abc\";\n```\n\n## noSwitchDeclarations\n\nRequire block for declarations in switch cases.\n\n```typescript\n// BAD\nswitch (x) {\n  case 0:\n    let y = 1;  // leaks to other cases\n    break;\n}\n\n// GOOD\nswitch (x) {\n  case 0: {\n    let y = 1;\n    break;\n  }\n}\n```\n\n## noUndeclaredVariables\n\nCatch undeclared variable usage.\n\n```typescript\n// BAD\nconsole.log(undeclaredVar);\n\n// GOOD\nconst declaredVar = 1;\nconsole.log(declaredVar);\n```\n\n## noUnnecessaryContinue\n\nRemove unnecessary continue statements.\n\n```typescript\n// BAD\nfor (const x of arr) {\n  if (x) {\n    doSomething();\n  } else {\n    continue;  // unnecessary\n  }\n}\n\n// GOOD\nfor (const x of arr) {\n  if (x) {\n    doSomething();\n  }\n}\n```\n\n## noUnreachable\n\nDetect unreachable code.\n\n```typescript\n// BAD\nfunction foo() {\n  return 1;\n  console.log(\"never runs\");  // unreachable\n}\n```\n\n## noUnreachableSuper\n\nEnsure super() is always called.\n\n```typescript\n// BAD\nclass Child extends Parent {\n  constructor(cond) {\n    if (cond) {\n      super();\n    }\n    // super not called if !cond\n  }\n}\n```\n\n## noUnsafeFinally\n\nPrevent control flow in finally blocks.\n\n```typescript\n// BAD\ntry {\n  return 1;\n} finally {\n  return 2;  // overrides try's return\n}\n\n// GOOD\ntry {\n  return 1;\n} finally {\n  cleanup();\n}\n```\n\n## noUnsafeOptionalChaining\n\nPrevent unsafe use after optional chain.\n\n```typescript\n// BAD\n(obj?.foo)();  // might call undefined\n\n// GOOD\nobj?.foo?.();\n```\n\n## noUnusedImports\n\nRemove unused imports.\n\n```typescript\n// BAD\nimport { unused } from \"module\";\n\n// GOOD - remove it\n```\n\n## noUnusedLabels\n\nRemove unused labels.\n\n```typescript\n// BAD\nlabel: {\n  break label;\n}\nunusedLabel: {}  // never referenced\n```\n\n## noUnusedPrivateClassMembers\n\nRemove unused private members.\n\n```typescript\n// BAD\nclass Foo {\n  #unused = 1;  // never read\n}\n\n// Remove it or use it\n```\n\n## noUnusedVariables\n\nRemove unused variables.\n\n```typescript\n// BAD\nconst unused = 1;\n\n// GOOD - use underscore for intentionally unused\nconst _intentionallyUnused = 1;\n```\n\n## noVoidElementsWithChildren\n\nVoid elements can't have children.\n\n```tsx\n// BAD\n<img>content</img>\n<br>content</br>\n\n// GOOD\n<img />\n<br />\n```\n\n## noVoidTypeReturn\n\nVoid functions shouldn't have return value used.\n\n```typescript\n// BAD\nconst result = console.log(\"hi\");\n\n// console.log returns undefined\n```\n\n## useArrayLiterals\n\nUse array literals instead of Array constructor.\n\n```typescript\n// BAD\nnew Array(1, 2, 3);\n\n// GOOD\n[1, 2, 3];\n```\n\n## useExhaustiveDependencies\n\nReact hooks must have correct dependencies.\n\n```tsx\n// BAD\nuseEffect(() => {\n  doSomething(prop);\n}, []);  // missing 'prop'\n\n// GOOD\nuseEffect(() => {\n  doSomething(prop);\n}, [prop]);\n```\n\n## useHookAtTopLevel\n\nHooks must be at top level.\n\n```tsx\n// BAD\nif (condition) {\n  useEffect(() => {});\n}\n\n// GOOD\nuseEffect(() => {\n  if (condition) {\n    // ...\n  }\n});\n```\n\n## useIsNan\n\nUse Number.isNaN() not === NaN.\n\n```typescript\n// BAD\nif (x === NaN) {}  // always false!\n\n// GOOD\nif (Number.isNaN(x)) {}\n```\n\n## useJsxKeyInIterable\n\nElements in iterables need keys.\n\n```tsx\n// BAD\nitems.map(item => <div>{item}</div>);\n\n// GOOD\nitems.map(item => <div key={item.id}>{item}</div>);\n```\n\n## useValidForDirection\n\nPrevent infinite loops.\n\n```typescript\n// BAD\nfor (let i = 0; i < 10; i--) {}  // infinite!\n\n// GOOD\nfor (let i = 0; i < 10; i++) {}\n```\n\n## useYield\n\nGenerators must yield.\n\n```typescript\n// BAD\nfunction* gen() {\n  return 1;  // no yield!\n}\n\n// GOOD\nfunction* gen() {\n  yield 1;\n}\n```\n"}, {"path": "linters/biome/security.md", "category": "linters", "name": "linters/biome/security", "content": "# Biome Security Rules\n\nRules that prevent security vulnerabilities.\n\n## noDangerouslySetInnerHtml\n\nPrevent XSS via dangerouslySetInnerHTML.\n\n```tsx\n// BAD\n<div dangerouslySetInnerHTML={{ __html: userContent }} />\n\n// GOOD - sanitize first\nimport DOMPurify from \"dompurify\";\n<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(userContent) }} />\n\n// BETTER - avoid when possible\n<div>{userContent}</div>\n```\n\n## noDangerouslySetInnerHtmlWithChildren\n\nDon't combine dangerouslySetInnerHTML with children.\n\n```tsx\n// BAD - children are ignored\n<div dangerouslySetInnerHTML={{ __html: html }}>\n  <span>Child</span>\n</div>\n\n// GOOD - use one or the other\n<div dangerouslySetInnerHTML={{ __html: html }} />\n// or\n<div><span>Child</span></div>\n```\n\n## noGlobalEval\n\nDon't use eval().\n\n```typescript\n// BAD\neval(userInput);\nnew Function(userInput);\nsetTimeout(userInput, 1000);\nsetInterval(userInput, 1000);\n\n// GOOD\nJSON.parse(userInput);  // for data\n// Use proper parsing for code\n```\n\n## Configuration\n\n```json\n{\n  \"linter\": {\n    \"rules\": {\n      \"security\": {\n        \"noDangerouslySetInnerHtml\": \"error\",\n        \"noDangerouslySetInnerHtmlWithChildren\": \"error\",\n        \"noGlobalEval\": \"error\"\n      }\n    }\n  }\n}\n```\n"}, {"path": "linters/biome/complexity.md", "category": "linters", "name": "linters/biome/complexity", "content": "# Biome Complexity Rules\n\nRules that reduce cognitive complexity.\n\n## noBannedTypes\n\nAvoid problematic types.\n\n```typescript\n// BAD\nconst a: Object = {};     // use object or {}\nconst b: String = \"\";     // use string\nconst c: Number = 1;      // use number\nconst d: Boolean = true;  // use boolean\nconst e: Function = fn;   // use specific function type\nconst f: {} = {};         // use object or Record\n\n// GOOD\nconst a: object = {};\nconst b: string = \"\";\nconst c: number = 1;\nconst d: boolean = true;\nconst e: () => void = fn;\nconst f: Record<string, unknown> = {};\n```\n\n## noExcessiveCognitiveComplexity\n\nLimit cognitive complexity of functions.\n\n```typescript\n// BAD - too complex\nfunction process(items) {\n  for (const item of items) {           // +1\n    if (item.active) {                  // +2 (nested)\n      for (const sub of item.subs) {    // +3 (nested)\n        if (sub.valid) {                // +4 (nested)\n          if (sub.type === \"a\") {       // +5 (nested)\n            // ...\n          } else if (sub.type === \"b\") { // +1\n            // ...\n          }\n        }\n      }\n    }\n  }\n}  // complexity: 16+\n\n// GOOD - extract functions\nfunction processItem(item: Item): void {\n  if (!item.active) return;\n  for (const sub of item.subs) {\n    processSub(sub);\n  }\n}\n\nfunction processSub(sub: Sub): void {\n  if (!sub.valid) return;\n  handleSubByType(sub);\n}\n\nfunction handleSubByType(sub: Sub): void {\n  switch (sub.type) {\n    case \"a\":\n      // ...\n      break;\n    case \"b\":\n      // ...\n      break;\n  }\n}\n```\n\nConfiguration:\n```json\n{\n  \"complexity\": {\n    \"noExcessiveCognitiveComplexity\": {\n      \"level\": \"error\",\n      \"options\": {\n        \"maxAllowedComplexity\": 15\n      }\n    }\n  }\n}\n```\n\n## noExcessiveNestedTestSuites\n\nLimit nesting in test suites.\n\n```typescript\n// BAD\ndescribe(\"A\", () => {\n  describe(\"B\", () => {\n    describe(\"C\", () => {\n      describe(\"D\", () => {\n        describe(\"E\", () => {\n          it(\"works\", () => {});\n        });\n      });\n    });\n  });\n});\n\n// GOOD - flatten\ndescribe(\"A > B > C\", () => {\n  it(\"works for D > E case\", () => {});\n});\n```\n\n## noForEach\n\nUse for-of instead of forEach.\n\n```typescript\n// BAD\nitems.forEach((item) => {\n  process(item);\n});\n\n// GOOD\nfor (const item of items) {\n  process(item);\n}\n```\n\n**Why:**\n1. Can't use break/continue\n2. Can't await properly\n3. Harder to debug\n\n```typescript\n// forEach breaks with async\nitems.forEach(async (item) => {\n  await process(item);  // doesn't wait!\n});\n\n// for-of works correctly\nfor (const item of items) {\n  await process(item);  // waits properly\n}\n```\n\n## noStaticOnlyClass\n\nAvoid classes with only static members.\n\n```typescript\n// BAD\nclass Utils {\n  static helper() {}\n  static other() {}\n}\n\n// GOOD - use module/namespace\nexport function helper() {}\nexport function other() {}\n\n// Or use object\nexport const Utils = {\n  helper() {},\n  other() {},\n};\n```\n\n## noThisInStatic\n\nDon't use this in static methods.\n\n```typescript\n// BAD\nclass Foo {\n  static bar() {\n    return this.baz;  // confusing\n  }\n}\n\n// GOOD\nclass Foo {\n  static bar() {\n    return Foo.baz;  // explicit\n  }\n}\n```\n\n## noUselessCatch\n\nRemove useless catch blocks.\n\n```typescript\n// BAD\ntry {\n  doSomething();\n} catch (e) {\n  throw e;  // useless\n}\n\n// GOOD - just remove try/catch\ndoSomething();\n\n// Or add value\ntry {\n  doSomething();\n} catch (e) {\n  log(e);\n  throw e;\n}\n```\n\n## noUselessConstructor\n\nRemove empty constructors.\n\n```typescript\n// BAD\nclass Foo {\n  constructor() {}\n}\n\nclass Bar extends Baz {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\n// GOOD - remove constructor\nclass Foo {}\n\nclass Bar extends Baz {}\n```\n\n## noUselessEmptyExport\n\nRemove useless empty export.\n\n```typescript\n// BAD\nexport {};  // not needed if other exports exist\n\nexport function foo() {}\n\n// GOOD\nexport function foo() {}\n```\n\n## noUselessFragments\n\nRemove unnecessary React fragments.\n\n```tsx\n// BAD\n<>{children}</>\n<><Child /></>\n\n// GOOD\n{children}\n<Child />\n\n// OK - multiple children need fragment\n<>\n  <Child1 />\n  <Child2 />\n</>\n```\n\n## noUselessLabel\n\nRemove useless labels.\n\n```typescript\n// BAD\nfoo: for (const x of arr) {\n  break;  // doesn't use label\n}\n\n// GOOD - remove label\nfor (const x of arr) {\n  break;\n}\n\n// OK - label is used\nouter: for (const x of arr) {\n  for (const y of x) {\n    break outer;  // breaks outer loop\n  }\n}\n```\n\n## noUselessLoneBlockStatements\n\nRemove useless blocks.\n\n```typescript\n// BAD\n{\n  const x = 1;\n}\n\n// GOOD - remove block unless scoping needed\nconst x = 1;\n```\n\n## noUselessRename\n\nRemove useless rename in import/export.\n\n```typescript\n// BAD\nimport { foo as foo } from \"mod\";\nexport { bar as bar };\n\n// GOOD\nimport { foo } from \"mod\";\nexport { bar };\n```\n\n## noUselessSwitchCase\n\nRemove useless switch case.\n\n```typescript\n// BAD\nswitch (x) {\n  case 1:\n    break;\n  default:\n    break;  // useless, can just remove switch\n}\n\n// If only default, use if or nothing\n```\n\n## noUselessTernary\n\nRemove useless ternary.\n\n```typescript\n// BAD\nconst x = condition ? true : false;\nconst y = condition ? false : true;\n\n// GOOD\nconst x = condition;\nconst y = !condition;\n```\n\n## noUselessThisAlias\n\nRemove useless this alias.\n\n```typescript\n// BAD\nconst self = this;\nself.method();\n\n// GOOD\nthis.method();\n\n// OK - needed for closure\nconst self = this;\nfunction callback() {\n  self.method();\n}\n```\n\n## noUselessTypeConstraint\n\nRemove useless type constraints.\n\n```typescript\n// BAD\nfunction foo<T extends unknown>() {}\nfunction bar<T extends any>() {}\n\n// GOOD\nfunction foo<T>() {}\nfunction bar<T>() {}\n```\n\n## noVoid\n\nAvoid void operator.\n\n```typescript\n// BAD\nvoid 0;\nvoid doSomething();\n\n// GOOD\nundefined;\ndoSomething();\n```\n\n## noWith\n\nPrevent with statement.\n\n```typescript\n// BAD\nwith (obj) {\n  foo;  // confusing scope\n}\n\n// GOOD\nobj.foo;\n```\n\n## useFlatMap\n\nUse flatMap instead of map().flat().\n\n```typescript\n// BAD\narr.map(x => x.items).flat();\n\n// GOOD\narr.flatMap(x => x.items);\n```\n\n## useLiteralKeys\n\nUse literal keys when possible.\n\n```typescript\n// BAD\nobj[\"property\"];\n\n// GOOD\nobj.property;\n\n// OK - dynamic key\nobj[variableKey];\n```\n\n## useOptionalChain\n\nUse optional chaining.\n\n```typescript\n// BAD\nfoo && foo.bar;\nfoo && foo.bar && foo.bar.baz;\nfoo != null && foo.bar;\n\n// GOOD\nfoo?.bar;\nfoo?.bar?.baz;\n```\n\n## useRegexLiterals\n\nUse regex literals not RegExp constructor.\n\n```typescript\n// BAD\nnew RegExp(\"\\\\d+\");\n\n// GOOD\n/\\d+/;\n\n// OK - dynamic pattern\nnew RegExp(pattern);\n```\n\n## useSimpleNumberKeys\n\nUse number keys not string.\n\n```typescript\n// BAD\nconst obj = { \"1\": \"one\", \"2\": \"two\" };\n\n// GOOD\nconst obj = { 1: \"one\", 2: \"two\" };\n```\n\n## useSimplifiedLogicExpression\n\nSimplify logic expressions.\n\n```typescript\n// BAD\n!!value;\n!(!value);\nx && x;\n\n// GOOD\nBoolean(value);\nvalue;\nx;\n```\n"}]}
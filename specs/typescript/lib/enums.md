Was this page helpful?

- Get Started

  - [TS for the New Programmer](/docs/handbook/typescript-from-scratch.html)
  - [TypeScript for JS Programmers](/docs/handbook/typescript-in-5-minutes.html)
  - [TS for Java/C# Programmers](/docs/handbook/typescript-in-5-minutes-oop.html)
  - [TS for Functional Programmers](/docs/handbook/typescript-in-5-minutes-func.html)
  - [TypeScript Tooling in 5 minutes](/docs/handbook/typescript-tooling-in-5-minutes.html)

- Handbook

  - [The TypeScript Handbook](/docs/handbook/intro.html)
  - [The Basics](/docs/handbook/2/basic-types.html)
  - [Everyday Types](/docs/handbook/2/everyday-types.html)
  - [Narrowing](/docs/handbook/2/narrowing.html)
  - [More on Functions](/docs/handbook/2/functions.html)
  - [Object Types](/docs/handbook/2/objects.html)
  - Type Manipulation

    - [Creating Types from Types](/docs/handbook/2/types-from-types.html)
    - [Generics](/docs/handbook/2/generics.html)
    - [Keyof Type Operator](/docs/handbook/2/keyof-types.html)
    - [Typeof Type Operator](/docs/handbook/2/typeof-types.html)
    - [Indexed Access Types](/docs/handbook/2/indexed-access-types.html)
    - [Conditional Types](/docs/handbook/2/conditional-types.html)
    - [Mapped Types](/docs/handbook/2/mapped-types.html)
    - [Template Literal Types](/docs/handbook/2/template-literal-types.html)

  - [Classes](/docs/handbook/2/classes.html)
  - [Modules](/docs/handbook/2/modules.html)

- Reference

  - [Utility Types](/docs/handbook/utility-types.html)
  - [Cheat Sheets](/cheatsheets/)
  - [Decorators](/docs/handbook/decorators.html)
  - [Declaration Merging](/docs/handbook/declaration-merging.html)
  - [Enums](/docs/handbook/enums.html)
  - [Iterators and Generators](/docs/handbook/iterators-and-generators.html)
  - [JSX](/docs/handbook/jsx.html)
  - [Mixins](/docs/handbook/mixins.html)
  - [Namespaces](/docs/handbook/namespaces.html)
  - [Namespaces and Modules](/docs/handbook/namespaces-and-modules.html)
  - [Symbols](/docs/handbook/symbols.html)
  - [Triple-Slash Directives](/docs/handbook/triple-slash-directives.html)
  - [Type Compatibility](/docs/handbook/type-compatibility.html)
  - [Type Inference](/docs/handbook/type-inference.html)
  - [Variable Declaration](/docs/handbook/variable-declarations.html)

- Modules Reference

  - [Introduction](/docs/handbook/modules/introduction.html)
  - [Theory](/docs/handbook/modules/theory.html)
  - Guides

    - [Choosing Compiler Options](/docs/handbook/modules/guides/choosing-compiler-options.html)

  - [Reference](/docs/handbook/modules/reference.html)
  - Appendices

    - [ESM/CJS Interoperability](/docs/handbook/modules/appendices/esm-cjs-interop.html)

- Tutorials

  - [ASP.NET Core](/docs/handbook/asp-net-core.html)
  - [Gulp](/docs/handbook/gulp.html)
  - [DOM Manipulation](/docs/handbook/dom-manipulation.html)
  - [Migrating from JavaScript](/docs/handbook/migrating-from-javascript.html)
  - [Using Babel with TypeScript](/docs/handbook/babel-with-typescript.html)

- What's New

  - [TypeScript 5.9](/docs/handbook/release-notes/typescript-5-9.html)
  - [TypeScript 5.8](/docs/handbook/release-notes/typescript-5-8.html)
  - [TypeScript 5.7](/docs/handbook/release-notes/typescript-5-7.html)
  - [TypeScript 5.6](/docs/handbook/release-notes/typescript-5-6.html)
  - [TypeScript 5.5](/docs/handbook/release-notes/typescript-5-5.html)
  - [TypeScript 5.4](/docs/handbook/release-notes/typescript-5-4.html)
  - [TypeScript 5.3](/docs/handbook/release-notes/typescript-5-3.html)
  - [TypeScript 5.2](/docs/handbook/release-notes/typescript-5-2.html)
  - [TypeScript 5.1](/docs/handbook/release-notes/typescript-5-1.html)
  - [TypeScript 5.0](/docs/handbook/release-notes/typescript-5-0.html)
  - [TypeScript 4.9](/docs/handbook/release-notes/typescript-4-9.html)
  - [TypeScript 4.8](/docs/handbook/release-notes/typescript-4-8.html)
  - [TypeScript 4.7](/docs/handbook/release-notes/typescript-4-7.html)
  - [TypeScript 4.6](/docs/handbook/release-notes/typescript-4-6.html)
  - [TypeScript 4.5](/docs/handbook/release-notes/typescript-4-5.html)
  - [TypeScript 4.4](/docs/handbook/release-notes/typescript-4-4.html)
  - [TypeScript 4.3](/docs/handbook/release-notes/typescript-4-3.html)
  - [TypeScript 4.2](/docs/handbook/release-notes/typescript-4-2.html)
  - [TypeScript 4.1](/docs/handbook/release-notes/typescript-4-1.html)
  - [TypeScript 4.0](/docs/handbook/release-notes/typescript-4-0.html)
  - [TypeScript 3.9](/docs/handbook/release-notes/typescript-3-9.html)
  - [TypeScript 3.8](/docs/handbook/release-notes/typescript-3-8.html)
  - [TypeScript 3.7](/docs/handbook/release-notes/typescript-3-7.html)
  - [TypeScript 3.6](/docs/handbook/release-notes/typescript-3-6.html)
  - [TypeScript 3.5](/docs/handbook/release-notes/typescript-3-5.html)
  - [TypeScript 3.4](/docs/handbook/release-notes/typescript-3-4.html)
  - [TypeScript 3.3](/docs/handbook/release-notes/typescript-3-3.html)
  - [TypeScript 3.2](/docs/handbook/release-notes/typescript-3-2.html)
  - [TypeScript 3.1](/docs/handbook/release-notes/typescript-3-1.html)
  - [TypeScript 3.0](/docs/handbook/release-notes/typescript-3-0.html)
  - [TypeScript 2.9](/docs/handbook/release-notes/typescript-2-9.html)
  - [TypeScript 2.8](/docs/handbook/release-notes/typescript-2-8.html)
  - [TypeScript 2.7](/docs/handbook/release-notes/typescript-2-7.html)
  - [TypeScript 2.6](/docs/handbook/release-notes/typescript-2-6.html)
  - [TypeScript 2.5](/docs/handbook/release-notes/typescript-2-5.html)
  - [TypeScript 2.4](/docs/handbook/release-notes/typescript-2-4.html)
  - [TypeScript 2.3](/docs/handbook/release-notes/typescript-2-3.html)
  - [TypeScript 2.2](/docs/handbook/release-notes/typescript-2-2.html)
  - [TypeScript 2.1](/docs/handbook/release-notes/typescript-2-1.html)
  - [TypeScript 2.0](/docs/handbook/release-notes/typescript-2-0.html)
  - [TypeScript 1.8](/docs/handbook/release-notes/typescript-1-8.html)
  - [TypeScript 1.7](/docs/handbook/release-notes/typescript-1-7.html)
  - [TypeScript 1.6](/docs/handbook/release-notes/typescript-1-6.html)
  - [TypeScript 1.5](/docs/handbook/release-notes/typescript-1-5.html)
  - [TypeScript 1.4](/docs/handbook/release-notes/typescript-1-4.html)
  - [TypeScript 1.3](/docs/handbook/release-notes/typescript-1-3.html)
  - [TypeScript 1.1](/docs/handbook/release-notes/typescript-1-1.html)

- Declaration Files

  - [Introduction](/docs/handbook/declaration-files/introduction.html)
  - [Declaration Reference](/docs/handbook/declaration-files/by-example.html)
  - [Library Structures](/docs/handbook/declaration-files/library-structures.html)
  - .d.ts Templates

    - [Modules .d.ts](/docs/handbook/declaration-files/templates/module-d-ts.html)
    - [Module: Plugin](/docs/handbook/declaration-files/templates/module-plugin-d-ts.html)
    - [Module: Class](/docs/handbook/declaration-files/templates/module-class-d-ts.html)
    - [Module: Function](/docs/handbook/declaration-files/templates/module-function-d-ts.html)
    - [Global .d.ts](/docs/handbook/declaration-files/templates/global-d-ts.html)
    - [Global: Modifying Module](/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html)

  - [Do's and Don'ts](/docs/handbook/declaration-files/do-s-and-don-ts.html)
  - [Deep Dive](/docs/handbook/declaration-files/deep-dive.html)
  - [Publishing](/docs/handbook/declaration-files/publishing.html)
  - [Consumption](/docs/handbook/declaration-files/consumption.html)

- JavaScript

  - [JS Projects Utilizing TypeScript](/docs/handbook/intro-to-js-ts.html)
  - [Type Checking JavaScript Files](/docs/handbook/type-checking-javascript-files.html)
  - [JSDoc Reference](/docs/handbook/jsdoc-supported-types.html)
  - [Creating .d.ts Files from .js files](/docs/handbook/declaration-files/dts-from-js.html)

- Project Configuration

  - [What is a tsconfig.json](/docs/handbook/tsconfig-json.html)
  - [Compiler Options in MSBuild](/docs/handbook/compiler-options-in-msbuild.html)
  - [TSConfig Reference](/tsconfig/)
  - [tsc CLI Options](/docs/handbook/compiler-options.html)
  - [Project References](/docs/handbook/project-references.html)
  - [Integrating with Build Tools](/docs/handbook/integrating-with-build-tools.html)
  - [Configuring Watch](/docs/handbook/configuring-watch.html)
  - [Nightly Builds](/docs/handbook/nightly-builds.html)

# Enums

Enums are one of the few features TypeScript has which is not a type-level extension of JavaScript.

Enums allow a developer to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.

## #numeric-enumsNumeric enums

We’ll first start off with numeric enums, which are probably more familiar if you’re coming from other languages. An enum can be defined using the `enum` keyword.

```
tsenum Direction {  Up = 1,  Down,  Left,  Right,}Tryhttps://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADlALxQCMANAbBgO4h2EAywAZqq1AEpwA5gAseeAL5A
```

Above, we have a numeric enum where `Up` is initialized with `1`. All of the following members are auto-incremented from that point on. In other words, `Direction.Up` has the value `1`, `Down` has `2`, `Left` has `3`, and `Right` has `4`.

If we wanted, we could leave off the initializers entirely:

```
tsenum Direction {  Up,  Down,  Left,  Right,}Tryhttps://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADgDQGwYDuIFhAMsAGar1QBKcA5gBZt4AvkA
```

Here, `Up` would have the value `0`, `Down` would have `1`, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.

Using an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:

```
tsenum UserResponse {  No = 0,  Yes = 1,} function respond(recipient: string, message: UserResponse): void {  // ...} respond("Princess Caroline", UserResponse.Yes);Tryhttps://www.typescriptlang.org/play/#code/KYOwrgtgBAqgzsATgJWHADgexAqBvAKCigDlMoBeKABgBoioBNNSqARnoF8CCAzMEAGMALgEtsURGiwgAJgAopg0elGhhALihxhiUSADmtKBDRwAhgeBb4SVBmwIAlFoBumUbPwMA9D6gAdEEE3ARSDnLyAEQACnpCZlAAwuaImAA2+sBRxrYo0o7AAcxwTgDcQA
```

Numeric enums can be mixed in [computed and constant members (see below)](#computed-and-constant-members). The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn’t allowed:

```
tsenum E {  A = getSomeValue(),  B,Enum member must have initializer.1061Enum member must have initializer.}Tryhttps://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYBsaBQBjOAO0QBdQBzSUgZTgFtIA1AQwBsBXSUAXlAAoAlLwB8oAEwBmANy4QoALRL8HUkoW5IRDvVABRUAG9coUAEFelanUatOkIQBoToAELOAvkA
```

## #string-enumsString enums

String enums are a similar concept, but have some subtle [runtime differences](#enums-at-runtime) as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.

```
tsenum Direction {  Up = "UP",  Down = "DOWN",  Left = "LEFT",  Right = "RIGHT",}Tryhttps://www.typescriptlang.org/play/#code/KYOwrgtgBAIglgJ2AYwC5wPYigbwFBRQCqADlALxQBERAClQDQGwYDu2lVMA8gOoByjZgBlgAM1QVqwgKIAxACpDCAJTgBzABaTOKgJIBxABJKmAXyA
```

While string enums don’t have auto-incrementing behavior, string enums have the benefit that they “serialize” well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn’t convey any useful meaning on its own (though [reverse mapping](#reverse-mappings) can often help). String enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.

## #heterogeneous-enumsHeterogeneous enums

Technically enums can be mixed with string and numeric members, but it’s not clear why you would ever want to do so:

```
tsenum BooleanLikeHeterogeneousEnum {  No = 0,  Yes = "YES",}Tryhttps://www.typescriptlang.org/play/#code/KYOwrgtgBAQg9nANsAhiAMgSwNbABLAAuwATnAOajBxgDOAouNAN4BQUUAcnFALxQAGADTsoATWC0+UAERj6AZRkiAvkA
```

Unless you’re really trying to take advantage of JavaScript’s runtime behavior in a clever way, it’s advised that you don’t do this.

## #computed-and-constant-membersComputed and constant members

Each enum member has a value associated with it which can be either constant or computed. An enum member is considered constant if:

- 

It is the first member in the enum and it has no initializer, in which case it’s assigned the value `0`:

```
ts// E.X is constant:enum E {  X,}Tryhttps://www.typescriptlang.org/play/#code/PTAEFEDoA1QSwM6gMYHsB2CAuBDdWAuAKAFN0BXAWwlAG8jRRoAaIgXyA
```

- 

It does not have an initializer and the preceding enum member was a numeric constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.

```
ts// All enum members in 'E1' and 'E2' are constant. enum E1 {  X,  Y,  Z,} enum E2 {  A = 1,  B,  C,}Tryhttps://www.typescriptlang.org/play/#code/PTAEEEBtNBTA7ArgW1M2yBGsBOBnUAS3lAHIBRARlNAEN4ATM8gJhtp1lAGMB7ePABd6ggHQAocQhSgqoAN7jQoABoAaJaACaG5QC0NAX0nTUrBZvCgAvKEq7QAIQcBhI0A
```

- 

The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:

  1. a literal enum expression (basically a string literal or a numeric literal)
  2. a reference to previously defined constant enum member (which can originate from a different enum)
  3. a parenthesized constant enum expression
  4. one of the `+`, `-`, `~` unary operators applied to constant enum expression
  5. `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^` binary operators with constant enum expressions as operands

It is a compile time error for constant enum expressions to be evaluated to `NaN` or `Infinity`.

In all other cases enum member is considered computed.

```
tsenum FileAccess {  // constant members  None,  Read = 1 << 1,  Write = 1 << 2,  ReadWrite = Read | Write,  // computed member  G = "123".length,}Tryhttps://www.typescriptlang.org/play/#code/KYOwrgtgBAYglgG2AQQMauAZ01A3gKCigHpipUB7ETAFwEMQaoJgIAjYAJ00KgDkqwADS8ASsDoATKAF4oARigAeJQpFEA6pzg1gshctUAmdVHFStOvXPPSAPlEu7TpchQgAHMLukt2XXgBxfQAieSMAZhCAOiQQAHMaAAsRAF8gA
```

## #union-enums-and-enum-member-typesUnion enums and enum member types

There is a special subset of constant enum members that aren’t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to

- any string literal (e.g. `"foo"`, `"bar"`, `"baz"`)
- any numeric literal (e.g. `1`, `100`)
- a unary minus applied to any numeric literal (e.g. `-1`, `-100`)

When all members in an enum have literal enum values, some special semantics come into play.

The first is that enum members also become types as well! For example, we can say that certain members can only have the value of an enum member:

```
tsenum ShapeKind {  Circle,  Square,} interface Circle {  kind: ShapeKind.Circle;  radius: number;} interface Square {  kind: ShapeKind.Square;  sideLength: number;} let c: Circle = {  kind: ShapeKind.Square,Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.2322Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.  radius: 100,};Tryhttps://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFCQHYCuAtqAMoAWAhgA6QDSAlvgCagDeOooAwo9AGMANpAA0XcgEdCVaGJwBfHDmYAXGADMqAyL37DdnbgGtmLVJVoMzAOj6CRAbgnQqLRoRSgixAEYxnJRV8dWgtHSkZOQ4JU1YLajomVhsyaVlIZ25ERhZIABkCAHNVClQff2hA5RFVUAFUewNQAF4YkzMEq2SWVPS5cW5Xd09UAEYABgnxBUcgA
```

The other change is that enum types themselves effectively become a union of each enum member. With union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch bugs where we might be comparing values incorrectly. For example:

```
tsenum E {  Foo,  Bar,} function f(x: E) {  if (x !== E.Foo || x !== E.Bar) {This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.2367This comparison appears to be unintentional because the types 'E.Foo' and 'E.Bar' have no overlap.    //  }}Tryhttps://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUJAHYCuAtqAKKgDeeooAYnHADR2gBCAhtGwL548AM2KEAxgBcAlnEKghACgAeqCgEoa7KUNDLQAQgC8hygDomcUAB8roJQeNnu0DbXr0Q7AXyA
```

In that example, we first checked whether `x` was not`E.Foo`. If that check succeeds, then our `||` will short-circuit, and the body of the ‘if’ will run. However, if the check didn’t succeed, then `x` can only be `E.Foo`, so it doesn’t make sense to see whether it’s not equal to `E.Bar`.

## #enums-at-runtimeEnums at runtime

Enums are real objects that exist at runtime. For example, the following enum

```
tsenum E {  X,  Y,  Z,}Tryhttps://www.typescriptlang.org/play/#code/KYOwrgtgBAolDeAoKUAaAaZUCamUC1MBfIA
```

can actually be passed around to functions

```
tsenum E {  X,  Y,  Z,} function f(obj: { X: number }) {  return obj.X;} // Works, since 'E' has a property named 'X' which is a number.f(E);Tryhttps://www.typescriptlang.org/play/#code/KYOwrgtgBAolDeAoKUAaAaZUCamUC1MBfRRAMzBAGMAXASwHsQoyAKBgIwCsAuBNPuAgdgAJyhEAlAiyjgNMKOacuAOlQBuRCUQB6XVADqDUQGsAzuijm61YFADkMB1AAWAQ3NR3UAA6iGXzEaAE8oEHcIYAATR1QXAHdXOipXKDovHyERUVVyVhhJDSA
```

## #enums-at-compile-timeEnums at compile time

Even though Enums are real objects that exist at runtime, the `keyof` keyword works differently than you might expect for typical objects. Instead, use `keyof typeof` to get a Type that represents all Enum keys as strings.

```
tsenum LogLevel {  ERROR,  WARN,  INFO,  DEBUG,} /** * This is equivalent to: * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG'; */type LogLevelStrings = keyof typeof LogLevel; function printImportant(key: LogLevelStrings, message: string) {  const num = LogLevel[key];  if (num <= LogLevel.WARN) {    console.log("Log level key is:", key);    console.log("Log level value is:", num);    console.log("Log level message is:", message);  }}printImportant("ERROR", "This is a message");Tryhttps://www.typescriptlang.org/play/#code/KYOwrgtgBAMg9gcxsAbsANlA3gKClAUQCUiB5IgGjygHUBBIgOSvwElGAxUlqAEQIBCAVQDiVAL44cAegBUsvLKgAVABYBLAM5QtUYAEcw6lAEN0oAC5QLcAFyLrATwAOwWImRp0AZQsAndRAEbQBeKAByYjIicKgAHwj6JliE8PYuFIj+YRFwgG5FaRwLFzd4JFQMXwCg0KgAa2BHOAAzJ1dW9wqvApwWsBAAYwt1OBAoZxqLVghnOD8LExALAApGx1suzyr-QOCKKAhgTU0TBGBNzV2ggEpsakGxq6hwaDDy7fQAbXWAXQL8Oo2itXlAADzvDyVdAAOiSjDuuHw+EeIE0cHMMPQiBWACJylBzF4Gk0dJpbLiDusbgDkaj0ZjsQg8QSiRgoKZ0GA3FoKQdXjTqCinhjgFicfjEIToYdjqdzmS+bKTmdgIL8JJJJNAtNZvNFss8VFyJSoLi1LpdCZlfLgLiaUA
```

### #reverse-mappingsReverse mappings

In addition to creating an object with property names for members, numeric enums members also get a reverse mapping from enum values to enum names. For example, in this example:

```
tsenum Enum {  A,} let a = Enum.A;let nameOfA = Enum[a]; // "A"Tryhttps://www.typescriptlang.org/play/#code/KYOwrgtgBAou0G8BQUoEEA0SC+SkBtgAXKAQygF5Z4A6NAbgOKhFImAHkAzNS6yANqkAuvSgB6cVABEaaUA
```

TypeScript compiles this down to the following JavaScript:

```
ts"use strict";var Enum;(function (Enum) {    Enum[Enum["A"] = 0] = "A";})(Enum || (Enum = {}));let a = Enum.A;let nameOfA = Enum[a]; // "A" Tryhttps://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAFMB2BXZURAogb01FAEEAaTAX00wBtt1QBDUAXmNIB01ANyt2oXJ2TYA8gDNqvfoQDanALrDQIUACJquoA
```

In this generated code, an enum is compiled into an object that stores both forward (`name` -> `value`) and reverse (`value` -> `name`) mappings. References to other enum members are always emitted as property accesses and never inlined.

Keep in mind that string enum members do not get a reverse mapping generated at all.

### #const-enums`const` enums

In most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it’s possible to use `const` enums. Const enums are defined using the `const` modifier on our enums:

```
tsconst enum Enum {  A = 1,  B = A * 2,}Tryhttps://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgUSag3gKBjAQRgF4YBGAGjxgCETCYAqGAJioF8g
```

Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.

```
tsconst enum Direction {  Up,  Down,  Left,  Right,} let directions = [  Direction.Up,  Direction.Down,  Direction.Left,  Direction.Right,];Tryhttps://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgEQJYCc7Ch8GAbwCgYYBVABwBoz0QB3MO8gGTgDMpWYAlDAHMAFjxIBfEiQA2cWABNsufOAgwAvDADa9TDjwEwAOmq89yw0bRMWupQfBGO3M-ZXGBIsQF0A3EA
```

in generated code will become

```
ts"use strict";let directions = [    0 /* Direction.Up */,    1 /* Direction.Down */,    2 /* Direction.Left */,    3 /* Direction.Right */,]; Tryhttps://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAGNYDtJ1QBTPAV2VABFUAnY7dVfUAb01FAFUAHAGg7UEeAZwAyxAGbpRoAEqoA5tBmYAvpkwAbYkQAmdBk3yRQAXlABtQTXqNmeAHS9Ztow8dVhrw-fyOJaR87YycFZVUAXQBuIA
```

#### #const-enum-pitfallsConst enum pitfalls

Inlining enum values is straightforward at first, but comes with subtle implications. These pitfalls pertain to ambient const enums only (basically const enums in `.d.ts` files) and sharing them between projects, but if you are publishing or consuming `.d.ts` files, these pitfalls likely apply to you, because `tsc --declaration` transforms `.ts` files into `.d.ts` files.

1. For the reasons laid out in the [isolatedModules documentation](/tsconfig#references-to-const-enum-members), that mode is fundamentally incompatible with ambient const enums. This means if you publish ambient const enums, downstream consumers will not be able to use [isolatedModules](/tsconfig#isolatedModules) and those enum values at the same time.
2. You can easily inline values from version A of a dependency at compile time, and import version B at runtime. Version A and B’s enums can have different values, if you are not very careful, resulting in [surprising bugs](https://github.com/microsoft/TypeScript/issues/5219#issue-110947903), like taking the wrong branches of `if` statements. These bugs are especially pernicious because it is common to run automated tests at roughly the same time as projects are built, with the same dependency versions, which misses these bugs completely.
3. [importsNotUsedAsValues: "preserve"](/tsconfig#importsNotUsedAsValues) will not elide imports for const enums used as values, but ambient const enums do not guarantee that runtime `.js` files exist. The unresolvable imports cause errors at runtime. The usual way to unambiguously elide imports, [type-only imports](/docs/handbook/modules/reference.html#type-only-imports-and-exports), [does not allow const enum values](https://github.com/microsoft/TypeScript/issues/40344), currently.

Here are two approaches to avoiding these pitfalls:

1. 

Do not use const enums at all. You can easily [ban const enums](https://typescript-eslint.io/linting/troubleshooting#how-can-i-ban-specific-language-feature) with the help of a linter. Obviously this avoids any issues with const enums, but prevents your project from inlining its own enums. Unlike inlining enums from other projects, inlining a project’s own enums is not problematic and has performance implications.

2. 

Do not publish ambient const enums, by deconstifying them with the help of [preserveConstEnums](/tsconfig#preserveConstEnums). This is the approach taken internally by the [TypeScript project itself](https://github.com/microsoft/TypeScript/pull/5422). [preserveConstEnums](/tsconfig#preserveConstEnums) emits the same JavaScript for const enums as plain enums. You can then safely strip the `const` modifier from `.d.ts` files [in a build step](https://github.com/microsoft/TypeScript/blob/1a981d1df1810c868a66b3828497f049a944951c/Gulpfile.js#L144).

This way downstream consumers will not inline enums from your project, avoiding the pitfalls above, but a project can still inline its own enums, unlike banning const enums entirely.

## #ambient-enumsAmbient enums

Ambient enums are used to describe the shape of already existing enum types.

```
tsdeclare enum Enum {  A = 1,  B,  C = 2,}Tryhttps://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEIB2BXAtvAoqjBvAUPPAILwC88AjADSHwBCtRAwufAEy0C+QA
```

One important difference between ambient and non-ambient enums is that, in regular enums, members that don’t have an initializer will be considered constant if its preceding enum member is considered constant. By contrast, an ambient (and non-const) enum member that does not have an initializer is always considered computed.

## #objects-vs-enumsObjects vs Enums

In modern TypeScript, you may not need an enum when an object with `as const` could suffice:

```
tsconst enum EDirection {  Up,  Down,  Left,  Right,} const ODirection = {  Up: 0,  Down: 1,  Left: 2,  Right: 3,} as const; EDirection.Up;           (enum member) EDirection.Up = 0 ODirection.Up;           (property) Up: 0 // Using the enum as a parameterfunction walk(dir: EDirection) {} // It requires an extra line to pull out the valuestype Direction = typeof ODirection[keyof typeof ODirection];function run(dir: Direction) {} walk(EDirection.Left);run(ODirection.Right);Tryhttps://www.typescriptlang.org/play/#code/MYewdgzgLgBApmArgWxgUQCIEsBOdhRbgwDeAUDDAKoAOANBTBiAO5gOUAycAZlBzABKWAOYALfmQC+ZMqEiwA8tjwEiYGAF5SjWgC4YABgHM2BgIwDufAwCYBw8VAMBmBlJgBDCDHnQA3LKYuPiE4AB0tIEA9NGU8QkAegD8ssohahFRZLEJeSmyuVQQWGAiMFBicPBIqN5eMDSeOJ7IcFBwOGQ8iGCZGiyeADYA1gAUACa4BsGqYWAAlKQyOXEAkrB4AI6IIT6eGnAAHlAtMEOl1VAgjYhDQzAgiLCV1QBuw4hwEGRQAJ40aoqULqLQVAFwEA8GDpObqADaIzgfyh4MBqNhIPAAF1Aj0+vMYDhepNpkwMvMliQVoNRmNZliwOFrFAFoFiWAxpj+uFHBI2UA
```

The biggest argument in favour of this format over TypeScript’s `enum` is that it keeps your codebase aligned with the state of JavaScript, and [when/if](https://github.com/rbuckton/proposal-enum) enums are added to JavaScript then you can move to the additional syntax.

##### On this page

- [Numeric enums](#numeric-enums)
- [String enums](#string-enums)
- [Heterogeneous enums](#heterogeneous-enums)
- [Computed and constant members](#computed-and-constant-members)
- [Union enums and enum member types](#union-enums-and-enum-member-types)
- [Enums at runtime](#enums-at-runtime)
- [Enums at compile time](#enums-at-compile-time)

  - [Reverse mappings](#reverse-mappings)
  - [const enums](#const-enums)

- [Ambient enums](#ambient-enums)
- [Objects vs Enums](#objects-vs-enums)

##### Is this page helpful?

YesNo

The TypeScript docs are an open source project. Help us improve these pages [by sending a Pull Request](https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/reference/Enums.md) ❤

Contributors to this page:
OTAGFDG-SGTA11+

Last updated: Jan 05, 2026

{"language": "elixir", "generatedAt": "2026-01-06T18:23:22.053767+00:00", "entries": [{"path": "generation-checklist.md", "category": "spec", "name": "generation-checklist", "content": "# Elixir Generation Checklist\n\n**Read this BEFORE writing Elixir code. Embrace immutability and pattern matching.**\n\n## Critical: You Must Do These\n\n### 1. Use Pattern Matching Everywhere\n```elixir\n# BAD - imperative style\ndef process(user) do\n  if user != nil do\n    if user.active do\n      # do work\n    end\n  end\nend\n\n# GOOD - pattern matching\ndef process(%User{active: true} = user) do\n  # do work with active user\nend\n\ndef process(%User{active: false}) do\n  {:error, :inactive_user}\nend\n\ndef process(nil) do\n  {:error, :no_user}\nend\n```\n\n### 2. Use the Pipe Operator for Data Transformation\n```elixir\n# BAD - nested function calls\nString.downcase(String.trim(String.replace(input, \"  \", \" \")))\n\n# GOOD - pipe operator\ninput\n|> String.replace(\"  \", \" \")\n|> String.trim()\n|> String.downcase()\n```\n\n### 3. Return Tagged Tuples for Results\n```elixir\n# BAD - returning nil or raising\ndef find_user(id) do\n  # returns nil if not found - caller might forget to check\nend\n\n# GOOD - tagged tuples\ndef find_user(id) do\n  case Repo.get(User, id) do\n    nil -> {:error, :not_found}\n    user -> {:ok, user}\n  end\nend\n\n# GOOD - handle with case or with\ncase find_user(id) do\n  {:ok, user} -> process(user)\n  {:error, reason} -> handle_error(reason)\nend\n```\n\n### 4. Use `with` for Happy Path\n```elixir\n# BAD - nested case statements\ncase fetch_user(id) do\n  {:ok, user} ->\n    case validate_user(user) do\n      {:ok, valid_user} ->\n        case save_user(valid_user) do\n          {:ok, saved} -> {:ok, saved}\n          {:error, reason} -> {:error, reason}\n        end\n      {:error, reason} -> {:error, reason}\n    end\n  {:error, reason} -> {:error, reason}\nend\n\n# GOOD - with statement\nwith {:ok, user} <- fetch_user(id),\n     {:ok, valid_user} <- validate_user(user),\n     {:ok, saved} <- save_user(valid_user) do\n  {:ok, saved}\nelse\n  {:error, reason} -> {:error, reason}\nend\n```\n\n### 5. Always Handle All Message Types in GenServer\n```elixir\n# GOOD - handle unknown messages\ndef handle_info(msg, state) do\n  Logger.warning(\"Unknown message: #{inspect(msg)}\")\n  {:noreply, state}\nend\n\ndef handle_call(msg, _from, state) do\n  Logger.warning(\"Unknown call: #{inspect(msg)}\")\n  {:reply, {:error, :unknown_call}, state}\nend\n```\n\n## Important: Strong Recommendations\n\n### 6. Use Structs for Domain Data\n```elixir\n# BAD - plain maps with typo risk\nuser = %{naem: \"Alice\"}  # Typo goes unnoticed\n\n# GOOD - struct with defined keys\ndefmodule User do\n  defstruct [:id, :name, :email, :active]\nend\n\nuser = %User{name: \"Alice\"}  # Compiler warns about unknown keys\n```\n\n### 7. Use Module Attributes for Constants\n```elixir\n# BAD - magic values scattered in code\ndef timeout, do: 5000\n\n# GOOD - module attribute\n@default_timeout 5_000\n\ndef timeout, do: @default_timeout\n```\n\n### 8. Use Guards for Type Validation\n```elixir\n# BAD - runtime type checking\ndef process(value) do\n  if is_integer(value) do\n    # ...\n  end\nend\n\n# GOOD - guards\ndef process(value) when is_integer(value) and value > 0 do\n  # Only matches positive integers\nend\n\ndef process(value) when is_binary(value) do\n  # Only matches strings\nend\n```\n\n### 9. Prefer Keyword Lists for Options\n```elixir\n# GOOD - keyword list for options\ndef fetch(url, opts \\\\ []) do\n  timeout = Keyword.get(opts, :timeout, 5_000)\n  headers = Keyword.get(opts, :headers, [])\n  # ...\nend\n\nfetch(\"http://example.com\", timeout: 10_000, headers: [{\"Accept\", \"application/json\"}])\n```\n\n### 10. Use Stream for Large Collections\n```elixir\n# BAD - loads everything into memory\nFile.read!(\"large.csv\")\n|> String.split(\"\\n\")\n|> Enum.map(&parse_line/1)\n|> Enum.filter(&valid?/1)\n\n# GOOD - lazy streaming\nFile.stream!(\"large.csv\")\n|> Stream.map(&parse_line/1)\n|> Stream.filter(&valid?/1)\n|> Enum.to_list()  # Only materializes at the end\n```\n\n## OTP Patterns\n\n### 11. Use Supervisors for Fault Tolerance\n```elixir\n# GOOD - supervised processes\ndefmodule MyApp.Application do\n  use Application\n\n  def start(_type, _args) do\n    children = [\n      {MyApp.Worker, []},\n      {MyApp.Cache, []}\n    ]\n\n    opts = [strategy: :one_for_one, name: MyApp.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\nend\n```\n\n### 12. Use GenServer for Stateful Processes\n```elixir\ndefmodule Counter do\n  use GenServer\n\n  # Client API\n  def start_link(initial) do\n    GenServer.start_link(__MODULE__, initial, name: __MODULE__)\n  end\n\n  def increment do\n    GenServer.call(__MODULE__, :increment)\n  end\n\n  # Server Callbacks\n  @impl true\n  def init(initial), do: {:ok, initial}\n\n  @impl true\n  def handle_call(:increment, _from, count) do\n    {:reply, count + 1, count + 1}\n  end\nend\n```\n\n### 13. Use Task for One-Off Async Work\n```elixir\n# GOOD - async task with supervision\ntask = Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n  expensive_operation()\nend)\n\nresult = Task.await(task, 30_000)\n```\n\n## Testing\n\n### 14. Use ExUnit Tags for Test Organization\n```elixir\n# GOOD - tagged tests\n@tag :integration\ntest \"connects to database\" do\n  # ...\nend\n\n@tag :slow\ntest \"processes large file\" do\n  # ...\nend\n\n# Run only fast tests: mix test --exclude slow\n```\n\n### 15. Use Mox for Mocking\n```elixir\n# In test_helper.exs\nMox.defmock(MyApp.HTTPClientMock, for: MyApp.HTTPClient)\n\n# In tests\ntest \"handles API error\" do\n  expect(MyApp.HTTPClientMock, :get, fn _url ->\n    {:error, :timeout}\n  end)\n\n  assert {:error, :api_unavailable} = MyApp.fetch_data()\nend\n```\n\n---\n\n**Quick Reference - Copy This Mental Model:**\n- Pattern matching everywhere\n- Pipe operator for transformations\n- Tagged tuples `{:ok, value}` / `{:error, reason}`\n- `with` for happy path\n- Structs for domain data\n- Guards for type validation\n- Stream for large collections\n- Supervisors for fault tolerance\n- GenServer for state\n- Task for async work\n"}, {"path": "patterns/idioms.md", "category": "patterns", "name": "patterns/idioms", "content": "# Elixir Idioms\n\n## Prefer pattern matching\n\nUse pattern matching in function heads and case statements.\n\n## Keep functions pure\n\nAvoid side effects in core logic.\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# Elixir Formatters\n\nUse the built-in formatter.\n\nSee: https://hexdocs.pm/mix/Mix.Tasks.Format.html\n"}, {"path": "stdlib/overview.md", "category": "stdlib", "name": "stdlib/overview", "content": "Search documentation of ElixirDefaultDefaultIn-browser searchSettings\n\n# API Reference Elixir v#1.19.4\n\n[View Source](https://github.com/elixir-lang/elixir)\n\n## Modules\n\n[Access](Access.html)\n\nKey-based access to data structures.\n\n[Agent](Agent.html)\n\nAgents are a simple abstraction around state.\n\n[Application](Application.html)\n\nA module for working with applications and defining application callbacks.\n\n[ArgumentError](ArgumentError.html)\n\nAn exception raised when an argument to a function is invalid.\n\n[ArithmeticError](ArithmeticError.html)\n\nAn exception raised on invalid arithmetic operations.\n\n[Atom](Atom.html)\n\nAtoms are constants whose values are their own name.\n\n[BadArityError](BadArityError.html)\n\nAn exception raised when a function is called with the wrong number of arguments.\n\n[BadBooleanError](BadBooleanError.html)\n\nAn exception raised when a boolean is expected, but something else was given.\n\n[BadFunctionError](BadFunctionError.html)\n\nAn exception raised when a function is expected, but something else was given.\n\n[BadMapError](BadMapError.html)\n\nAn exception raised when a map is expected, but something else was given.\n\n[BadStructError](BadStructError.html)deprecated[Base](Base.html)\n\nThis module provides data encoding and decoding functions according to RFC 4648.\n\n[Behaviour](Behaviour.html)deprecated\n\nMechanism for handling behaviours.\n\n[Bitwise](Bitwise.html)\n\nA set of functions that perform calculations on bits.\n\n[Calendar](Calendar.html)\n\nThis module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir.\n\n[Calendar.ISO](Calendar.ISO.html)\n\nThe default calendar implementation, a Gregorian calendar following ISO 8601.\n\n[Calendar.TimeZoneDatabase](Calendar.TimeZoneDatabase.html)\n\nThis module defines a behaviour for providing time zone data.\n\n[Calendar.UTCOnlyTimeZoneDatabase](Calendar.UTCOnlyTimeZoneDatabase.html)\n\nBuilt-in time zone database that works only in the `Etc/UTC` timezone.\n\n[CaseClauseError](CaseClauseError.html)\n\nAn exception raised when a term in a `case/2` expression does not match any of the defined `->` clauses.\n\n[Code](Code.html)\n\nUtilities for managing code compilation, code evaluation, and code loading.\n\n[Code.Fragment](Code.Fragment.html)\n\nThis module provides conveniences for analyzing fragments of textual code and extract available information whenever possible.\n\n[Code.LoadError](Code.LoadError.html)\n\nAn exception raised when a file cannot be loaded.\n\n[Collectable](Collectable.html)\n\nA protocol to traverse data structures.\n\n[CompileError](CompileError.html)\n\nAn exception raised when there's an error when compiling code.\n\n[CondClauseError](CondClauseError.html)\n\nAn exception raised when no clauses in a `cond/1` expression evaluate to a truthy value.\n\n[Config](Config.html)\n\nA simple keyword-based configuration API.\n\n[Config.Provider](Config.Provider.html)\n\nSpecifies a provider API that loads configuration during boot.\n\n[Config.Reader](Config.Reader.html)\n\nAPI for reading config files defined with `Config`.\n\n[Date](Date.html)\n\nA Date struct and functions.\n\n[Date.Range](Date.Range.html)\n\nReturns an inclusive range between dates.\n\n[DateTime](DateTime.html)\n\nA datetime implementation with a time zone.\n\n[Dict](Dict.html)deprecated\n\nGeneric API for dictionaries.\n\n[Duration](Duration.html)\n\nStruct and functions for handling durations.\n\n[DynamicSupervisor](DynamicSupervisor.html)\n\nA supervisor optimized to only start children dynamically.\n\n[Enum](Enum.html)\n\nFunctions for working with collections (known as enumerables).\n\n[Enum.EmptyError](Enum.EmptyError.html)\n\nAn exception that is raised when something expects a non-empty enumerable but finds an empty one.\n\n[Enum.OutOfBoundsError](Enum.OutOfBoundsError.html)\n\nAn exception that is raised when a function expects an enumerable to have a certain size but finds that it is too small.\n\n[Enumerable](Enumerable.html)\n\nEnumerable protocol used by `Enum` and `Stream` modules.\n\n[ErlangError](ErlangError.html)\n\nAn exception raised when invoking an Erlang code that errors with a value not handled by Elixir.\n\n[Exception](Exception.html)\n\nFunctions for dealing with throw/catch/exit and exceptions.\n\n[File](File.html)\n\nThis module contains functions to manipulate files.\n\n[File.CopyError](File.CopyError.html)\n\nAn exception that is raised when copying a file fails.\n\n[File.Error](File.Error.html)\n\nAn exception that is raised when a file operation fails.\n\n[File.LinkError](File.LinkError.html)\n\nAn exception that is raised when linking a file fails.\n\n[File.RenameError](File.RenameError.html)\n\nAn exception that is raised when renaming a file fails.\n\n[File.Stat](File.Stat.html)\n\nA struct that holds file information.\n\n[File.Stream](File.Stream.html)\n\nDefines a `File.Stream` struct returned by `File.stream!/3`.\n\n[Float](Float.html)\n\nFunctions for working with floating-point numbers.\n\n[Function](Function.html)\n\nA set of functions for working with functions.\n\n[FunctionClauseError](FunctionClauseError.html)\n\nAn exception raised when a function call doesn't match any defined clause.\n\n[GenEvent](GenEvent.html)deprecated\n\nAn event manager with event handlers behaviour.\n\n[GenServer](GenServer.html)\n\nA behaviour module for implementing the server of a client-server relation.\n\n[HashDict](HashDict.html)deprecated\n\nTuple-based HashDict implementation.\n\n[HashSet](HashSet.html)deprecated\n\nTuple-based HashSet implementation.\n\n[IO](IO.html)\n\nFunctions handling input/output (IO).\n\n[IO.ANSI](IO.ANSI.html)\n\nFunctionality to render ANSI escape sequences.\n\n[IO.Stream](IO.Stream.html)\n\nDefines an `IO.Stream` struct returned by `IO.stream/2` and `IO.binstream/2`.\n\n[IO.StreamError](IO.StreamError.html)[Inspect](Inspect.html)\n\nThe `Inspect` protocol converts an Elixir data structure into an algebra document.\n\n[Inspect.Algebra](Inspect.Algebra.html)\n\nA set of functions for creating and manipulating algebra documents.\n\n[Inspect.Error](Inspect.Error.html)\n\nRaised when a struct cannot be inspected.\n\n[Inspect.Opts](Inspect.Opts.html)\n\nDefines the options used by the `Inspect` protocol.\n\n[Integer](Integer.html)\n\nFunctions for working with integers.\n\n[JSON](JSON.html)\n\nJSON encoding and decoding.\n\n[JSON.DecodeError](JSON.DecodeError.html)\n\nThe exception raised by `JSON.decode!/1`.\n\n[JSON.Encoder](JSON.Encoder.html)\n\nA protocol for custom JSON encoding of data structures.\n\n[Kernel](Kernel.html)\n\n`Kernel` is Elixir's default environment.\n\n[Kernel.ParallelCompiler](Kernel.ParallelCompiler.html)\n\nA module responsible for compiling and requiring files in parallel.\n\n[Kernel.SpecialForms](Kernel.SpecialForms.html)\n\nSpecial forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.\n\n[Kernel.TypespecError](Kernel.TypespecError.html)\n\nAn exception raised when there's an error in a typespec.\n\n[KeyError](KeyError.html)\n\nAn exception raised when a key is not found in a data structure.\n\n[Keyword](Keyword.html)\n\nA keyword list is a list that consists exclusively of two-element tuples.\n\n[List](List.html)\n\nLinked lists hold zero, one, or more elements in the chosen order.\n\n[List.Chars](List.Chars.html)\n\nThe `List.Chars` protocol is responsible for converting a structure to a charlist (only if applicable).\n\n[Macro](Macro.html)\n\nFunctions for manipulating AST and implementing macros.\n\n[Macro.Env](Macro.Env.html)\n\nA struct that holds compile time environment information.\n\n[Map](Map.html)\n\nMaps are the \"go to\" key-value data structure in Elixir.\n\n[MapSet](MapSet.html)\n\nFunctions that work on sets.\n\n[MatchError](MatchError.html)\n\nAn exception raised when a pattern match (`=/2`) fails.\n\n[MismatchedDelimiterError](MismatchedDelimiterError.html)\n\nAn exception raised when a mismatched delimiter is found when parsing code.\n\n[MissingApplicationsError](MissingApplicationsError.html)\n\nAn exception that is raised when an application depends on one or more missing applications.\n\n[Module](Module.html)\n\nProvides functions to deal with modules during compilation time.\n\n[NaiveDateTime](NaiveDateTime.html)\n\nA NaiveDateTime struct (without a time zone) and functions.\n\n[Node](Node.html)\n\nFunctions related to VM nodes.\n\n[OptionParser](OptionParser.html)\n\nFunctions for parsing command line arguments.\n\n[OptionParser.ParseError](OptionParser.ParseError.html)\n\nAn exception raised when parsing option fails.\n\n[PartitionSupervisor](PartitionSupervisor.html)\n\nA supervisor that starts multiple partitions of the same child.\n\n[Path](Path.html)\n\nThis module provides conveniences for manipulating or retrieving file system paths.\n\n[Port](Port.html)\n\nFunctions for interacting with the external world through ports.\n\n[Process](Process.html)\n\nConveniences for working with processes and the process dictionary.\n\n[Protocol](Protocol.html)\n\nReference and functions for working with protocols.\n\n[Protocol.UndefinedError](Protocol.UndefinedError.html)\n\nAn exception raised when a protocol is not implemented for a given value.\n\n[Range](Range.html)\n\nRanges represent a sequence of zero, one or many, ascending or descending integers with a common difference called step.\n\n[Record](Record.html)\n\nModule to work with, define, and import records.\n\n[Regex](Regex.html)\n\nProvides regular expressions for Elixir.\n\n[Regex.CompileError](Regex.CompileError.html)\n\nAn exception raised when a regular expression could not be compiled.\n\n[Registry](Registry.html)\n\nA local, decentralized and scalable key-value process storage.\n\n[RuntimeError](RuntimeError.html)\n\nAn exception for a generic runtime error.\n\n[Set](Set.html)deprecated\n\nGeneric API for sets.\n\n[Stream](Stream.html)\n\nFunctions for creating and composing streams.\n\n[String](String.html)\n\nStrings in Elixir are UTF-8 encoded binaries.\n\n[String.Chars](String.Chars.html)\n\nThe `String.Chars` protocol is responsible for converting a structure to a binary (only if applicable).\n\n[StringIO](StringIO.html)\n\nControls an IO device process that wraps a string.\n\n[Supervisor](Supervisor.html)\n\nA behaviour module for implementing supervisors.\n\n[Supervisor.Spec](Supervisor.Spec.html)deprecated\n\nOutdated functions for building child specifications.\n\n[SyntaxError](SyntaxError.html)\n\nAn exception raised when there's a syntax error when parsing code.\n\n[System](System.html)\n\nThe `System` module provides functions that interact directly with the VM or the host system.\n\n[System.EnvError](System.EnvError.html)\n\nAn exception raised when a system environment variable is not set.\n\n[SystemLimitError](SystemLimitError.html)\n\nAn exception raised when a system limit has been reached.\n\n[Task](Task.html)\n\nConveniences for spawning and awaiting tasks.\n\n[Task.Supervisor](Task.Supervisor.html)\n\nA task supervisor.\n\n[Time](Time.html)\n\nA Time struct and functions.\n\n[TokenMissingError](TokenMissingError.html)\n\nAn exception raised when a token is missing when parsing code.\n\n[TryClauseError](TryClauseError.html)\n\nAn exception raised when none of the `else` clauses in a `try/1` match.\n\n[Tuple](Tuple.html)\n\nFunctions for working with tuples.\n\n[URI](URI.html)\n\nUtilities for working with URIs.\n\n[URI.Error](URI.Error.html)\n\nAn exception raised when an error occurs when a `URI` is invalid.\n\n[UndefinedFunctionError](UndefinedFunctionError.html)\n\nAn exception raised when a function is invoked that is not defined.\n\n[UnicodeConversionError](UnicodeConversionError.html)\n\nAn exception raised when converting data to or from Unicode.\n\n[Version](Version.html)\n\nFunctions for parsing and matching versions against requirements.\n\n[Version.InvalidRequirementError](Version.InvalidRequirementError.html)\n\nAn exception raised when a version requirement is invalid.\n\n[Version.InvalidVersionError](Version.InvalidVersionError.html)\n\nAn exception raised when a version is invalid.\n\n[Version.Requirement](Version.Requirement.html)\n\nA struct that holds version requirement information.\n\n[WithClauseError](WithClauseError.html)\n\nAn exception raised when a term in a `with/1` expression does not match any of the defined `->` clauses in its `else`.\n\n Search HexDocs [Download ePub version](Elixir.epub)\n\n Built using [ExDoc](https://github.com/elixir-lang/ex_doc) (v0.39.1) for the [Elixir programming language](https://elixir-lang.org)\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# Elixir Syntax Reference\nVersion: unknown\n\nSource: https://hexdocs.pm/elixir/syntax-reference.html\n\n\nSee: https://hexdocs.pm/elixir/syntax-reference.html\n"}, {"path": "linters/credo/overview.md", "category": "linters", "name": "linters/credo/overview", "content": "# Credo\n\nCredo is a static code analysis tool for Elixir focusing on teaching and code consistency.\n\nVersion: 1.7.10\nSource: https://hexdocs.pm/credo/\n\n## Installation\n\nAdd to `mix.exs`:\n\n```elixir\ndefp deps do\n  [{:credo, \"~> 1.7\", only: [:dev, :test], runtime: false}]\nend\n```\n\n## Usage\n\n```bash\n# Run analysis\nmix credo\n\n# Strict mode\nmix credo --strict\n\n# Focus on specific file\nmix credo lib/my_app/module.ex\n\n# Generate config\nmix credo gen.config\n```\n\n## Configuration\n\nCreate `.credo.exs`:\n\n```elixir\n%{\n  configs: [\n    %{\n      name: \"default\",\n      files: %{\n        included: [\"lib/\", \"src/\", \"test/\"],\n        excluded: [~r\"/_build/\", ~r\"/deps/\"]\n      },\n      checks: %{\n        enabled: [\n          {Credo.Check.Consistency.TabsOrSpaces, []},\n          {Credo.Check.Readability.ModuleDoc, []},\n          {Credo.Check.Refactor.Nesting, [max_nesting: 2]}\n        ],\n        disabled: [\n          {Credo.Check.Design.TagTODO, []}\n        ]\n      }\n    }\n  ]\n}\n```\n\n## Check Categories\n\n### Consistency\nEnsures consistent coding style across the codebase.\n\n### Design\nChecks for software design issues.\n\n### Readability\nImproves code readability.\n\n### Refactor\nIdentifies refactoring opportunities.\n\n### Warning\nCatches potential bugs and issues.\n\n## Priority Levels\n\n- `:higher` - Critical issues\n- `:high` - Important issues\n- `:normal` - Standard checks\n- `:low` - Minor suggestions\n- `:ignore` - Disabled\n\n## Inline Configuration\n\n```elixir\n# Disable for line\n# credo:disable-for-this-file\n# credo:disable-for-next-line\n# credo:disable-for-lines:3\n\ndefmodule MyModule do\n  # credo:disable-for-this-file Credo.Check.Readability.ModuleDoc\nend\n```\n"}, {"path": "linters/credo/checks.md", "category": "linters", "name": "linters/credo/checks", "content": "# Credo Checks Reference\n\nComplete list of Credo checks for Elixir.\n\nSource: https://hexdocs.pm/credo/\n\n## Consistency Checks\n\n### Credo.Check.Consistency.ExceptionNames\nEnsures consistent exception naming (Error vs Exception suffix).\n\n### Credo.Check.Consistency.LineEndings\nEnsures consistent line endings (unix vs windows).\n\n### Credo.Check.Consistency.MultiAliasImportRequireUse\nEnsures consistent multi-alias syntax.\n\n### Credo.Check.Consistency.ParameterPatternMatching\nEnsures consistent parameter pattern matching style.\n\n### Credo.Check.Consistency.SpaceAroundOperators\nEnsures consistent spacing around operators.\n\n### Credo.Check.Consistency.SpaceInParentheses\nEnsures consistent spacing in parentheses.\n\n### Credo.Check.Consistency.TabsOrSpaces\nEnsures consistent use of tabs or spaces.\n\n### Credo.Check.Consistency.UnusedVariableNames\nEnsures consistent unused variable naming.\n\n## Design Checks\n\n### Credo.Check.Design.AliasUsage\nSuggests using aliases for frequently used modules.\n\n### Credo.Check.Design.DuplicatedCode\nDetects duplicated code blocks.\n\n### Credo.Check.Design.SkipTestWithoutComment\nEnsures skipped tests have explanatory comments.\n\n### Credo.Check.Design.TagFIXME\nWarns about FIXME tags in comments.\n\n### Credo.Check.Design.TagTODO\nWarns about TODO tags in comments.\n\n## Readability Checks\n\n### Credo.Check.Readability.AliasAs\nSuggests using :as option for clearer aliases.\n\n### Credo.Check.Readability.AliasOrder\nEnsures aliases are alphabetically ordered.\n\n### Credo.Check.Readability.BlockPipe\nDiscourages piping into blocks.\n\n### Credo.Check.Readability.FunctionNames\nEnsures function names follow conventions.\n\n### Credo.Check.Readability.ImplTrue\nWarns about @impl true without specifying behavior.\n\n### Credo.Check.Readability.LargeNumbers\nSuggests underscores in large numbers.\n\n### Credo.Check.Readability.MaxLineLength\nEnforces maximum line length.\n\n### Credo.Check.Readability.ModuleAttributeNames\nEnsures module attribute naming conventions.\n\n### Credo.Check.Readability.ModuleDoc\nEnsures modules have documentation.\n\n### Credo.Check.Readability.ModuleNames\nEnsures module naming conventions.\n\n### Credo.Check.Readability.MultiAlias\nSuggests multi-alias syntax.\n\n### Credo.Check.Readability.NestedFunctionCalls\nDiscourages deeply nested function calls.\n\n### Credo.Check.Readability.OneArityFunctionInPipe\nEnsures one-arity functions in pipes have parentheses.\n\n### Credo.Check.Readability.OnePipePerLine\nEnsures one pipe per line.\n\n### Credo.Check.Readability.ParenthesesInCondition\nDiscourages parentheses in if/unless conditions.\n\n### Credo.Check.Readability.ParenthesesOnZeroArityDefs\nEnsures consistent parentheses on zero-arity functions.\n\n### Credo.Check.Readability.PipeIntoAnonymousFunctions\nDiscourages piping into anonymous functions.\n\n### Credo.Check.Readability.PredicateFunctionNames\nEnsures predicate functions end with ?.\n\n### Credo.Check.Readability.PreferImplicitTry\nSuggests implicit try in function bodies.\n\n### Credo.Check.Readability.PreferUnquotedAtoms\nPrefers unquoted atoms when possible.\n\n### Credo.Check.Readability.RedundantBlankLines\nRemoves redundant blank lines.\n\n### Credo.Check.Readability.Semicolons\nDiscourages semicolons.\n\n### Credo.Check.Readability.SeparateAliasRequire\nSuggests separating alias and require.\n\n### Credo.Check.Readability.SingleFunctionToBlockPipe\nDiscourages single function to block pipes.\n\n### Credo.Check.Readability.SinglePipe\nDiscourages single pipe usage.\n\n### Credo.Check.Readability.SpaceAfterCommas\nEnsures space after commas.\n\n### Credo.Check.Readability.Specs\nEncourages typespecs for public functions.\n\n### Credo.Check.Readability.StrictModuleLayout\nEnforces strict module layout ordering.\n\n### Credo.Check.Readability.StringSigils\nSuggests sigils for strings with quotes.\n\n### Credo.Check.Readability.TrailingBlankLine\nEnsures trailing blank line.\n\n### Credo.Check.Readability.TrailingWhiteSpace\nRemoves trailing whitespace.\n\n### Credo.Check.Readability.UnnecessaryAliasExpansion\nRemoves unnecessary alias expansion.\n\n### Credo.Check.Readability.VariableNames\nEnsures variable naming conventions.\n\n### Credo.Check.Readability.WithCustomTaggedTuple\nSuggests custom tagged tuples over ok/error.\n\n### Credo.Check.Readability.WithSingleClause\nDiscourages with with single clause.\n\n## Refactor Checks\n\n### Credo.Check.Refactor.ABCSize\nChecks ABC (Assignment, Branch, Condition) complexity.\n\n### Credo.Check.Refactor.AppendSingleItem\nSuggests using ++ [item] alternatives.\n\n### Credo.Check.Refactor.Apply\nSuggests using apply for dynamic function calls.\n\n### Credo.Check.Refactor.CaseTrivialMatches\nSimplifies trivial case matches.\n\n### Credo.Check.Refactor.CondStatements\nSuggests cond over nested if statements.\n\n### Credo.Check.Refactor.CyclomaticComplexity\nChecks cyclomatic complexity.\n\n### Credo.Check.Refactor.DoubleBooleanNegation\nRemoves double boolean negation.\n\n### Credo.Check.Refactor.FilterCount\nSuggests Enum.count/2 over filter then count.\n\n### Credo.Check.Refactor.FilterFilter\nCombines multiple filters.\n\n### Credo.Check.Refactor.FilterReject\nSimplifies filter/reject combinations.\n\n### Credo.Check.Refactor.FunctionArity\nChecks function arity limits.\n\n### Credo.Check.Refactor.IoPuts\nWarns about IO.puts for debugging.\n\n### Credo.Check.Refactor.LongQuoteBlocks\nWarns about long quote blocks.\n\n### Credo.Check.Refactor.MapInto\nSuggests Map.new over Enum.into.\n\n### Credo.Check.Refactor.MapJoin\nSuggests Enum.map_join.\n\n### Credo.Check.Refactor.MapMap\nCombines multiple maps.\n\n### Credo.Check.Refactor.MatchInCondition\nAvoids match in condition.\n\n### Credo.Check.Refactor.ModuleDependencies\nChecks module dependencies.\n\n### Credo.Check.Refactor.NegatedConditionsInUnless\nSimplifies negated unless conditions.\n\n### Credo.Check.Refactor.NegatedConditionsWithElse\nSimplifies negated if/else.\n\n### Credo.Check.Refactor.NegatedIsNil\nSuggests is_nil alternatives.\n\n### Credo.Check.Refactor.Nesting\nChecks nesting depth.\n\n### Credo.Check.Refactor.PassAsyncInTestCases\nEnsures async: true in test cases.\n\n### Credo.Check.Refactor.PipeChainStart\nEnsures proper pipe chain start.\n\n### Credo.Check.Refactor.RedundantWithClauseResult\nRemoves redundant with clause results.\n\n### Credo.Check.Refactor.RejectFilter\nSimplifies reject/filter combinations.\n\n### Credo.Check.Refactor.RejectReject\nCombines multiple rejects.\n\n### Credo.Check.Refactor.UnlessWithElse\nDiscourages unless with else.\n\n### Credo.Check.Refactor.UtcNowTruncate\nSuggests DateTime.utc_now with truncate option.\n\n### Credo.Check.Refactor.VariableRebinding\nWarns about variable rebinding.\n\n### Credo.Check.Refactor.WithClauses\nSimplifies with clauses.\n\n## Warning Checks\n\n### Credo.Check.Warning.ApplicationConfigInModuleAttribute\nWarns about config in module attributes.\n\n### Credo.Check.Warning.BoolOperationOnSameValues\nDetects boolean operations on same values.\n\n### Credo.Check.Warning.Dbg\nWarns about dbg calls.\n\n### Credo.Check.Warning.ExpensiveEmptyEnumCheck\nSuggests efficient empty enum checks.\n\n### Credo.Check.Warning.ForbiddenModule\nWarns about forbidden module usage.\n\n### Credo.Check.Warning.IExPry\nWarns about IEx.pry calls.\n\n### Credo.Check.Warning.IoInspect\nWarns about IO.inspect calls.\n\n### Credo.Check.Warning.LazyLogging\nSuggests lazy logging.\n\n### Credo.Check.Warning.LeakyEnvironment\nWarns about leaky environment.\n\n### Credo.Check.Warning.MapGetUnsafePass\nWarns about unsafe Map.get patterns.\n\n### Credo.Check.Warning.MissedMetadataKeyInLoggerConfig\nChecks logger config metadata.\n\n### Credo.Check.Warning.MixEnv\nWarns about Mix.env at compile time.\n\n### Credo.Check.Warning.OperationOnSameValues\nDetects operations on same values.\n\n### Credo.Check.Warning.OperationWithConstantResult\nDetects operations with constant results.\n\n### Credo.Check.Warning.RaiseInsideRescue\nWarns about raise inside rescue.\n\n### Credo.Check.Warning.SpecWithStruct\nWarns about specs with structs.\n\n### Credo.Check.Warning.UnsafeExec\nWarns about unsafe command execution.\n\n### Credo.Check.Warning.UnsafeToAtom\nWarns about unsafe String.to_atom.\n\n### Credo.Check.Warning.UnusedEnumOperation\nDetects unused enum operations.\n\n### Credo.Check.Warning.UnusedFileOperation\nDetects unused file operations.\n\n### Credo.Check.Warning.UnusedKeywordOperation\nDetects unused keyword operations.\n\n### Credo.Check.Warning.UnusedListOperation\nDetects unused list operations.\n\n### Credo.Check.Warning.UnusedPathOperation\nDetects unused path operations.\n\n### Credo.Check.Warning.UnusedRegexOperation\nDetects unused regex operations.\n\n### Credo.Check.Warning.UnusedStringOperation\nDetects unused string operations.\n\n### Credo.Check.Warning.UnusedTupleOperation\nDetects unused tuple operations.\n\n### Credo.Check.Warning.WrongTestFileExtension\nEnsures correct test file extensions.\n"}]}
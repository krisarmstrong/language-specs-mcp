{"language": "cpp", "generatedAt": "2026-01-05T15:15:54.730694+00:00", "entries": [{"path": "compilers.md", "category": "spec", "name": "compilers", "content": "# Compilers\n\nGCC: unknown\n\nSource: https://gcc.gnu.org/\n\nClang: unknown\n\nSource: https://clang.llvm.org/\n\n"}, {"path": "patterns/idioms.md", "category": "patterns", "name": "patterns/idioms", "content": "# Modern C++ Idiomatic Patterns (C++17/20/23)\n\n## Memory Management\n\n### Use smart pointers, not raw new/delete\n\n```cpp\n// BAD\nWidget* w = new Widget();\n// ... forget to delete\n\n// GOOD\nauto w = std::make_unique<Widget>();\n// automatically deleted\n\n// Shared ownership\nauto shared = std::make_shared<Widget>();\n```\n\n### Rule of Zero/Five\n\n```cpp\n// Rule of Zero: Use RAII wrappers, no manual resource management\nclass Good {\n    std::string name;\n    std::vector<int> data;\n    // No destructor, copy/move ops needed\n};\n\n// Rule of Five: If you define one, define all\nclass Manual {\n    int* data;\npublic:\n    ~Manual();\n    Manual(const Manual&);\n    Manual& operator=(const Manual&);\n    Manual(Manual&&) noexcept;\n    Manual& operator=(Manual&&) noexcept;\n};\n```\n\n## Use auto (but not everywhere)\n\n```cpp\n// GOOD - obvious type\nauto it = container.begin();\nauto ptr = std::make_unique<Widget>();\n\n// GOOD - complex type\nauto lambda = [](int x) { return x * 2; };\n\n// BAD - hides important type info\nauto config = getConfig();  // What type is this?\n\n// BETTER\nConfig config = getConfig();\n```\n\n## Range-based for\n\n```cpp\n// BAD\nfor (size_t i = 0; i < vec.size(); ++i) {\n    process(vec[i]);\n}\n\n// GOOD\nfor (const auto& item : vec) {\n    process(item);\n}\n\n// Modify in place\nfor (auto& item : vec) {\n    item.update();\n}\n```\n\n## Use constexpr\n\n```cpp\n// Compile-time computation\nconstexpr int factorial(int n) {\n    return n <= 1 ? 1 : n * factorial(n - 1);\n}\n\nconstexpr int fact5 = factorial(5);  // computed at compile time\n```\n\n## std::optional for nullable values\n\n```cpp\n// BAD\nWidget* find(int id);  // nullptr if not found\n\n// GOOD\nstd::optional<Widget> find(int id);\n\n// Usage\nif (auto w = find(42)) {\n    w->doSomething();\n}\n```\n\n## std::variant for type-safe unions\n\n```cpp\nusing Result = std::variant<Success, Error>;\n\nResult doSomething() {\n    if (failed) {\n        return Error{\"something went wrong\"};\n    }\n    return Success{data};\n}\n\n// Visit pattern\nstd::visit([](auto&& arg) {\n    using T = std::decay_t<decltype(arg)>;\n    if constexpr (std::is_same_v<T, Success>) {\n        handle(arg.data);\n    } else {\n        log(arg.message);\n    }\n}, result);\n```\n\n## Structured bindings\n\n```cpp\nstd::map<std::string, int> map;\n\n// BAD\nfor (const auto& pair : map) {\n    std::cout << pair.first << \": \" << pair.second;\n}\n\n// GOOD\nfor (const auto& [key, value] : map) {\n    std::cout << key << \": \" << value;\n}\n```\n\n## Use [[nodiscard]]\n\n```cpp\n[[nodiscard]] Error doSomething();\n\ndoSomething();  // Warning: ignoring return value\n```\n\n## String views\n\n```cpp\n// BAD - unnecessary copy\nvoid process(const std::string& s);\n\n// GOOD - no copy for literals or string views\nvoid process(std::string_view s);\n```\n\n## Concepts (C++20)\n\n```cpp\ntemplate<typename T>\nconcept Numeric = std::integral<T> || std::floating_point<T>;\n\ntemplate<Numeric T>\nT add(T a, T b) {\n    return a + b;\n}\n```\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# C++ Formatters\n\n## clang-format\n\nSee: https://clang.llvm.org/docs/ClangFormat.html\n"}, {"path": "formatters/clang-format.md", "category": "formatters", "name": "formatters/clang-format", "content": "# clang-format Options\nVersion: unknown\n\nSource: https://clang.llvm.org/docs/ClangFormatStyleOptions.html\n\n\nSee: https://clang.llvm.org/docs/ClangFormatStyleOptions.html\n"}, {"path": "stdlib/overview.md", "category": "stdlib", "name": "stdlib/overview", "content": "# Modern C++ Standard Library\n\n## Core Headers\n\n| Header | Purpose |\n|--------|---------|\n| `<memory>` | Smart pointers |\n| `<string>` | String class |\n| `<string_view>` | Non-owning string reference |\n| `<vector>` | Dynamic array |\n| `<array>` | Fixed-size array |\n| `<map>` / `<unordered_map>` | Associative containers |\n| `<optional>` | Nullable values |\n| `<variant>` | Type-safe union |\n| `<expected>` | Result type (C++23) |\n| `<span>` | Non-owning view |\n| `<ranges>` | Range algorithms |\n| `<format>` | Type-safe formatting |\n| `<filesystem>` | File operations |\n| `<thread>` | Threading |\n| `<mutex>` | Synchronization |\n| `<chrono>` | Time utilities |\n\n## Smart Pointers\n\n```cpp\n#include <memory>\n\n// Unique ownership\nstd::unique_ptr<T> ptr = std::make_unique<T>(args...);\n\n// Shared ownership\nstd::shared_ptr<T> ptr = std::make_shared<T>(args...);\n\n// Non-owning observer\nstd::weak_ptr<T> weak = shared;\n```\n\n## Containers\n\n```cpp\nstd::vector<T> vec;           // Dynamic array\nstd::array<T, N> arr;         // Fixed array\nstd::map<K, V> map;           // Ordered map\nstd::unordered_map<K, V> um;  // Hash map\nstd::set<T> set;              // Ordered set\nstd::deque<T> dq;             // Double-ended queue\n```\n\n## Algorithms\n\n```cpp\n#include <algorithm>\n#include <ranges>\n\n// Classic\nstd::sort(vec.begin(), vec.end());\nauto it = std::find(vec.begin(), vec.end(), value);\n\n// Ranges (C++20)\nstd::ranges::sort(vec);\nauto it = std::ranges::find(vec, value);\n\n// Projections\nstd::ranges::sort(people, {}, &Person::name);\n```\n"}, {"path": "stdlib/headers/index.md", "category": "stdlib", "name": "stdlib/headers/index", "content": "# C++ Standard Library Headers\n\nSee: https://en.cppreference.com/w/cpp/header\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# C++ Language Specification Summary\nVersion: c++23\n\nSource: https://en.cppreference.com/w/cpp\n\n\nBased on C++23 (ISO/IEC 14882:2024)\n\n## Keywords (C++23)\n\n```cpp\nalignas         alignof         and             and_eq\nasm             auto            bitand          bitor\nbool            break           case            catch\nchar            char8_t         char16_t        char32_t\nclass           compl           concept         const\nconsteval       constexpr       constinit       const_cast\ncontinue        co_await        co_return       co_yield\ndecltype        default         delete          do\ndouble          dynamic_cast    else            enum\nexplicit        export          extern          false\nfloat           for             friend          goto\nif              inline          int             long\nmutable         namespace       new             noexcept\nnot             not_eq          nullptr         operator\nor              or_eq           private         protected\npublic          register        reinterpret_cast requires\nreturn          short           signed          sizeof\nstatic          static_assert   static_cast     struct\nswitch          template        this            thread_local\nthrow           true            try             typedef\ntypeid          typename        union           unsigned\nusing           virtual         void            volatile\nwchar_t         while           xor             xor_eq\n```\n\n## Types\n\n### Fundamental Types\n\n```cpp\n// Boolean\nbool                    // true or false\n\n// Characters\nchar                    // at least 8 bits\nwchar_t                 // wide character\nchar8_t                 // UTF-8 (C++20)\nchar16_t                // UTF-16\nchar32_t                // UTF-32\n\n// Integers\nshort                   // at least 16 bits\nint                     // at least 16 bits\nlong                    // at least 32 bits\nlong long               // at least 64 bits\n\n// Floating point\nfloat                   // single precision\ndouble                  // double precision\nlong double             // extended precision\n\n// Void\nvoid                    // no type/value\n\n// Null pointer\nstd::nullptr_t          // type of nullptr\n```\n\n### Fixed-Width Types\n\n```cpp\n#include <cstdint>\n\nint8_t      int16_t     int32_t     int64_t\nuint8_t     uint16_t    uint32_t    uint64_t\nintptr_t    uintptr_t\nsize_t      ptrdiff_t\n```\n\n### Type Aliases\n\n```cpp\nusing IntPtr = int*;\nusing Callback = void(*)(int);\nusing StringVector = std::vector<std::string>;\n\n// Template alias\ntemplate<typename T>\nusing Vec = std::vector<T>;\n```\n\n## Auto and Decltype\n\n```cpp\n// Type inference\nauto x = 42;            // int\nauto y = 3.14;          // double\nauto z = \"hello\";       // const char*\nauto v = std::vector{1, 2, 3};  // std::vector<int>\n\n// Decltype\nint x = 0;\ndecltype(x) y = 1;      // int\ndecltype(auto) z = x;   // int (preserves value category)\n\n// Trailing return type\nauto add(int a, int b) -> int {\n    return a + b;\n}\n\n// C++14: return type deduction\nauto add(int a, int b) {\n    return a + b;\n}\n```\n\n## Classes\n\n### Basic Class\n\n```cpp\nclass Widget {\npublic:\n    Widget();                           // default constructor\n    Widget(int value);                  // parameterized constructor\n    Widget(const Widget& other);        // copy constructor\n    Widget(Widget&& other) noexcept;    // move constructor\n    ~Widget();                          // destructor\n    \n    Widget& operator=(const Widget& other);     // copy assignment\n    Widget& operator=(Widget&& other) noexcept; // move assignment\n    \n    int getValue() const;\n    void setValue(int value);\n    \nprivate:\n    int value_;\n    std::string name_;\n};\n```\n\n### Rule of Zero/Five\n\n```cpp\n// Rule of Zero: Use RAII, no manual resource management\nclass Good {\n    std::string name;\n    std::vector<int> data;\n    std::unique_ptr<Resource> resource;\n    // No destructor, copy/move ops needed\n};\n\n// Rule of Five: If you define one, define all\nclass Manual {\n    int* data;\npublic:\n    Manual() : data(new int[100]) {}\n    ~Manual() { delete[] data; }\n    Manual(const Manual& other);\n    Manual& operator=(const Manual& other);\n    Manual(Manual&& other) noexcept;\n    Manual& operator=(Manual&& other) noexcept;\n};\n```\n\n### Inheritance\n\n```cpp\nclass Base {\npublic:\n    virtual void method() = 0;      // pure virtual\n    virtual void other() {}         // virtual with default\n    void concrete() {}              // non-virtual\n    virtual ~Base() = default;      // virtual destructor\n};\n\nclass Derived : public Base {\npublic:\n    void method() override;         // override\n    void other() final;             // can't be overridden further\n};\n```\n\n## Templates\n\n### Function Templates\n\n```cpp\ntemplate<typename T>\nT max(T a, T b) {\n    return a > b ? a : b;\n}\n\n// With concepts (C++20)\ntemplate<typename T>\nrequires std::integral<T>\nT gcd(T a, T b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\n// Abbreviated function template (C++20)\nauto add(auto a, auto b) {\n    return a + b;\n}\n```\n\n### Class Templates\n\n```cpp\ntemplate<typename T, size_t N>\nclass Array {\n    T data[N];\npublic:\n    T& operator[](size_t i) { return data[i]; }\n    constexpr size_t size() const { return N; }\n};\n\n// Deduction guides (C++17)\ntemplate<typename T, typename... Args>\nArray(T, Args...) -> Array<T, 1 + sizeof...(Args)>;\n```\n\n### Concepts (C++20)\n\n```cpp\ntemplate<typename T>\nconcept Numeric = std::integral<T> || std::floating_point<T>;\n\ntemplate<typename T>\nconcept Printable = requires(T t) {\n    { std::cout << t } -> std::same_as<std::ostream&>;\n};\n\ntemplate<Numeric T>\nT square(T x) {\n    return x * x;\n}\n```\n\n### Variadic Templates\n\n```cpp\ntemplate<typename... Args>\nvoid print(Args... args) {\n    (std::cout << ... << args) << '\\n';  // fold expression\n}\n\n// Pack expansion\ntemplate<typename... Ts>\nauto sum(Ts... args) {\n    return (args + ...);  // unary right fold\n}\n```\n\n## Smart Pointers\n\n```cpp\n#include <memory>\n\n// Unique ownership\nstd::unique_ptr<Widget> p1 = std::make_unique<Widget>();\nauto p2 = std::make_unique<Widget[]>(10);  // array\n\n// Shared ownership\nstd::shared_ptr<Widget> p3 = std::make_shared<Widget>();\nstd::shared_ptr<Widget> p4 = p3;  // both own\n\n// Weak reference (doesn't extend lifetime)\nstd::weak_ptr<Widget> w = p3;\nif (auto p = w.lock()) {\n    // use p\n}\n```\n\n## Move Semantics\n\n```cpp\nclass Buffer {\n    std::unique_ptr<char[]> data_;\n    size_t size_;\n    \npublic:\n    // Move constructor\n    Buffer(Buffer&& other) noexcept\n        : data_(std::move(other.data_))\n        , size_(std::exchange(other.size_, 0))\n    {}\n    \n    // Move assignment\n    Buffer& operator=(Buffer&& other) noexcept {\n        data_ = std::move(other.data_);\n        size_ = std::exchange(other.size_, 0);\n        return *this;\n    }\n};\n\n// Perfect forwarding\ntemplate<typename T, typename... Args>\nstd::unique_ptr<T> make(Args&&... args) {\n    return std::make_unique<T>(std::forward<Args>(args)...);\n}\n```\n\n## Lambda Expressions\n\n```cpp\n// Basic lambda\nauto add = [](int a, int b) { return a + b; };\n\n// With capture\nint x = 10;\nauto addX = [x](int a) { return a + x; };      // capture by value\nauto addX = [&x](int a) { return a + x; };     // capture by reference\nauto addX = [=](int a) { return a + x; };      // capture all by value\nauto addX = [&](int a) { return a + x; };      // capture all by reference\n\n// Mutable lambda\nauto counter = [n = 0]() mutable { return ++n; };\n\n// Generic lambda (C++14)\nauto add = [](auto a, auto b) { return a + b; };\n\n// Template lambda (C++20)\nauto add = []<typename T>(T a, T b) { return a + b; };\n```\n\n## Ranges (C++20)\n\n```cpp\n#include <ranges>\n\nstd::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n// Views\nauto even = v | std::views::filter([](int n) { return n % 2 == 0; });\nauto squared = v | std::views::transform([](int n) { return n * n; });\n\n// Chained\nauto result = v \n    | std::views::filter([](int n) { return n % 2 == 0; })\n    | std::views::transform([](int n) { return n * n; })\n    | std::views::take(3);\n\n// Range algorithms\nstd::ranges::sort(v);\nauto it = std::ranges::find(v, 5);\n```\n\n## Coroutines (C++20)\n\n```cpp\n#include <coroutine>\n#include <generator>  // C++23\n\n// Generator\nstd::generator<int> range(int start, int end) {\n    for (int i = start; i < end; ++i) {\n        co_yield i;\n    }\n}\n\n// Usage\nfor (int i : range(0, 10)) {\n    std::cout << i << '\\n';\n}\n```\n\n## Modules (C++20)\n\n```cpp\n// math.ixx (module interface)\nexport module math;\n\nexport int add(int a, int b) {\n    return a + b;\n}\n\n// main.cpp\nimport math;\n\nint main() {\n    return add(1, 2);\n}\n```\n\n## Structured Bindings (C++17)\n\n```cpp\n// With arrays\nint arr[] = {1, 2, 3};\nauto [a, b, c] = arr;\n\n// With structs\nstruct Point { int x, y; };\nPoint p{10, 20};\nauto [x, y] = p;\n\n// With maps\nstd::map<std::string, int> m;\nfor (const auto& [key, value] : m) {\n    std::cout << key << \": \" << value << '\\n';\n}\n```\n\n## std::optional, variant, expected\n\n```cpp\n// Optional (C++17)\nstd::optional<int> find(const std::vector<int>& v, int target) {\n    auto it = std::find(v.begin(), v.end(), target);\n    if (it != v.end()) return *it;\n    return std::nullopt;\n}\n\n// Variant (C++17)\nstd::variant<int, std::string, double> v = \"hello\";\nstd::visit([](auto&& arg) { std::cout << arg; }, v);\n\n// Expected (C++23)\nstd::expected<int, std::string> divide(int a, int b) {\n    if (b == 0) return std::unexpected(\"division by zero\");\n    return a / b;\n}\n```\n\n## Constexpr and Consteval\n\n```cpp\n// Constexpr: may be evaluated at compile time\nconstexpr int factorial(int n) {\n    return n <= 1 ? 1 : n * factorial(n - 1);\n}\n\nconstexpr int f5 = factorial(5);  // compile-time\nint runtime_n = get_value();\nint fn = factorial(runtime_n);    // runtime OK too\n\n// Consteval (C++20): must be evaluated at compile time\nconsteval int square(int n) {\n    return n * n;\n}\n\nconstexpr int s = square(5);   // OK: compile-time\nint x = 5;\nint y = square(x);             // ERROR: not compile-time\n\n// Constinit (C++20): must be constant initialized\nconstinit int global = 42;     // OK\nconstinit int bad = get();     // ERROR if get() not constexpr\n```\n\n## Attributes\n\n```cpp\n[[nodiscard]] int compute();\n[[nodiscard(\"reason\")]] int compute2();  // C++20\n\n[[deprecated]] void old_func();\n[[deprecated(\"use new_func\")]] void old_func2();\n\n[[maybe_unused]] void callback(int x);\n\n[[noreturn]] void terminate();\n\n[[likely]] if (condition) { }   // C++20\n[[unlikely]] if (error) { }     // C++20\n\n[[assume(x > 0)]]  // C++23\n```\n"}, {"path": "linters/cppcheck/overview.md", "category": "linters", "name": "linters/cppcheck/overview", "content": "# cppcheck Manual\nVersion: unknown\n\nSource: https://cppcheck.sourceforge.io/manual.html\n\n\nSee: https://cppcheck.sourceforge.io/manual.html\n"}, {"path": "linters/cppcheck/errors.md", "category": "linters", "name": "linters/cppcheck/errors", "content": "# cppcheck Error Checks\n\nCritical bugs that will cause crashes or incorrect behavior.\n\n## nullPointer\n\nNull pointer dereference.\n\n```cpp\n// BAD\nint* p = nullptr;\n*p = 5;  // crash\n\nint* getData();\nint x = *getData();  // crash if getData returns null\n\n// GOOD\nint* p = getData();\nif (p != nullptr) {\n    *p = 5;\n}\n```\n\n## nullPointerArithmetic\n\nArithmetic on null pointer.\n\n```cpp\n// BAD\nint* p = nullptr;\nint* q = p + 1;  // undefined behavior\n\n// GOOD\nint arr[10];\nint* p = arr;\nint* q = p + 1;  // OK\n```\n\n## nullPointerRedundantCheck\n\nRedundant null check after dereference.\n\n```cpp\n// BAD - already dereferenced, check is too late\nint x = *p;\nif (p != nullptr) {  // redundant - would have crashed above\n    use(x);\n}\n\n// GOOD - check before dereference\nif (p != nullptr) {\n    int x = *p;\n    use(x);\n}\n```\n\n## uninitvar\n\nUse of uninitialized variable.\n\n```cpp\n// BAD\nint x;\nprintf(\"%d\", x);  // undefined value\n\nint* p;\n*p = 5;  // undefined behavior\n\n// GOOD\nint x = 0;\nprintf(\"%d\", x);\n\nint* p = nullptr;  // or point to valid memory\n```\n\n## uninitMemberVar\n\nUninitialized member variable.\n\n```cpp\n// BAD\nclass Foo {\n    int x;  // never initialized\npublic:\n    Foo() { }  // x is garbage\n};\n\n// GOOD\nclass Foo {\n    int x = 0;\npublic:\n    Foo() = default;\n};\n\n// Or\nclass Foo {\n    int x;\npublic:\n    Foo() : x(0) { }\n};\n```\n\n## uninitStructMember\n\nUninitialized struct member.\n\n```cpp\n// BAD\nstruct Point { int x, y; };\nPoint p;\nprintf(\"%d\", p.x);  // garbage\n\n// GOOD\nPoint p = {0, 0};\nPoint p = {};  // zero-initialized\n```\n\n## memleak\n\nMemory leak - allocated memory not freed.\n\n```cpp\n// BAD\nvoid foo() {\n    char* p = malloc(100);\n    if (error) return;  // leak!\n    free(p);\n}\n\n// GOOD\nvoid foo() {\n    char* p = malloc(100);\n    if (error) {\n        free(p);\n        return;\n    }\n    free(p);\n}\n\n// BETTER - use RAII in C++\nvoid foo() {\n    auto p = std::make_unique<char[]>(100);\n    if (error) return;  // automatically freed\n}\n```\n\n## resourceLeak\n\nResource leak - file handle, socket, etc not closed.\n\n```cpp\n// BAD\nvoid foo() {\n    FILE* f = fopen(\"file\", \"r\");\n    if (error) return;  // leak!\n    fclose(f);\n}\n\n// GOOD\nvoid foo() {\n    FILE* f = fopen(\"file\", \"r\");\n    if (f == nullptr) return;\n    if (error) {\n        fclose(f);\n        return;\n    }\n    fclose(f);\n}\n```\n\n## deallocuse\n\nUse after free.\n\n```cpp\n// BAD\nchar* p = malloc(100);\nfree(p);\nstrcpy(p, \"hello\");  // use after free!\n\n// GOOD\nchar* p = malloc(100);\nstrcpy(p, \"hello\");\nfree(p);\np = nullptr;  // prevent accidental reuse\n```\n\n## doubleFree\n\nFreeing memory twice.\n\n```cpp\n// BAD\nchar* p = malloc(100);\nfree(p);\nfree(p);  // double free!\n\n// GOOD\nchar* p = malloc(100);\nfree(p);\np = nullptr;\n// free(p);  // free(nullptr) is safe but unnecessary\n```\n\n## bufferAccessOutOfBounds\n\nBuffer overrun.\n\n```cpp\n// BAD\nchar buf[10];\nstrcpy(buf, \"this string is too long\");  // overflow\n\nint arr[5];\narr[5] = 0;  // out of bounds\n\n// GOOD\nchar buf[32];\nstrncpy(buf, str, sizeof(buf) - 1);\nbuf[sizeof(buf) - 1] = '\\0';\n\nint arr[5];\narr[4] = 0;  // last valid index\n```\n\n## arrayIndexOutOfBounds\n\nArray index out of bounds.\n\n```cpp\n// BAD\nint arr[10];\nfor (int i = 0; i <= 10; i++) {  // off by one\n    arr[i] = 0;\n}\n\n// GOOD\nfor (int i = 0; i < 10; i++) {\n    arr[i] = 0;\n}\n```\n\n## negativeIndex\n\nNegative array index.\n\n```cpp\n// BAD\nint arr[10];\nint i = -1;\narr[i] = 0;  // undefined behavior\n\n// GOOD\nif (i >= 0 && i < 10) {\n    arr[i] = 0;\n}\n```\n\n## invalidIterator\n\nUse of invalid iterator.\n\n```cpp\n// BAD\nstd::vector<int> v = {1, 2, 3};\nauto it = v.begin();\nv.push_back(4);  // may invalidate iterators\n*it = 0;  // undefined behavior!\n\n// GOOD\nstd::vector<int> v = {1, 2, 3};\nv.push_back(4);\nauto it = v.begin();  // get iterator after modification\n*it = 0;\n```\n\n## danglingReference\n\nDangling reference.\n\n```cpp\n// BAD\nint& getRef() {\n    int x = 42;\n    return x;  // dangling reference!\n}\n\n// BAD\nstd::string_view sv = getString();  // temporary destroyed\n\n// GOOD\nint& getRef() {\n    static int x = 42;\n    return x;\n}\n\nstd::string s = getString();\nstd::string_view sv = s;  // s must outlive sv\n```\n\n## invalidContainer\n\nInvalid container operation.\n\n```cpp\n// BAD\nstd::vector<int> v;\nv.front();  // undefined - empty container\n\n// GOOD\nstd::vector<int> v;\nif (!v.empty()) {\n    v.front();\n}\n```\n\n## mismatchAllocDealloc\n\nMismatched allocation/deallocation.\n\n```cpp\n// BAD\nint* p = new int;\nfree(p);  // should use delete\n\nint* arr = new int[10];\ndelete arr;  // should use delete[]\n\n// GOOD\nint* p = new int;\ndelete p;\n\nint* arr = new int[10];\ndelete[] arr;\n\nvoid* m = malloc(100);\nfree(m);\n```\n\n## deallocDealloc\n\nDeallocation of already deallocated memory.\n\n```cpp\n// BAD\nint* p = new int;\ndelete p;\ndelete p;  // double delete!\n\n// GOOD\nint* p = new int;\ndelete p;\np = nullptr;\n```\n\n## zerodiv\n\nDivision by zero.\n\n```cpp\n// BAD\nint x = 10 / 0;  // undefined behavior\n\nint divisor = getValue();\nint result = 100 / divisor;  // might be zero\n\n// GOOD\nint divisor = getValue();\nif (divisor != 0) {\n    int result = 100 / divisor;\n}\n```\n\n## shiftTooManyBits\n\nShift by too many bits.\n\n```cpp\n// BAD\nint x = 1 << 32;  // undefined for 32-bit int\nint y = 1 << -1;  // undefined\n\n// GOOD\nint x = 1 << 31;  // max safe shift for 32-bit signed\nunsigned u = 1U << 31;\n```\n\n## integerOverflow\n\nInteger overflow.\n\n```cpp\n// BAD\nint x = INT_MAX;\nx = x + 1;  // undefined behavior (signed overflow)\n\n// GOOD\nint x = INT_MAX;\nif (x < INT_MAX) {\n    x = x + 1;\n}\n\n// Or use unsigned (wraps defined)\nunsigned u = UINT_MAX;\nu = u + 1;  // wraps to 0, defined behavior\n```\n\n## signConversion\n\nSuspicious sign conversion.\n\n```cpp\n// BAD\nint x = -1;\nunsigned u = x;  // large positive value\nif (u < 10) { }  // always false!\n\n// GOOD\nint x = -1;\nif (x >= 0) {\n    unsigned u = x;\n}\n```\n"}, {"path": "linters/cppcheck/checks.md", "category": "linters", "name": "linters/cppcheck/checks", "content": "# cppcheck Error Checks\n\nCritical bugs that are always reported.\n\n## Memory Errors\n\n### memleak\n\nMemory allocated but not freed.\n\n```cpp\n// BAD\nvoid foo() {\n    char* p = malloc(100);\n    if (error) return;  // leak!\n    free(p);\n}\n\n// GOOD\nvoid foo() {\n    char* p = malloc(100);\n    if (error) {\n        free(p);\n        return;\n    }\n    free(p);\n}\n```\n\n### resourceLeak\n\nFile/resource opened but not closed.\n\n```cpp\n// BAD\nvoid foo() {\n    FILE* f = fopen(\"file\", \"r\");\n    if (error) return;  // leak!\n    fclose(f);\n}\n\n// GOOD - use RAII in C++\nvoid foo() {\n    std::ifstream f(\"file\");\n    if (error) return;  // automatically closed\n}\n```\n\n### deallocuse / useAfterFree\n\nUse after free.\n\n```cpp\n// BAD\nchar* p = malloc(100);\nfree(p);\nstrcpy(p, \"hello\");  // use after free!\n\n// GOOD\nchar* p = malloc(100);\nstrcpy(p, \"hello\");\nfree(p);\np = NULL;  // prevent reuse\n```\n\n### doubleFree\n\nFreeing memory twice.\n\n```cpp\n// BAD\nfree(p);\nfree(p);  // double free!\n\n// GOOD\nfree(p);\np = NULL;\n```\n\n### deallocDealloc\n\nDealloc mismatch.\n\n```cpp\n// BAD\nint* p = new int;\nfree(p);  // should be delete!\n\nint* a = new int[10];\ndelete a;  // should be delete[]!\n\n// GOOD\nint* p = new int;\ndelete p;\n\nint* a = new int[10];\ndelete[] a;\n```\n\n### memleakOnRealloc\n\nLeak when realloc fails.\n\n```cpp\n// BAD\np = realloc(p, new_size);  // if fails, p is lost!\n\n// GOOD\nvoid* tmp = realloc(p, new_size);\nif (tmp == NULL) {\n    free(p);  // free original\n    return ERROR;\n}\np = tmp;\n```\n\n## Null Pointer Errors\n\n### nullPointer\n\nNull pointer dereference.\n\n```cpp\n// BAD\nint* p = NULL;\n*p = 5;  // crash!\n\n// GOOD\nint* p = malloc(sizeof(int));\nif (p != NULL) {\n    *p = 5;\n}\n```\n\n### nullPointerRedundantCheck\n\nCheck after dereference.\n\n```cpp\n// BAD\n*p = 5;  // dereference\nif (p == NULL) {  // too late!\n    return;\n}\n\n// GOOD\nif (p == NULL) {\n    return;\n}\n*p = 5;\n```\n\n## Buffer Errors\n\n### arrayIndexOutOfBounds\n\nArray access out of bounds.\n\n```cpp\n// BAD\nint arr[10];\narr[10] = 5;  // out of bounds!\n\n// GOOD\nint arr[10];\narr[9] = 5;\n```\n\n### bufferAccessOutOfBounds\n\nBuffer overflow.\n\n```cpp\n// BAD\nchar buf[10];\nstrcpy(buf, \"this is too long\");  // overflow!\n\n// GOOD\nchar buf[10];\nstrncpy(buf, \"this is too long\", sizeof(buf) - 1);\nbuf[sizeof(buf) - 1] = '\\0';\n```\n\n### negativeIndex\n\nNegative array index.\n\n```cpp\n// BAD\nint arr[10];\nint i = -1;\narr[i] = 5;  // negative index!\n```\n\n### stringLiteralWrite\n\nWriting to string literal.\n\n```cpp\n// BAD\nchar* s = \"hello\";\ns[0] = 'H';  // undefined behavior!\n\n// GOOD\nchar s[] = \"hello\";\ns[0] = 'H';\n```\n\n## Uninitialized Variables\n\n### uninitvar\n\nUsing uninitialized variable.\n\n```cpp\n// BAD\nint x;\nprintf(\"%d\", x);  // uninitialized!\n\n// GOOD\nint x = 0;\nprintf(\"%d\", x);\n```\n\n### uninitdata\n\nUsing uninitialized data.\n\n```cpp\n// BAD\nstruct S { int a; int b; };\nstruct S s;\nprintf(\"%d\", s.a);  // uninitialized!\n\n// GOOD\nstruct S s = {0};\nprintf(\"%d\", s.a);\n```\n\n### uninitMemberVar\n\nUsing uninitialized member.\n\n```cpp\n// BAD\nclass Foo {\n    int x;\npublic:\n    int getX() { return x; }  // x not initialized!\n};\n\n// GOOD\nclass Foo {\n    int x = 0;\npublic:\n    int getX() { return x; }\n};\n```\n\n## Division Errors\n\n### zerodiv\n\nDivision by zero.\n\n```cpp\n// BAD\nint x = 5 / 0;\n\n// GOOD\nif (divisor != 0) {\n    int x = 5 / divisor;\n}\n```\n\n### zerodivcond\n\nDivision by zero in condition.\n\n```cpp\n// BAD\nif (x != 0) { }\ny = z / x;  // x might be 0 here!\n\n// GOOD\nif (x != 0) {\n    y = z / x;\n}\n```\n\n## Control Flow Errors\n\n### unreachableCode\n\nCode that can never execute.\n\n```cpp\n// BAD\nreturn 0;\nprintf(\"never reached\");  // unreachable!\n```\n\n### duplicateBreak\n\nDuplicate break.\n\n```cpp\n// BAD\ncase 1:\n    break;\n    break;  // duplicate!\n```\n\n### identicalConditionAfterEarlyExit\n\nRedundant condition.\n\n```cpp\n// BAD\nif (x > 0) return;\nif (x > 0) {  // always false here!\n    // ...\n}\n```\n\n## Misc Errors\n\n### invalidPrintfArgType_*\n\nWrong printf format specifier.\n\n```cpp\n// BAD\nprintf(\"%d\", \"string\");  // wrong type!\nprintf(\"%s\", 42);        // wrong type!\n\n// GOOD\nprintf(\"%s\", \"string\");\nprintf(\"%d\", 42);\n```\n\n### wrongPrintfScanfArgNum\n\nWrong number of printf/scanf arguments.\n\n```cpp\n// BAD\nprintf(\"%d %d\", x);  // missing argument!\n\n// GOOD\nprintf(\"%d %d\", x, y);\n```\n\n### invalidScanfArgType_*\n\nWrong scanf argument type.\n\n```cpp\n// BAD\nint x;\nscanf(\"%s\", x);  // should be pointer!\n\n// GOOD\nchar buf[100];\nscanf(\"%s\", buf);\n```\n\n### leakReturnValNotUsed\n\nReturn value leak.\n\n```cpp\n// BAD\nmalloc(100);  // leak - return value ignored!\nstrdup(\"hello\");  // leak!\n\n// GOOD\nchar* p = malloc(100);\n// use p\nfree(p);\n```\n\n### selfAssignment\n\nSelf assignment.\n\n```cpp\n// BAD\nx = x;\n\n// Just remove it\n```\n\n### redundantAssignment\n\nRedundant assignment.\n\n```cpp\n// BAD\nx = 1;\nx = 2;  // first assignment wasted\n\n// GOOD\nx = 2;\n```\n\n### unreadVariable\n\nVariable assigned but never read.\n\n```cpp\n// BAD\nint x = 5;  // never used\n\n// Remove it or use it\n```\n\n### unusedVariable\n\nVariable declared but never used.\n\n```cpp\n// BAD\nint unused;\n\n// Remove it\n```\n\n### constParameter\n\nParameter could be const.\n\n```cpp\n// BAD\nvoid foo(int* p) {\n    printf(\"%d\", *p);  // doesn't modify\n}\n\n// GOOD\nvoid foo(const int* p) {\n    printf(\"%d\", *p);\n}\n```\n\n### constVariable\n\nVariable could be const.\n\n```cpp\n// BAD\nint x = 5;\nprintf(\"%d\", x);  // x never modified\n\n// GOOD\nconst int x = 5;\nprintf(\"%d\", x);\n```\n"}, {"path": "linters/clang-tidy/overview.md", "category": "linters", "name": "linters/clang-tidy/overview", "content": "# clang-tidy Checks\nVersion: unknown\n\nSource: https://clang.llvm.org/extra/clang-tidy/checks/list.html\n\n\nSee: https://clang.llvm.org/extra/clang-tidy/checks/list.html\n"}, {"path": "linters/clang-tidy/cert.md", "category": "linters", "name": "linters/clang-tidy/cert", "content": "# clang-tidy cert-* Checks\n\nCERT Secure Coding Standards for C and C++.\n\n## cert-dcl03-c / cert-dcl16-c\n\nUse appropriate literal suffixes.\n\n```cpp\n// BAD\nlong x = 42l;  // lowercase L looks like 1\nunsigned u = 42u;\n\n// GOOD\nlong x = 42L;\nunsigned u = 42U;\nlong long ll = 42LL;\nunsigned long long ull = 42ULL;\n```\n\n## cert-dcl21-cpp\n\nPostfix operator++ should return const.\n\n```cpp\n// BAD - allows (i++)++ which is undefined\nIterator operator++(int) {\n    Iterator tmp = *this;\n    ++*this;\n    return tmp;\n}\n\n// GOOD\nconst Iterator operator++(int) {\n    Iterator tmp = *this;\n    ++*this;\n    return tmp;\n}\n```\n\n## cert-dcl50-cpp\n\nDon't define C-style variadic functions.\n\n```cpp\n// BAD\nvoid log(const char* fmt, ...) {\n    va_list args;\n    // ...\n}\n\n// GOOD - use variadic templates\ntemplate<typename... Args>\nvoid log(const char* fmt, Args&&... args);\n```\n\n## cert-dcl58-cpp\n\nDon't modify std namespace.\n\n```cpp\n// BAD\nnamespace std {\n    template<>\n    struct hash<MyType> { };  // UB in most cases\n}\n\n// GOOD - specialize in your namespace or use ADL\n// For hash, this is actually allowed as an exception\n```\n\n## cert-env33-c\n\nDon't call system().\n\n```cpp\n// BAD - command injection risk\nsystem(userInput);\nsystem(\"rm -rf \" + path);\n\n// GOOD - use exec family or specific APIs\nexecl(\"/bin/rm\", \"rm\", path.c_str(), nullptr);\n\n// Or use std::filesystem\nstd::filesystem::remove(path);\n```\n\n## cert-err33-c\n\nCheck return values for errors.\n\n```cpp\n// BAD\nfopen(path, \"r\");  // return not checked\nmalloc(size);      // return not checked\nfclose(file);      // return not checked\n\n// GOOD\nFILE* f = fopen(path, \"r\");\nif (f == nullptr) {\n    // handle error\n}\n\nvoid* p = malloc(size);\nif (p == nullptr) {\n    // handle error\n}\n\nif (fclose(file) != 0) {\n    // handle error\n}\n```\n\n## cert-err34-c\n\nCheck scanf return values.\n\n```cpp\n// BAD\nscanf(\"%d\", &x);\n\n// GOOD\nif (scanf(\"%d\", &x) != 1) {\n    // handle parse error\n}\n```\n\n## cert-err52-cpp\n\nDon't use setjmp/longjmp in C++.\n\n```cpp\n// BAD - doesn't call destructors\njmp_buf env;\nif (setjmp(env) == 0) {\n    // ...\n    longjmp(env, 1);  // skips destructors!\n}\n\n// GOOD - use exceptions\ntry {\n    // ...\n    throw std::runtime_error(\"error\");\n} catch (const std::exception& e) {\n    // handle\n}\n```\n\n## cert-err58-cpp\n\nHandle exceptions from static initializers.\n\n```cpp\n// BAD - exception terminates program\nstatic std::vector<int> v = riskyInit();  // might throw\n\n// GOOD - wrap in function\nstatic std::vector<int>& getV() {\n    static std::vector<int> v = []() {\n        try {\n            return riskyInit();\n        } catch (...) {\n            return std::vector<int>{};\n        }\n    }();\n    return v;\n}\n```\n\n## cert-err60-cpp\n\nException objects must be nothrow copy constructible.\n\n```cpp\n// BAD\nclass MyException : public std::exception {\n    std::string msg;  // copy might throw\npublic:\n    MyException(std::string m) : msg(std::move(m)) {}\n};\n\n// GOOD - use shared_ptr for complex data\nclass MyException : public std::exception {\n    std::shared_ptr<std::string> msg;  // copy is noexcept\npublic:\n    MyException(std::string m) \n        : msg(std::make_shared<std::string>(std::move(m))) {}\n};\n```\n\n## cert-fio38-c\n\nDon't copy FILE objects.\n\n```cpp\n// BAD\nFILE f1 = *fopen(\"file\", \"r\");  // undefined behavior\nFILE f2 = f1;                    // undefined behavior\n\n// GOOD\nFILE* f1 = fopen(\"file\", \"r\");\n// use f1 pointer, don't copy\n```\n\n## cert-flp30-c\n\nDon't use floating-point for loop counters.\n\n```cpp\n// BAD - accumulating error\nfor (float f = 0.0f; f < 1.0f; f += 0.1f) {\n    // f may never exactly equal 1.0\n}\n\n// GOOD\nfor (int i = 0; i < 10; ++i) {\n    float f = i * 0.1f;\n}\n```\n\n## cert-mem57-cpp\n\nProvide aligned new for over-aligned types.\n\n```cpp\n// BAD - over-aligned without operator new\nstruct alignas(64) CacheLine {\n    char data[64];\n};\nauto p = new CacheLine;  // may not be aligned in C++14\n\n// GOOD - C++17 aligned allocation\nauto p = new CacheLine;  // C++17 handles it\n\n// Or provide aligned new (pre-C++17)\nstruct alignas(64) CacheLine {\n    char data[64];\n    void* operator new(size_t size) {\n        return aligned_alloc(64, size);\n    }\n    void operator delete(void* p) {\n        free(p);\n    }\n};\n```\n\n## cert-msc30-c / cert-msc50-cpp\n\nDon't use rand() for security.\n\n```cpp\n// BAD - predictable\nint token = rand();\nsrand(time(nullptr));\n\n// GOOD - use <random>\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 100);\nint token = dis(gen);\n\n// For security-critical (tokens, keys)\n#include <openssl/rand.h>\nunsigned char token[32];\nRAND_bytes(token, sizeof(token));\n```\n\n## cert-msc32-c / cert-msc51-cpp\n\nProperly seed random number generators.\n\n```cpp\n// BAD - predictable seed\nsrand(time(nullptr));  // time is predictable\nstd::mt19937 gen(42);  // constant seed\n\n// GOOD\nstd::random_device rd;\nstd::mt19937 gen(rd());\n\n// For reproducible tests, document the seed\nstd::mt19937 gen(KNOWN_SEED);  // for testing only\n```\n\n## cert-oop11-cpp\n\nDon't return rvalue reference.\n\n```cpp\n// BAD\nstd::string&& getName() {\n    return std::move(name_);  // dangling reference!\n}\n\n// GOOD\nstd::string getName() {\n    return name_;  // copy\n}\n\nstd::string getName() && {\n    return std::move(name_);  // move from expiring object\n}\n```\n\n## cert-oop54-cpp\n\nGracefully handle self-assignment.\n\n```cpp\n// BAD\nFoo& operator=(const Foo& other) {\n    delete ptr;\n    ptr = new int(*other.ptr);  // crash if this == &other\n    return *this;\n}\n\n// GOOD - check for self-assignment\nFoo& operator=(const Foo& other) {\n    if (this != &other) {\n        delete ptr;\n        ptr = new int(*other.ptr);\n    }\n    return *this;\n}\n\n// BETTER - copy and swap\nFoo& operator=(Foo other) {  // by value\n    swap(*this, other);\n    return *this;\n}\n```\n\n## cert-oop57-cpp\n\nPrefer special member functions over memcpy/memmove.\n\n```cpp\n// BAD - may not work for non-trivial types\nFoo a, b;\nmemcpy(&a, &b, sizeof(Foo));  // UB if Foo is non-trivial\n\n// GOOD\nFoo a, b;\na = b;  // uses copy assignment\n```\n\n## cert-oop58-cpp\n\nCopy operations should provide strong exception safety.\n\n```cpp\n// BAD - not exception safe\nFoo& operator=(const Foo& other) {\n    delete ptr;  // point of no return\n    ptr = new int(*other.ptr);  // if this throws, object is invalid\n    return *this;\n}\n\n// GOOD - copy and swap (strong guarantee)\nFoo& operator=(const Foo& other) {\n    Foo tmp(other);  // if this throws, *this unchanged\n    swap(*this, tmp);\n    return *this;\n}\n```\n\n## cert-pos44-c\n\nDon't use signals for thread sync.\n\n```cpp\n// BAD - data race\nvolatile sig_atomic_t flag = 0;\n\nvoid handler(int) {\n    flag = 1;\n}\n\nvoid thread() {\n    while (!flag) { }  // spin on flag\n}\n\n// GOOD - use atomics or mutexes\nstd::atomic<bool> flag{false};\n\nvoid thread() {\n    while (!flag.load()) { }\n}\n```\n\n## cert-str34-c\n\nCast characters to unsigned before widening.\n\n```cpp\n// BAD - sign extension\nchar c = getchar();\nint i = c;  // if c is negative, i is negative\n\n// GOOD\nchar c = getchar();\nint i = static_cast<unsigned char>(c);\n\n// Or use unsigned char from start\nunsigned char c = getchar();\n```\n"}, {"path": "linters/clang-tidy/bugprone.md", "category": "linters", "name": "linters/clang-tidy/bugprone", "content": "# clang-tidy bugprone-* Checks\n\nBug-finding checks for common programming mistakes.\n\n## bugprone-argument-comment\n\nChecks that argument comments match parameter names.\n\n```cpp\n// BAD\nvoid draw(int x, int y);\ndraw(/*y=*/10, /*x=*/20);  // swapped!\n\n// GOOD\ndraw(/*x=*/10, /*y=*/20);\n```\n\n## bugprone-assert-side-effect\n\nFinds assertions with side effects (removed in release builds).\n\n```cpp\n// BAD - side effect in assert\nassert(i++ < 10);  // i not incremented in release!\nassert(processItem());  // not called in release!\n\n// GOOD\n++i;\nassert(i < 10);\n\nbool result = processItem();\nassert(result);\n```\n\n## bugprone-assignment-in-if-condition\n\nFinds assignments in if conditions.\n\n```cpp\n// BAD - probably meant ==\nif (x = 0) { }\n\n// GOOD\nif (x == 0) { }\n\n// If intentional, be explicit\nif ((x = getValue()) != 0) { }\n```\n\n## bugprone-bool-pointer-implicit-conversion\n\nFinds implicit bool* to bool conversions.\n\n```cpp\n// BAD\nbool* p = &flag;\nif (p) { }  // checks if pointer is non-null, not the bool value\n\n// GOOD\nif (p && *p) { }  // check both\nif (*p) { }       // if you know p is valid\n```\n\n## bugprone-branch-clone\n\nFinds duplicated code in if/else branches.\n\n```cpp\n// BAD\nif (condition) {\n    doSomething();\n    return 1;\n} else {\n    doSomething();  // duplicate!\n    return 1;\n}\n\n// GOOD - remove branch or fix logic\ndoSomething();\nreturn 1;\n```\n\n## bugprone-copy-constructor-init\n\nFinds copy constructors that don't call base copy constructor.\n\n```cpp\n// BAD\nclass Derived : public Base {\n    Derived(const Derived& other) : Base() { }  // should call Base(other)\n};\n\n// GOOD\nclass Derived : public Base {\n    Derived(const Derived& other) : Base(other) { }\n};\n```\n\n## bugprone-dangling-handle\n\nFinds dangling references to temporary strings.\n\n```cpp\n// BAD\nstd::string_view sv = getString();  // getString() returns temporary\nuse(sv);  // dangling!\n\n// GOOD\nstd::string s = getString();\nstd::string_view sv = s;\nuse(sv);\n```\n\n## bugprone-dynamic-static-initializers\n\nFinds dynamic initialization of static variables.\n\n```cpp\n// BAD - initialization order undefined\nstatic int x = someFunction();\n\n// GOOD - use function-local static or constexpr\nint getX() {\n    static int x = someFunction();  // initialized on first call\n    return x;\n}\n```\n\n## bugprone-exception-escape\n\nFinds functions that may throw but shouldn't.\n\n```cpp\n// BAD - destructor shouldn't throw\n~MyClass() {\n    throw std::runtime_error(\"oops\");  // undefined behavior!\n}\n\n// GOOD\n~MyClass() noexcept {\n    try {\n        cleanup();\n    } catch (...) {\n        // log but don't throw\n    }\n}\n```\n\n## bugprone-fold-init-type\n\nFinds folds with wrong init type.\n\n```cpp\n// BAD - init is int, accumulator loses precision\nauto sum = std::accumulate(v.begin(), v.end(), 0);  // v is vector<double>\n\n// GOOD\nauto sum = std::accumulate(v.begin(), v.end(), 0.0);\n```\n\n## bugprone-forwarding-reference-overload\n\nFinds forwarding reference constructors that hide copy/move.\n\n```cpp\n// BAD - template catches everything\nclass Widget {\n    template<typename T>\n    Widget(T&& arg) { }  // catches Widget& too!\n};\n\n// GOOD - constrain the template\nclass Widget {\n    template<typename T>\n    requires (!std::same_as<std::remove_cvref_t<T>, Widget>)\n    Widget(T&& arg) { }\n};\n```\n\n## bugprone-implicit-widening-of-multiplication-result\n\nFinds multiplication overflow before widening.\n\n```cpp\n// BAD - multiplication overflows before cast\nint a = 1000000, b = 1000000;\nlong long result = a * b;  // overflow!\n\n// GOOD - cast before multiplication\nlong long result = static_cast<long long>(a) * b;\n```\n\n## bugprone-incorrect-roundings\n\nFinds incorrect rounding patterns.\n\n```cpp\n// BAD\nint rounded = (int)(d + 0.5);  // wrong for negative numbers\n\n// GOOD\nint rounded = std::lround(d);\n```\n\n## bugprone-infinite-loop\n\nFinds loops that never terminate.\n\n```cpp\n// BAD\nwhile (true) {\n    if (condition) continue;  // no break ever!\n}\n\n// GOOD\nwhile (true) {\n    if (condition) break;\n}\n```\n\n## bugprone-integer-division\n\nFinds integer division in floating-point context.\n\n```cpp\n// BAD\ndouble ratio = count / total;  // integer division!\n\n// GOOD\ndouble ratio = static_cast<double>(count) / total;\n```\n\n## bugprone-macro-parentheses\n\nFinds macros without proper parentheses.\n\n```cpp\n// BAD\n#define DOUBLE(x) x * 2\nint y = DOUBLE(1 + 2);  // expands to 1 + 2 * 2 = 5, not 6\n\n// GOOD\n#define DOUBLE(x) ((x) * 2)\n```\n\n## bugprone-macro-repeated-side-effects\n\nFinds macros that evaluate arguments multiple times.\n\n```cpp\n// BAD\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\nint x = MAX(i++, j++);  // incremented twice!\n\n// GOOD - use inline function\ntemplate<typename T>\nconstexpr T max(T a, T b) { return a > b ? a : b; }\n```\n\n## bugprone-misplaced-operator-in-strlen-in-alloc\n\nFinds strlen() + 1 mistakes.\n\n```cpp\n// BAD\nchar* copy = malloc(strlen(s + 1));  // wrong - s+1 passed to strlen\n\n// GOOD\nchar* copy = malloc(strlen(s) + 1);  // +1 outside strlen\n```\n\n## bugprone-misplaced-widening-cast\n\nFinds casts that should be done earlier.\n\n```cpp\n// BAD - multiplication already overflowed\nlong long result = (long long)(a * b);\n\n// GOOD - cast before operation\nlong long result = (long long)a * b;\n```\n\n## bugprone-move-forwarding-reference\n\nFinds std::move on forwarding references.\n\n```cpp\n// BAD - should use std::forward\ntemplate<typename T>\nvoid foo(T&& arg) {\n    bar(std::move(arg));  // wrong!\n}\n\n// GOOD\ntemplate<typename T>\nvoid foo(T&& arg) {\n    bar(std::forward<T>(arg));\n}\n```\n\n## bugprone-multiple-statement-macro\n\nFinds multi-statement macros without braces.\n\n```cpp\n// BAD\n#define DO_BOTH do_a(); do_b()\nif (cond) DO_BOTH;  // only do_a is conditional!\n\n// GOOD\n#define DO_BOTH do { do_a(); do_b(); } while(0)\n```\n\n## bugprone-narrowing-conversions\n\nFinds implicit narrowing conversions.\n\n```cpp\n// BAD\nint x = 3.14;      // loses .14\nchar c = 1000;     // overflow\nfloat f = 1e100;   // overflow\n\n// GOOD - explicit conversion\nint x = static_cast<int>(3.14);\n```\n\n## bugprone-not-null-terminated-result\n\nFinds string operations that may not null-terminate.\n\n```cpp\n// BAD\nchar buf[10];\nstrncpy(buf, src, sizeof(buf));  // may not null-terminate\n\n// GOOD\nstrncpy(buf, src, sizeof(buf) - 1);\nbuf[sizeof(buf) - 1] = '\\0';\n\n// BETTER - use strlcpy or snprintf\nsnprintf(buf, sizeof(buf), \"%s\", src);\n```\n\n## bugprone-parent-virtual-call\n\nFinds calls to parent virtual through wrong type.\n\n```cpp\n// BAD\nclass Derived : public Base {\n    void foo() override {\n        Base::foo();       // OK\n        this->Base::foo(); // OK\n        ((Base*)this)->foo(); // calls Derived::foo! infinite recursion\n    }\n};\n```\n\n## bugprone-signed-char-misuse\n\nFinds signed char used where unsigned expected.\n\n```cpp\n// BAD - char may be negative\nchar c = getchar();\nif (c == 255) { }  // never true if char is signed!\n\n// GOOD\nint c = getchar();  // getchar returns int\nif (c == 255) { }\n```\n\n## bugprone-sizeof-container\n\nFinds sizeof() on containers.\n\n```cpp\n// BAD\nstd::vector<int> v;\nsize_t bytes = sizeof(v);  // size of vector struct, not contents!\n\n// GOOD\nsize_t bytes = v.size() * sizeof(int);\nsize_t elements = v.size();\n```\n\n## bugprone-sizeof-expression\n\nFinds suspicious sizeof expressions.\n\n```cpp\n// BAD\nint* arr = malloc(10);\nmemset(arr, 0, sizeof(arr));  // only clears pointer size!\n\n// GOOD\nint* arr = malloc(10 * sizeof(int));\nmemset(arr, 0, 10 * sizeof(int));\n```\n\n## bugprone-string-constructor\n\nFinds suspicious string constructor calls.\n\n```cpp\n// BAD - creates string of 'x' characters, not \"x\" string\nstd::string s('x', 50);  // wrong order!\n\n// GOOD\nstd::string s(50, 'x');  // 50 copies of 'x'\nstd::string s(\"x\");      // string \"x\"\n```\n\n## bugprone-string-literal-with-embedded-nul\n\nFinds strings with embedded NUL characters.\n\n```cpp\n// BAD - NUL in middle, string truncated\nstd::string s = \"hello\\0world\";  // s is \"hello\"\n\n// GOOD - if intentional, use constructor\nstd::string s(\"hello\\0world\", 11);  // includes NUL\n```\n\n## bugprone-suspicious-enum-usage\n\nFinds suspicious enum operations.\n\n```cpp\n// BAD - mixing enum values\nenum Color { Red, Green, Blue };\nenum Size { Small, Medium, Large };\nif (color == Small) { }  // comparing different enums\n\n// GOOD - use enum class\nenum class Color { Red, Green, Blue };\nenum class Size { Small, Medium, Large };\n// if (color == Size::Small) { }  // error!\n```\n\n## bugprone-suspicious-include\n\nFinds includes with implementation file extensions.\n\n```cpp\n// BAD\n#include \"file.cpp\"  // probably wrong\n#include \"file.c\"\n\n// GOOD\n#include \"file.h\"\n#include \"file.hpp\"\n```\n\n## bugprone-suspicious-memory-comparison\n\nFinds memcmp on non-trivially-comparable types.\n\n```cpp\n// BAD - padding bytes may differ\nstruct S { char a; int b; };  // has padding\nS s1, s2;\nmemcmp(&s1, &s2, sizeof(S));  // compares padding too!\n\n// GOOD\ns1.a == s2.a && s1.b == s2.b\n```\n\n## bugprone-suspicious-memset-usage\n\nFinds suspicious memset patterns.\n\n```cpp\n// BAD\nmemset(buf, sizeof(buf), 0);  // args swapped!\n\n// GOOD\nmemset(buf, 0, sizeof(buf));\n```\n\n## bugprone-suspicious-missing-comma\n\nFinds string literals missing comma.\n\n```cpp\n// BAD\nconst char* arr[] = {\n    \"one\",\n    \"two\"   // missing comma\n    \"three\" // concatenated with \"two\"!\n};\n\n// GOOD\nconst char* arr[] = {\n    \"one\",\n    \"two\",\n    \"three\"\n};\n```\n\n## bugprone-suspicious-semicolon\n\nFinds suspicious semicolons.\n\n```cpp\n// BAD\nif (condition);  // empty if body!\n{\n    doSomething();  // always runs\n}\n\n// GOOD\nif (condition) {\n    doSomething();\n}\n```\n\n## bugprone-suspicious-string-compare\n\nFinds suspicious string comparisons.\n\n```cpp\n// BAD - strcmp returns 0 for equal!\nif (strcmp(a, b)) {\n    // strings are NOT equal here\n}\n\n// GOOD\nif (strcmp(a, b) == 0) {\n    // strings are equal\n}\n```\n\n## bugprone-swapped-arguments\n\nFinds likely swapped function arguments.\n\n```cpp\n// BAD\nmemset(buf, sizeof(buf), 0);  // size and value swapped\n\n// GOOD\nmemset(buf, 0, sizeof(buf));\n```\n\n## bugprone-terminating-continue\n\nFinds continue that terminates loop.\n\n```cpp\n// BAD\ndo {\n    continue;  // loop runs once!\n} while (false);\n```\n\n## bugprone-throw-keyword-missing\n\nFinds missing throw keyword.\n\n```cpp\n// BAD\nif (error) {\n    std::runtime_error(\"oops\");  // creates and discards!\n}\n\n// GOOD\nif (error) {\n    throw std::runtime_error(\"oops\");\n}\n```\n\n## bugprone-too-small-loop-variable\n\nFinds loop variables that may overflow.\n\n```cpp\n// BAD\nfor (char i = 0; i < size; i++) { }  // char may overflow\n\n// GOOD\nfor (size_t i = 0; i < size; i++) { }\n```\n\n## bugprone-undefined-memory-manipulation\n\nFinds memset/memcpy on non-trivial types.\n\n```cpp\n// BAD\nstd::string s;\nmemset(&s, 0, sizeof(s));  // undefined behavior!\n\n// GOOD\nstd::string s;\ns.clear();\n```\n\n## bugprone-undelegated-constructor\n\nFinds constructor calls that don't delegate.\n\n```cpp\n// BAD\nclass Foo {\n    Foo() { }\n    Foo(int x) {\n        Foo();  // creates temporary, doesn't delegate!\n    }\n};\n\n// GOOD\nclass Foo {\n    Foo() { }\n    Foo(int x) : Foo() { }  // C++11 delegating constructor\n};\n```\n\n## bugprone-unhandled-exception-at-new\n\nFinds new expressions that may throw.\n\n```cpp\n// BAD\nint* p = new int[size];  // may throw std::bad_alloc\n\n// GOOD\nint* p = new (std::nothrow) int[size];\nif (!p) { /* handle */ }\n\n// BETTER - use smart pointer\nauto p = std::make_unique<int[]>(size);\n```\n\n## bugprone-unhandled-self-assignment\n\nFinds copy assignment without self-assignment check.\n\n```cpp\n// BAD\nFoo& operator=(const Foo& other) {\n    delete ptr;\n    ptr = new int(*other.ptr);  // crashes if this == &other\n    return *this;\n}\n\n// GOOD\nFoo& operator=(const Foo& other) {\n    if (this != &other) {\n        delete ptr;\n        ptr = new int(*other.ptr);\n    }\n    return *this;\n}\n\n// BETTER - copy and swap\nFoo& operator=(Foo other) {  // by value\n    swap(*this, other);\n    return *this;\n}\n```\n\n## bugprone-unused-raii\n\nFinds RAII objects created and immediately destroyed.\n\n```cpp\n// BAD\n{\n    std::lock_guard<std::mutex>(mutex);  // unnamed - destroyed immediately!\n    // critical section not protected\n}\n\n// GOOD\n{\n    std::lock_guard<std::mutex> lock(mutex);  // named - lives until scope end\n    // critical section protected\n}\n```\n\n## bugprone-unused-return-value\n\nFinds ignored return values.\n\n```cpp\n// BAD\nstd::remove(v.begin(), v.end(), value);  // doesn't erase!\nempty();  // return value ignored\n\n// GOOD\nv.erase(std::remove(v.begin(), v.end(), value), v.end());\nif (empty()) { }\n```\n\n## bugprone-use-after-move\n\nFinds use of moved-from objects.\n\n```cpp\n// BAD\nstd::vector<int> v = {1, 2, 3};\nauto v2 = std::move(v);\nv.push_back(4);  // undefined behavior!\n\n// GOOD\nstd::vector<int> v = {1, 2, 3};\nauto v2 = std::move(v);\nv.clear();  // now safe to reuse\nv.push_back(4);\n```\n\n## bugprone-virtual-near-miss\n\nFinds methods that almost override.\n\n```cpp\n// BAD - typo in override\nclass Base {\n    virtual void doWork();\n};\n\nclass Derived : public Base {\n    void dowork();  // lowercase 'w' - doesn't override!\n};\n\n// GOOD\nclass Derived : public Base {\n    void doWork() override;  // compiler catches mismatches\n};\n```\n"}, {"path": "linters/clang-tidy/cppcoreguidelines.md", "category": "linters", "name": "linters/clang-tidy/cppcoreguidelines", "content": "# clang-tidy cppcoreguidelines-* Checks\n\nChecks based on the C++ Core Guidelines (https://isocpp.github.io/CppCoreGuidelines/).\n\n## cppcoreguidelines-avoid-c-arrays\n\nUse std::array or std::vector instead of C arrays.\n\n```cpp\n// BAD\nint arr[10];\nvoid foo(int arr[]);\n\n// GOOD\nstd::array<int, 10> arr;\nvoid foo(std::span<int> arr);  // C++20\nvoid foo(int* arr, size_t size);  // pre-C++20\n```\n\n## cppcoreguidelines-avoid-const-or-ref-data-members\n\nAvoid const or reference data members.\n\n```cpp\n// BAD - makes class non-assignable\nclass Foo {\n    const int id;           // can't reassign\n    std::string& name_ref;  // can't reassign\n};\n\n// GOOD\nclass Foo {\n    int id;                 // can reassign\n    std::string* name_ptr;  // can reassign (or use accessor)\n    \n    // If immutable ID needed, make it private with getter only\n    int getId() const { return id_; }\nprivate:\n    int id_;\n};\n```\n\n## cppcoreguidelines-avoid-do-while\n\nAvoid do-while loops.\n\n```cpp\n// BAD - condition at end, harder to reason about\ndo {\n    process();\n} while (condition);\n\n// GOOD - condition at start\nwhile (true) {\n    process();\n    if (!condition) break;\n}\n\n// Or restructure\nprocess();\nwhile (condition) {\n    process();\n}\n```\n\n## cppcoreguidelines-avoid-goto\n\nDon't use goto.\n\n```cpp\n// BAD\nif (error) goto cleanup;\n// ...\ncleanup:\n    free(resources);\n\n// GOOD - RAII\n{\n    auto guard = make_scope_guard([] { free(resources); });\n    if (error) return;\n    // ...\n}  // guard cleans up\n```\n\n## cppcoreguidelines-avoid-magic-numbers\n\nSame as readability-magic-numbers.\n\n## cppcoreguidelines-avoid-non-const-global-variables\n\nAvoid non-const global variables.\n\n```cpp\n// BAD\nint globalCounter = 0;\nstd::string globalConfig;\n\n// GOOD - const is OK\nconst int MAX_SIZE = 100;\nconstexpr double PI = 3.14159;\n\n// GOOD - encapsulate in function\nint& getCounter() {\n    static int counter = 0;\n    return counter;\n}\n```\n\n## cppcoreguidelines-avoid-reference-coroutine-parameters\n\nDon't pass by reference to coroutines.\n\n```cpp\n// BAD - reference may dangle\ntask<void> process(const std::string& s) {\n    co_await something();\n    use(s);  // s may be dangling!\n}\n\n// GOOD - pass by value\ntask<void> process(std::string s) {\n    co_await something();\n    use(s);  // s is owned by coroutine\n}\n```\n\n## cppcoreguidelines-c-copy-assignment-signature\n\nCopy assignment should return reference to *this.\n\n```cpp\n// BAD\nvoid operator=(const Foo& other);\nFoo operator=(const Foo& other);\n\n// GOOD\nFoo& operator=(const Foo& other) {\n    // ...\n    return *this;\n}\n```\n\n## cppcoreguidelines-init-variables\n\nInitialize variables on declaration.\n\n```cpp\n// BAD\nint x;\ndouble* p;\n\n// GOOD\nint x = 0;\ndouble* p = nullptr;\n\n// C++11 brace initialization\nint x{};\ndouble* p{};\n```\n\n## cppcoreguidelines-interfaces-global-init\n\nAvoid global initializer order issues.\n\n```cpp\n// BAD - initialization order undefined\n// file1.cpp\nstd::string config = getConfig();\n\n// file2.cpp\nextern std::string config;\nLogger logger(config);  // config might not be initialized yet!\n\n// GOOD - lazy initialization\nconst std::string& getConfig() {\n    static std::string config = loadConfig();\n    return config;\n}\n```\n\n## cppcoreguidelines-macro-usage\n\nAvoid macros for constants/functions.\n\n```cpp\n// BAD\n#define PI 3.14159\n#define SQUARE(x) ((x) * (x))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\n// GOOD\nconstexpr double PI = 3.14159;\n\ntemplate<typename T>\nconstexpr T square(T x) { return x * x; }\n\ntemplate<typename T>\nconstexpr T max(T a, T b) { return a > b ? a : b; }\n```\n\n## cppcoreguidelines-misleading-capture-default-by-value\n\nWarn about capturing this by value default.\n\n```cpp\n// BAD - [=] captures this by value, not *this\nclass Foo {\n    int x;\n    void bar() {\n        auto f = [=] { return x; };  // captures this pointer\n    }\n};\n\n// GOOD - explicit capture\nclass Foo {\n    int x;\n    void bar() {\n        auto f = [this] { return x; };     // explicit this pointer\n        auto g = [*this] { return x; };    // copies *this (C++17)\n        auto h = [x = x] { return x; };    // capture by value\n    }\n};\n```\n\n## cppcoreguidelines-missing-std-forward\n\nUse std::forward with forwarding references.\n\n```cpp\n// BAD - loses rvalue-ness\ntemplate<typename T>\nvoid wrapper(T&& arg) {\n    inner(arg);  // always lvalue\n}\n\n// GOOD\ntemplate<typename T>\nvoid wrapper(T&& arg) {\n    inner(std::forward<T>(arg));\n}\n```\n\n## cppcoreguidelines-narrowing-conversions\n\nAvoid narrowing conversions.\n\n```cpp\n// BAD\nint i = 3.14;           // narrowing\nchar c = 1000;          // narrowing, overflow\nfloat f = 1e100;        // narrowing, overflow\n\n// GOOD\nint i = static_cast<int>(3.14);  // explicit\nauto i = static_cast<int>(3.14);\n\n// Or use gsl::narrow\nint i = gsl::narrow<int>(3.14);  // throws on data loss\nint i = gsl::narrow_cast<int>(3.14);  // asserts in debug\n```\n\n## cppcoreguidelines-no-malloc\n\nDon't use malloc/free.\n\n```cpp\n// BAD\nint* p = (int*)malloc(sizeof(int) * 10);\nfree(p);\n\n// GOOD\nauto p = std::make_unique<int[]>(10);\n\n// Or std::vector for dynamic arrays\nstd::vector<int> v(10);\n```\n\n## cppcoreguidelines-owning-memory\n\nUse gsl::owner for raw owning pointers.\n\n```cpp\n// BAD - unclear ownership\nint* create() {\n    return new int(42);  // caller must delete?\n}\n\n// GOOD - explicit ownership\ngsl::owner<int*> create() {\n    return new int(42);  // caller must delete\n}\n\n// BETTER - use smart pointers\nstd::unique_ptr<int> create() {\n    return std::make_unique<int>(42);\n}\n```\n\n## cppcoreguidelines-prefer-member-initializer\n\nInitialize members in member initializer list.\n\n```cpp\n// BAD\nclass Foo {\n    int x;\n    std::string name;\npublic:\n    Foo() {\n        x = 0;        // assignment, not initialization\n        name = \"\";    // assignment, not initialization\n    }\n};\n\n// GOOD\nclass Foo {\n    int x;\n    std::string name;\npublic:\n    Foo() : x(0), name(\"\") {}\n};\n\n// BETTER - default member initializers\nclass Foo {\n    int x = 0;\n    std::string name;\npublic:\n    Foo() = default;\n};\n```\n\n## cppcoreguidelines-pro-bounds-array-to-pointer-decay\n\nAvoid array-to-pointer decay.\n\n```cpp\n// BAD - loses size information\nvoid foo(int* arr);\nint arr[10];\nfoo(arr);  // decays to pointer\n\n// GOOD\nvoid foo(std::span<int> arr);  // C++20\nvoid foo(int* arr, size_t size);\n\ntemplate<size_t N>\nvoid foo(int (&arr)[N]);  // preserves size\n```\n\n## cppcoreguidelines-pro-bounds-constant-array-index\n\nUse gsl::at() or bounds-checked access.\n\n```cpp\n// BAD - no bounds checking\narr[i];\nvec[i];\n\n// GOOD\ngsl::at(arr, i);  // throws if out of bounds\nvec.at(i);        // throws if out of bounds\n```\n\n## cppcoreguidelines-pro-bounds-pointer-arithmetic\n\nAvoid pointer arithmetic.\n\n```cpp\n// BAD\np++;\np + n;\np[n];\n\n// GOOD - use std::span or iterators\nfor (int x : std::span(p, size)) { }\nfor (auto it = vec.begin(); it != vec.end(); ++it) { }\n```\n\n## cppcoreguidelines-pro-type-const-cast\n\nDon't use const_cast.\n\n```cpp\n// BAD\nconst_cast<int*>(ptr);\n\n// GOOD - fix the design\n// If you need non-const, don't make it const\n// If API requires const, don't cast it away\n```\n\n## cppcoreguidelines-pro-type-cstyle-cast\n\nDon't use C-style casts.\n\n```cpp\n// BAD\nint x = (int)3.14;\nvoid* p = (void*)ptr;\n\n// GOOD\nint x = static_cast<int>(3.14);\nvoid* p = static_cast<void*>(ptr);\n```\n\n## cppcoreguidelines-pro-type-member-init\n\nInitialize all members.\n\n```cpp\n// BAD\nclass Foo {\n    int x;      // uninitialized\n    int* ptr;   // uninitialized\n};\n\n// GOOD\nclass Foo {\n    int x = 0;\n    int* ptr = nullptr;\n};\n```\n\n## cppcoreguidelines-pro-type-reinterpret-cast\n\nDon't use reinterpret_cast.\n\n```cpp\n// BAD\nint* p = reinterpret_cast<int*>(addr);\n\n// GOOD - use std::bit_cast (C++20)\nauto p = std::bit_cast<int*>(addr);\n\n// Or design to not need it\n```\n\n## cppcoreguidelines-pro-type-static-cast-downcast\n\nUse dynamic_cast for downcasting.\n\n```cpp\n// BAD - no runtime check\nDerived* d = static_cast<Derived*>(base);\n\n// GOOD - runtime checked\nDerived* d = dynamic_cast<Derived*>(base);\nif (d) {\n    // safe to use\n}\n```\n\n## cppcoreguidelines-pro-type-union-access\n\nDon't access union members directly.\n\n```cpp\n// BAD\nunion U {\n    int i;\n    float f;\n};\nU u;\nu.i = 1;\nfloat f = u.f;  // undefined behavior\n\n// GOOD - use std::variant\nstd::variant<int, float> v = 1;\nint i = std::get<int>(v);\n```\n\n## cppcoreguidelines-pro-type-vararg\n\nDon't use C-style varargs.\n\n```cpp\n// BAD\nvoid log(const char* fmt, ...);\n\n// GOOD - use variadic templates\ntemplate<typename... Args>\nvoid log(std::format_string<Args...> fmt, Args&&... args) {\n    std::cout << std::format(fmt, std::forward<Args>(args)...);\n}\n```\n\n## cppcoreguidelines-rvalue-reference-param-not-moved\n\nMove from rvalue reference parameters.\n\n```cpp\n// BAD - takes rvalue but copies\nvoid foo(std::string&& s) {\n    member_ = s;  // copies!\n}\n\n// GOOD\nvoid foo(std::string&& s) {\n    member_ = std::move(s);\n}\n```\n\n## cppcoreguidelines-slicing\n\nAvoid object slicing.\n\n```cpp\n// BAD\nDerived d;\nBase b = d;  // slices off Derived part\n\nvoid foo(Base b);\nfoo(Derived());  // sliced on copy\n\n// GOOD\nBase& b = d;              // reference preserves type\nvoid foo(const Base& b);  // reference parameter\nvoid foo(Base* b);        // pointer parameter\n```\n\n## cppcoreguidelines-special-member-functions\n\nFollow rule of zero/five.\n\n```cpp\n// BAD - violates rule of 5\nclass Foo {\n    int* data;\npublic:\n    ~Foo() { delete data; }  // only destructor\n    // missing: copy ctor, copy assign, move ctor, move assign\n};\n\n// GOOD - rule of 5\nclass Foo {\n    int* data;\npublic:\n    ~Foo() { delete data; }\n    Foo(const Foo& other);\n    Foo& operator=(const Foo& other);\n    Foo(Foo&& other) noexcept;\n    Foo& operator=(Foo&& other) noexcept;\n};\n\n// BETTER - rule of 0\nclass Foo {\n    std::unique_ptr<int> data;\n    // compiler generates correct special members\n};\n```\n\n## cppcoreguidelines-virtual-class-destructor\n\nVirtual classes need virtual destructor.\n\n```cpp\n// BAD\nclass Base {\n    virtual void foo();\n    ~Base();  // non-virtual!\n};\n\ndelete basePtr;  // undefined if points to Derived\n\n// GOOD\nclass Base {\n    virtual void foo();\n    virtual ~Base() = default;\n};\n```\n"}, {"path": "linters/clang-tidy/performance.md", "category": "linters", "name": "linters/clang-tidy/performance", "content": "# clang-tidy performance-* Checks\n\nPerformance optimization checks.\n\n## performance-avoid-endl\n\nUse '\\n' instead of std::endl.\n\n```cpp\n// BAD - endl flushes buffer every time\nstd::cout << \"line 1\" << std::endl;\nstd::cout << \"line 2\" << std::endl;\n\n// GOOD - '\\n' doesn't flush\nstd::cout << \"line 1\\n\";\nstd::cout << \"line 2\\n\";\n\n// Explicit flush when needed\nstd::cout << \"prompt: \" << std::flush;\n```\n\n## performance-faster-string-find\n\nUse character overload for single-char find.\n\n```cpp\n// BAD - string overload, more overhead\nstr.find(\"x\");\nstr.rfind(\"x\");\nstr.find_first_of(\"x\");\nstr.find_last_of(\"x\");\n\n// GOOD - character overload, faster\nstr.find('x');\nstr.rfind('x');\nstr.find_first_of('x');\nstr.find_last_of('x');\n```\n\n## performance-for-range-copy\n\nAvoid unnecessary copies in range-based for.\n\n```cpp\n// BAD - copies every element\nfor (auto item : container) {\n    use(item);\n}\n\n// GOOD - reference, no copy\nfor (const auto& item : container) {\n    use(item);\n}\n\n// For modification\nfor (auto& item : container) {\n    modify(item);\n}\n```\n\n## performance-implicit-conversion-in-loop\n\nAvoid implicit conversions in loops.\n\n```cpp\n// BAD - converts size_t to int every iteration\nfor (int i = 0; i < vec.size(); ++i) { }\n\n// GOOD - matching types\nfor (size_t i = 0; i < vec.size(); ++i) { }\n\n// BETTER - range-based\nfor (const auto& item : vec) { }\n```\n\n## performance-inefficient-algorithm\n\nUse more efficient algorithm variants.\n\n```cpp\n// BAD - find + erase is O(n) + O(n)\nauto it = std::find(v.begin(), v.end(), value);\nif (it != v.end()) {\n    v.erase(it);\n}\n\n// GOOD for unordered removal - O(n)\nauto it = std::find(v.begin(), v.end(), value);\nif (it != v.end()) {\n    std::swap(*it, v.back());\n    v.pop_back();\n}\n\n// For removing all matching elements\nv.erase(std::remove(v.begin(), v.end(), value), v.end());\n```\n\n## performance-inefficient-string-concatenation\n\nAvoid repeated string concatenation.\n\n```cpp\n// BAD - creates temporaries\nstd::string result = a + b + c + d;\n\n// Also BAD in loops\nstd::string s;\nfor (const auto& item : items) {\n    s = s + item;  // O(n\u00b2)\n}\n\n// GOOD - reserve and append\nstd::string s;\ns.reserve(total_size);\nfor (const auto& item : items) {\n    s += item;\n}\n\n// Or use stringstream\nstd::ostringstream oss;\nfor (const auto& item : items) {\n    oss << item;\n}\nstd::string s = oss.str();\n```\n\n## performance-inefficient-vector-operation\n\nReserve vector capacity before filling.\n\n```cpp\n// BAD - reallocates as it grows\nstd::vector<int> v;\nfor (int i = 0; i < 1000; ++i) {\n    v.push_back(i);\n}\n\n// GOOD - single allocation\nstd::vector<int> v;\nv.reserve(1000);\nfor (int i = 0; i < 1000; ++i) {\n    v.push_back(i);\n}\n\n// BETTER if size known\nstd::vector<int> v(1000);\nfor (int i = 0; i < 1000; ++i) {\n    v[i] = i;\n}\n```\n\n## performance-move-const-arg\n\nDon't move const objects.\n\n```cpp\n// BAD - const can't be moved, will copy\nconst std::string s = \"hello\";\nfunc(std::move(s));  // actually copies\n\n// GOOD\nstd::string s = \"hello\";\nfunc(std::move(s));  // actually moves\n```\n\n## performance-move-constructor-init\n\nUse std::move in constructor initializers.\n\n```cpp\n// BAD - copies parameter\nclass Foo {\n    std::string name_;\npublic:\n    Foo(std::string name) : name_(name) {}  // copies\n};\n\n// GOOD - moves parameter\nclass Foo {\n    std::string name_;\npublic:\n    Foo(std::string name) : name_(std::move(name)) {}\n};\n```\n\n## performance-no-automatic-move\n\nEnsure automatic move isn't prevented.\n\n```cpp\n// BAD - const prevents move\nstd::vector<int> getVector() {\n    const std::vector<int> v = compute();\n    return v;  // copies because const\n}\n\n// GOOD - non-const enables move\nstd::vector<int> getVector() {\n    std::vector<int> v = compute();\n    return v;  // moves\n}\n```\n\n## performance-no-int-to-ptr\n\nAvoid integer to pointer casts.\n\n```cpp\n// BAD\nvoid* p = (void*)0x12345678;\nint* ip = reinterpret_cast<int*>(addr);\n\n// GOOD - if you really need this\nvoid* p = reinterpret_cast<void*>(static_cast<uintptr_t>(0x12345678));\n```\n\n## performance-noexcept-destructor\n\nDestructors should be noexcept.\n\n```cpp\n// BAD\nclass Foo {\n    ~Foo() { }  // implicitly noexcept(true), but not explicit\n};\n\n// GOOD\nclass Foo {\n    ~Foo() noexcept { }\n};\n\n// If destructor might throw (avoid this!)\nclass Foo {\n    ~Foo() noexcept(false) { }  // explicit that it throws\n};\n```\n\n## performance-noexcept-move-constructor\n\nMove operations should be noexcept.\n\n```cpp\n// BAD - prevents optimizations\nclass Foo {\n    Foo(Foo&& other) { }\n    Foo& operator=(Foo&& other) { }\n};\n\n// GOOD - enables optimizations\nclass Foo {\n    Foo(Foo&& other) noexcept { }\n    Foo& operator=(Foo&& other) noexcept { }\n};\n```\n\n**Why:** std::vector won't use move if it's not noexcept.\n\n## performance-noexcept-swap\n\nSwap should be noexcept.\n\n```cpp\n// BAD\nvoid swap(Foo& a, Foo& b) {\n    // ...\n}\n\n// GOOD\nvoid swap(Foo& a, Foo& b) noexcept {\n    // ...\n}\n```\n\n## performance-trivially-destructible\n\nUse trivially destructible types when possible.\n\n```cpp\n// BAD - non-trivial destructor\nstruct Point {\n    int x, y;\n    ~Point() { }  // unnecessary, prevents optimizations\n};\n\n// GOOD - trivially destructible\nstruct Point {\n    int x, y;\n    // no destructor needed\n};\n```\n\n## performance-type-promotion-in-math-fn\n\nAvoid unnecessary type promotion in math functions.\n\n```cpp\n// BAD - float promoted to double\nfloat f = 3.14f;\nfloat result = std::sin(f);  // calls sin(double)\n\n// GOOD - use float overload\nfloat f = 3.14f;\nfloat result = std::sinf(f);  // or std::sin(f) in C++11\n```\n\n## performance-unnecessary-copy-initialization\n\nAvoid unnecessary copies when initializing.\n\n```cpp\n// BAD - copies the result\nconst std::string& ref = getString();\nauto copy = ref;  // unnecessary copy if only reading\n\n// GOOD - use reference\nconst auto& copy = getString();\n\n// Or if you need a copy, move from temporary\nauto copy = getString();  // moves from temporary\n```\n\n## performance-unnecessary-value-param\n\nPass by const reference instead of value for read-only params.\n\n```cpp\n// BAD - copies the string\nvoid process(std::string s) {\n    std::cout << s;\n}\n\n// GOOD - no copy\nvoid process(const std::string& s) {\n    std::cout << s;\n}\n\n// Exception: if you need to store/modify, take by value and move\nvoid store(std::string s) {\n    member_ = std::move(s);\n}\n```\n"}, {"path": "linters/clang-tidy/modernize.md", "category": "linters", "name": "linters/clang-tidy/modernize", "content": "# clang-tidy modernize-* Checks\n\nModernize C++ code to newer standards (C++11/14/17/20/23).\n\n## modernize-avoid-bind\n\nReplace std::bind with lambdas.\n\n```cpp\n// BAD\nauto f = std::bind(&Foo::bar, this, std::placeholders::_1);\n\n// GOOD\nauto f = [this](int x) { return bar(x); };\n```\n\n## modernize-avoid-c-arrays\n\nUse std::array or std::vector instead of C arrays.\n\n```cpp\n// BAD\nint arr[10];\nint arr[] = {1, 2, 3};\n\n// GOOD\nstd::array<int, 10> arr;\nstd::array arr = {1, 2, 3};  // C++17 CTAD\nstd::vector<int> arr = {1, 2, 3};\n```\n\n## modernize-concat-nested-namespaces\n\nUse C++17 nested namespace syntax.\n\n```cpp\n// BAD\nnamespace foo {\nnamespace bar {\nnamespace baz {\n}\n}\n}\n\n// GOOD (C++17)\nnamespace foo::bar::baz {\n}\n```\n\n## modernize-deprecated-headers\n\nReplace deprecated C headers with C++ equivalents.\n\n```cpp\n// BAD\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <stdint.h>\n\n// GOOD\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cstdint>\n```\n\n## modernize-deprecated-ios-base-aliases\n\nReplace deprecated iostream aliases.\n\n```cpp\n// BAD\nstd::ios_base::io_state\nstd::ios_base::open_mode\nstd::ios_base::seek_dir\n\n// GOOD\nstd::ios_base::iostate\nstd::ios_base::openmode\nstd::ios_base::seekdir\n```\n\n## modernize-loop-convert\n\nConvert for loops to range-based for.\n\n```cpp\n// BAD\nfor (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n    std::cout << *it;\n}\n\nfor (int i = 0; i < v.size(); ++i) {\n    std::cout << v[i];\n}\n\n// GOOD\nfor (int x : v) {\n    std::cout << x;\n}\n\nfor (const auto& x : v) {\n    std::cout << x;\n}\n```\n\n## modernize-make-shared\n\nUse std::make_shared instead of new.\n\n```cpp\n// BAD\nstd::shared_ptr<Foo> p(new Foo(1, 2));\nstd::shared_ptr<Foo> p = std::shared_ptr<Foo>(new Foo());\n\n// GOOD\nauto p = std::make_shared<Foo>(1, 2);\n```\n\n**Why:** Single allocation, exception safe.\n\n## modernize-make-unique\n\nUse std::make_unique instead of new.\n\n```cpp\n// BAD\nstd::unique_ptr<Foo> p(new Foo(1, 2));\nstd::unique_ptr<Foo[]> arr(new Foo[10]);\n\n// GOOD\nauto p = std::make_unique<Foo>(1, 2);\nauto arr = std::make_unique<Foo[]>(10);\n```\n\n## modernize-pass-by-value\n\nPass by value and move for sink parameters.\n\n```cpp\n// BAD - copies even when caller has temporary\nclass Foo {\n    std::string name_;\npublic:\n    void setName(const std::string& name) {\n        name_ = name;\n    }\n};\n\n// GOOD - moves temporaries, copies lvalues\nclass Foo {\n    std::string name_;\npublic:\n    void setName(std::string name) {\n        name_ = std::move(name);\n    }\n};\n```\n\n## modernize-raw-string-literal\n\nUse raw string literals for complex escapes.\n\n```cpp\n// BAD\nconst char* regex = \"\\\\d+\\\\.\\\\d+\";\nconst char* path = \"C:\\\\Users\\\\name\\\\file\";\nconst char* json = \"{\\\"key\\\": \\\"value\\\"}\";\n\n// GOOD\nconst char* regex = R\"(\\d+\\.\\d+)\";\nconst char* path = R\"(C:\\Users\\name\\file)\";\nconst char* json = R\"({\"key\": \"value\"})\";\n\n// With delimiter for strings containing )\nconst char* s = R\"delim(contains ) character)delim\";\n```\n\n## modernize-redundant-void-arg\n\nRemove redundant void in empty parameter lists.\n\n```cpp\n// BAD (C-style)\nint foo(void);\nint bar(void) { return 0; }\n\n// GOOD (C++)\nint foo();\nint bar() { return 0; }\n```\n\n## modernize-replace-auto-ptr\n\nReplace deprecated std::auto_ptr with std::unique_ptr.\n\n```cpp\n// BAD (removed in C++17)\nstd::auto_ptr<Foo> p(new Foo());\n\n// GOOD\nstd::unique_ptr<Foo> p = std::make_unique<Foo>();\n```\n\n## modernize-replace-disallow-copy-and-assign-macro\n\nReplace DISALLOW_COPY macro with deleted functions.\n\n```cpp\n// BAD\nclass Foo {\n    DISALLOW_COPY_AND_ASSIGN(Foo);\n};\n\n// GOOD\nclass Foo {\n    Foo(const Foo&) = delete;\n    Foo& operator=(const Foo&) = delete;\n};\n```\n\n## modernize-replace-random-shuffle\n\nReplace std::random_shuffle with std::shuffle.\n\n```cpp\n// BAD (removed in C++17)\nstd::random_shuffle(v.begin(), v.end());\n\n// GOOD\nstd::random_device rd;\nstd::mt19937 g(rd());\nstd::shuffle(v.begin(), v.end(), g);\n```\n\n## modernize-return-braced-init-list\n\nUse braced init for return.\n\n```cpp\n// BAD\nstd::pair<int, int> foo() {\n    return std::make_pair(1, 2);\n}\n\n// GOOD\nstd::pair<int, int> foo() {\n    return {1, 2};\n}\n```\n\n## modernize-shrink-to-fit\n\nUse shrink_to_fit() instead of swap trick.\n\n```cpp\n// BAD\nstd::vector<int>(v).swap(v);\n\n// GOOD\nv.shrink_to_fit();\n```\n\n## modernize-unary-static-assert\n\nUse single-argument static_assert (C++17).\n\n```cpp\n// BAD\nstatic_assert(sizeof(int) == 4, \"\");\n\n// GOOD (C++17)\nstatic_assert(sizeof(int) == 4);\n```\n\n## modernize-use-auto\n\nUse auto where type is obvious.\n\n```cpp\n// BAD\nstd::vector<int>::iterator it = v.begin();\nstd::unique_ptr<Foo> p = std::make_unique<Foo>();\nWidget* w = new Widget();\n\n// GOOD\nauto it = v.begin();\nauto p = std::make_unique<Foo>();\nauto* w = new Widget();  // auto* makes pointer explicit\n```\n\n## modernize-use-bool-literals\n\nUse true/false instead of integer literals.\n\n```cpp\n// BAD\nbool b = 1;\nbool c = 0;\nfunction(1);  // where param is bool\n\n// GOOD\nbool b = true;\nbool c = false;\nfunction(true);\n```\n\n## modernize-use-default-member-init\n\nUse default member initializers.\n\n```cpp\n// BAD\nclass Foo {\n    int x;\n    std::string name;\npublic:\n    Foo() : x(0), name(\"default\") {}\n};\n\n// GOOD\nclass Foo {\n    int x = 0;\n    std::string name = \"default\";\npublic:\n    Foo() = default;\n};\n```\n\n## modernize-use-emplace\n\nUse emplace instead of push_back with temporaries.\n\n```cpp\n// BAD\nv.push_back(Foo(1, 2));\nv.push_back(std::make_pair(1, 2));\n\n// GOOD\nv.emplace_back(1, 2);\n```\n\n## modernize-use-equals-default\n\nUse = default for trivial special members.\n\n```cpp\n// BAD\nclass Foo {\npublic:\n    Foo() {}\n    ~Foo() {}\n    Foo(const Foo& other) : x(other.x) {}\n};\n\n// GOOD\nclass Foo {\npublic:\n    Foo() = default;\n    ~Foo() = default;\n    Foo(const Foo&) = default;\n};\n```\n\n## modernize-use-equals-delete\n\nUse = delete instead of private undefined.\n\n```cpp\n// BAD (C++03 style)\nclass Foo {\nprivate:\n    Foo(const Foo&);  // undefined\n    Foo& operator=(const Foo&);  // undefined\n};\n\n// GOOD\nclass Foo {\npublic:\n    Foo(const Foo&) = delete;\n    Foo& operator=(const Foo&) = delete;\n};\n```\n\n## modernize-use-nodiscard\n\nAdd [[nodiscard]] where appropriate.\n\n```cpp\n// BAD\nbool isEmpty() const { return size_ == 0; }\nError validate() const { return check(); }\n\n// GOOD\n[[nodiscard]] bool isEmpty() const { return size_ == 0; }\n[[nodiscard]] Error validate() const { return check(); }\n```\n\n## modernize-use-noexcept\n\nUse noexcept instead of throw().\n\n```cpp\n// BAD\nvoid foo() throw();\nvoid bar() throw(std::exception);\n\n// GOOD\nvoid foo() noexcept;\nvoid bar();  // may throw\n```\n\n## modernize-use-nullptr\n\nUse nullptr instead of NULL or 0.\n\n```cpp\n// BAD\nint* p = NULL;\nint* q = 0;\nif (p == NULL) {}\n\n// GOOD\nint* p = nullptr;\nint* q = nullptr;\nif (p == nullptr) {}\nif (!p) {}  // also fine\n```\n\n## modernize-use-override\n\nUse override for virtual function overrides.\n\n```cpp\n// BAD\nclass Derived : public Base {\n    virtual void foo();  // override? new virtual?\n    void bar();          // override? non-virtual?\n};\n\n// GOOD\nclass Derived : public Base {\n    void foo() override;     // definitely overrides\n    void bar() override;     // compiler error if Base::bar not virtual\n};\n```\n\n## modernize-use-starts-ends-with\n\nUse starts_with/ends_with (C++20).\n\n```cpp\n// BAD\nif (s.find(\"prefix\") == 0) {}\nif (s.rfind(\"suffix\") == s.size() - 6) {}\nif (s.substr(0, 6) == \"prefix\") {}\n\n// GOOD (C++20)\nif (s.starts_with(\"prefix\")) {}\nif (s.ends_with(\"suffix\")) {}\n```\n\n## modernize-use-std-print\n\nUse std::print instead of printf (C++23).\n\n```cpp\n// BAD\nprintf(\"Hello %s, you are %d\\n\", name, age);\nstd::cout << \"Hello \" << name << \", you are \" << age << \"\\n\";\n\n// GOOD (C++23)\nstd::print(\"Hello {}, you are {}\\n\", name, age);\nstd::println(\"Hello {}, you are {}\", name, age);\n```\n\n## modernize-use-trailing-return-type\n\nUse trailing return type syntax.\n\n```cpp\n// Traditional\nint foo();\nstd::vector<int> bar();\n\n// Trailing (useful for templates, decltype)\nauto foo() -> int;\nauto bar() -> std::vector<int>;\n\n// Required for some cases\ntemplate<typename T, typename U>\nauto add(T t, U u) -> decltype(t + u);\n```\n\n## modernize-use-transparent-functors\n\nUse transparent comparators.\n\n```cpp\n// BAD - requires exact key type\nstd::map<std::string, int> m;\nm.find(\"key\");  // constructs temporary std::string\n\n// GOOD - heterogeneous lookup\nstd::map<std::string, int, std::less<>> m;\nm.find(\"key\");  // compares directly with const char*\n```\n\n## modernize-use-uncaught-exceptions\n\nUse std::uncaught_exceptions (plural).\n\n```cpp\n// BAD (deprecated in C++17, removed in C++20)\nbool throwing = std::uncaught_exception();\n\n// GOOD\nint count = std::uncaught_exceptions();\nbool throwing = count > 0;\n```\n\n## modernize-use-using\n\nUse using instead of typedef.\n\n```cpp\n// BAD\ntypedef std::vector<int> IntVector;\ntypedef int (*FuncPtr)(int, int);\ntypedef std::map<std::string, std::vector<int>> StringToInts;\n\n// GOOD\nusing IntVector = std::vector<int>;\nusing FuncPtr = int (*)(int, int);\nusing StringToInts = std::map<std::string, std::vector<int>>;\n\n// Template aliases only work with using\ntemplate<typename T>\nusing Vec = std::vector<T>;\n```\n"}, {"path": "linters/clang-tidy/readability.md", "category": "linters", "name": "linters/clang-tidy/readability", "content": "# clang-tidy readability-* Checks\n\nCode readability and clarity improvements.\n\n## readability-avoid-const-params-in-decls\n\nDon't use const for pass-by-value params in declarations.\n\n```cpp\n// BAD - const in declaration is noise\nvoid foo(const int x);  // declaration\nvoid foo(const int x) { }  // definition - const is fine here\n\n// GOOD\nvoid foo(int x);  // declaration\nvoid foo(const int x) { }  // definition - const prevents accidental modification\n```\n\n## readability-avoid-nested-conditional-operator\n\nAvoid nested ternary operators.\n\n```cpp\n// BAD - hard to read\nint x = a ? b ? c : d : e;\n\n// GOOD - use if/else\nint x;\nif (a) {\n    x = b ? c : d;\n} else {\n    x = e;\n}\n```\n\n## readability-braces-around-statements\n\nRequire braces for if/for/while.\n\n```cpp\n// BAD\nif (condition)\n    doSomething();\n\nfor (int i = 0; i < n; i++)\n    process(i);\n\n// GOOD\nif (condition) {\n    doSomething();\n}\n\nfor (int i = 0; i < n; i++) {\n    process(i);\n}\n```\n\n## readability-const-return-type\n\nDon't return const values.\n\n```cpp\n// BAD - prevents move semantics\nconst std::string getName() { return name_; }\n\n// GOOD\nstd::string getName() { return name_; }\n\n// Const reference is fine\nconst std::string& getName() const { return name_; }\n```\n\n## readability-container-contains\n\nUse contains() instead of count/find (C++20).\n\n```cpp\n// BAD\nif (set.count(value) > 0) { }\nif (set.find(value) != set.end()) { }\nif (map.count(key)) { }\n\n// GOOD (C++20)\nif (set.contains(value)) { }\nif (map.contains(key)) { }\n```\n\n## readability-container-data-pointer\n\nUse data() instead of &container[0].\n\n```cpp\n// BAD\nchar* p = &str[0];\nint* q = &vec[0];\n\n// GOOD\nchar* p = str.data();\nint* q = vec.data();\n```\n\n## readability-container-size-empty\n\nUse empty() instead of size() == 0.\n\n```cpp\n// BAD\nif (vec.size() == 0) { }\nif (str.size() != 0) { }\nif (0 == list.size()) { }\n\n// GOOD\nif (vec.empty()) { }\nif (!str.empty()) { }\nif (!list.empty()) { }\n```\n\n## readability-convert-member-functions-to-static\n\nMake member functions static if they don't use this.\n\n```cpp\n// BAD - doesn't use any members\nclass Foo {\n    int helper(int x) { return x * 2; }\n};\n\n// GOOD\nclass Foo {\n    static int helper(int x) { return x * 2; }\n};\n```\n\n## readability-delete-null-pointer\n\nDon't check for null before delete.\n\n```cpp\n// BAD - delete handles null\nif (ptr != nullptr) {\n    delete ptr;\n}\n\n// GOOD\ndelete ptr;\n```\n\n## readability-duplicate-include\n\nRemove duplicate #include.\n\n```cpp\n// BAD\n#include <vector>\n#include <string>\n#include <vector>  // duplicate\n\n// GOOD\n#include <string>\n#include <vector>\n```\n\n## readability-else-after-return\n\nDon't use else after return.\n\n```cpp\n// BAD\nif (condition) {\n    return a;\n} else {\n    return b;\n}\n\n// GOOD\nif (condition) {\n    return a;\n}\nreturn b;\n```\n\n## readability-function-cognitive-complexity\n\nLimit cognitive complexity of functions.\n\n```cpp\n// BAD - high cognitive complexity\nvoid process(Data& d) {\n    if (d.valid) {                    // +1\n        for (auto& item : d.items) {  // +2 (nested)\n            if (item.active) {        // +3 (nested)\n                for (auto& sub : item.subs) {  // +4 (nested)\n                    if (sub.check()) {  // +5 (nested)\n                        // ...\n                    }\n                }\n            }\n        }\n    }\n}  // complexity: 15+\n\n// GOOD - extract functions\nvoid processItem(Item& item);\nvoid processSub(Sub& sub);\n\nvoid process(Data& d) {\n    if (!d.valid) return;\n    for (auto& item : d.items) {\n        processItem(item);\n    }\n}\n```\n\n## readability-function-size\n\nLimit function size (lines, statements, parameters, nesting).\n\n```cpp\n// Configuration\nCheckOptions:\n  - key: readability-function-size.LineThreshold\n    value: 100\n  - key: readability-function-size.StatementThreshold\n    value: 50\n  - key: readability-function-size.ParameterThreshold\n    value: 6\n  - key: readability-function-size.NestingThreshold\n    value: 4\n```\n\n## readability-identifier-length\n\nEnforce minimum identifier length.\n\n```cpp\n// BAD - too short\nint n;\nfor (int i; ...) { }\nauto f = []() { };\n\n// GOOD\nint count;\nfor (int index; ...) { }\nauto filter = []() { };\n\n// Exceptions often configured for i, j, k, x, y, etc.\n```\n\n## readability-identifier-naming\n\nEnforce naming conventions.\n\n```cpp\n// Configuration example\nCheckOptions:\n  - key: readability-identifier-naming.ClassCase\n    value: CamelCase\n  - key: readability-identifier-naming.FunctionCase\n    value: camelBack\n  - key: readability-identifier-naming.VariableCase\n    value: lower_case\n  - key: readability-identifier-naming.ConstantCase\n    value: UPPER_CASE\n  - key: readability-identifier-naming.MemberPrefix\n    value: m_\n  - key: readability-identifier-naming.PrivateMemberSuffix\n    value: _\n```\n\n## readability-implicit-bool-conversion\n\nAvoid implicit bool conversions.\n\n```cpp\n// BAD\nint x = 5;\nif (x) { }  // implicit conversion to bool\nbool b = x;  // implicit conversion\n\n// GOOD\nif (x != 0) { }\nbool b = (x != 0);\n\n// Pointers are OK\nint* p = getPointer();\nif (p) { }  // common idiom\n```\n\n## readability-inconsistent-declaration-parameter-name\n\nParameter names should match across declarations.\n\n```cpp\n// BAD\nvoid foo(int x, int y);  // declaration\nvoid foo(int a, int b) { }  // definition - different names\n\n// GOOD\nvoid foo(int x, int y);  // declaration\nvoid foo(int x, int y) { }  // definition - same names\n```\n\n## readability-isolate-declaration\n\nOne declaration per statement.\n\n```cpp\n// BAD\nint x, y, z;\nint* p, q;  // q is not a pointer!\n\n// GOOD\nint x;\nint y;\nint z;\nint* p;\nint* q;\n```\n\n## readability-magic-numbers\n\nAvoid magic numbers.\n\n```cpp\n// BAD\nif (age >= 18) { }\nfor (int i = 0; i < 86400; i++) { }\ndouble area = 3.14159 * r * r;\n\n// GOOD\nconstexpr int ADULT_AGE = 18;\nconstexpr int SECONDS_PER_DAY = 86400;\nconstexpr double PI = 3.14159;\n\nif (age >= ADULT_AGE) { }\nfor (int i = 0; i < SECONDS_PER_DAY; i++) { }\ndouble area = PI * r * r;\n```\n\n## readability-make-member-function-const\n\nMake member functions const if they don't modify state.\n\n```cpp\n// BAD\nclass Foo {\n    int x_;\n    int getX() { return x_; }  // doesn't modify, should be const\n};\n\n// GOOD\nclass Foo {\n    int x_;\n    int getX() const { return x_; }\n};\n```\n\n## readability-misleading-indentation\n\nCatch misleading indentation.\n\n```cpp\n// BAD\nif (condition)\n    foo();\n    bar();  // looks like it's in the if, but isn't!\n\n// GOOD\nif (condition) {\n    foo();\n}\nbar();\n```\n\n## readability-misplaced-array-index\n\nPrefer arr[index] over index[arr].\n\n```cpp\n// BAD (but valid C/C++)\nint x = 5[arr];  // same as arr[5]\n\n// GOOD\nint x = arr[5];\n```\n\n## readability-named-parameter\n\nGive names to function parameters.\n\n```cpp\n// BAD\nvoid process(int, std::string, bool);\n\n// GOOD\nvoid process(int id, std::string name, bool verbose);\n\n// If intentionally unused, use comment\nvoid callback(int /*unused*/, std::string name);\n```\n\n## readability-non-const-parameter\n\nMake pointer parameters const if not modified.\n\n```cpp\n// BAD\nvoid print(int* data, size_t size);  // doesn't modify data\n\n// GOOD\nvoid print(const int* data, size_t size);\n```\n\n## readability-qualified-auto\n\nUse auto* and auto& explicitly.\n\n```cpp\n// BAD - unclear if pointer\nauto p = getPointer();\n\n// GOOD - explicit pointer\nauto* p = getPointer();\n\n// BAD - unclear if reference\nauto r = getReference();\n\n// GOOD - explicit reference\nauto& r = getReference();\n```\n\n## readability-redundant-access-specifiers\n\nRemove redundant access specifiers.\n\n```cpp\n// BAD\nclass Foo {\npublic:\n    void foo();\npublic:  // redundant\n    void bar();\n};\n\n// GOOD\nclass Foo {\npublic:\n    void foo();\n    void bar();\n};\n```\n\n## readability-redundant-control-flow\n\nRemove redundant control flow.\n\n```cpp\n// BAD\nvoid foo() {\n    doSomething();\n    return;  // redundant\n}\n\nfor (...) {\n    if (condition) {\n        continue;  // at end of loop, redundant\n    }\n}\n\n// GOOD\nvoid foo() {\n    doSomething();\n}\n\nfor (...) {\n    if (!condition) {\n        // work\n    }\n}\n```\n\n## readability-redundant-declaration\n\nRemove redundant declarations.\n\n```cpp\n// BAD\nextern int x;\nextern int x;  // redundant\n\n// GOOD\nextern int x;\n```\n\n## readability-redundant-member-init\n\nRemove redundant member initializers.\n\n```cpp\n// BAD\nclass Foo {\n    int x = 0;\n    std::string s = \"\";\npublic:\n    Foo() : x(0), s(\"\") {}  // redundant - same as defaults\n};\n\n// GOOD\nclass Foo {\n    int x = 0;\n    std::string s;  // default-initialized to \"\"\npublic:\n    Foo() = default;\n};\n```\n\n## readability-redundant-preprocessor\n\nRemove redundant preprocessor directives.\n\n```cpp\n// BAD\n#ifndef FOO\n#ifndef FOO  // redundant\n#define FOO\n#endif\n#endif\n\n// GOOD\n#ifndef FOO\n#define FOO\n#endif\n```\n\n## readability-redundant-smartptr-get\n\nRemove redundant smart pointer get().\n\n```cpp\n// BAD\nif (ptr.get() != nullptr) { }\nif (ptr.get()) { }\n*ptr.get();\n\n// GOOD\nif (ptr != nullptr) { }\nif (ptr) { }\n*ptr;\n```\n\n## readability-redundant-string-cstr\n\nRemove redundant c_str() calls.\n\n```cpp\n// BAD\nstd::string s = str.c_str();\nprintf(\"%s\", str.c_str());  // needed for C functions\n\n// GOOD\nstd::string s = str;\nstd::cout << str;  // no c_str() needed\n```\n\n## readability-redundant-string-init\n\nRemove redundant string initialization.\n\n```cpp\n// BAD\nstd::string s = \"\";\nstd::string s(\"\");\nstd::string s{\"\"};\n\n// GOOD\nstd::string s;  // default is empty\n```\n\n## readability-simplify-boolean-expr\n\nSimplify boolean expressions.\n\n```cpp\n// BAD\nif (condition == true) { }\nif (condition == false) { }\nbool b = condition ? true : false;\nreturn condition ? true : false;\n\n// GOOD\nif (condition) { }\nif (!condition) { }\nbool b = condition;\nreturn condition;\n```\n\n## readability-simplify-subscript-expr\n\nSimplify subscript expressions.\n\n```cpp\n// BAD\nstr.data()[0];\nvec.data()[i];\n\n// GOOD\nstr[0];\nvec[i];\n```\n\n## readability-static-accessed-through-instance\n\nAccess static members through class name.\n\n```cpp\n// BAD\nFoo foo;\nfoo.staticMethod();\nfoo.STATIC_CONSTANT;\n\n// GOOD\nFoo::staticMethod();\nFoo::STATIC_CONSTANT;\n```\n\n## readability-string-compare\n\nUse comparison operators for strings.\n\n```cpp\n// BAD\nif (str.compare(\"other\") == 0) { }\nif (str.compare(\"other\") != 0) { }\n\n// GOOD\nif (str == \"other\") { }\nif (str != \"other\") { }\n```\n\n## readability-suspicious-call-argument\n\nFinds likely argument swaps.\n\n```cpp\n// BAD\nvoid setRect(int x, int y, int width, int height);\nsetRect(width, height, x, y);  // suspicious - names suggest swap\n\n// GOOD\nsetRect(x, y, width, height);\n```\n\n## readability-uniqueptr-delete-release\n\nUse reset() instead of delete + release().\n\n```cpp\n// BAD\ndelete ptr.release();\n\n// GOOD\nptr.reset();\n```\n\n## readability-uppercase-literal-suffix\n\nUse uppercase literal suffixes.\n\n```cpp\n// BAD\nlong x = 42l;      // l looks like 1\nfloat f = 3.14f;   // inconsistent\nunsigned u = 42u;\n\n// GOOD\nlong x = 42L;\nfloat f = 3.14F;\nunsigned u = 42U;\nlong long ll = 42LL;\n```\n\n## readability-use-anyofallof\n\nUse std::any_of/all_of/none_of.\n\n```cpp\n// BAD\nbool found = false;\nfor (const auto& item : items) {\n    if (item.matches()) {\n        found = true;\n        break;\n    }\n}\n\n// GOOD\nbool found = std::any_of(items.begin(), items.end(),\n    [](const auto& item) { return item.matches(); });\n\n// C++20 ranges\nbool found = std::ranges::any_of(items, &Item::matches);\n```\n"}]}
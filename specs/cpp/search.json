{"language": "cpp", "generatedAt": "2026-01-06T18:23:21.997257+00:00", "entries": [{"path": "compilers.md", "category": "spec", "name": "compilers", "content": "# Compilers\n\nGCC: 15.2.0\n\nSource: https://gcc.gnu.org/\n\nClang: 21.1.8\n\nSource: https://clang.llvm.org/\n\n"}, {"path": "generation-checklist.md", "category": "spec", "name": "generation-checklist", "content": "# C++ Generation Checklist\n\n**Read this BEFORE writing C++ code. Modern C++ is memory-safe when used correctly.**\n\n## Critical: You Must Do These\n\n### 1. Use Smart Pointers, Not Raw `new`/`delete`\n```cpp\n// BAD - manual memory management\nWidget* w = new Widget();\n// ... forget to delete = leak\ndelete w;\n\n// GOOD - automatic cleanup\nauto w = std::make_unique<Widget>();\n// or for shared ownership\nauto w = std::make_shared<Widget>();\n```\n\n### 2. Use RAII for All Resources\n```cpp\n// BAD - manual resource management\nvoid process() {\n    FILE* f = fopen(\"data.txt\", \"r\");\n    if (error) return;  // Leak!\n    fclose(f);\n}\n\n// GOOD - RAII wrapper\nvoid process() {\n    std::ifstream file(\"data.txt\");\n    if (error) return;  // Automatic cleanup\n}\n```\n\n### 3. Prefer `std::string` Over C Strings\n```cpp\n// BAD - manual buffer management\nchar buf[256];\nstrcpy(buf, str);\n\n// GOOD - automatic management\nstd::string s = str;\n```\n\n### 4. Use `nullptr` Not `NULL` or `0`\n```cpp\n// BAD - ambiguous\nWidget* w = NULL;\nWidget* w = 0;\n\n// GOOD - type-safe\nWidget* w = nullptr;\n```\n\n### 5. Initialize All Members in Constructors\n```cpp\n// BAD - uninitialized members\nclass Widget {\n    int count;\n    std::string name;\npublic:\n    Widget() { }  // count is garbage!\n};\n\n// GOOD - member initializer list\nclass Widget {\n    int count;\n    std::string name;\npublic:\n    Widget() : count(0), name() { }\n};\n\n// BETTER - default member initializers (C++11)\nclass Widget {\n    int count = 0;\n    std::string name;\n};\n```\n\n## Important: Strong Recommendations\n\n### 6. Use `const` Extensively\n```cpp\n// GOOD - const correctness\nclass Widget {\npublic:\n    int getValue() const { return value; }  // const method\n    void process(const std::string& s);     // const ref param\n};\n```\n\n### 7. Pass by `const&` for Read-Only Objects\n```cpp\n// BAD - unnecessary copy\nvoid process(std::string s);\nvoid process(std::vector<int> v);\n\n// GOOD - no copy\nvoid process(const std::string& s);\nvoid process(const std::vector<int>& v);\n```\n\n### 8. Use Range-Based For Loops\n```cpp\n// BAD - index-based\nfor (size_t i = 0; i < vec.size(); ++i) {\n    process(vec[i]);\n}\n\n// GOOD - range-based\nfor (const auto& item : vec) {\n    process(item);\n}\n```\n\n### 9. Use `auto` for Complex Types\n```cpp\n// BAD - verbose, error-prone\nstd::map<std::string, std::vector<int>>::iterator it = map.begin();\n\n// GOOD - cleaner\nauto it = map.begin();\n```\n\n### 10. Prefer `std::array` Over C Arrays\n```cpp\n// BAD - decays to pointer, no size info\nint arr[10];\n\n// GOOD - knows its size, safer\nstd::array<int, 10> arr;\n```\n\n## Modern C++ (11/14/17/20)\n\n### 11. Use `override` for Virtual Functions\n```cpp\nclass Derived : public Base {\n    // BAD - silent bug if signature doesn't match\n    void process();\n\n    // GOOD - compiler error if not overriding\n    void process() override;\n};\n```\n\n### 12. Use `= default` and `= delete`\n```cpp\nclass Widget {\npublic:\n    Widget() = default;                          // Use compiler default\n    Widget(const Widget&) = delete;              // Prevent copying\n    Widget& operator=(const Widget&) = delete;   // Prevent assignment\n};\n```\n\n### 13. Use `std::optional` for Maybe-Values (C++17)\n```cpp\n// BAD - sentinel values or out params\nint find(const std::vector<int>& v, int target);  // Returns -1 if not found?\n\n// GOOD - explicit optionality\nstd::optional<int> find(const std::vector<int>& v, int target);\n```\n\n### 14. Use Structured Bindings (C++17)\n```cpp\n// BAD - verbose\nstd::pair<int, std::string> p = getPair();\nint id = p.first;\nstd::string name = p.second;\n\n// GOOD - clean\nauto [id, name] = getPair();\n```\n\n### 15. Use `std::string_view` for Read-Only Strings (C++17)\n```cpp\n// BAD - forces allocation for string literals\nvoid process(const std::string& s);\n\n// GOOD - no allocation, works with string, char*, string_view\nvoid process(std::string_view s);\n```\n\n## Concurrency\n\n### 16. Use `std::mutex` with `std::lock_guard`\n```cpp\n// BAD - manual lock/unlock\nmutex.lock();\n// ... exception here = deadlock\nmutex.unlock();\n\n// GOOD - RAII locking\n{\n    std::lock_guard<std::mutex> lock(mutex);\n    // Automatically unlocked on scope exit\n}\n```\n\n### 17. Prefer `std::atomic` for Simple Shared State\n```cpp\n// BAD - data race\nbool running = true;\n\n// GOOD - atomic operations\nstd::atomic<bool> running{true};\n```\n\n---\n\n**Quick Reference - Copy This Mental Model:**\n- Smart pointers (unique_ptr, shared_ptr)\n- RAII for all resources\n- std::string not char[]\n- nullptr not NULL\n- Initialize all members\n- const& for read-only params\n- Range-based for loops\n- auto for complex types\n- override on virtual methods\n- std::optional for maybe-values\n- lock_guard for mutexes\n"}, {"path": "patterns/idioms.md", "category": "patterns", "name": "patterns/idioms", "content": "# Modern C++ Idiomatic Patterns (C++17/20/23)\n\n## Memory Management\n\n### Use smart pointers, not raw new/delete\n\n```cpp\n// BAD\nWidget* w = new Widget();\n// ... forget to delete\n\n// GOOD\nauto w = std::make_unique<Widget>();\n// automatically deleted\n\n// Shared ownership\nauto shared = std::make_shared<Widget>();\n```\n\n### Rule of Zero/Five\n\n```cpp\n// Rule of Zero: Use RAII wrappers, no manual resource management\nclass Good {\n    std::string name;\n    std::vector<int> data;\n    // No destructor, copy/move ops needed\n};\n\n// Rule of Five: If you define one, define all\nclass Manual {\n    int* data;\npublic:\n    ~Manual();\n    Manual(const Manual&);\n    Manual& operator=(const Manual&);\n    Manual(Manual&&) noexcept;\n    Manual& operator=(Manual&&) noexcept;\n};\n```\n\n## Use auto (but not everywhere)\n\n```cpp\n// GOOD - obvious type\nauto it = container.begin();\nauto ptr = std::make_unique<Widget>();\n\n// GOOD - complex type\nauto lambda = [](int x) { return x * 2; };\n\n// BAD - hides important type info\nauto config = getConfig();  // What type is this?\n\n// BETTER\nConfig config = getConfig();\n```\n\n## Range-based for\n\n```cpp\n// BAD\nfor (size_t i = 0; i < vec.size(); ++i) {\n    process(vec[i]);\n}\n\n// GOOD\nfor (const auto& item : vec) {\n    process(item);\n}\n\n// Modify in place\nfor (auto& item : vec) {\n    item.update();\n}\n```\n\n## Use constexpr\n\n```cpp\n// Compile-time computation\nconstexpr int factorial(int n) {\n    return n <= 1 ? 1 : n * factorial(n - 1);\n}\n\nconstexpr int fact5 = factorial(5);  // computed at compile time\n```\n\n## std::optional for nullable values\n\n```cpp\n// BAD\nWidget* find(int id);  // nullptr if not found\n\n// GOOD\nstd::optional<Widget> find(int id);\n\n// Usage\nif (auto w = find(42)) {\n    w->doSomething();\n}\n```\n\n## std::variant for type-safe unions\n\n```cpp\nusing Result = std::variant<Success, Error>;\n\nResult doSomething() {\n    if (failed) {\n        return Error{\"something went wrong\"};\n    }\n    return Success{data};\n}\n\n// Visit pattern\nstd::visit([](auto&& arg) {\n    using T = std::decay_t<decltype(arg)>;\n    if constexpr (std::is_same_v<T, Success>) {\n        handle(arg.data);\n    } else {\n        log(arg.message);\n    }\n}, result);\n```\n\n## Structured bindings\n\n```cpp\nstd::map<std::string, int> map;\n\n// BAD\nfor (const auto& pair : map) {\n    std::cout << pair.first << \": \" << pair.second;\n}\n\n// GOOD\nfor (const auto& [key, value] : map) {\n    std::cout << key << \": \" << value;\n}\n```\n\n## Use [[nodiscard]]\n\n```cpp\n[[nodiscard]] Error doSomething();\n\ndoSomething();  // Warning: ignoring return value\n```\n\n## String views\n\n```cpp\n// BAD - unnecessary copy\nvoid process(const std::string& s);\n\n// GOOD - no copy for literals or string views\nvoid process(std::string_view s);\n```\n\n## Concepts (C++20)\n\n```cpp\ntemplate<typename T>\nconcept Numeric = std::integral<T> || std::floating_point<T>;\n\ntemplate<Numeric T>\nT add(T a, T b) {\n    return a + b;\n}\n```\n"}, {"path": "patterns/anti-patterns.md", "category": "patterns", "name": "patterns/anti-patterns", "content": "# C++ Anti-Patterns\n\nCommon mistakes and code smells to avoid in C++ code.\n\n## Raw Pointers for Ownership\n\n```cpp\n// BAD - Manual memory management\nclass Container {\n    int* data;\npublic:\n    Container() : data(new int[100]) {}\n    ~Container() { delete[] data; }  // Easy to forget\n};\n\n// GOOD - Smart pointers\nclass Container {\n    std::unique_ptr<int[]> data;\npublic:\n    Container() : data(std::make_unique<int[]>(100)) {}\n    // Destructor automatically handles cleanup\n};\n```\n\n## Not Following Rule of Three/Five/Zero\n\n```cpp\n// BAD - Missing copy/move operations\nclass Resource {\n    int* ptr;\npublic:\n    Resource() : ptr(new int(42)) {}\n    ~Resource() { delete ptr; }\n    // Missing: copy constructor, copy assignment,\n    // move constructor, move assignment\n};\n\nResource a;\nResource b = a;  // Double-free bug!\n\n// GOOD - Rule of Zero with smart pointer\nclass Resource {\n    std::unique_ptr<int> ptr;\npublic:\n    Resource() : ptr(std::make_unique<int>(42)) {}\n    // Compiler generates correct copy/move operations\n};\n```\n\n## Using C-Style Arrays\n\n```cpp\n// BAD - No bounds checking, size not tracked\nint arr[100];\narr[150] = 42;  // Buffer overflow, undefined behavior\n\n// GOOD - std::array or std::vector\nstd::array<int, 100> arr;\narr.at(150) = 42;  // Throws std::out_of_range\n\nstd::vector<int> vec(100);\nvec.at(150) = 42;  // Throws std::out_of_range\n```\n\n## Returning Reference to Local Variable\n\n```cpp\n// BAD - Undefined behavior\nstd::string& getName() {\n    std::string name = \"John\";\n    return name;  // Reference to destroyed object!\n}\n\n// GOOD - Return by value (move semantics)\nstd::string getName() {\n    std::string name = \"John\";\n    return name;  // Moved, not copied (RVO)\n}\n```\n\n## Not Using const Correctness\n\n```cpp\n// BAD - Can't call on const objects\nclass Data {\n    int value;\npublic:\n    int getValue() { return value; }  // Non-const\n};\n\nvoid process(const Data& d) {\n    d.getValue();  // Error! Can't call non-const method\n}\n\n// GOOD - const-correct\nclass Data {\n    int value;\npublic:\n    int getValue() const { return value; }\n};\n```\n\n## Using new/delete Directly\n\n```cpp\n// BAD - Memory leaks if exception thrown\nvoid process() {\n    int* data = new int[1000];\n    riskyOperation();  // If throws, memory leaked\n    delete[] data;\n}\n\n// GOOD - RAII with smart pointers\nvoid process() {\n    auto data = std::make_unique<int[]>(1000);\n    riskyOperation();  // data cleaned up even if throws\n}\n```\n\n## Catching by Value\n\n```cpp\n// BAD - Slicing and unnecessary copy\ntry {\n    throw DerivedError(\"message\");\n} catch (BaseError e) {  // Sliced to BaseError!\n    // ...\n}\n\n// GOOD - Catch by reference\ntry {\n    throw DerivedError(\"message\");\n} catch (const BaseError& e) {\n    // Polymorphism preserved\n}\n```\n\n## Using NULL Instead of nullptr\n\n```cpp\n// BAD - NULL is just 0, ambiguous\nvoid func(int);\nvoid func(int*);\nfunc(NULL);  // Calls func(int), not func(int*)!\n\n// GOOD - nullptr is type-safe\nfunc(nullptr);  // Calls func(int*)\n```\n\n## Virtual Destructor Missing\n\n```cpp\n// BAD - Undefined behavior on delete\nclass Base {\npublic:\n    ~Base() { }  // Non-virtual\n};\n\nclass Derived : public Base {\n    int* data;\npublic:\n    ~Derived() { delete data; }\n};\n\nBase* ptr = new Derived();\ndelete ptr;  // Only Base destructor called! Memory leak\n\n// GOOD - Virtual destructor\nclass Base {\npublic:\n    virtual ~Base() = default;\n};\n```\n\n## Using std::endl Instead of '\\n'\n\n```cpp\n// BAD - Flushes buffer each time (slow)\nfor (int i = 0; i < 1000; i++) {\n    std::cout << i << std::endl;  // 1000 flushes\n}\n\n// GOOD - Use '\\n', flush when needed\nfor (int i = 0; i < 1000; i++) {\n    std::cout << i << '\\n';\n}\nstd::cout << std::flush;  // One flush at end\n```\n\n## String Comparison with ==\n\n```cpp\n// BAD (C-style strings) - Compares pointers!\nconst char* a = \"hello\";\nconst char* b = \"hello\";\nif (a == b) { }  // Compares addresses, not content\n\n// GOOD for C-style - Use strcmp\nif (strcmp(a, b) == 0) { }\n\n// BETTER - Use std::string\nstd::string a = \"hello\";\nstd::string b = \"hello\";\nif (a == b) { }  // Works correctly\n```\n\n## Implicit Conversions\n\n```cpp\n// BAD - Implicit conversion surprises\nclass FilePath {\npublic:\n    FilePath(const std::string& path) { }  // Implicit\n};\n\nvoid process(const FilePath& path);\nprocess(\"file.txt\");  // Implicit conversion\n\n// GOOD - Explicit constructors\nclass FilePath {\npublic:\n    explicit FilePath(const std::string& path) { }\n};\n\nprocess(\"file.txt\");  // Error!\nprocess(FilePath(\"file.txt\"));  // OK - explicit\n```\n\n## Not Using override Keyword\n\n```cpp\n// BAD - Silent bug if signature doesn't match\nclass Base {\npublic:\n    virtual void process(int x) { }\n};\n\nclass Derived : public Base {\npublic:\n    void process(int x) const { }  // Oops! New method, not override\n};\n\n// GOOD - Compiler catches mismatch\nclass Derived : public Base {\npublic:\n    void process(int x) const override { }  // Error! Signature mismatch\n};\n```\n\n## Using Magic Numbers\n\n```cpp\n// BAD - What does 86400 mean?\nsleep(86400);\n\n// GOOD - Named constants\nconstexpr int SECONDS_PER_DAY = 86400;\nsleep(SECONDS_PER_DAY);\n\n// OR use chrono\nusing namespace std::chrono_literals;\nstd::this_thread::sleep_for(24h);\n```\n\n## Including Entire Namespace\n\n```cpp\n// BAD - Namespace pollution\nusing namespace std;\n// Now count could be std::count or your count\n\n// GOOD - Specific using declarations\nusing std::string;\nusing std::vector;\n\n// OR use qualified names\nstd::vector<std::string> items;\n```\n"}, {"path": "formatters/overview.md", "category": "formatters", "name": "formatters/overview", "content": "# C++ Formatters\n\n## clang-format\n\nSee: https://clang.llvm.org/docs/ClangFormat.html\n"}, {"path": "formatters/clang-format.md", "category": "formatters", "name": "formatters/clang-format", "content": "# clang-format Options\nVersion: 21.1.8\n\nSource: https://clang.llvm.org/docs/ClangFormatStyleOptions.html\n\n\nSee: https://clang.llvm.org/docs/ClangFormatStyleOptions.html\n"}, {"path": "stdlib/overview.md", "category": "stdlib", "name": "stdlib/overview", "content": "# Modern C++ Standard Library\n\n## Core Headers\n\n| Header | Purpose |\n|--------|---------|\n| `<memory>` | Smart pointers |\n| `<string>` | String class |\n| `<string_view>` | Non-owning string reference |\n| `<vector>` | Dynamic array |\n| `<array>` | Fixed-size array |\n| `<map>` / `<unordered_map>` | Associative containers |\n| `<optional>` | Nullable values |\n| `<variant>` | Type-safe union |\n| `<expected>` | Result type (C++23) |\n| `<span>` | Non-owning view |\n| `<ranges>` | Range algorithms |\n| `<format>` | Type-safe formatting |\n| `<filesystem>` | File operations |\n| `<thread>` | Threading |\n| `<mutex>` | Synchronization |\n| `<chrono>` | Time utilities |\n\n## Smart Pointers\n\n```cpp\n#include <memory>\n\n// Unique ownership\nstd::unique_ptr<T> ptr = std::make_unique<T>(args...);\n\n// Shared ownership\nstd::shared_ptr<T> ptr = std::make_shared<T>(args...);\n\n// Non-owning observer\nstd::weak_ptr<T> weak = shared;\n```\n\n## Containers\n\n```cpp\nstd::vector<T> vec;           // Dynamic array\nstd::array<T, N> arr;         // Fixed array\nstd::map<K, V> map;           // Ordered map\nstd::unordered_map<K, V> um;  // Hash map\nstd::set<T> set;              // Ordered set\nstd::deque<T> dq;             // Double-ended queue\n```\n\n## Algorithms\n\n```cpp\n#include <algorithm>\n#include <ranges>\n\n// Classic\nstd::sort(vec.begin(), vec.end());\nauto it = std::find(vec.begin(), vec.end(), value);\n\n// Ranges (C++20)\nstd::ranges::sort(vec);\nauto it = std::ranges::find(vec, value);\n\n// Projections\nstd::ranges::sort(people, {}, &Person::name);\n```\n"}, {"path": "stdlib/headers/index.md", "category": "stdlib", "name": "stdlib/headers/index", "content": "C++ Standard Library headers - cppreference.com\n\n##### [cppreference.com](../../index.html)\n\n[Create account](https://en.cppreference.com/mwiki/index.php?title=Special:UserLogin&returnto=cpp%2Fheader&type=signup)\n\n- [Log in](https://en.cppreference.com/mwiki/index.php?title=Special:UserLogin&returnto=cpp%2Fheader)\n\n##### Namespaces\n\n- [Page](headers.html)\n- [Discussion](../Talk%253Acpp/header.html)\n\n##### Variantsheaders.html#\n\n##### Views\n\n- [View](headers.html)\n- [Edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit)\n- [History](https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=history)\n\n##### Actionsheaders.html#\n\n# C++ Standard Library headers\n\nFrom cppreference.com< [cpp](../cpp.html)[C++](../cpp.html)[Compiler support](compiler_support.html)[Freestanding and hosted](freestanding.html)[Language](language.html)[Standard library](standard_library.html)Standard library headers[Named requirements](iterator/concepts.html)[Feature test macros](experimental/feature_test.html)(C++20)[Language support library](utility.html#Language_support)[Concepts library](concepts.html)(C++20)[Diagnostics library](error.html)[Memory management library](memory.html)[Metaprogramming library](meta.html)(C++11)[General utilities library](utility.html)[Containers library](container.html)[Iterators library](iterator.html)[Ranges library](ranges.html)(C++20)[Algorithms library](algorithm.html)[Strings library](string.html)[Text processing library](text.html)[Numerics library](numeric.html)[Date and time library](chrono.html)[Input/output library](io.html)[Filesystem library](filesystem.html)(C++17)[Concurrency support library](atomic.html)(C++11)[Execution control library](experimental/execution.html)(C++26)[Technical specifications](experimental.html)[Symbols index](symbol_index.html)[External libraries](links/libs.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&action=edit)Standard library headers[Language support](headers.html#Language_support_library)[<cfloat>](header/cfloat.html)[<climits>](header/climits.html)[<compare>](header/compare.html)(C++20)[<contracts>](header/contracts.html)(C++26)[<coroutine>](header/coroutine.html)(C++20)[<csetjmp>](header/csetjmp.html)[<csignal>](header/csignal.html)[<cstdarg>](header/cstdarg.html)[<cstddef>](header/cstddef.html)[<cstdint>](header/cstdint.html)(C++11)[<cstdlib>](header/cstdlib.html)[<exception>](header/exception.html)[<initializer_list>](header/initializer_list.html)(C++11)[<limits>](header/limits.html)[<new>](header/new.html)[<source_location>](header/source_location.html)(C++20)[<stdfloat>](header/stdfloat.html)(C++23)[<typeinfo>](header/typeinfo.html)[<version>](header/version.html)(C++20)[Concepts](headers.html#Concepts_library)[<concepts>](header/concepts.html)(C++20)[Diagnostics](headers.html#Diagnostics_library)[<cassert>](header/cassert.html)[<cerrno>](header/cerrno.html)[<debugging>](header/debugging.html)(C++26)[<stacktrace>](header/stacktrace.html)(C++23)[<stdexcept>](header/stdexcept.html)[<system_error>](header/system_error.html)(C++11)[Memory management](headers.html#Memory_management_library)[<memory>](header/memory.html)[<memory_resource>](header/memory_resource.html)(C++17)[<scoped_allocator>](header/scoped_allocator.html)(C++11)[Metaprogramming](headers.html#Metaprogramming_library)[<type_traits>](header/type_traits.html)(C++11)[<ratio>](header/ratio.html)(C++11)\n[General utilities](headers.html#General_utilities_library)[<any>](header/any.html)(C++17)[<bitset>](header/bitset.html)[<bit>](header/bit.html)(C++20)[<charconv>](header/charconv.html)(C++17)[<expected>](header/expected.html)(C++23)[<format>](header/format.html)(C++20)[<functional>](header/functional.html)[<optional>](header/optional.html)(C++17)[<stdbit.h>](header/stdbit.h.html)(C++26)[<tuple>](header/tuple.html)(C++11)[<typeindex>](header/typeindex.html)(C++11)[<utility>](header/utility.html)[<variant>](header/variant.html)(C++17)[Containers](headers.html#Containers_library)[<array>](header/array.html)(C++11)[<deque>](header/deque.html)[<flat_map>](header/flat_map.html)(C++23)[<flat_set>](header/flat_set.html)(C++23)[<forward_list>](header/forward_list.html)(C++11)[<hive>](header/hive.html)(C++26)[<inplace_vector>](header/inplace_vector.html)(C++26)[<list>](header/list.html)[<map>](header/map.html)[<mdspan>](header/mdspan.html)(C++23)[<queue>](header/queue.html)[<set>](header/set.html)[<span>](header/span.html)(C++20)[<stack>](header/stack.html)[<unordered_map>](header/unordered_map.html)(C++11)[<unordered_set>](header/unordered_set.html)(C++11)[<vector>](header/vector.html)[Iterators](headers.html#Iterators_library)[<iterator>](header/iterator.html)[Ranges](headers.html#Ranges_library)[<generator>](header/generator.html)(C++23)[<ranges>](header/ranges.html)(C++20)[Algorithms](headers.html#Algorithms_library)[<algorithm>](header/algorithm.html)[<numeric>](header/numeric.html)[Strings](headers.html#Strings_library)[<cctype>](header/cctype.html)[<cstring>](header/cstring.html)[<cuchar>](header/cuchar.html)(C++11)[<cwchar>](header/cwchar.html)[<cwctype>](header/cwctype.html)[<string_view>](header/string_view.html)(C++17)[<string>](header/string.html)[Text processing](headers.html#Text_processing_library)[<clocale>](header/clocale.html)[<codecvt>](header/codecvt.html)(C++11/17/26*)[<locale>](header/locale.html)[<regex>](header/regex.html)(C++11)[<text_encoding>](header/text_encoding.html)(C++26)[Numerics](headers.html#Numerics_library)[<cfenv>](header/cfenv.html)(C++11)[<cmath>](header/cmath.html)[<complex>](header/complex.html)[<linalg>](header/linalg.html)(C++26)[<numbers>](header/numbers.html)(C++20)[<random>](header/random.html)(C++11)[<simd>](header/simd.html)(C++26)[<stdckdint.h>](header/stdckdint.h.html)(C++26)[<valarray>](header/valarray.html)[Time](headers.html#Time_library)[<chrono>](header/chrono.html)(C++11)[<ctime>](header/ctime.html)[C compatibility](headers.html#C_compatibility_headers)[<ccomplex>](header/ccomplex.html)(C++11/17/20*)[<ciso646>](header/ciso646.html)(until C++20)[<cstdalign>](header/cstdalign.html)(C++11/17/20*)[<cstdbool>](header/cstdbool.html)(C++11/17/20*)[<ctgmath>](header/ctgmath.html)(C++11/17/20*)[Input/output](headers.html#Input.2Foutput_library)[<cinttypes>](header/cinttypes.html)(C++11)[<cstdio>](header/cstdio.html)[<filesystem>](header/filesystem.html)(C++17)[<fstream>](header/fstream.html)[<iomanip>](header/iomanip.html)[<iosfwd>](header/iosfwd.html)[<iostream>](header/iostream.html)[<ios>](header/ios.html)[<istream>](header/istream.html)[<ostream>](header/ostream.html)[<print>](header/print.html)(C++23)[<spanstream>](header/spanstream.html)(C++23)[<sstream>](header/sstream.html)[<streambuf>](header/streambuf.html)[<strstream>](header/strstream.html)(C++98/26*)[<syncstream>](header/syncstream.html)(C++20)[Concurrency support](headers.html#Concurrency_support_library)[<atomic>](header/atomic.html)(C++11)[<barrier>](header/barrier.html)(C++20)[<condition_variable>](header/condition_variable.html)(C++11)[<future>](header/future.html)(C++11)[<hazard_pointer>](header/hazard_pointer.html)(C++26)[<latch>](header/latch.html)(C++20)[<mutex>](header/mutex.html)(C++11)[<rcu>](header/rcu.html)(C++26)[<semaphore>](header/semaphore.html)(C++20)[<shared_mutex>](header/shared_mutex.html)(C++14)[<stdatomic.h>](header/stdatomic.h.html)(C++23)[<stop_token>](header/stop_token.html)(C++20)[<thread>](header/thread.html)(C++11)[Execution support](headers.html#Multi-purpose_headers)[<execution>](header/execution.html)(C++17)\n\n[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/navbar_content&action=edit)\n\nThe interface of C++ standard library is defined by the following collection of headers. \n\n## Contents\n\n- [1 Multi-purpose headers](headers.html#Multi-purpose_headers)\n- [2 Language support library](headers.html#Language_support_library)\n- [3 Concepts library](headers.html#Concepts_library)\n- [4 Diagnostics library](headers.html#Diagnostics_library)\n- [5 Memory management library](headers.html#Memory_management_library)\n- [6 Metaprogramming library](headers.html#Metaprogramming_library)\n- [7 General utilities library](headers.html#General_utilities_library)\n- [8 Containers library](headers.html#Containers_library)\n- [9 Iterators library](headers.html#Iterators_library)\n- [10 Ranges library](headers.html#Ranges_library)\n- [11 Algorithms library](headers.html#Algorithms_library)\n- [12 Strings library](headers.html#Strings_library)\n- [13 Text processing library](headers.html#Text_processing_library)\n- [14 Numerics library](headers.html#Numerics_library)\n- [15 Time library](headers.html#Time_library)\n- [16 Input/output library](headers.html#Input.2Foutput_library)\n- [17 Concurrency support library](headers.html#Concurrency_support_library)\n- [18 C compatibility headers](headers.html#C_compatibility_headers)\n\n  - [18.1 Special C compatibility headers](headers.html#Special_C_compatibility_headers)\n  - [18.2 Empty C headers](headers.html#Empty_C_headers)\n  - [18.3 Meaningless C headers](headers.html#Meaningless_C_headers)\n  - [18.4 Unsupported C headers](headers.html#Unsupported_C_headers)\n\n- [19 Experimental libraries](headers.html#Experimental_libraries)\n- [20 See also](headers.html#See_also)\n\n### Multi-purpose headers\n\n[<cstdlib>](header/cstdlib.html) General purpose utilities: [program control](utility/program.html), [dynamic memory allocation](memory/c.html), [random numbers](numeric/random.html#C_random_library), [sort and search](algorithm.html#C_library)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstdlib&action=edit)[<execution>](header/execution.html)(C++17) Predefined execution policies for parallel versions of the algorithms and execution control components(since C++26)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_execution&action=edit)\n\n### Language support library\n\n[<cfloat>](header/cfloat.html)[Limits of floating-point types](types/climits.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cfloat&action=edit)[<climits>](header/climits.html)[Limits of integral types](types/climits.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_climits&action=edit)[<compare>](header/compare.html)(C++20)[Three-way comparison operator](language/operator_comparison.html#Three-way_comparison) support[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_compare&action=edit)[<contracts>](header/contracts.html)(C++26)[Contracts support library](contract.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_contracts&action=edit)[<coroutine>](header/coroutine.html)(C++20)[Coroutine support library](coroutine.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_coroutine&action=edit)[<csetjmp>](header/csetjmp.html)[Macro (and function) that saves (and jumps) to an execution context](utility/program/setjmp.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_csetjmp&action=edit)[<csignal>](header/csignal.html)[Functions and macro constants for signal management](utility/program.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_csignal&action=edit)[<cstdarg>](header/cstdarg.html)[Handling of variable length argument lists](utility/variadic.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstdarg&action=edit)[<cstddef>](header/cstddef.html)[Standard macros and typedefs](utility/rtti.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstddef&action=edit)[<cstdint>](header/cstdint.html)(C++11)[Fixed-width integer types](types/integer.html) and [limits of other types](types/climits.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstdint&action=edit)[<exception>](header/exception.html)[Exception handling utilities](error.html#Exception_handling)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_exception&action=edit)[<initializer_list>](header/initializer_list.html)(C++11)[std::initializer_list](utility/initializer_list.html) class template[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_initializer_list&action=edit)[<limits>](header/limits.html)[Query properties of arithmetic types](types/numeric_limits.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_limits&action=edit)[<new>](header/new.html)[Low-level memory management utilities](memory/new.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_new&action=edit)[<source_location>](header/source_location.html)(C++20) Supplies means to obtain [source code location](utility/source_location.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_source_location&action=edit)[<stdfloat>](header/stdfloat.html)(C++23)[Fixed-width floating-point types](types/floating-point.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdfloat&action=edit)[<typeindex>](header/typeindex.html)(C++11)[std::type_index](types/type_index.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_typeindex&action=edit)[<typeinfo>](header/typeinfo.html)[Runtime type information utilities](utility/rtti.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_typeinfo&action=edit)[<version>](header/version.html)(C++20) Supplies macros for verifying implementation status of library[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_version&action=edit)\n\n### Concepts library\n\n[<concepts>](header/concepts.html)(C++20)[Fundamental library concepts](concepts.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_concepts&action=edit)\n\n### Diagnostics library\n\n[<cassert>](header/cassert.html)[Conditionally compiled macro that compares its argument to zero](error/assert.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cassert&action=edit)[<cerrno>](header/cerrno.html)[Macro containing the last error number](error/errno.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cerrno&action=edit)[<debugging>](header/debugging.html)(C++26) Debugging library[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_debugging&action=edit)[<stacktrace>](header/stacktrace.html)(C++23)[Stacktrace](utility/basic_stacktrace.html) library[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stacktrace&action=edit)[<stdexcept>](header/stdexcept.html)[Standard exception types](error.html#Exception_categories)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdexcept&action=edit)[<system_error>](header/system_error.html)(C++11) Defines [std::error_code](error/error_code.html), a platform-dependent error code[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_system_error&action=edit)\n\n### Memory management library\n\n[<memory>](header/memory.html)[High-level memory management utilities](memory.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_memory&action=edit)[<memory_resource>](header/memory_resource.html)(C++17)[Polymorphic allocators and memory resources](memory/memory_resource.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_memory_resource&action=edit)[<scoped_allocator>](header/scoped_allocator.html)(C++11)[Nested allocator class](memory/scoped_allocator_adaptor.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_scoped_allocator&action=edit)\n\n### Metaprogramming library\n\n[<ratio>](header/ratio.html)(C++11)[Compile-time rational arithmetic](utility/ratio.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ratio&action=edit)[<type_traits>](header/type_traits.html)(C++11)[Compile-time type information utilities](utility/rtti.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_type_traits&action=edit)\n\n### General utilities library\n\n[<any>](header/any.html)(C++17)[std::any](utility/any.html) class[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_any&action=edit)[<bit>](header/bit.html)(C++20)[Bit manipulation](numeric.html#Bit_manipulation_.28since_C.2B.2B20.29) functions[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_bit&action=edit)[<bitset>](header/bitset.html)[std::bitset](utility/bitset.html) class template[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_bitset&action=edit)[<expected>](header/expected.html)(C++23)std::expected class template[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_expected&action=edit)[<functional>](header/functional.html)[Function objects, Function invocations, Bind operations and Reference wrappers](functional.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_functional&action=edit)[<optional>](header/optional.html)(C++17)[std::optional](utility/optional.html) class template[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_optional&action=edit)[<tuple>](header/tuple.html)(C++11)[std::tuple](utility/tuple.html) class template[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_tuple&action=edit)[<utility>](header/utility.html) Various [utility components](utility.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_utility&action=edit)[<variant>](header/variant.html)(C++17)[std::variant](utility/variant.html) class template[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_variant&action=edit)\n\n### Containers library\n\n[<array>](header/array.html)(C++11)[std::array](container/array.html) container[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_array&action=edit)[<deque>](header/deque.html)[std::deque](container/deque.html) container[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_deque&action=edit)[<flat_map>](header/flat_map.html)(C++23)std::flat_map and std::flat_multimap container adaptors[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_flat_map&action=edit)[<flat_set>](header/flat_set.html)(C++23)std::flat_set and std::flat_multiset container adaptors[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_flat_set&action=edit)[<forward_list>](header/forward_list.html)(C++11)[std::forward_list](container/forward_list.html) container[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_forward_list&action=edit)[<hive>](header/hive.html)(C++26)std::hive container[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_hive&action=edit)[<inplace_vector>](header/inplace_vector.html)(C++26)std::inplace_vector container[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_inplace_vector&action=edit)[<list>](header/list.html)[std::list](container/list.html) container[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_list&action=edit)[<map>](header/map.html)[std::map](container/map.html) and [std::multimap](container/multimap.html) associative containers[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_map&action=edit)[<mdspan>](header/mdspan.html)(C++23)std::mdspan view[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_mdspan&action=edit)[<queue>](header/queue.html)[std::queue](container/queue.html) and [std::priority_queue](container/priority_queue.html) container adaptors[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_queue&action=edit)[<set>](header/set.html)[std::set](container/set.html) and [std::multiset](container/multiset.html) associative containers[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_set&action=edit)[<span>](header/span.html)(C++20)std::span view[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_span&action=edit)[<stack>](header/stack.html)[std::stack](container/stack.html) container adaptor[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stack&action=edit)[<unordered_map>](header/unordered_map.html)(C++11)[std::unordered_map](container/unordered_map.html) and [std::unordered_multimap](container/unordered_multimap.html) unordered associative containers[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_unordered_map&action=edit)[<unordered_set>](header/unordered_set.html)(C++11)[std::unordered_set](container/unordered_set.html) and [std::unordered_multiset](container/unordered_multiset.html) unordered associative containers[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_unordered_set&action=edit)[<vector>](header/vector.html)[std::vector](container/vector.html) container[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_vector&action=edit)\n\n### Iterators library\n\n[<iterator>](header/iterator.html)[Range iterators](iterator.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_iterator&action=edit)\n\n### Ranges library\n\n[<generator>](header/generator.html)(C++23)std::generator class template[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_generator&action=edit)[<ranges>](header/ranges.html)(C++20)[Range access, primitives, requirements, utilities and adaptors](ranges.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ranges&action=edit)\n\n### Algorithms library\n\n[<algorithm>](header/algorithm.html)[Algorithms that operate on ranges](algorithm.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_algorithm&action=edit)[<numeric>](header/numeric.html)[Numeric operations on values in ranges](numeric.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_numeric&action=edit)\n\n### Strings library\n\n[<cstring>](header/cstring.html) Various [narrow character string handling functions](string/byte.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstring&action=edit)[<string>](header/string.html)[std::basic_string](string/basic_string.html) class template[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_string&action=edit)[<string_view>](header/string_view.html)(C++17)[std::basic_string_view](string/basic_string_view.html) class template[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_string_view&action=edit)\n\n### Text processing library\n\n[<cctype>](header/cctype.html)[Functions to determine the category of narrow characters](string/byte.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cctype&action=edit)[<charconv>](header/charconv.html)(C++17)std::to_chars and std::from_chars[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_charconv&action=edit)[<clocale>](header/clocale.html)[C localization utilities](locale.html#C_library_locales)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_clocale&action=edit)[<codecvt>](header/codecvt.html)(C++11)(deprecated in C++17)(removed in C++26)[Unicode conversion facilities](locale.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_codecvt&action=edit)[<cuchar>](header/cuchar.html)(C++11) C-style [Unicode character conversion functions](string/multibyte.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cuchar&action=edit)[<cwchar>](header/cwchar.html) Various [wide](string/wide.html) and [multibyte](string/multibyte.html) string handling functions[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cwchar&action=edit)[<cwctype>](header/cwctype.html)[Functions to determine the category of wide characters](string/wide.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cwctype&action=edit)[<format>](header/format.html)(C++20)[Formatting library](utility/format.html) including [std::format](utility/format/format.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_format&action=edit)[<locale>](header/locale.html)[Localization utilities](locale.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_locale&action=edit)[<regex>](header/regex.html)(C++11)[Classes, algorithms and iterators to support regular expression processing](regex.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_regex&action=edit)[<text_encoding>](header/text_encoding.html)(C++26) Text encoding identifications[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_text_encoding&action=edit)\n\n### Numerics library\n\n[<cfenv>](header/cfenv.html)(C++11)[Floating-point environment](numeric/fenv.html) access functions[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cfenv&action=edit)[<cmath>](header/cmath.html)[Common mathematics functions](numeric/math.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cmath&action=edit)[<complex>](header/complex.html)[Complex number type](numeric/complex.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_complex&action=edit)[<linalg>](header/linalg.html)(C++26)[Basic linear algebra algorithms (BLAS)](numeric/linalg.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_linalg&action=edit)[<numbers>](header/numbers.html)(C++20)[Math constants](numeric/constants.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_numbers&action=edit)[<random>](header/random.html)(C++11)[Random number generators and distributions](numeric/random.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_random&action=edit)[<simd>](header/simd.html)(C++26)[Data-parallel types and operations on these types](numeric/simd.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_simd&action=edit)[<valarray>](header/valarray.html)[Class for representing and manipulating arrays of values](numeric/valarray.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_valarray&action=edit)\n\n### Time library\n\n[<chrono>](header/chrono.html)(C++11)[C++ time utilities](chrono.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_chrono&action=edit)[<ctime>](header/ctime.html)[C-style time/date utilities](chrono/c.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ctime&action=edit)\n\n### Input/output library\n\n[<cinttypes>](header/cinttypes.html)(C++11)[Formatting macros](types/integer.html#Format_macro_constants), `intmax_t` and `uintmax_t` math and conversions[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cinttypes&action=edit)[<cstdio>](header/cstdio.html)[C-style input-output functions](io/c.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstdio&action=edit)[<filesystem>](header/filesystem.html)(C++17)[std::filesystem::path](filesystem/path.html) class and [supporting functions](filesystem.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_filesystem&action=edit)[<fstream>](header/fstream.html)[std::basic_fstream](io/basic_fstream.html), [std::basic_ifstream](io/basic_ifstream.html), [std::basic_ofstream](io/basic_ofstream.html) class templates and typedefs[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_fstream&action=edit)[<iomanip>](header/iomanip.html)[Helper functions to control the format of input and output](io/manip.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_iomanip&action=edit)[<ios>](header/ios.html)[std::ios_base](io/ios_base.html) class, [std::basic_ios](io/basic_ios.html) class template and typedefs[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ios&action=edit)[<iosfwd>](header/iosfwd.html) Forward declarations of all classes in the input/output library[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_iosfwd&action=edit)[<iostream>](header/iostream.html) Several standard stream objects[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_iostream&action=edit)[<istream>](header/istream.html)[std::basic_istream](io/basic_istream.html) class template and typedefs[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_istream&action=edit)[<ostream>](header/ostream.html)[std::basic_ostream](io/basic_ostream.html), [std::basic_iostream](io/basic_iostream.html) class templates and typedefs[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ostream&action=edit)[<print>](header/print.html)(C++23) Formatted output library including std::print[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_print&action=edit)[<spanstream>](header/spanstream.html)(C++23)std::basic_spanstream, std::basic_ispanstream, std::basic_ospanstream class templates and typedefs[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_spanstream&action=edit)[<sstream>](header/sstream.html)[std::basic_stringstream](io/basic_stringstream.html), [std::basic_istringstream](io/basic_istringstream.html), [std::basic_ostringstream](io/basic_ostringstream.html) class templates and typedefs[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_sstream&action=edit)[<streambuf>](header/streambuf.html)[std::basic_streambuf](io/basic_streambuf.html) class template[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_streambuf&action=edit)[<strstream>](header/strstream.html)(deprecated in C++98)(removed in C++26)[std::strstream](io/strstream.html), [std::istrstream](io/istrstream.html), [std::ostrstream](io/ostrstream.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_strstream&action=edit)[<syncstream>](header/syncstream.html)(C++20)std::basic_osyncstream, std::basic_syncbuf and typedefs[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_syncstream&action=edit)\n\n### Concurrency support library\n\n[<atomic>](header/atomic.html)(C++11)[Atomic operations library](atomic.html#Atomic_operations)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_atomic&action=edit)[<barrier>](header/barrier.html)(C++20)[Barriers](thread/barrier.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_barrier&action=edit)[<condition_variable>](header/condition_variable.html)(C++11)[Thread waiting conditions](atomic.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_condition_variable&action=edit)[<future>](header/future.html)(C++11)[Primitives for asynchronous computations](atomic.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_future&action=edit)[<hazard_pointer>](header/hazard_pointer.html)(C++26) Hazard pointers[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_hazard_pointer&action=edit)[<latch>](header/latch.html)(C++20)[Latches](thread/latch.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_latch&action=edit)[<mutex>](header/mutex.html)(C++11)[Mutual exclusion primitives](atomic.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_mutex&action=edit)[<rcu>](header/rcu.html)(C++26) Read-copy update mechanisms[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_rcu&action=edit)[<semaphore>](header/semaphore.html)(C++20)[Semaphores](thread/counting_semaphore.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_semaphore&action=edit)[<shared_mutex>](header/shared_mutex.html)(C++14)[Shared mutual exclusion primitives](atomic.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_shared_mutex&action=edit)[<stop_token>](header/stop_token.html)(C++20) Stop tokens for [std::jthread](thread/jthread.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stop_token&action=edit)[<thread>](header/thread.html)(C++11)[std::thread](thread/thread.html) class and [supporting functions](atomic.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_thread&action=edit)\n\n### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=1)]C compatibility headers\n\nFor some of the C standard library headers of the form `xxx.h`, the C++ standard library both includes an identically-named header and another header of the form `cxxx` (all meaningful `cxxx` headers are listed above). The intended use of headers of form `xxx.h` is for interoperability only. It is possible that C++ source files need to include one of these headers in order to be valid ISO C. Source files that are not intended to also be valid ISO C should not use any of the C headers. \n\nWith the exception of [complex.h](header/ccomplex.html), each `xxx.h` header included in the C++ standard library places in the global namespace each name that the corresponding `cxxx` header would have placed in the std namespace. \n\nThese headers are allowed to also declare the same names in the std namespace, and the corresponding `cxxx` headers are allowed to also declare the same names in the global namespace: including [<cstdlib>](header/cstdlib.html) definitely provides [std::malloc](memory/c/malloc.html) and may also provide ::malloc. Including [<stdlib.h>](../c/header/stdlib.html) definitely provides ::malloc and may also provide [std::malloc](memory/c/malloc.html). This applies even to functions and function overloads that are not part of C standard library. \n\nNotes: `xxx.h` headers are deprecated in C++98 and undeprecated in C++23. These headers are discouraged for pure C++ code, but not subject to future removal. \n\n[<assert.h>](header/cassert.html) Behaves same as [<cassert>](header/cassert.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_assert.h&action=edit)[<ctype.h>](header/cctype.html) Behaves as if each name from [<cctype>](header/cctype.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ctype.h&action=edit)[<errno.h>](header/cerrno.html) Behaves same as [<cerrno>](header/cerrno.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_errno.h&action=edit)[<fenv.h>](header/cfenv.html)(C++11) Behaves as if each name from [<cfenv>](header/cfenv.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_fenv.h&action=edit)[<float.h>](header/cfloat.html) Behaves same as [<cfloat>](header/cfloat.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_float.h&action=edit)[<inttypes.h>](header/cinttypes.html)(C++11) Behaves as if each name from [<cinttypes>](header/cinttypes.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_inttypes.h&action=edit)[<limits.h>](header/climits.html) Behaves same as [<climits>](header/climits.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_limits.h&action=edit)[<locale.h>](header/clocale.html) Behaves as if each name from [<clocale>](header/clocale.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_locale.h&action=edit)[<math.h>](header/cmath.html) Behaves as if each name from [<cmath>](header/cmath.html) is placed in global namespace,\nexcept for names of [mathematical special functions](numeric/special_math.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_math.h&action=edit)[<setjmp.h>](header/csetjmp.html) Behaves as if each name from [<csetjmp>](header/csetjmp.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_setjmp.h&action=edit)[<signal.h>](header/csignal.html) Behaves as if each name from [<csignal>](header/csignal.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_signal.h&action=edit)[<stdarg.h>](header/cstdarg.html) Behaves as if each name from [<cstdarg>](header/cstdarg.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdarg.h&action=edit)[<stddef.h>](header/cstddef.html) Behaves as if each name from [<cstddef>](header/cstddef.html) is placed in global namespace,\nexcept for names of [std::byte and related functions](types/byte.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stddef.h&action=edit)[<stdint.h>](header/cstdint.html)(C++11) Behaves as if each name from [<cstdint>](header/cstdint.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdint.h&action=edit)[<stdio.h>](header/cstdio.html) Behaves as if each name from [<cstdio>](header/cstdio.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdio.h&action=edit)[<stdlib.h>](header/cstdlib.html) Behaves as if each name from [<cstdlib>](header/cstdlib.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdlib.h&action=edit)[<string.h>](header/cstring.html) Behaves as if each name from [<cstring>](header/cstring.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_string.h&action=edit)[<time.h>](header/ctime.html) Behaves as if each name from [<ctime>](header/ctime.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_time.h&action=edit)[<uchar.h>](header/cuchar.html)(C++11) Behaves as if each name from [<cuchar>](header/cuchar.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_uchar.h&action=edit)[<wchar.h>](header/cwchar.html) Behaves as if each name from [<cwchar>](header/cwchar.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_wchar.h&action=edit)[<wctype.h>](header/cwctype.html) Behaves as if each name from [<cwctype>](header/cwctype.html) is placed in global namespace[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_wctype.h&action=edit)\n\n#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=2)]Special C compatibility headers\n\nThe headers [<stdatomic.h>](../c/header/stdatomic.html), [<stdbit.h>](../c/header/stdbit.html), and [<stdckdint.h>](../c/header/stdckdint.html) declare names which are also provided in the C standard library. The header [<stdatomic.h>](../c/header/stdatomic.html) also defines the [_Atomic](../c/keyword/_Atomic.html) macro which is a [keyword](../c/keyword.html) in C. Unlike other `<xxx.h>` headers, corresponding `<cstdatomic>`, `<cstdbit>`, and `<cstdckdint>` are not provided. \n\n[<stdatomic.h>](header/stdatomic.h.html)(C++23) Defines `_Atomic` and provides corresponding components in the C standard library[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdatomic.h&action=edit)[<stdbit.h>](header/stdbit.h.html)(C++26) Provides corresponding components in the C standard library[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdbit.h&action=edit)[<stdckdint.h>](header/stdckdint.h.html)(C++26) Provides corresponding components in the C standard library[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdckdint.h&action=edit)\n\n#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=3)]Empty C headers\n\nThe headers [<complex.h>](../c/header/complex.html), [<ccomplex>](header/ccomplex.html), [<tgmath.h>](../c/header/tgmath.html), and [<ctgmath>](header/ctgmath.html) do not contain any content from the C standard library and instead merely include other headers from the C++ standard library. \n\n[<ccomplex>](header/ccomplex.html)(C++11)(deprecated in C++17)(removed in C++20) Simply includes the header [<complex>](header/complex.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ccomplex&action=edit)[<complex.h>](header/ccomplex.html)(C++11) Simply includes the header [<complex>](header/complex.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_complex.h&action=edit)[<ctgmath>](header/ctgmath.html)(C++11)(deprecated in C++17)(removed in C++20) Simply includes the headers [<complex>](header/complex.html) and [<cmath>](header/cmath.html): the overloads equivalent to the contents of the C header [<tgmath.h>](../c/header/tgmath.html) are already provided by those headers[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ctgmath&action=edit)[<tgmath.h>](header/ctgmath.html)(C++11) Simply includes the headers [<complex>](header/complex.html) and [<cmath>](header/cmath.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_tgmath.h&action=edit)\n\n#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=4)]Meaningless C headers\n\nThe headers [<ciso646>](header/ciso646.html), [<cstdalign>](header/cstdalign.html), and [<cstdbool>](header/cstdbool.html) are meaningless in C++ because the macros they provide in C are language keywords in C++. \n\n[<ciso646>](header/ciso646.html)(removed in C++20) Empty header. [The macros that appear in iso646.h in C](../c/language/operator_alternative.html) are [keywords in C++](language/operator_alternative.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ciso646&action=edit)[<cstdalign>](header/cstdalign.html)(C++11)(deprecated in C++17)(removed in C++20) Defines [compatibility macro constants  __alignas_is_defined and __alignof_is_defined](utility/rtti.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstdalign&action=edit)[<cstdbool>](header/cstdbool.html)(C++11)(deprecated in C++17)(removed in C++20) Defines a [compatibility macro constant __bool_true_false_are_defined](utility/rtti.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstdbool&action=edit)[<iso646.h>](header/ciso646.html) Has no effect[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_iso646.h&action=edit)[<stdalign.h>](header/cstdalign.html)(C++11) Defines [compatibility macro constants  __alignas_is_defined and __alignof_is_defined](utility/rtti.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdalign.h&action=edit)[<stdbool.h>](header/cstdbool.html)(C++11) Defines a [compatibility macro constant __bool_true_false_are_defined](utility/rtti.html)[[edit]](https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdbool.h&action=edit)\n\n#### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=5)]Unsupported C headers\n\nThe C headers [<stdatomic.h>](../c/header/stdatomic.html),(until C++23)[<stdnoreturn.h>](../c/header/stdnoreturn.html), and [<threads.h>](../c/header/threads.html) are not included in C++ and have no `cxxx` equivalents. \n\n### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=6)][Experimental libraries](header/experimental.html)\n\n[C++ TR's/TS's](experimental.html) also define several collections of headers. \n\n### [[edit](https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=7)]See also\n\n[C documentation](../c/header.html) for Standard Library headers Retrieved from \"[https://en.cppreference.com/mwiki/index.php?title=cpp/header&oldid=182846](https://en.cppreference.com/mwiki/index.php?title=cpp/header&oldid=182846)\" Hidden category: \n\n- [Pages with unreviewed LWG DR marker](../Category%253APages_with_unreviewed_LWG_DR_marker.html)\n\n##### Navigation\n\n- [Support us](http://www.cppreference.com/support)\n- [Recent changes](https://en.cppreference.com/w/Special:RecentChanges)\n- [FAQ](../Cppreference%253AAbout.html)\n- [Offline version](../Cppreference%253AArchives.html)\n\n##### Toolboxheaders.html#\n\n- [What links here](https://en.cppreference.com/w/Special:WhatLinksHere/cpp/header)\n- [Related changes](https://en.cppreference.com/w/Special:RecentChangesLinked/cpp/header)\n- [Upload file](http://upload.cppreference.com/w/Special:Upload)\n- [Special pages](https://en.cppreference.com/w/Special:SpecialPages)\n- [Printable version](https://en.cppreference.com/mwiki/index.php?title=cpp/header&printable=yes)\n- [Permanent link](https://en.cppreference.com/mwiki/index.php?title=cpp/header&oldid=182846)\n- [Page information](https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=info)\n\n- In other languages\n\n- [\u0627\u0644\u0639\u0631\u0628\u064a\u0629](http://ar.cppreference.com/w/cpp/header)\n- [Deutsch](http://de.cppreference.com/w/cpp/header)\n- [Espa\u00f1ol](http://es.cppreference.com/w/cpp/header)\n- [Fran\u00e7ais](http://fr.cppreference.com/w/cpp/header)\n- [Italiano](http://it.cppreference.com/w/cpp/header)\n- [\u65e5\u672c\u8a9e](http://ja.cppreference.com/w/cpp/header)\n- [Portugu\u00eas](http://pt.cppreference.com/w/cpp/header)\n- [\u0420\u0443\u0441\u0441\u043a\u0438\u0439](http://ru.cppreference.com/w/cpp/header)\n- [\u4e2d\u6587](http://zh.cppreference.com/w/cpp/header)\n\n-  This page was last modified on 26 April 2025, at 09:49.\n\n- [Privacy policy](../Cppreference%253APrivacy_policy.html)\n- [About cppreference.com](../Cppreference%253AAbout.html)\n- [Disclaimers](../Cppreference%253AGeneral_disclaimer.html)\n\n- https://www.mediawiki.org/http://qbnz.com/highlighter/http://www.tigertech.net/referral/cppreference.com\n"}, {"path": "spec.md", "category": "spec", "name": "spec", "content": "# C++ Language Specification Summary\nVersion: c++23\n\nSource: https://en.cppreference.com/w/cpp\n\n\nBased on C++23 (ISO/IEC 14882:2024)\n\n## Keywords (C++23)\n\n```cpp\nalignas         alignof         and             and_eq\nasm             auto            bitand          bitor\nbool            break           case            catch\nchar            char8_t         char16_t        char32_t\nclass           compl           concept         const\nconsteval       constexpr       constinit       const_cast\ncontinue        co_await        co_return       co_yield\ndecltype        default         delete          do\ndouble          dynamic_cast    else            enum\nexplicit        export          extern          false\nfloat           for             friend          goto\nif              inline          int             long\nmutable         namespace       new             noexcept\nnot             not_eq          nullptr         operator\nor              or_eq           private         protected\npublic          register        reinterpret_cast requires\nreturn          short           signed          sizeof\nstatic          static_assert   static_cast     struct\nswitch          template        this            thread_local\nthrow           true            try             typedef\ntypeid          typename        union           unsigned\nusing           virtual         void            volatile\nwchar_t         while           xor             xor_eq\n```\n\n## Types\n\n### Fundamental Types\n\n```cpp\n// Boolean\nbool                    // true or false\n\n// Characters\nchar                    // at least 8 bits\nwchar_t                 // wide character\nchar8_t                 // UTF-8 (C++20)\nchar16_t                // UTF-16\nchar32_t                // UTF-32\n\n// Integers\nshort                   // at least 16 bits\nint                     // at least 16 bits\nlong                    // at least 32 bits\nlong long               // at least 64 bits\n\n// Floating point\nfloat                   // single precision\ndouble                  // double precision\nlong double             // extended precision\n\n// Void\nvoid                    // no type/value\n\n// Null pointer\nstd::nullptr_t          // type of nullptr\n```\n\n### Fixed-Width Types\n\n```cpp\n#include <cstdint>\n\nint8_t      int16_t     int32_t     int64_t\nuint8_t     uint16_t    uint32_t    uint64_t\nintptr_t    uintptr_t\nsize_t      ptrdiff_t\n```\n\n### Type Aliases\n\n```cpp\nusing IntPtr = int*;\nusing Callback = void(*)(int);\nusing StringVector = std::vector<std::string>;\n\n// Template alias\ntemplate<typename T>\nusing Vec = std::vector<T>;\n```\n\n## Auto and Decltype\n\n```cpp\n// Type inference\nauto x = 42;            // int\nauto y = 3.14;          // double\nauto z = \"hello\";       // const char*\nauto v = std::vector{1, 2, 3};  // std::vector<int>\n\n// Decltype\nint x = 0;\ndecltype(x) y = 1;      // int\ndecltype(auto) z = x;   // int (preserves value category)\n\n// Trailing return type\nauto add(int a, int b) -> int {\n    return a + b;\n}\n\n// C++14: return type deduction\nauto add(int a, int b) {\n    return a + b;\n}\n```\n\n## Classes\n\n### Basic Class\n\n```cpp\nclass Widget {\npublic:\n    Widget();                           // default constructor\n    Widget(int value);                  // parameterized constructor\n    Widget(const Widget& other);        // copy constructor\n    Widget(Widget&& other) noexcept;    // move constructor\n    ~Widget();                          // destructor\n    \n    Widget& operator=(const Widget& other);     // copy assignment\n    Widget& operator=(Widget&& other) noexcept; // move assignment\n    \n    int getValue() const;\n    void setValue(int value);\n    \nprivate:\n    int value_;\n    std::string name_;\n};\n```\n\n### Rule of Zero/Five\n\n```cpp\n// Rule of Zero: Use RAII, no manual resource management\nclass Good {\n    std::string name;\n    std::vector<int> data;\n    std::unique_ptr<Resource> resource;\n    // No destructor, copy/move ops needed\n};\n\n// Rule of Five: If you define one, define all\nclass Manual {\n    int* data;\npublic:\n    Manual() : data(new int[100]) {}\n    ~Manual() { delete[] data; }\n    Manual(const Manual& other);\n    Manual& operator=(const Manual& other);\n    Manual(Manual&& other) noexcept;\n    Manual& operator=(Manual&& other) noexcept;\n};\n```\n\n### Inheritance\n\n```cpp\nclass Base {\npublic:\n    virtual void method() = 0;      // pure virtual\n    virtual void other() {}         // virtual with default\n    void concrete() {}              // non-virtual\n    virtual ~Base() = default;      // virtual destructor\n};\n\nclass Derived : public Base {\npublic:\n    void method() override;         // override\n    void other() final;             // can't be overridden further\n};\n```\n\n## Templates\n\n### Function Templates\n\n```cpp\ntemplate<typename T>\nT max(T a, T b) {\n    return a > b ? a : b;\n}\n\n// With concepts (C++20)\ntemplate<typename T>\nrequires std::integral<T>\nT gcd(T a, T b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\n// Abbreviated function template (C++20)\nauto add(auto a, auto b) {\n    return a + b;\n}\n```\n\n### Class Templates\n\n```cpp\ntemplate<typename T, size_t N>\nclass Array {\n    T data[N];\npublic:\n    T& operator[](size_t i) { return data[i]; }\n    constexpr size_t size() const { return N; }\n};\n\n// Deduction guides (C++17)\ntemplate<typename T, typename... Args>\nArray(T, Args...) -> Array<T, 1 + sizeof...(Args)>;\n```\n\n### Concepts (C++20)\n\n```cpp\ntemplate<typename T>\nconcept Numeric = std::integral<T> || std::floating_point<T>;\n\ntemplate<typename T>\nconcept Printable = requires(T t) {\n    { std::cout << t } -> std::same_as<std::ostream&>;\n};\n\ntemplate<Numeric T>\nT square(T x) {\n    return x * x;\n}\n```\n\n### Variadic Templates\n\n```cpp\ntemplate<typename... Args>\nvoid print(Args... args) {\n    (std::cout << ... << args) << '\\n';  // fold expression\n}\n\n// Pack expansion\ntemplate<typename... Ts>\nauto sum(Ts... args) {\n    return (args + ...);  // unary right fold\n}\n```\n\n## Smart Pointers\n\n```cpp\n#include <memory>\n\n// Unique ownership\nstd::unique_ptr<Widget> p1 = std::make_unique<Widget>();\nauto p2 = std::make_unique<Widget[]>(10);  // array\n\n// Shared ownership\nstd::shared_ptr<Widget> p3 = std::make_shared<Widget>();\nstd::shared_ptr<Widget> p4 = p3;  // both own\n\n// Weak reference (doesn't extend lifetime)\nstd::weak_ptr<Widget> w = p3;\nif (auto p = w.lock()) {\n    // use p\n}\n```\n\n## Move Semantics\n\n```cpp\nclass Buffer {\n    std::unique_ptr<char[]> data_;\n    size_t size_;\n    \npublic:\n    // Move constructor\n    Buffer(Buffer&& other) noexcept\n        : data_(std::move(other.data_))\n        , size_(std::exchange(other.size_, 0))\n    {}\n    \n    // Move assignment\n    Buffer& operator=(Buffer&& other) noexcept {\n        data_ = std::move(other.data_);\n        size_ = std::exchange(other.size_, 0);\n        return *this;\n    }\n};\n\n// Perfect forwarding\ntemplate<typename T, typename... Args>\nstd::unique_ptr<T> make(Args&&... args) {\n    return std::make_unique<T>(std::forward<Args>(args)...);\n}\n```\n\n## Lambda Expressions\n\n```cpp\n// Basic lambda\nauto add = [](int a, int b) { return a + b; };\n\n// With capture\nint x = 10;\nauto addX = [x](int a) { return a + x; };      // capture by value\nauto addX = [&x](int a) { return a + x; };     // capture by reference\nauto addX = [=](int a) { return a + x; };      // capture all by value\nauto addX = [&](int a) { return a + x; };      // capture all by reference\n\n// Mutable lambda\nauto counter = [n = 0]() mutable { return ++n; };\n\n// Generic lambda (C++14)\nauto add = [](auto a, auto b) { return a + b; };\n\n// Template lambda (C++20)\nauto add = []<typename T>(T a, T b) { return a + b; };\n```\n\n## Ranges (C++20)\n\n```cpp\n#include <ranges>\n\nstd::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n// Views\nauto even = v | std::views::filter([](int n) { return n % 2 == 0; });\nauto squared = v | std::views::transform([](int n) { return n * n; });\n\n// Chained\nauto result = v \n    | std::views::filter([](int n) { return n % 2 == 0; })\n    | std::views::transform([](int n) { return n * n; })\n    | std::views::take(3);\n\n// Range algorithms\nstd::ranges::sort(v);\nauto it = std::ranges::find(v, 5);\n```\n\n## Coroutines (C++20)\n\n```cpp\n#include <coroutine>\n#include <generator>  // C++23\n\n// Generator\nstd::generator<int> range(int start, int end) {\n    for (int i = start; i < end; ++i) {\n        co_yield i;\n    }\n}\n\n// Usage\nfor (int i : range(0, 10)) {\n    std::cout << i << '\\n';\n}\n```\n\n## Modules (C++20)\n\n```cpp\n// math.ixx (module interface)\nexport module math;\n\nexport int add(int a, int b) {\n    return a + b;\n}\n\n// main.cpp\nimport math;\n\nint main() {\n    return add(1, 2);\n}\n```\n\n## Structured Bindings (C++17)\n\n```cpp\n// With arrays\nint arr[] = {1, 2, 3};\nauto [a, b, c] = arr;\n\n// With structs\nstruct Point { int x, y; };\nPoint p{10, 20};\nauto [x, y] = p;\n\n// With maps\nstd::map<std::string, int> m;\nfor (const auto& [key, value] : m) {\n    std::cout << key << \": \" << value << '\\n';\n}\n```\n\n## std::optional, variant, expected\n\n```cpp\n// Optional (C++17)\nstd::optional<int> find(const std::vector<int>& v, int target) {\n    auto it = std::find(v.begin(), v.end(), target);\n    if (it != v.end()) return *it;\n    return std::nullopt;\n}\n\n// Variant (C++17)\nstd::variant<int, std::string, double> v = \"hello\";\nstd::visit([](auto&& arg) { std::cout << arg; }, v);\n\n// Expected (C++23)\nstd::expected<int, std::string> divide(int a, int b) {\n    if (b == 0) return std::unexpected(\"division by zero\");\n    return a / b;\n}\n```\n\n## Constexpr and Consteval\n\n```cpp\n// Constexpr: may be evaluated at compile time\nconstexpr int factorial(int n) {\n    return n <= 1 ? 1 : n * factorial(n - 1);\n}\n\nconstexpr int f5 = factorial(5);  // compile-time\nint runtime_n = get_value();\nint fn = factorial(runtime_n);    // runtime OK too\n\n// Consteval (C++20): must be evaluated at compile time\nconsteval int square(int n) {\n    return n * n;\n}\n\nconstexpr int s = square(5);   // OK: compile-time\nint x = 5;\nint y = square(x);             // ERROR: not compile-time\n\n// Constinit (C++20): must be constant initialized\nconstinit int global = 42;     // OK\nconstinit int bad = get();     // ERROR if get() not constexpr\n```\n\n## Attributes\n\n```cpp\n[[nodiscard]] int compute();\n[[nodiscard(\"reason\")]] int compute2();  // C++20\n\n[[deprecated]] void old_func();\n[[deprecated(\"use new_func\")]] void old_func2();\n\n[[maybe_unused]] void callback(int x);\n\n[[noreturn]] void terminate();\n\n[[likely]] if (condition) { }   // C++20\n[[unlikely]] if (error) { }     // C++20\n\n[[assume(x > 0)]]  // C++23\n```\n"}, {"path": "linters/cppcheck/overview.md", "category": "linters", "name": "linters/cppcheck/overview", "content": "# cppcheck Manual\nVersion: 2.19.0\n\nSource: https://cppcheck.sourceforge.io/manual.html\n\n\nSee: https://cppcheck.sourceforge.io/manual.html\n"}, {"path": "linters/cppcheck/errors.md", "category": "linters", "name": "linters/cppcheck/errors", "content": "# cppcheck Error Checks\n\nCritical bugs that will cause crashes or incorrect behavior.\n\n## nullPointer\n\nNull pointer dereference.\n\n```cpp\n// BAD\nint* p = nullptr;\n*p = 5;  // crash\n\nint* getData();\nint x = *getData();  // crash if getData returns null\n\n// GOOD\nint* p = getData();\nif (p != nullptr) {\n    *p = 5;\n}\n```\n\n## nullPointerArithmetic\n\nArithmetic on null pointer.\n\n```cpp\n// BAD\nint* p = nullptr;\nint* q = p + 1;  // undefined behavior\n\n// GOOD\nint arr[10];\nint* p = arr;\nint* q = p + 1;  // OK\n```\n\n## nullPointerRedundantCheck\n\nRedundant null check after dereference.\n\n```cpp\n// BAD - already dereferenced, check is too late\nint x = *p;\nif (p != nullptr) {  // redundant - would have crashed above\n    use(x);\n}\n\n// GOOD - check before dereference\nif (p != nullptr) {\n    int x = *p;\n    use(x);\n}\n```\n\n## uninitvar\n\nUse of uninitialized variable.\n\n```cpp\n// BAD\nint x;\nprintf(\"%d\", x);  // undefined value\n\nint* p;\n*p = 5;  // undefined behavior\n\n// GOOD\nint x = 0;\nprintf(\"%d\", x);\n\nint* p = nullptr;  // or point to valid memory\n```\n\n## uninitMemberVar\n\nUninitialized member variable.\n\n```cpp\n// BAD\nclass Foo {\n    int x;  // never initialized\npublic:\n    Foo() { }  // x is garbage\n};\n\n// GOOD\nclass Foo {\n    int x = 0;\npublic:\n    Foo() = default;\n};\n\n// Or\nclass Foo {\n    int x;\npublic:\n    Foo() : x(0) { }\n};\n```\n\n## uninitStructMember\n\nUninitialized struct member.\n\n```cpp\n// BAD\nstruct Point { int x, y; };\nPoint p;\nprintf(\"%d\", p.x);  // garbage\n\n// GOOD\nPoint p = {0, 0};\nPoint p = {};  // zero-initialized\n```\n\n## memleak\n\nMemory leak - allocated memory not freed.\n\n```cpp\n// BAD\nvoid foo() {\n    char* p = malloc(100);\n    if (error) return;  // leak!\n    free(p);\n}\n\n// GOOD\nvoid foo() {\n    char* p = malloc(100);\n    if (error) {\n        free(p);\n        return;\n    }\n    free(p);\n}\n\n// BETTER - use RAII in C++\nvoid foo() {\n    auto p = std::make_unique<char[]>(100);\n    if (error) return;  // automatically freed\n}\n```\n\n## resourceLeak\n\nResource leak - file handle, socket, etc not closed.\n\n```cpp\n// BAD\nvoid foo() {\n    FILE* f = fopen(\"file\", \"r\");\n    if (error) return;  // leak!\n    fclose(f);\n}\n\n// GOOD\nvoid foo() {\n    FILE* f = fopen(\"file\", \"r\");\n    if (f == nullptr) return;\n    if (error) {\n        fclose(f);\n        return;\n    }\n    fclose(f);\n}\n```\n\n## deallocuse\n\nUse after free.\n\n```cpp\n// BAD\nchar* p = malloc(100);\nfree(p);\nstrcpy(p, \"hello\");  // use after free!\n\n// GOOD\nchar* p = malloc(100);\nstrcpy(p, \"hello\");\nfree(p);\np = nullptr;  // prevent accidental reuse\n```\n\n## doubleFree\n\nFreeing memory twice.\n\n```cpp\n// BAD\nchar* p = malloc(100);\nfree(p);\nfree(p);  // double free!\n\n// GOOD\nchar* p = malloc(100);\nfree(p);\np = nullptr;\n// free(p);  // free(nullptr) is safe but unnecessary\n```\n\n## bufferAccessOutOfBounds\n\nBuffer overrun.\n\n```cpp\n// BAD\nchar buf[10];\nstrcpy(buf, \"this string is too long\");  // overflow\n\nint arr[5];\narr[5] = 0;  // out of bounds\n\n// GOOD\nchar buf[32];\nstrncpy(buf, str, sizeof(buf) - 1);\nbuf[sizeof(buf) - 1] = '\\0';\n\nint arr[5];\narr[4] = 0;  // last valid index\n```\n\n## arrayIndexOutOfBounds\n\nArray index out of bounds.\n\n```cpp\n// BAD\nint arr[10];\nfor (int i = 0; i <= 10; i++) {  // off by one\n    arr[i] = 0;\n}\n\n// GOOD\nfor (int i = 0; i < 10; i++) {\n    arr[i] = 0;\n}\n```\n\n## negativeIndex\n\nNegative array index.\n\n```cpp\n// BAD\nint arr[10];\nint i = -1;\narr[i] = 0;  // undefined behavior\n\n// GOOD\nif (i >= 0 && i < 10) {\n    arr[i] = 0;\n}\n```\n\n## invalidIterator\n\nUse of invalid iterator.\n\n```cpp\n// BAD\nstd::vector<int> v = {1, 2, 3};\nauto it = v.begin();\nv.push_back(4);  // may invalidate iterators\n*it = 0;  // undefined behavior!\n\n// GOOD\nstd::vector<int> v = {1, 2, 3};\nv.push_back(4);\nauto it = v.begin();  // get iterator after modification\n*it = 0;\n```\n\n## danglingReference\n\nDangling reference.\n\n```cpp\n// BAD\nint& getRef() {\n    int x = 42;\n    return x;  // dangling reference!\n}\n\n// BAD\nstd::string_view sv = getString();  // temporary destroyed\n\n// GOOD\nint& getRef() {\n    static int x = 42;\n    return x;\n}\n\nstd::string s = getString();\nstd::string_view sv = s;  // s must outlive sv\n```\n\n## invalidContainer\n\nInvalid container operation.\n\n```cpp\n// BAD\nstd::vector<int> v;\nv.front();  // undefined - empty container\n\n// GOOD\nstd::vector<int> v;\nif (!v.empty()) {\n    v.front();\n}\n```\n\n## mismatchAllocDealloc\n\nMismatched allocation/deallocation.\n\n```cpp\n// BAD\nint* p = new int;\nfree(p);  // should use delete\n\nint* arr = new int[10];\ndelete arr;  // should use delete[]\n\n// GOOD\nint* p = new int;\ndelete p;\n\nint* arr = new int[10];\ndelete[] arr;\n\nvoid* m = malloc(100);\nfree(m);\n```\n\n## deallocDealloc\n\nDeallocation of already deallocated memory.\n\n```cpp\n// BAD\nint* p = new int;\ndelete p;\ndelete p;  // double delete!\n\n// GOOD\nint* p = new int;\ndelete p;\np = nullptr;\n```\n\n## zerodiv\n\nDivision by zero.\n\n```cpp\n// BAD\nint x = 10 / 0;  // undefined behavior\n\nint divisor = getValue();\nint result = 100 / divisor;  // might be zero\n\n// GOOD\nint divisor = getValue();\nif (divisor != 0) {\n    int result = 100 / divisor;\n}\n```\n\n## shiftTooManyBits\n\nShift by too many bits.\n\n```cpp\n// BAD\nint x = 1 << 32;  // undefined for 32-bit int\nint y = 1 << -1;  // undefined\n\n// GOOD\nint x = 1 << 31;  // max safe shift for 32-bit signed\nunsigned u = 1U << 31;\n```\n\n## integerOverflow\n\nInteger overflow.\n\n```cpp\n// BAD\nint x = INT_MAX;\nx = x + 1;  // undefined behavior (signed overflow)\n\n// GOOD\nint x = INT_MAX;\nif (x < INT_MAX) {\n    x = x + 1;\n}\n\n// Or use unsigned (wraps defined)\nunsigned u = UINT_MAX;\nu = u + 1;  // wraps to 0, defined behavior\n```\n\n## signConversion\n\nSuspicious sign conversion.\n\n```cpp\n// BAD\nint x = -1;\nunsigned u = x;  // large positive value\nif (u < 10) { }  // always false!\n\n// GOOD\nint x = -1;\nif (x >= 0) {\n    unsigned u = x;\n}\n```\n"}, {"path": "linters/cppcheck/checks.md", "category": "linters", "name": "linters/cppcheck/checks", "content": "# cppcheck Error Checks\n\nCritical bugs that are always reported.\n\n## Memory Errors\n\n### memleak\n\nMemory allocated but not freed.\n\n```cpp\n// BAD\nvoid foo() {\n    char* p = malloc(100);\n    if (error) return;  // leak!\n    free(p);\n}\n\n// GOOD\nvoid foo() {\n    char* p = malloc(100);\n    if (error) {\n        free(p);\n        return;\n    }\n    free(p);\n}\n```\n\n### resourceLeak\n\nFile/resource opened but not closed.\n\n```cpp\n// BAD\nvoid foo() {\n    FILE* f = fopen(\"file\", \"r\");\n    if (error) return;  // leak!\n    fclose(f);\n}\n\n// GOOD - use RAII in C++\nvoid foo() {\n    std::ifstream f(\"file\");\n    if (error) return;  // automatically closed\n}\n```\n\n### deallocuse / useAfterFree\n\nUse after free.\n\n```cpp\n// BAD\nchar* p = malloc(100);\nfree(p);\nstrcpy(p, \"hello\");  // use after free!\n\n// GOOD\nchar* p = malloc(100);\nstrcpy(p, \"hello\");\nfree(p);\np = NULL;  // prevent reuse\n```\n\n### doubleFree\n\nFreeing memory twice.\n\n```cpp\n// BAD\nfree(p);\nfree(p);  // double free!\n\n// GOOD\nfree(p);\np = NULL;\n```\n\n### deallocDealloc\n\nDealloc mismatch.\n\n```cpp\n// BAD\nint* p = new int;\nfree(p);  // should be delete!\n\nint* a = new int[10];\ndelete a;  // should be delete[]!\n\n// GOOD\nint* p = new int;\ndelete p;\n\nint* a = new int[10];\ndelete[] a;\n```\n\n### memleakOnRealloc\n\nLeak when realloc fails.\n\n```cpp\n// BAD\np = realloc(p, new_size);  // if fails, p is lost!\n\n// GOOD\nvoid* tmp = realloc(p, new_size);\nif (tmp == NULL) {\n    free(p);  // free original\n    return ERROR;\n}\np = tmp;\n```\n\n## Null Pointer Errors\n\n### nullPointer\n\nNull pointer dereference.\n\n```cpp\n// BAD\nint* p = NULL;\n*p = 5;  // crash!\n\n// GOOD\nint* p = malloc(sizeof(int));\nif (p != NULL) {\n    *p = 5;\n}\n```\n\n### nullPointerRedundantCheck\n\nCheck after dereference.\n\n```cpp\n// BAD\n*p = 5;  // dereference\nif (p == NULL) {  // too late!\n    return;\n}\n\n// GOOD\nif (p == NULL) {\n    return;\n}\n*p = 5;\n```\n\n## Buffer Errors\n\n### arrayIndexOutOfBounds\n\nArray access out of bounds.\n\n```cpp\n// BAD\nint arr[10];\narr[10] = 5;  // out of bounds!\n\n// GOOD\nint arr[10];\narr[9] = 5;\n```\n\n### bufferAccessOutOfBounds\n\nBuffer overflow.\n\n```cpp\n// BAD\nchar buf[10];\nstrcpy(buf, \"this is too long\");  // overflow!\n\n// GOOD\nchar buf[10];\nstrncpy(buf, \"this is too long\", sizeof(buf) - 1);\nbuf[sizeof(buf) - 1] = '\\0';\n```\n\n### negativeIndex\n\nNegative array index.\n\n```cpp\n// BAD\nint arr[10];\nint i = -1;\narr[i] = 5;  // negative index!\n```\n\n### stringLiteralWrite\n\nWriting to string literal.\n\n```cpp\n// BAD\nchar* s = \"hello\";\ns[0] = 'H';  // undefined behavior!\n\n// GOOD\nchar s[] = \"hello\";\ns[0] = 'H';\n```\n\n## Uninitialized Variables\n\n### uninitvar\n\nUsing uninitialized variable.\n\n```cpp\n// BAD\nint x;\nprintf(\"%d\", x);  // uninitialized!\n\n// GOOD\nint x = 0;\nprintf(\"%d\", x);\n```\n\n### uninitdata\n\nUsing uninitialized data.\n\n```cpp\n// BAD\nstruct S { int a; int b; };\nstruct S s;\nprintf(\"%d\", s.a);  // uninitialized!\n\n// GOOD\nstruct S s = {0};\nprintf(\"%d\", s.a);\n```\n\n### uninitMemberVar\n\nUsing uninitialized member.\n\n```cpp\n// BAD\nclass Foo {\n    int x;\npublic:\n    int getX() { return x; }  // x not initialized!\n};\n\n// GOOD\nclass Foo {\n    int x = 0;\npublic:\n    int getX() { return x; }\n};\n```\n\n## Division Errors\n\n### zerodiv\n\nDivision by zero.\n\n```cpp\n// BAD\nint x = 5 / 0;\n\n// GOOD\nif (divisor != 0) {\n    int x = 5 / divisor;\n}\n```\n\n### zerodivcond\n\nDivision by zero in condition.\n\n```cpp\n// BAD\nif (x != 0) { }\ny = z / x;  // x might be 0 here!\n\n// GOOD\nif (x != 0) {\n    y = z / x;\n}\n```\n\n## Control Flow Errors\n\n### unreachableCode\n\nCode that can never execute.\n\n```cpp\n// BAD\nreturn 0;\nprintf(\"never reached\");  // unreachable!\n```\n\n### duplicateBreak\n\nDuplicate break.\n\n```cpp\n// BAD\ncase 1:\n    break;\n    break;  // duplicate!\n```\n\n### identicalConditionAfterEarlyExit\n\nRedundant condition.\n\n```cpp\n// BAD\nif (x > 0) return;\nif (x > 0) {  // always false here!\n    // ...\n}\n```\n\n## Misc Errors\n\n### invalidPrintfArgType_*\n\nWrong printf format specifier.\n\n```cpp\n// BAD\nprintf(\"%d\", \"string\");  // wrong type!\nprintf(\"%s\", 42);        // wrong type!\n\n// GOOD\nprintf(\"%s\", \"string\");\nprintf(\"%d\", 42);\n```\n\n### wrongPrintfScanfArgNum\n\nWrong number of printf/scanf arguments.\n\n```cpp\n// BAD\nprintf(\"%d %d\", x);  // missing argument!\n\n// GOOD\nprintf(\"%d %d\", x, y);\n```\n\n### invalidScanfArgType_*\n\nWrong scanf argument type.\n\n```cpp\n// BAD\nint x;\nscanf(\"%s\", x);  // should be pointer!\n\n// GOOD\nchar buf[100];\nscanf(\"%s\", buf);\n```\n\n### leakReturnValNotUsed\n\nReturn value leak.\n\n```cpp\n// BAD\nmalloc(100);  // leak - return value ignored!\nstrdup(\"hello\");  // leak!\n\n// GOOD\nchar* p = malloc(100);\n// use p\nfree(p);\n```\n\n### selfAssignment\n\nSelf assignment.\n\n```cpp\n// BAD\nx = x;\n\n// Just remove it\n```\n\n### redundantAssignment\n\nRedundant assignment.\n\n```cpp\n// BAD\nx = 1;\nx = 2;  // first assignment wasted\n\n// GOOD\nx = 2;\n```\n\n### unreadVariable\n\nVariable assigned but never read.\n\n```cpp\n// BAD\nint x = 5;  // never used\n\n// Remove it or use it\n```\n\n### unusedVariable\n\nVariable declared but never used.\n\n```cpp\n// BAD\nint unused;\n\n// Remove it\n```\n\n### constParameter\n\nParameter could be const.\n\n```cpp\n// BAD\nvoid foo(int* p) {\n    printf(\"%d\", *p);  // doesn't modify\n}\n\n// GOOD\nvoid foo(const int* p) {\n    printf(\"%d\", *p);\n}\n```\n\n### constVariable\n\nVariable could be const.\n\n```cpp\n// BAD\nint x = 5;\nprintf(\"%d\", x);  // x never modified\n\n// GOOD\nconst int x = 5;\nprintf(\"%d\", x);\n```\n"}, {"path": "linters/clang-tidy/overview.md", "category": "linters", "name": "linters/clang-tidy/overview", "content": "# clang-tidy Checks\nVersion: 21.1.8\n\nSource: https://clang.llvm.org/extra/clang-tidy/checks/list.html\n\n\nSee: https://clang.llvm.org/extra/clang-tidy/checks/list.html\n"}, {"path": "linters/clang-tidy/cert.md", "category": "linters", "name": "linters/clang-tidy/cert", "content": "# clang-tidy cert-* Checks\n\nCERT Secure Coding Standards for C and C++.\n\n## cert-dcl03-c / cert-dcl16-c\n\nUse appropriate literal suffixes.\n\n```cpp\n// BAD\nlong x = 42l;  // lowercase L looks like 1\nunsigned u = 42u;\n\n// GOOD\nlong x = 42L;\nunsigned u = 42U;\nlong long ll = 42LL;\nunsigned long long ull = 42ULL;\n```\n\n## cert-dcl21-cpp\n\nPostfix operator++ should return const.\n\n```cpp\n// BAD - allows (i++)++ which is undefined\nIterator operator++(int) {\n    Iterator tmp = *this;\n    ++*this;\n    return tmp;\n}\n\n// GOOD\nconst Iterator operator++(int) {\n    Iterator tmp = *this;\n    ++*this;\n    return tmp;\n}\n```\n\n## cert-dcl50-cpp\n\nDon't define C-style variadic functions.\n\n```cpp\n// BAD\nvoid log(const char* fmt, ...) {\n    va_list args;\n    // ...\n}\n\n// GOOD - use variadic templates\ntemplate<typename... Args>\nvoid log(const char* fmt, Args&&... args);\n```\n\n## cert-dcl58-cpp\n\nDon't modify std namespace.\n\n```cpp\n// BAD\nnamespace std {\n    template<>\n    struct hash<MyType> { };  // UB in most cases\n}\n\n// GOOD - specialize in your namespace or use ADL\n// For hash, this is actually allowed as an exception\n```\n\n## cert-env33-c\n\nDon't call system().\n\n```cpp\n// BAD - command injection risk\nsystem(userInput);\nsystem(\"rm -rf \" + path);\n\n// GOOD - use exec family or specific APIs\nexecl(\"/bin/rm\", \"rm\", path.c_str(), nullptr);\n\n// Or use std::filesystem\nstd::filesystem::remove(path);\n```\n\n## cert-err33-c\n\nCheck return values for errors.\n\n```cpp\n// BAD\nfopen(path, \"r\");  // return not checked\nmalloc(size);      // return not checked\nfclose(file);      // return not checked\n\n// GOOD\nFILE* f = fopen(path, \"r\");\nif (f == nullptr) {\n    // handle error\n}\n\nvoid* p = malloc(size);\nif (p == nullptr) {\n    // handle error\n}\n\nif (fclose(file) != 0) {\n    // handle error\n}\n```\n\n## cert-err34-c\n\nCheck scanf return values.\n\n```cpp\n// BAD\nscanf(\"%d\", &x);\n\n// GOOD\nif (scanf(\"%d\", &x) != 1) {\n    // handle parse error\n}\n```\n\n## cert-err52-cpp\n\nDon't use setjmp/longjmp in C++.\n\n```cpp\n// BAD - doesn't call destructors\njmp_buf env;\nif (setjmp(env) == 0) {\n    // ...\n    longjmp(env, 1);  // skips destructors!\n}\n\n// GOOD - use exceptions\ntry {\n    // ...\n    throw std::runtime_error(\"error\");\n} catch (const std::exception& e) {\n    // handle\n}\n```\n\n## cert-err58-cpp\n\nHandle exceptions from static initializers.\n\n```cpp\n// BAD - exception terminates program\nstatic std::vector<int> v = riskyInit();  // might throw\n\n// GOOD - wrap in function\nstatic std::vector<int>& getV() {\n    static std::vector<int> v = []() {\n        try {\n            return riskyInit();\n        } catch (...) {\n            return std::vector<int>{};\n        }\n    }();\n    return v;\n}\n```\n\n## cert-err60-cpp\n\nException objects must be nothrow copy constructible.\n\n```cpp\n// BAD\nclass MyException : public std::exception {\n    std::string msg;  // copy might throw\npublic:\n    MyException(std::string m) : msg(std::move(m)) {}\n};\n\n// GOOD - use shared_ptr for complex data\nclass MyException : public std::exception {\n    std::shared_ptr<std::string> msg;  // copy is noexcept\npublic:\n    MyException(std::string m) \n        : msg(std::make_shared<std::string>(std::move(m))) {}\n};\n```\n\n## cert-fio38-c\n\nDon't copy FILE objects.\n\n```cpp\n// BAD\nFILE f1 = *fopen(\"file\", \"r\");  // undefined behavior\nFILE f2 = f1;                    // undefined behavior\n\n// GOOD\nFILE* f1 = fopen(\"file\", \"r\");\n// use f1 pointer, don't copy\n```\n\n## cert-flp30-c\n\nDon't use floating-point for loop counters.\n\n```cpp\n// BAD - accumulating error\nfor (float f = 0.0f; f < 1.0f; f += 0.1f) {\n    // f may never exactly equal 1.0\n}\n\n// GOOD\nfor (int i = 0; i < 10; ++i) {\n    float f = i * 0.1f;\n}\n```\n\n## cert-mem57-cpp\n\nProvide aligned new for over-aligned types.\n\n```cpp\n// BAD - over-aligned without operator new\nstruct alignas(64) CacheLine {\n    char data[64];\n};\nauto p = new CacheLine;  // may not be aligned in C++14\n\n// GOOD - C++17 aligned allocation\nauto p = new CacheLine;  // C++17 handles it\n\n// Or provide aligned new (pre-C++17)\nstruct alignas(64) CacheLine {\n    char data[64];\n    void* operator new(size_t size) {\n        return aligned_alloc(64, size);\n    }\n    void operator delete(void* p) {\n        free(p);\n    }\n};\n```\n\n## cert-msc30-c / cert-msc50-cpp\n\nDon't use rand() for security.\n\n```cpp\n// BAD - predictable\nint token = rand();\nsrand(time(nullptr));\n\n// GOOD - use <random>\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 100);\nint token = dis(gen);\n\n// For security-critical (tokens, keys)\n#include <openssl/rand.h>\nunsigned char token[32];\nRAND_bytes(token, sizeof(token));\n```\n\n## cert-msc32-c / cert-msc51-cpp\n\nProperly seed random number generators.\n\n```cpp\n// BAD - predictable seed\nsrand(time(nullptr));  // time is predictable\nstd::mt19937 gen(42);  // constant seed\n\n// GOOD\nstd::random_device rd;\nstd::mt19937 gen(rd());\n\n// For reproducible tests, document the seed\nstd::mt19937 gen(KNOWN_SEED);  // for testing only\n```\n\n## cert-oop11-cpp\n\nDon't return rvalue reference.\n\n```cpp\n// BAD\nstd::string&& getName() {\n    return std::move(name_);  // dangling reference!\n}\n\n// GOOD\nstd::string getName() {\n    return name_;  // copy\n}\n\nstd::string getName() && {\n    return std::move(name_);  // move from expiring object\n}\n```\n\n## cert-oop54-cpp\n\nGracefully handle self-assignment.\n\n```cpp\n// BAD\nFoo& operator=(const Foo& other) {\n    delete ptr;\n    ptr = new int(*other.ptr);  // crash if this == &other\n    return *this;\n}\n\n// GOOD - check for self-assignment\nFoo& operator=(const Foo& other) {\n    if (this != &other) {\n        delete ptr;\n        ptr = new int(*other.ptr);\n    }\n    return *this;\n}\n\n// BETTER - copy and swap\nFoo& operator=(Foo other) {  // by value\n    swap(*this, other);\n    return *this;\n}\n```\n\n## cert-oop57-cpp\n\nPrefer special member functions over memcpy/memmove.\n\n```cpp\n// BAD - may not work for non-trivial types\nFoo a, b;\nmemcpy(&a, &b, sizeof(Foo));  // UB if Foo is non-trivial\n\n// GOOD\nFoo a, b;\na = b;  // uses copy assignment\n```\n\n## cert-oop58-cpp\n\nCopy operations should provide strong exception safety.\n\n```cpp\n// BAD - not exception safe\nFoo& operator=(const Foo& other) {\n    delete ptr;  // point of no return\n    ptr = new int(*other.ptr);  // if this throws, object is invalid\n    return *this;\n}\n\n// GOOD - copy and swap (strong guarantee)\nFoo& operator=(const Foo& other) {\n    Foo tmp(other);  // if this throws, *this unchanged\n    swap(*this, tmp);\n    return *this;\n}\n```\n\n## cert-pos44-c\n\nDon't use signals for thread sync.\n\n```cpp\n// BAD - data race\nvolatile sig_atomic_t flag = 0;\n\nvoid handler(int) {\n    flag = 1;\n}\n\nvoid thread() {\n    while (!flag) { }  // spin on flag\n}\n\n// GOOD - use atomics or mutexes\nstd::atomic<bool> flag{false};\n\nvoid thread() {\n    while (!flag.load()) { }\n}\n```\n\n## cert-str34-c\n\nCast characters to unsigned before widening.\n\n```cpp\n// BAD - sign extension\nchar c = getchar();\nint i = c;  // if c is negative, i is negative\n\n// GOOD\nchar c = getchar();\nint i = static_cast<unsigned char>(c);\n\n// Or use unsigned char from start\nunsigned char c = getchar();\n```\n"}, {"path": "linters/clang-tidy/bugprone.md", "category": "linters", "name": "linters/clang-tidy/bugprone", "content": "# clang-tidy bugprone-* Checks\n\nBug-finding checks for common programming mistakes.\n\n## bugprone-argument-comment\n\nChecks that argument comments match parameter names.\n\n```cpp\n// BAD\nvoid draw(int x, int y);\ndraw(/*y=*/10, /*x=*/20);  // swapped!\n\n// GOOD\ndraw(/*x=*/10, /*y=*/20);\n```\n\n## bugprone-assert-side-effect\n\nFinds assertions with side effects (removed in release builds).\n\n```cpp\n// BAD - side effect in assert\nassert(i++ < 10);  // i not incremented in release!\nassert(processItem());  // not called in release!\n\n// GOOD\n++i;\nassert(i < 10);\n\nbool result = processItem();\nassert(result);\n```\n\n## bugprone-assignment-in-if-condition\n\nFinds assignments in if conditions.\n\n```cpp\n// BAD - probably meant ==\nif (x = 0) { }\n\n// GOOD\nif (x == 0) { }\n\n// If intentional, be explicit\nif ((x = getValue()) != 0) { }\n```\n\n## bugprone-bool-pointer-implicit-conversion\n\nFinds implicit bool* to bool conversions.\n\n```cpp\n// BAD\nbool* p = &flag;\nif (p) { }  // checks if pointer is non-null, not the bool value\n\n// GOOD\nif (p && *p) { }  // check both\nif (*p) { }       // if you know p is valid\n```\n\n## bugprone-branch-clone\n\nFinds duplicated code in if/else branches.\n\n```cpp\n// BAD\nif (condition) {\n    doSomething();\n    return 1;\n} else {\n    doSomething();  // duplicate!\n    return 1;\n}\n\n// GOOD - remove branch or fix logic\ndoSomething();\nreturn 1;\n```\n\n## bugprone-copy-constructor-init\n\nFinds copy constructors that don't call base copy constructor.\n\n```cpp\n// BAD\nclass Derived : public Base {\n    Derived(const Derived& other) : Base() { }  // should call Base(other)\n};\n\n// GOOD\nclass Derived : public Base {\n    Derived(const Derived& other) : Base(other) { }\n};\n```\n\n## bugprone-dangling-handle\n\nFinds dangling references to temporary strings.\n\n```cpp\n// BAD\nstd::string_view sv = getString();  // getString() returns temporary\nuse(sv);  // dangling!\n\n// GOOD\nstd::string s = getString();\nstd::string_view sv = s;\nuse(sv);\n```\n\n## bugprone-dynamic-static-initializers\n\nFinds dynamic initialization of static variables.\n\n```cpp\n// BAD - initialization order undefined\nstatic int x = someFunction();\n\n// GOOD - use function-local static or constexpr\nint getX() {\n    static int x = someFunction();  // initialized on first call\n    return x;\n}\n```\n\n## bugprone-exception-escape\n\nFinds functions that may throw but shouldn't.\n\n```cpp\n// BAD - destructor shouldn't throw\n~MyClass() {\n    throw std::runtime_error(\"oops\");  // undefined behavior!\n}\n\n// GOOD\n~MyClass() noexcept {\n    try {\n        cleanup();\n    } catch (...) {\n        // log but don't throw\n    }\n}\n```\n\n## bugprone-fold-init-type\n\nFinds folds with wrong init type.\n\n```cpp\n// BAD - init is int, accumulator loses precision\nauto sum = std::accumulate(v.begin(), v.end(), 0);  // v is vector<double>\n\n// GOOD\nauto sum = std::accumulate(v.begin(), v.end(), 0.0);\n```\n\n## bugprone-forwarding-reference-overload\n\nFinds forwarding reference constructors that hide copy/move.\n\n```cpp\n// BAD - template catches everything\nclass Widget {\n    template<typename T>\n    Widget(T&& arg) { }  // catches Widget& too!\n};\n\n// GOOD - constrain the template\nclass Widget {\n    template<typename T>\n    requires (!std::same_as<std::remove_cvref_t<T>, Widget>)\n    Widget(T&& arg) { }\n};\n```\n\n## bugprone-implicit-widening-of-multiplication-result\n\nFinds multiplication overflow before widening.\n\n```cpp\n// BAD - multiplication overflows before cast\nint a = 1000000, b = 1000000;\nlong long result = a * b;  // overflow!\n\n// GOOD - cast before multiplication\nlong long result = static_cast<long long>(a) * b;\n```\n\n## bugprone-incorrect-roundings\n\nFinds incorrect rounding patterns.\n\n```cpp\n// BAD\nint rounded = (int)(d + 0.5);  // wrong for negative numbers\n\n// GOOD\nint rounded = std::lround(d);\n```\n\n## bugprone-infinite-loop\n\nFinds loops that never terminate.\n\n```cpp\n// BAD\nwhile (true) {\n    if (condition) continue;  // no break ever!\n}\n\n// GOOD\nwhile (true) {\n    if (condition) break;\n}\n```\n\n## bugprone-integer-division\n\nFinds integer division in floating-point context.\n\n```cpp\n// BAD\ndouble ratio = count / total;  // integer division!\n\n// GOOD\ndouble ratio = static_cast<double>(count) / total;\n```\n\n## bugprone-macro-parentheses\n\nFinds macros without proper parentheses.\n\n```cpp\n// BAD\n#define DOUBLE(x) x * 2\nint y = DOUBLE(1 + 2);  // expands to 1 + 2 * 2 = 5, not 6\n\n// GOOD\n#define DOUBLE(x) ((x) * 2)\n```\n\n## bugprone-macro-repeated-side-effects\n\nFinds macros that evaluate arguments multiple times.\n\n```cpp\n// BAD\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\nint x = MAX(i++, j++);  // incremented twice!\n\n// GOOD - use inline function\ntemplate<typename T>\nconstexpr T max(T a, T b) { return a > b ? a : b; }\n```\n\n## bugprone-misplaced-operator-in-strlen-in-alloc\n\nFinds strlen() + 1 mistakes.\n\n```cpp\n// BAD\nchar* copy = malloc(strlen(s + 1));  // wrong - s+1 passed to strlen\n\n// GOOD\nchar* copy = malloc(strlen(s) + 1);  // +1 outside strlen\n```\n\n## bugprone-misplaced-widening-cast\n\nFinds casts that should be done earlier.\n\n```cpp\n// BAD - multiplication already overflowed\nlong long result = (long long)(a * b);\n\n// GOOD - cast before operation\nlong long result = (long long)a * b;\n```\n\n## bugprone-move-forwarding-reference\n\nFinds std::move on forwarding references.\n\n```cpp\n// BAD - should use std::forward\ntemplate<typename T>\nvoid foo(T&& arg) {\n    bar(std::move(arg));  // wrong!\n}\n\n// GOOD\ntemplate<typename T>\nvoid foo(T&& arg) {\n    bar(std::forward<T>(arg));\n}\n```\n\n## bugprone-multiple-statement-macro\n\nFinds multi-statement macros without braces.\n\n```cpp\n// BAD\n#define DO_BOTH do_a(); do_b()\nif (cond) DO_BOTH;  // only do_a is conditional!\n\n// GOOD\n#define DO_BOTH do { do_a(); do_b(); } while(0)\n```\n\n## bugprone-narrowing-conversions\n\nFinds implicit narrowing conversions.\n\n```cpp\n// BAD\nint x = 3.14;      // loses .14\nchar c = 1000;     // overflow\nfloat f = 1e100;   // overflow\n\n// GOOD - explicit conversion\nint x = static_cast<int>(3.14);\n```\n\n## bugprone-not-null-terminated-result\n\nFinds string operations that may not null-terminate.\n\n```cpp\n// BAD\nchar buf[10];\nstrncpy(buf, src, sizeof(buf));  // may not null-terminate\n\n// GOOD\nstrncpy(buf, src, sizeof(buf) - 1);\nbuf[sizeof(buf) - 1] = '\\0';\n\n// BETTER - use strlcpy or snprintf\nsnprintf(buf, sizeof(buf), \"%s\", src);\n```\n\n## bugprone-parent-virtual-call\n\nFinds calls to parent virtual through wrong type.\n\n```cpp\n// BAD\nclass Derived : public Base {\n    void foo() override {\n        Base::foo();       // OK\n        this->Base::foo(); // OK\n        ((Base*)this)->foo(); // calls Derived::foo! infinite recursion\n    }\n};\n```\n\n## bugprone-signed-char-misuse\n\nFinds signed char used where unsigned expected.\n\n```cpp\n// BAD - char may be negative\nchar c = getchar();\nif (c == 255) { }  // never true if char is signed!\n\n// GOOD\nint c = getchar();  // getchar returns int\nif (c == 255) { }\n```\n\n## bugprone-sizeof-container\n\nFinds sizeof() on containers.\n\n```cpp\n// BAD\nstd::vector<int> v;\nsize_t bytes = sizeof(v);  // size of vector struct, not contents!\n\n// GOOD\nsize_t bytes = v.size() * sizeof(int);\nsize_t elements = v.size();\n```\n\n## bugprone-sizeof-expression\n\nFinds suspicious sizeof expressions.\n\n```cpp\n// BAD\nint* arr = malloc(10);\nmemset(arr, 0, sizeof(arr));  // only clears pointer size!\n\n// GOOD\nint* arr = malloc(10 * sizeof(int));\nmemset(arr, 0, 10 * sizeof(int));\n```\n\n## bugprone-string-constructor\n\nFinds suspicious string constructor calls.\n\n```cpp\n// BAD - creates string of 'x' characters, not \"x\" string\nstd::string s('x', 50);  // wrong order!\n\n// GOOD\nstd::string s(50, 'x');  // 50 copies of 'x'\nstd::string s(\"x\");      // string \"x\"\n```\n\n## bugprone-string-literal-with-embedded-nul\n\nFinds strings with embedded NUL characters.\n\n```cpp\n// BAD - NUL in middle, string truncated\nstd::string s = \"hello\\0world\";  // s is \"hello\"\n\n// GOOD - if intentional, use constructor\nstd::string s(\"hello\\0world\", 11);  // includes NUL\n```\n\n## bugprone-suspicious-enum-usage\n\nFinds suspicious enum operations.\n\n```cpp\n// BAD - mixing enum values\nenum Color { Red, Green, Blue };\nenum Size { Small, Medium, Large };\nif (color == Small) { }  // comparing different enums\n\n// GOOD - use enum class\nenum class Color { Red, Green, Blue };\nenum class Size { Small, Medium, Large };\n// if (color == Size::Small) { }  // error!\n```\n\n## bugprone-suspicious-include\n\nFinds includes with implementation file extensions.\n\n```cpp\n// BAD\n#include \"file.cpp\"  // probably wrong\n#include \"file.c\"\n\n// GOOD\n#include \"file.h\"\n#include \"file.hpp\"\n```\n\n## bugprone-suspicious-memory-comparison\n\nFinds memcmp on non-trivially-comparable types.\n\n```cpp\n// BAD - padding bytes may differ\nstruct S { char a; int b; };  // has padding\nS s1, s2;\nmemcmp(&s1, &s2, sizeof(S));  // compares padding too!\n\n// GOOD\ns1.a == s2.a && s1.b == s2.b\n```\n\n## bugprone-suspicious-memset-usage\n\nFinds suspicious memset patterns.\n\n```cpp\n// BAD\nmemset(buf, sizeof(buf), 0);  // args swapped!\n\n// GOOD\nmemset(buf, 0, sizeof(buf));\n```\n\n## bugprone-suspicious-missing-comma\n\nFinds string literals missing comma.\n\n```cpp\n// BAD\nconst char* arr[] = {\n    \"one\",\n    \"two\"   // missing comma\n    \"three\" // concatenated with \"two\"!\n};\n\n// GOOD\nconst char* arr[] = {\n    \"one\",\n    \"two\",\n    \"three\"\n};\n```\n\n## bugprone-suspicious-semicolon\n\nFinds suspicious semicolons.\n\n```cpp\n// BAD\nif (condition);  // empty if body!\n{\n    doSomething();  // always runs\n}\n\n// GOOD\nif (condition) {\n    doSomething();\n}\n```\n\n## bugprone-suspicious-string-compare\n\nFinds suspicious string comparisons.\n\n```cpp\n// BAD - strcmp returns 0 for equal!\nif (strcmp(a, b)) {\n    // strings are NOT equal here\n}\n\n// GOOD\nif (strcmp(a, b) == 0) {\n    // strings are equal\n}\n```\n\n## bugprone-swapped-arguments\n\nFinds likely swapped function arguments.\n\n```cpp\n// BAD\nmemset(buf, sizeof(buf), 0);  // size and value swapped\n\n// GOOD\nmemset(buf, 0, sizeof(buf));\n```\n\n## bugprone-terminating-continue\n\nFinds continue that terminates loop.\n\n```cpp\n// BAD\ndo {\n    continue;  // loop runs once!\n} while (false);\n```\n\n## bugprone-throw-keyword-missing\n\nFinds missing throw keyword.\n\n```cpp\n// BAD\nif (error) {\n    std::runtime_error(\"oops\");  // creates and discards!\n}\n\n// GOOD\nif (error) {\n    throw std::runtime_error(\"oops\");\n}\n```\n\n## bugprone-too-small-loop-variable\n\nFinds loop variables that may overflow.\n\n```cpp\n// BAD\nfor (char i = 0; i < size; i++) { }  // char may overflow\n\n// GOOD\nfor (size_t i = 0; i < size; i++) { }\n```\n\n## bugprone-undefined-memory-manipulation\n\nFinds memset/memcpy on non-trivial types.\n\n```cpp\n// BAD\nstd::string s;\nmemset(&s, 0, sizeof(s));  // undefined behavior!\n\n// GOOD\nstd::string s;\ns.clear();\n```\n\n## bugprone-undelegated-constructor\n\nFinds constructor calls that don't delegate.\n\n```cpp\n// BAD\nclass Foo {\n    Foo() { }\n    Foo(int x) {\n        Foo();  // creates temporary, doesn't delegate!\n    }\n};\n\n// GOOD\nclass Foo {\n    Foo() { }\n    Foo(int x) : Foo() { }  // C++11 delegating constructor\n};\n```\n\n## bugprone-unhandled-exception-at-new\n\nFinds new expressions that may throw.\n\n```cpp\n// BAD\nint* p = new int[size];  // may throw std::bad_alloc\n\n// GOOD\nint* p = new (std::nothrow) int[size];\nif (!p) { /* handle */ }\n\n// BETTER - use smart pointer\nauto p = std::make_unique<int[]>(size);\n```\n\n## bugprone-unhandled-self-assignment\n\nFinds copy assignment without self-assignment check.\n\n```cpp\n// BAD\nFoo& operator=(const Foo& other) {\n    delete ptr;\n    ptr = new int(*other.ptr);  // crashes if this == &other\n    return *this;\n}\n\n// GOOD\nFoo& operator=(const Foo& other) {\n    if (this != &other) {\n        delete ptr;\n        ptr = new int(*other.ptr);\n    }\n    return *this;\n}\n\n// BETTER - copy and swap\nFoo& operator=(Foo other) {  // by value\n    swap(*this, other);\n    return *this;\n}\n```\n\n## bugprone-unused-raii\n\nFinds RAII objects created and immediately destroyed.\n\n```cpp\n// BAD\n{\n    std::lock_guard<std::mutex>(mutex);  // unnamed - destroyed immediately!\n    // critical section not protected\n}\n\n// GOOD\n{\n    std::lock_guard<std::mutex> lock(mutex);  // named - lives until scope end\n    // critical section protected\n}\n```\n\n## bugprone-unused-return-value\n\nFinds ignored return values.\n\n```cpp\n// BAD\nstd::remove(v.begin(), v.end(), value);  // doesn't erase!\nempty();  // return value ignored\n\n// GOOD\nv.erase(std::remove(v.begin(), v.end(), value), v.end());\nif (empty()) { }\n```\n\n## bugprone-use-after-move\n\nFinds use of moved-from objects.\n\n```cpp\n// BAD\nstd::vector<int> v = {1, 2, 3};\nauto v2 = std::move(v);\nv.push_back(4);  // undefined behavior!\n\n// GOOD\nstd::vector<int> v = {1, 2, 3};\nauto v2 = std::move(v);\nv.clear();  // now safe to reuse\nv.push_back(4);\n```\n\n## bugprone-virtual-near-miss\n\nFinds methods that almost override.\n\n```cpp\n// BAD - typo in override\nclass Base {\n    virtual void doWork();\n};\n\nclass Derived : public Base {\n    void dowork();  // lowercase 'w' - doesn't override!\n};\n\n// GOOD\nclass Derived : public Base {\n    void doWork() override;  // compiler catches mismatches\n};\n```\n"}, {"path": "linters/clang-tidy/cppcoreguidelines.md", "category": "linters", "name": "linters/clang-tidy/cppcoreguidelines", "content": "# clang-tidy cppcoreguidelines-* Checks\n\nChecks based on the C++ Core Guidelines (https://isocpp.github.io/CppCoreGuidelines/).\n\n## cppcoreguidelines-avoid-c-arrays\n\nUse std::array or std::vector instead of C arrays.\n\n```cpp\n// BAD\nint arr[10];\nvoid foo(int arr[]);\n\n// GOOD\nstd::array<int, 10> arr;\nvoid foo(std::span<int> arr);  // C++20\nvoid foo(int* arr, size_t size);  // pre-C++20\n```\n\n## cppcoreguidelines-avoid-const-or-ref-data-members\n\nAvoid const or reference data members.\n\n```cpp\n// BAD - makes class non-assignable\nclass Foo {\n    const int id;           // can't reassign\n    std::string& name_ref;  // can't reassign\n};\n\n// GOOD\nclass Foo {\n    int id;                 // can reassign\n    std::string* name_ptr;  // can reassign (or use accessor)\n    \n    // If immutable ID needed, make it private with getter only\n    int getId() const { return id_; }\nprivate:\n    int id_;\n};\n```\n\n## cppcoreguidelines-avoid-do-while\n\nAvoid do-while loops.\n\n```cpp\n// BAD - condition at end, harder to reason about\ndo {\n    process();\n} while (condition);\n\n// GOOD - condition at start\nwhile (true) {\n    process();\n    if (!condition) break;\n}\n\n// Or restructure\nprocess();\nwhile (condition) {\n    process();\n}\n```\n\n## cppcoreguidelines-avoid-goto\n\nDon't use goto.\n\n```cpp\n// BAD\nif (error) goto cleanup;\n// ...\ncleanup:\n    free(resources);\n\n// GOOD - RAII\n{\n    auto guard = make_scope_guard([] { free(resources); });\n    if (error) return;\n    // ...\n}  // guard cleans up\n```\n\n## cppcoreguidelines-avoid-magic-numbers\n\nSame as readability-magic-numbers.\n\n## cppcoreguidelines-avoid-non-const-global-variables\n\nAvoid non-const global variables.\n\n```cpp\n// BAD\nint globalCounter = 0;\nstd::string globalConfig;\n\n// GOOD - const is OK\nconst int MAX_SIZE = 100;\nconstexpr double PI = 3.14159;\n\n// GOOD - encapsulate in function\nint& getCounter() {\n    static int counter = 0;\n    return counter;\n}\n```\n\n## cppcoreguidelines-avoid-reference-coroutine-parameters\n\nDon't pass by reference to coroutines.\n\n```cpp\n// BAD - reference may dangle\ntask<void> process(const std::string& s) {\n    co_await something();\n    use(s);  // s may be dangling!\n}\n\n// GOOD - pass by value\ntask<void> process(std::string s) {\n    co_await something();\n    use(s);  // s is owned by coroutine\n}\n```\n\n## cppcoreguidelines-c-copy-assignment-signature\n\nCopy assignment should return reference to *this.\n\n```cpp\n// BAD\nvoid operator=(const Foo& other);\nFoo operator=(const Foo& other);\n\n// GOOD\nFoo& operator=(const Foo& other) {\n    // ...\n    return *this;\n}\n```\n\n## cppcoreguidelines-init-variables\n\nInitialize variables on declaration.\n\n```cpp\n// BAD\nint x;\ndouble* p;\n\n// GOOD\nint x = 0;\ndouble* p = nullptr;\n\n// C++11 brace initialization\nint x{};\ndouble* p{};\n```\n\n## cppcoreguidelines-interfaces-global-init\n\nAvoid global initializer order issues.\n\n```cpp\n// BAD - initialization order undefined\n// file1.cpp\nstd::string config = getConfig();\n\n// file2.cpp\nextern std::string config;\nLogger logger(config);  // config might not be initialized yet!\n\n// GOOD - lazy initialization\nconst std::string& getConfig() {\n    static std::string config = loadConfig();\n    return config;\n}\n```\n\n## cppcoreguidelines-macro-usage\n\nAvoid macros for constants/functions.\n\n```cpp\n// BAD\n#define PI 3.14159\n#define SQUARE(x) ((x) * (x))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\n// GOOD\nconstexpr double PI = 3.14159;\n\ntemplate<typename T>\nconstexpr T square(T x) { return x * x; }\n\ntemplate<typename T>\nconstexpr T max(T a, T b) { return a > b ? a : b; }\n```\n\n## cppcoreguidelines-misleading-capture-default-by-value\n\nWarn about capturing this by value default.\n\n```cpp\n// BAD - [=] captures this by value, not *this\nclass Foo {\n    int x;\n    void bar() {\n        auto f = [=] { return x; };  // captures this pointer\n    }\n};\n\n// GOOD - explicit capture\nclass Foo {\n    int x;\n    void bar() {\n        auto f = [this] { return x; };     // explicit this pointer\n        auto g = [*this] { return x; };    // copies *this (C++17)\n        auto h = [x = x] { return x; };    // capture by value\n    }\n};\n```\n\n## cppcoreguidelines-missing-std-forward\n\nUse std::forward with forwarding references.\n\n```cpp\n// BAD - loses rvalue-ness\ntemplate<typename T>\nvoid wrapper(T&& arg) {\n    inner(arg);  // always lvalue\n}\n\n// GOOD\ntemplate<typename T>\nvoid wrapper(T&& arg) {\n    inner(std::forward<T>(arg));\n}\n```\n\n## cppcoreguidelines-narrowing-conversions\n\nAvoid narrowing conversions.\n\n```cpp\n// BAD\nint i = 3.14;           // narrowing\nchar c = 1000;          // narrowing, overflow\nfloat f = 1e100;        // narrowing, overflow\n\n// GOOD\nint i = static_cast<int>(3.14);  // explicit\nauto i = static_cast<int>(3.14);\n\n// Or use gsl::narrow\nint i = gsl::narrow<int>(3.14);  // throws on data loss\nint i = gsl::narrow_cast<int>(3.14);  // asserts in debug\n```\n\n## cppcoreguidelines-no-malloc\n\nDon't use malloc/free.\n\n```cpp\n// BAD\nint* p = (int*)malloc(sizeof(int) * 10);\nfree(p);\n\n// GOOD\nauto p = std::make_unique<int[]>(10);\n\n// Or std::vector for dynamic arrays\nstd::vector<int> v(10);\n```\n\n## cppcoreguidelines-owning-memory\n\nUse gsl::owner for raw owning pointers.\n\n```cpp\n// BAD - unclear ownership\nint* create() {\n    return new int(42);  // caller must delete?\n}\n\n// GOOD - explicit ownership\ngsl::owner<int*> create() {\n    return new int(42);  // caller must delete\n}\n\n// BETTER - use smart pointers\nstd::unique_ptr<int> create() {\n    return std::make_unique<int>(42);\n}\n```\n\n## cppcoreguidelines-prefer-member-initializer\n\nInitialize members in member initializer list.\n\n```cpp\n// BAD\nclass Foo {\n    int x;\n    std::string name;\npublic:\n    Foo() {\n        x = 0;        // assignment, not initialization\n        name = \"\";    // assignment, not initialization\n    }\n};\n\n// GOOD\nclass Foo {\n    int x;\n    std::string name;\npublic:\n    Foo() : x(0), name(\"\") {}\n};\n\n// BETTER - default member initializers\nclass Foo {\n    int x = 0;\n    std::string name;\npublic:\n    Foo() = default;\n};\n```\n\n## cppcoreguidelines-pro-bounds-array-to-pointer-decay\n\nAvoid array-to-pointer decay.\n\n```cpp\n// BAD - loses size information\nvoid foo(int* arr);\nint arr[10];\nfoo(arr);  // decays to pointer\n\n// GOOD\nvoid foo(std::span<int> arr);  // C++20\nvoid foo(int* arr, size_t size);\n\ntemplate<size_t N>\nvoid foo(int (&arr)[N]);  // preserves size\n```\n\n## cppcoreguidelines-pro-bounds-constant-array-index\n\nUse gsl::at() or bounds-checked access.\n\n```cpp\n// BAD - no bounds checking\narr[i];\nvec[i];\n\n// GOOD\ngsl::at(arr, i);  // throws if out of bounds\nvec.at(i);        // throws if out of bounds\n```\n\n## cppcoreguidelines-pro-bounds-pointer-arithmetic\n\nAvoid pointer arithmetic.\n\n```cpp\n// BAD\np++;\np + n;\np[n];\n\n// GOOD - use std::span or iterators\nfor (int x : std::span(p, size)) { }\nfor (auto it = vec.begin(); it != vec.end(); ++it) { }\n```\n\n## cppcoreguidelines-pro-type-const-cast\n\nDon't use const_cast.\n\n```cpp\n// BAD\nconst_cast<int*>(ptr);\n\n// GOOD - fix the design\n// If you need non-const, don't make it const\n// If API requires const, don't cast it away\n```\n\n## cppcoreguidelines-pro-type-cstyle-cast\n\nDon't use C-style casts.\n\n```cpp\n// BAD\nint x = (int)3.14;\nvoid* p = (void*)ptr;\n\n// GOOD\nint x = static_cast<int>(3.14);\nvoid* p = static_cast<void*>(ptr);\n```\n\n## cppcoreguidelines-pro-type-member-init\n\nInitialize all members.\n\n```cpp\n// BAD\nclass Foo {\n    int x;      // uninitialized\n    int* ptr;   // uninitialized\n};\n\n// GOOD\nclass Foo {\n    int x = 0;\n    int* ptr = nullptr;\n};\n```\n\n## cppcoreguidelines-pro-type-reinterpret-cast\n\nDon't use reinterpret_cast.\n\n```cpp\n// BAD\nint* p = reinterpret_cast<int*>(addr);\n\n// GOOD - use std::bit_cast (C++20)\nauto p = std::bit_cast<int*>(addr);\n\n// Or design to not need it\n```\n\n## cppcoreguidelines-pro-type-static-cast-downcast\n\nUse dynamic_cast for downcasting.\n\n```cpp\n// BAD - no runtime check\nDerived* d = static_cast<Derived*>(base);\n\n// GOOD - runtime checked\nDerived* d = dynamic_cast<Derived*>(base);\nif (d) {\n    // safe to use\n}\n```\n\n## cppcoreguidelines-pro-type-union-access\n\nDon't access union members directly.\n\n```cpp\n// BAD\nunion U {\n    int i;\n    float f;\n};\nU u;\nu.i = 1;\nfloat f = u.f;  // undefined behavior\n\n// GOOD - use std::variant\nstd::variant<int, float> v = 1;\nint i = std::get<int>(v);\n```\n\n## cppcoreguidelines-pro-type-vararg\n\nDon't use C-style varargs.\n\n```cpp\n// BAD\nvoid log(const char* fmt, ...);\n\n// GOOD - use variadic templates\ntemplate<typename... Args>\nvoid log(std::format_string<Args...> fmt, Args&&... args) {\n    std::cout << std::format(fmt, std::forward<Args>(args)...);\n}\n```\n\n## cppcoreguidelines-rvalue-reference-param-not-moved\n\nMove from rvalue reference parameters.\n\n```cpp\n// BAD - takes rvalue but copies\nvoid foo(std::string&& s) {\n    member_ = s;  // copies!\n}\n\n// GOOD\nvoid foo(std::string&& s) {\n    member_ = std::move(s);\n}\n```\n\n## cppcoreguidelines-slicing\n\nAvoid object slicing.\n\n```cpp\n// BAD\nDerived d;\nBase b = d;  // slices off Derived part\n\nvoid foo(Base b);\nfoo(Derived());  // sliced on copy\n\n// GOOD\nBase& b = d;              // reference preserves type\nvoid foo(const Base& b);  // reference parameter\nvoid foo(Base* b);        // pointer parameter\n```\n\n## cppcoreguidelines-special-member-functions\n\nFollow rule of zero/five.\n\n```cpp\n// BAD - violates rule of 5\nclass Foo {\n    int* data;\npublic:\n    ~Foo() { delete data; }  // only destructor\n    // missing: copy ctor, copy assign, move ctor, move assign\n};\n\n// GOOD - rule of 5\nclass Foo {\n    int* data;\npublic:\n    ~Foo() { delete data; }\n    Foo(const Foo& other);\n    Foo& operator=(const Foo& other);\n    Foo(Foo&& other) noexcept;\n    Foo& operator=(Foo&& other) noexcept;\n};\n\n// BETTER - rule of 0\nclass Foo {\n    std::unique_ptr<int> data;\n    // compiler generates correct special members\n};\n```\n\n## cppcoreguidelines-virtual-class-destructor\n\nVirtual classes need virtual destructor.\n\n```cpp\n// BAD\nclass Base {\n    virtual void foo();\n    ~Base();  // non-virtual!\n};\n\ndelete basePtr;  // undefined if points to Derived\n\n// GOOD\nclass Base {\n    virtual void foo();\n    virtual ~Base() = default;\n};\n```\n"}, {"path": "linters/clang-tidy/performance.md", "category": "linters", "name": "linters/clang-tidy/performance", "content": "# clang-tidy performance-* Checks\n\nPerformance optimization checks.\n\n## performance-avoid-endl\n\nUse '\\n' instead of std::endl.\n\n```cpp\n// BAD - endl flushes buffer every time\nstd::cout << \"line 1\" << std::endl;\nstd::cout << \"line 2\" << std::endl;\n\n// GOOD - '\\n' doesn't flush\nstd::cout << \"line 1\\n\";\nstd::cout << \"line 2\\n\";\n\n// Explicit flush when needed\nstd::cout << \"prompt: \" << std::flush;\n```\n\n## performance-faster-string-find\n\nUse character overload for single-char find.\n\n```cpp\n// BAD - string overload, more overhead\nstr.find(\"x\");\nstr.rfind(\"x\");\nstr.find_first_of(\"x\");\nstr.find_last_of(\"x\");\n\n// GOOD - character overload, faster\nstr.find('x');\nstr.rfind('x');\nstr.find_first_of('x');\nstr.find_last_of('x');\n```\n\n## performance-for-range-copy\n\nAvoid unnecessary copies in range-based for.\n\n```cpp\n// BAD - copies every element\nfor (auto item : container) {\n    use(item);\n}\n\n// GOOD - reference, no copy\nfor (const auto& item : container) {\n    use(item);\n}\n\n// For modification\nfor (auto& item : container) {\n    modify(item);\n}\n```\n\n## performance-implicit-conversion-in-loop\n\nAvoid implicit conversions in loops.\n\n```cpp\n// BAD - converts size_t to int every iteration\nfor (int i = 0; i < vec.size(); ++i) { }\n\n// GOOD - matching types\nfor (size_t i = 0; i < vec.size(); ++i) { }\n\n// BETTER - range-based\nfor (const auto& item : vec) { }\n```\n\n## performance-inefficient-algorithm\n\nUse more efficient algorithm variants.\n\n```cpp\n// BAD - find + erase is O(n) + O(n)\nauto it = std::find(v.begin(), v.end(), value);\nif (it != v.end()) {\n    v.erase(it);\n}\n\n// GOOD for unordered removal - O(n)\nauto it = std::find(v.begin(), v.end(), value);\nif (it != v.end()) {\n    std::swap(*it, v.back());\n    v.pop_back();\n}\n\n// For removing all matching elements\nv.erase(std::remove(v.begin(), v.end(), value), v.end());\n```\n\n## performance-inefficient-string-concatenation\n\nAvoid repeated string concatenation.\n\n```cpp\n// BAD - creates temporaries\nstd::string result = a + b + c + d;\n\n// Also BAD in loops\nstd::string s;\nfor (const auto& item : items) {\n    s = s + item;  // O(n\u00b2)\n}\n\n// GOOD - reserve and append\nstd::string s;\ns.reserve(total_size);\nfor (const auto& item : items) {\n    s += item;\n}\n\n// Or use stringstream\nstd::ostringstream oss;\nfor (const auto& item : items) {\n    oss << item;\n}\nstd::string s = oss.str();\n```\n\n## performance-inefficient-vector-operation\n\nReserve vector capacity before filling.\n\n```cpp\n// BAD - reallocates as it grows\nstd::vector<int> v;\nfor (int i = 0; i < 1000; ++i) {\n    v.push_back(i);\n}\n\n// GOOD - single allocation\nstd::vector<int> v;\nv.reserve(1000);\nfor (int i = 0; i < 1000; ++i) {\n    v.push_back(i);\n}\n\n// BETTER if size known\nstd::vector<int> v(1000);\nfor (int i = 0; i < 1000; ++i) {\n    v[i] = i;\n}\n```\n\n## performance-move-const-arg\n\nDon't move const objects.\n\n```cpp\n// BAD - const can't be moved, will copy\nconst std::string s = \"hello\";\nfunc(std::move(s));  // actually copies\n\n// GOOD\nstd::string s = \"hello\";\nfunc(std::move(s));  // actually moves\n```\n\n## performance-move-constructor-init\n\nUse std::move in constructor initializers.\n\n```cpp\n// BAD - copies parameter\nclass Foo {\n    std::string name_;\npublic:\n    Foo(std::string name) : name_(name) {}  // copies\n};\n\n// GOOD - moves parameter\nclass Foo {\n    std::string name_;\npublic:\n    Foo(std::string name) : name_(std::move(name)) {}\n};\n```\n\n## performance-no-automatic-move\n\nEnsure automatic move isn't prevented.\n\n```cpp\n// BAD - const prevents move\nstd::vector<int> getVector() {\n    const std::vector<int> v = compute();\n    return v;  // copies because const\n}\n\n// GOOD - non-const enables move\nstd::vector<int> getVector() {\n    std::vector<int> v = compute();\n    return v;  // moves\n}\n```\n\n## performance-no-int-to-ptr\n\nAvoid integer to pointer casts.\n\n```cpp\n// BAD\nvoid* p = (void*)0x12345678;\nint* ip = reinterpret_cast<int*>(addr);\n\n// GOOD - if you really need this\nvoid* p = reinterpret_cast<void*>(static_cast<uintptr_t>(0x12345678));\n```\n\n## performance-noexcept-destructor\n\nDestructors should be noexcept.\n\n```cpp\n// BAD\nclass Foo {\n    ~Foo() { }  // implicitly noexcept(true), but not explicit\n};\n\n// GOOD\nclass Foo {\n    ~Foo() noexcept { }\n};\n\n// If destructor might throw (avoid this!)\nclass Foo {\n    ~Foo() noexcept(false) { }  // explicit that it throws\n};\n```\n\n## performance-noexcept-move-constructor\n\nMove operations should be noexcept.\n\n```cpp\n// BAD - prevents optimizations\nclass Foo {\n    Foo(Foo&& other) { }\n    Foo& operator=(Foo&& other) { }\n};\n\n// GOOD - enables optimizations\nclass Foo {\n    Foo(Foo&& other) noexcept { }\n    Foo& operator=(Foo&& other) noexcept { }\n};\n```\n\n**Why:** std::vector won't use move if it's not noexcept.\n\n## performance-noexcept-swap\n\nSwap should be noexcept.\n\n```cpp\n// BAD\nvoid swap(Foo& a, Foo& b) {\n    // ...\n}\n\n// GOOD\nvoid swap(Foo& a, Foo& b) noexcept {\n    // ...\n}\n```\n\n## performance-trivially-destructible\n\nUse trivially destructible types when possible.\n\n```cpp\n// BAD - non-trivial destructor\nstruct Point {\n    int x, y;\n    ~Point() { }  // unnecessary, prevents optimizations\n};\n\n// GOOD - trivially destructible\nstruct Point {\n    int x, y;\n    // no destructor needed\n};\n```\n\n## performance-type-promotion-in-math-fn\n\nAvoid unnecessary type promotion in math functions.\n\n```cpp\n// BAD - float promoted to double\nfloat f = 3.14f;\nfloat result = std::sin(f);  // calls sin(double)\n\n// GOOD - use float overload\nfloat f = 3.14f;\nfloat result = std::sinf(f);  // or std::sin(f) in C++11\n```\n\n## performance-unnecessary-copy-initialization\n\nAvoid unnecessary copies when initializing.\n\n```cpp\n// BAD - copies the result\nconst std::string& ref = getString();\nauto copy = ref;  // unnecessary copy if only reading\n\n// GOOD - use reference\nconst auto& copy = getString();\n\n// Or if you need a copy, move from temporary\nauto copy = getString();  // moves from temporary\n```\n\n## performance-unnecessary-value-param\n\nPass by const reference instead of value for read-only params.\n\n```cpp\n// BAD - copies the string\nvoid process(std::string s) {\n    std::cout << s;\n}\n\n// GOOD - no copy\nvoid process(const std::string& s) {\n    std::cout << s;\n}\n\n// Exception: if you need to store/modify, take by value and move\nvoid store(std::string s) {\n    member_ = std::move(s);\n}\n```\n"}, {"path": "linters/clang-tidy/modernize.md", "category": "linters", "name": "linters/clang-tidy/modernize", "content": "# clang-tidy modernize-* Checks\n\nModernize C++ code to newer standards (C++11/14/17/20/23).\n\n## modernize-avoid-bind\n\nReplace std::bind with lambdas.\n\n```cpp\n// BAD\nauto f = std::bind(&Foo::bar, this, std::placeholders::_1);\n\n// GOOD\nauto f = [this](int x) { return bar(x); };\n```\n\n## modernize-avoid-c-arrays\n\nUse std::array or std::vector instead of C arrays.\n\n```cpp\n// BAD\nint arr[10];\nint arr[] = {1, 2, 3};\n\n// GOOD\nstd::array<int, 10> arr;\nstd::array arr = {1, 2, 3};  // C++17 CTAD\nstd::vector<int> arr = {1, 2, 3};\n```\n\n## modernize-concat-nested-namespaces\n\nUse C++17 nested namespace syntax.\n\n```cpp\n// BAD\nnamespace foo {\nnamespace bar {\nnamespace baz {\n}\n}\n}\n\n// GOOD (C++17)\nnamespace foo::bar::baz {\n}\n```\n\n## modernize-deprecated-headers\n\nReplace deprecated C headers with C++ equivalents.\n\n```cpp\n// BAD\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <stdint.h>\n\n// GOOD\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cstdint>\n```\n\n## modernize-deprecated-ios-base-aliases\n\nReplace deprecated iostream aliases.\n\n```cpp\n// BAD\nstd::ios_base::io_state\nstd::ios_base::open_mode\nstd::ios_base::seek_dir\n\n// GOOD\nstd::ios_base::iostate\nstd::ios_base::openmode\nstd::ios_base::seekdir\n```\n\n## modernize-loop-convert\n\nConvert for loops to range-based for.\n\n```cpp\n// BAD\nfor (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n    std::cout << *it;\n}\n\nfor (int i = 0; i < v.size(); ++i) {\n    std::cout << v[i];\n}\n\n// GOOD\nfor (int x : v) {\n    std::cout << x;\n}\n\nfor (const auto& x : v) {\n    std::cout << x;\n}\n```\n\n## modernize-make-shared\n\nUse std::make_shared instead of new.\n\n```cpp\n// BAD\nstd::shared_ptr<Foo> p(new Foo(1, 2));\nstd::shared_ptr<Foo> p = std::shared_ptr<Foo>(new Foo());\n\n// GOOD\nauto p = std::make_shared<Foo>(1, 2);\n```\n\n**Why:** Single allocation, exception safe.\n\n## modernize-make-unique\n\nUse std::make_unique instead of new.\n\n```cpp\n// BAD\nstd::unique_ptr<Foo> p(new Foo(1, 2));\nstd::unique_ptr<Foo[]> arr(new Foo[10]);\n\n// GOOD\nauto p = std::make_unique<Foo>(1, 2);\nauto arr = std::make_unique<Foo[]>(10);\n```\n\n## modernize-pass-by-value\n\nPass by value and move for sink parameters.\n\n```cpp\n// BAD - copies even when caller has temporary\nclass Foo {\n    std::string name_;\npublic:\n    void setName(const std::string& name) {\n        name_ = name;\n    }\n};\n\n// GOOD - moves temporaries, copies lvalues\nclass Foo {\n    std::string name_;\npublic:\n    void setName(std::string name) {\n        name_ = std::move(name);\n    }\n};\n```\n\n## modernize-raw-string-literal\n\nUse raw string literals for complex escapes.\n\n```cpp\n// BAD\nconst char* regex = \"\\\\d+\\\\.\\\\d+\";\nconst char* path = \"C:\\\\Users\\\\name\\\\file\";\nconst char* json = \"{\\\"key\\\": \\\"value\\\"}\";\n\n// GOOD\nconst char* regex = R\"(\\d+\\.\\d+)\";\nconst char* path = R\"(C:\\Users\\name\\file)\";\nconst char* json = R\"({\"key\": \"value\"})\";\n\n// With delimiter for strings containing )\nconst char* s = R\"delim(contains ) character)delim\";\n```\n\n## modernize-redundant-void-arg\n\nRemove redundant void in empty parameter lists.\n\n```cpp\n// BAD (C-style)\nint foo(void);\nint bar(void) { return 0; }\n\n// GOOD (C++)\nint foo();\nint bar() { return 0; }\n```\n\n## modernize-replace-auto-ptr\n\nReplace deprecated std::auto_ptr with std::unique_ptr.\n\n```cpp\n// BAD (removed in C++17)\nstd::auto_ptr<Foo> p(new Foo());\n\n// GOOD\nstd::unique_ptr<Foo> p = std::make_unique<Foo>();\n```\n\n## modernize-replace-disallow-copy-and-assign-macro\n\nReplace DISALLOW_COPY macro with deleted functions.\n\n```cpp\n// BAD\nclass Foo {\n    DISALLOW_COPY_AND_ASSIGN(Foo);\n};\n\n// GOOD\nclass Foo {\n    Foo(const Foo&) = delete;\n    Foo& operator=(const Foo&) = delete;\n};\n```\n\n## modernize-replace-random-shuffle\n\nReplace std::random_shuffle with std::shuffle.\n\n```cpp\n// BAD (removed in C++17)\nstd::random_shuffle(v.begin(), v.end());\n\n// GOOD\nstd::random_device rd;\nstd::mt19937 g(rd());\nstd::shuffle(v.begin(), v.end(), g);\n```\n\n## modernize-return-braced-init-list\n\nUse braced init for return.\n\n```cpp\n// BAD\nstd::pair<int, int> foo() {\n    return std::make_pair(1, 2);\n}\n\n// GOOD\nstd::pair<int, int> foo() {\n    return {1, 2};\n}\n```\n\n## modernize-shrink-to-fit\n\nUse shrink_to_fit() instead of swap trick.\n\n```cpp\n// BAD\nstd::vector<int>(v).swap(v);\n\n// GOOD\nv.shrink_to_fit();\n```\n\n## modernize-unary-static-assert\n\nUse single-argument static_assert (C++17).\n\n```cpp\n// BAD\nstatic_assert(sizeof(int) == 4, \"\");\n\n// GOOD (C++17)\nstatic_assert(sizeof(int) == 4);\n```\n\n## modernize-use-auto\n\nUse auto where type is obvious.\n\n```cpp\n// BAD\nstd::vector<int>::iterator it = v.begin();\nstd::unique_ptr<Foo> p = std::make_unique<Foo>();\nWidget* w = new Widget();\n\n// GOOD\nauto it = v.begin();\nauto p = std::make_unique<Foo>();\nauto* w = new Widget();  // auto* makes pointer explicit\n```\n\n## modernize-use-bool-literals\n\nUse true/false instead of integer literals.\n\n```cpp\n// BAD\nbool b = 1;\nbool c = 0;\nfunction(1);  // where param is bool\n\n// GOOD\nbool b = true;\nbool c = false;\nfunction(true);\n```\n\n## modernize-use-default-member-init\n\nUse default member initializers.\n\n```cpp\n// BAD\nclass Foo {\n    int x;\n    std::string name;\npublic:\n    Foo() : x(0), name(\"default\") {}\n};\n\n// GOOD\nclass Foo {\n    int x = 0;\n    std::string name = \"default\";\npublic:\n    Foo() = default;\n};\n```\n\n## modernize-use-emplace\n\nUse emplace instead of push_back with temporaries.\n\n```cpp\n// BAD\nv.push_back(Foo(1, 2));\nv.push_back(std::make_pair(1, 2));\n\n// GOOD\nv.emplace_back(1, 2);\n```\n\n## modernize-use-equals-default\n\nUse = default for trivial special members.\n\n```cpp\n// BAD\nclass Foo {\npublic:\n    Foo() {}\n    ~Foo() {}\n    Foo(const Foo& other) : x(other.x) {}\n};\n\n// GOOD\nclass Foo {\npublic:\n    Foo() = default;\n    ~Foo() = default;\n    Foo(const Foo&) = default;\n};\n```\n\n## modernize-use-equals-delete\n\nUse = delete instead of private undefined.\n\n```cpp\n// BAD (C++03 style)\nclass Foo {\nprivate:\n    Foo(const Foo&);  // undefined\n    Foo& operator=(const Foo&);  // undefined\n};\n\n// GOOD\nclass Foo {\npublic:\n    Foo(const Foo&) = delete;\n    Foo& operator=(const Foo&) = delete;\n};\n```\n\n## modernize-use-nodiscard\n\nAdd [[nodiscard]] where appropriate.\n\n```cpp\n// BAD\nbool isEmpty() const { return size_ == 0; }\nError validate() const { return check(); }\n\n// GOOD\n[[nodiscard]] bool isEmpty() const { return size_ == 0; }\n[[nodiscard]] Error validate() const { return check(); }\n```\n\n## modernize-use-noexcept\n\nUse noexcept instead of throw().\n\n```cpp\n// BAD\nvoid foo() throw();\nvoid bar() throw(std::exception);\n\n// GOOD\nvoid foo() noexcept;\nvoid bar();  // may throw\n```\n\n## modernize-use-nullptr\n\nUse nullptr instead of NULL or 0.\n\n```cpp\n// BAD\nint* p = NULL;\nint* q = 0;\nif (p == NULL) {}\n\n// GOOD\nint* p = nullptr;\nint* q = nullptr;\nif (p == nullptr) {}\nif (!p) {}  // also fine\n```\n\n## modernize-use-override\n\nUse override for virtual function overrides.\n\n```cpp\n// BAD\nclass Derived : public Base {\n    virtual void foo();  // override? new virtual?\n    void bar();          // override? non-virtual?\n};\n\n// GOOD\nclass Derived : public Base {\n    void foo() override;     // definitely overrides\n    void bar() override;     // compiler error if Base::bar not virtual\n};\n```\n\n## modernize-use-starts-ends-with\n\nUse starts_with/ends_with (C++20).\n\n```cpp\n// BAD\nif (s.find(\"prefix\") == 0) {}\nif (s.rfind(\"suffix\") == s.size() - 6) {}\nif (s.substr(0, 6) == \"prefix\") {}\n\n// GOOD (C++20)\nif (s.starts_with(\"prefix\")) {}\nif (s.ends_with(\"suffix\")) {}\n```\n\n## modernize-use-std-print\n\nUse std::print instead of printf (C++23).\n\n```cpp\n// BAD\nprintf(\"Hello %s, you are %d\\n\", name, age);\nstd::cout << \"Hello \" << name << \", you are \" << age << \"\\n\";\n\n// GOOD (C++23)\nstd::print(\"Hello {}, you are {}\\n\", name, age);\nstd::println(\"Hello {}, you are {}\", name, age);\n```\n\n## modernize-use-trailing-return-type\n\nUse trailing return type syntax.\n\n```cpp\n// Traditional\nint foo();\nstd::vector<int> bar();\n\n// Trailing (useful for templates, decltype)\nauto foo() -> int;\nauto bar() -> std::vector<int>;\n\n// Required for some cases\ntemplate<typename T, typename U>\nauto add(T t, U u) -> decltype(t + u);\n```\n\n## modernize-use-transparent-functors\n\nUse transparent comparators.\n\n```cpp\n// BAD - requires exact key type\nstd::map<std::string, int> m;\nm.find(\"key\");  // constructs temporary std::string\n\n// GOOD - heterogeneous lookup\nstd::map<std::string, int, std::less<>> m;\nm.find(\"key\");  // compares directly with const char*\n```\n\n## modernize-use-uncaught-exceptions\n\nUse std::uncaught_exceptions (plural).\n\n```cpp\n// BAD (deprecated in C++17, removed in C++20)\nbool throwing = std::uncaught_exception();\n\n// GOOD\nint count = std::uncaught_exceptions();\nbool throwing = count > 0;\n```\n\n## modernize-use-using\n\nUse using instead of typedef.\n\n```cpp\n// BAD\ntypedef std::vector<int> IntVector;\ntypedef int (*FuncPtr)(int, int);\ntypedef std::map<std::string, std::vector<int>> StringToInts;\n\n// GOOD\nusing IntVector = std::vector<int>;\nusing FuncPtr = int (*)(int, int);\nusing StringToInts = std::map<std::string, std::vector<int>>;\n\n// Template aliases only work with using\ntemplate<typename T>\nusing Vec = std::vector<T>;\n```\n"}, {"path": "linters/clang-tidy/readability.md", "category": "linters", "name": "linters/clang-tidy/readability", "content": "# clang-tidy readability-* Checks\n\nCode readability and clarity improvements.\n\n## readability-avoid-const-params-in-decls\n\nDon't use const for pass-by-value params in declarations.\n\n```cpp\n// BAD - const in declaration is noise\nvoid foo(const int x);  // declaration\nvoid foo(const int x) { }  // definition - const is fine here\n\n// GOOD\nvoid foo(int x);  // declaration\nvoid foo(const int x) { }  // definition - const prevents accidental modification\n```\n\n## readability-avoid-nested-conditional-operator\n\nAvoid nested ternary operators.\n\n```cpp\n// BAD - hard to read\nint x = a ? b ? c : d : e;\n\n// GOOD - use if/else\nint x;\nif (a) {\n    x = b ? c : d;\n} else {\n    x = e;\n}\n```\n\n## readability-braces-around-statements\n\nRequire braces for if/for/while.\n\n```cpp\n// BAD\nif (condition)\n    doSomething();\n\nfor (int i = 0; i < n; i++)\n    process(i);\n\n// GOOD\nif (condition) {\n    doSomething();\n}\n\nfor (int i = 0; i < n; i++) {\n    process(i);\n}\n```\n\n## readability-const-return-type\n\nDon't return const values.\n\n```cpp\n// BAD - prevents move semantics\nconst std::string getName() { return name_; }\n\n// GOOD\nstd::string getName() { return name_; }\n\n// Const reference is fine\nconst std::string& getName() const { return name_; }\n```\n\n## readability-container-contains\n\nUse contains() instead of count/find (C++20).\n\n```cpp\n// BAD\nif (set.count(value) > 0) { }\nif (set.find(value) != set.end()) { }\nif (map.count(key)) { }\n\n// GOOD (C++20)\nif (set.contains(value)) { }\nif (map.contains(key)) { }\n```\n\n## readability-container-data-pointer\n\nUse data() instead of &container[0].\n\n```cpp\n// BAD\nchar* p = &str[0];\nint* q = &vec[0];\n\n// GOOD\nchar* p = str.data();\nint* q = vec.data();\n```\n\n## readability-container-size-empty\n\nUse empty() instead of size() == 0.\n\n```cpp\n// BAD\nif (vec.size() == 0) { }\nif (str.size() != 0) { }\nif (0 == list.size()) { }\n\n// GOOD\nif (vec.empty()) { }\nif (!str.empty()) { }\nif (!list.empty()) { }\n```\n\n## readability-convert-member-functions-to-static\n\nMake member functions static if they don't use this.\n\n```cpp\n// BAD - doesn't use any members\nclass Foo {\n    int helper(int x) { return x * 2; }\n};\n\n// GOOD\nclass Foo {\n    static int helper(int x) { return x * 2; }\n};\n```\n\n## readability-delete-null-pointer\n\nDon't check for null before delete.\n\n```cpp\n// BAD - delete handles null\nif (ptr != nullptr) {\n    delete ptr;\n}\n\n// GOOD\ndelete ptr;\n```\n\n## readability-duplicate-include\n\nRemove duplicate #include.\n\n```cpp\n// BAD\n#include <vector>\n#include <string>\n#include <vector>  // duplicate\n\n// GOOD\n#include <string>\n#include <vector>\n```\n\n## readability-else-after-return\n\nDon't use else after return.\n\n```cpp\n// BAD\nif (condition) {\n    return a;\n} else {\n    return b;\n}\n\n// GOOD\nif (condition) {\n    return a;\n}\nreturn b;\n```\n\n## readability-function-cognitive-complexity\n\nLimit cognitive complexity of functions.\n\n```cpp\n// BAD - high cognitive complexity\nvoid process(Data& d) {\n    if (d.valid) {                    // +1\n        for (auto& item : d.items) {  // +2 (nested)\n            if (item.active) {        // +3 (nested)\n                for (auto& sub : item.subs) {  // +4 (nested)\n                    if (sub.check()) {  // +5 (nested)\n                        // ...\n                    }\n                }\n            }\n        }\n    }\n}  // complexity: 15+\n\n// GOOD - extract functions\nvoid processItem(Item& item);\nvoid processSub(Sub& sub);\n\nvoid process(Data& d) {\n    if (!d.valid) return;\n    for (auto& item : d.items) {\n        processItem(item);\n    }\n}\n```\n\n## readability-function-size\n\nLimit function size (lines, statements, parameters, nesting).\n\n```cpp\n// Configuration\nCheckOptions:\n  - key: readability-function-size.LineThreshold\n    value: 100\n  - key: readability-function-size.StatementThreshold\n    value: 50\n  - key: readability-function-size.ParameterThreshold\n    value: 6\n  - key: readability-function-size.NestingThreshold\n    value: 4\n```\n\n## readability-identifier-length\n\nEnforce minimum identifier length.\n\n```cpp\n// BAD - too short\nint n;\nfor (int i; ...) { }\nauto f = []() { };\n\n// GOOD\nint count;\nfor (int index; ...) { }\nauto filter = []() { };\n\n// Exceptions often configured for i, j, k, x, y, etc.\n```\n\n## readability-identifier-naming\n\nEnforce naming conventions.\n\n```cpp\n// Configuration example\nCheckOptions:\n  - key: readability-identifier-naming.ClassCase\n    value: CamelCase\n  - key: readability-identifier-naming.FunctionCase\n    value: camelBack\n  - key: readability-identifier-naming.VariableCase\n    value: lower_case\n  - key: readability-identifier-naming.ConstantCase\n    value: UPPER_CASE\n  - key: readability-identifier-naming.MemberPrefix\n    value: m_\n  - key: readability-identifier-naming.PrivateMemberSuffix\n    value: _\n```\n\n## readability-implicit-bool-conversion\n\nAvoid implicit bool conversions.\n\n```cpp\n// BAD\nint x = 5;\nif (x) { }  // implicit conversion to bool\nbool b = x;  // implicit conversion\n\n// GOOD\nif (x != 0) { }\nbool b = (x != 0);\n\n// Pointers are OK\nint* p = getPointer();\nif (p) { }  // common idiom\n```\n\n## readability-inconsistent-declaration-parameter-name\n\nParameter names should match across declarations.\n\n```cpp\n// BAD\nvoid foo(int x, int y);  // declaration\nvoid foo(int a, int b) { }  // definition - different names\n\n// GOOD\nvoid foo(int x, int y);  // declaration\nvoid foo(int x, int y) { }  // definition - same names\n```\n\n## readability-isolate-declaration\n\nOne declaration per statement.\n\n```cpp\n// BAD\nint x, y, z;\nint* p, q;  // q is not a pointer!\n\n// GOOD\nint x;\nint y;\nint z;\nint* p;\nint* q;\n```\n\n## readability-magic-numbers\n\nAvoid magic numbers.\n\n```cpp\n// BAD\nif (age >= 18) { }\nfor (int i = 0; i < 86400; i++) { }\ndouble area = 3.14159 * r * r;\n\n// GOOD\nconstexpr int ADULT_AGE = 18;\nconstexpr int SECONDS_PER_DAY = 86400;\nconstexpr double PI = 3.14159;\n\nif (age >= ADULT_AGE) { }\nfor (int i = 0; i < SECONDS_PER_DAY; i++) { }\ndouble area = PI * r * r;\n```\n\n## readability-make-member-function-const\n\nMake member functions const if they don't modify state.\n\n```cpp\n// BAD\nclass Foo {\n    int x_;\n    int getX() { return x_; }  // doesn't modify, should be const\n};\n\n// GOOD\nclass Foo {\n    int x_;\n    int getX() const { return x_; }\n};\n```\n\n## readability-misleading-indentation\n\nCatch misleading indentation.\n\n```cpp\n// BAD\nif (condition)\n    foo();\n    bar();  // looks like it's in the if, but isn't!\n\n// GOOD\nif (condition) {\n    foo();\n}\nbar();\n```\n\n## readability-misplaced-array-index\n\nPrefer arr[index] over index[arr].\n\n```cpp\n// BAD (but valid C/C++)\nint x = 5[arr];  // same as arr[5]\n\n// GOOD\nint x = arr[5];\n```\n\n## readability-named-parameter\n\nGive names to function parameters.\n\n```cpp\n// BAD\nvoid process(int, std::string, bool);\n\n// GOOD\nvoid process(int id, std::string name, bool verbose);\n\n// If intentionally unused, use comment\nvoid callback(int /*unused*/, std::string name);\n```\n\n## readability-non-const-parameter\n\nMake pointer parameters const if not modified.\n\n```cpp\n// BAD\nvoid print(int* data, size_t size);  // doesn't modify data\n\n// GOOD\nvoid print(const int* data, size_t size);\n```\n\n## readability-qualified-auto\n\nUse auto* and auto& explicitly.\n\n```cpp\n// BAD - unclear if pointer\nauto p = getPointer();\n\n// GOOD - explicit pointer\nauto* p = getPointer();\n\n// BAD - unclear if reference\nauto r = getReference();\n\n// GOOD - explicit reference\nauto& r = getReference();\n```\n\n## readability-redundant-access-specifiers\n\nRemove redundant access specifiers.\n\n```cpp\n// BAD\nclass Foo {\npublic:\n    void foo();\npublic:  // redundant\n    void bar();\n};\n\n// GOOD\nclass Foo {\npublic:\n    void foo();\n    void bar();\n};\n```\n\n## readability-redundant-control-flow\n\nRemove redundant control flow.\n\n```cpp\n// BAD\nvoid foo() {\n    doSomething();\n    return;  // redundant\n}\n\nfor (...) {\n    if (condition) {\n        continue;  // at end of loop, redundant\n    }\n}\n\n// GOOD\nvoid foo() {\n    doSomething();\n}\n\nfor (...) {\n    if (!condition) {\n        // work\n    }\n}\n```\n\n## readability-redundant-declaration\n\nRemove redundant declarations.\n\n```cpp\n// BAD\nextern int x;\nextern int x;  // redundant\n\n// GOOD\nextern int x;\n```\n\n## readability-redundant-member-init\n\nRemove redundant member initializers.\n\n```cpp\n// BAD\nclass Foo {\n    int x = 0;\n    std::string s = \"\";\npublic:\n    Foo() : x(0), s(\"\") {}  // redundant - same as defaults\n};\n\n// GOOD\nclass Foo {\n    int x = 0;\n    std::string s;  // default-initialized to \"\"\npublic:\n    Foo() = default;\n};\n```\n\n## readability-redundant-preprocessor\n\nRemove redundant preprocessor directives.\n\n```cpp\n// BAD\n#ifndef FOO\n#ifndef FOO  // redundant\n#define FOO\n#endif\n#endif\n\n// GOOD\n#ifndef FOO\n#define FOO\n#endif\n```\n\n## readability-redundant-smartptr-get\n\nRemove redundant smart pointer get().\n\n```cpp\n// BAD\nif (ptr.get() != nullptr) { }\nif (ptr.get()) { }\n*ptr.get();\n\n// GOOD\nif (ptr != nullptr) { }\nif (ptr) { }\n*ptr;\n```\n\n## readability-redundant-string-cstr\n\nRemove redundant c_str() calls.\n\n```cpp\n// BAD\nstd::string s = str.c_str();\nprintf(\"%s\", str.c_str());  // needed for C functions\n\n// GOOD\nstd::string s = str;\nstd::cout << str;  // no c_str() needed\n```\n\n## readability-redundant-string-init\n\nRemove redundant string initialization.\n\n```cpp\n// BAD\nstd::string s = \"\";\nstd::string s(\"\");\nstd::string s{\"\"};\n\n// GOOD\nstd::string s;  // default is empty\n```\n\n## readability-simplify-boolean-expr\n\nSimplify boolean expressions.\n\n```cpp\n// BAD\nif (condition == true) { }\nif (condition == false) { }\nbool b = condition ? true : false;\nreturn condition ? true : false;\n\n// GOOD\nif (condition) { }\nif (!condition) { }\nbool b = condition;\nreturn condition;\n```\n\n## readability-simplify-subscript-expr\n\nSimplify subscript expressions.\n\n```cpp\n// BAD\nstr.data()[0];\nvec.data()[i];\n\n// GOOD\nstr[0];\nvec[i];\n```\n\n## readability-static-accessed-through-instance\n\nAccess static members through class name.\n\n```cpp\n// BAD\nFoo foo;\nfoo.staticMethod();\nfoo.STATIC_CONSTANT;\n\n// GOOD\nFoo::staticMethod();\nFoo::STATIC_CONSTANT;\n```\n\n## readability-string-compare\n\nUse comparison operators for strings.\n\n```cpp\n// BAD\nif (str.compare(\"other\") == 0) { }\nif (str.compare(\"other\") != 0) { }\n\n// GOOD\nif (str == \"other\") { }\nif (str != \"other\") { }\n```\n\n## readability-suspicious-call-argument\n\nFinds likely argument swaps.\n\n```cpp\n// BAD\nvoid setRect(int x, int y, int width, int height);\nsetRect(width, height, x, y);  // suspicious - names suggest swap\n\n// GOOD\nsetRect(x, y, width, height);\n```\n\n## readability-uniqueptr-delete-release\n\nUse reset() instead of delete + release().\n\n```cpp\n// BAD\ndelete ptr.release();\n\n// GOOD\nptr.reset();\n```\n\n## readability-uppercase-literal-suffix\n\nUse uppercase literal suffixes.\n\n```cpp\n// BAD\nlong x = 42l;      // l looks like 1\nfloat f = 3.14f;   // inconsistent\nunsigned u = 42u;\n\n// GOOD\nlong x = 42L;\nfloat f = 3.14F;\nunsigned u = 42U;\nlong long ll = 42LL;\n```\n\n## readability-use-anyofallof\n\nUse std::any_of/all_of/none_of.\n\n```cpp\n// BAD\nbool found = false;\nfor (const auto& item : items) {\n    if (item.matches()) {\n        found = true;\n        break;\n    }\n}\n\n// GOOD\nbool found = std::any_of(items.begin(), items.end(),\n    [](const auto& item) { return item.matches(); });\n\n// C++20 ranges\nbool found = std::ranges::any_of(items, &Item::matches);\n```\n"}]}